#![feature
(
    tool_lints
)]

#![allow
(
    non_camel_case_types,
    unknown_lints,
    unused_imports,
    unused_macros,
)]
/**/
#[macro_use] extern crate lazy_static;
/**/
extern crate nix;
extern crate regex;
//#[macro_use] extern crate pest_derive;
//extern crate clap;
//extern crate errno;
//extern crate exec;
//extern crate glob;
//extern crate lineread;
//extern crate libc;
//extern crate pest;
//extern crate pest_derive;
//extern crate rusqlite;
//extern crate yaml_rust;
use ::lineread::{Command, Interface, ReadResult};


#[macro_use] mod macros
{
    use ::
    {
        *,
    };

    #[macro_export] macro_rules! log
    {
        ($fmt:expr) =>
        (
            let log_file = if let Ok(x) = std::env::var("CICADA_LOG_FILE") { x.clone() }
            else { String::new() };

            if !log_file.is_empty()
            {
                use std::io::Write as _;

                let msg = $fmt;
                match std::fs::OpenOptions::new().append(true).create(true).open(&log_file)
                {
                    Ok(mut cfile) =>
                    {
                        let pid = $crate::tlog::getpid();
                        let now = $crate::ctime::DateTime::now();
                        let msg = format!("[{}][{}] {}", now, pid, msg);
                        let msg = if msg.ends_with('\n') { msg } else { format!("{}\n", msg) };
                        match cfile.write_all(msg.as_bytes())
                        {
                            Ok(_) => {}
                            Err(_) => println!("tlog: write_all error")
                        }
                    }

                    Err(_) => println!("tlog: open file error"),
                }

            }
        );

        ($fmt:expr, $($arg:tt)*) =>
        (
            let msg = format!($fmt, $($arg)*);
            log!(&msg);
        );
    }

    #[macro_export] macro_rules! println_stderr
    {
        ($fmt:expr) =>
        (
            match writeln!(&mut ::std::io::stderr(), $fmt)
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );

        ($fmt:expr, $($arg:tt)*) =>
        (
            match writeln!(&mut ::std::io::stderr(), $fmt, $($arg)*)
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );
    }
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod boxed
{
    pub use std::boxed::{ * };
}

pub mod builtins
{
    use ::
    {
        *,
    };

    pub mod alias
    {
        use ::
        {
            *,
        };
        use regex::Regex;

        use crate::shell;
        use crate::tools;
        use crate::types::{Command, CommandLine, CommandResult};
        use crate::builtins::utils::print_stderr_with_capture;
        use crate::builtins::utils::print_stdout_with_capture;

        pub fn run(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();

            if tokens.len() == 1 {
                return show_alias_list(sh, cmd, cl, capture);
            }

            if tokens.len() > 2 {
                let info = "alias syntax error: usage: alias foo='echo foo'";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let input = &tokens[1].1;
            let re_single_read = Regex::new(r"^[a-zA-Z0-9_\.-]+$").unwrap();
            if re_single_read.is_match(input) {
                return show_single_alias(sh, input, cmd, cl, capture);
            }

            let re_to_add = Regex::new(r"^([a-zA-Z0-9_\.-]+)=(.*)$").unwrap();
            for cap in re_to_add.captures_iter(input) {
                let name = tools::unquote(&cap[1]);
                // due to limitation of `parses::parser_line`,
                // `alias foo-bar='foo bar'` will become 'foo-bar=foo bar'
                // while `alias foo_bar='foo bar'` keeps foo_bar='foo bar'
                let value = if cap[2].starts_with('"') || cap[2].starts_with('\'') {
                    tools::unquote(&cap[2])
                } else {
                    cap[2].to_string()
                };
                sh.add_alias(name.as_str(), value.as_str());
            }

            CommandResult::new()
        }

        fn show_alias_list(sh: &shell::Shell, cmd: &Command,
                        cl: &CommandLine, capture: bool) -> CommandResult {
            let mut lines = Vec::new();
            for (name, value) in sh.get_alias_list() {
                let line = format!("alias {}='{}'", name, value);
                lines.push(line);
            }
            let buffer = lines.join("\n");
            let mut cr = CommandResult::new();
            print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
            cr
        }

        fn show_single_alias(sh: &shell::Shell, name_to_find: &str, cmd: &Command,
                            cl: &CommandLine, capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            if let Some(content) = sh.get_alias_content(name_to_find) {
                let info = format!("alias {}='{}'", name_to_find, content);
                print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
            } else {
                let info = format!(":: alias: {}: not found", name_to_find);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            }
            cr
        }
    }

    pub mod bg
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::jobc;
        use crate::libc;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if sh.jobs.is_empty() {
                let info = ":: bg: no job found";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let mut job_id = -1;
            if tokens.len() == 1 {
                if let Some((gid, _)) = sh.jobs.iter().next() {
                    job_id = *gid;
                }
            }

            if tokens.len() >= 2 {
                let mut job_str = tokens[1].1.clone();
                if job_str.starts_with("%") {
                    job_str = job_str.trim_start_matches('%').to_string();
                }

                match job_str.parse::<i32>() {
                    Ok(n) => job_id = n,
                    Err(_) => {
                        let info = ":: bg: invalid job id";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }
            if job_id == -1 {
                let info = ":: bg: not such job";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let gid: i32;

            {
                let mut result = sh.get_job_by_id(job_id);
                // fall back to find job by using prcess group id
                if result.is_none() {
                    result = sh.get_job_by_gid(job_id);
                }

                match result {
                    Some(job) => {
                        unsafe {
                            libc::killpg(job.gid, libc::SIGCONT);
                            gid = job.gid;
                            if job.status == "Running" {
                                let info = format!(":: bg: job {} already in background", job.id);
                                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                                return cr;
                            }
                        }

                        let info_cmd = format!("[{}]  {} &", job.id, job.cmd);
                        print_stderr_with_capture(&info_cmd, &mut cr, cl, cmd, capture);
                        cr.status = 0;
                    }
                    None => {
                        let info = ":: bg: not such job";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            jobc::mark_job_as_running(sh, gid, true);
            cr
        }
    }

    pub mod cd
    {
        use ::
        {
            *,
        };
        use std::env;
        use std::path::Path;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::parsers;
        use crate::shell;
        use crate::tools;
        use crate::types::{Command, CommandLine, CommandResult};

        pub fn run(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();
            let args = parsers::parser_line::tokens_to_args(&tokens);

            if args.len() > 2 {
                let info = ":: cd: too many argument";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let str_current_dir = tools::get_current_dir();

            let mut dir_to = if args.len() == 1 {
                let home = tools::get_user_home();
                home.to_string()
            } else {
                args[1..].join("")
            };

            if dir_to == "-" {
                if sh.previous_dir.is_empty() {
                    let info = "no previous dir";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
                dir_to = sh.previous_dir.clone();
            } else if !dir_to.starts_with('/') {
                dir_to = format!("{}/{}", str_current_dir, dir_to);
            }

            if !Path::new(&dir_to).exists() {
                let info = format!(":: cd: {}: No such file or directory", &args[1]);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }

            match Path::new(&dir_to).canonicalize() {
                Ok(p) => {
                    dir_to = p.as_path().to_string_lossy().to_string();
                }
                Err(e) => {
                    let info = format!(":: cd: error: {}", e);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }

            match env::set_current_dir(&dir_to) {
                Ok(_) => {
                    sh.current_dir = dir_to.clone();
                    if str_current_dir != dir_to {
                        sh.previous_dir = str_current_dir.clone();
                        env::set_var("PWD", &sh.current_dir);
                    };
                    cr.status = 0;
                    cr
                }
                Err(e) => {
                    let info = format!(":: cd: {}", e);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    cr
                }
            }
        }
    }

    pub mod cinfo
    {
        use ::
        {
            *,
        };
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::history;
        use crate::libs;
        use crate::rcfile;
        use crate::shell::Shell;
        use crate::types::{Command, CommandLine, CommandResult};

        pub fn run(_sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult 
        {
            let mut info = vec![];
            const VERSION: &str = "25.5.5";
            info.push(("version", VERSION));

            let os_name = libs::os_type::get_os_name();
            info.push(("os-name", &os_name));

            let hfile = history::get_history_file();
            info.push(("history-file", &hfile));

            let rcf = rcfile::get_rc_file();
            info.push(("rc-file", &rcf));
            /*
            let git_hash = env!("GIT_HASH");
            if !git_hash.is_empty() {
                info.push(("git-commit", env!("GIT_HASH")));
            }

            let git_branch = env!("GIT_BRANCH");
            let mut branch = String::new();
            if !git_branch.is_empty() {
                branch.push_str(git_branch);
                let git_status = env!("GIT_STATUS");
                if git_status != "0" {
                    branch.push_str(" (dirty)");
                }
                info.push(("git-branch", &branch));
            } 

            info.push(("built-with", env!("BUILD_RUSTC_VERSION")));
            info.push(("built-at", env!("BUILD_DATE"))); */

            let mut lines = Vec::new();
            for (k, v) in &info {
                // longest key above is 12-char length
                lines.push(format!("{: >12}: {}", k, v));
            }
            let buffer = lines.join("\n");
            let mut cr = CommandResult::new();
            print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
            cr
        }
    }

    pub mod exec
    {
        use ::
        {
            *,
        };
        use exec;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::parsers;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(_sh: &Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();
            let args = parsers::parser_line::tokens_to_args(&tokens);
            let len = args.len();
            if len == 1 {
                print_stderr_with_capture("invalid usage", &mut cr, cl, cmd, capture);
                return cr;
            }

            let mut _cmd = exec::Command::new(&args[1]);
            let err = _cmd.args(&args[2..len]).exec();
            let info = format!(":: exec: {}", err);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            cr
        }
    }

    pub mod exit
    {
        use ::
        {
            *,
        };
        /*
        use std::process;
        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};
        */

        pub fn run(sh: &Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();
            if tokens.len() > 2 {
                let info = ":: exit: too many arguments";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            if tokens.len() == 2 {
                let _code = &tokens[1].1;
                match _code.parse::<i32>() {
                    Ok(x) => {
                        process::exit(x);
                    }
                    Err(_) => {
                        let info = format!(":: exit: {}: numeric argument required", _code);
                        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                        process::exit(255);
                    }
                }
            }

            for (_i, job) in sh.jobs.iter() {
                if !job.cmd.starts_with("nohup ") {
                    let mut info = String::new();
                    info.push_str("There are background jobs.");
                    info.push_str("Run `jobs` to see details; `exit 1` to force quit.");
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }

            process::exit(0);
            cr
        }
    }

    pub mod export
    {
        use ::
        {
            *,
        };
        use regex::Regex;
        use std::env;

        use crate::libs;
        use crate::parsers;
        use crate::tools;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(_sh: &Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();

            let re_name_ptn = Regex::new(r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$").unwrap();
            for (_, text) in tokens.iter() {
                if text == "export" {
                    continue;
                }

                if !tools::is_env(text) {
                    let mut info = String::new();
                    info.push_str("export: invalid command\n");
                    info.push_str("usage: export XXX=YYY");
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }

                if !re_name_ptn.is_match(text) {
                    let mut info = String::new();
                    info.push_str("export: invalid command\n");
                    info.push_str("usage: export XXX=YYY ZZ=123");
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }

                for cap in re_name_ptn.captures_iter(text) {
                    let name = cap[1].to_string();
                    let token = parsers::parser_line::unquote(&cap[2]);
                    let value = libs::path::expand_home(&token);
                    env::set_var(name, &value);
                }
            }
            cr
        }
    }

    pub mod fg
    {
        use ::
        {
            *,
        };
        use libc;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::jobc;
        use crate::shell::{self, Shell};
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if sh.jobs.is_empty() {
                let info = ":: fg: no job found";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let mut job_id = -1;
            if tokens.len() == 1 {
                if let Some((gid, _)) = sh.jobs.iter().next() {
                    job_id = *gid;
                }
            }

            if tokens.len() >= 2 {
                let mut job_str = tokens[1].1.clone();
                if job_str.starts_with("%") {
                    job_str = job_str.trim_start_matches('%').to_string();
                }

                match job_str.parse::<i32>() {
                    Ok(n) => job_id = n,
                    Err(_) => {
                        let info = ":: fg: invalid job id";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            if job_id == -1 {
                let info = ":: not job id found";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let gid: i32;
            let pid_list: Vec<i32>;

            {
                let mut result = sh.get_job_by_id(job_id);
                // fall back to find job by using prcess group id
                if result.is_none() {
                    result = sh.get_job_by_gid(job_id);
                }

                match result {
                    Some(job) => {
                        print_stderr_with_capture(&job.cmd, &mut cr, cl, cmd, capture);
                        cr.status = 0;

                        unsafe {
                            if !shell::give_terminal_to(job.gid) {
                                return CommandResult::error();
                            }

                            libc::killpg(job.gid, libc::SIGCONT);
                            pid_list = job.pids.clone();
                            gid = job.gid;
                        }
                    }
                    None => {
                        let info = ":: fg: no such job";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            unsafe {
                jobc::mark_job_as_running(sh, gid, false);

                let cr = jobc::wait_fg_job(sh, gid, &pid_list);

                let gid_shell = libc::getpgid(0);
                if !shell::give_terminal_to(gid_shell) {
                    log!("failed to give term to back to shell : {}", gid_shell);
                }

                cr
            }
        }
    }

    pub mod history
    {
        use ::
        {
            *,
        };

        use std::path::Path;

        use rusqlite::Connection as Conn;
        use structopt::StructOpt;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::ctime;
        use crate::history;
        use crate::parsers;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        #[derive(Debug, StructOpt)]
        #[structopt(name = "history", about = "History in cicada shell")]
        struct OptMain {
            #[structopt(short, long, help = "For current session only")]
            session: bool,

            #[structopt(short, long, help = "Search old items first")]
            asc: bool,

            #[structopt(short, long, help = "For current directory only")]
            pwd: bool,

            #[structopt(short, long, help = "Only show ROWID")]
            only_id: bool,

            #[structopt(short, long, help = "Do not show ROWID")]
            no_id: bool,

            #[structopt(short="d", long, help = "Show date")]
            show_date: bool,

            #[structopt(short, long, default_value = "20")]
            limit: i32,

            #[structopt(name = "PATTERN", default_value = "", help = "You can use % to match anything")]
            pattern: String,

            #[structopt(subcommand)]
            cmd: Option<SubCommand>
        }

        #[derive(StructOpt, Debug)]
        enum SubCommand {
            #[structopt(about="Add new item into history")]
            Add {
                #[structopt(short="t", long, help = "Specify a timestamp for the new item")]
                timestamp: Option<f64>,

                #[structopt(name="INPUT", help = "input to be added into history")]
                input: String,
            },
            #[structopt(about="Delete item from history")]
            Delete {
                #[structopt(name="ROWID", help = "Row IDs of item to delete")]
                rowid: Vec<usize>,
            }
        }

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let hfile = history::get_history_file();
            let path = Path::new(hfile.as_str());
            if !path.exists() {
                let info = "no history file";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }
            let conn = match Conn::open(&hfile) {
                Ok(x) => x,
                Err(e) => {
                    let info = format!("history: sqlite error: {:?}", e);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            };

            let tokens = cmd.tokens.clone();
            let args = parsers::parser_line::tokens_to_args(&tokens);

            let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");
            let opt = OptMain::from_iter_safe(args);
            match opt {
                Ok(opt) => {
                    match opt.cmd {
                        Some(SubCommand::Delete {rowid: rowids}) => {
                            let mut _count = 0;
                            for rowid in rowids {
                                let _deleted = delete_history_item(&conn, rowid);
                                if _deleted {
                                    _count += 1;
                                }
                            }
                            if _count > 0 {
                                let info = format!("deleted {} items", _count);
                                print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                            }
                            cr
                        }
                        Some(SubCommand::Add {timestamp: ts, input}) => {
                            let ts = ts.unwrap_or(0 as f64);
                            add_history(sh, ts, &input);
                            cr
                        }
                        None => {
                            let (str_out, str_err) = list_current_history(sh, &conn, &opt);
                            if !str_out.is_empty() {
                                print_stdout_with_capture(&str_out, &mut cr, cl, cmd, capture);
                            }
                            if !str_err.is_empty() {
                                print_stderr_with_capture(&str_err, &mut cr, cl, cmd, capture);
                            }
                            cr
                        }
                    }
                }
                Err(e) => {
                    let info = format!("{}", e);
                    if show_usage {
                        print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                        cr.status = 0;
                    } else {
                        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                        cr.status = 1;
                    }
                    cr
                }
            }
        }

        fn add_history(sh: &Shell, ts: f64, input: &str) {
            let (tsb, tse) = (ts, ts + 1.0);
            history::add_raw(sh, input, 0, tsb, tse);
        }

        fn list_current_history(sh: &Shell, conn: &Conn,
                                opt: &OptMain) -> (String, String) {
            let mut result_stderr = String::new();
            let result_stdout = String::new();

            let history_table = history::get_history_table();
            let mut sql = format!("SELECT ROWID, inp, tsb FROM {} WHERE ROWID > 0",
                                history_table);
            if !opt.pattern.is_empty() {
                sql = format!("{} AND inp LIKE '%{}%'", sql, opt.pattern)
            }
            if opt.session {
                sql = format!("{} AND sessionid = '{}'", sql, sh.session_id)
            }
            if opt.pwd {
                sql = format!("{} AND info like '%dir:{}|%'", sql, sh.current_dir)
            }

            if opt.asc {
                sql = format!("{} ORDER BY tsb", sql);
            } else {
                sql = format!("{} order by tsb desc", sql);
            };
            sql = format!("{} limit {} ", sql, opt.limit);

            let mut stmt = match conn.prepare(&sql) {
                Ok(x) => x,
                Err(e) => {
                    let info = format!("history: prepare select error: {:?}", e);
                    result_stderr.push_str(&info);
                    return (result_stdout, result_stderr);
                }
            };

            let mut rows = match stmt.query([]) {
                Ok(x) => x,
                Err(e) => {
                    let info = format!("history: query error: {:?}", e);
                    result_stderr.push_str(&info);
                    return (result_stdout, result_stderr);
                }
            };

            let mut lines = Vec::new();
            loop {
                match rows.next() {
                    Ok(_rows) => {
                        if let Some(row) = _rows {
                            let row_id: i32 = match row.get(0) {
                                Ok(x) => x,
                                Err(e) => {
                                    let info = format!("history: error: {:?}", e);
                                    result_stderr.push_str(&info);
                                    return (result_stdout, result_stderr);
                                }
                            };
                            let inp: String = match row.get(1) {
                                Ok(x) => x,
                                Err(e) => {
                                    let info = format!("history: error: {:?}", e);
                                    result_stderr.push_str(&info);
                                    return (result_stdout, result_stderr);
                                }
                            };

                            if opt.no_id {
                                lines.push(inp.to_string());
                            } else if opt.only_id {
                                lines.push(row_id.to_string());
                            } else if opt.show_date {
                                let tsb: f64 = match row.get(2) {
                                    Ok(x) => x,
                                    Err(e) => {
                                        let info = format!("history: error: {:?}", e);
                                        result_stderr.push_str(&info);
                                        return (result_stdout, result_stderr);
                                    }
                                };
                                let dt = ctime::DateTime::from_timestamp(tsb);
                                lines.push(format!("{}: {}: {}", row_id, dt, inp));
                            } else {
                                lines.push(format!("{}: {}", row_id, inp));
                            }
                        } else {
                            break;
                        }
                    }
                    Err(e) => {
                        let info = format!("history: rows next error: {:?}", e);
                        result_stderr.push_str(&info);
                        return (result_stdout, result_stderr);
                    }
                }
            }

            if !opt.asc {
                lines.reverse();
            }

            let buffer = lines.join("\n");

            (buffer, result_stderr)
        }

        fn delete_history_item(conn: &Conn, rowid: usize) -> bool {
            let history_table = history::get_history_table();
            let sql = format!("DELETE from {} where rowid = {}", history_table, rowid);
            match conn.execute(&sql, []) {
                Ok(_) => true,
                Err(e) => {
                    log!("history: error when delete: {:?}", e);
                    false
                }
            }
        }
    }

    pub mod jobs
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stdout_with_capture;
        use crate::jobc;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            if sh.jobs.is_empty() {
                return cr;
            }

            // update status of jobs if any
            jobc::try_wait_bg_jobs(sh, false, false);

            let mut lines = Vec::new();
            let jobs = sh.jobs.clone();
            let no_trim = cmd.tokens.len() >= 2 && cmd.tokens[1].1 == "-f";
            for (_i, job) in jobs.iter() {
                let line = jobc::get_job_line(job, !no_trim);
                lines.push(line);
            }
            let buffer = lines.join("\n");

            print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
            cr
        }
    }

    pub mod read
    {
        use ::
        {
            *,
        };

        use std::io;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::libs::re::re_contains;
        use crate::types::{CommandResult, CommandLine, Command};
        use crate::tools;

        fn _find_invalid_identifier(name_list: &Vec<String>) -> Option<String> {
            for id_ in name_list {
                if !re_contains(id_, r"^[a-zA-Z_][a-zA-Z0-9_]*$") {
                    return Some(id_.to_string());
                }
            }
            None
        }

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();

            let name_list: Vec<String>;
            if tokens.len() <= 1 {
                name_list = vec!["REPLY".to_string()];
            } else {
                name_list = tokens[1..].iter().map(|x| x.1.clone()).collect();
                if let Some(id_) = _find_invalid_identifier(&name_list) {
                    let info = format!(":: read: `{}': not a valid identifier", id_);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }

            let mut buffer = String::new();

            if cmd.has_here_string() {
                if let Some(redirect_from) = &cmd.redirect_from {
                    buffer.push_str(&redirect_from.1);
                    buffer.push('\n');
                }
            } else {
                match io::stdin().read_line(&mut buffer) {
                    Ok(_) => {}
                    Err(e) => {
                        let info = format!(":: read: error in reading stdin: {:?}", e);
                        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            let envs = cl.envs.clone();
            let value_list = tools::split_into_fields(sh, buffer.trim(), &envs);

            let idx_2rd_last = name_list.len() - 1;
            for i in 0..idx_2rd_last {
                let name = name_list.get(i);
                if name.is_none() {
                    let info = ":: read: name index error";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
                let name = name.unwrap();

                let value = value_list.get(i).unwrap_or(&String::new()).clone();
                sh.set_env(name, &value);
            }

            let name_last = &name_list[idx_2rd_last];
            let value_left: String = if value_list.len() > idx_2rd_last {
                value_list[idx_2rd_last..].join(" ")
            } else {
                String::new()
            };
            sh.set_env(name_last, &value_left);
            cr
        }
    }

    pub mod source
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::parsers;
        use crate::scripting;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = &cmd.tokens;
            let args = parsers::parser_line::tokens_to_args(tokens);

            if args.len() < 2 {
                let info = ":: source: no file specified";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let status = scripting::run_script(sh, &args);
            cr.status = status;
            cr
        }
    }

    pub mod unalias
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if tokens.len() != 2 {
                let info = ":: unalias: syntax error";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let input = &tokens[1].1;
            if !sh.remove_alias(input) {
                let info = format!(":: unalias: {}: not found", input);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
            cr
        }
    }

    pub mod vox
    {
        use ::
        {
            *,
        };

        use std::env;
        use std::fs;
        use std::path::Path;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::execute;
        use crate::parsers;
        use crate::shell::{self, Shell};
        use crate::types::{self, CommandResult, CommandLine, Command};

        fn in_env() -> bool {
            env::var("VIRTUAL_ENV").map_or(false, |x| !x.is_empty())
        }

        fn get_envs_home() -> String {
            env::var("VIRTUALENV_HOME").unwrap_or_default()
        }

        fn get_all_venvs() -> Result<Vec<String>, String> {
            let home_envs = get_envs_home();
            if home_envs.is_empty() {
                let info = String::from("you need to set VIRTUALENV_HOME to use vox");
                return Err(info);
            }
            if !Path::new(home_envs.as_str()).exists() {
                match fs::create_dir_all(home_envs.as_str()) {
                    Ok(_) => {}
                    Err(e) => {
                        let info = format!("fs create_dir_all failed: {:?}", e);
                        return Err(info);
                    }
                }
            }

            let mut venvs = Vec::new();
            let pdir = home_envs.clone();
            if let Ok(list) = fs::read_dir(home_envs) {
                for ent in list.flatten() {
                    let ent_name = ent.file_name();
                    if let Ok(path) = ent_name.into_string() {
                        let full_path = format!("{}/{}/bin/activate", pdir, path);
                        if !Path::new(full_path.as_str()).exists() {
                            continue;
                        }
                        venvs.push(path);
                    }
                }
            }

            Ok(venvs)
        }

        fn enter_env(sh: &Shell, path: &str) -> String {
            if in_env() {
                return "vox: already in env".to_string();
            }

            let home_envs = get_envs_home();
            let full_path = format!("{}/{}/bin/activate", home_envs, path);
            if !Path::new(full_path.as_str()).exists() {
                return format!("no such env: {}", full_path);
            }

            let path_env = format!("{}/{}", home_envs, path);
            env::set_var("VIRTUAL_ENV", &path_env);
            let path_new = String::from("${VIRTUAL_ENV}/bin:$PATH");
            let mut tokens: types::Tokens = Vec::new();
            tokens.push((String::new(), path_new));
            shell::expand_env(sh, &mut tokens);
            env::set_var("PATH", &tokens[0].1);
            String::new()
        }

        fn exit_env(sh: &Shell) -> String {
            if !in_env() {
                return String::from("vox: not in an env");
            }

            let env_path = match env::var("PATH") {
                Ok(x) => x,
                Err(_) => {
                    return String::from("vox: cannot read PATH env");
                }
            };

            let mut _tokens: Vec<&str> = env_path.split(':').collect();
            let mut path_virtual_env = String::from("${VIRTUAL_ENV}/bin");
            // shell::extend_env(sh, &mut path_virtual_env);
            let mut tokens: types::Tokens = Vec::new();
            tokens.push((String::new(), path_virtual_env));
            shell::expand_env(sh, &mut tokens);
            path_virtual_env = tokens[0].1.clone();
            _tokens
                .iter()
                .position(|&n| n == path_virtual_env)
                .map(|e| _tokens.remove(e));
            let env_path_new = _tokens.join(":");
            env::set_var("PATH", &env_path_new);
            env::set_var("VIRTUAL_ENV", "");

            String::new()
        }

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();
            let args = parsers::parser_line::tokens_to_args(&tokens);
            let len = args.len();
            let subcmd = if len > 1 { &args[1] } else { "" };

            if len == 1 || (len == 2 && subcmd == "ls") {
                match get_all_venvs() {
                    Ok(venvs) => {
                        let info = venvs.join("\n");
                        print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                    Err(reason) => {
                        print_stderr_with_capture(&reason, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            if len == 3 && subcmd == "create" {
                let pybin = match env::var("VIRTUALENV_PYBIN") {
                    Ok(x) => x,
                    Err(_) => "python3".to_string(),
                };
                let dir_venv = get_envs_home();
                let venv_name = args[2].to_string();
                let line = format!("{} -m venv \"{}/{}\"", pybin, dir_venv, venv_name);
                print_stderr_with_capture(&line, &mut cr, cl, cmd, capture);
                let cr_list = execute::run_command_line(sh, &line, false, false);
                return cr_list[0].clone();
            }

            if len == 3 && subcmd == "enter" {
                let _err = enter_env(sh, args[2].as_str());
                if !_err.is_empty() {
                    print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
                }
                cr
            } else if len == 2 && subcmd == "exit" {
                let _err = exit_env(sh);
                if !_err.is_empty() {
                    print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
                }
                cr
            } else {
                let info = ":: vox: invalid option";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                cr
            }
        }
    }

    pub mod minfd
    {
        use ::
        {
            *,
        };

        use std::io::Write;

        use crate::shell::Shell;
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(_sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();

            let fd = nix::fcntl::open(
                "/dev/null",
                nix::fcntl::OFlag::empty(),
                nix::sys::stat::Mode::empty()
            );
            match fd {
                Ok(fd) => {
                    let info = format!("{}", fd);
                    print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                    unsafe { libc::close(fd); }
                }
                Err(e) => {
                    println_stderr!(":: minfd: error: {}", e);
                }
            }

            cr
        }
    }

    pub mod set
    {
        use ::
        {
            *,
        };

        use structopt::StructOpt;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::parsers;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        #[derive(Debug, StructOpt)]
        #[structopt(name = "set", about = "Set shell options (BETA)")]
        struct OptMain {
            #[structopt(short, help = "exit on error status")]
            exit_on_error: bool,
        }

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = &cmd.tokens;
            let args = parsers::parser_line::tokens_to_args(tokens);
            let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");

            let opt = OptMain::from_iter_safe(args);
            match opt {
                Ok(opt) => {
                    if opt.exit_on_error {
                        sh.exit_on_error = true;
                        cr
                    } else {
                        let info = ":: set: option not implemented";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        cr
                    }
                }
                Err(e) => {
                    let info = format!("{}", e);
                    if show_usage {
                        print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                        cr.status = 0;
                    } else {
                        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                        cr.status = 1;
                    }
                    cr
                }
            }
        }
    }

    pub mod unpath
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if tokens.len() != 2 {
                let info = ":: unpath: syntax error";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let input = &tokens[1].1;
            sh.remove_path(input);
            cr
        }
    }

    pub mod unset
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if tokens.len() != 2 {
                let info = ":: unset: syntax error";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let input = &tokens[1].1;
            if !sh.remove_env(input) {
                let info = format!(":: unset: invalid varname: {:?}", input);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
            cr
        }
    }

    pub mod utils
    {
        use ::
        {
            *,
        };

        use std::fs::File;
        use std::io::Write;
        use std::os::unix::io::{FromRawFd, RawFd};

        use errno::errno;

        use crate::tools;
        use crate::types::{Command, CommandLine, CommandResult, Redirection};

        /// Helper function to get (stdout, stderr) pairs for redirections,
        /// e.g. `alias foo 1>/dev/null 2>&1 > foo.txt`
        /// (i.e. [
        ///      ("1", ">", "/dev/null"),
        ///      ("2", ">", "&1"),
        ///      ("1", ">", "foo.txt"),
        ///  ])
        fn _get_std_fds(redirects: &[Redirection]) -> (Option<RawFd>, Option<RawFd>) {
            if redirects.is_empty() {
                return (None, None);
            }

            let mut fd_out = None;
            let mut fd_err = None;

            for i in 0..redirects.len() {
                let item = &redirects[i];
                if item.0 == "1" {
                    // 1>&2
                    let mut _fd_candidate = None;

                    if item.2 == "&2" {
                        let (_fd_out, _fd_err) = _get_std_fds(&redirects[i+1..]);
                        if let Some(fd) = _fd_err {
                            _fd_candidate = Some(fd);
                        } else {
                            _fd_candidate = unsafe { Some(libc::dup(2)) };
                        }
                    } else {  // 1> foo.log
                        let append = item.1 == ">>";
                        if let Ok(fd) = tools::create_raw_fd_from_file(&item.2, append) {
                            _fd_candidate = Some(fd);
                        }
                    }

                    // for command like this: `alias > a.txt > b.txt > c.txt`,
                    // we need to return the last one, but close the previous two.
                    if let Some(fd) = fd_out {
                        unsafe { libc::close(fd); }
                    }

                    fd_out = _fd_candidate;
                }

                if item.0 == "2" {
                    // 2>&1
                    let mut _fd_candidate = None;

                    if item.2 == "&1" {
                        if let Some(fd) = fd_out {
                            _fd_candidate = unsafe { Some(libc::dup(fd)) };
                        }
                    } else {  // 2>foo.log
                        let append = item.1 == ">>";
                        if let Ok(fd) = tools::create_raw_fd_from_file(&item.2, append) {
                            _fd_candidate = Some(fd);
                        }
                    }

                    if let Some(fd) = fd_err {
                        unsafe { libc::close(fd); }
                    }

                    fd_err = _fd_candidate;
                }
            }

            (fd_out, fd_err)
        }

        fn _get_dupped_stdout_fd(cmd: &Command, cl: &CommandLine) -> RawFd {
            // if with pipeline, e.g. `history | grep foo`, then we don't need to
            // dup stdout since it is running in a sperated process, whose fd can
            // be dropped after use.
            if cl.with_pipeline() {
                return 1;
            }

            let (_fd_out, _fd_err) = _get_std_fds(&cmd.redirects_to);
            if let Some(fd) = _fd_err {
                unsafe { libc::close(fd); }
            }
            if let Some(fd) = _fd_out {
                fd
            } else {
                let fd = unsafe { libc::dup(1) };
                if fd == -1 {
                    let eno = errno();
                    println_stderr!(":: dup: {}", eno);
                }
                fd
            }
        }

        fn _get_dupped_stderr_fd(cmd: &Command, cl: &CommandLine) -> RawFd {
            if cl.with_pipeline() {
                return 2;
            }

            let (_fd_out, _fd_err) = _get_std_fds(&cmd.redirects_to);
            if let Some(fd) = _fd_out {
                unsafe { libc::close(fd); }
            }

            if let Some(fd) = _fd_err {
                fd
            } else {
                let fd = unsafe { libc::dup(2) };
                if fd == -1 {
                    let eno = errno();
                    println_stderr!(":: dup: {}", eno);
                }
                fd
            }
        }

        pub fn print_stdout(info: &str, cmd: &Command, cl: &CommandLine) {
            let fd = _get_dupped_stdout_fd(cmd, cl);
            if fd == -1 {
                return;
            }

            unsafe {
                let mut f = File::from_raw_fd(fd);
                let info = info.trim_end_matches('\n');
                match f.write_all(info.as_bytes()) {
                    Ok(_) => {},
                    Err(e) => {
                        println_stderr!("write_all: error: {}", e);
                    }
                }
                if !info.is_empty() {
                    match f.write_all(b"\n") {
                        Ok(_) => {},
                        Err(e) => {
                            println_stderr!("write_all: error: {}", e);
                        }
                    }
                }
            }
        }

        pub fn print_stderr(info: &str, cmd: &Command, cl: &CommandLine) {
            let fd = _get_dupped_stderr_fd(cmd, cl);
            if fd == -1 {
                return;
            }

            unsafe {
                let mut f = File::from_raw_fd(fd);
                let info = info.trim_end_matches('\n');
                match f.write_all(info.as_bytes()) {
                    Ok(_) => (),
                    Err(e) => {
                        println_stderr!("write_all: error: {}", e);
                    }
                }

                if !info.is_empty() {
                    match f.write_all(b"\n") {
                        Ok(_) => (),
                        Err(e) => {
                            println_stderr!("write_all: error: {}", e);
                        }
                    }
                }
            }
        }

        pub fn print_stderr_with_capture(info: &str, cr: &mut CommandResult,
                                        cl: &CommandLine, cmd: &Command,
                                        capture: bool) {
            cr.status = 1;
            if capture {
                cr.stderr = info.to_string();
            } else {
                print_stderr(info, cmd, cl);
            }
        }

        pub fn print_stdout_with_capture(info: &str, cr: &mut CommandResult,
                                        cl: &CommandLine, cmd: &Command,
                                        capture: bool) {
            cr.status = 0;
            if capture {
                cr.stdout = info.to_string();
            } else {
                print_stdout(info, cmd, cl);
            }
        }
    }
}

pub mod calculator
{
    use ::
    {
        num::{ Wrapping as W },
        pest::
        {
            iterators::{ Pair, Pairs },
            pratt_parser::{ Assoc, Op, PrattParser },
            Parser,
        },
        *,
    };

    /*
    num = @{ int ~ ("." ~ ASCII_DIGIT*)? ~ (^"e" ~ int)? }
    int = { ("+" | "-")? ~ ASCII_DIGIT+ }

    operation = _{ add | subtract | multiply | divide | power }
    add      = { "+" }
    subtract = { "-" }
    multiply = { "*" }
    divide   = { "/" }
    power    = { "^" }

    expr = { term ~ (operation ~ term)* }
    term = _{ num | "(" ~ expr ~ ")" }

    calculation = _{ SOI ~ expr ~ EOI }

    WHITESPACE = _{ " " | "\t" }
    #[grammar = "calculator/grammar.pest"] 
    #[derive(Parser)]
    struct Calculator;

    lazy_static!
    {
        static ref PRATT_PARSER: PrattParser<Rule> = {
            use Rule::*;
            use Assoc::*;

            PrattParser::new()
                .op(Op::infix(add, Left) | Op::infix(subtract, Left))
                .op(Op::infix(multiply, Left) | Op::infix(divide, Left))
                .op(Op::infix(power, Right))
        };
    }

    pub fn eval_int(expression: Pairs<Rule>) -> i64 {
        PRATT_PARSER
            .map_primary(|primary| match primary.as_rule() {
                Rule::num => primary.as_str().parse::<i64>().unwrap(),
                Rule::expr => eval_int(primary.into_inner()),
                _ => unreachable!(),
            })
            .map_infix(|lhs: i64, op: Pair<Rule>, rhs: i64| match op.as_rule() {
                Rule::add => (W(lhs) + W(rhs)).0,
                Rule::subtract => (W(lhs) - W(rhs)).0,
                Rule::multiply => (W(lhs) * W(rhs)).0,
                Rule::divide => {
                    if rhs == 0 {
                        (lhs as f64 / 0.0) as i64
                    } else {
                        (W(lhs) / W(rhs)).0
                    }
                }
                Rule::power => lhs.pow(rhs as u32),
                _ => unreachable!(),
            })
            .parse(expression)
    }

    pub fn eval_float(expression: Pairs<Rule>) -> f64 {
        PRATT_PARSER
            .map_primary(|primary| match primary.as_rule() {
                Rule::num => primary.as_str().parse::<f64>().unwrap(),
                Rule::expr => eval_float(primary.into_inner()),
                _ => unreachable!(),
            })
            .map_infix(|lhs, op, rhs| match op.as_rule() {
                Rule::add => lhs + rhs,
                Rule::subtract => lhs - rhs,
                Rule::multiply => lhs * rhs,
                Rule::divide => lhs / rhs,
                Rule::power => lhs.powf(rhs),
                _ => unreachable!(),
            })
            .parse(expression)
    }

    pub fn calculate(line: &str) -> Result<pest::iterators::Pairs<'_, Rule>, pest::error::Error<Rule>> {
        Calculator::parse(Rule::calculation, line)
    }
    */
}

pub mod cell
{
    pub use std::cell::{ * };
}

pub mod cmp
{
    pub use std::cmp::{ * };
}

pub mod collections
{
    pub use std::collections::{ * };
}

pub mod completers
{
    use ::
    {
        *,
    };

    use std::path::Path;
    use std::sync::Arc;

    use lineread::complete::{Completer, Completion};
    use lineread::prompter::Prompter;
    use lineread::terminal::Terminal;

    pub mod dots
    {
        use ::
        {
            *,
        };

        use std::borrow::Cow;
        use std::fs::File;
        use std::io::{Read, Write};
        use std::path::Path;

        use lineread::complete::escape;
        use lineread::complete::escaped_word_start;
        use lineread::complete::unescape;
        use lineread::complete::Suffix;
        use lineread::complete::{Completer, Completion};
        use lineread::prompter::Prompter;
        use lineread::terminal::Terminal;
        use yaml_rust::{Yaml, YamlLoader};
        use yaml_rust::yaml::Hash;

        use crate::execute;
        use crate::parsers;
        use crate::tools;

        /// Performs completion by searching dotfiles
        pub struct DotsCompleter;

        impl<Term: Terminal> Completer<Term> for DotsCompleter {
            fn complete(
                &self,
                word: &str,
                reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                let line = reader.buffer();
                Some(complete_dots(line, word))
            }

            fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
                escaped_word_start(&line[..end])
            }

            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                escape(word)
            }

            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                unescape(word)
            }
        }

        fn get_dot_file(line: &str) -> (String, String) {
            let args = parsers::parser_line::line_to_plain_tokens(line);
            let dir = tools::get_user_completer_dir();
            let dot_file = format!("{}/{}.yaml", dir, args[0]);
            if !Path::new(&dot_file).exists() {
                return (String::new(), String::new());
            }
            let sub_cmd = if (args.len() >= 3 && !args[1].starts_with('-'))
                || (args.len() >= 2 && !args[1].starts_with('-') && line.ends_with(' '))
            {
                args[1].as_str()
            } else {
                ""
            };

            (dot_file, sub_cmd.to_string())
        }

        fn handle_lv1_string(res: &mut Vec<Completion>,
                            value: &str, word: &str) {
            if !value.starts_with(word) && !value.starts_with('`') {
                return;
            }

            let linfo = parsers::parser_line::parse_line(value);
            let tokens = linfo.tokens;
            if tokens.len() == 1 && tokens[0].0 == "`" {
                log!("run subcmd: {:?}", &tokens[0].1);
                let cr = execute::run(&tokens[0].1);
                let v: Vec<&str> = cr.stdout.split(|c| c == '\n' || c == ' ').collect();
                for s in v {
                    if s.trim().is_empty() {
                        continue;
                    }
                    handle_lv1_string(res, s, word);
                }
                return;
            }

            let display = None;
            let suffix = Suffix::Default;
            res.push(Completion {
                completion: value.to_string(),
                display,
                suffix,
            });
        }

        fn handle_lv1_hash(res: &mut Vec<Completion>,
                        h: &Hash, word: &str) {
            for v in h.values() {
                if let Yaml::Array(ref arr) = v {
                    for s in arr {
                        if let Yaml::String(value) = s {
                            if !value.starts_with(word) && !value.starts_with('`') {
                                continue;
                            }
                            handle_lv1_string(res, value, word);
                        }
                    }
                }
            }
        }

        fn complete_dots(line: &str, word: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            if line.trim().is_empty() {
                return res;
            }
            let (dot_file, sub_cmd) = get_dot_file(line);
            if dot_file.is_empty() {
                return res;
            }

            let mut f;
            match File::open(&dot_file) {
                Ok(x) => f = x,
                Err(e) => {
                    println_stderr!("\n:: open dot_file error: {:?}", e);
                    return res;
                }
            }

            let mut s = String::new();
            match f.read_to_string(&mut s) {
                Ok(_) => {}
                Err(e) => {
                    println_stderr!("\n:: read_to_string error: {:?}", e);
                    return res;
                }
            }

            let docs = match YamlLoader::load_from_str(&s) {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("\n:: Bad Yaml file: {}: {:?}", dot_file, e);
                    return res;
                }
            };

            for doc in docs.iter() {
                match *doc {
                    Yaml::Array(ref v) => {
                        for x in v {
                            match *x {
                                Yaml::String(ref name) => {
                                    if !sub_cmd.is_empty() {
                                        continue;
                                    }
                                    handle_lv1_string(&mut res, name, word);
                                }
                                Yaml::Hash(ref h) => {
                                    if sub_cmd.is_empty() {
                                        for k in h.keys() {
                                            if let Yaml::String(value) = k {
                                                handle_lv1_string(&mut res, value, word);
                                            }
                                        }
                                    } else {
                                        let key = Yaml::from_str(&sub_cmd);
                                        if !h.contains_key(&key) {
                                            continue;
                                        }
                                        handle_lv1_hash(&mut res, h, word);
                                    }
                                }
                                _ => {
                                    println_stderr!("\nThis yaml file is in bad format: {}", dot_file);
                                }
                            }
                        }
                    }
                    _ => {
                        println_stderr!("\nThis yaml file is in bad format: {}", dot_file);
                    }
                }
            }
            res
        }
    }

    pub mod env
    {
        use ::
        {
            *,
        };

        use std::env;
        use std::sync::Arc;

        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::prompter::Prompter;
        use lineread::terminal::Terminal;

        use crate::shell;

        pub struct EnvCompleter {
            pub sh: Arc<shell::Shell>,
        }

        impl<Term: Terminal> Completer<Term> for EnvCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                let sh = Arc::try_unwrap(self.sh.clone());
                match sh {
                    Ok(x) => Some(complete_env(&x, word)),
                    Err(x) => Some(complete_env(&x, word)),
                }
            }
        }

        fn complete_env(sh: &shell::Shell, path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            if path.trim().is_empty() {
                return res;
            }
            let mut prefix = path.to_string();
            prefix.remove(0);

            for (key, _) in env::vars_os() {
                let env_name = key.to_string_lossy().to_string();
                if env_name.starts_with(&prefix) {
                    res.push(Completion {
                        completion: format!("${}", env_name),
                        display: None,
                        suffix: Suffix::Default,
                    });
                }
            }

            // sh.envs is a just clone here; see FIXME in main.rs
            for key in sh.envs.keys() {
                if key.starts_with(&prefix) {
                    res.push(Completion {
                        completion: format!("${}", key),
                        display: None,
                        suffix: Suffix::Default,
                    });
                }
            }

            res
        }
    }

    pub mod make
    {
        use ::
        {
            *,
        };
        use std::env;
        use std::fs::File;
        use std::io::{BufRead, BufReader, Write};

        use regex::Regex;

        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::prompter::Prompter;
        use lineread::terminal::Terminal;

        pub struct MakeCompleter;

        impl<Term: Terminal> Completer<Term> for MakeCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_make(word))
            }
        }

        fn handle_file(ci: &mut Vec<Completion>, path: &str, file_path: &str, current_dir: &str) {
            if let Ok(f) = File::open(file_path) {
                let file = BufReader::new(&f);
                let re_cmd = match Regex::new(r"^ *([^ ]+):") {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!(":: regex build error: {:?}", e);
                        return;
                    }
                };

                let re_include = match Regex::new(r"^ *include  *([^ ]+) *$") {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!(":: regex build error: {:?}", e);
                        return;
                    }
                };

                for line in file.lines().map_while(Result::ok) {
                    if re_cmd.is_match(&line) {
                        for cap in re_cmd.captures_iter(&line) {
                            if !cap[1].starts_with(path) {
                                continue;
                            }
                            ci.push(Completion {
                                completion: cap[1].to_string(),
                                display: None,
                                suffix: Suffix::Default,
                            });
                        }
                    }
                    if re_include.is_match(&line) {
                        for cap in re_include.captures_iter(&line) {
                            let _file = &cap[1];
                            if _file.contains('/') {
                                handle_file(ci, path, _file, current_dir);
                            } else {
                                let make_file = current_dir.to_owned() + "/" + _file;
                                handle_file(ci, path, &make_file, current_dir);
                            }
                        }
                    }
                }
            }
        }

        fn complete_make(path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            let current_dir = match env::current_dir() {
                Ok(dir) => match dir.to_str() {
                    Some(s) => s.to_string(),
                    None => {
                        println!(":: to_str error");
                        return res;
                    }
                },
                Err(e) => {
                    println!(":: get current_dir error: {:?}", e);
                    return res;
                }
            };

            let make_file = format!("{}/Makefile", current_dir);
            handle_file(&mut res, path, &make_file, &current_dir);
            res
        }
    }

    pub mod path
    {
        use ::
        {
            *,
        };

        use std::collections::HashSet;
        use std::env;
        use std::fs::read_dir;
        use std::io::Write;
        use std::iter::FromIterator;
        use std::os::unix::fs::PermissionsExt;
        use std::path::MAIN_SEPARATOR;
        use std::sync::Arc;

        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::terminal::Terminal;
        use lineread::Prompter;

        use crate::completers::utils;
        use crate::libs;
        use crate::parsers;
        use crate::shell;
        use crate::tools;

        pub struct BinCompleter {
            pub sh: Arc<shell::Shell>,
        }
        pub struct CdCompleter;
        pub struct PathCompleter;

        fn is_env_prefix(line: &str) -> bool {
            libs::re::re_contains(line, r" *\$[a-zA-Z_][A-Za-z0-9_]*")
        }

        fn is_pipelined(path: &str) -> bool {
            if !path.contains('|') {
                return false;
            }
            !path.starts_with('"') && !path.starts_with('\'')
        }

        impl<Term: Terminal> Completer<Term> for BinCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                let sh = Arc::try_unwrap(self.sh.clone());
                match sh {
                    Ok(x) => Some(complete_bin(&x, word)),
                    Err(x) => Some(complete_bin(&x, word)),
                }
            }
        }

        impl<Term: Terminal> Completer<Term> for PathCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_path(word, false))
            }
        }

        impl<Term: Terminal> Completer<Term> for CdCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_path(word, true))
            }
        }

        fn needs_expand_home(line: &str) -> bool {
            libs::re::re_contains(line, r"( +~ +)|( +~/)|(^ *~/)|( +~ *$)")
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path(word: &str, for_dir: bool) -> Vec<Completion> {
            let is_env = is_env_prefix(word);
            let mut res = Vec::new();
            let linfo = parsers::parser_line::parse_line(word);
            let tokens = linfo.tokens;
            let (path, path_sep) = if tokens.is_empty() {
                (String::new(), String::new())
            } else {
                let (ref _path_sep, ref _path) = tokens[tokens.len() - 1];
                (_path.clone(), _path_sep.clone())
            };

            let (_, _dir_orig, _f) = split_pathname(&path, "");
            let dir_orig = if _dir_orig.is_empty() {
                String::new()
            } else {
                _dir_orig.clone()
            };
            let mut path_extended = path.clone();
            if needs_expand_home(&path_extended) {
                utils::expand_home_string(&mut path_extended)
            }
            utils::expand_env_string(&mut path_extended);

            let (_, _dir_lookup, file_name) = split_pathname(&path_extended, "");
            let dir_lookup = if _dir_lookup.is_empty() {
                ".".to_string()
            } else {
                _dir_lookup.clone()
            };
            // let dir_lookup = _dir_lookup.unwrap_or(".");
            if let Ok(entries) = read_dir(dir_lookup) {
                for entry in entries.flatten() {
                    let pathbuf = entry.path();
                    let is_dir = pathbuf.is_dir();
                    if for_dir && !is_dir {
                        continue;
                    }

                    let entry_name = entry.file_name();
                    // TODO: Deal with non-UTF8 paths in some way
                    if let Ok(_path) = entry_name.into_string() {
                        if _path.starts_with(&file_name) {
                            let (name, display) = if !dir_orig.is_empty() {
                                (
                                    format!("{}{}{}", dir_orig, MAIN_SEPARATOR, _path),
                                    Some(_path),
                                )
                            } else {
                                (_path, None)
                            };
                            let mut name = str::replace(name.as_str(), "//", "/");
                            if path_sep.is_empty() && !is_env {
                                name = tools::escape_path(&name);
                            }
                            let mut quoted = false;
                            if !path_sep.is_empty() {
                                name = tools::wrap_sep_string(&path_sep, &name);
                                quoted = true;
                            }
                            let suffix = if is_dir {
                                if quoted {
                                    name.pop();
                                }
                                Suffix::Some(MAIN_SEPARATOR)
                            } else {
                                Suffix::Default
                            };
                            res.push(Completion {
                                completion: name,
                                display,
                                suffix,
                            });
                        }
                    }
                }
            }
            res.sort_by(|a, b| a.completion.cmp(&b.completion));
            res
        }

        // Split optional directory and prefix. (see its test cases for more details)
        fn split_pathname(path: &str, prefix: &str) -> (String, String, String) {
            if is_pipelined(path) {
                let tokens: Vec<&str> = path.rsplitn(2, '|').collect();
                let prefix = format!("{}|", tokens[1]);
                return split_pathname(tokens[0], &prefix);
            }
            match path.rfind('/') {
                Some(pos) => (
                    prefix.to_string(),
                    path[..=pos].to_string(),
                    path[pos + 1..].to_string(),
                ),
                None => (prefix.to_string(), String::new(), path.to_string()),
            }
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        fn complete_bin(sh: &shell::Shell, path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            let (prefix, _, fname) = split_pathname(path, "");
            let env_path = match env::var("PATH") {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!(":: env error when complete_bin: {:?}", e);
                    return res;
                }
            };

            let mut checker: HashSet<String> = HashSet::new();

            // handle alias, builtins, and functions
            for func in sh.funcs.keys() {
                if !func.starts_with(&fname) {
                    continue;
                }
                if checker.contains(func) {
                    continue;
                }
                checker.insert(func.clone());
                res.push(Completion {
                    completion: func.to_owned(),
                    display: None,
                    suffix: Suffix::Default,
                });
            }
            for alias in sh.aliases.keys() {
                if !alias.starts_with(&fname) {
                    continue;
                }
                if checker.contains(alias) {
                    continue;
                }
                checker.insert(alias.clone());
                res.push(Completion {
                    completion: alias.to_owned(),
                    display: None,
                    suffix: Suffix::Default,
                });
            }

            let builtins = vec![
                "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg",
                "history", "jobs", "read", "source", "ulimit", "unalias", "vox",
                "minfd", "set", "unset", "unpath",
            ];
            for item in &builtins {
                if !item.starts_with(&fname) {
                    continue;
                }
                if checker.contains(*item) {
                    continue;
                }
                checker.insert(item.to_string());
                res.push(Completion {
                    completion: item.to_string(),
                    display: None,
                    suffix: Suffix::Default,
                });
            }

            let vec_path: Vec<&str> = env_path.split(':').collect();
            let path_list: HashSet<&str> = HashSet::from_iter(vec_path.iter().cloned());

            for p in &path_list {
                if let Ok(list) = read_dir(p) {
                    for entry in list.flatten() {
                        if let Ok(name) = entry.file_name().into_string() {
                            if name.starts_with(&fname) {
                                let _mode = match entry.metadata() {
                                    Ok(x) => x,
                                    Err(e) => {
                                        println_stderr!(":: metadata error: {:?}", e);
                                        continue;
                                    }
                                };
                                let mode = _mode.permissions().mode();
                                if mode & 0o111 == 0 {
                                    // not binary
                                    continue;
                                }
                                if checker.contains(&name) {
                                    continue;
                                }

                                let display = None;
                                let suffix = Suffix::Default;
                                checker.insert(name.clone());
                                // TODO: need to handle quoted: `$ "foo#bar"`
                                let name_e = tools::escape_path(&name);
                                let name_e = format!("{}{}", prefix, name_e);
                                res.push(Completion {
                                    completion: name_e,
                                    display,
                                    suffix,
                                });
                            }
                        }
                    }
                }
            }
            res
        }
    }

    pub mod ssh
    {
        use ::
        {
            *,
        };

        use std::fs::File;
        use std::io::{BufRead, BufReader};

        use regex::Regex;

        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::terminal::Terminal;
        use lineread::Prompter;

        use crate::tools;

        pub struct SshCompleter;

        impl<Term: Terminal> Completer<Term> for SshCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_ssh(word))
            }
        }

        fn complete_ssh(path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            let home = tools::get_user_home();
            let ssh_config = home + "/.ssh/config";
            if let Ok(f) = File::open(&ssh_config) {
                let file = BufReader::new(&f);
                let re = match Regex::new(r"^ *(?i)host +([^ ]+)") {
                    Ok(x) => x,
                    Err(e) => {
                        println!("Regex build error: {:?}", e);
                        return res;
                    }
                };
                for line in file.lines().map_while(Result::ok) {
                    if !re.is_match(&line) {
                        continue;
                    }
                    for cap in re.captures_iter(&line) {
                        if !cap[1].starts_with(path) {
                            continue;
                        }
                        res.push(Completion {
                            completion: cap[1].to_string(),
                            display: None,
                            suffix: Suffix::Default,
                        });
                    }
                }
            }
            res
        }
    }

    pub mod utils
    {
        use ::
        {
            *,
        };

        use regex::Regex;
        use std::env;

        use crate::libs;
        use crate::tools;

        pub fn expand_home_string(text: &mut String) {
            let v = vec![
                r"(?P<head> +)~(?P<tail> +)",
                r"(?P<head> +)~(?P<tail>/)",
                r"^(?P<head> *)~(?P<tail>/)",
                r"(?P<head> +)~(?P<tail> *$)",
            ];
            for item in &v {
                let re;
                if let Ok(x) = Regex::new(item) {
                    re = x;
                } else {
                    return;
                }
                let home = tools::get_user_home();
                let ss = text.clone();
                let to = format!("$head{}$tail", home);
                let result = re.replace_all(ss.as_str(), to.as_str());
                *text = result.to_string();
            }
        }

        pub fn expand_env_string(text: &mut String) {
            // expand "$HOME/.local/share" to "/home/tom/.local/share"
            if !text.starts_with('$') {
                return;
            }
            let ptn = r"^\$([A-Za-z_][A-Za-z0-9_]*)";
            let mut env_value = String::new();
            match libs::re::find_first_group(ptn, text) {
                Some(x) => {
                    if let Ok(val) = env::var(&x) {
                        env_value = val;
                    }
                }
                None => {
                    return;
                }
            }

            if env_value.is_empty() {
                return;
            }
            let t = text.clone();
            *text = libs::re::replace_all(&t, ptn, &env_value);
        }
    }
    
    use crate::libs;
    use crate::parsers;
    use crate::shell;
    use crate::tools;

    pub struct CicadaCompleter {
        pub sh: Arc<shell::Shell>,
    }

    fn for_make(line: &str) -> bool {
        libs::re::re_contains(line, r"^ *make ")
    }

    fn for_env(line: &str) -> bool {
        libs::re::re_contains(line, r" *\$[_a-zA-Z0-9]*$")
    }

    fn for_ssh(line: &str) -> bool {
        libs::re::re_contains(line, r"^ *(ssh|scp).* +[^ \./]+ *$")
    }

    fn for_cd(line: &str) -> bool {
        libs::re::re_contains(line, r"^ *cd +")
    }

    fn for_bin(line: &str) -> bool {
        let ptn = r"(^ *(sudo|which|nohup)? *[a-zA-Z0-9_\.-]+$)|(^.+\| *(sudo|which|nohup)? *[a-zA-Z0-9_\.-]+$)";
        libs::re::re_contains(line, ptn)
    }

    fn for_dots(line: &str) -> bool {
        let args = parsers::parser_line::line_to_plain_tokens(line);
        let len = args.len();
        if len == 0 {
            return false;
        }
        let dir = tools::get_user_completer_dir();
        let dot_file = format!("{}/{}.yaml", dir, args[0]);
        Path::new(dot_file.as_str()).exists()
    }

    impl<Term: Terminal> Completer<Term> for CicadaCompleter {
        fn complete(
            &self,
            word: &str,
            reader: &Prompter<Term>,
            start: usize,
            _end: usize,
        ) -> Option<Vec<Completion>> {
            let line = reader.buffer();

            let completions: Option<Vec<Completion>>;
            if for_dots(line) {
                let cpl = Arc::new(dots::DotsCompleter);
                completions = cpl.complete(word, reader, start, _end);
            } else if for_ssh(line) {
                let cpl = Arc::new(ssh::SshCompleter);
                completions = cpl.complete(word, reader, start, _end);
            } else if for_make(line) {
                let cpl = Arc::new(make::MakeCompleter);
                completions = cpl.complete(word, reader, start, _end);
            } else if for_bin(line) {
                let cpl = Arc::new(path::BinCompleter {
                    sh: self.sh.clone(),
                });
                completions = cpl.complete(word, reader, start, _end);
            } else if for_env(line) {
                let cpl = Arc::new(env::EnvCompleter {
                    sh: self.sh.clone(),
                });
                completions = cpl.complete(word, reader, start, _end);
            } else if for_cd(line) {
                // `for_cd` should be put a bottom position, so that
                // `cd $SOME_ENV_<TAB>` works as expected.
                let cpl = Arc::new(path::CdCompleter);
                // completions for `cd` should not fail back to path-completion
                return cpl.complete(word, reader, start, _end);
            } else {
                completions = None;
            }

            if let Some(x) = completions {
                if !x.is_empty() {
                    return Some(x);
                }
            }

            // empty completions should fail back to path-completion,
            // so that `$ make generate /path/to/fi<Tab>` still works.
            let cpl = Arc::new(path::PathCompleter);
            cpl.complete(word, reader, start, _end)
        }

        fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
            escaped_word_start(&line[..end])
        }
    }

    pub fn escaped_word_start(line: &str) -> usize {
        let mut start_position: usize = 0;
        let mut found_bs = false;
        let mut found_space = false;
        let mut with_quote = false;
        let mut ch_quote = '\0';
        let mut extra_bytes = 0;
        for (i, c) in line.chars().enumerate() {
            if found_space {
                found_space = false;
                start_position = i + extra_bytes;
            }

            if c == '\\' {
                found_bs = true;
                continue;
            }
            if c == ' ' && !found_bs && !with_quote {
                found_space = true;
                continue;
            }

            if !with_quote && !found_bs && (c == '"' || c == '\'') {
                with_quote = true;
                ch_quote = c;
            } else if with_quote && !found_bs && ch_quote == c {
                with_quote = false;
            }

            let bytes_c = c.len_utf8();
            if bytes_c > 1 {
                extra_bytes += bytes_c - 1;
            }
            found_bs = false;
        }
        if found_space {
            start_position = line.len();
        }
        start_position
    }
}

pub mod convert
{
    pub use std::convert::{ * };
}

pub mod core
{
    use ::
    {
        *,
    };
    /*
    use std::env;
    use std::ffi::{CStr, CString};
    use std::fs::File;
    use std::io::{Read, Write};
    use std::os::unix::io::FromRawFd;
    use std::os::fd::RawFd;
    use std::process;

    use nix::unistd::{execve, ForkResult};
    use libs::pipes::pipe;

    use crate::builtins;
    use crate::calculator;
    use crate::jobc;
    use crate::libs;
    use crate::parsers;
    use crate::scripting;
    use crate::shell::{self, Shell};
    use crate::tools;
    use crate::types::{CommandLine, CommandOptions, CommandResult}; */
    
    fn try_run_builtin_in_subprocess(
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<i32> {
        if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) {
            return Some(cr.status);
        }
        None
    }

    fn try_run_builtin(
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<CommandResult> {
        // for builtin, only capture its outputs when it locates at the end
        let capture = capture && idx_cmd + 1 == cl.commands.len();

        if idx_cmd >= cl.commands.len() {
            println_stderr!("unexpected error in try_run_builtin");
            return None;
        }

        let cmd = &cl.commands[idx_cmd];
        let tokens = cmd.tokens.clone();
        let cname = tokens[0].1.clone();
        if cname == "alias" {
            let cr = builtins::alias::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "bg" {
            let cr = builtins::bg::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "cd" {
            let cr = builtins::cd::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "cinfo" {
            let cr = builtins::cinfo::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "exec" {
            let cr = builtins::exec::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "exit" {
            let cr = builtins::exit::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "export" {
            let cr = builtins::export::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "fg" {
            let cr = builtins::fg::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "history" {
            let cr = builtins::history::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "jobs" {
            let cr = builtins::jobs::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "minfd" {
            let cr = builtins::minfd::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "read" {
            let cr = builtins::read::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "set" {
            let cr = builtins::set::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "source" {
            let cr = builtins::source::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "ulimit" {
            let cr = builtins::ulimit::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "unalias" {
            let cr = builtins::unalias::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "unset" {
            let cr = builtins::unset::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "unpath" {
            let cr = builtins::unpath::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "vox" {
            let cr = builtins::vox::run(sh, cl, cmd, capture);
            return Some(cr);
        }
        None
    }
    /// Run a pipeline (e.g. `echo hi | wc -l`)
    /// returns: (is-terminal-given, command-result)
    pub fn run_pipeline(
        sh: &mut shell::Shell,
        cl: &CommandLine,
        tty: bool,
        capture: bool,
        log_cmd: bool,
    ) -> (bool, CommandResult) {
        let mut term_given = false;
        if cl.background && capture {
            println_stderr!(":: cannot capture output of background cmd");
            return (term_given, CommandResult::error());
        }

        if let Some(cr) = try_run_calculator(&cl.line, capture) {
            return (term_given, cr);
        }

        // FIXME: move func-run into run single command
        if let Some(cr) = try_run_func(sh, cl, capture, log_cmd) {
            return (term_given, cr);
        }

        if log_cmd {
            log!("run: {}", cl.line);
        }

        let length = cl.commands.len();
        if length == 0 {
            println!(":: invalid command: cmds with empty length");
            return (false, CommandResult::error());
        }

        let mut pipes = Vec::new();
        let mut errored_pipes = false;
        for _ in 0..length - 1 {
            match pipe() {
                Ok(fds) => pipes.push(fds),
                Err(e) => {
                    errored_pipes = true;
                    println_stderr!(":: pipeline1: {}", e);
                    break;
                }
            }
        }

        if errored_pipes {
            // release fds that already created when errors occurred
            for fds in pipes {
                libs::close(fds.0);
                libs::close(fds.1);
            }
            return (false, CommandResult::error());
        }

        if pipes.len() + 1 != length {
            println!(":: invalid command: unmatched pipes count");
            return (false, CommandResult::error());
        }

        let mut pgid: i32 = 0;
        let mut fg_pids: Vec<i32> = Vec::new();

        let isatty = if tty {
            unsafe { libc::isatty(1) == 1 }
        } else {
            false
        };
        let options = CommandOptions {
            isatty,
            capture_output: capture,
            background: cl.background,
            envs: cl.envs.clone(),
        };

        let mut fds_capture_stdout = None;
        let mut fds_capture_stderr = None;
        if capture {
            match pipe() {
                Ok(fds) => fds_capture_stdout = Some(fds),
                Err(e) => {
                    println_stderr!(":: pipeline2: {}", e);
                    return (false, CommandResult::error());
                }
            }
            match pipe() {
                Ok(fds) => fds_capture_stderr = Some(fds),
                Err(e) => {
                    if let Some(fds) = fds_capture_stdout {
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                    println_stderr!(":: pipeline3: {}", e);
                    return (false, CommandResult::error());
                }
            }
        }

        let mut cmd_result = CommandResult::new();
        for i in 0..length {
            let child_id: i32 = run_single_program(
                sh,
                cl,
                i,
                &options,
                &mut pgid,
                &mut term_given,
                &mut cmd_result,
                &pipes,
                &fds_capture_stdout,
                &fds_capture_stderr,
            );

            if child_id > 0 && !cl.background {
                fg_pids.push(child_id);
            }
        }

        if cl.is_single_and_builtin() {
            return (false, cmd_result);
        }

        if cl.background {
            if let Some(job) = sh.get_job_by_gid(pgid) {
                println_stderr!("[{}] {}", job.id, job.gid);
            }
        }

        if !fg_pids.is_empty() {
            let _cr = jobc::wait_fg_job(sh, pgid, &fg_pids);
            // for capture commands, e.g. `echo foo` in `echo "hello $(echo foo)"
            // the cmd_result is already built in loop calling run_single_program()
            // above.
            if !capture {
                cmd_result = _cr;
            }
        }
        (term_given, cmd_result)
    }
    /// Run a single command.
    /// e.g. the `sort -k2` part of `ps ax | sort -k2 | head`
    #[allow(clippy::needless_range_loop)]
    #[allow(clippy::too_many_arguments)]
    fn run_single_program(
        sh: &mut shell::Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        options: &CommandOptions,
        pgid: &mut i32,
        term_given: &mut bool,
        cmd_result: &mut CommandResult,
        pipes: &[(RawFd, RawFd)],
        fds_capture_stdout: &Option<(RawFd, RawFd)>,
        fds_capture_stderr: &Option<(RawFd, RawFd)>,
    ) -> i32 {
        let capture = options.capture_output;
        if cl.is_single_and_builtin() {
            if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) {
                *cmd_result = cr;
                return unsafe { libc::getpid() };
            }

            println_stderr!(":: error when run singler builtin");
            log!("error when run singler builtin: {:?}", cl);
            return 1;
        }

        let pipes_count = pipes.len();
        let mut fds_stdin = None;
        let cmd = cl.commands.get(idx_cmd).unwrap();

        if cmd.has_here_string() {
            match pipe() {
                Ok(fds) => fds_stdin = Some(fds),
                Err(e) => {
                    println_stderr!(":: pipeline4: {}", e);
                    return 1;
                }
            }
        }

        match libs::fork::fork() {
            Ok(ForkResult::Child) => {
                unsafe {
                    // child processes need to handle ctrl-Z
                    libc::signal(libc::SIGTSTP, libc::SIG_DFL);
                    libc::signal(libc::SIGQUIT, libc::SIG_DFL);
                }

                // close pipes unrelated to current child (left side)
                if idx_cmd > 0 {
                    for i in 0..idx_cmd - 1 {
                        let fds = pipes[i];
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                }
                // close pipes unrelated to current child (right side)
                for i in idx_cmd + 1..pipes_count {
                    let fds = pipes[i];
                    libs::close(fds.0);
                    libs::close(fds.1);
                }
                // close pipe fds for capturing stdout/stderr
                // (they're only used in last child)
                if idx_cmd < pipes_count {
                    if let Some(fds) = fds_capture_stdout {
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                    if let Some(fds) = fds_capture_stderr {
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                }

                if idx_cmd == 0 {
                    unsafe {
                        let pid = libc::getpid();
                        libc::setpgid(0, pid);
                    }
                } else {
                    unsafe {
                        libc::setpgid(0, *pgid);
                    }
                }

                // (in child) replace stdin/stdout with read/write ends of pipe
                if idx_cmd > 0 {
                    let fds_prev = pipes[idx_cmd - 1];
                    libs::dup2(fds_prev.0, 0);
                    libs::close(fds_prev.0);
                    libs::close(fds_prev.1);
                }
                if idx_cmd < pipes_count {
                    let fds = pipes[idx_cmd];
                    libs::dup2(fds.1, 1);
                    libs::close(fds.1);
                    libs::close(fds.0);
                }

                if cmd.has_redirect_from() {
                    if let Some(redirect_from) = &cmd.redirect_from {
                        let fd = tools::get_fd_from_file(&redirect_from.clone().1);
                        if fd == -1 {
                            process::exit(1);
                        }

                        libs::dup2(fd, 0);
                        libs::close(fd);
                    }
                }

                if cmd.has_here_string() {
                    if let Some(fds) = fds_stdin {
                        libs::close(fds.1);
                        libs::dup2(fds.0, 0);
                        libs::close(fds.0);
                    }
                }

                let mut stdout_redirected = false;
                let mut stderr_redirected = false;
                for item in &cmd.redirects_to {
                    let from_ = &item.0;
                    let op_ = &item.1;
                    let to_ = &item.2;
                    if to_ == "&1" && from_ == "2" {
                        if idx_cmd < pipes_count {
                            libs::dup2(1, 2);
                        } else if !options.capture_output {
                            let fd = libs::dup(1);
                            if fd == -1 {
                                println_stderr!(":: dup error");
                                process::exit(1);
                            }
                            libs::dup2(fd, 2);
                        } else {
                            // note: capture output with redirections does not
                            // make much sense
                        }
                    } else if to_ == "&2" && from_ == "1" {
                        if idx_cmd < pipes_count || !options.capture_output {
                            let fd = libs::dup(2);
                            if fd == -1 {
                                println_stderr!(":: dup error");
                                process::exit(1);
                            }
                            libs::dup2(fd, 1);
                        } else {
                            // note: capture output with redirections does not
                            // make much sense
                        }
                    } else {
                        let append = op_ == ">>";
                        match tools::create_raw_fd_from_file(to_, append) {
                            Ok(fd) => {
                                if fd == -1 {
                                    println_stderr!(":: fork: fd error");
                                    process::exit(1);
                                }

                                if from_ == "1" {
                                    libs::dup2(fd, 1);
                                    stdout_redirected = true;
                                } else {
                                    libs::dup2(fd, 2);
                                    stderr_redirected = true;
                                }
                            }
                            Err(e) => {
                                println_stderr!(":: fork: {}", e);
                                process::exit(1);
                            }
                        }
                    }
                }

                // capture output of last process if needed.
                if idx_cmd == pipes_count && options.capture_output {
                    if !stdout_redirected {
                        if let Some(fds) = fds_capture_stdout {
                            libs::close(fds.0);
                            libs::dup2(fds.1, 1);
                            libs::close(fds.1);
                        }
                    }
                    if !stderr_redirected {
                        if let Some(fds) = fds_capture_stderr {
                            libs::close(fds.0);
                            libs::dup2(fds.1, 2);
                            libs::close(fds.1);
                        }
                    }
                }

                if cmd.is_builtin() {
                    if let Some(status) = try_run_builtin_in_subprocess(sh, cl, idx_cmd, capture) {
                        process::exit(status);
                    }
                }

                // our strings do not have '\x00' bytes in them,
                // we can use CString::new().expect() safely.
                let mut c_envs: Vec<_> = env::vars()
                    .map(|(k, v)| {
                        CString::new(format!("{}={}", k, v).as_str()).expect("CString error")
                    })
                    .collect();
                for (key, value) in cl.envs.iter() {
                    c_envs.push(
                        CString::new(format!("{}={}", key, value).as_str()).expect("CString error"),
                    );
                }

                let program = &cmd.tokens[0].1;
                let path = if program.contains('/') {
                    program.clone()
                } else {
                    libs::path::find_file_in_path(program, true)
                };
                if path.is_empty() {
                    println_stderr!(":: {}: command not found", program);
                    process::exit(127);
                }

                let c_program = CString::new(path.as_str()).expect("CString::new failed");
                let c_args: Vec<_> = cmd
                    .tokens
                    .iter()
                    .map(|x| CString::new(x.1.as_str()).expect("CString error"))
                    .collect();

                let c_args: Vec<&CStr> = c_args.iter().map(|x| x.as_c_str()).collect();
                let c_envs: Vec<&CStr> = c_envs.iter().map(|x| x.as_c_str()).collect();
                match execve(&c_program, &c_args, &c_envs) {
                    Ok(_) => {}
                    Err(e) => match e {
                        nix::Error::ENOEXEC => {
                            println_stderr!(":: {}: exec format error (ENOEXEC)", program);
                        }
                        nix::Error::ENOENT => {
                            println_stderr!(":: {}: file does not exist", program);
                        }
                        nix::Error::EACCES => {
                            println_stderr!(":: {}: Permission denied", program);
                        }
                        _ => {
                            println_stderr!(":: {}: {:?}", program, e);
                        }
                    },
                }

                process::exit(1);
            }
            Ok(ForkResult::Parent { child, .. }) => {
                let pid: i32 = child.into();
                if idx_cmd == 0 {
                    *pgid = pid;
                    unsafe {
                        // we need to wait pgid of child set to itself,
                        // before give terminal to it (for macos).
                        // 1. this loop causes `bash`, `htop` etc to go `T` status
                        //    immediate after start on linux (ubuntu).
                        // 2. but on mac, we need this loop, otherwise commands
                        //    like `vim` will go to `T` status after start.
                        if cfg!(target_os = "macos") {
                            loop {
                                let _pgid = libc::getpgid(pid);
                                if _pgid == pid {
                                    break;
                                }
                            }
                        }

                        if sh.has_terminal
                            && options.isatty
                            && !cl.background
                        {
                            *term_given = shell::give_terminal_to(pid);
                        }
                    }
                }

                if options.isatty && !options.capture_output {
                    let _cmd = parsers::parser_line::tokens_to_line(&cmd.tokens);
                    sh.insert_job(*pgid, pid, &_cmd, "Running", cl.background);
                }

                if let Some(redirect_from) = &cmd.redirect_from {
                    if redirect_from.0 == "<<<" {
                        if let Some(fds) = fds_stdin {
                            unsafe {
                                libs::close(fds.0);

                                let mut f = File::from_raw_fd(fds.1);
                                match f.write_all(redirect_from.1.clone().as_bytes()) {
                                    Ok(_) => {}
                                    Err(e) => println_stderr!(":: write_all: {}", e),
                                }
                                match f.write_all(b"\n") {
                                    Ok(_) => {}
                                    Err(e) => println_stderr!(":: write_all: {}", e),
                                }
                            }
                        }
                    }
                }

                // (in parent) close unused pipe ends
                if idx_cmd < pipes_count {
                    let fds = pipes[idx_cmd];
                    libs::close(fds.1);
                }
                if idx_cmd > 0 {
                    // close pipe end only after dupped in the child
                    let fds = pipes[idx_cmd - 1];
                    libs::close(fds.0);
                }

                if idx_cmd == pipes_count && options.capture_output {
                    let mut s_out = String::new();
                    let mut s_err = String::new();

                    unsafe {
                        if let Some(fds) = fds_capture_stdout {
                            libs::close(fds.1);

                            let mut f = File::from_raw_fd(fds.0);
                            match f.read_to_string(&mut s_out) {
                                Ok(_) => {}
                                Err(e) => println_stderr!(":: readstr: {}", e),
                            }
                        }
                        if let Some(fds) = fds_capture_stderr {
                            libs::close(fds.1);
                            let mut f_err = File::from_raw_fd(fds.0);
                            match f_err.read_to_string(&mut s_err) {
                                Ok(_) => {}
                                Err(e) => println_stderr!(":: readstr: {}", e),
                            }
                        }
                    }

                    *cmd_result = CommandResult {
                        gid: *pgid,
                        status: 0,
                        stdout: s_out.clone(),
                        stderr: s_err.clone(),
                    };
                }

                pid
            }

            Err(_) => {
                println_stderr!("Fork failed");
                *cmd_result = CommandResult::error();
                0
            }
        }
    }

    fn try_run_func(
        sh: &mut Shell,
        cl: &CommandLine,
        capture: bool,
        log_cmd: bool,
    ) -> Option<CommandResult> {
        if cl.is_empty() {
            return None;
        }

        let command = &cl.commands[0];
        if let Some(func_body) = sh.get_func(&command.tokens[0].1) {
            let mut args = vec!["cicada".to_string()];
            for token in &command.tokens {
                args.push(token.1.to_string());
            }
            if log_cmd {
                log!("run func: {:?}", &args);
            }
            let cr_list = scripting::run_lines(sh, &func_body, &args, capture);
            let mut stdout = String::new();
            let mut stderr = String::new();
            for cr in cr_list {
                stdout.push_str(cr.stdout.trim());
                stdout.push(' ');
                stderr.push_str(cr.stderr.trim());
                stderr.push(' ');
            }
            let mut cr = CommandResult::new();
            cr.stdout = stdout;
            cr.stderr = stderr;
            return Some(cr);
        }
        None
    }

    fn try_run_calculator(line: &str, capture: bool) -> Option<CommandResult> {
        if tools::is_arithmetic(line) {
            match run_calculator(line) {
                Ok(result) => {
                    let mut cr = CommandResult::new();
                    if capture {
                        cr.stdout = result.clone();
                    } else {
                        println!("{}", result);
                    }
                    return Some(cr);
                }
                Err(e) => {
                    let mut cr = CommandResult::from_status(0, 1);
                    if capture {
                        cr.stderr = e.to_string();
                    } else {
                        println_stderr!(":: calculator: {}", e);
                    }
                    return Some(cr);
                }
            }
        }
        None
    }

    pub fn run_calculator(line: &str) -> Result<String, &str> {
        let parse_result = calculator::calculate(line);
        match parse_result {
            Ok(mut calc) => {
                let expr = calc.next().unwrap().into_inner();

                if line.contains('.') {
                    Ok(format!("{}", calculator::eval_float(expr)))
                } else {
                    Ok(format!("{}", calculator::eval_int(expr)))
                }
            }
            Err(_) => {
                Err("syntax error")
            }
        }
    }
}

pub mod ctime
{
    use ::
    {
        *,
    };
    use std::fmt;
    use time::OffsetDateTime;

    #[derive(Debug, PartialEq, Eq)]
    pub struct DateTime {
        odt: OffsetDateTime,
    }

    impl DateTime {
        pub fn now() -> Self {
            let odt: OffsetDateTime = match OffsetDateTime::now_local() {
                Ok(dt) => dt,
                Err(_) => OffsetDateTime::now_utc(),
            };
            DateTime { odt }
        }

        pub fn from_timestamp(ts: f64) -> Self {
            let dummy_now = Self::now();
            let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
            let ts_nano = (ts + offset_seconds as f64) * 1000000000.0;
            let odt: OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos(ts_nano as i128) {
                Ok(x) => x,
                Err(_) => OffsetDateTime::now_utc(),
            };
            DateTime { odt }
        }

        pub fn unix_timestamp(&self) -> f64 {
            self.odt.unix_timestamp_nanos() as f64 / 1000000000.0
        }
    }

    impl fmt::Display for DateTime {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                self.odt.year(),
                self.odt.month() as u8,
                self.odt.day(),
                self.odt.hour(),
                self.odt.minute(),
                self.odt.second(),
                self.odt.millisecond(),
            )
        }
    }
}

pub mod errno
{
    //! Cross-platform interface to the `errno` variable.
    use ::
    {
        *,
    };
    
    mod sys
    {
        pub mod unix
        {
            //! Implementation of `errno` functionality for Unix systems.
            use ::
            {
                *,
            };
            use core::str;
            use libc::{self, c_int, size_t, strerror_r, strlen};

            use crate::Errno;

            fn from_utf8_lossy(input: &[u8]) -> &str {
                match str::from_utf8(input) {
                    Ok(valid) => valid,
                    Err(error) => unsafe { str::from_utf8_unchecked(&input[..error.valid_up_to()]) },
                }
            }

            pub fn with_description<F, T>(err: Errno, callback: F) -> T
            where
                F: FnOnce(Result<&str, Errno>) -> T,
            {
                let mut buf = [0u8; 1024];
                let c_str = unsafe {
                    let rc = strerror_r(err.0, buf.as_mut_ptr() as *mut _, buf.len() as size_t);
                    if rc != 0 {
                        // Handle negative return codes for compatibility with glibc < 2.13
                        let fm_err = match rc < 0 {
                            true => errno(),
                            false => Errno(rc),
                        };
                        if fm_err != Errno(libc::ERANGE) {
                            return callback(Err(fm_err));
                        }
                    }
                    let c_str_len = strlen(buf.as_ptr() as *const _);
                    &buf[..c_str_len]
                };
                callback(Ok(from_utf8_lossy(c_str)))
            }

            pub const STRERROR_NAME: &str = "strerror_r";

            pub fn errno() -> Errno {
                unsafe { Errno(*errno_location()) }
            }

            pub fn set_errno(Errno(errno): Errno) {
                unsafe {
                    *errno_location() = errno;
                }
            }

            extern "C" {
                #[cfg_attr(
                    any(
                        target_os = "macos",
                        target_os = "ios",
                        target_os = "tvos",
                        target_os = "watchos",
                        target_os = "visionos",
                        target_os = "freebsd"
                    ),
                    link_name = "__error"
                )]
                #[cfg_attr(
                    any(
                        target_os = "openbsd",
                        target_os = "netbsd",
                        target_os = "android",
                        target_os = "espidf",
                        target_os = "vxworks",
                        target_os = "cygwin",
                        target_env = "newlib"
                    ),
                    link_name = "__errno"
                )]
                #[cfg_attr(
                    any(target_os = "solaris", target_os = "illumos"),
                    link_name = "___errno"
                )]
                #[cfg_attr(target_os = "haiku", link_name = "_errnop")]
                #[cfg_attr(
                    any(
                        target_os = "linux",
                        target_os = "hurd",
                        target_os = "redox",
                        target_os = "dragonfly",
                        target_os = "emscripten",
                    ),
                    link_name = "__errno_location"
                )]
                #[cfg_attr(target_os = "aix", link_name = "_Errno")]
                #[cfg_attr(target_os = "nto", link_name = "__get_errno_ptr")]
                fn errno_location() -> *mut c_int;
            }
        }

        pub mod windows
        {
            //! Implementation of `errno` functionality for Windows.
            use ::
            {
                *,
            };
            
            use core::char::{self, REPLACEMENT_CHARACTER};
            use core::ptr;
            use core::str;
            use windows_sys::Win32::Foundation::{GetLastError, SetLastError, WIN32_ERROR};
            use windows_sys::Win32::System::Diagnostics::Debug::{
                FormatMessageW, FORMAT_MESSAGE_FROM_SYSTEM, FORMAT_MESSAGE_IGNORE_INSERTS,
            };

            use crate::Errno;

            fn from_utf16_lossy<'a>(input: &[u16], output: &'a mut [u8]) -> &'a str {
                let mut output_len = 0;
                for c in char::decode_utf16(input.iter().copied().take_while(|&x| x != 0))
                    .map(|x| x.unwrap_or(REPLACEMENT_CHARACTER))
                {
                    let c_len = c.len_utf8();
                    if c_len > output.len() - output_len {
                        break;
                    }
                    c.encode_utf8(&mut output[output_len..]);
                    output_len += c_len;
                }
                unsafe { str::from_utf8_unchecked(&output[..output_len]) }
            }

            pub fn with_description<F, T>(err: Errno, callback: F) -> T
            where
                F: FnOnce(Result<&str, Errno>) -> T,
            {
                // This value is calculated from the macro
                // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)
                let lang_id = 0x0800_u32;

                let mut buf = [0u16; 2048];

                unsafe {
                    let res = FormatMessageW(
                        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                        ptr::null_mut(),
                        err.0 as u32,
                        lang_id,
                        buf.as_mut_ptr(),
                        buf.len() as u32,
                        ptr::null_mut(),
                    );
                    if res == 0 {
                        // Sometimes FormatMessageW can fail e.g. system doesn't like lang_id
                        let fm_err = errno();
                        return callback(Err(fm_err));
                    }

                    let mut msg = [0u8; 2048];
                    let msg = from_utf16_lossy(&buf[..res as usize], &mut msg[..]);
                    // Trim trailing CRLF inserted by FormatMessageW
                    callback(Ok(msg.trim_end()))
                }
            }

            pub const STRERROR_NAME: &str = "FormatMessageW";

            pub fn errno() -> Errno {
                unsafe { Errno(GetLastError() as i32) }
            }

            pub fn set_errno(Errno(errno): Errno) {
                unsafe { SetLastError(errno as WIN32_ERROR) }
            }
        }
        #[cfg(unix)] pub use self::unix::{ * };
        #[cfg(windows)] pub use self::windows::{ * };
    }
    /*
    use core::fmt;
    #[cfg(feature = "std")]
    use std::error::Error;
    #[cfg(feature = "std")]
    use std::io;
    */
    /// Wraps a platform-specific error code.
    #[derive(Copy, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
    pub struct Errno(pub i32);

    impl fmt::Debug for Errno 
    {
        fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
            sys::with_description(*self, |desc| {
                fmt.debug_struct("Errno")
                    .field("code", &self.0)
                    .field("description", &desc.ok())
                    .finish()
            })
        }
    }

    impl fmt::Display for Errno 
    {
        fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
            sys::with_description(*self, |desc| match desc {
                Ok(desc) => fmt.write_str(desc),
                Err(fm_err) => write!(
                    fmt,
                    "OS error {} ({} returned error {})",
                    self.0,
                    sys::STRERROR_NAME,
                    fm_err.0
                ),
            })
        }
    }

    impl From<Errno> for i32 
    {
        fn from(e: Errno) -> Self {
            e.0
        }
    }

    impl Error for Errno 
    {
        // TODO: Remove when MSRV >= 1.27
        #[allow(deprecated)]
        fn description(&self) -> &str {
            "system error"
        }
    }

    impl From<Errno> for io::Error 
    {
        fn from(errno: Errno) -> Self {
            io::Error::from_raw_os_error(errno.0)
        }
    }
    /// Returns the platform-specific value of `errno`.
    pub fn errno() -> Errno 
    {
        sys::errno()
    }
    /// Sets the platform-specific value of `errno`.
    pub fn set_errno(err: Errno) 
    {
        sys::set_errno(err)
    }
}

pub mod error
{
    pub use std::error::{ * };
}

pub mod env
{
    pub use std::env::{ * };
}

pub mod exec
{
    //! A simple wrapper around the C library's `execvp` function.
    use ::
    {
        errno::{ Errno, errno },
        error::{ self, Error as ErrorTrait },
        ffi::{ CString, NulError, OsStr, OsString },
        *,
    };
    /*
    use std::ffi::{CString, NulError, OsStr, OsString};
    use std::iter::{IntoIterator, Iterator};
    use std::fmt;
    use std::ptr;
    use std::os::unix::ffi::OsStrExt;
    */
    /// Represents an error calling `exec`.
    ///
    /// This is marked `#[must_use]`, which is unusual for error types.
    /// Normally, the fact that `Result` is marked in this fashion is
    /// sufficient, but in this case, this error is returned bare from
    /// functions that only return a result if they fail.
    #[derive(Debug)]
    #[must_use]
    pub enum Error {
        /// One of the strings passed to `execv` contained an internal null byte
        /// and can't be passed correctly to C.
        BadArgument(NulError),
        /// An error was returned by the system.
        Errno(Errno),
    }

    impl error::Error for Error {
        fn description(&self) -> &str {
            match self {
                &Error::BadArgument(_) => "bad argument to exec",
                &Error::Errno(_) => "couldn't exec process",
            }
        }
        fn cause(&self) -> Option<&error::Error> {
            match self {
                &Error::BadArgument(ref err) => Some(err),
                &Error::Errno(_) => None,
            }
        }
    }

    impl fmt::Display for Error {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                &Error::BadArgument(ref err) =>
                    write!(f, "{}: {}", self.description(), err),
                &Error::Errno(err) =>
                    write!(f, "{}: {}", self.description(), err),
            }
        }
    }

    impl From<NulError> for Error {
        /// Convert a `NulError` into an `ExecError`.
        fn from(err: NulError) -> Error {
            Error::BadArgument(err)
        }
    }
    /// Like `try!`, but it just returns the error directly without wrapping it
    /// in `Err`.  For functions that only return if something goes wrong.
    macro_rules! exec_try {
        ( $ expr : expr ) => {
            match $expr {
                Ok(val) => val,
                Err(err) => return From::from(err),
            }
        };
    }
    /// Run `program` with `args`, completely replacing the currently running program.
    pub fn execvp<S, I>(program: S, args: I) -> Error
        where S: AsRef<OsStr>, I: IntoIterator, I::Item: AsRef<OsStr>
    {
        let program_cstring =
            exec_try!(CString::new(program.as_ref().as_bytes()));
        let arg_cstrings = exec_try!(args.into_iter().map(|arg| {
            CString::new(arg.as_ref().as_bytes())
        }).collect::<Result<Vec<_>, _>>());
        let mut arg_charptrs: Vec<_> = arg_cstrings.iter().map(|arg| {
            arg.as_ptr()
        }).collect();
        arg_charptrs.push(ptr::null());
        
        let res = unsafe {
            libc::execvp(program_cstring.as_ptr(), arg_charptrs.as_ptr())
        };
        
        if res < 0 {
            Error::Errno(errno())
        } else {
            panic!("execvp returned unexpectedly")
        }
    }
    /// Build a command to execute.  This has an API which is deliberately similar to `std::process::Command`.
    pub struct Command {
        /// The program name and arguments, in typical C `argv` style.
        argv: Vec<OsString>,
    }

    impl Command {
        /// Create a new command builder, specifying the program to run.  The
        /// program will be searched for using the usual rules for `PATH`.
        pub fn new<S: AsRef<OsStr>>(program: S) -> Command {
            Command {
                argv: vec!(program.as_ref().to_owned()),
            }
        }
        /// Add an argument to the command builder.  This can be chained.
        pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {
            self.argv.push(arg.as_ref().to_owned());
            self
        }
        /// Add multiple arguments to the command builder.
        pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command {
            for arg in args {
                self.arg(arg.as_ref());
            }
            self
        }
        /// Execute the command we built.  If this function succeeds, it will never return.
        pub fn exec(&mut self) -> Error {
            execvp(&self.argv[0], &self.argv)
        }
    }
}

pub mod execute
{
    use ::
    {
        *,
    };
    use std::collections::HashMap;
    use std::io::{self, Read, Write};

    use regex::Regex;

    use crate::core;
    use crate::libs;
    use crate::parsers;
    use crate::shell::{self, Shell};
    use crate::types::{CommandLine, CommandResult, Tokens};
    /// Entry point for non-ttys (e.g. Cmd-N on MacVim)
    pub fn run_procs_for_non_tty(sh: &mut Shell) {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();
        match handle.read_to_string(&mut buffer) {
            Ok(_) => {
                log!("run non tty command: {}", &buffer);
                run_command_line(sh, &buffer, false, false);
            }
            Err(e) => {
                println!(":: stdin.read_to_string() failed: {:?}", e);
            }
        }
    }

    pub fn run_command_line(sh: &mut Shell, line: &str, tty: bool,
                            capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();
        for token in parsers::parser_line::line_to_cmds(line) {
            if token == ";" || token == "&&" || token == "||" {
                sep = token.clone();
                continue;
            }
            if sep == "&&" && status != 0 {
                break;
            }
            if sep == "||" && status == 0 {
                break;
            }
            let cmd = token.clone();
            let cr = run_proc(sh, &cmd, tty, capture);
            status = cr.status;
            sh.previous_status = status;
            cr_list.push(cr);
        }
        cr_list
    }

    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String> {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let ptn_env_exp = r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$";
        let re = Regex::new(ptn_env_exp).unwrap();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !libs::re::re_contains(text, ptn_env_exp) {
                break;
            }

            for cap in re.captures_iter(text) {
                let name = cap[1].to_string();
                let value = parsers::parser_line::unquote(&cap[2]);
                envs.insert(name, value);
            }

            n += 1;
        }
        if n > 0 {
            tokens.drain(0..n);
        }
        envs
    }

    fn line_to_tokens(sh: &mut Shell, line: &str) -> (Tokens, HashMap<String, String>) {
        let linfo = parsers::parser_line::parse_line(line);
        let mut tokens = linfo.tokens;
        shell::do_expansion(sh, &mut tokens);
        let envs = drain_env_tokens(&mut tokens);
        (tokens, envs)
    }

    fn set_shell_vars(sh: &mut Shell, envs: &HashMap<String, String>) {
        for (name, value) in envs.iter() {
            sh.set_env(name, value);
        }
    }
    /// Run simple command or pipeline without using `&&`, `||`, `;`.
    /// example 1: `ls`
    /// example 2: `ls | wc`
    fn run_proc(sh: &mut Shell, line: &str, tty: bool,
                capture: bool) -> CommandResult {
        let log_cmd = !sh.cmd.starts_with(' ');
        match CommandLine::from_line(line, sh) {
            Ok(cl) => {
                if cl.is_empty() {
                    // for commands with only envs, e.g.
                    // $ FOO=1 BAR=2
                    // we need to define these **Shell Variables**.
                    if !cl.envs.is_empty() {
                        set_shell_vars(sh, &cl.envs);
                    }
                    return CommandResult::new();
                }

                let (term_given, cr) = core::run_pipeline(sh, &cl, tty, capture, log_cmd);
                if term_given {
                    unsafe {
                        let gid = libc::getpgid(0);
                        shell::give_terminal_to(gid);
                    }
                }

                cr
            }
            Err(e) => {
                println_stderr!(":: {}", e);
                CommandResult::from_status(0, 1)
            }
        }
    }

    fn run_with_shell(sh: &mut Shell, line: &str) -> CommandResult {
        let (tokens, envs) = line_to_tokens(sh, line);
        if tokens.is_empty() {
            set_shell_vars(sh, &envs);
            return CommandResult::new();
        }

        match CommandLine::from_line(line, sh) {
            Ok(c) => {
                let (term_given, cr) = core::run_pipeline(sh, &c, false, true, false);
                if term_given {
                    unsafe {
                        let gid = libc::getpgid(0);
                        shell::give_terminal_to(gid);
                    }
                }

                cr
            }
            Err(e) => {
                println_stderr!(":: {}", e);
                CommandResult::from_status(0, 1)
            }
        }
    }

    pub fn run(line: &str) -> CommandResult {
        let mut sh = Shell::new();
        run_with_shell(&mut sh, line)
    }

    #[cfg(test)]
    mod tests {
        use super::core::run_calculator;
        use super::run_with_shell;
        use super::shell;
        use super::libs;

        #[test]
        fn test_run_calculator() {
            assert_eq!(
                run_calculator("(1 + 2 * 3.0 - 1.5) / 0.2"),
                Ok("27.5".to_string())
            );
            assert_eq!(
                run_calculator("(5 + 2 * 3 - 4) / 3"),
                Ok("2".to_string())
            );
            assert_eq!(
                run_calculator("((2 ^ 35) + (3^7) - 9740555) / 10000000"),
                Ok("3435".to_string())
            );
        }

        #[test]
        fn test_run_itself() {
            use std::fs::File;
            use std::io::BufRead;
            use std::io::BufReader;

            let f = File::open("./tests/run_procs.txt").expect("file not found");
            let file = BufReader::new(&f);
            let mut input = String::new();
            let mut expected_stdout = String::new();
            let mut sh = shell::Shell::new();
            for (num, l) in file.lines().enumerate() {
                let line = l.unwrap();
                match num % 3 {
                    0 => {
                        input = line.clone();
                    }
                    1 => {
                        expected_stdout = line.clone();
                    }
                    2 => match run_with_shell(&mut sh, &input) {
                        cr => {
                            let ptn = if expected_stdout.is_empty() {
                                r"^$"
                            } else {
                                expected_stdout.as_str()
                            };
                            let matched = libs::re::re_contains(&cr.stdout.trim(), &ptn);
                            if !matched {
                                println!("\nSTDOUT Check Failed:");
                                println!("input: {}", &input);
                                println!("stdout: {:?}", &cr.stdout.trim());
                                println!("expected: {:?}", &expected_stdout);
                                println!("line number: {}\n", num);
                            }
                            assert!(matched);

                            let ptn = if line.is_empty() {
                                r"^$"
                            } else {
                                line.as_str()
                            };
                            let matched = libs::re::re_contains(&cr.stderr.trim(), &ptn);
                            if !matched {
                                println!("\nSTDERR Check Failed:");
                                println!("input: {}", &input);
                                println!("stderr: {:?}", &cr.stderr);
                                println!("expected: {}", &ptn);
                                println!("line number: {}\n", num + 1);
                            }
                            assert!(matched);
                        }
                    },
                    _ => {
                        assert!(false);
                    }
                }
            }
        }
    }
}

pub mod ffi
{
    pub use std::ffi::{ * };
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod glob
{
    //! Support for matching file paths against Unix shell style patterns.
    use ::
    {
        *,
    };
    
    use std::cmp;
    use std::cmp::Ordering;
    use std::error::Error;
    use std::fmt;
    use std::fs;
    use std::fs::DirEntry;
    use std::io;
    use std::ops::Deref;
    use std::path::{self, Component, Path, PathBuf};
    use std::str::FromStr;

    use CharSpecifier::{CharRange, SingleChar};
    use MatchResult::{EntirePatternDoesntMatch, Match, SubPatternDoesntMatch};
    use PatternToken::AnyExcept;
    use PatternToken::{AnyChar, AnyRecursiveSequence, AnySequence, AnyWithin, Char};
    /// An iterator that yields `Path`s from the filesystem that match a particular pattern.
    #[derive(Debug)]
    pub struct Paths {
        dir_patterns: Vec<Pattern>,
        require_dir: bool,
        options: MatchOptions,
        todo: Vec<Result<(PathWrapper, usize), GlobError>>,
        scope: Option<PathWrapper>,
    }
    /// Return an iterator that produces all the `Path`s that match the given
    /// pattern using default match options, which may be absolute or relative to
    /// the current working directory.
    pub fn glob(pattern: &str) -> Result<Paths, PatternError> {
        glob_with(pattern, MatchOptions::new())
    }
    /// Return an iterator that produces all the `Path`s that match the given
    /// pattern using the specified match options, which may be absolute or relative
    /// to the current working directory.
    pub fn glob_with(pattern: &str, options: MatchOptions) -> Result<Paths, PatternError> {
        #[cfg(windows)]
        fn check_windows_verbatim(p: &Path) -> bool {
            match p.components().next() {
                Some(Component::Prefix(ref p)) => {
                    // Allow VerbatimDisk paths. std canonicalize() generates them, and they work fine
                    p.kind().is_verbatim()
                        && if let std::path::Prefix::VerbatimDisk(_) = p.kind() {
                            false
                        } else {
                            true
                        }
                }
                _ => false,
            }
        }
        #[cfg(not(windows))]
        fn check_windows_verbatim(_: &Path) -> bool {
            false
        }

        #[cfg(windows)]
        fn to_scope(p: &Path) -> PathBuf {
            // FIXME handle volume relative paths here
            p.to_path_buf()
        }
        #[cfg(not(windows))]
        fn to_scope(p: &Path) -> PathBuf {
            p.to_path_buf()
        }

        // make sure that the pattern is valid first, else early return with error
        let _ = Pattern::new(pattern)?;

        let mut components = Path::new(pattern).components().peekable();
        loop {
            match components.peek() {
                Some(&Component::Prefix(..)) | Some(&Component::RootDir) => {
                    components.next();
                }
                _ => break,
            }
        }
        let rest = components.map(|s| s.as_os_str()).collect::<PathBuf>();
        let normalized_pattern = Path::new(pattern).iter().collect::<PathBuf>();
        let root_len = normalized_pattern.to_str().unwrap().len() - rest.to_str().unwrap().len();
        let root = if root_len > 0 {
            Some(Path::new(&pattern[..root_len]))
        } else {
            None
        };

        if root_len > 0 && check_windows_verbatim(root.unwrap()) {
            // FIXME: How do we want to handle verbatim paths? I'm inclined to
            // return nothing, since we can't very well find all UNC shares with a
            // 1-letter server name.
            return Ok(Paths {
                dir_patterns: Vec::new(),
                require_dir: false,
                options,
                todo: Vec::new(),
                scope: None,
            });
        }

        let scope = root.map_or_else(|| PathBuf::from("."), to_scope);
        let scope = PathWrapper::from_path(scope);

        let mut dir_patterns = Vec::new();
        let components =
            pattern[cmp::min(root_len, pattern.len())..].split_terminator(path::is_separator);

        for component in components {
            dir_patterns.push(Pattern::new(component)?);
        }

        if root_len == pattern.len() {
            dir_patterns.push(Pattern {
                original: "".to_string(),
                tokens: Vec::new(),
                is_recursive: false,
            });
        }

        let last_is_separator = pattern.chars().next_back().map(path::is_separator);
        let require_dir = last_is_separator == Some(true);
        let todo = Vec::new();

        Ok(Paths {
            dir_patterns,
            require_dir,
            options,
            todo,
            scope: Some(scope),
        })
    }
    /// A glob iteration error.
    #[derive(Debug)]
    pub struct GlobError {
        path: PathBuf,
        error: io::Error,
    }

    impl GlobError {
        /// The Path that the error corresponds to.
        pub fn path(&self) -> &Path {
            &self.path
        }
        /// The error in question.
        pub fn error(&self) -> &io::Error {
            &self.error
        }
        /// Consumes self, returning the _raw_ underlying `io::Error`
        pub fn into_error(self) -> io::Error {
            self.error
        }
    }

    impl Error for GlobError {
        #[allow(deprecated)]
        fn description(&self) -> &str {
            self.error.description()
        }

        #[allow(unknown_lints, bare_trait_objects)]
        fn cause(&self) -> Option<&Error> {
            Some(&self.error)
        }
    }

    impl fmt::Display for GlobError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(
                f,
                "attempting to read `{}` resulted in an error: {}",
                self.path.display(),
                self.error
            )
        }
    }

    #[derive(Debug)]
    struct PathWrapper {
        path: PathBuf,
        is_directory: bool,
    }

    impl PathWrapper {
        fn from_dir_entry(path: PathBuf, e: DirEntry) -> Self {
            let is_directory = e
                .file_type()
                .ok()
                .and_then(|file_type| {
                    // We need to use fs::metadata to resolve the actual path
                    // if it's a symlink.
                    if file_type.is_symlink() {
                        None
                    } else {
                        Some(file_type.is_dir())
                    }
                })
                .or_else(|| fs::metadata(&path).map(|m| m.is_dir()).ok())
                .unwrap_or(false);
            Self { path, is_directory }
        }
        fn from_path(path: PathBuf) -> Self {
            let is_directory = fs::metadata(&path).map(|m| m.is_dir()).unwrap_or(false);
            Self { path, is_directory }
        }

        fn into_path(self) -> PathBuf {
            self.path
        }
    }

    impl Deref for PathWrapper {
        type Target = Path;

        fn deref(&self) -> &Self::Target {
            self.path.deref()
        }
    }

    impl AsRef<Path> for PathWrapper {
        fn as_ref(&self) -> &Path {
            self.path.as_ref()
        }
    }
    /// An alias for a glob iteration result.
    ///
    /// This represents either a matched path or a glob iteration error,
    /// such as failing to read a particular directory's contents.
    pub type GlobResult = Result<PathBuf, GlobError>;

    impl Iterator for Paths {
        type Item = GlobResult;

        fn next(&mut self) -> Option<GlobResult> {
            // the todo buffer hasn't been initialized yet, so it's done at this
            // point rather than in glob() so that the errors are unified that is,
            // failing to fill the buffer is an iteration error construction of the
            // iterator (i.e. glob()) only fails if it fails to compile the Pattern
            if let Some(scope) = self.scope.take() {
                if !self.dir_patterns.is_empty() {
                    // Shouldn't happen, but we're using -1 as a special index.
                    assert!(self.dir_patterns.len() < std::usize::MAX);

                    fill_todo(&mut self.todo, &self.dir_patterns, 0, &scope, self.options);
                }
            }

            loop {
                if self.dir_patterns.is_empty() || self.todo.is_empty() {
                    return None;
                }

                let (path, mut idx) = match self.todo.pop().unwrap() {
                    Ok(pair) => pair,
                    Err(e) => return Some(Err(e)),
                };

                // idx -1: was already checked by fill_todo, maybe path was '.' or
                // '..' that we can't match here because of normalization.
                if idx == std::usize::MAX {
                    if self.require_dir && !path.is_directory {
                        continue;
                    }
                    return Some(Ok(path.into_path()));
                }

                if self.dir_patterns[idx].is_recursive {
                    let mut next = idx;

                    // collapse consecutive recursive patterns
                    while (next + 1) < self.dir_patterns.len()
                        && self.dir_patterns[next + 1].is_recursive
                    {
                        next += 1;
                    }

                    if path.is_directory {
                        // the path is a directory, so it's a match

                        // push this directory's contents
                        fill_todo(
                            &mut self.todo,
                            &self.dir_patterns,
                            next,
                            &path,
                            self.options,
                        );

                        if next == self.dir_patterns.len() - 1 {
                            // pattern ends in recursive pattern, so return this
                            // directory as a result
                            return Some(Ok(path.into_path()));
                        } else {
                            // advanced to the next pattern for this path
                            idx = next + 1;
                        }
                    } else if next == self.dir_patterns.len() - 1 {
                        // not a directory and it's the last pattern, meaning no
                        // match
                        continue;
                    } else {
                        // advanced to the next pattern for this path
                        idx = next + 1;
                    }
                }

                // not recursive, so match normally
                if self.dir_patterns[idx].matches_with(
                    {
                        match path.file_name().and_then(|s| s.to_str()) {
                            // FIXME (#9639): How do we handle non-utf8 filenames?
                            // Ignore them for now; ideally we'd still match them
                            // against a *
                            None => continue,
                            Some(x) => x,
                        }
                    },
                    self.options,
                ) {
                    if idx == self.dir_patterns.len() - 1 {
                        // it is not possible for a pattern to match a directory
                        // *AND* its children so we don't need to check the
                        // children

                        if !self.require_dir || path.is_directory {
                            return Some(Ok(path.into_path()));
                        }
                    } else {
                        fill_todo(
                            &mut self.todo,
                            &self.dir_patterns,
                            idx + 1,
                            &path,
                            self.options,
                        );
                    }
                }
            }
        }
    }
    /// A pattern parsing error.
    #[derive(Debug)]
    #[allow(missing_copy_implementations)]
    pub struct PatternError {
        /// The approximate character index of where the error occurred.
        pub pos: usize,

        /// A message describing the error.
        pub msg: &'static str,
    }

    impl Error for PatternError {
        fn description(&self) -> &str {
            self.msg
        }
    }

    impl fmt::Display for PatternError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(
                f,
                "Pattern syntax error near position {}: {}",
                self.pos, self.msg
            )
        }
    }
    /// A compiled Unix shell style pattern.
    ///
    /// - `?` matches any single character.
    ///
    /// - `*` matches any (possibly empty) sequence of characters.
    ///
    /// - `**` matches the current directory and arbitrary
    ///   subdirectories. To match files in arbitrary subdiretories, use
    ///   `**/*`.
    ///
    ///   This sequence **must** form a single path component, so both
    ///   `**a` and `b**` are invalid and will result in an error.  A
    ///   sequence of more than two consecutive `*` characters is also
    ///   invalid.
    ///
    /// - `[...]` matches any character inside the brackets.  Character sequences
    ///   can also specify ranges of characters, as ordered by Unicode, so e.g.
    ///   `[0-9]` specifies any character between 0 and 9 inclusive. An unclosed
    ///   bracket is invalid.
    ///
    /// - `[!...]` is the negation of `[...]`, i.e. it matches any characters
    ///   **not** in the brackets.
    ///
    /// - The metacharacters `?`, `*`, `[`, `]` can be matched by using brackets
    ///   (e.g. `[?]`).  When a `]` occurs immediately following `[` or `[!` then it
    ///   is interpreted as being part of, rather then ending, the character set, so
    ///   `]` and NOT `]` can be matched by `[]]` and `[!]]` respectively.  The `-`
    ///   character can be specified inside a character sequence pattern by placing
    ///   it at the start or the end, e.g. `[abc-]`.
    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Debug)]
    pub struct Pattern {
        original: String,
        tokens: Vec<PatternToken>,
        is_recursive: bool,
    }
    /// Show the original glob pattern.
    impl fmt::Display for Pattern {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.original.fmt(f)
        }
    }

    impl FromStr for Pattern {
        type Err = PatternError;

        fn from_str(s: &str) -> Result<Self, PatternError> {
            Self::new(s)
        }
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    enum PatternToken {
        Char(char),
        AnyChar,
        AnySequence,
        AnyRecursiveSequence,
        AnyWithin(Vec<CharSpecifier>),
        AnyExcept(Vec<CharSpecifier>),
    }

    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    enum CharSpecifier {
        SingleChar(char),
        CharRange(char, char),
    }

    #[derive(Copy, Clone, PartialEq)]
    enum MatchResult {
        Match,
        SubPatternDoesntMatch,
        EntirePatternDoesntMatch,
    }

    const ERROR_WILDCARDS: &str = "wildcards are either regular `*` or recursive `**`";
    const ERROR_RECURSIVE_WILDCARDS: &str = "recursive wildcards must form a single path \
                                            component";
    const ERROR_INVALID_RANGE: &str = "invalid range pattern";

    impl Pattern {
        /// This function compiles Unix shell style patterns.
        pub fn new(pattern: &str) -> Result<Self, PatternError> {
            let chars = pattern.chars().collect::<Vec<_>>();
            let mut tokens = Vec::new();
            let mut is_recursive = false;
            let mut i = 0;

            while i < chars.len() {
                match chars[i] {
                    '?' => {
                        tokens.push(AnyChar);
                        i += 1;
                    }
                    '*' => {
                        let old = i;

                        while i < chars.len() && chars[i] == '*' {
                            i += 1;
                        }

                        let count = i - old;

                        match count.cmp(&2) {
                            Ordering::Greater => {
                                return Err(PatternError {
                                    pos: old + 2,
                                    msg: ERROR_WILDCARDS,
                                })
                            }
                            Ordering::Equal => {
                                // ** can only be an entire path component
                                // i.e. a/**/b is valid, but a**/b or a/**b is not
                                // invalid matches are treated literally
                                let is_valid = if i == 2 || path::is_separator(chars[i - count - 1]) {
                                    // it ends in a '/'
                                    if i < chars.len() && path::is_separator(chars[i]) {
                                        i += 1;
                                        true
                                    // or the pattern ends here
                                    // this enables the existing globbing mechanism
                                    } else if i == chars.len() {
                                        true
                                    // `**` ends in non-separator
                                    } else {
                                        return Err(PatternError {
                                            pos: i,
                                            msg: ERROR_RECURSIVE_WILDCARDS,
                                        });
                                    }
                                // `**` begins with non-separator
                                } else {
                                    return Err(PatternError {
                                        pos: old - 1,
                                        msg: ERROR_RECURSIVE_WILDCARDS,
                                    });
                                };

                                if is_valid {
                                    // collapse consecutive AnyRecursiveSequence to a
                                    // single one

                                    let tokens_len = tokens.len();

                                    if !(tokens_len > 1
                                        && tokens[tokens_len - 1] == AnyRecursiveSequence)
                                    {
                                        is_recursive = true;
                                        tokens.push(AnyRecursiveSequence);
                                    }
                                }
                            }
                            Ordering::Less => tokens.push(AnySequence),
                        }
                    }
                    '[' => {
                        if i + 4 <= chars.len() && chars[i + 1] == '!' {
                            match chars[i + 3..].iter().position(|x| *x == ']') {
                                None => (),
                                Some(j) => {
                                    let chars = &chars[i + 2..i + 3 + j];
                                    let cs = parse_char_specifiers(chars);
                                    tokens.push(AnyExcept(cs));
                                    i += j + 4;
                                    continue;
                                }
                            }
                        } else if i + 3 <= chars.len() && chars[i + 1] != '!' {
                            match chars[i + 2..].iter().position(|x| *x == ']') {
                                None => (),
                                Some(j) => {
                                    let cs = parse_char_specifiers(&chars[i + 1..i + 2 + j]);
                                    tokens.push(AnyWithin(cs));
                                    i += j + 3;
                                    continue;
                                }
                            }
                        }

                        // if we get here then this is not a valid range pattern
                        return Err(PatternError {
                            pos: i,
                            msg: ERROR_INVALID_RANGE,
                        });
                    }
                    c => {
                        tokens.push(Char(c));
                        i += 1;
                    }
                }
            }

            Ok(Self {
                tokens,
                original: pattern.to_string(),
                is_recursive,
            })
        }
        /// Escape metacharacters within the given string by surrounding them in
        /// brackets. The resulting string will, when compiled into a `Pattern`,
        /// match the input string and nothing else.
        pub fn escape(s: &str) -> String {
            let mut escaped = String::new();
            for c in s.chars() {
                match c {
                    // note that ! does not need escaping because it is only special
                    // inside brackets
                    '?' | '*' | '[' | ']' => {
                        escaped.push('[');
                        escaped.push(c);
                        escaped.push(']');
                    }
                    c => {
                        escaped.push(c);
                    }
                }
            }
            escaped
        }
        /// Return if the given `str` matches this `Pattern` using the default
        /// match options (i.e. `MatchOptions::new()`).
        pub fn matches(&self, str: &str) -> bool {
            self.matches_with(str, MatchOptions::new())
        }
        /// Return if the given `Path`, when converted to a `str`, matches this
        /// `Pattern` using the default match options (i.e. `MatchOptions::new()`).
        pub fn matches_path(&self, path: &Path) -> bool {
            // FIXME (#9639): This needs to handle non-utf8 paths
            path.to_str().map_or(false, |s| self.matches(s))
        }
        /// Return if the given `str` matches this `Pattern` using the specified
        /// match options.
        pub fn matches_with(&self, str: &str, options: MatchOptions) -> bool {
            self.matches_from(true, str.chars(), 0, options) == Match
        }
        /// Return if the given `Path`, when converted to a `str`, matches this
        /// `Pattern` using the specified match options.
        pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool {
            // FIXME (#9639): This needs to handle non-utf8 paths
            path.to_str()
                .map_or(false, |s| self.matches_with(s, options))
        }
        /// Access the original glob pattern.
        pub fn as_str(&self) -> &str {
            &self.original
        }

        fn matches_from(
            &self,
            mut follows_separator: bool,
            mut file: std::str::Chars,
            i: usize,
            options: MatchOptions,
        ) -> MatchResult {
            for (ti, token) in self.tokens[i..].iter().enumerate() {
                match *token {
                    AnySequence | AnyRecursiveSequence => {
                        // ** must be at the start.
                        debug_assert!(match *token {
                            AnyRecursiveSequence => follows_separator,
                            _ => true,
                        });

                        // Empty match
                        match self.matches_from(follows_separator, file.clone(), i + ti + 1, options) {
                            SubPatternDoesntMatch => (), // keep trying
                            m => return m,
                        };

                        while let Some(c) = file.next() {
                            if follows_separator && options.require_literal_leading_dot && c == '.' {
                                return SubPatternDoesntMatch;
                            }
                            follows_separator = path::is_separator(c);
                            match *token {
                                AnyRecursiveSequence if !follows_separator => continue,
                                AnySequence
                                    if options.require_literal_separator && follows_separator =>
                                {
                                    return SubPatternDoesntMatch
                                }
                                _ => (),
                            }
                            match self.matches_from(
                                follows_separator,
                                file.clone(),
                                i + ti + 1,
                                options,
                            ) {
                                SubPatternDoesntMatch => (), // keep trying
                                m => return m,
                            }
                        }
                    }
                    _ => {
                        let c = match file.next() {
                            Some(c) => c,
                            None => return EntirePatternDoesntMatch,
                        };

                        let is_sep = path::is_separator(c);

                        if !match *token {
                            AnyChar | AnyWithin(..) | AnyExcept(..)
                                if (options.require_literal_separator && is_sep)
                                    || (follows_separator
                                        && options.require_literal_leading_dot
                                        && c == '.') =>
                            {
                                false
                            }
                            AnyChar => true,
                            AnyWithin(ref specifiers) => in_char_specifiers(specifiers, c, options),
                            AnyExcept(ref specifiers) => !in_char_specifiers(specifiers, c, options),
                            Char(c2) => chars_eq(c, c2, options.case_sensitive),
                            AnySequence | AnyRecursiveSequence => unreachable!(),
                        } {
                            return SubPatternDoesntMatch;
                        }
                        follows_separator = is_sep;
                    }
                }
            }
            
            if file.next().is_none() {
                Match
            } else {
                SubPatternDoesntMatch
            }
        }
    }
    
    fn fill_todo(
        todo: &mut Vec<Result<(PathWrapper, usize), GlobError>>,
        patterns: &[Pattern],
        idx: usize,
        path: &PathWrapper,
        options: MatchOptions,
    ) {
        // convert a pattern that's just many Char(_) to a string
        fn pattern_as_str(pattern: &Pattern) -> Option<String> {
            let mut s = String::new();
            for token in &pattern.tokens {
                match *token {
                    Char(c) => s.push(c),
                    _ => return None,
                }
            }

            Some(s)
        }

        let add = |todo: &mut Vec<_>, next_path: PathWrapper| {
            if idx + 1 == patterns.len() {
                // We know it's good, so don't make the iterator match this path
                // against the pattern again. In particular, it can't match
                // . or .. globs since these never show up as path components.
                todo.push(Ok((next_path, std::usize::MAX)));
            } else {
                fill_todo(todo, patterns, idx + 1, &next_path, options);
            }
        };

        let pattern = &patterns[idx];
        let is_dir = path.is_directory;
        let curdir = path.as_ref() == Path::new(".");
        match pattern_as_str(pattern) {
            Some(s) => {
                // This pattern component doesn't have any metacharacters, so we
                // don't need to read the current directory to know where to
                // continue. So instead of passing control back to the iterator,
                // we can just check for that one entry and potentially recurse
                // right away.
                let special = "." == s || ".." == s;
                let next_path = if curdir {
                    PathBuf::from(s)
                } else {
                    path.join(&s)
                };
                let next_path = PathWrapper::from_path(next_path);
                if (special && is_dir)
                    || (!special
                        && (fs::metadata(&next_path).is_ok()
                            || fs::symlink_metadata(&next_path).is_ok()))
                {
                    add(todo, next_path);
                }
            }
            None if is_dir => {
                let dirs = fs::read_dir(path).and_then(|d| {
                    d.map(|e| {
                        e.map(|e| {
                            let path = if curdir {
                                PathBuf::from(e.path().file_name().unwrap())
                            } else {
                                e.path()
                            };
                            PathWrapper::from_dir_entry(path, e)
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()
                });
                match dirs {
                    Ok(mut children) => {
                        if options.require_literal_leading_dot {
                            children
                                .retain(|x| !x.file_name().unwrap().to_str().unwrap().starts_with('.'));
                        }
                        children.sort_by(|p1, p2| p2.file_name().cmp(&p1.file_name()));
                        todo.extend(children.into_iter().map(|x| Ok((x, idx))));

                        // Matching the special directory entries . and .. that
                        // refer to the current and parent directory respectively
                        // requires that the pattern has a leading dot, even if the
                        // `MatchOptions` field `require_literal_leading_dot` is not
                        // set.
                        if !pattern.tokens.is_empty() && pattern.tokens[0] == Char('.') {
                            for &special in &[".", ".."] {
                                if pattern.matches_with(special, options) {
                                    add(todo, PathWrapper::from_path(path.join(special)));
                                }
                            }
                        }
                    }
                    Err(e) => {
                        todo.push(Err(GlobError {
                            path: path.to_path_buf(),
                            error: e,
                        }));
                    }
                }
            }
            None => {
                // not a directory, nothing more to find
            }
        }
    }

    fn parse_char_specifiers(s: &[char]) -> Vec<CharSpecifier> {
        let mut cs = Vec::new();
        let mut i = 0;
        while i < s.len() {
            if i + 3 <= s.len() && s[i + 1] == '-' {
                cs.push(CharRange(s[i], s[i + 2]));
                i += 3;
            } else {
                cs.push(SingleChar(s[i]));
                i += 1;
            }
        }
        cs
    }

    fn in_char_specifiers(specifiers: &[CharSpecifier], c: char, options: MatchOptions) -> bool {
        for &specifier in specifiers.iter() {
            match specifier {
                SingleChar(sc) => {
                    if chars_eq(c, sc, options.case_sensitive) {
                        return true;
                    }
                }
                CharRange(start, end) => {
                    // FIXME: work with non-ascii chars properly (issue #1347)
                    if !options.case_sensitive && c.is_ascii() && start.is_ascii() && end.is_ascii() {
                        let start = start.to_ascii_lowercase();
                        let end = end.to_ascii_lowercase();

                        let start_up = start.to_uppercase().next().unwrap();
                        let end_up = end.to_uppercase().next().unwrap();

                        // only allow case insensitive matching when
                        // both start and end are within a-z or A-Z
                        if start != start_up && end != end_up {
                            let c = c.to_ascii_lowercase();
                            if c >= start && c <= end {
                                return true;
                            }
                        }
                    }

                    if c >= start && c <= end {
                        return true;
                    }
                }
            }
        }

        false
    }
    /// A helper function to determine if two chars are (possibly case-insensitively) equal.
    fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {
        if cfg!(windows) && path::is_separator(a) && path::is_separator(b) {
            true
        } else if !case_sensitive && a.is_ascii() && b.is_ascii() {
            // FIXME: work with non-ascii chars properly (issue #9084)
            a.eq_ignore_ascii_case(&b)
        } else {
            a == b
        }
    }
    /// Configuration options to modify the behaviour of `Pattern::matches_with(..)`.
    #[allow(missing_copy_implementations)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    pub struct MatchOptions {
        /// Whether or not patterns should be matched in a case-sensitive manner.
        /// This currently only considers upper/lower case relationships between
        /// ASCII characters, but in future this might be extended to work with
        /// Unicode.
        pub case_sensitive: bool,

        /// Whether or not path-component separator characters (e.g. `/` on
        /// Posix) must be matched by a literal `/`, rather than by `*` or `?` or
        /// `[...]`.
        pub require_literal_separator: bool,

        /// Whether or not paths that contain components that start with a `.`
        /// will require that `.` appears literally in the pattern; `*`, `?`, `**`,
        /// or `[...]` will not match. This is useful because such files are
        /// conventionally considered hidden on Unix systems and it might be
        /// desirable to skip them when listing files.
        pub require_literal_leading_dot: bool,
    }

    impl MatchOptions {
        /// Constructs a new `MatchOptions` with default field values.
        pub fn new() -> Self {
            Self {
                case_sensitive: true,
                require_literal_separator: false,
                require_literal_leading_dot: false,
            }
        }
    }
}

pub mod hash
{
    pub use std::hash::{ * };
}

pub mod heapsize
{
    //! Data structure measurement.
    use ::
    {
        *,
    };
    /*
    #[cfg(target_os = "windows")]
    extern crate winapi;

    #[cfg(target_os = "windows")]
    use winapi::um::heapapi::{GetProcessHeap, HeapSize, HeapValidate};
    use std::borrow::Cow;
    use std::cell::{Cell, RefCell};
    use std::collections::{BTreeMap, HashSet, HashMap, LinkedList, VecDeque};
    use std::hash::BuildHasher;
    use std::hash::Hash;
    use std::marker::PhantomData;
    use std::mem::{size_of, align_of};
    use std::net::{Ipv4Addr, Ipv6Addr};
    use std::ops::{Range, RangeFrom, RangeFull, RangeTo};
    use std::os::raw::c_void;
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, AtomicIsize, AtomicUsize};
    use std::rc::Rc;
    */
    /// Get the size of a heap block.
    ///
    /// Ideally Rust would expose a function like this in std::rt::heap.
    ///
    /// `unsafe` because the caller must ensure that the pointer is from jemalloc.
    /// FIXME: This probably interacts badly with custom allocators:
    /// https://doc.rust-lang.org/book/custom-allocators.html
    pub unsafe fn heap_size_of<T>(ptr: *const T) -> usize {
        if ptr as usize <= align_of::<T>() {
            0
        } else {
            heap_size_of_impl(ptr as *const c_void)
        }
    }

    #[cfg(not(target_os = "windows"))]
    unsafe fn heap_size_of_impl(ptr: *const c_void) -> usize {
        // The C prototype is `je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr)`. On some
        // platforms `JEMALLOC_USABLE_SIZE_CONST` is `const` and on some it is empty. But in practice
        // this function doesn't modify the contents of the block that `ptr` points to, so we use
        // `*const c_void` here.
        extern "C" {
            #[cfg_attr(any(prefixed_jemalloc, target_os = "macos", target_os = "ios", target_os = "android"), link_name = "je_malloc_usable_size")]
            fn malloc_usable_size(ptr: *const c_void) -> usize;
        }
        malloc_usable_size(ptr)
    }

    #[cfg(target_os = "windows")]
    unsafe fn heap_size_of_impl(mut ptr: *const c_void) -> usize {
        let heap = GetProcessHeap();

        if HeapValidate(heap, 0, ptr) == 0 {
            ptr = *(ptr as *const *const c_void).offset(-1);
        }

        HeapSize(heap, 0, ptr) as usize
    }

    // The simplest trait for measuring the size of heap data structures. More complex traits that
    // return multiple measurements -- e.g. measure text separately from images -- are also possible,
    // and should be used when appropriate.
    //
    pub trait HeapSizeOf {
        /// Measure the size of any heap-allocated structures that hang off this value, but not the
        /// space taken up by the value itself (i.e. what size_of::<T> measures, more or less); that
        /// space is handled by the implementation of HeapSizeOf for Box<T> below.
        fn heap_size_of_children(&self) -> usize;
    }

    // There are two possible ways to measure the size of `self` when it's on the heap: compute it
    // (with `::std::rt::heap::usable_size(::std::mem::size_of::<T>(), 0)`) or measure it directly
    // using the heap allocator (with `heap_size_of`). We do the latter, for the following reasons.
    //
    // * The heap allocator is the true authority for the sizes of heap blocks; its measurement is
    //   guaranteed to be correct. In comparison, size computations are error-prone. (For example, the
    //   `rt::heap::usable_size` function used in some of Rust's non-default allocator implementations
    //   underestimate the true usable size of heap blocks, which is safe in general but would cause
    //   under-measurement here.)
    //
    // * If we measure something that isn't a heap block, we'll get a crash. This keeps us honest,
    //   which is important because unsafe code is involved and this can be gotten wrong.
    //
    // However, in the best case, the two approaches should give the same results.
    //
    impl<T: HeapSizeOf + ?Sized> HeapSizeOf for Box<T> {
        fn heap_size_of_children(&self) -> usize {
            // Measure size of `self`.
            unsafe {
                heap_size_of(&**self as *const T as *const c_void) + (**self).heap_size_of_children()
            }
        }
    }

    impl<T: HeapSizeOf> HeapSizeOf for [T] {
        fn heap_size_of_children(&self) -> usize {
            self.iter().fold(0, |size, item| size + item.heap_size_of_children())
        }
    }

    impl HeapSizeOf for String {
        fn heap_size_of_children(&self) -> usize {
            unsafe {
                heap_size_of(self.as_ptr())
            }
        }
    }

    impl<'a, T: ?Sized> HeapSizeOf for &'a T {
        fn heap_size_of_children(&self) -> usize {
            0
        }
    }

    // The implementations for *mut T and *const T are designed for use cases like LinkedHashMap where
    // you have a data structure which internally maintains an e.g. HashMap parameterized with raw
    // pointers. We want to be able to rely on the standard HeapSizeOf implementation for `HashMap`,
    // and can handle the contribution of the raw pointers manually.
    //
    // These have to return 0 since we don't know if the pointer is pointing to a heap allocation or
    // even valid memory.
    impl<T: ?Sized> HeapSizeOf for *mut T {
        fn heap_size_of_children(&self) -> usize {
            0
        }
    }

    impl<T: ?Sized> HeapSizeOf for *const T {
        fn heap_size_of_children(&self) -> usize {
            0
        }
    }

    impl<T: HeapSizeOf> HeapSizeOf for Option<T> {
        fn heap_size_of_children(&self) -> usize {
            match *self {
                None => 0,
                Some(ref x) => x.heap_size_of_children()
            }
        }
    }

    impl<T: HeapSizeOf, E: HeapSizeOf> HeapSizeOf for Result<T, E> {
        fn heap_size_of_children(&self) -> usize {
            match *self {
                Ok(ref x) => x.heap_size_of_children(),
                Err(ref e) => e.heap_size_of_children(),
            }
        }
    }

    impl<'a, B: ?Sized + ToOwned> HeapSizeOf for Cow<'a, B> where B::Owned: HeapSizeOf {
        fn heap_size_of_children(&self) -> usize {
            match *self {
                Cow::Borrowed(_) => 0,
                Cow::Owned(ref b) => b.heap_size_of_children(),
            }
        }
    }

    impl HeapSizeOf for () {
        fn heap_size_of_children(&self) -> usize {
            0
        }
    }

    impl<T1, T2> HeapSizeOf for (T1, T2)
        where T1: HeapSizeOf, T2 :HeapSizeOf
    {
        fn heap_size_of_children(&self) -> usize {
            self.0.heap_size_of_children() +
                self.1.heap_size_of_children()
        }
    }

    impl<T1, T2, T3> HeapSizeOf for (T1, T2, T3)
        where T1: HeapSizeOf, T2 :HeapSizeOf, T3: HeapSizeOf
    {
        fn heap_size_of_children(&self) -> usize {
            self.0.heap_size_of_children() +
                self.1.heap_size_of_children() +
                self.2.heap_size_of_children()
        }
    }

    impl<T1, T2, T3, T4> HeapSizeOf for (T1, T2, T3, T4)
        where T1: HeapSizeOf, T2 :HeapSizeOf, T3: HeapSizeOf, T4: HeapSizeOf
    {
        fn heap_size_of_children(&self) -> usize {
            self.0.heap_size_of_children() +
                self.1.heap_size_of_children() +
                self.2.heap_size_of_children() +
                self.3.heap_size_of_children()
    }
    }

    impl<T1, T2, T3, T4, T5> HeapSizeOf for (T1, T2, T3, T4, T5)
        where T1: HeapSizeOf, T2 :HeapSizeOf, T3: HeapSizeOf, T4: HeapSizeOf, T5: HeapSizeOf
    {
        fn heap_size_of_children(&self) -> usize {
            self.0.heap_size_of_children() +
                self.1.heap_size_of_children() +
                self.2.heap_size_of_children() +
                self.3.heap_size_of_children() +
                self.4.heap_size_of_children()
    }
    }

    impl<T: HeapSizeOf> HeapSizeOf for Arc<T> {
        fn heap_size_of_children(&self) -> usize {
            (**self).heap_size_of_children()
        }
    }

    impl<T: HeapSizeOf> HeapSizeOf for RefCell<T> {
        fn heap_size_of_children(&self) -> usize {
            self.borrow().heap_size_of_children()
        }
    }

    impl<T: HeapSizeOf + Copy> HeapSizeOf for Cell<T> {
        fn heap_size_of_children(&self) -> usize {
            self.get().heap_size_of_children()
        }
    }

    impl<T: HeapSizeOf> HeapSizeOf for Vec<T> {
        fn heap_size_of_children(&self) -> usize {
            self.iter().fold(
                unsafe { heap_size_of(self.as_ptr()) },
                |n, elem| n + elem.heap_size_of_children())
        }
    }

    impl<T: HeapSizeOf> HeapSizeOf for VecDeque<T> {
        fn heap_size_of_children(&self) -> usize {
            self.iter().fold(
                // FIXME: get the buffer pointer for heap_size_of(), capacity() is a lower bound:
                self.capacity() * size_of::<T>(),
                |n, elem| n + elem.heap_size_of_children())
        }
    }

    impl<T> HeapSizeOf for Vec<Rc<T>> {
        fn heap_size_of_children(&self) -> usize {
            // The fate of measuring Rc<T> is still undecided, but we still want to measure
            // the space used for storing them.
            unsafe {
                heap_size_of(self.as_ptr())
            }
        }
    }

    impl<T: HeapSizeOf, S> HeapSizeOf for HashSet<T, S>
        where T: Eq + Hash, S: BuildHasher {
        fn heap_size_of_children(&self) -> usize {
            //TODO(#6908) measure actual bucket memory usage instead of approximating
            let size = self.capacity() * (size_of::<T>() + size_of::<usize>());
            self.iter().fold(size, |n, value| {
                n + value.heap_size_of_children()
            })
        }
    }

    impl<K: HeapSizeOf, V: HeapSizeOf, S> HeapSizeOf for HashMap<K, V, S>
        where K: Eq + Hash, S: BuildHasher {
        fn heap_size_of_children(&self) -> usize {
            //TODO(#6908) measure actual bucket memory usage instead of approximating
            let size = self.capacity() * (size_of::<V>() + size_of::<K>() + size_of::<usize>());
            self.iter().fold(size, |n, (key, value)| {
                n + key.heap_size_of_children() + value.heap_size_of_children()
            })
        }
    }

    // PhantomData is always 0.
    impl<T> HeapSizeOf for PhantomData<T> {
        fn heap_size_of_children(&self) -> usize {
            0
        }
    }

    // A linked list has an overhead of two words per item.
    impl<T: HeapSizeOf> HeapSizeOf for LinkedList<T> {
        fn heap_size_of_children(&self) -> usize {
            let mut size = 0;
            for item in self {
                size += 2 * size_of::<usize>() + size_of::<T>() + item.heap_size_of_children();
            }
            size
        }
    }

    // FIXME: Overhead for the BTreeMap nodes is not accounted for.
    impl<K: HeapSizeOf, V: HeapSizeOf> HeapSizeOf for BTreeMap<K, V> {
        fn heap_size_of_children(&self) -> usize {
            let mut size = 0;
            for (key, value) in self.iter() {
                size += size_of::<(K, V)>() +
                        key.heap_size_of_children() +
                        value.heap_size_of_children();
            }
            size
        }
    }

    impl<T> HeapSizeOf for Range<T>
    where
        T: HeapSizeOf,
    {
        fn heap_size_of_children(&self) -> usize {
            self.start.heap_size_of_children() + self.end.heap_size_of_children()
        }
    }

    impl<T> HeapSizeOf for RangeFrom<T>
    where
        T: HeapSizeOf,
    {
        fn heap_size_of_children(&self) -> usize {
            self.start.heap_size_of_children()
        }
    }

    impl<T> HeapSizeOf for RangeTo<T>
    where
        T: HeapSizeOf,
    {
        fn heap_size_of_children(&self) -> usize {
            self.end.heap_size_of_children()
        }
    }

    /// For use on types defined in external crates
    /// with known heap sizes.
    #[macro_export]
    macro_rules! known_heap_size(
        ($size:expr, $($ty:ty),+) => (
            $(
                impl $crate::HeapSizeOf for $ty {
                    #[inline(always)]
                    fn heap_size_of_children(&self) -> usize {
                        $size
                    }
                }
            )+
        );
        ($size: expr, $($ty:ident<$($gen:ident),+>),+) => (
            $(
            impl<$($gen: $crate::HeapSizeOf),+> $crate::HeapSizeOf for $ty<$($gen),+> {
                #[inline(always)]
                fn heap_size_of_children(&self) -> usize {
                    $size
                }
            }
            )+
        );
    );

    known_heap_size!(0, char, str);
    known_heap_size!(0, u8, u16, u32, u64, usize);
    known_heap_size!(0, i8, i16, i32, i64, isize);
    known_heap_size!(0, bool, f32, f64);
    known_heap_size!(0, AtomicBool, AtomicIsize, AtomicUsize);
    known_heap_size!(0, Ipv4Addr, Ipv6Addr, RangeFull);
}

pub mod highlight
{
    use ::
    {
        *,
    };
    use std::ops::Range;
    use std::sync::Arc;
    use std::collections::HashSet;
    use std::path::Path;
    use std::env;
    use std::fs;
    use std::sync::Mutex;
    use std::os::unix::fs::PermissionsExt;

    use lineread::highlighting::{Highlighter, Style};

    use crate::tools;
    use crate::shell;
    use crate::parsers::parser_line;

    #[derive(Clone)]
    pub struct CicadaHighlighter;

    const GREEN: &str = "\x01\x1b[0;32m\x02";

    lazy_static! {
        static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
        static ref ALIASES: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
    }
    /// Initialize the available commands cache by scanning PATH directories
    pub fn init_command_cache() {
        let commands = scan_available_commands();
        if let Ok(mut cache) = AVAILABLE_COMMANDS.lock() {
            *cache = commands;
        }
    }
    /// Update aliases in the highlighter's cache
    pub fn update_aliases(sh: &shell::Shell) {
        if let Ok(mut aliases) = ALIASES.lock() {
            aliases.clear();
            for alias_name in sh.aliases.keys() {
                aliases.insert(alias_name.clone());
            }
        }
    }

    fn scan_available_commands() -> HashSet<String> {
        let mut commands = HashSet::new();

        if let Ok(path_var) = env::var("PATH") {
            for path in path_var.split(':') {
                if path.is_empty() {
                    continue;
                }

                let dir_path = Path::new(path);
                if !dir_path.is_dir() {
                    continue;
                }

                if let Ok(entries) = fs::read_dir(dir_path) {
                    for entry in entries.filter_map(Result::ok) {
                        if let Ok(file_type) = entry.file_type() {
                            if file_type.is_file() || file_type.is_symlink() {
                                if let Ok(metadata) = entry.metadata() {
                                    // Check if file is executable
                                    if metadata.permissions().mode() & 0o111 != 0 {
                                        if let Some(name) = entry.file_name().to_str() {
                                            commands.insert(name.to_string());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        commands
    }

    fn is_command(word: &str) -> bool {
        if tools::is_builtin(word) {
            return true;
        }
        if let Ok(aliases) = ALIASES.lock() {
            if aliases.contains(word) {
                return true;
            }
        }
        if let Ok(commands) = AVAILABLE_COMMANDS.lock() {
            if commands.contains(word) {
                return true;
            }
        }
        false
    }

    fn find_token_range_heuristic(line: &str, start_byte: usize, token: &(String, String)) -> Option<Range<usize>> {
        let (sep, word) = token;

        // Find the start of the token, skipping leading whitespace from the search start position
        let mut search_area = &line[start_byte..];
        let token_start_byte = if let Some(non_ws_offset) = search_area.find(|c: char| !c.is_whitespace()) {
            // Calculate the actual byte index of the first non-whitespace character
            start_byte + search_area.char_indices().nth(non_ws_offset).map_or(0, |(idx, _)| idx)
        } else {
            return None; // Only whitespace left
        };

        search_area = &line[token_start_byte..];

        // Estimate the end byte based on the token structure
        let mut estimated_len = 0;
        let mut current_search_offset = 0;

        // Match separator prefix if needed (e.g., `"` or `'`)
        if !sep.is_empty() && search_area.starts_with(sep) {
            estimated_len += sep.len();
            current_search_offset += sep.len();
        }

        // Match the word content
        // Use starts_with for a basic check, assuming the word appears next
        if search_area[current_search_offset..].starts_with(word) {
            estimated_len += word.len();
            current_search_offset += word.len();

            // Match separator suffix if needed
            if !sep.is_empty() && search_area[current_search_offset..].starts_with(sep) {
                estimated_len += sep.len();
            }

            Some(token_start_byte..(token_start_byte + estimated_len))

        } else if word.is_empty() && !sep.is_empty() && search_area.starts_with(sep) && search_area[sep.len()..].starts_with(sep) {
            // Handle empty quoted string like "" or ''
            estimated_len += sep.len() * 2;
            Some(token_start_byte..(token_start_byte + estimated_len))
        }
        else {
            // Fallback: Maybe it's just the word without quotes, or a separator like `|`
            if search_area.starts_with(word) {
                Some(token_start_byte..(token_start_byte + word.len()))
            } else {
                // Could not reliably map the token back to the original string segment
                // This might happen with complex escapes or parser ambiguities
                // As a basic fallback, consume up to the next space or end of line? Unsafe.
                // Return None to signal failure for this token.
                None
            }
        }
    }

    impl Highlighter for CicadaHighlighter {
        fn highlight(&self, line: &str) -> Vec<(Range<usize>, Style)> {
            let mut styles = Vec::new();
            if line.is_empty() {
                return styles;
            }

            let line_info = parser_line::parse_line(line);
            if line_info.tokens.is_empty() {
                // If parser returns no tokens, style whole line as default
                styles.push((0..line.len(), Style::Default));
                return styles;
            }

            let mut current_byte_idx = 0;
            let mut is_start_of_segment = true;

            for token in &line_info.tokens {
                // Find the range in the original line for this token
                match find_token_range_heuristic(line, current_byte_idx, token) {
                    Some(token_range) => {
                        // Style potential whitespace before the token
                        if token_range.start > current_byte_idx {
                            styles.push((current_byte_idx..token_range.start, Style::Default));
                        }

                        let (_sep, word) = token;
                        let mut current_token_style = Style::Default;

                        if is_start_of_segment && !word.is_empty() {
                            if is_command(word) {
                                current_token_style = Style::AnsiColor(GREEN.to_string());
                            }
                            // Only the first non-empty token in a segment can be a command
                            is_start_of_segment = false;
                        }

                        styles.push((token_range.clone(), current_token_style));

                        // Check if this token marks the end of a command segment
                        if ["|", "&&", "||", ";"].contains(&word.as_str()) {
                            is_start_of_segment = true;
                        }

                        current_byte_idx = token_range.end;
                    }
                    None => {
                        // If we can't map a token, style the rest of the line as default and stop.
                        if current_byte_idx < line.len() {
                        styles.push((current_byte_idx..line.len(), Style::Default));
                        }
                        current_byte_idx = line.len(); // Mark as done
                        break; // Stop processing further tokens
                    }
                }
            }

            // Style any remaining characters after the last processed token
            if current_byte_idx < line.len() {
                styles.push((current_byte_idx..line.len(), Style::Default));
            }

            styles
        }
    }

    pub fn create_highlighter() -> Arc<CicadaHighlighter> {
        Arc::new(CicadaHighlighter)
    }
}

pub mod hint
{
    pub use std::hint::{ * };
}

pub mod history
{
    use ::
    {
        *,
    };
    use std::collections::HashMap;
    use std::env;
    use std::fs;
    use std::io::Write;
    use std::path::Path;

    use lineread::terminal::DefaultTerminal;
    use lineread::Interface;
    use rusqlite::Connection as Conn;
    use rusqlite::Error::SqliteFailure;

    use crate::shell;
    use crate::tools;

    fn init_db(hfile: &str, htable: &str) {
        let path = Path::new(hfile);
        if !path.exists() {
            let _parent = match path.parent() {
                Some(x) => x,
                None => {
                    println_stderr!(":: history init - no parent found");
                    return;
                }
            };
            let parent = match _parent.to_str() {
                Some(x) => x,
                None => {
                    println_stderr!(":: parent to_str is None");
                    return;
                }
            };
            match fs::create_dir_all(parent) {
                Ok(_) => {}
                Err(e) => {
                    println_stderr!(":: histdir create error: {}", e);
                    return;
                }
            }
            match fs::File::create(hfile) {
                Ok(_) => {
                    println!(":: created history file: {}", hfile);
                }
                Err(e) => {
                    println_stderr!(":: history: file create failed: {}", e);
                }
            }
        }

        let conn = match Conn::open(hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!(":: history: open db error: {}", e);
                return;
            }
        };
        let sql = format!(
            "
            CREATE TABLE IF NOT EXISTS {}
                (inp TEXT,
                rtn INTEGER,
                tsb REAL,
                tse REAL,
                sessionid TEXT,
                out TEXT,
                info TEXT
                );
        ",
            htable
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => println_stderr!(":: history: query error: {}", e),
        }
    }

    pub fn init(rl: &mut Interface<DefaultTerminal>) {
        let mut hist_size: usize = 99999;
        if let Ok(x) = env::var("HISTORY_SIZE") {
            if let Ok(y) = x.parse::<usize>() {
                hist_size = y;
            }
        }
        rl.set_history_size(hist_size);

        let history_table = get_history_table();
        let hfile = get_history_file();

        if !Path::new(&hfile).exists() {
            init_db(&hfile, &history_table);
        }

        let mut delete_dups = true;
        if let Ok(x) = env::var("HISTORY_DELETE_DUPS") {
            if x == "0" {
                delete_dups = false;
            }
        }
        if delete_dups {
            delete_duplicated_histories();
        }

        let conn = match Conn::open(&hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!(":: history: conn error: {}", e);
                return;
            }
        };
        let sql = format!("SELECT inp FROM {} ORDER BY tsb;", history_table);
        let mut stmt = match conn.prepare(&sql) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!(":: prepare select error: {}", e);
                return;
            }
        };

        let rows = match stmt.query_map([], |row| row.get(0)) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!(":: query select error: {}", e);
                return;
            }
        };

        let mut dict_helper: HashMap<String, bool> = HashMap::new();
        for x in rows.flatten() {
            let inp: String = x;
            if dict_helper.contains_key(&inp) {
                continue;
            }
            dict_helper.insert(inp.clone(), true);
            rl.add_history(inp.trim().to_string());
        }
    }

    pub fn get_history_file() -> String {
        if let Ok(hfile) = env::var("HISTORY_FILE") {
            hfile
        } else if let Ok(d) = env::var("XDG_DATA_HOME") {
            format!("{}/{}", d, "cicada/history.sqlite")
        } else {
            let home = tools::get_user_home();
            format!("{}/{}", home, ".local/share/cicada/history.sqlite")
        }
    }

    pub fn get_history_table() -> String {
        if let Ok(hfile) = env::var("HISTORY_TABLE") {
            hfile
        } else {
            String::from("cicada_history")
        }
    }

    fn delete_duplicated_histories() {
        let hfile = get_history_file();
        let history_table = get_history_table();
        let conn = match Conn::open(&hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!(":: history: conn error: {}", e);
                return;
            }
        };
        let sql = format!(
            "DELETE FROM {} WHERE rowid NOT IN (
            SELECT MAX(rowid) FROM {} GROUP BY inp)",
            history_table, history_table
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => match e {
                SqliteFailure(ee, msg) => {
                    if ee.extended_code == 5 {
                        log!(
                            "failed to delete dup histories: {}",
                            msg.unwrap_or("db is locked?".to_owned()),
                        );
                        return;
                    }
                    println_stderr!(
                        ":: history: delete dups error: {}: {:?}",
                        &ee,
                        &msg
                    );
                }
                _ => {
                    println_stderr!(":: history: delete dup error: {}", e);
                }
            },
        }
    }

    pub fn add_raw(sh: &shell::Shell, line: &str, status: i32,
                tsb: f64, tse: f64) {
        let hfile = get_history_file();
        let history_table = get_history_table();
        if !Path::new(&hfile).exists() {
            init_db(&hfile, &history_table);
        }

        let conn = match Conn::open(&hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!(":: history: conn error: {}", e);
                return;
            }
        };
        let sql = format!(
            "INSERT INTO \
            {} (inp, rtn, tsb, tse, sessionid, info) \
            VALUES('{}', {}, {}, {}, '{}', 'dir:{}|');",
            history_table,
            str::replace(line.trim(), "'", "''"),
            status,
            tsb,
            tse,
            sh.session_id,
            sh.current_dir,
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => println_stderr!(":: history: save error: {}", e),
        }
    }

    pub fn add(sh: &shell::Shell, rl: &mut Interface<DefaultTerminal>, line: &str,
            status: i32, tsb: f64, tse: f64) {
        add_raw(sh, line, status, tsb, tse);
        rl.add_history(line.to_string());
    }
}

pub mod intrinsics
{
    //! Compiler intrinsics.
    use ::
    {
        marker::{ DiscriminantKind, Tuple },
        sync::atomic::{ self, AtomicBool, AtomicI32, AtomicIsize, AtomicU32, Ordering },
        mem::{ SizedTypeProperties },
        *,
    };
    /*
    use crate::marker::{DiscriminantKind, Tuple};
    use crate::mem::SizedTypeProperties;
    use crate::{ptr, ub_checks};
    */

    pub mod fallback
    {
        use ::
        { 
            *,
        };
    }

    pub mod mir
    {
        use ::
        { 
            *,
        };
    }

    pub mod simd
    {
        use ::
        { 
            *,
        };
    }
    /// Stores the value at the specified memory location.
    #[rustc_intrinsic] #[rustc_nounwind]
    pub unsafe fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);
    /// Stores the value at the specified memory location.
    #[rustc_intrinsic] #[rustc_nounwind]
    pub unsafe fn atomic_store_release<T: Copy>(dst: *mut T, val: T);
    /// Stores the value at the specified memory location.
    #[rustc_intrinsic] #[rustc_nounwind]
    pub unsafe fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);
    /// Do NOT use this intrinsic; "unordered" operations do not exist in our memory model!
    #[rustc_intrinsic] #[rustc_nounwind]
    pub unsafe fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);
}

pub mod io
{
    pub use std::io::{ * };
} use std::io::Write;

pub mod iter
{
    pub use std::iter::{ * };
}

pub mod jobc
{
    use ::
    {
        *,
    };
    use std::io::Write;

    use nix::sys::signal::Signal;
    use nix::sys::wait::waitpid;
    use nix::sys::wait::WaitPidFlag as WF;
    use nix::sys::wait::WaitStatus as WS;
    use nix::unistd::Pid;

    use crate::shell;
    use crate::signals;
    use crate::types::{self, CommandResult};

    pub fn get_job_line(job: &types::Job, trim: bool) -> String {
        let mut cmd = job.cmd.clone();
        if trim && cmd.len() > 50 {
            cmd.truncate(50);
            cmd.push_str(" ...");
        }
        let _cmd = if job.is_bg && job.status == "Running" {
            format!("{} &", cmd)
        } else {
            cmd
        };
        format!("[{}] {}  {}   {}", job.id, job.gid, job.status, _cmd)
    }

    pub fn print_job(job: &types::Job) {
        let line = get_job_line(job, true);
        println_stderr!("{}", line);
    }

    pub fn mark_job_as_done(sh: &mut shell::Shell, gid: i32, pid: i32, reason: &str) {
        if let Some(mut job) = sh.remove_pid_from_job(gid, pid) {
            job.status = reason.to_string();
            if job.is_bg {
                println_stderr!("");
                print_job(&job);
            }
        }
    }

    pub fn mark_job_as_stopped(sh: &mut shell::Shell, gid: i32, report: bool) {
        sh.mark_job_as_stopped(gid);
        if !report {
            return;
        }

        // add an extra line to separate output of fg commands if any.
        if let Some(job) = sh.get_job_by_gid(gid) {
            println_stderr!("");
            print_job(job);
        }
    }

    pub fn mark_job_member_stopped(sh: &mut shell::Shell, pid: i32, gid: i32, report: bool) {
        let _gid = if gid == 0 {
            unsafe { libc::getpgid(pid) }
        } else {
            gid
        };

        if let Some(job) = sh.mark_job_member_stopped(pid, gid) {
            if job.all_members_stopped() {
                mark_job_as_stopped(sh, gid, report);
            }
        }
    }

    pub fn mark_job_member_continued(sh: &mut shell::Shell, pid: i32, gid: i32) {
        let _gid = if gid == 0 {
            unsafe { libc::getpgid(pid) }
        } else {
            gid
        };

        if let Some(job) = sh.mark_job_member_continued(pid, gid) {
            if job.all_members_running() {
                mark_job_as_running(sh, gid, true);
            }
        }
    }

    pub fn mark_job_as_running(sh: &mut shell::Shell, gid: i32, bg: bool) {
        sh.mark_job_as_running(gid, bg);
    }

    #[allow(unreachable_patterns)]
    pub fn waitpidx(wpid: i32, block: bool) -> types::WaitStatus {
        let options = if block {
            Some(WF::WUNTRACED | WF::WCONTINUED)
        } else {
            Some(WF::WUNTRACED | WF::WCONTINUED | WF::WNOHANG)
        };
        match waitpid(Pid::from_raw(wpid), options) {
            Ok(WS::Exited(pid, status)) => {
                let pid = i32::from(pid);
                types::WaitStatus::from_exited(pid, status)
            }
            Ok(WS::Stopped(pid, sig)) => {
                let pid = i32::from(pid);
                types::WaitStatus::from_stopped(pid, sig as i32)
            }
            Ok(WS::Continued(pid)) => {
                let pid = i32::from(pid);
                types::WaitStatus::from_continuted(pid)
            }
            Ok(WS::Signaled(pid, sig, _core_dumped)) => {
                let pid = i32::from(pid);
                types::WaitStatus::from_signaled(pid, sig as i32)
            }
            Ok(WS::StillAlive) => {
                types::WaitStatus::empty()
            }
            Ok(_others) => {
                // this is for PtraceEvent and PtraceSyscall on Linux,
                // unreachable on other platforms.
                types::WaitStatus::from_others()
            }
            Err(e) => {
                types::WaitStatus::from_error(e as i32)
            }
        }
    }

    pub fn wait_fg_job(sh: &mut shell::Shell, gid: i32, pids: &[i32]) -> CommandResult {
        let mut cmd_result = CommandResult::new();
        let mut count_waited = 0;
        let count_child = pids.len();
        if count_child == 0 {
            return cmd_result;
        }
        let pid_last = pids.last().unwrap();

        loop {
            let ws = waitpidx(-1, true);
            // here when we calling waitpidx(), all signals should have
            // been masked. There should no errors (ECHILD/EINTR etc) happen.
            if ws.is_error() {
                let err = ws.get_errno();
                if err == nix::Error::ECHILD {
                    break;
                }

                log!("jobc unexpected waitpid error: {}", err);
                cmd_result = CommandResult::from_status(gid, err as i32);
                break;
            }

            let pid = ws.get_pid();
            let is_a_fg_child = pids.contains(&pid);
            if is_a_fg_child && !ws.is_continued() {
                count_waited += 1;
            }

            if ws.is_exited() {
                if is_a_fg_child {
                    mark_job_as_done(sh, gid, pid, "Done");
                } else {
                    let status = ws.get_status();
                    signals::insert_reap_map(pid, status);
                }
            } else if ws.is_stopped() {
                if is_a_fg_child {
                    // for stop signal of fg job (current job)
                    // i.e. Ctrl-Z is pressed on the fg job
                    mark_job_member_stopped(sh, pid, gid, true);
                } else {
                    // for stop signal of bg jobs
                    signals::insert_stopped_map(pid);
                    mark_job_member_stopped(sh, pid, 0, false);
                }
            } else if ws.is_continued() {
                if !is_a_fg_child {
                    signals::insert_cont_map(pid);
                }
                continue;
            } else if ws.is_signaled() {
                if is_a_fg_child {
                    mark_job_as_done(sh, gid, pid, "Killed");
                } else {
                    signals::killed_map_insert(pid, ws.get_signal());
                }
            }

            if is_a_fg_child && pid == *pid_last {
                let status = ws.get_status();
                cmd_result.status = status;
            }

            if count_waited >= count_child {
                break;
            }
        }
        cmd_result
    }

    pub fn try_wait_bg_jobs(sh: &mut shell::Shell, report: bool, sig_handler_enabled: bool) {
        if sh.jobs.is_empty() {
            return;
        }

        if !sig_handler_enabled {
            // we need to wait pids in case CICADA_ENABLE_SIG_HANDLER=0
            signals::handle_sigchld(Signal::SIGCHLD as i32);
        }

        let jobs = sh.jobs.clone();
        for (_i, job) in jobs.iter() {
            for pid in job.pids.iter() {
                if let Some(_status) = signals::pop_reap_map(*pid) {
                    mark_job_as_done(sh, job.gid, *pid, "Done");
                    continue;
                }

                if let Some(sig) = signals::killed_map_pop(*pid) {
                    let reason = if sig == Signal::SIGQUIT as i32 {
                        format!("Quit: {}", sig)
                    } else if sig == Signal::SIGINT as i32 {
                        format!("Interrupt: {}", sig)
                    } else if sig == Signal::SIGKILL as i32 {
                        format!("Killed: {}", sig)
                    } else if sig == Signal::SIGTERM as i32 {
                        format!("Terminated: {}", sig)
                    } else {
                        format!("Killed: {}", sig)
                    };
                    mark_job_as_done(sh, job.gid, *pid, &reason);
                    continue;
                }

                if signals::pop_stopped_map(*pid) {
                    mark_job_member_stopped(sh, *pid, job.gid, report);
                } else if signals::pop_cont_map(*pid) {
                    mark_job_member_continued(sh, *pid, job.gid);
                }
            }
        }
    }
}

pub mod libs
{
    use ::
    {
        *,
    };

    pub mod colored
    {
        use ::
        {
            *,
        };
        // setting prompt in crate lineread needs wrap every SEQ chars
        // with prefixing with '\x01' and suffix with '\x02'.
        // Color Reference: https://misc.flogisoft.com/bash/tip_colors_and_formatting

        // cicada special
        pub const SEQ: &str = "\x01";
        pub const END_SEQ: &str = "\x02";
        pub const ESC: &str = "\x1B";

        // Set
        pub const BOLD: &str = "\x01\x1B[1m\x02";
        pub const DIM: &str = "\x01\x1B[2m\x02";
        pub const UNDERLINED: &str = "\x01\x1B[4m\x02";
        pub const BLINK: &str = "\x01\x1B[5m\x02";
        pub const REVERSE: &str = "\x01\x1B[7m\x02";
        pub const HIDDEN: &str = "\x01\x1B[8m\x02";

        // Reset
        pub const RESET: &str = "\x01\x1B[0m\x02";
        pub const RESET_BOLD: &str = "\x01\x1B[21m\x02";
        pub const RESET_DIM: &str = "\x01\x1B[22m\x02";
        pub const RESET_UNDERLINED: &str = "\x01\x1B[24m\x02";
        pub const RESET_BLINK: &str = "\x01\x1B[25m\x02";
        pub const RESET_REVERSE: &str = "\x01\x1B[27m\x02";
        pub const RESET_HIDDEN: &str = "\x01\x1B[28m\x02";

        // Foreground (text)
        pub const DEFAULT: &str = "\x01\x1B[39m\x02";
        pub const BLACK: &str = "\x01\x1B[30m\x02";
        pub const RED: &str = "\x01\x1B[31m\x02";
        pub const GREEN: &str = "\x01\x1B[32m\x02";
        pub const YELLOW: &str = "\x01\x1B[33m\x02";
        pub const BLUE: &str = "\x01\x1B[34m\x02";
        pub const MAGENTA: &str = "\x01\x1B[35m\x02";
        pub const CYAN: &str = "\x01\x1B[36m\x02";
        pub const GRAY_L: &str = "\x01\x1B[37m\x02";

        pub const GRAY_D: &str = "\x01\x1B[90m\x02";
        pub const RED_L: &str = "\x01\x1B[91m\x02";
        pub const GREEN_L: &str = "\x01\x1B[92m\x02";
        pub const YELLOW_L: &str = "\x01\x1B[93m\x02";
        pub const BLUE_L: &str = "\x01\x1B[94m\x02";
        pub const MAGENTA_L: &str = "\x01\x1B[95m\x02";
        pub const CYAN_L: &str = "\x01\x1B[96m\x02";
        pub const WHITE: &str = "\x01\x1B[97m\x02";

        pub const BLUE_B: &str = "\x01\x1B[34m\x1B[1m\x02";
        pub const BLACK_B: &str = "\x01\x1B[30m\x1B[1m\x02";
        pub const WHITE_B: &str = "\x01\x1B[97m\x1B[1m\x02";
        pub const RED_B: &str = "\x01\x1B[31m\x1B[1m\x02";
        pub const GREEN_B: &str = "\x01\x1B[32m\x1B[1m\x02";

        // Background
        pub const DEFAULT_BG: &str = "\x01\x1B[49m\x02";
        pub const BLACK_BG: &str   = "\x01\x1B[40m\x02";
        pub const RED_BG: &str     = "\x01\x1B[41m\x02";
        pub const GREEN_BG: &str   = "\x01\x1B[42m\x02";
        pub const YELLOW_BG: &str   = "\x01\x1B[43m\x02";
        pub const BLUE_BG: &str    = "\x01\x1B[44m\x02";
        pub const MAGENTA_BG: &str    = "\x01\x1B[45m\x02";
        pub const CYAN_BG: &str    = "\x01\x1B[46m\x02";
        pub const GRAY_L_BG: &str    = "\x01\x1B[47m\x02";

        pub const GRAY_D_BG: &str   = "\x01\x1B[100m\x02";
        pub const RED_L_BG: &str   = "\x01\x1B[101m\x02";
        pub const GREEN_L_BG: &str   = "\x01\x1B[102m\x02";
        pub const YELLOW_L_BG: &str   = "\x01\x1B[103m\x02";
        pub const BLUE_L_BG: &str   = "\x01\x1B[104m\x02";
        pub const MAGENTA_L_BG: &str   = "\x01\x1B[105m\x02";
        pub const CYAN_L_BG: &str   = "\x01\x1B[106m\x02";
        pub const WHITE_BG: &str   = "\x01\x1B[107m\x02";
    }

    pub mod fork
    {
        use ::
        {
            *,
        };
        use nix::Result;
        use nix::unistd::{fork as nix_fork, ForkResult};

        // make fork "safe again", in order not to touch the code in core.rs,
        // see https://github.com/nix-rust/nix/issues/586
        // we can have refactorings any time needed.
        pub fn fork() -> Result<ForkResult> {
            unsafe{ nix_fork() }
        }
    }

    pub mod os_type
    {
        use ::
        {
            *,
        };
        use crate::execute;

        pub fn get_os_name() -> String {
            let uname = get_uname();
            if uname.to_lowercase() == "darwin" {
                get_macos_name()
            } else {
                get_other_os_name()
            }
        }

        fn get_other_os_name() -> String {
            let mut name = get_release_value("PRETTY_NAME");
            if !name.is_empty() {
                return name;
            }
            name = get_release_value("DISTRIB_DESCRIPTION");
            if !name.is_empty() {
                return name;
            }
            name = get_release_value("IMAGE_DESCRIPTION");
            if !name.is_empty() {
                return name;
            }
            get_uname_mo()
        }

        fn get_release_value(ptn: &str) -> String {
            let line = format!(
                "grep -i '{}' /etc/*release* 2>&1 | grep -o '=.*' | tr '\"=' ' '",
                ptn
            );
            let cr = execute::run(&line);
            return cr.stdout.trim().to_string();
        }

        fn get_uname() -> String {
            let cr = execute::run("uname");
            return cr.stdout.trim().to_string();
        }

        fn get_uname_mo() -> String {
            let cr = execute::run("uname -m -o");
            return cr.stdout.trim().to_string();
        }

        fn get_macos_name() -> String {
            let mut os_name = get_osx_codename();
            let ver = get_osx_version();
            if !ver.is_empty() {
                os_name.push(' ');
                os_name.push_str(&ver);
            }
            os_name
        }

        fn get_osx_codename() -> String {
            let cr = execute::run("grep -o 'SOFTWARE LICENSE AGREEMENT FOR .*[a-zA-Z]' '/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf' | sed 's/SOFTWARE LICENSE AGREEMENT FOR *//'");
            return cr.stdout.trim().to_string();
        }

        fn get_osx_version() -> String {
            let cr = execute::run("sw_vers -productVersion");
            return cr.stdout.trim().to_string();
        }
    }

    pub mod path
    {
        use ::
        {
            *,
        };

        use std::borrow::Cow;
        use std::env;
        use std::fs::read_dir;
        use std::io::{ErrorKind, Write};
        use std::os::unix::fs::PermissionsExt;

        use regex::Regex;

        use crate::tools;

        pub fn basename(path: &str) -> Cow<'_, str> {
            let mut pieces = path.rsplit('/');
            match pieces.next() {
                Some(p) => p.into(),
                None => path.into(),
            }
        }

        pub fn expand_home(text: &str) -> String {
            let mut s: String = text.to_string();
            let v = vec![
                r"(?P<head> +)~(?P<tail> +)",
                r"(?P<head> +)~(?P<tail>/)",
                r"^(?P<head> *)~(?P<tail>/)",
                r"(?P<head> +)~(?P<tail> *$)",
            ];
            for item in &v {
                let re;
                if let Ok(x) = Regex::new(item) {
                    re = x;
                } else {
                    return String::new();
                }
                let home = tools::get_user_home();
                let ss = s.clone();
                let to = format!("$head{}$tail", home);
                let result = re.replace_all(ss.as_str(), to.as_str());
                s = result.to_string();
            }
            s
        }

        pub fn find_file_in_path(filename: &str, exec: bool) -> String {
            let env_path = match env::var("PATH") {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!(":: error with env PATH: {:?}", e);
                    return String::new();
                }
            };
            let vec_path: Vec<&str> = env_path.split(':').collect();
            for p in &vec_path {
                match read_dir(p) {
                    Ok(list) => {
                        for entry in list.flatten() {
                            if let Ok(name) = entry.file_name().into_string() {
                                if name != filename {
                                    continue;
                                }

                                if exec {
                                    let _mode = match entry.metadata() {
                                        Ok(x) => x,
                                        Err(e) => {
                                            println_stderr!(":: metadata error: {:?}", e);
                                            continue;
                                        }
                                    };
                                    let mode = _mode.permissions().mode();
                                    if mode & 0o111 == 0 {
                                        // not binary
                                        continue;
                                    }
                                }

                                return entry.path().to_string_lossy().to_string();
                            }
                        }
                    }
                    Err(e) => {
                        if e.kind() == ErrorKind::NotFound {
                            continue;
                        }
                        log!(":: fs read_dir error: {}: {}", p, e);
                    }
                }
            }
            String::new()
        }

        pub fn current_dir() -> String {
            let _current_dir = match env::current_dir() {
                Ok(x) => x,
                Err(e) => {
                    log!(":: PROMPT: env current_dir error: {}", e);
                    return String::new();
                }
            };
            let current_dir = match _current_dir.to_str() {
                Some(x) => x,
                None => {
                    log!(":: PROMPT: to_str error");
                    return String::new();
                }
            };

            current_dir.to_string()
        }
    }

    pub mod re
    {
        use ::
        {
            *,
        };
        use regex;

        pub fn find_first_group(ptn: &str, text: &str) -> Option<String> {
            let re = match regex::Regex::new(ptn) {
                Ok(x) => x,
                Err(_) => return None,
            };
            match re.captures(text) {
                Some(caps) => {
                    if let Some(x) = caps.get(1) {
                        return Some(x.as_str().to_owned());
                    }
                }
                None => {
                    return None;
                }
            }
            None
        }

        pub fn re_contains(text: &str, ptn: &str) -> bool {
            let re = match regex::Regex::new(ptn) {
                Ok(x) => x,
                Err(e) => {
                    println!("Regex new error: {:?}", e);
                    return false;
                }
            };
            re.is_match(text)
        }

        pub fn replace_all(text: &str, ptn: &str, ptn_to: &str) -> String {
            let re = regex::Regex::new(ptn).unwrap();
            let result = re.replace_all(text, ptn_to);
            result.to_string()
        }

        #[cfg(test)]
        mod tests {
            use super::find_first_group;

            #[test]
            fn test_find_first_group() {
                let s = find_first_group(r"", "");
                assert_eq!(s, None);

                let s = find_first_group(r"abc", "123");
                assert_eq!(s, None);

                let s = find_first_group(r"\$\((.+)\)", "ls -l $(find x) -h");
                assert_eq!(s, Some("find x".to_string()));

                let s = find_first_group(r"(\d+)-(\d+)-(\d+)", "2017-09-16");
                assert_eq!(s, Some("2017".to_string()));
            }
        }
    }

    pub mod term_size
    {
        use ::
        {
            *,
        };
        // via: https://github.com/clap-rs/term_size-rs/blob/644f28c3a8811e56edcf42036b5e754dbb24a0d7/src/platform/unix.rs
        use libc::{c_int, c_ulong, winsize, STDERR_FILENO, STDIN_FILENO, STDOUT_FILENO};
        use std::mem::zeroed;

        // Unfortunately the actual command is not standardised...
        #[cfg(any(target_os = "linux", target_os = "android"))]
        static TIOCGWINSZ: c_ulong = 0x5413;

        #[cfg(any(
            target_os = "macos",
            target_os = "ios",
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
        ))]
        static TIOCGWINSZ: c_ulong = 0x40087468;

        #[cfg(target_os = "solaris")]
        static TIOCGWINSZ: c_ulong = 0x5468;

        extern "C" {
            fn ioctl(fd: c_int, request: c_ulong, ...) -> c_int;
        }
        /// Runs the ioctl command. Returns (0, 0) if all of the streams are not to a terminal, or
        /// there is an error. (0, 0) is an invalid size to have anyway, which is why
        /// it can be used as a nil value.
        unsafe fn get_dimensions_any() -> winsize {
            let mut window: winsize = zeroed();
            let mut result = ioctl(STDOUT_FILENO, TIOCGWINSZ, &mut window);

            if result == -1 {
                window = zeroed();
                result = ioctl(STDIN_FILENO, TIOCGWINSZ, &mut window);
                if result == -1 {
                    window = zeroed();
                    result = ioctl(STDERR_FILENO, TIOCGWINSZ, &mut window);
                    if result == -1 {
                        return zeroed();
                    }
                }
            }
            window
        }
        /// Query the current processes's output (`stdout`), input (`stdin`), and error (`stderr`) in that order, 
        ///in the attempt to dtermine terminal width.
        pub fn dimensions() -> Option<(usize, usize)> {
            let w = unsafe { get_dimensions_any() };

            if w.ws_col == 0 || w.ws_row == 0 {
                None
            } else {
                Some((w.ws_col as usize, w.ws_row as usize))
            }
        }
    }

    pub mod progopts
    {
        use ::
        {
            *,
        };
        pub fn is_login(args: &[String]) -> bool 
        {
            if !args.is_empty() && args[0].starts_with("-") {
                return true;
            }

            if args.len() > 1 && (args[1] == "--login" || args[1] == "-l") {
                return true;
            }

            if let Ok(term_program) = std::env::var("TERM_PROGRAM") {
                if term_program == "vscode" {
                    return true;
                }
            }

            false
        }

        pub fn is_script(args: &[String]) -> bool {
            args.len() > 1 && !args[1].starts_with("-")
        }

        pub fn is_command_string(args: &[String]) -> bool {
            args.len() > 1 && args[1] == "-c"
        }

        pub fn is_non_tty() -> bool {
            unsafe { libc::isatty(0) == 0 }
        }
    }

    pub mod pipes
    {
        use ::
        {
            *,
        };
        // via: nix v0.26.4. We do not want to use OwnedFd in newer version nix.
        use std::os::fd::RawFd;
        use nix::Error;
        use std::mem;
        use libc::c_int;

        pub fn pipe() -> std::result::Result<(RawFd, RawFd), Error> {
            let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
            let res = unsafe { libc::pipe(fds.as_mut_ptr() as *mut c_int) };
            Error::result(res)?;
            unsafe { Ok((fds.assume_init()[0], fds.assume_init()[1])) }
        }
    }
    
    pub fn close(fd: i32) {
        unsafe { libc::close(fd); }
    }

    pub fn dup(fd: i32) -> i32 {
        unsafe { libc::dup(fd) }
    }

    pub fn dup2(src: i32, dst: i32) {
        unsafe { libc::dup2(src, dst); }
    }
}

pub mod lineread
{
    //! Provides a configurable, concurrent, extensible, interactive input reader for Unix terminals and Windows console.
    use ::
    {
        *,
    };
    /*
    pub use crate::command::Command;
    pub use crate::complete::{Completer, Completion, Suffix};
    pub use crate::function::Function;
    pub use crate::interface::Interface;
    pub use crate::prompter::Prompter;
    pub use crate::reader::{Reader, ReadResult};
    pub use crate::terminal::{DefaultTerminal, Signal, Terminal};
    pub use crate::writer::Writer; */

    pub mod chars
    {
        //! Provides utilities for manipulating character values
        use ::
        {
            *,
        };
        

        // This is technically configurable on Unix, but exposing that information
        // from the low-level terminal interface and storing it in Reader is a pain.
        // Does anyone even care?
        /// Character value indicating end-of-file
        pub const EOF: char = '\x04';

        /// Character value generated by the Escape key
        pub const ESCAPE: char = '\x1b';

        /// Character value generated by the Backspace key
        ///
        /// On Unix systems, this is equivalent to `RUBOUT`
        #[cfg(unix)]
        pub const DELETE: char = RUBOUT;

        /// Character value generated by the Backspace key
        ///
        /// On Windows systems, this character is Ctrl-H
        #[cfg(windows)]
        pub const DELETE: char = '\x08';

        /// Character value generated by the Backspace key on some systems
        pub const RUBOUT: char = '\x7f';

        /// Returns a character name as a key sequence, e.g. `Control-x` or `Meta-x`.
        ///
        /// Returns `None` if the name is invalid.
        pub fn parse_char_name(name: &str) -> Option<String> {
            let name_lc = name.to_lowercase();

            let is_ctrl = contains_any(&name_lc, &["c-", "ctrl-", "control-"]);
            let is_meta = contains_any(&name_lc, &["m-", "meta-"]);

            let name = match name_lc.rfind('-') {
                Some(pos) => &name_lc[pos + 1..],
                None => &name_lc[..]
            };

            let ch = match name {
                "del" | "rubout"  => DELETE,
                "esc" | "escape"  => ESCAPE,
                "lfd" | "newline" => '\n',
                "ret" | "return"  => '\r',
                "spc" | "space"   => ' ',
                "tab"             => '\t',
                s if !s.is_empty() => s.chars().next().unwrap(),
                _ => return None
            };

            let ch = match (is_ctrl, is_meta) {
                (true,  true)  => meta(ctrl(ch)),
                (true,  false) => ctrl(ch).to_string(),
                (false, true)  => meta(ch),
                (false, false) => ch.to_string(),
            };

            Some(ch)
        }
        /// Returns a character sequence escaped for user-facing display.
        ///
        /// Escape is formatted as `\e`.
        /// Control key combinations are prefixed with `\C-`.
        pub fn escape_sequence(s: &str) -> String {
            let mut res = String::with_capacity(s.len());

            for ch in s.chars() {
                match ch {
                    ESCAPE => res.push_str(r"\e"),
                    RUBOUT => res.push_str(r"\C-?"),
                    '\\' => res.push_str(r"\\"),
                    '\'' => res.push_str(r"\'"),
                    '"' => res.push_str(r#"\""#),
                    ch if is_ctrl(ch) => {
                        res.push_str(r"\C-");
                        res.push(unctrl_lower(ch));
                    }
                    ch => res.push(ch)
                }
            }

            res
        }
        /// Returns a meta sequence for the given character.
        pub fn meta(ch: char) -> String {
            let mut s = String::with_capacity(ch.len_utf8() + 1);
            s.push(ESCAPE);
            s.push(ch);
            s
        }

        fn contains_any(s: &str, strs: &[&str]) -> bool {
            strs.iter().any(|a| s.contains(a))
        }
        /// Returns whether the character is printable.
        ///
        /// That is, not NUL or a control character (other than Tab or Newline).
        pub fn is_printable(c: char) -> bool {
            c == '\t' || c == '\n' || !(c == '\0' || is_ctrl(c))
        }

        const CTRL_BIT: u8 = 0x40;
        const CTRL_MASK: u8 = 0x1f;

        /// Returns whether the given character is a control character.
        pub fn is_ctrl(c: char) -> bool {
            const CTRL_MAX: u32 = 0x1f;

            c != '\0' && c as u32 <= CTRL_MAX
        }
        /// Returns a control character for the given character.
        pub fn ctrl(c: char) -> char {
            ((c as u8) & CTRL_MASK) as char
        }
        /// Returns the printable character corresponding to the given control character.
        pub fn unctrl(c: char) -> char {
            ((c as u8) | CTRL_BIT) as char
        }
        /// Returns the lowercase character corresponding to the given control character.
        pub fn unctrl_lower(c: char) -> char {
            unctrl(c).to_ascii_lowercase()
        }
    }

    pub mod command
    {
        //! Defines the set of line editing commands
        use ::
        {
            *,
        };
        

        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::fmt;

        use crate::chars::escape_sequence;

        macro_rules! define_commands {
            ( $( #[$meta:meta] $name:ident => $str:expr , )+ ) => {
                /// Represents a command to modify `Reader` state
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub enum Command {
                    $( #[$meta] $name , )+
                    /// Custom application-defined command
                    Custom(Cow<'static, str>),
                    /// Execute a given key sequence
                    Macro(Cow<'static, str>),
                }
                /// List of all command names
                pub static COMMANDS: &[&str] = &[ $( $str ),+ ];

                impl fmt::Display for Command {
                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                        match *self {
                            $( Command::$name => f.write_str($str) , )+
                            Command::Custom(ref s) => f.write_str(s),
                            Command::Macro(ref s) => write!(f, "\"{}\"",
                                escape_sequence(s))
                        }
                    }
                }

                impl Command {
                    /// Constructs a command from a `'static str` reference.
                    ///
                    /// If the string does not refer to a built-in command, a value
                    /// of `Command::Custom(Borrowed(name))` will be returned.
                    pub fn from_str(name: &'static str) -> Command {
                        Command::opt_from_str(name)
                            .unwrap_or_else(|| Command::Custom(Borrowed(name)))
                    }
                    /// Constructs a command from a non-`'static` string-like type.
                    ///
                    /// If the string does not refer to a built-in command, a value
                    /// of `Command::Custom(Owned(name.into()))` will be returned.
                    pub fn from_string<T>(name: T) -> Command
                            where T: AsRef<str> + Into<String> {
                        Command::opt_from_str(name.as_ref())
                            .unwrap_or_else(|| Command::Custom(Owned(name.into())))
                    }

                    fn opt_from_str(s: &str) -> Option<Command> {
                        match s {
                            $( $str => Some(Command::$name), )+
                            _ => None
                        }
                    }
                }
            }
        }

        define_commands!{
            /// Abort history search
            Abort => "abort",
            /// Accepts the current input line
            AcceptLine => "accept-line",
            /// Perform completion
            Complete => "complete",
            /// Insert all completions into the input buffer
            InsertCompletions => "insert-completions",
            /// Show possible completions
            PossibleCompletions => "possible-completions",
            /// Insert the next possible completion
            MenuComplete => "menu-complete",
            /// Insert the previous possible completion
            MenuCompleteBackward => "menu-complete-backward",
            /// Begin numeric argument input
            DigitArgument => "digit-argument",
            /// Insert character or sequence at the cursor
            SelfInsert => "self-insert",
            /// Inserts a tab character
            TabInsert => "tab-insert",
            /// Toggles insert/overwrite mode
            OverwriteMode => "overwrite-mode",
            /// Insert a comment and accept input
            InsertComment => "insert-comment",
            /// Move the cursor backward one character
            BackwardChar => "backward-char",
            /// Move the cursor forward one character
            ForwardChar => "forward-char",
            /// Search for a given character
            CharacterSearch => "character-search",
            /// Search backward for a given character
            CharacterSearchBackward => "character-search-backward",
            /// Move the cursor backward one word
            BackwardWord => "backward-word",
            /// Move the cursor forward one word
            ForwardWord => "forward-word",
            /// Kill all characters before the cursor
            BackwardKillLine => "backward-kill-line",
            /// Kill all characters after the cursor
            KillLine => "kill-line",
            /// Kill a word before the cursor
            BackwardKillWord => "backward-kill-word",
            /// Kill a word after the cursor
            KillWord => "kill-word",
            /// Kill a word before the cursor, delimited by whitespace
            UnixWordRubout => "unix-word-rubout",
            /// Clear the screen
            ClearScreen => "clear-screen",
            /// Move the cursor to the beginning of the line
            BeginningOfLine => "beginning-of-line",
            /// Move the cursor to the end of the line
            EndOfLine => "end-of-line",
            /// Delete one character before the cursor
            BackwardDeleteChar => "backward-delete-char",
            /// Delete one character after the cursor
            DeleteChar => "delete-char",
            /// Drag the character before the cursor forward
            TransposeChars => "transpose-chars",
            /// Drag the word before the cursor forward
            TransposeWords => "transpose-words",
            /// Move to the first line of history
            BeginningOfHistory => "beginning-of-history",
            /// Move to the last line of history
            EndOfHistory => "end-of-history",
            /// Select next line in history
            NextHistory => "next-history",
            /// Select previous line in history
            PreviousHistory => "previous-history",
            /// Incremental search in history
            ForwardSearchHistory => "forward-search-history",
            /// Incremental reverse search in history
            ReverseSearchHistory => "reverse-search-history",
            /// Non-incremental forward history search using input up to the cursor
            HistorySearchForward => "history-search-forward",
            /// Non-incremental backward history search using input up to the cursor
            HistorySearchBackward => "history-search-backward",
            /// Insert literal character
            QuotedInsert => "quoted-insert",
            /// Insert text into buffer from the kill ring
            Yank => "yank",
            /// Rotate the kill ring and yank the new top
            YankPop => "yank-pop",
        }
        /// Describes the category of a command
        ///
        /// A command's category determines how particular operations behave
        /// in succession.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Category {
            /// Completion command
            Complete,
            /// Kill command
            Kill,
            /// Non-incremental search command
            Search,
            /// Incremental search command
            IncrementalSearch,
            /// Yank command
            Yank,
            /// Digit argument command
            Digit,
            /// Other command
            Other,
        }

        impl Command {
            /// Returns the category of the command
            pub fn category(&self) -> Category {
                use self::Command::*;

                match *self {
                    DigitArgument => Category::Digit,
                    Complete | InsertCompletions | PossibleCompletions |
                        MenuComplete | MenuCompleteBackward => Category::Complete,
                    BackwardKillLine | KillLine | BackwardKillWord | KillWord |
                        UnixWordRubout => Category::Kill,
                    ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                    HistorySearchForward | HistorySearchBackward => Category::Search,
                    Yank | YankPop => Category::Yank,
                    _ => Category::Other
                }
            }
        }

        impl Default for Command {
            fn default() -> Self {
                Command::Custom(Borrowed(""))
            }
        }
    }

    pub mod complete
    {
        //! Provides utilities for implementing word completion
        use ::
        {
            *,
        };
        

        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::fs::read_dir;
        use std::path::{is_separator, MAIN_SEPARATOR};

        use crate::prompter::Prompter;
        use crate::terminal::Terminal;

        /// Represents a single possible completion
        #[derive(Clone, Debug)]
        pub struct Completion {
            /// Whole completion text
            pub completion: String,
            /// Listing display string; `None` if matches completion
            pub display: Option<String>,
            /// Completion suffix; replaces append character
            pub suffix: Suffix,
        }
        /// Specifies an optional suffix to override the default value
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Suffix {
            /// Use the default suffix
            Default,
            /// Use no suffix
            None,
            /// Use the given suffix
            Some(char),
        }

        impl Completion {
            /// Returns a simple `Completion` value, with display string matching
            /// completion and using the default completion suffix.
            pub fn simple(s: String) -> Completion {
                Completion{
                    completion: s,
                    display: None,
                    suffix: Suffix::default(),
                }
            }
            /// Returns the full completion string, including suffix, using the given
            /// default suffix if one is not assigned to this completion.
            pub fn completion(&self, def_suffix: Option<char>) -> Cow<str> {
                let mut s = Borrowed(&self.completion[..]);

                if let Some(suffix) = self.suffix.with_default(def_suffix) {
                    s.to_mut().push(suffix);
                }

                s
            }
            /// Returns the display string, including suffix
            pub fn display(&self) -> Cow<str> {
                let mut s = Borrowed(self.display_str());

                if let Suffix::Some(suffix) = self.suffix {
                    s.to_mut().push(suffix);
                }

                s
            }
            /// Returns the number of characters displayed
            pub fn display_chars(&self) -> usize {
                let n = self.display_str().chars().count();
                n + if self.suffix.is_some() { 1 } else { 0 }
            }

            fn display_str(&self) -> &str {
                match self.display {
                    Some(ref dis) => dis,
                    None => &self.completion
                }
            }
        }

        impl Suffix {
            /// Returns whether the `Suffix` value is the `Default` variant.
            pub fn is_default(&self) -> bool {
                match *self {
                    Suffix::Default => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `Some(_)` variant.
            pub fn is_some(&self) -> bool {
                match *self {
                    Suffix::Some(_) => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `None` variant.
            pub fn is_none(&self) -> bool {
                match *self {
                    Suffix::None => true,
                    _ => false
                }
            }
            /// Returns an `Option<char>`, using the given value in place of `Default`.
            pub fn with_default(self, default: Option<char>) -> Option<char> {
                match self {
                    Suffix::None => None,
                    Suffix::Some(ch) => Some(ch),
                    Suffix::Default => default
                }
            }
        }

        impl Default for Suffix {
            fn default() -> Suffix {
                Suffix::Default
            }
        }
        /// Performs completion for `Prompter` when triggered by a user input sequence
        pub trait Completer<Term: Terminal>: Send + Sync {
            /// Returns the set of possible completions for the prefix `word`.
            fn complete(&self, word: &str, prompter: &Prompter<Term>,
                start: usize, end: usize) -> Option<Vec<Completion>>;

            /// Returns the starting position of the word under the cursor.
            ///
            /// The default implementation uses `Prompter::word_break_chars()` to
            /// detect the start of a word.
            fn word_start(&self, line: &str, end: usize, prompter: &Prompter<Term>) -> usize {
                word_break_start(&line[..end], prompter.word_break_chars())
            }
            /// Quotes a possible completion for insertion into input.
            ///
            /// The default implementation returns the word, as is.
            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
            /// Unquotes a piece of user input before searching for completions.
            ///
            /// The default implementation returns the word, as is.
            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
        }
        /// `Completer` type that performs no completion
        ///
        /// This is the default `Completer` for a new `Prompter` instance.
        pub struct DummyCompleter;

        impl<Term: Terminal> Completer<Term> for DummyCompleter {
            fn complete(&self, _word: &str, _reader: &Prompter<Term>,
                    _start: usize, _end: usize) -> Option<Vec<Completion>> { None }
        }
        /// Performs completion by searching for filenames matching the word prefix.
        pub struct PathCompleter;

        impl<Term: Terminal> Completer<Term> for PathCompleter {
            fn complete(&self, word: &str, _reader: &Prompter<Term>, _start: usize, _end: usize)
                    -> Option<Vec<Completion>> {
                Some(complete_path(word))
            }

            fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
                escaped_word_start(&line[..end])
            }

            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                escape(word)
            }

            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                unescape(word)
            }
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path(path: &str) -> Vec<Completion> {
            let (base_dir, fname) = split_path(path);
            let mut res = Vec::new();

            let lookup_dir = base_dir.unwrap_or(".");

            if let Ok(list) = read_dir(lookup_dir) {
                for ent in list {
                    if let Ok(ent) = ent {
                        let ent_name = ent.file_name();

                        // TODO: Deal with non-UTF8 paths in some way
                        if let Ok(path) = ent_name.into_string() {
                            if path.starts_with(fname) {
                                let (name, display) = if let Some(dir) = base_dir {
                                    (format!("{}{}{}", dir, MAIN_SEPARATOR, path),
                                        Some(path))
                                } else {
                                    (path, None)
                                };

                                let is_dir = ent.metadata().ok()
                                    .map_or(false, |m| m.is_dir());

                                let suffix = if is_dir {
                                    Suffix::Some(MAIN_SEPARATOR)
                                } else {
                                    Suffix::Default
                                };

                                res.push(Completion{
                                    completion: name,
                                    display: display,
                                    suffix: suffix,
                                });
                            }
                        }
                    }
                }
            }

            res.sort_by(|a, b| a.display_str().cmp(b.display_str()));
            res
        }
        /// Returns the start position of the word that ends at the end of the string.
        pub fn word_break_start(s: &str, word_break: &str) -> usize {
            let mut start = s.len();

            for (idx, ch) in s.char_indices().rev() {
                if word_break.contains(ch) {
                    break;
                }
                start = idx;
            }

            start
        }
        /// Returns the start position of a word with non-word characters escaped by
        /// backslash (`\\`).
        pub fn escaped_word_start(s: &str) -> usize {
            let mut chars = s.char_indices().rev();
            let mut start = s.len();

            while let Some((idx, ch)) = chars.next() {
                if needs_escape(ch) {
                    let n = {
                        let mut n = 0;

                        loop {
                            let mut clone = chars.clone();

                            let ch = match clone.next() {
                                Some((_, ch)) => ch,
                                None => break
                            };

                            if ch == '\\' {
                                chars = clone;
                                n += 1;
                            } else {
                                break;
                            }
                        }

                        n
                    };

                    if n % 2 == 0 {
                        break;
                    }
                }

                start = idx;
            }

            start
        }
        /// Escapes a word by prefixing a backslash (`\\`) to non-word characters.
        pub fn escape(s: &str) -> Cow<str> {
            let n = s.chars().filter(|&ch| needs_escape(ch)).count();

            if n == 0 {
                Borrowed(s)
            } else {
                let mut res = String::with_capacity(s.len() + n);

                for ch in s.chars() {
                    if needs_escape(ch) {
                        res.push('\\');
                    }
                    res.push(ch);
                }

                Owned(res)
            }
        }
        /// Unescapes a word by removing the backslash (`\\`) from escaped characters.
        pub fn unescape(s: &str) -> Cow<str> {
            if s.contains('\\') {
                let mut res = String::with_capacity(s.len());
                let mut chars = s.chars();

                while let Some(ch) = chars.next() {
                    if ch == '\\' {
                        if let Some(ch) = chars.next() {
                            res.push(ch);
                        }
                    } else {
                        res.push(ch);
                    }
                }

                Owned(res)
            } else {
                Borrowed(s)
            }
        }

        fn needs_escape(ch: char) -> bool {
            match ch {
                ' ' | '\t' | '\n' | '\\' => true,
                _ => false
            }
        }

        fn split_path(path: &str) -> (Option<&str>, &str) {
            match path.rfind(is_separator) {
                Some(pos) => (Some(&path[..pos]), &path[pos + 1..]),
                None => (None, path)
            }
        }
    }

    pub mod function
    {
        //! Provides the `Function` trait for implementing custom `Prompter` commands
        use ::
        {
            *,
        };
        

        use std::io;

        use crate::command::Category;
        use crate::prompter::Prompter;
        use crate::terminal::Terminal;

        /// Implements custom functionality for a `Prompter` command
        pub trait Function<Term: Terminal>: Send + Sync {
            /// Executes the function.
            ///
            /// `count` is the numerical argument supplied by the user; `1` by default.
            /// `prompter.explicit_arg()` may be called to determine whether this value
            /// was explicitly supplied by the user.
            ///
            /// `ch` is the final character of the sequence that triggered the command.
            /// `prompter.sequence()` may be called to determine the full sequence that
            /// triggered the command.
            fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()>;

            /// Returns the command category.
            fn category(&self) -> Category { Category::Other }
        }

        impl<F, Term: Terminal> Function<Term> for F where
                F: Send + Sync,
                F: Fn(&mut Prompter<Term>, i32, char) -> io::Result<()> {
            fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()> {
                self(prompter, count, ch)
            }
        }
    }

    pub mod highlighting
    {
        //! Syntax highlighting functionality for the terminal interface
        use ::
        {
            *,
        };
        

        use std::ops::Range;

        /// Represents a style to be applied to a text range.
        #[derive(Debug, Clone, PartialEq, Eq)]
        pub enum Style {
            /// A style using raw ANSI color codes
            AnsiColor(String),
            /// The default terminal style
            Default,
        }
        /// A trait for providing style information for a line of text.
        pub trait Highlighter {
            /// Takes the current line buffer and returns a list of styled ranges.
            fn highlight(&self, line: &str) -> Vec<(Range<usize>, Style)>;
        }
        /// Style reset sequence
        pub const RESET_STYLE: &str = "\x1b[0m";
    }

    pub mod inputrc
    {
        //! Parses configuration files in the format of GNU Readline `inputrc`
        use ::
        {
            *,
        };

        

        use std::char::from_u32;
        use std::fs::File;
        use std::io::{stderr, Read, Write};
        use std::path::Path;
        use std::str::{Chars, Lines};

        use crate::chars::{ctrl, meta, parse_char_name};
        use crate::command::Command;

        /// Parsed configuration directive
        #[derive(Clone, Debug)]
        pub enum Directive {
            /// Bind construct; `"input-sequence": command-or-macro`
            Bind(String, Command),
            /// Conditional construct;
            /// (`$if name=value` or `$if value`) *directives*
            /// (optional `$else` *directives*) `$endif`
            Conditional{
                /// Value name; if `None`, value refers to application name
                name: Option<String>,
                /// Value to compare
                value: String,
                /// Group of directives evaluated when condition is true
                then_group: Vec<Directive>,
                /// Group of directives evaluated when condition is false
                else_group: Vec<Directive>,
            },
            /// Set variable; `set name value`
            SetVariable(String, String),
        }
        /// Parses the named file and returns contained directives.
        ///
        /// If the file cannot be opened, `None` is returned and an error is printed
        /// to `stderr`. If any errors are encountered during parsing, they are printed
        /// to `stderr`.
        pub fn parse_file<P: ?Sized>(filename: &P) -> Option<Vec<Directive>> where P: AsRef<Path> {
            let filename = filename.as_ref();

            let mut f = match File::open(filename) {
                Ok(f) => f,
                Err(e) => {
                    let _ = writeln!(stderr(), "lineread: {}: {}", filename.display(), e);
                    return None;
                }
            };

            let mut buf = String::new();

            if let Err(e) = f.read_to_string(&mut buf) {
                let _ = writeln!(stderr(), "{}: {}", filename.display(), e);
                return None;
            }

            Some(parse_text(filename, &buf))
        }
        /// Parses some text and returns contained directives.
        ///
        /// If any errors are encountered during parsing, they are printed to `stderr`.
        pub fn parse_text<P: ?Sized>(name: &P, line: &str) -> Vec<Directive> where P: AsRef<Path> {
            let mut p = Parser::new(name.as_ref(), line);
            p.parse()
        }

        struct Parser<'a> {
            lines: Lines<'a>,
            filename: &'a Path,
            line_num: usize,
        }

        enum Token<'a> {
            /// Colon; `:`
            Colon,
            /// Equal; `=`
            Equal,
            /// Conditional or other special directive; `$word`
            SpecialWord(&'a str),
            /// Double-quoted string; `"foo"`
            String(String),
            /// Bare word; `foo`
            Word(&'a str),
            /// Invalid token
            Invalid,
        }

        impl<'a> Parser<'a> {
            pub fn new(filename: &'a Path, text: &'a str) -> Parser<'a> {
                Parser{
                    lines: text.lines(),
                    filename: filename,
                    line_num: 0,
                }
            }

            fn next_line(&mut self) -> Option<&'a str> {
                self.lines.next().map(|line| {
                    self.line_num += 1;
                    line.trim()
                })
            }

            fn parse(&mut self) -> Vec<Directive> {
                let mut dirs = Vec::new();

                while let Some(line) = self.next_line() {
                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    if let Some(Token::SpecialWord("include")) = tokens.next() {
                        let path = tokens.line;

                        if let Some(d) = parse_file(Path::new(path)) {
                            dirs.extend(d);
                        }

                        continue;
                    }

                    if let Some(dir) = self.parse_line(line) {
                        dirs.push(dir);
                    }
                }

                dirs
            }

            fn parse_conditional(&mut self) -> (Vec<Directive>, Vec<Directive>) {
                let mut then_group = Vec::new();
                let mut else_group = Vec::new();
                let mut parse_else = false;

                loop {
                    let line = match self.next_line() {
                        Some(line) => line,
                        None => {
                            self.error("missing $endif directive");
                            break;
                        }
                    };

                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    let start = match tokens.next() {
                        Some(tok) => tok,
                        None => continue
                    };

                    match start {
                        Token::SpecialWord("else") => {
                            if parse_else {
                                self.error("duplicate $else directive");
                            } else {
                                parse_else = true;
                            }
                        }
                        Token::SpecialWord("endif") => {
                            break;
                        }
                        _ => {
                            if let Some(dir) = self.parse_line(line) {
                                if parse_else {
                                    else_group.push(dir);
                                } else {
                                    then_group.push(dir);
                                }
                            }
                        }
                    }
                }

                (then_group, else_group)
            }

            fn parse_line(&mut self, line: &str) -> Option<Directive> {
                let mut tokens = Tokens::new(line);

                let start = tokens.next()?;

                let dir = match start {
                    Token::SpecialWord("if") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (name, value) = match tokens.next() {
                            Some(Token::Equal) => {
                                let value = match tokens.next() {
                                    Some(Token::Word(w)) => w,
                                    None => "",
                                    _ => {
                                        self.invalid();
                                        return None;
                                    }
                                };

                                (Some(name), value)
                            }
                            None => (None, name),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (then_group, else_group) = self.parse_conditional();

                        Directive::Conditional{
                            name: name.map(|s| s.to_owned()),
                            value: value.to_owned(),
                            then_group: then_group,
                            else_group: else_group,
                        }
                    }
                    Token::SpecialWord("else") => {
                        self.error("$else without matching $if directive");
                        return None;
                    }
                    Token::SpecialWord("endif") => {
                        self.error("$endif without matching $if directive");
                        return None;
                    }
                    Token::String(seq) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(out)) =>
                                Directive::Bind(seq, Command::Macro(out.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    Token::Word("set") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let rest = tokens.line;

                        let value = match tokens.next() {
                            Some(Token::String(s)) => s,
                            Some(Token::Word(_)) => rest.to_owned(),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        Directive::SetVariable(name.to_owned(), value)
                    }
                    Token::Word(name) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        let seq = match parse_char_name(name) {
                            Some(seq) => seq,
                            None => {
                                self.invalid();
                                return None;
                            }
                        };

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(macro_seq)) =>
                                Directive::Bind(seq, Command::Macro(macro_seq.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    _ => {
                        self.invalid();
                        return None;
                    }
                };

                Some(dir)
            }

            fn error(&self, msg: &str) {
                let _ = writeln!(stderr(),
                    "lineread: {} line {}: {}", self.filename.display(), self.line_num, msg);
            }

            fn invalid(&self) {
                self.error("invalid directive");
            }
        }

        struct Tokens<'a> {
            line: &'a str,
        }

        impl<'a> Tokens<'a> {
            fn new(line: &str) -> Tokens {
                Tokens{
                    line: line,
                }
            }
        }

        impl<'a> Iterator for Tokens<'a> {
            type Item = Token<'a>;

            fn next(&mut self) -> Option<Token<'a>> {
                let ch = self.line.chars().next()?;

                let tok = match ch {
                    ':' => {
                        self.line = self.line[1..].trim_start();
                        Token::Colon
                    }
                    '=' => {
                        self.line = self.line[1..].trim_start();
                        Token::Equal
                    }
                    '$' => {
                        let (word, rest) = parse_word(&self.line[1..]);
                        self.line = rest.trim_start();
                        Token::SpecialWord(word)
                    }
                    '"' => {
                        let (tok, rest) = parse_string(self.line);
                        self.line = rest.trim_start();
                        tok
                    }
                    _ => {
                        let (word, rest) = parse_word(self.line);
                        self.line = rest.trim_start();
                        Token::Word(word)
                    }
                };

                Some(tok)
            }
        }

        fn parse_escape(chars: &mut Chars) -> Option<String> {
            let ch = chars.next()?;

            let esc = match ch {
                'C'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    ctrl(chars.next()?)
                }
                'M'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    return Some(meta(chars.next()?));
                }
                'e'  => '\x1b',
                '\\' => '\\',
                '"'  => '"',
                '\'' => '\'',
                'a'  => '\x07',
                'b'  => '\x08',
                'd'  => '\x7f',
                'f'  => '\x0c',
                'n'  => '\n',
                'r'  => '\r',
                't'  => '\t',
                'u'  => {
                    match chars.next() {
                        Some('{') => (),
                        _ => return None
                    }

                    let mut n = 0;

                    for _ in 0..6 {
                        match chars.clone().next().and_then(|ch| ch.to_digit(16)) {
                            Some(digit) => {
                                chars.next();
                                n *= 16;
                                n += digit;
                            }
                            None => break
                        }
                    }

                    match chars.next() {
                        Some('}') => (),
                        _ => return None
                    }

                    from_u32(n)?
                }
                'v'  => '\x0b',
                'x'  => {
                    let mut n = 0;

                    for _ in 0..2 {
                        // Peek the next character
                        let digit = chars.clone().next()?.to_digit(16)? as u8;

                        // Consume if valid
                        chars.next();

                        n <<= 4;
                        n |= digit;
                    }

                    n as char
                }
                '0' ..= '3' => {
                    let mut n = ch as u8 - b'0';

                    for _ in 0..2 {
                        // Peek the next character
                        let digit = chars.clone().next()?.to_digit(8)? as u8;

                        // Consume if valid
                        chars.next();

                        n <<= 3;
                        n |= digit;
                    }

                    n as char
                }
                _ => return None
            };

            Some(esc.to_string())
        }

        fn parse_string(s: &str) -> (Token, &str) {
            let mut chars = s.chars();
            let mut res = String::new();
            
            chars.next();

            while let Some(ch) = chars.next() {
                match ch {
                    '"' => return (Token::String(res), chars.as_str()),
                    '\\' => {
                        match parse_escape(&mut chars) {
                            Some(esc) => {
                                res.push_str(&esc);
                            }
                            None => break
                        }
                    }
                    ch => res.push(ch)
                }
            }

            (Token::Invalid, "")
        }

        fn parse_word(s: &str) -> (&str, &str) {
            let mut chars = s.char_indices();

            loop {
                let mut clone = chars.clone();

                match clone.next() {
                    Some((ind, ch)) if ch == ':' || ch == '"' || ch == '=' ||
                            ch.is_whitespace() => {
                        return (&s[..ind], &s[ind..]);
                    }
                    None => {
                        return (s, "");
                    }
                    _ => ()
                }

                chars = clone;
            }
        }
    }

    pub mod interface
    {
        //! Provides the main interface to interactive input reader
        use ::
        {
            *,
        };
        

        use std::borrow::Cow;
        use std::fmt;
        use std::fs::{File, OpenOptions};
        use std::io::{
            self, BufRead, BufReader, BufWriter,
            Read as _, Seek, SeekFrom, Write as _,
        };
        use std::path::Path;
        use std::sync::{Arc, Mutex, MutexGuard};
        use std::time::Duration;

        use crate::command::Command;
        use crate::complete::Completer;
        use crate::function::Function;
        use crate::highlighting::Highlighter;
        use crate::inputrc::Directive;
        use crate::reader::{Read, Reader, ReadLock, ReadResult};
        use crate::terminal::{DefaultTerminal, Signal, Terminal};
        use crate::variables::Variable;
        use crate::writer::{Write, Writer, WriteLock};

        /// The main interface to input reading and other terminal operations.
        pub struct Interface<Term: Terminal> {
            term: Term,
            write: Mutex<dyn Write>,
            read: Mutex<Read<Term>>,
            highlighter: Option<Arc<dyn Highlighter + Send + Sync>>,
        }

        impl Interface<DefaultTerminal> {
            /// Creates a new `Interface` with the given application name.
            ///
            /// `application` is a string containing the name of the application.
            /// This can be used in user configurations to specify behavior for
            /// particular applications.
            ///
            /// The default terminal interface is used.
            pub fn new<T>(application: T) -> io::Result<Interface<DefaultTerminal>>
                    where T: Into<Cow<'static, str>> {
                let term = DefaultTerminal::new()?;
                Interface::with_term(application, term)
            }
        }

        impl<Term: Terminal> Interface<Term> {
            /// Creates a new `Interface` instance with a particular terminal implementation.
            ///
            /// To use the default terminal interface, call `Interface::new` instead.
            pub fn with_term<T>(application: T, term: Term) -> io::Result<Interface<Term>>
                    where T: Into<Cow<'static, str>> {
                let size = term.lock_write().size()?;
                let read = Read::new(&term, application.into());

                Ok(Interface{
                    term: term,
                    write: Mutex::new(Write::new(size)),
                    read: Mutex::new(read),
                    highlighter: None,
                })
            }
            /// Acquires the read lock and returns a `Reader` instance.
            ///
            /// The `Reader` instance allows exclusive access to variables, bindings,
            /// and command implementations.
            pub fn lock_reader(&self) -> Reader<Term> {
                Reader::new(self, self.lock_read())
            }
            /// Acquires the write lock and returns a `Writer` instance.
            ///
            /// If a `read_line` call is in progress, this method will move the cursor
            /// to a new line after the prompt, allowing output to be written without
            /// corrupting the prompt text. The prompt will be redrawn when the `Writer`
            /// instance is dropped.
            ///
            /// To instead erase the prompt and write text, use [`lock_writer_erase`].
            ///
            /// [`lock_writer_erase`]: #method.lock_writer_erase
            pub fn lock_writer_append(&self) -> io::Result<Writer<Term>> {
                Writer::with_lock(self.lock_write(), false)
            }
            /// Acquires the write lock and returns a `Writer` instance.
            ///
            /// If a `read_line` call is in progress, this method will erase the prompt,
            /// allowing output to be written without corrupting the prompt text.
            /// The prompt will be redrawn when the `Writer` instance is dropped.
            ///
            /// To instead write text after the prompt, use [`lock_writer_append`].
            ///
            /// [`lock_writer_append`]: #method.lock_writer_append
            pub fn lock_writer_erase(&self) -> io::Result<Writer<Term>> {
                Writer::with_lock(self.lock_write(), true)
            }

            fn lock_read(&self) -> ReadLock<Term> {
                ReadLock::new(
                    self.term.lock_read(),
                    self.read.lock().expect("Interface::lock_read"))
            }

            pub fn lock_write(&self) -> WriteLock<Term> {
                WriteLock::new(
                    self.term.lock_write(),
                    self.write.lock().expect("Interface::lock_write"),
                    self.highlighter.clone(),
                )
            }

            pub fn lock_write_data(&self) -> MutexGuard<Write> {
                self.write.lock().expect("Interface::lock_write_data")
            }
        }
        /// ## Locking
        ///
        /// The following methods internally acquire the read lock.
        ///
        /// The lock is released before the method returns.
        ///
        /// If the read lock is already held, e.g. because a `read_line` call is in
        /// progress, the method will block until the lock is released.
        impl<Term: Terminal> Interface<Term> {
            /// Interactively reads a line from the terminal device.
            ///
            /// User input is collected until one of the following conditions is met:
            ///
            /// * If the user issues an end-of-file, `ReadResult::Eof` is returned.
            /// * When the user inputs a newline (`'\n'`), the resulting input
            ///   (not containing a trailing newline character) is returned as
            ///   `ReadResult::Input(_)`.
            /// * When a reported signal (see [`set_report_signal`]) is received,
            ///   it is returned as `ReadResult::Signal(_)`. The `read_line` operation may
            ///   then be either resumed with another call to `read_line` or ended by
            ///   calling [`cancel_read_line`].
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`set_report_signal`]: #method.set_report_signal
            pub fn read_line(&self) -> io::Result<ReadResult> {
                self.lock_reader().read_line()
            }
            /// Performs one step of the interactive `read_line` loop.
            ///
            /// This method can be used to drive the `read_line` process asynchronously.
            /// It will wait for input only up to the specified duration, then process
            /// any available input from the terminal.
            ///
            /// If the user completes the input process, `Ok(Some(result))` is returned.
            /// Otherwise, `Ok(None)` is returned to indicate that the interactive loop
            /// may continue.
            ///
            /// The interactive prompt may be cancelled prematurely using the
            /// [`cancel_read_line`] method.
            ///
            /// See [`read_line`] for details on the return value.
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`read_line`]: #method.read_line
            pub fn read_line_step(&self, timeout: Option<Duration>)
                    -> io::Result<Option<ReadResult>> {
                self.lock_reader().read_line_step(timeout)
            }
            /// Cancels an in-progress `read_line` operation.
            ///
            /// This method will reset internal data structures to their original state
            /// and move the terminal cursor to a new, empty line.
            ///
            /// This method is called to prematurely end the interactive loop when
            /// using the [`read_line_step`] method.
            ///
            /// It is not necessary to call this method if using the [`read_line`] method.
            ///
            /// [`read_line`]: #method.read_line
            /// [`read_line_step`]: #method.read_line_step
            pub fn cancel_read_line(&self) -> io::Result<()> {
                self.lock_reader().cancel_read_line()
            }
            /// Returns a clone of the current completer instance.
            pub fn completer(&self) -> Arc<dyn Completer<Term>> {
                self.lock_reader().completer().clone()
            }
            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer(&self, completer: Arc<dyn Completer<Term>>)
                    -> Arc<dyn Completer<Term>> {
                self.lock_reader().set_completer(completer)
            }
            /// Returns the value of the named variable or `None`
            /// if no such variable exists.
            pub fn get_variable(&self, name: &str) -> Option<Variable> {
                self.lock_reader().get_variable(name)
            }
            /// Sets the value of the named variable and returns the previous
            /// value.
            ///
            /// If `name` does not refer to a variable or the `value` is not
            /// a valid value for the variable, `None` is returned.
            pub fn set_variable(&self, name: &str, value: &str) -> Option<Variable> {
                self.lock_reader().set_variable(name, value)
            }
            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal(&self, signal: Signal) -> bool {
                self.lock_reader().ignore_signal(signal)
            }
            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal(&self, signal: Signal, set: bool) {
                self.lock_reader().set_ignore_signal(signal, set)
            }
            /// Returns whether the given `Signal` is reported.
            pub fn report_signal(&self, signal: Signal) -> bool {
                self.lock_reader().report_signal(signal)
            }
            /// Sets whether the given `Signal` is reported.
            pub fn set_report_signal(&self, signal: Signal, set: bool) {
                self.lock_reader().set_report_signal(signal, set)
            }
            /// Binds a sequence to a command.
            ///
            /// Returns the previously bound command.
            pub fn bind_sequence<T>(&self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.lock_reader().bind_sequence(seq, cmd)
            }
            /// Binds a sequence to a command, if and only if the given sequence
            /// is not already bound to a command.
            ///
            /// Returns `true` if a new binding was created.
            pub fn bind_sequence_if_unbound<T>(&self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                self.lock_reader().bind_sequence_if_unbound(seq, cmd)
            }
            /// Removes a binding for the given sequence.
            ///
            /// Returns the previously bound command.
            pub fn unbind_sequence(&self, seq: &str) -> Option<Command> {
                self.lock_reader().unbind_sequence(seq)
            }
            /// Defines a named function to which sequences may be bound.
            ///
            /// The name should consist of lowercase ASCII letters and numbers,
            /// containing no spaces, with words separated by hyphens. However,
            /// this is not a requirement.
            ///
            /// Returns the function previously defined with the same name.
            pub fn define_function<T>(&self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.lock_reader().define_function(name, cmd)
            }
            /// Removes a function defined with the given name.
            ///
            /// Returns the defined function.
            pub fn remove_function(&self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.lock_reader().remove_function(name)
            }
            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives(&self, dirs: Vec<Directive>) {
                self.lock_reader().evaluate_directives(&self.term, dirs)
            }
            /// Evaluates a single configuration directive.
            pub fn evaluate_directive(&self, dir: Directive) {
                self.lock_reader().evaluate_directive(&self.term, dir)
            }
        }
        /// ## Locking
        ///
        /// The following methods internally acquire the write lock.
        ///
        /// The lock is released before the method returns.
        ///
        /// If the write lock is already held, the method will block until it is released.
        impl<Term: Terminal> Interface<Term> {
            /// Returns the current input buffer.
            pub fn buffer(&self) -> String {
                self.lock_write().buffer.to_owned()
            }
            /// Returns the current number of history entries.
            pub fn history_len(&self) -> usize {
                self.lock_write().history_len()
            }
            /// Returns the maximum number of history entries.
            ///
            /// Not to be confused with [`history_len`], which returns the *current*
            /// number of history entries.
            ///
            /// [`history_len`]: #method.history_len
            pub fn history_size(&self) -> usize {
                self.lock_write().history_size()
            }
            /// Save history entries to the specified file.
            ///
            /// If the file does not exist, it is created and all history entries are
            /// written to the new file.
            ///
            /// If the file does exist, entries added since the last call to `save_history`
            /// (or since the start of the application) are appended to the named file.
            ///
            /// If the file would contain more than `self.history_size()` entries,
            /// it is first truncated, discarding the oldest entries.
            pub fn save_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
                let path = path.as_ref();
                let mut w = self.lock_write();

                if !path.exists() || w.history_size() == !0 {
                    self.append_history(path, &w)?;
                } else {
                    self.rewrite_history(path, &w)?;
                }

                w.reset_new_history();
                Ok(())
            }

            fn append_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>)
                    -> io::Result<()> {
                let file = OpenOptions::new()
                    .append(true)
                    .create(true)
                    .open(path.as_ref())?;

                self.append_history_to(&file, w)
            }

            fn append_history_to(&self, file: &File, w: &WriteLock<Term>) -> io::Result<()> {
                let mut wtr = BufWriter::new(file);

                for entry in w.new_history() {
                    wtr.write_all(entry.as_bytes())?;
                    wtr.write_all(b"\n")?;
                }

                wtr.flush()
            }

            fn rewrite_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>)
                    -> io::Result<()> {
                fn nth_line(s: &str, n: usize) -> Option<usize> {
                    let start = s.as_ptr() as usize;

                    s.lines().nth(n)
                        .map(|s| s.as_ptr() as usize - start)
                }

                let mut file = OpenOptions::new()
                    .create(true)
                    .read(true)
                    .write(true)
                    .open(path.as_ref())?;

                let mut hist = String::new();

                file.read_to_string(&mut hist)?;

                let n_lines = hist.lines().count();
                let n = n_lines.saturating_sub(
                    w.history_size() - w.new_history_entries());

                if n != 0 {
                    if let Some(pos) = nth_line(&hist, n) {
                        file.seek(SeekFrom::Start(0))?;
                        file.write_all(hist[pos..].as_bytes())?;

                        let n = file.seek(SeekFrom::Current(0))?;
                        file.set_len(n)?;
                    }
                }

                self.append_history_to(&file, w)
            }
            /// Load history entries from the specified file.
            pub fn load_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
                let mut writer = self.lock_write();

                let file = File::open(&path)?;
                let rdr = BufReader::new(file);

                for line in rdr.lines() {
                    writer.add_history(line?);
                }

                writer.reset_new_history();

                Ok(())
            }
            /// Writes formatted text to the terminal display.
            ///
            /// This method enables `Interface` to be used as the receiver to
            /// the [`writeln!`] macro.
            ///
            /// If the text contains any unprintable characters (e.g. escape sequences),
            /// those characters will be escaped before printing.
            ///
            /// # Notes
            ///
            /// If this method is called during a [`read_line`] call, the prompt will
            /// first be erased, then restored after the given string is printed.
            /// Therefore, the written text should end with a newline. If the `writeln!`
            /// macro is used, a newline is automatically added to the end of the text.
            ///
            /// To instead write text after the prompt, use [`lock_writer_append`].
            ///
            /// [`read_line`]: #method.read_line
            /// [`writeln!`]: https://doc.rust-lang.org/std/macro.writeln.html
            /// [`lock_writer_append`]: #method.lock_writer_append
            pub fn write_fmt(&self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }

            fn write_str(&self, line: &str) -> io::Result<()> {
                self.lock_writer_erase()?.write_str(line)
            }
        }
        /// ## Locking
        ///
        /// The following methods internally acquire both the read and write locks.
        ///
        /// The locks are released before the method returns.
        ///
        /// If either lock is already held, the method will block until it is released.
        impl<Term: Terminal> Interface<Term> {
            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt(&self, prompt: &str) -> io::Result<()> {
                self.lock_reader().set_prompt(prompt)
            }
            /// Sets the input buffer to the given string.
            pub fn set_buffer(&self, buf: &str) -> io::Result<()> {
                self.lock_reader().set_buffer(buf)
            }
            /// Sets the cursor position in the input buffer.
            pub fn set_cursor(&self, pos: usize) -> io::Result<()> {
                self.lock_reader().set_cursor(pos)
            }
            /// Adds a line to history.
            pub fn add_history(&self, line: String) {
                self.lock_reader().add_history(line);
            }
            /// Adds a line to history, unless it is identical to the most recent entry.
            pub fn add_history_unique(&self, line: String) {
                self.lock_reader().add_history_unique(line);
            }
            /// Removes all history entries.
            pub fn clear_history(&self) {
                self.lock_reader().clear_history();
            }
            /// Removes the history entry at the given index.
            pub fn remove_history(&self, idx: usize) {
                self.lock_reader().remove_history(idx);
            }
            /// Sets the maximum number of history entries.
            pub fn set_history_size(&self, n: usize) {
                self.lock_reader().set_history_size(n);
            }
            /// Truncates history to the only the most recent `n` entries.
            pub fn truncate_history(&self, n: usize) {
                self.lock_reader().truncate_history(n);
            }
            /// Sets the syntax highlighter for the input line.
            pub fn set_highlighter(&mut self, highlighter: Arc<dyn Highlighter + Send + Sync>) {
                self.highlighter = Some(highlighter);
            }
        }
    }

    pub mod memory
    {
        //! Implements an in-memory `Terminal` interface.
        use ::
        {
            *,
        };
        

        use std::cmp::min;
        use std::iter::repeat;
        use std::io;
        use std::sync::{Arc, Mutex, MutexGuard};
        use std::time::Duration;

        use crate::terminal::{
            CursorMode, RawRead, SignalSet, Size,
            Terminal, TerminalReader, TerminalWriter,
        };

        /// Default size of a `MemoryTerminal` buffer
        pub const DEFAULT_SIZE: Size = Size{
            columns: 80,
            lines: 24,
        };

        /// Implements an in-memory `Terminal` interface
        ///
        /// The contents of a `MemoryTerminal` are shared. That is, cloning
        /// a `MemoryTerminal` value will share the contained terminal buffer.
        #[derive(Clone, Debug)]
        pub struct MemoryTerminal {
            write: Arc<Mutex<Writer>>,
            read: Arc<Mutex<Reader>>,
        }

        #[derive(Debug)]
        struct Writer {
            memory: Vec<char>,
            col: usize,
            line: usize,
            cursor_mode: CursorMode,
            size: Size,
        }

        #[derive(Debug)]
        struct Reader {
            input: Vec<u8>,
            resize: Option<Size>,
        }
        /// Holds the lock on read operations of a `MemoryTerminal`.
        pub struct MemoryReadGuard<'a>(MutexGuard<'a, Reader>);

        /// Holds the lock on write operations of a `MemoryTerminal`.
        pub struct MemoryWriteGuard<'a>(MutexGuard<'a, Writer>);

        impl MemoryTerminal {
            /// Returns a new `MemoryTerminal` with the default buffer size.
            pub fn new() -> MemoryTerminal {
                MemoryTerminal::default()
            }
            /// Returns a new `MemoryTerminal` with the given buffer size.
            ///
            /// # Panics
            ///
            /// If either of the `lines` or `columns` fields are `0`.
            pub fn with_size(size: Size) -> MemoryTerminal {
                MemoryTerminal{
                    read: Arc::new(Mutex::new(Reader::new())),
                    write: Arc::new(Mutex::new(Writer::new(size))),
                }
            }
            /// Clears the terminal buffer and places the cursor at `(0, 0)`.
            pub fn clear_all(&self) {
                self.lock_writer().clear_all();
            }
            /// Clears all characters beginning at the cursor and ending at buffer end.
            pub fn clear_to_end(&self) {
                self.lock_writer().clear_to_end();
            }
            /// Clears the input buffer.
            pub fn clear_input(&self) {
                self.lock_reader().clear_input();
            }
            /// Returns whether any input remains to be read.
            pub fn has_input(&self) -> bool {
                self.lock_reader().has_input()
            }
            /// Returns an iterator over lines in the buffer.
            ///
            /// # Notes
            ///
            /// The returned iterator immutably borrows the contents of the
            /// `MemoryTerminal`. Attempting to perform a mutating operation on the
            /// parent `MemoryTerminal` while the `Lines` iterator lives will cause
            /// a panic.
            pub fn lines(&self) -> Lines {
                Lines{
                    writer: self.lock_writer(),
                    line: 0,
                }
            }
            /// Moves the cursor up `n` cells.
            pub fn move_up(&self, n: usize) {
                self.lock_writer().move_up(n);
            }
            /// Moves the cursor down `n` cells.
            pub fn move_down(&self, n: usize) {
                self.lock_writer().move_down(n);
            }
            /// Moves the cursor left `n` cells.
            pub fn move_left(&self, n: usize) {
                self.lock_writer().move_left(n);
            }
            /// Moves the cursor right `n` cells.
            pub fn move_right(&self, n: usize) {
                self.lock_writer().move_right(n);
            }
            /// Moves the cursor to the first column of the current line.
            pub fn move_to_first_column(&self) {
                self.lock_writer().move_to_first_column()
            }
            /// Pushes a character sequence to the back of the input queue.
            pub fn push_input(&self, s: &str) {
                self.lock_reader().push_input(s.as_bytes());
            }
            /// Reads some input from the input buffer.
            pub fn read_input(&self, buf: &mut [u8]) -> usize {
                self.lock_reader().read_input(buf)
            }
            /// Changes the size of the terminal buffer.
            /// The buffer will be truncated or filled with spaces, as necessary.
            ///
            /// # Panics
            ///
            /// If either of the `lines` or `columns` fields are `0` or if the area
            /// exceeds `usize` maximum.
            pub fn resize(&self, new_size: Size) {
                self.lock_writer().resize(new_size);
                self.lock_reader().resize(new_size);
            }
            /// Moves the contents of the buffer up `n` lines.
            /// The first `n` lines of text will be erased.
            pub fn scroll_up(&self, n: usize) {
                self.lock_writer().scroll_up(n);
            }
            /// Returns the `(line, column)` position of the cursor.
            pub fn cursor(&self) -> (usize, usize) {
                let r = self.lock_writer();
                (r.line, r.col)
            }
            /// Sets the cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) {
                self.lock_writer().set_cursor_mode(mode);
            }
            /// Returns the cursor mode.
            pub fn cursor_mode(&self) -> CursorMode {
                self.lock_writer().cursor_mode()
            }
            /// Returns the size of the terminal buffer.
            pub fn size(&self) -> Size {
                self.lock_writer().size
            }
            /// Writes some text into the buffer.
            ///
            /// If the text extends beyond the length of the current line without a
            /// newline character (`'\n'`), the extraneous text will be dropped.
            pub fn write(&self, s: &str) {
                self.lock_writer().write(s);
            }

            fn lock_reader(&self) -> MutexGuard<Reader> {
                self.read.lock().unwrap()
            }

            fn lock_writer(&self) -> MutexGuard<Writer> {
                self.write.lock().unwrap()
            }
        }

        impl Default for MemoryTerminal {
            fn default() -> MemoryTerminal {
                MemoryTerminal::with_size(DEFAULT_SIZE)
            }
        }

        impl Reader {
            fn new() -> Reader {
                Reader{
                    input: Vec::new(),
                    resize: None,
                }
            }

            fn has_input(&mut self) -> bool {
                self.resize.is_some() || !self.input.is_empty()
            }

            fn clear_input(&mut self) {
                self.input.clear();
            }

            fn push_input(&mut self, bytes: &[u8]) {
                self.input.extend(bytes);
            }

            fn read_input(&mut self, buf: &mut [u8]) -> usize {
                let n = min(buf.len(), self.input.len());

                buf[..n].copy_from_slice(&self.input[..n]);
                let _ = self.input.drain(..n);
                n
            }

            fn resize(&mut self, size: Size) {
                self.resize = Some(size);
            }
        }

        impl Writer {
            fn new(size: Size) -> Writer {
                assert!(size.lines != 0 && size.columns != 0,
                    "zero-area terminal buffer: {:?}", size);

                let n_chars = size.lines * size.columns;

                Writer{
                    memory: vec![' '; n_chars],
                    col: 0,
                    line: 0,
                    cursor_mode: CursorMode::Normal,
                    size: size,
                }
            }

            fn clear_all(&mut self) {
                for ch in &mut self.memory {
                    *ch = ' ';
                }
                self.col = 0;
                self.line = 0;
            }

            fn clear_to_end(&mut self) {
                let idx = self.index();

                for ch in &mut self.memory[idx..] {
                    *ch = ' ';
                }
            }

            fn move_up(&mut self, n: usize) {
                self.line = self.line.saturating_sub(n);
            }

            fn move_down(&mut self, n: usize) {
                self.line = min(self.size.lines - 1, self.line + n);
            }

            fn move_left(&mut self, n: usize) {
                self.col = self.col.saturating_sub(n);
            }

            fn move_right(&mut self, n: usize) {
                self.col = min(self.size.columns - 1, self.col + n);
            }

            fn move_to_first_column(&mut self) {
                self.col = 0;
            }

            fn resize(&mut self, new_size: Size) {
                if self.size != new_size {
                    let n_chars = new_size.lines.checked_mul(new_size.columns)
                        .unwrap_or_else(|| panic!("terminal size too large: {:?}", new_size));

                    assert!(n_chars != 0, "zero-area terminal buffer: {:?}", new_size);

                    let mut new_buf = Vec::with_capacity(n_chars);

                    let (n_copy, n_extra) = if new_size.columns > self.size.columns {
                        (self.size.columns, new_size.columns - self.size.columns)
                    } else {
                        (new_size.columns, 0)
                    };

                    for line in self.memory.chunks(self.size.columns).take(new_size.lines) {
                        new_buf.extend(&line[..n_copy]);
                        new_buf.extend(repeat(' ').take(n_extra));
                    }

                    if new_size.lines > self.size.lines {
                        let n_lines = new_size.lines - self.size.lines;
                        new_buf.extend(repeat(' ').take(n_lines * new_size.columns));
                    }

                    debug_assert_eq!(new_buf.len(), n_chars);

                    self.col = min(self.col, new_size.columns);
                    self.line = min(self.line, new_size.lines);
                    self.size = new_size;
                    self.memory = new_buf;
                }
            }

            fn scroll_up(&mut self, n: usize) {
                let chars = min(self.memory.len(), self.size.columns * n);
                self.memory.drain(..chars);
                self.memory.extend(repeat(' ').take(chars));
                self.line = self.line.saturating_sub(n);
            }

            fn set_cursor_mode(&mut self, mode: CursorMode) {
                self.cursor_mode = mode;
            }

            fn cursor_mode(&self) -> CursorMode {
                self.cursor_mode
            }

            fn write(&mut self, s: &str) {
                for ch in s.chars() {
                    if ch == '\n' {
                        self.advance_line();
                    } else if ch == '\r' {
                        self.col = 0;
                    } else {
                        self.write_char(ch);
                    }
                }
            }

            fn advance_line(&mut self) {
                self.line += 1;
                self.col = 0;
                if self.line == self.size.lines {
                    self.scroll_up(1);
                }
            }

            fn write_char(&mut self, ch: char) {
                if self.col >= self.size.columns {
                    self.advance_line();
                }

                let idx = self.index();
                self.memory[idx] = ch;
                self.col += 1;
            }

            fn index(&self) -> usize {
                self.line * self.size.columns + self.col
            }
        }
        /// Iterator over lines in a `MemoryTerminal` buffer.
        ///
        /// Note that while this value behaves as an iterator, it cannot implement
        /// the `Iterator` trait because its yielded values borrow `self`.
        pub struct Lines<'a> {
            writer: MutexGuard<'a, Writer>,
            line: usize,
        }

        impl<'a> Lines<'a> {
            /// Returns the next line in the buffer.
            pub fn next(&mut self) -> Option<&[char]> {
                if self.line >= self.writer.size.lines {
                    None
                } else {
                    let start = self.writer.size.columns * self.line;
                    self.line += 1;
                    let end = self.writer.size.columns * self.line;

                    Some(&self.writer.memory[start..end])
                }
            }
            /// Returns the number of lines remaining in the iterator.
            pub fn lines_remaining(&self) -> usize {
                self.writer.size.lines - self.line
            }
        }

        impl Terminal for MemoryTerminal {
            // No preparation needed for in-memory terminal
            type PrepareState = ();
            //type Reader = MemoryReadGuard;
            //type Writer = MemoryWriteGuard;

            fn name(&self) -> &str { "memory-terminal" }

            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a> {
                Box::new(MemoryReadGuard(self.lock_reader()))
            }

            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a> {
                Box::new(MemoryWriteGuard(self.lock_writer()))
            }
        }

        impl<'a> TerminalReader<MemoryTerminal> for MemoryReadGuard<'a> {
            fn wait_for_input(&mut self, _timeout: Option<Duration>) -> io::Result<bool> {
                Ok(!self.0.input.is_empty())
            }

            fn prepare(&mut self, _block_signals: bool, _report_signals: SignalSet)
                    -> io::Result<()> { Ok(()) }

            unsafe fn prepare_with_lock(&mut self,
                    _lock: &mut dyn TerminalWriter<MemoryTerminal>,
                    _block_signals: bool, _report_signals: SignalSet)
                    -> io::Result<()> { Ok(()) }

            fn restore(&mut self, _state: ()) -> io::Result<()> { Ok(()) }

            unsafe fn restore_with_lock(&mut self,
                    _lock: &mut dyn TerminalWriter<MemoryTerminal>, _state: ())
                    -> io::Result<()> { Ok(()) }

            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead> {
                if let Some(size) = self.0.resize.take() {
                    return Ok(RawRead::Resize(size));
                }

                buf.reserve(16);

                let cap = buf.capacity();
                let len = buf.len();
                let n;

                unsafe {
                    buf.set_len(cap);
                    n = self.0.read_input(&mut buf[len..]);
                    buf.set_len(len + n);
                }

                Ok(RawRead::Bytes(n))
            }
        }

        impl<'a> TerminalWriter<MemoryTerminal> for MemoryWriteGuard<'a> {
            fn size(&self) -> io::Result<Size> {
                Ok(self.0.size)
            }

            fn clear_screen(&mut self) -> io::Result<()> {
                self.0.clear_all();
                Ok(())
            }

            fn clear_to_screen_end(&mut self) -> io::Result<()> {
                self.0.clear_to_end();
                Ok(())
            }

            fn move_up(&mut self, n: usize) -> io::Result<()> {
                self.0.move_up(n);
                Ok(())
            }

            fn move_down(&mut self, n: usize) -> io::Result<()> {
                self.0.move_down(n);
                Ok(())
            }

            fn move_left(&mut self, n: usize) -> io::Result<()> {
                self.0.move_left(n);
                Ok(())
            }

            fn move_right(&mut self, n: usize) -> io::Result<()> {
                self.0.move_right(n);
                Ok(())
            }

            fn move_to_first_column(&mut self) -> io::Result<()> {
                self.0.move_to_first_column();
                Ok(())
            }

            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.0.set_cursor_mode(mode);
                Ok(())
            }

            fn write(&mut self, s: &str) -> io::Result<()> {
                self.0.write(s);
                Ok(())
            }

            fn flush(&mut self) -> io::Result<()> { Ok(()) }
        }
    }

    pub mod prompter
    {
        //! Provides access to prompt input state
        use ::
        {
            *,
        };
        
        use std::io;
        use std::mem::replace;
        use std::ops::Range;
        use std::sync::Arc;
        use std::time::Instant;

        use mortal::FindResult;

        use crate::chars::{is_ctrl, is_printable, DELETE, EOF};
        use crate::command::{Category, Command};
        use crate::complete::Completion;
        use crate::function::Function;
        use crate::reader::{BindingIter, InputState, ReadLock, ReadResult};
        use crate::table::{format_columns, Line, Table};
        use crate::terminal::{CursorMode, Signal, Size, Terminal};
        use crate::util::{
            get_open_paren, find_matching_paren, first_word,
            longest_common_prefix, repeat_char,
            back_n_words, forward_n_words,
            backward_char, forward_char, backward_word, forward_word,
            word_start, word_end, RangeArgument,
        };
        use crate::variables::VariableIter;
        use crate::writer::{
            BLINK_DURATION, display_str,
            Digit, Display, HistoryIter, PromptType, Writer, WriteLock,
        };

        /// Provides access to the current state of input while a `read_line` call
        /// is in progress.
        ///
        /// Holds read and write locks on terminal operations.
        /// See [`Interface`] for more information about concurrent operations.
        ///
        /// Instances of this type cannot be constructed by public methods.
        /// Instead, an instance is created internally during a call to [`read_line`].
        ///
        /// [`Interface`]: ../interface/struct.Interface.html
        /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
        pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminal> {
            pub read: &'a mut ReadLock<'b, Term>,
            write: WriteLock<'b, Term>,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Prompter<'a, 'b, Term> {
            pub fn new(read: &'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term>)
                    -> Prompter<'a, 'b, Term> {
                Prompter{read, write}
            }
            /// Returns a `Writer` instance using the currently held write lock.
            ///
            /// This method will move the cursor to a new line after the prompt,
            /// allowing output to be written without corrupting the prompt text.
            /// The prompt will be redrawn when the `Writer` instance is dropped.
            ///
            /// To instead erase the prompt and write text, use [`writer_erase`].
            ///
            /// [`writer_erase`]: #method.writer_erase
            pub fn writer_append<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>> {
                Writer::with_ref(&mut self.write, false)
            }
            /// Returns a `Writer` instance using the currently held write lock.
            ///
            /// This method will erase the prompt, allowing output to be written
            /// without corrupting the prompt text. The prompt will be redrawn
            /// when the `Writer` instance is dropped.
            ///
            /// To instead write text after the prompt, use [`writer_append`].
            ///
            /// [`writer_append`]: #method.writer_append
            pub fn writer_erase<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>> {
                Writer::with_ref(&mut self.write, true)
            }
            /// Resets input state at the start of `read_line`
            fn reset_input(&mut self) {
                self.read.reset_data();
                self.write.reset_data();
            }

            pub fn start_read_line(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.is_prompt_drawn = true;
                self.write.update_size()?;
                self.write.draw_prompt()
            }

            pub fn end_read_line(&mut self) -> io::Result<()> {
                self.write.expire_blink()?;

                if self.read.overwrite_mode {
                    self.write.set_cursor_mode(CursorMode::Normal)?;
                }
                if self.write.is_prompt_drawn {
                    self.write.move_to_end()?;
                    self.write.write_str("\n")?;
                    self.write.is_prompt_drawn = false;
                }

                self.reset_input();
                self.read.state = InputState::Inactive;

                Ok(())
            }

            pub fn handle_input(&mut self, ch: char) -> io::Result<Option<ReadResult>> {
                self.write.expire_blink()?;

                match self.read.state {
                    InputState::Inactive => panic!("input received in inactive state"),
                    InputState::NewSequence => {
                        if ch == EOF && self.write.buffer.is_empty() {
                            self.write.write_str("\n")?;
                            self.write.is_prompt_drawn = false;
                            return Ok(Some(ReadResult::Eof));
                        } else {
                            self.read.sequence.push(ch);
                            self.execute_sequence()?;

                            if self.read.input_accepted {
                                let s = replace(&mut self.write.buffer, String::new());
                                return Ok(Some(ReadResult::Input(s)));
                            }
                        }
                    }
                    InputState::ContinueSequence{expiry: _} => {
                        self.read.sequence.push(ch);

                        self.execute_sequence()?;

                        if self.read.input_accepted {
                            let s = replace(&mut self.write.buffer, String::new());
                            return Ok(Some(ReadResult::Input(s)));
                        }
                    }
                    InputState::Number => {
                        if let Some(digit) = ch.to_digit(10) {
                            self.write.input_arg.input(digit as i32);

                            if self.write.input_arg.is_out_of_bounds() {
                                self.read.state = InputState::NewSequence;
                                self.write.input_arg = Digit::None;
                                self.write.explicit_arg = false;
                                self.write.redraw_prompt(PromptType::Normal)?;
                            } else {
                                self.write.redraw_prompt(PromptType::Number)?;
                            }
                        } else {
                            self.read.state = InputState::NewSequence;
                            self.write.redraw_prompt(PromptType::Normal)?;
                            self.read.macro_buffer.insert(0, ch);
                        }
                    }
                    InputState::CharSearch{n, backward} => {
                        if n != 0 {
                            if backward {
                                self.write.backward_search_char(n, ch)?;
                            } else {
                                self.write.forward_search_char(n, ch)?;
                            }
                        }
                        self.read.state = InputState::NewSequence;
                    }
                    InputState::TextSearch => {
                        if ch == DELETE {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.pop();
                                write.last_search.clone_from(&write.search_buffer);
                            }
                            self.write.search_history_update()?;
                        } else if self.is_abort(ch) {
                            self.abort_search_history()?;
                        } else if is_ctrl(ch) {
                            // End search, handle input after cancelling
                            self.end_search_history()?;
                            self.read.macro_buffer.insert(0, ch);
                        } else {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.push(ch);
                                write.last_search.clone_from(&write.search_buffer);
                            }
                            self.write.search_history_update()?;
                        }
                    }
                    InputState::CompleteIntro => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.write_str("\n")?;
                                self.show_completions_page(0)?;
                            }
                            '\r' | '\n' => {
                                self.write.write_str("\n")?;
                                self.show_completions_line(0)?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.write_str("\n")?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::CompleteMore(offset) => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.clear_prompt()?;
                                self.show_completions_page(offset)?;
                            }
                            '\r' | '\n' => {
                                self.write.clear_prompt()?;
                                self.show_completions_line(offset)?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.clear_prompt()?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::QuotedInsert(n) => {
                        if n != 0 {
                            self.insert(n, ch)?;
                        }
                        self.read.state = InputState::NewSequence;
                    }
                }

                Ok(None)
            }
            /// Returns the current buffer.
            pub fn buffer(&self) -> &str {
                &self.write.buffer
            }
            /// Returns the "backup" buffer.
            ///
            /// When the user is currently editing a history entry, the backup buffer
            /// contains the original user input.
            pub fn backup_buffer(&self) -> &str {
                &self.write.backup_buffer
            }
            /// Returns the command `Category` of the most recently executed command.
            ///
            /// Some commands may use this to influence behavior of repeated commands.
            pub fn last_command_category(&self) -> Category {
                self.read.last_cmd
            }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars(&self) -> &str {
                &self.read.word_break
            }
            /// Sets the buffer to the given value.
            ///
            /// The cursor is moved to the end of the buffer.
            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
                self.write.set_buffer(buf)
            }
            /// Returns the current position of the cursor.
            pub fn cursor(&self) -> usize {
                self.write.cursor
            }
            /// Sets the cursor to the given position within the buffer.
            ///
            /// # Panics
            ///
            /// If the given position is out of bounds or is not aligned to `char` boundaries.
            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
                self.write.set_cursor(pos)
            }
            /// Sets the prompt that will be displayed when `read_line` is called.
            ///
            /// # Notes
            ///
            /// If `prompt` contains any terminal escape sequences (e.g. color codes),
            /// such escape sequences should be immediately preceded by the character
            /// `'\x01'` and immediately followed by the character `'\x02'`.
            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
                self.write.set_prompt(prompt)
            }
            /// Returns the size of the terminal at the last draw operation.
            pub fn screen_size(&self) -> Size {
                self.write.screen_size
            }
            /// Returns whether a numerical argument was explicitly supplied by the user.
            pub fn explicit_arg(&self) -> bool {
                self.write.explicit_arg
            }
            /// Returns the current input sequence.
            pub fn sequence(&self) -> &str {
                &self.read.sequence
            }
            /// Returns an iterator over bound sequences
            pub fn bindings(&self) -> BindingIter {
                self.read.bindings()
            }
            /// Returns an iterator over variable values.
            pub fn variables(&self) -> VariableIter {
                self.read.variables()
            }
            /// Returns an iterator over history entries
            pub fn history(&self) -> HistoryIter {
                self.write.history()
            }
            /// Returns the index into history currently being edited.
            ///
            /// If the user is not editing a line of history, `None` is returned.
            pub fn history_index(&self) -> Option<usize> {
                self.write.history_index
            }
            /// Returns the current number of history entries.
            pub fn history_len(&self) -> usize {
                self.write.history.len()
            }

            fn next_history(&mut self, n: usize) -> io::Result<()> {
                self.write.next_history(n)
            }

            fn prev_history(&mut self, n: usize) -> io::Result<()> {
                self.write.prev_history(n)
            }
            /// Selects the history entry currently being edited by the user.
            ///
            /// Setting the entry to `None` will result in editing the input buffer.
            ///
            /// # Panics
            ///
            /// If the index is out of bounds.
            pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
                self.write.select_history_entry(new)
            }
            /// Returns the current set of completions.
            ///
            /// Unless the most recent command executed was one operating on completion
            /// sets, the result is `None`.
            pub fn completions(&self) -> Option<&[Completion]> {
                self.read.completions.as_ref().map(|v| &v[..])
            }
            /// Sets the current set of completions.
            ///
            /// This completion set is accessed by commands such as `complete` and
            /// `possible-completions`.
            ///
            /// This set will only remain active until the end of the next
            /// non-completion command's execution. Therefore, any `Function`
            /// that uses this method must be of the `Complete` category.
            pub fn set_completions(&mut self, completions: Option<Vec<Completion>>) {
                self.read.completions = completions;
            }
            /// Attempts to execute the current sequence.
            ///
            /// If no bindings match and the sequence contains only printable characters,
            /// the sequence will be inserted as text.
            ///
            /// Returns `true` if a complete sequence was found and executed.
            fn execute_sequence(&mut self) -> io::Result<()> {
                match self.find_binding(&self.read.sequence) {
                    FindResult::Found(cmd) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.read.state = InputState::NewSequence;
                        self.execute_command(cmd, n, ch)?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.read.state = InputState::NewSequence;
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => {
                        let expiry = None;
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                    FindResult::Undecided(_) => {
                        let expiry = self.keyseq_expiry();
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                }

                Ok(())
            }

            fn force_execute_sequence(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;

                match self.find_binding(&self.read.sequence) {
                    FindResult::Found(cmd) |
                    FindResult::Undecided(cmd) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.execute_command(cmd, n, ch)?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => unreachable!(),
                }

                Ok(())
            }
            /// Execute the command `SelfInsert` on the first character in the input
            /// sequence, if it is printable. Then, queue the remaining characters
            /// so they may be reinterpreted.
            fn insert_first_char(&mut self) -> io::Result<()> {
                let (first, rest) = {
                    let mut chars = self.read.sequence.chars();

                    (chars.next().unwrap(), chars.as_str().to_owned())
                };

                self.read.sequence.clear();

                if is_printable(first) {
                    let n = self.write.input_arg.to_i32();
                    self.execute_command(Command::SelfInsert, n, first)?;
                }

                if !rest.is_empty() {
                    self.read.queue_input(&rest);
                }

                Ok(())
            }

            fn find_binding(&self, seq: &str) -> FindResult<Command> {
                self.read.bindings.find(seq).cloned()
            }

            fn get_function(&self, name: &str) -> Option<&Arc<dyn Function<Term>>> {
                self.read.functions.get(name)
            }

            fn is_abort(&self, ch: char) -> bool {
                let mut buf = [0; 4];
                let s = ch.encode_utf8(&mut buf);

                self.find_binding(&s) == FindResult::Found(Command::Abort)
            }

            fn execute_command(&mut self, cmd: Command, n: i32, ch: char) -> io::Result<()> {
                use crate::command::Command::*;

                let mut category = cmd.category();

                if self.read.overwrite_mode {
                    match cmd {
                        DigitArgument | SelfInsert => (),
                        BackwardDeleteChar if n >= 0 => (),
                        _ => self.read.overwritten_chars.clear()
                    }
                }

                match cmd {
                    Abort => (),
                    AcceptLine => {
                        self.accept_input()?;
                    }
                    Complete => {
                        if !self.read.disable_completion {
                            self.complete_word()?;
                        } else if is_printable(ch) {
                            self.execute_command(SelfInsert, n, ch)?;
                        }
                    }
                    InsertCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some(completions) = self.read.completions.take() {
                            self.insert_completions(&completions)?;
                            self.read.completions = Some(completions);
                        }
                    }
                    PossibleCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some(completions) = self.read.completions.take() {
                            self.show_completions(&completions)?;
                            self.read.completions = Some(completions);
                        }
                    }
                    MenuComplete => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.next_completion(n as usize)?;
                        } else {
                            self.prev_completion((-n) as usize)?;
                        }
                    }
                    MenuCompleteBackward => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.prev_completion(n as usize)?;
                        } else {
                            self.next_completion((-n) as usize)?;
                        }
                    }
                    DigitArgument => {
                        self.read.state = InputState::Number;
                        self.write.set_digit_from_char(ch);
                        self.write.redraw_prompt(PromptType::Number)?;
                    }
                    SelfInsert => {
                        if n > 0 {
                            let n = n as usize;

                            if self.read.overwrite_mode {
                                self.overwrite(n, ch)?;
                            } else {
                                self.insert(n, ch)?;
                            }

                            if self.read.blink_matching_paren {
                                if let Some(open) = get_open_paren(ch) {
                                    if let Some(pos) = find_matching_paren(
                                            &self.write.buffer[..self.write.cursor],
                                            &self.read.string_chars, open, ch) {
                                        self.blink(pos)?;
                                    }
                                }
                            }
                        }
                    }
                    TabInsert => {
                        if n > 0 {
                            self.insert(n as usize, '\t')?;
                        }
                    }
                    InsertComment => {
                        if self.explicit_arg() &&
                                self.write.buffer.starts_with(&self.read.comment_begin[..]) {
                            self.write.move_to(0)?;
                            let n = self.read.comment_begin.len();

                            self.delete_range(..n)?;
                            self.accept_input()?;
                        } else {
                            self.write.move_to(0)?;
                            let s = self.read.comment_begin.clone();
                            self.insert_str(&s)?;
                            self.accept_input()?;
                        }
                    }
                    BackwardChar => {
                        if n > 0 {
                            self.write.backward_char(n as usize)?;
                        } else if n < 0 {
                            self.write.forward_char((-n) as usize)?;
                        }
                    }
                    ForwardChar => {
                        if n > 0 {
                            self.write.forward_char(n as usize)?;
                        } else if n < 0 {
                            self.write.backward_char((-n) as usize)?;
                        }
                    }
                    CharacterSearch => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: false,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: (-n) as usize,
                                backward: true,
                            };
                        }
                    }
                    CharacterSearchBackward => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: true,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: (-n) as usize,
                                backward: false,
                            };
                        }
                    }
                    BackwardWord => {
                        if n > 0 {
                            self.backward_word(n as usize)?;
                        } else if n < 0 {
                            self.forward_word((-n) as usize)?;
                        }
                    }
                    ForwardWord => {
                        if n > 0 {
                            let pos = forward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            self.write.move_to(pos)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            self.write.move_to(pos)?;
                        }
                    }
                    BackwardKillLine => {
                        let r = ..self.write.cursor;
                        self.kill_range(r)?;
                    }
                    KillLine => {
                        let r = self.write.cursor..;
                        self.kill_range(r)?;
                    }
                    BackwardKillWord => {
                        if n > 0 {
                            let pos = backward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        }
                    }
                    KillWord => {
                        if n > 0 {
                            let pos = forward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = backward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        }
                    }
                    UnixWordRubout => {
                        if n > 0 {
                            let pos = backward_word(n as usize,
                                &self.write.buffer, self.write.cursor, " \t\n");
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, " \t\n");
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        }
                    }
                    ClearScreen => {
                        self.write.clear_screen()?;
                    }
                    BeginningOfLine => self.write.move_to(0)?,
                    EndOfLine => self.write.move_to_end()?,
                    BackwardDeleteChar => {
                        if n > 0 {
                            if self.read.overwrite_mode {
                                self.overwrite_back(n as usize)?;
                            } else {
                                let pos = backward_char(n as usize,
                                    &self.write.buffer, self.write.cursor);
                                let r = pos..self.write.cursor;
                                self.delete_range(r)?;
                            }
                        } else if n < 0 {
                            let pos = forward_char((-n) as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = self.write.cursor..pos;
                            self.delete_range(r)?;
                        }
                    }
                    DeleteChar => {
                        if n > 0 {
                            let pos = forward_char(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = self.write.cursor..pos;
                            self.delete_range(r)?;
                        } else if n < 0 {
                            let pos = backward_char(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = pos..self.write.cursor;
                            self.delete_range(r)?;
                        }
                    }
                    TransposeChars => {
                        if n != 0 && self.write.cursor != 0 {
                            let (src, dest);

                            if !self.explicit_arg() && self.write.cursor == self.write.buffer.len() {
                                let end = backward_char(1, &self.write.buffer, self.write.cursor);
                                let start = backward_char(1, &self.write.buffer, end);

                                src = start..end;
                                dest = end..self.write.cursor;
                            } else {
                                let start = backward_char(1, &self.write.buffer, self.write.cursor);
                                let end = self.write.cursor;

                                src = start..end;

                                dest = if n < 0 {
                                    let back = backward_char((-n) as usize, &self.write.buffer, start);
                                    back..start
                                } else {
                                    let fwd = forward_char(n as usize + 1, &self.write.buffer, start);
                                    end..fwd
                                };
                            }

                            self.transpose_range(src, dest)?;
                        }
                    }
                    TransposeWords => {
                        if n != 0 {
                            if let Some(first) = first_word(&self.write.buffer[..self.write.cursor], &self.read.word_break) {
                                let start = word_start(&self.write.buffer, self.write.cursor, &self.read.word_break);

                                if first != start {
                                    let (src, dest);

                                    if !self.explicit_arg() && start == self.write.buffer.len() {
                                        let dest_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                        let dest_end = word_end(&self.write.buffer, dest_start, &self.read.word_break);

                                        let src_start = backward_word(1, &self.write.buffer, dest_start, &self.read.word_break);
                                        let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                        src = src_start..src_end;
                                        dest = dest_start..dest_end;
                                    } else {
                                        let src_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                        let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                        src = src_start..src_end;

                                        dest = if n < 0 {
                                            back_n_words((-n) as usize, &self.write.buffer, src_start, &self.read.word_break)
                                        } else {
                                            forward_n_words(n as usize, &self.write.buffer, src_start, &self.read.word_break)
                                        };
                                    }

                                    self.transpose_range(src, dest)?;
                                }
                            }
                        }
                    }
                    BeginningOfHistory => {
                        self.select_history_entry(Some(0))?;
                    }
                    EndOfHistory => {
                        self.select_history_entry(None)?;
                    }
                    NextHistory => {
                        if n > 0 {
                            self.next_history(n as usize)?;
                        } else if n < 0 {
                            self.prev_history((-n) as usize)?;
                        }
                    }
                    PreviousHistory => {
                        if n > 0 {
                            self.prev_history(n as usize)?;
                        } else if n < 0 {
                            self.next_history((-n) as usize)?;
                        }
                    }
                    ForwardSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history(false)?;
                        } else {
                            self.write.start_search_history(false)?;
                        }
                    }
                    ReverseSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history(true)?;
                        } else {
                            self.write.start_search_history(true)?;
                        }
                    }
                    HistorySearchForward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search(false)?;
                        } else {
                            self.write.start_history_search(false)?;
                        }
                    }
                    HistorySearchBackward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search(true)?;
                        } else {
                            self.write.start_history_search(true)?;
                        }
                    }
                    QuotedInsert => {
                        self.read.state = InputState::QuotedInsert(
                            if n >= 0 { n as usize } else { 0 });
                    }
                    OverwriteMode => {
                        self.read.overwrite_mode = !self.read.overwrite_mode;

                        if !self.read.overwrite_mode {
                            self.read.overwritten_append = 0;
                            self.read.overwritten_chars.clear();
                        }

                        let mode = if self.read.overwrite_mode {
                            CursorMode::Overwrite
                        } else {
                            CursorMode::Normal
                        };

                        self.write.set_cursor_mode(mode)?;
                    }
                    Yank => {
                        self.yank()?;
                    }
                    YankPop => {
                        self.yank_pop()?;
                    }
                    Custom(ref name) => {
                        if let Some(fun) = self.get_function(name).cloned() {
                            fun.execute(self, n, ch)?;

                            category = fun.category();
                        }
                    }
                    Macro(ref seq) => {
                        self.read.queue_input(seq);
                    }
                }

                if category != Category::Digit {
                    self.write.input_arg = Digit::None;
                    self.write.explicit_arg = false;

                    self.read.last_cmd = category;

                    if category != Category::Complete {
                        self.read.completions = None;
                    }

                    if category != Category::Yank {
                        self.read.last_yank = None;
                    }
                }

                Ok(())
            }
            /// Accepts the current input buffer as user input.
            ///
            /// This method may be called by a [`Function`] implementation, immediately
            /// before ending execution, in order to simulate the `accept-line` command;
            /// e.g. to implement a command that extends the default behavior of the
            /// `accept-line` action.
            ///
            /// Behavior of this method is undefined if called outside of a `Function`
            /// implementation.
            ///
            /// [`Function`]: ../function/trait.Function.html
            pub fn accept_input(&mut self) -> io::Result<()> {
                self.write.move_to_end()?;
                self.write.write_str("\n")?;
                self.read.input_accepted = true;
                self.write.is_prompt_drawn = false;
                Ok(())
            }
            /// Moves the cursor to the given position, waits for 500 milliseconds
            /// (or until next user input), then restores the original cursor position.
            ///
            /// # Panics
            ///
            /// If the given position is out of bounds or is not aligned to `char` boundaries.
            pub fn blink(&mut self, pos: usize) -> io::Result<()> {
                self.write.blink(pos)?;

                self.read.max_wait_duration = Some(BLINK_DURATION);

                Ok(())
            }

            fn check_expire_blink(&mut self, now: Instant) -> io::Result<()> {
                if self.write.check_expire_blink(now)? {
                    self.read.max_wait_duration = None;
                }

                Ok(())
            }

            fn check_expire_sequence(&mut self, now: Instant) -> io::Result<()> {
                if let InputState::ContinueSequence{expiry: Some(expiry)} = self.read.state {
                    if now >= expiry {
                        self.read.max_wait_duration = None;
                        self.force_execute_sequence()?;
                    }
                }

                Ok(())
            }

            fn keyseq_expiry(&mut self) -> Option<Instant> {
                if let Some(t) = self.read.keyseq_timeout {
                    self.read.max_wait_duration = Some(t);
                    Some(Instant::now() + t)
                } else {
                    None
                }
            }

            pub fn check_expire_timeout(&mut self) -> io::Result<()> {
                let now = Instant::now();

                self.check_expire_blink(now)?;
                self.check_expire_sequence(now)
            }

            fn expire_blink(&mut self) -> io::Result<()> {
                self.read.max_wait_duration = None;
                self.write.expire_blink()
            }

            fn build_completions(&mut self) {
                let compl = self.read.completer.clone();
                let end = self.write.cursor;
                let start = compl.word_start(&self.write.buffer, end, self);

                if start > end {
                    panic!("Completer::word_start returned invalid index; \
                        start > end ({} > {})", start, end);
                }

                let unquoted = compl.unquote(&self.write.buffer[start..end]).into_owned();

                let completions = compl.complete(&unquoted, self, start, end);
                let n_completions = completions.as_ref().map_or(0, |c| c.len());

                self.read.completions = completions;
                self.read.completion_index = n_completions;
                self.read.completion_start = start;
                self.read.completion_prefix = end;
            }

            fn complete_word(&mut self) -> io::Result<()> {
                if let Some(completions) = self.read.completions.take() {
                    if completions.len() == 1 {
                        self.substitute_completion(&completions[0])?;
                    } else {
                        self.show_completions(&completions)?;
                        self.read.completions = Some(completions);
                    }
                } else {
                    self.build_completions();
                    let completions = self.read.completions.take().unwrap_or_default();

                    if completions.len() == 1 {
                        self.substitute_completion(&completions[0])?;
                    } else if !completions.is_empty() {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;

                        {
                            let pfx = longest_common_prefix(completions.iter()
                                .map(|compl| &compl.completion[..]))
                                .unwrap_or_default();
                            self.replace_str_forward(start..end, &pfx)?;
                        }

                        self.read.completions = Some(completions);
                    }
                }

                Ok(())
            }

            fn substitute_completion(&mut self, compl: &Completion) -> io::Result<()> {
                let mut s = self.read.completer.quote(&compl.completion);

                if let Some(suffix) = compl.suffix.with_default(self.read.completion_append_character) {
                    s.to_mut().push(suffix);
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;
                self.replace_str_forward(start..end, &s)
            }

            fn insert_completions(&mut self, completions: &[Completion]) -> io::Result<()> {
                let mut words = String::new();

                for compl in completions {
                    words.push_str(&self.read.completer.unquote(&compl.completion));
                    words.push(' ');
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;

                self.replace_str_forward(start..end, &words)
            }

            fn show_completions(&mut self, completions: &[Completion]) -> io::Result<()> {
                if completions.is_empty() {
                    return Ok(());
                }

                let eff_width = self.write.screen_size.columns
                    .min(self.read.completion_display_width);

                let completions = completions.iter()
                    .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                    .collect::<Vec<_>>();

                let cols = format_columns(&completions, eff_width,
                    self.read.print_completions_horizontally);
                let table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                    self.read.print_completions_horizontally);

                self.write.write_str("\n")?;

                let n_completions = completions.len();

                if self.read.page_completions &&
                        n_completions >= self.read.completion_query_items {
                    // TODO: Replace borrowed data in `Table` with owned data.
                    // Then, store table here to avoid regenerating column widths
                    self.start_page_completions(n_completions)
                } else {
                    self.show_list_completions(table)?;
                    self.write.draw_prompt()
                }
            }

            fn start_page_completions(&mut self, n_completions: usize) -> io::Result<()> {
                self.read.state = InputState::CompleteIntro;
                self.write.redraw_prompt(PromptType::CompleteIntro(n_completions))
            }

            fn end_page_completions(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.prompt_type = PromptType::Normal;
                self.write.draw_prompt()
            }

            fn is_paging_completions(&self) -> bool {
                match self.read.state {
                    InputState::CompleteMore(_) => true,
                    _ => false
                }
            }

            fn show_completions_page(&mut self, offset: usize) -> io::Result<()> {
                if let Some(compl) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min(self.read.completion_display_width);
                    let n_lines = self.write.screen_size.lines - 1;

                    let completions = compl.iter()
                        .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                        .collect::<Vec<_>>();

                    let cols = format_columns(&completions, width,
                        self.read.print_completions_horizontally);
                    let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                        self.read.print_completions_horizontally);

                    for row in table.by_ref().skip(offset).take(n_lines) {
                        self.show_completion_line(row)?;
                    }

                    if table.has_more() {
                        self.read.completions = Some(compl);
                        self.read.state = InputState::CompleteMore(offset + n_lines);
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok(())
            }

            fn show_completions_line(&mut self, offset: usize) -> io::Result<()> {
                if let Some(compl) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min(self.read.completion_display_width);
                    let completions = compl.iter()
                        .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                        .collect::<Vec<_>>();

                    let cols = format_columns(&completions, width,
                        self.read.print_completions_horizontally);
                    let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                        self.read.print_completions_horizontally);

                    if let Some(row) = table.by_ref().skip(offset).next() {
                        self.show_completion_line(row)?;
                    }

                    if table.has_more() {
                        self.read.completions = Some(compl);
                        self.read.state = InputState::CompleteMore(offset + 1);
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok(())
            }

            fn show_completion_line<S: AsRef<str>>(&mut self, line: Line<S>) -> io::Result<()> {
                let mut space = 0;

                for (width, name) in line {
                    self.write.move_right(space)?;
                    self.write.write_str(name)?;
                    space = width - name.chars().count();
                }

                self.write.write_str("\n")
            }

            fn show_list_completions<S: AsRef<str>>(&mut self, table: Table<S>) -> io::Result<()> {
                for line in table {
                    let mut space = 0;

                    for (width, name) in line {
                        self.write.move_right(space)?;
                        self.write.write_str(name)?;
                        space = width - name.chars().count();
                    }
                    self.write.write_str("\n")?;
                }

                Ok(())
            }

            fn next_completion(&mut self, n: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let max = len + 1;

                let old = self.read.completion_index;
                let new = (old + n) % max;

                if old != new {
                    self.set_completion(new)?;
                }

                Ok(())
            }

            fn prev_completion(&mut self, n: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let max = len + 1;

                let old = self.read.completion_index;
                let new = if n <= old {
                    max - old - n
                } else {
                    old - n
                };

                self.set_completion(new)
            }

            fn set_completion(&mut self, new: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let old = self.read.completion_index;

                if old != new {
                    self.read.completion_index = new;

                    if new == len {
                        let start = self.read.completion_prefix;
                        let end = self.write.cursor;

                        self.delete_range(start..end)?;
                    } else {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;
                        let s = self.read.completions.as_ref().unwrap()[new]
                            .completion(self.read.completion_append_character).into_owned();

                        self.replace_str_forward(start..end, &s)?;
                    }
                }

                Ok(())
            }

            fn abort_search_history(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.read.last_cmd = Category::Other;
                self.write.abort_search_history()
            }

            fn end_search_history(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.end_search_history()
            }

            pub fn handle_resize(&mut self, size: Size) -> io::Result<()> {
                self.expire_blink()?;

                if self.is_paging_completions() {
                    self.end_page_completions()?;
                }

                self.write.screen_size = size;

                let p = self.write.prompt_type;
                self.write.redraw_prompt(p)
            }

            pub fn handle_signal(&mut self, signal: Signal) -> io::Result<()> {
                self.expire_blink()?;

                match signal {
                    Signal::Continue => {
                        self.write.draw_prompt()?;
                    }
                    Signal::Interrupt => {
                        self.read.macro_buffer.clear();
                        self.write.move_to_end()?;

                        if self.read.echo_control_characters {
                            self.write.write_str("^C")?;
                        }

                        self.write.write_str("\n")?;
                        self.reset_input();
                        self.write.draw_prompt()?;
                    }
                    _ => ()
                }

                Ok(())
            }

            fn backward_word(&mut self, n: usize) -> io::Result<()> {
                let pos = backward_word(n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break);
                self.write.move_to(pos)
            }

            fn forward_word(&mut self, n: usize) -> io::Result<()> {
                let pos = forward_word(n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break);
                self.write.move_to(pos)
            }
            /// Deletes a range of text from the input buffer.
            ///
            /// # Panics
            ///
            /// If the given range is out of bounds or is not aligned to `char` boundaries.
            pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                self.write.delete_range(range)
            }
            /// Deletes a range from the buffer and adds the removed text to the
            /// kill ring.
            ///
            /// # Panics
            ///
            /// If the given range is out of bounds or is not aligned to `char` boundaries.
            pub fn kill_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                let len = end - start;

                if len != 0 {
                    let buf = self.write.buffer[start..end].to_owned();

                    if self.read.last_cmd != Category::Kill {
                        self.push_kill_ring(buf);
                    } else if end == self.write.cursor {
                        self.prepend_kill_ring(buf);
                    } else {
                        self.append_kill_ring(buf);
                    }

                    self.delete_range(start..end)?;
                }

                Ok(())
            }

            fn push_kill_ring(&mut self, s: String) {
                if self.read.kill_ring.len() == self.read.kill_ring.capacity() {
                    self.read.kill_ring.pop_back();
                }
                self.read.kill_ring.push_front(s);
            }

            fn rotate_kill_ring(&mut self) {
                if let Some(kill) = self.read.kill_ring.pop_front() {
                    self.read.kill_ring.push_back(kill);
                }
            }

            fn append_kill_ring(&mut self, s: String) {
                if let Some(kill) = self.read.kill_ring.front_mut() {
                    kill.push_str(&s);
                    return;
                }
                self.push_kill_ring(s);
            }

            fn prepend_kill_ring(&mut self, s: String) {
                if let Some(kill) = self.read.kill_ring.front_mut() {
                    kill.insert_str(0, &s);
                    return;
                }
                self.push_kill_ring(s);
            }
            /// Transposes two regions of the buffer, `src` and `dest`.
            /// The cursor is placed at the end of the new location of `src`.
            ///
            /// # Panics
            ///
            /// If `src` and `dest` overlap, are out of bounds,
            /// or are not aligned to `char` boundaries.
            pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                    -> io::Result<()> {
                self.write.transpose_range(src, dest)
            }
            /// Insert text from the front of the kill ring at the current cursor position.
            /// The cursor is placed at the end of the new text.
            pub fn yank(&mut self) -> io::Result<()> {
                if let Some(kill) = self.read.kill_ring.front().cloned() {
                    let start = self.write.cursor;
                    self.read.last_yank = Some((start, start + kill.len()));

                    self.insert_str(&kill)?;
                }

                Ok(())
            }
            /// Rotates the kill ring and replaces yanked text with the new front.
            ///
            /// If the previous operation was not `yank`, this has no effect.
            pub fn yank_pop(&mut self) -> io::Result<()> {
                if let Some((start, end)) = self.read.last_yank {
                    self.rotate_kill_ring();

                    if let Some(kill) = self.read.kill_ring.front().cloned() {
                        self.read.last_yank = Some((start, start + kill.len()));

                        self.write.move_to(start)?;
                        self.replace_str_forward(start..end, &kill)?;
                    }
                }

                Ok(())
            }
            /// Overwrite `n` characters; assumes `n >= 1`
            fn overwrite(&mut self, n: usize, ch: char) -> io::Result<()> {
                let start = self.write.cursor;
                let end = forward_char(n, &self.write.buffer, start);

                {
                    let over = &self.write.buffer[start..end];
                    let n_chars = over.chars().count();

                    if n > n_chars {
                        self.read.overwritten_append += n - n_chars;
                    }

                    if !over.is_empty() {
                        self.read.overwritten_chars.push_str(&over);
                    }
                }

                let s = repeat_char(ch, n);
                self.replace_str_forward(start..end, &s)
            }

            fn overwrite_back(&mut self, mut n: usize) -> io::Result<()> {
                if self.read.overwritten_append != 0 {
                    let n_del = n.min(self.read.overwritten_append);

                    let pos = backward_char(n_del, &self.write.buffer, self.write.cursor);
                    let r = pos..self.write.cursor;
                    self.delete_range(r)?;

                    self.read.overwritten_append -= n_del;
                    n -= n_del;
                }

                if n != 0 && !self.read.overwritten_chars.is_empty() {
                    let n_repl = n.min(self.read.overwritten_chars.chars().count());

                    let pos = backward_char(n_repl, &self.write.buffer, self.write.cursor);

                    let over_pos = backward_char(n_repl,
                        &self.read.overwritten_chars, self.read.overwritten_chars.len());

                    let over = self.read.overwritten_chars.drain(over_pos..).collect::<String>();

                    let r = pos..self.write.cursor;
                    self.replace_str_backward(r, &over)?;

                    n -= n_repl;
                }

                if n != 0 {
                    self.write.backward_char(n)?;
                }

                Ok(())
            }
            /// Insert a given character at the current cursor position `n` times.
            ///
            /// The cursor position remains the same.
            pub fn insert(&mut self, n: usize, ch: char) -> io::Result<()> {
                if n != 0 {
                    let s = repeat_char(ch, n);
                    self.insert_str(&s)?;
                }

                Ok(())
            }
            /// Insert a string at the current cursor position.
            ///
            /// The cursor is placed at the end of the new string.
            pub fn insert_str(&mut self, s: &str) -> io::Result<()> {
                self.write.insert_str(s)
            }
            /// Replaces a range in the buffer and redraws.
            ///
            /// The cursor is placed at the start of the range.
            pub fn replace_str_backward<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                self.replace_str_impl(range, s)?;
                let len = self.write.buffer.len();
                self.write.move_from(len)
            }
            /// Replaces a range in the buffer and redraws.
            ///
            /// The cursor is placed at the end of the new string.
            pub fn replace_str_forward<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                self.replace_str_impl(range, s)?;
                self.write.cursor += s.len();
                let len = self.write.buffer.len();
                self.write.move_from(len)
            }
            /// Replaces a range in the buffer and redraws.
            ///
            /// The cursor position is set to start of range, on-screen cursor remains
            /// at end of buffer.
            fn replace_str_impl<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                self.write.move_to(start)?;

                let _ = self.write.buffer.drain(start..end);
                let cursor = self.write.cursor;
                self.write.buffer.insert_str(cursor, s);

                self.write.draw_buffer(cursor)?;
                self.write.clear_to_screen_end()
            }
        }
    }

    pub mod reader
    {
        //! Provides access to terminal read operations
        use ::
        {
            *,
        };
        

        use std::borrow::Cow;
        use std::collections::{HashMap, VecDeque};
        use std::io;
        use std::mem::replace;
        use std::ops::{Deref, DerefMut};
        use std::path::{Path, PathBuf};
        use std::slice;
        use std::sync::{Arc, MutexGuard};
        use std::time::{Duration, Instant};

        use mortal::SequenceMap;

        use crate::command::{Category, Command};
        use crate::complete::{Completer, Completion, DummyCompleter};
        use crate::function::Function;
        use crate::inputrc::{parse_file, Directive};
        use crate::interface::Interface;
        use crate::prompter::Prompter;
        use crate::sys::path::{env_init_file, system_init_file, user_init_file};
        use crate::terminal::{
            RawRead, Signal, SignalSet, Size,
            Terminal, TerminalReader,
        };
        use crate::util::{first_char, match_name};
        use crate::variables::{Variable, Variables, VariableIter};

        /// Default set of string characters
        pub const STRING_CHARS: &str = "\"'";

        /// Default set of word break characters
        pub const WORD_BREAK_CHARS: &str = " \t\n\"\\'`@$><=;|&{(";

        /// Indicates the start of a series of invisible characters in the prompt
        pub const START_INVISIBLE: char = '\x01';

        /// Indicates the end of a series of invisible characters in the prompt
        pub const END_INVISIBLE: char = '\x02';

        /// Maximum size of kill ring
        const MAX_KILLS: usize = 10;

        /// Provides access to data related to reading and processing user input.
        ///
        /// Holds a lock on terminal read operations.
        /// See [`Interface`] for more information about concurrent operations.
        ///
        /// An instance of this type can be constructed using the
        /// [`Interface::lock_reader`] method.
        ///
        /// [`Interface`]: ../interface/struct.Interface.html
        /// [`Interface::lock_reader`]: ../interface/struct.Interface.html#method.lock_reader
        pub struct Reader<'a, Term: 'a + Terminal> {
            iface: &'a Interface<Term>,
            lock: ReadLock<'a, Term>,
        }

        pub struct Read<Term: Terminal> {
            /// Application name
            pub application: Cow<'static, str>,

            /// Pending input
            pub input_buffer: Vec<u8>,
            /// Pending macro sequence
            pub macro_buffer: String,

            pub bindings: SequenceMap<Cow<'static, str>, Command>,
            pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,

            /// Current input sequence
            pub sequence: String,
            /// Whether newline has been received
            pub input_accepted: bool,

            /// Whether overwrite mode is currently active
            pub overwrite_mode: bool,
            /// Characters appended while in overwrite mode
            pub overwritten_append: usize,
            /// Characters overwritten in overwrite mode
            pub overwritten_chars: String,

            /// Configured completer
            pub completer: Arc<dyn Completer<Term>>,
            /// Character appended to completions
            pub completion_append_character: Option<char>,
            /// Current set of possible completions
            pub completions: Option<Vec<Completion>>,
            /// Current "menu-complete" entry being viewed:
            pub completion_index: usize,
            /// Start of the completed word
            pub completion_start: usize,
            /// Start of the inserted prefix of a completed word
            pub completion_prefix: usize,

            pub string_chars: Cow<'static, str>,
            pub word_break: Cow<'static, str>,

            pub last_cmd: Category,
            pub last_yank: Option<(usize, usize)>,
            pub kill_ring: VecDeque<String>,

            pub catch_signals: bool,
            pub ignore_signals: SignalSet,
            pub report_signals: SignalSet,
            pub last_resize: Option<Size>,
            pub last_signal: Option<Signal>,

            variables: Variables,

            pub state: InputState,
            pub max_wait_duration: Option<Duration>,
        }

        pub struct ReadLock<'a, Term: 'a + Terminal> {
            term: Box<dyn TerminalReader<Term> + 'a>,
            data: MutexGuard<'a, Read<Term>>,
        }
        /// Returned from [`read_line`] to indicate user input
        ///
        /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
        #[derive(Debug)]
        pub enum ReadResult {
            /// User issued end-of-file
            Eof,
            /// User input received
            Input(String),
            /// Reported signal was received
            Signal(Signal),
        }

        #[derive(Copy, Clone, Debug)]
        pub enum InputState {
            Inactive,
            NewSequence,
            ContinueSequence{
                expiry: Option<Instant>,
            },
            Number,
            CharSearch{
                n: usize,
                backward: bool,
            },
            TextSearch,
            CompleteIntro,
            CompleteMore(usize),
            QuotedInsert(usize),
        }

        impl<'a, Term: 'a + Terminal> Reader<'a, Term> {
            pub fn new(iface: &'a Interface<Term>, lock: ReadLock<'a, Term>)
                    -> Reader<'a, Term> {
                Reader{iface, lock}
            }
            /// Interactively reads a line from the terminal device.
            ///
            /// User input is collected until one of the following conditions is met:
            ///
            /// * If the user issues an end-of-file, `ReadResult::Eof` is returned.
            /// * When the user inputs a newline (`'\n'`), the resulting input
            ///   (not containing a trailing newline character) is returned as
            ///   `ReadResult::Input(_)`.
            /// * When a reported signal (see [`set_report_signal`]) is received,
            ///   it is returned as `ReadResult::Signal(_)`. The `read_line` operation may
            ///   then be either resumed with another call to `read_line` or ended by
            ///   calling [`cancel_read_line`].
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`set_report_signal`]: #method.set_report_signal
            pub fn read_line(&mut self) -> io::Result<ReadResult> {
                loop {
                    if let Some(res) = self.read_line_step(None)? {
                        return Ok(res);
                    }
                }
            }
            /// Performs one step of the interactive `read_line` loop.
            ///
            /// This method can be used to drive the `read_line` process asynchronously.
            /// It will wait for input only up to the specified duration, then process
            /// any available input from the terminal.
            ///
            /// If the user completes the input process, `Ok(Some(result))` is returned.
            /// Otherwise, `Ok(None)` is returned to indicate that the interactive loop
            /// may continue.
            ///
            /// The interactive prompt may be cancelled prematurely using the
            /// [`cancel_read_line`] method.
            ///
            /// See [`read_line`] for details on the return value.
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`read_line`]: #method.read_line
            pub fn read_line_step(&mut self, timeout: Option<Duration>)
                    -> io::Result<Option<ReadResult>> {
                self.initialize_read_line()?;

                let state = self.prepare_term()?;
                let res = self.read_line_step_impl(timeout);
                self.lock.term.restore(state)?;

                res
            }
            /// Cancels an in-progress `read_line` operation.
            ///
            /// This method will reset internal data structures to their original state
            /// and move the terminal cursor to a new, empty line.
            ///
            /// This method is called to prematurely end the interactive loop when
            /// using the [`read_line_step`] method.
            ///
            /// It is not necessary to call this method if using the [`read_line`] method.
            ///
            /// [`read_line`]: #method.read_line
            /// [`read_line_step`]: #method.read_line_step
            pub fn cancel_read_line(&mut self) -> io::Result<()> {
                self.end_read_line()
            }

            fn initialize_read_line(&mut self) -> io::Result<()> {
                if !self.lock.is_active() {
                    self.prompter().start_read_line()?;
                }
                Ok(())
            }

            fn read_line_step_impl(&mut self, timeout: Option<Duration>)
                    -> io::Result<Option<ReadResult>> {
                let do_read = if self.lock.is_input_available() {
                    // This branch will be taken only if a macro has buffered some input.
                    // We check for input with a zero duration to see if the user has
                    // entered Ctrl-C, e.g. to interrupt an infinitely recursive macro.
                    self.lock.term.wait_for_input(Some(Duration::from_secs(0)))?
                } else {
                    let timeout = limit_duration(timeout, self.lock.max_wait_duration);
                    self.lock.term.wait_for_input(timeout)?
                };

                if do_read {
                    self.lock.read_input()?;
                }

                if let Some(size) = self.lock.take_resize() {
                    self.handle_resize(size)?;
                }

                if let Some(sig) = self.lock.take_signal() {
                    if self.lock.report_signals.contains(sig) {
                        return Ok(Some(ReadResult::Signal(sig)));
                    }
                    if !self.lock.ignore_signals.contains(sig) {
                        self.handle_signal(sig)?;
                    }
                }

                // Acquire the write lock and process all available input
                {
                    let mut prompter = self.prompter();

                    prompter.check_expire_timeout()?;

                    // If the macro buffer grows in size while input is being processed,
                    // we end this step and let the caller try again. This is to allow
                    // reading Ctrl-C to interrupt (perhaps infinite) macro execution.
                    let mut macro_len = prompter.read.data.macro_buffer.len();

                    while prompter.read.is_input_available() {
                        if let Some(ch) = prompter.read.read_char()? {
                            if let Some(r) = prompter.handle_input(ch)? {
                                prompter.end_read_line()?;
                                return Ok(Some(r));
                            }
                        }

                        let new_macro_len = prompter.read.data.macro_buffer.len();

                        if new_macro_len != 0 && new_macro_len >= macro_len {
                            break;
                        }

                        macro_len = new_macro_len;
                    }
                }

                Ok(None)
            }

            fn end_read_line(&mut self) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().end_read_line()?;
                }
                Ok(())
            }

            fn prepare_term(&mut self) -> io::Result<Term::PrepareState> {
                if self.read_next_raw() {
                    self.lock.term.prepare(true, SignalSet::new())
                } else {
                    let mut signals = self.lock.report_signals.union(self.lock.ignore_signals);

                    if self.lock.catch_signals {
                        // Ctrl-C is always intercepted (unless we're catching no signals).
                        // By default, lineread handles it by clearing the current input state.
                        signals.insert(Signal::Interrupt);
                    }

                    let block_signals = !self.lock.catch_signals;

                    self.lock.term.prepare(block_signals, signals)
                }
            }

            fn read_next_raw(&self) -> bool {
                match self.lock.state {
                    InputState::QuotedInsert(_) => true,
                    _ => false
                }
            }
            /// Sets the input buffer to the given string.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// # Notes
            ///
            /// To prevent invalidating the cursor, this method sets the cursor
            /// position to the end of the new buffer.
            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_buffer(buf)
                } else {
                    self.iface.lock_write_data().set_buffer(buf);
                    Ok(())
                }
            }
            /// Sets the cursor position in the input buffer.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// # Panics
            ///
            /// If the given position is out of bounds or not on a `char` boundary.
            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_cursor(pos)
                } else {
                    self.iface.lock_write_data().set_cursor(pos);
                    Ok(())
                }
            }
            /// Sets the prompt that will be displayed when `read_line` is called.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// # Notes
            ///
            /// If `prompt` contains any terminal escape sequences (e.g. color codes),
            /// such escape sequences should be immediately preceded by the character
            /// `'\x01'` and immediately followed by the character `'\x02'`.
            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
                self.prompter().set_prompt(prompt)
            }
            /// Adds a line to history.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn add_history(&self, line: String) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history(line);
                }
            }
            /// Adds a line to history, unless it is identical to the most recent entry.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn add_history_unique(&self, line: String) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history_unique(line);
                }
            }
            /// Removes all history entries.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn clear_history(&self) {
                if !self.lock.is_active() {
                    self.iface.lock_write().clear_history();
                }
            }
            /// Removes the history entry at the given index.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If the index is out of bounds, this method has no effect.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn remove_history(&self, idx: usize) {
                if !self.lock.is_active() {
                    self.iface.lock_write().remove_history(idx);
                }
            }
            /// Sets the maximum number of history entries.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If `n` is less than the current number of history entries,
            /// the oldest entries are truncated to meet the given requirement.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn set_history_size(&self, n: usize) {
                if !self.lock.is_active() {
                    self.iface.lock_write().set_history_size(n);
                }
            }
            /// Truncates history to the only the most recent `n` entries.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn truncate_history(&self, n: usize) {
                if !self.lock.is_active() {
                    self.iface.lock_write().truncate_history(n);
                }
            }
            /// Returns the application name
            pub fn application(&self) -> &str {
                &self.lock.application
            }
            /// Sets the application name
            pub fn set_application<T>(&mut self, application: T)
                    where T: Into<Cow<'static, str>> {
                self.lock.application = application.into();
            }
            /// Returns a reference to the current completer instance.
            pub fn completer(&self) -> &Arc<dyn Completer<Term>> {
                &self.lock.completer
            }
            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer(&mut self, completer: Arc<dyn Completer<Term>>)
                    -> Arc<dyn Completer<Term>> {
                replace(&mut self.lock.completer, completer)
            }
            /// Returns the value of the named variable or `None`
            /// if no such variable exists.
            pub fn get_variable(&self, name: &str) -> Option<Variable> {
                self.lock.get_variable(name)
            }
            /// Sets the value of the named variable and returns the previous
            /// value.
            ///
            /// If `name` does not refer to a variable or the `value` is not
            /// a valid value for the variable, `None` is returned.
            pub fn set_variable(&mut self, name: &str, value: &str) -> Option<Variable> {
                self.lock.set_variable(name, value)
            }
            /// Returns an iterator over stored variables.
            pub fn variables(&self) -> VariableIter {
                self.lock.variables.iter()
            }
            /// Returns whether to "blink" matching opening parenthesis character
            /// when a closing parenthesis character is entered.
            ///
            /// The default value is `false`.
            pub fn blink_matching_paren(&self) -> bool {
                self.lock.blink_matching_paren
            }
            /// Sets the `blink-matching-paren` variable.
            pub fn set_blink_matching_paren(&mut self, set: bool) {
                self.lock.blink_matching_paren = set;
            }
            /// Returns whether `lineread` will catch certain signals.
            pub fn catch_signals(&self) -> bool {
                self.lock.catch_signals
            }
            /// Sets whether `lineread` will catch certain signals.
            ///
            /// This setting is `true` by default. It can be disabled to allow the
            /// host program to handle signals itself.
            pub fn set_catch_signals(&mut self, enabled: bool) {
                self.lock.catch_signals = enabled;
            }
            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal(&self, signal: Signal) -> bool {
                self.lock.ignore_signals.contains(signal)
            }
            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal(&mut self, signal: Signal, set: bool) {
                if set {
                    self.lock.ignore_signals.insert(signal);
                    self.lock.report_signals.remove(signal);
                } else {
                    self.lock.ignore_signals.remove(signal);
                }
            }
            /// Returns whether the given `Signal` is to be reported.
            pub fn report_signal(&self, signal: Signal) -> bool {
                self.lock.report_signals.contains(signal)
            }
            /// Sets whether to report the given `Signal`.
            ///
            /// When a reported signal is received via the terminal, it will be returned
            /// from `Interface::read_line` as `Ok(Signal(signal))`.
            pub fn set_report_signal(&mut self, signal: Signal, set: bool) {
                if set {
                    self.lock.report_signals.insert(signal);
                    self.lock.ignore_signals.remove(signal);
                } else {
                    self.lock.report_signals.remove(signal);
                }
            }
            /// Returns whether Tab completion is disabled.
            ///
            /// The default value is `false`.
            pub fn disable_completion(&self) -> bool {
                self.lock.disable_completion
            }
            /// Sets the `disable-completion` variable.
            pub fn set_disable_completion(&mut self, disable: bool) {
                self.lock.disable_completion = disable;
            }
            /// When certain control characters are pressed, a character sequence
            /// equivalent to this character will be echoed.
            ///
            /// The default value is `true`.
            pub fn echo_control_characters(&self) -> bool {
                self.lock.echo_control_characters
            }
            /// Sets the `echo-control-characters` variable.
            pub fn set_echo_control_characters(&mut self, echo: bool) {
                self.lock.echo_control_characters = echo;
            }
            /// Returns the character, if any, that is appended to a successful completion.
            pub fn completion_append_character(&self) -> Option<char> {
                self.lock.completion_append_character
            }
            /// Sets the character, if any, that is appended to a successful completion.
            pub fn set_completion_append_character(&mut self, ch: Option<char>) {
                self.lock.completion_append_character = ch;
            }
            /// Returns the width of completion listing display.
            ///
            /// If this value is greater than the terminal width, terminal width is used
            /// instead.
            ///
            /// The default value is equal to `usize::max_value()`.
            pub fn completion_display_width(&self) -> usize {
                self.lock.completion_display_width
            }
            /// Sets the `completion-display-width` variable.
            pub fn set_completion_display_width(&mut self, n: usize) {
                self.lock.completion_display_width = n;
            }
            /// Returns the minimum number of completion items that require user
            /// confirmation before listing.
            ///
            /// The default value is `100`.
            pub fn completion_query_items(&self) -> usize {
                self.lock.completion_query_items
            }
            /// Sets the `completion-query-items` variable.
            pub fn set_completion_query_items(&mut self, n: usize) {
                self.lock.completion_query_items = n;
            }
            /// Returns the timeout to wait for further user input when an ambiguous
            /// sequence has been entered. If the value is `None`, wait is indefinite.
            ///
            /// The default value 500 milliseconds.
            pub fn keyseq_timeout(&self) -> Option<Duration> {
                self.lock.keyseq_timeout
            }
            /// Sets the `keyseq-timeout` variable.
            pub fn set_keyseq_timeout(&mut self, timeout: Option<Duration>) {
                self.lock.keyseq_timeout = timeout;
            }
            /// Returns whether to list possible completions one page at a time.
            ///
            /// The default value is `true`.
            pub fn page_completions(&self) -> bool {
                self.lock.page_completions
            }
            /// Sets the `page-completions` variable.
            pub fn set_page_completions(&mut self, set: bool) {
                self.lock.page_completions = set;
            }
            /// Returns whether to list completions horizontally, rather than down
            /// the screen.
            ///
            /// The default value is `false`.
            pub fn print_completions_horizontally(&self) -> bool {
                self.lock.print_completions_horizontally
            }
            /// Sets the `print-completions-horizontally` variable.
            pub fn set_print_completions_horizontally(&mut self, set: bool) {
                self.lock.print_completions_horizontally = set;
            }
            /// Returns the set of characters that delimit strings.
            pub fn string_chars(&self) -> &str {
                &self.lock.string_chars
            }
            /// Sets the set of characters that delimit strings.
            pub fn set_string_chars<T>(&mut self, chars: T)
                    where T: Into<Cow<'static, str>> {
                self.lock.string_chars = chars.into();
            }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars(&self) -> &str {
                &self.lock.word_break
            }
            /// Sets the set of characters that indicate a word break.
            pub fn set_word_break_chars<T>(&mut self, chars: T)
                    where T: Into<Cow<'static, str>> {
                self.lock.word_break = chars.into();
            }
            /// Returns an iterator over bound sequences
            pub fn bindings(&self) -> BindingIter {
                self.lock.bindings()
            }
            /// Binds a sequence to a command.
            ///
            /// Returns the previously bound command.
            pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.lock.bind_sequence(seq, cmd)
            }
            /// Binds a sequence to a command, if and only if the given sequence
            /// is not already bound to a command.
            ///
            /// Returns `true` if a new binding was created.
            pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                self.lock.bind_sequence_if_unbound(seq, cmd)
            }
            /// Removes a binding for the given sequence.
            ///
            /// Returns the previously bound command.
            pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
                self.lock.unbind_sequence(seq)
            }
            /// Defines a named function to which sequences may be bound.
            ///
            /// The name should consist of lowercase ASCII letters and numbers,
            /// containing no spaces, with words separated by hyphens. However,
            /// this is not a requirement.
            ///
            /// Returns the function previously defined with the same name.
            pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.lock.define_function(name, cmd)
            }
            /// Removes a function defined with the given name.
            ///
            /// Returns the defined function.
            pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.lock.remove_function(name)
            }

            pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
                self.lock.data.evaluate_directives(term, dirs)
            }

            pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
                self.lock.data.evaluate_directive(term, dir)
            }

            fn prompter<'b>(&'b mut self) -> Prompter<'b, 'a, Term> {
                Prompter::new(
                    &mut self.lock,
                    self.iface.lock_write())
            }

            fn handle_resize(&mut self, size: Size) -> io::Result<()> {
                self.prompter().handle_resize(size)
            }

            fn handle_signal(&mut self, sig: Signal) -> io::Result<()> {
                self.prompter().handle_signal(sig)
            }
        }

        impl<'a, Term: 'a + Terminal> ReadLock<'a, Term> {
            pub fn new(term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>>)
                    -> ReadLock<'a, Term> {
                ReadLock{term, data}
            }
            /// Reads the next character of input.
            ///
            /// Performs a non-blocking read from the terminal, if necessary.
            ///
            /// If non-input data was received (e.g. a signal) or insufficient input
            /// is available, `Ok(None)` is returned.
            pub fn read_char(&mut self) -> io::Result<Option<char>> {
                if let Some(ch) = self.macro_pop() {
                    Ok(Some(ch))
                } else if let Some(ch) = self.decode_input()? {
                    Ok(Some(ch))
                } else {
                    Ok(None)
                }
            }

            fn read_input(&mut self) -> io::Result<()> {
                match self.term.read(&mut self.data.input_buffer)? {
                    RawRead::Bytes(_) => (),
                    RawRead::Resize(new_size) => {
                        self.last_resize = Some(new_size);
                    }
                    RawRead::Signal(sig) => {
                        self.last_signal = Some(sig);
                    }
                }

                Ok(())
            }

            fn is_input_available(&self) -> bool {
                !self.data.macro_buffer.is_empty() || match self.peek_input() {
                    Ok(Some(_)) | Err(_) => true,
                    Ok(None) => false
                }
            }

            fn macro_pop(&mut self) -> Option<char> {
                if self.data.macro_buffer.is_empty() {
                    None
                } else {
                    Some(self.data.macro_buffer.remove(0))
                }
            }

            fn decode_input(&mut self) -> io::Result<Option<char>> {
                let res = self.peek_input();

                if let Ok(Some(ch)) = res {
                    self.data.input_buffer.drain(..ch.len_utf8());
                }

                res
            }

            fn peek_input(&self) -> io::Result<Option<char>> {
                if self.data.input_buffer.is_empty() {
                    Ok(None)
                } else {
                    first_char(&self.data.input_buffer)
                }
            }

            pub fn reset_data(&mut self) {
                self.data.reset_data();
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for ReadLock<'a, Term> {
            type Target = Read<Term>;

            fn deref(&self) -> &Read<Term> {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for ReadLock<'a, Term> {
            fn deref_mut(&mut self) -> &mut Read<Term> {
                &mut self.data
            }
        }

        impl<Term: Terminal> Deref for Read<Term> {
            type Target = Variables;

            fn deref(&self) -> &Variables {
                &self.variables
            }
        }

        impl<Term: Terminal> DerefMut for Read<Term> {
            fn deref_mut(&mut self) -> &mut Variables {
                &mut self.variables
            }
        }

        impl<Term: Terminal> Read<Term> {
            pub fn new(term: &Term, application: Cow<'static, str>) -> Read<Term> {
                let mut r = Read{
                    application,

                    bindings: default_bindings(),
                    functions: HashMap::new(),

                    input_buffer: Vec::new(),
                    macro_buffer: String::new(),

                    sequence: String::new(),
                    input_accepted: false,

                    overwrite_mode: false,
                    overwritten_append: 0,
                    overwritten_chars: String::new(),

                    completer: Arc::new(DummyCompleter),
                    completion_append_character: Some(' '),
                    completions: None,
                    completion_index: 0,
                    completion_start: 0,
                    completion_prefix: 0,

                    string_chars: STRING_CHARS.into(),
                    word_break: WORD_BREAK_CHARS.into(),

                    last_cmd: Category::Other,
                    last_yank: None,
                    kill_ring: VecDeque::with_capacity(MAX_KILLS),

                    catch_signals: true,
                    ignore_signals: SignalSet::new(),
                    report_signals: SignalSet::new(),
                    last_resize: None,
                    last_signal: None,

                    variables: Variables::default(),

                    state: InputState::Inactive,
                    max_wait_duration: None,
                };

                r.read_init(term);
                r
            }

            pub fn bindings(&self) -> BindingIter {
                BindingIter(self.bindings.sequences().iter())
            }

            pub fn variables(&self) -> VariableIter {
                self.variables.iter()
            }

            fn take_resize(&mut self) -> Option<Size> {
                self.last_resize.take()
            }

            fn take_signal(&mut self) -> Option<Signal> {
                self.last_signal.take()
            }

            pub fn queue_input(&mut self, seq: &str) {
                self.macro_buffer.insert_str(0, seq);
            }

            pub fn is_active(&self) -> bool {
                match self.state {
                    InputState::Inactive => false,
                    _ => true
                }
            }

            pub fn reset_data(&mut self) {
                self.state = InputState::NewSequence;
                self.input_accepted = false;
                self.overwrite_mode = false;
                self.overwritten_append = 0;
                self.overwritten_chars.clear();
                self.sequence.clear();

                self.completions = None;

                self.last_cmd = Category::Other;
                self.last_yank = None;

                self.last_resize = None;
                self.last_signal = None;
            }

            pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.bindings.insert(seq.into(), cmd)
            }

            pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                use mortal::sequence::Entry;

                match self.bindings.entry(seq.into()) {
                    Entry::Occupied(_) => false,
                    Entry::Vacant(ent) => {
                        ent.insert(cmd);
                        true
                    }
                }
            }

            pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
                self.bindings.remove(seq)
                    .map(|(_, cmd)| cmd)
            }

            pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.functions.insert(name.into(), cmd)
            }

            pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.functions.remove(name)
            }

            fn read_init(&mut self, term: &Term) {
                if let Some(path) = env_init_file() {
                    // If `INPUTRC` is present, even if invalid, parse nothing else.
                    // Thus, an empty `INPUTRC` will inhibit loading configuration.
                    self.read_init_file_if_exists(term, Some(path));
                } else {
                    if !self.read_init_file_if_exists(term, user_init_file()) {
                        self.read_init_file_if_exists(term, system_init_file());
                    }
                }
            }

            fn read_init_file_if_exists(&mut self, term: &Term, path: Option<PathBuf>) -> bool {
                match path {
                    Some(ref path) if path.exists() => {
                        self.read_init_file(term, path);
                        true
                    }
                    _ => false
                }
            }

            fn read_init_file(&mut self, term: &Term, path: &Path) {
                if let Some(dirs) = parse_file(path) {
                    self.evaluate_directives(term, dirs);
                }
            }
            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
                for dir in dirs {
                    self.evaluate_directive(term, dir);
                }
            }
            /// Evaluates a single configuration directive.
            pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
                match dir {
                    Directive::Bind(seq, cmd) => {
                        self.bind_sequence(seq, cmd);
                    }
                    Directive::Conditional{name, value, then_group, else_group} => {
                        let name = name.as_ref().map(|s| &s[..]);

                        if self.eval_condition(term, name, &value) {
                            self.evaluate_directives(term, then_group);
                        } else {
                            self.evaluate_directives(term, else_group);
                        }
                    }
                    Directive::SetVariable(name, value) => {
                        self.set_variable(&name, &value);
                    }
                }
            }

            fn eval_condition(&self, term: &Term, name: Option<&str>, value: &str) -> bool {
                match name {
                    None => self.application == value,
                    Some("lib") => value == "lineread",
                    Some("mode") => value == "emacs",
                    Some("term") => self.term_matches(term, value),
                    _ => false
                }
            }

            fn term_matches(&self, term: &Term, value: &str) -> bool {
                match_name(term.name(), value)
            }
        }
        /// Iterator over `Reader` bindings
        pub struct BindingIter<'a>(slice::Iter<'a, (Cow<'static, str>, Command)>);

        impl<'a> ExactSizeIterator for BindingIter<'a> {}

        impl<'a> Iterator for BindingIter<'a> {
            type Item = (&'a str, &'a Command);

            #[inline]
            fn next(&mut self) -> Option<Self::Item> {
                self.0.next().map(|&(ref s, ref cmd)| (&s[..], cmd))
            }

            #[inline]
            fn nth(&mut self, n: usize) -> Option<Self::Item> {
                self.0.nth(n).map(|&(ref s, ref cmd)| (&s[..], cmd))
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.0.size_hint()
            }
        }

        impl<'a> DoubleEndedIterator for BindingIter<'a> {
            #[inline]
            fn next_back(&mut self) -> Option<Self::Item> {
                self.0.next_back().map(|&(ref s, ref cmd)| (&s[..], cmd))
            }
        }

        fn default_bindings() -> SequenceMap<Cow<'static, str>, Command> {
            use crate::command::Command::*;

            SequenceMap::from(vec![
                // Carriage return and line feed
                ("\r".into(), AcceptLine),
                ("\n".into(), AcceptLine),

                // Possible sequences for arrow keys, Home, End
                ("\x1b[A".into(), PreviousHistory),
                ("\x1b[B".into(), NextHistory),
                ("\x1b[C".into(), ForwardChar),
                ("\x1b[D".into(), BackwardChar),
                ("\x1b[H".into(), BeginningOfLine),
                ("\x1b[F".into(), EndOfLine),

                // More possible sequences for arrow keys, Home, End
                ("\x1bOA".into(), PreviousHistory),
                ("\x1bOB".into(), NextHistory),
                ("\x1bOC".into(), ForwardChar),
                ("\x1bOD".into(), BackwardChar),
                ("\x1bOH".into(), BeginningOfLine),
                ("\x1bOF".into(), EndOfLine),

                // Possible sequences for Insert, Delete
                ("\x1b[2~".into(), OverwriteMode),
                ("\x1b[3~".into(), DeleteChar),

                // Basic commands
                ("\x01"    .into(), BeginningOfLine),           // Ctrl-A
                ("\x02"    .into(), BackwardChar),              // Ctrl-B
                ("\x04"    .into(), DeleteChar),                // Ctrl-D
                ("\x05"    .into(), EndOfLine),                 // Ctrl-E
                ("\x06"    .into(), ForwardChar),               // Ctrl-F
                ("\x07"    .into(), Abort),                     // Ctrl-G
                ("\x08"    .into(), BackwardDeleteChar),        // Ctrl-H
                ("\x0b"    .into(), KillLine),                  // Ctrl-K
                ("\x0c"    .into(), ClearScreen),               // Ctrl-L
                ("\x0e"    .into(), NextHistory),               // Ctrl-N
                ("\x10"    .into(), PreviousHistory),           // Ctrl-P
                ("\x12"    .into(), ReverseSearchHistory),      // Ctrl-R
                ("\x14"    .into(), TransposeChars),            // Ctrl-T
                ("\x15"    .into(), BackwardKillLine),          // Ctrl-U
                ("\x16"    .into(), QuotedInsert),              // Ctrl-V
                ("\x17"    .into(), UnixWordRubout),            // Ctrl-W
                ("\x19"    .into(), Yank),                      // Ctrl-Y
                ("\x1d"    .into(), CharacterSearch),           // Ctrl-]
                ("\x7f"    .into(), BackwardDeleteChar),        // Rubout
                ("\x1b\x08".into(), BackwardKillWord),          // Escape, Ctrl-H
                ("\x1b\x1d".into(), CharacterSearchBackward),   // Escape, Ctrl-]
                ("\x1b\x7f".into(), BackwardKillWord),          // Escape, Rubout
                ("\x1bb"   .into(), BackwardWord),              // Escape, b
                ("\x1bd"   .into(), KillWord),                  // Escape, d
                ("\x1bf"   .into(), ForwardWord),               // Escape, f
                ("\x1bt"   .into(), TransposeWords),            // Escape, t
                ("\x1by"   .into(), YankPop),                   // Escape, y
                ("\x1b#"   .into(), InsertComment),             // Escape, #
                ("\x1b<"   .into(), BeginningOfHistory),        // Escape, <
                ("\x1b>"   .into(), EndOfHistory),              // Escape, >

                // Completion commands
                ("\t"   .into(), Complete),             // Tab
                ("\x1b?".into(), PossibleCompletions),  // Escape, ?
                ("\x1b*".into(), InsertCompletions),    // Escape, *

                // Digit commands
                ("\x1b-".into(), DigitArgument),    // Escape, -
                ("\x1b0".into(), DigitArgument),    // Escape, 0
                ("\x1b1".into(), DigitArgument),    // Escape, 1
                ("\x1b2".into(), DigitArgument),    // Escape, 2
                ("\x1b3".into(), DigitArgument),    // Escape, 3
                ("\x1b4".into(), DigitArgument),    // Escape, 4
                ("\x1b5".into(), DigitArgument),    // Escape, 5
                ("\x1b6".into(), DigitArgument),    // Escape, 6
                ("\x1b7".into(), DigitArgument),    // Escape, 7
                ("\x1b8".into(), DigitArgument),    // Escape, 8
                ("\x1b9".into(), DigitArgument),    // Escape, 9
            ])
        }

        fn limit_duration(dur: Option<Duration>, max: Option<Duration>) -> Option<Duration> {
            match (dur, max) {
                (dur, None) | (None, dur) => dur,
                (Some(dur), Some(max)) => Some(dur.min(max)),
            }
        }
    }

    pub mod table
    {
        //! Provides utilities for formatting strings in a table
        use ::
        {
            *,
        };
        

        use std::cmp::min;

        const COL_SPACE: usize = 2;

        /// Represents a table of strings, formatted into rows and columns
        ///
        /// A `Table` is an `Iterator` yielding `Line` elements, which are in turn
        /// iterators yielding `(usize, &str)` elements, describing the width and content
        /// of each cell in a given row.
        pub struct Table<'a, S: 'a> {
            strings: &'a [S],
            sizes: Option<&'a [usize]>,
            offset: usize,
            per_col: usize,
            rows: usize,
            horizontal: bool,
        }

        impl<'a, S: 'a + AsRef<str>> Table<'a, S> {
            /// Constructs a new table from the given set of strings, using the given column sizes.
            pub fn new(strs: &'a [S], mut sizes: Option<&'a [usize]>,
                    horizontal: bool) -> Table<'a, S> {
                if let Some(sz) = sizes {
                    if sz.is_empty() {
                        sizes = None;
                    }
                }

                let n_strs = strs.len();
                let n_cols = sizes.map_or(1, |sz| sz.len());

                let rows = n_strs / n_cols + (n_strs % n_cols != 0) as usize;

                Table{
                    strings: strs,
                    sizes: sizes,
                    offset: 0,
                    per_col: (strs.len() + (n_cols - 1)) / n_cols,
                    rows: rows,
                    horizontal: horizontal,
                }
            }
            /// Returns whether more lines are present in the table.
            pub fn has_more(&self) -> bool {
                self.offset < self.rows
            }

            fn num_cols(&self) -> usize {
                self.sizes.map_or(1, |sz| sz.len())
            }
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Table<'a, S> {
            type Item = Line<'a, S>;

            fn next(&mut self) -> Option<Line<'a, S>> {
                if self.offset == self.rows {
                    return None;
                }

                let n = self.num_cols();

                let (start, end, stride) = if self.horizontal {
                    let start = self.offset * n;
                    let end = min(self.strings.len(), start + n);
                    (start, end, 1)
                } else {
                    let start = self.offset;
                    let end = min(self.strings.len(), start + self.per_col * n);
                    (start, end, self.per_col)
                };

                self.offset += 1;

                Some(Line{
                    strings: &self.strings[start..end],
                    sizes: self.sizes,
                    stride: stride,
                    offset: 0,
                })
            }
        }
        /// Represents a single line of the table.
        pub struct Line<'a, S: 'a> {
            strings: &'a [S],
            sizes: Option<&'a [usize]>,
            stride: usize,
            offset: usize,
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Line<'a, S> {
            type Item = (usize, &'a str);

            fn next(&mut self) -> Option<(usize, &'a str)> {
                let s = self.strings.get(self.offset * self.stride)?.as_ref();

                let width = self.sizes.and_then(|sz| sz.get(self.offset).cloned())
                    .unwrap_or_else(|| s.chars().count());

                self.offset += 1;

                Some((width, s))
            }
        }
        /// Formats a series of strings into columns, fitting within a given screen width.
        /// Returns the size of each resulting column, including spacing.
        pub fn format_columns<S: AsRef<str>>(strs: &[S], screen_width: usize,
                horizontal: bool) -> Option<Vec<usize>> {
            if strs.is_empty() {
                return None;
            }

            let n_strs = strs.len();

            let (mut min_len, mut max_len) = min_max(strs.iter().map(|s| s.as_ref().chars().count()));

            if min_len == 0 { min_len = 1; }
            if max_len == 0 { max_len = 1; }

            let mut min_cols = min(n_strs, screen_width / max_len);
            let max_cols = min(n_strs, screen_width / min_len);

            if min_cols <= 1 {
                // No point in checking whether text can fit within one column
                min_cols = 2;
            }

            if max_cols <= 1 {
                return None;
            }

            let mut col_sizes = if min_cols == max_cols {
                vec![vec![0; max_cols]]
            } else {
                (min_cols..max_cols + 1)
                    .map(|n| vec![0; n]).collect::<Vec<_>>()
            };

            for (i, s) in strs.iter().enumerate() {
                let len = s.as_ref().chars().count();

                for cols in &mut col_sizes {
                    let n_cols = cols.len();

                    let col = if horizontal {
                        i % n_cols
                    } else {
                        let per_col = (n_strs + (n_cols - 1)) / n_cols;
                        i / per_col
                    };

                    let real_len = if col == n_cols - 1 { len } else { len + COL_SPACE };

                    if real_len > cols[col] {
                        cols[col] = real_len;
                    }
                }
            }

            for cols in col_sizes.into_iter().rev() {
                if cols.iter().fold(0, |a, b| a + b) <= screen_width {
                    return Some(cols);
                }
            }

            None
        }

        fn min_max<I>(iter: I) -> (usize, usize) where I: Iterator<Item=usize> {
            let mut min = usize::max_value();
            let mut max = 0;

            for n in iter {
                if n < min {
                    min = n;
                }
                if n + COL_SPACE > max {
                    max = n + COL_SPACE;
                }
            }

            (min, max)
        }
    }

    pub mod terminal
    {
        //! Provides a low-level terminal interface
        use ::
        {
            *,
        };
        

        use std::io;
        use std::time::Duration;

        use mortal::{self, PrepareConfig, PrepareState, TerminalReadGuard, TerminalWriteGuard};
        use crate::sys;

        pub use mortal::{CursorMode, Signal, SignalSet, Size};

        /// Default `Terminal` interface
        pub struct DefaultTerminal(mortal::Terminal);

        /// Represents the result of a `Terminal` read operation
        pub enum RawRead {
            /// `n` bytes were read from the device
            Bytes(usize),
            /// The terminal window was resized
            Resize(Size),
            /// A signal was received while waiting for input
            Signal(Signal),
        }
        /// Defines a low-level interface to the terminal
        pub trait Terminal: Sized + Send + Sync {
            // TODO: When generic associated types are implemented (and stabilized),
            // boxed trait objects may be replaced by `Reader` and `Writer`.
            /// Returned by `prepare`; passed to `restore` to restore state.
            type PrepareState;
            /*
            /// Holds an exclusive read lock and provides read operations
            type Reader: TerminalReader;
            /// Holds an exclusive write lock and provides write operations
            type Writer: TerminalWriter;
            */

            /// Returns the name of the terminal.
            fn name(&self) -> &str;

            /// Acquires a lock on terminal read operations and returns a value holding
            /// that lock and granting access to such operations.
            ///
            /// The lock must not be released until the returned value is dropped.
            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a>;

            /// Acquires a lock on terminal write operations and returns a value holding
            /// that lock and granting access to such operations.
            ///
            /// The lock must not be released until the returned value is dropped.
            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a>;
        }
        /// Holds a lock on `Terminal` read operations
        pub trait TerminalReader<Term: Terminal> {
            /// Prepares the terminal for line reading and editing operations.
            ///
            /// If `block_signals` is `true`, the terminal will be configured to treat
            /// special characters that would otherwise be interpreted as signals as
            /// their literal value.
            ///
            /// If `block_signals` is `false`, a signal contained in the `report_signals`
            /// set may be returned.
            ///
            /// # Notes
            ///
            /// This method may be called more than once. However, if the state values
            /// are not restored in reverse order in which they were created,
            /// the state of the underlying terminal device becomes undefined.
            fn prepare(&mut self, block_signals: bool, report_signals: SignalSet)
                -> io::Result<Term::PrepareState>;

            /// Like `prepare`, but called when the write lock is already held.
            ///
            /// # Safety
            ///
            /// This method must be called with a `TerminalWriter` instance returned
            /// by the same `Terminal` instance to which this `TerminalReader` belongs.
            unsafe fn prepare_with_lock(&mut self, lock: &mut dyn TerminalWriter<Term>,
                    block_signals: bool, report_signals: SignalSet)
                    -> io::Result<Term::PrepareState>;

            /// Restores the terminal state using the given state data.
            fn restore(&mut self, state: Term::PrepareState) -> io::Result<()>;

            /// Like `restore`, but called when the write lock is already held.
            ///
            /// # Safety
            ///
            /// This method must be called with a `TerminalWriter` instance returned
            /// by the same `Terminal` instance to which this `TerminalReader` belongs.
            unsafe fn restore_with_lock(&mut self, lock: &mut dyn TerminalWriter<Term>,
                    state: Term::PrepareState) -> io::Result<()>;

            /// Reads some input from the terminal and appends it to the given buffer.
            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead>;

            /// Waits `timeout` for user input. If `timeout` is `None`, waits indefinitely.
            ///
            /// Returns `Ok(true)` if input becomes available within the given timeout
            /// or if a signal is received.
            ///
            /// Returns `Ok(false)` if the timeout expires before input becomes available.
            fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool>;
        }
        /// Holds a lock on `Terminal` write operations
        pub trait TerminalWriter<Term: Terminal> {
            /// Returns the size of the terminal window
            fn size(&self) -> io::Result<Size>;

            /// Presents a clear terminal screen, with cursor at first row, first column.
            ///
            /// If the terminal possesses a scrolling window over a buffer, this shall
            /// have the effect of moving the visible window down such that it shows
            /// an empty view of the buffer, preserving some or all of existing buffer
            /// contents, where possible.
            fn clear_screen(&mut self) -> io::Result<()>;

            /// Clears characters on the line occupied by the cursor, beginning with the
            /// cursor and ending at the end of the line. Also clears all characters on
            /// all lines after the cursor.
            fn clear_to_screen_end(&mut self) -> io::Result<()>;

            /// Moves the cursor up `n` cells; `n` may be zero.
            fn move_up(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor down `n` cells; `n` may be zero.
            fn move_down(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor left `n` cells; `n` may be zero.
            fn move_left(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor right `n` cells; `n` may be zero.
            fn move_right(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor to the first column of the current line
            fn move_to_first_column(&mut self) -> io::Result<()>;

            /// Set the current cursor mode
            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>;

            /// Writes output to the terminal.
            ///
            /// For each carriage return `'\r'` written to the terminal, the cursor
            /// should be moved to the first column of the current line.
            ///
            /// For each newline `'\n'` written to the terminal, the cursor should
            /// be moved to the first column of the following line.
            ///
            /// The terminal interface shall not automatically move the cursor to the next
            /// line when `write` causes a character to be written to the final column.
            fn write(&mut self, s: &str) -> io::Result<()>;

            /// Flushes any currently buffered output data.
            ///
            /// `TerminalWriter` instances may not buffer data on all systems.
            ///
            /// Data must be flushed when the `TerminalWriter` instance is dropped.
            fn flush(&mut self) -> io::Result<()>;
        }

        impl DefaultTerminal {
            /// Opens access to the terminal device associated with standard output.
            pub fn new() -> io::Result<DefaultTerminal> {
                mortal::Terminal::new().map(DefaultTerminal)
            }
            /// Opens access to the terminal device associated with standard error.
            pub fn stderr() -> io::Result<DefaultTerminal> {
                mortal::Terminal::stderr().map(DefaultTerminal)
            }

            unsafe fn cast_writer<'a>(writer: &'a mut dyn TerminalWriter<Self>)
                    -> &'a mut TerminalWriteGuard<'a> {
                &mut *(writer as *mut _ as *mut TerminalWriteGuard)
            }
        }

        impl Terminal for DefaultTerminal {
            type PrepareState = PrepareState;

            fn name(&self) -> &str {
                self.0.name()
            }

            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a> {
                Box::new(self.0.lock_read().unwrap())
            }

            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a> {
                Box::new(self.0.lock_write().unwrap())
            }
        }

        impl<'a> TerminalReader<DefaultTerminal> for TerminalReadGuard<'a> {
            fn prepare(&mut self, block_signals: bool, report_signals: SignalSet)
                    -> io::Result<PrepareState> {
                self.prepare(PrepareConfig{
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                })
            }

            unsafe fn prepare_with_lock(&mut self,
                    lock: &mut dyn TerminalWriter<DefaultTerminal>,
                    block_signals: bool, report_signals: SignalSet)
                    -> io::Result<PrepareState> {
                let lock = DefaultTerminal::cast_writer(lock);

                self.prepare_with_lock(lock, PrepareConfig{
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                })
            }

            fn restore(&mut self, state: PrepareState) -> io::Result<()> {
                self.restore(state)
            }

            unsafe fn restore_with_lock(&mut self,
                    lock: &mut dyn TerminalWriter<DefaultTerminal>, state: PrepareState)
                    -> io::Result<()> {
                let lock = DefaultTerminal::cast_writer(lock);
                self.restore_with_lock(lock, state)
            }

            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead> {
                sys::terminal_read(self, buf)
            }

            fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                self.wait_event(timeout)
            }

        }

        impl<'a> TerminalWriter<DefaultTerminal> for TerminalWriteGuard<'a> {
            fn size(&self) -> io::Result<Size> {
                self.size()
            }

            fn clear_screen(&mut self) -> io::Result<()> {
                self.clear_screen()
            }

            fn clear_to_screen_end(&mut self) -> io::Result<()> {
                self.clear_to_screen_end()
            }

            fn move_up(&mut self, n: usize) -> io::Result<()> {
                self.move_up(n)
            }
            fn move_down(&mut self, n: usize) -> io::Result<()> {
                self.move_down(n)
            }
            fn move_left(&mut self, n: usize) -> io::Result<()> {
                self.move_left(n)
            }
            fn move_right(&mut self, n: usize) -> io::Result<()> {
                self.move_right(n)
            }

            fn move_to_first_column(&mut self) -> io::Result<()> {
                self.move_to_first_column()
            }

            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.set_cursor_mode(mode)
            }

            fn write(&mut self, s: &str) -> io::Result<()> {
                self.write_str(s)
            }

            fn flush(&mut self) -> io::Result<()> {
                self.flush()
            }
        }
    }

    pub mod util
    {
        //! Provides miscellaneous utilities
        use ::
        {
            *,
        };
        

        use std::borrow::Cow;
        use std::io;
        use std::ops::{Range, RangeFrom, RangeFull, RangeTo};
        use std::str::{from_utf8, from_utf8_unchecked};

        pub fn filter_visible(s: &str) -> Cow<str> {
            use crate::reader::{START_INVISIBLE, END_INVISIBLE};

            if !s.contains(START_INVISIBLE) {
                return Cow::Borrowed(s);
            }

            let mut virt = String::new();
            let mut ignore = false;

            for ch in s.chars() {
                if ch == START_INVISIBLE {
                    ignore = true;
                } else if ch == END_INVISIBLE {
                    ignore = false;
                } else if !ignore {
                    virt.push(ch);
                }
            }

            Cow::Owned(virt)
        }
        /// Returns the longest common prefix of a set of strings.
        ///
        /// If no common prefix exists, `None` is returned.
        pub fn longest_common_prefix<'a, I, S>(iter: I) -> Option<&'a str> where
                I: IntoIterator<Item=&'a S>,
                S: 'a + ?Sized + AsRef<str>,
                {
            let mut iter = iter.into_iter();

            let mut pfx = iter.next()?.as_ref();

            for s in iter {
                let s = s.as_ref();

                let n = pfx.chars().zip(s.chars())
                    .take_while(|&(a, b)| a == b)
                    .map(|(ch, _)| ch.len_utf8()).sum();

                if n == 0 {
                    return None;
                } else {
                    pfx = &pfx[..n];
                }
            }

            Some(pfx)
        }
        /// Returns a string consisting of a `char`, repeated `n` times.
        pub fn repeat_char(ch: char, n: usize) -> String {
            let mut buf = [0; 4];
            let s = ch.encode_utf8(&mut buf);

            s.repeat(n)
        }
        /// Implemented for built-in range types
        // Waiting for stabilization of `std` trait of the same name
        pub trait RangeArgument<T> {
            /// Returns the start of range, if present.
            fn start(&self) -> Option<&T> { None }
            /// Returns the end of range, if present.
            fn end(&self) -> Option<&T> { None }
        }

        impl<T> RangeArgument<T> for Range<T> {
            fn start(&self) -> Option<&T> { Some(&self.start) }

            fn end(&self) -> Option<&T> { Some(&self.end) }
        }

        impl<T> RangeArgument<T> for RangeFrom<T> {
            fn start(&self) -> Option<&T> { Some(&self.start) }
        }

        impl<T> RangeArgument<T> for RangeTo<T> {
            fn end(&self) -> Option<&T> { Some(&self.end) }
        }

        impl<T> RangeArgument<T> for RangeFull {}

        pub fn backward_char(n: usize, s: &str, cur: usize) -> usize {
            let mut chars = s[..cur].char_indices()
                .filter(|&(_, ch)| !is_combining_mark(ch));
            let mut res = cur;

            for _ in 0..n {
                match chars.next_back() {
                    Some((idx, _)) => res = idx,
                    None => return 0
                }
            }

            res
        }

        pub fn forward_char(n: usize, s: &str, cur: usize) -> usize {
            let mut chars = s[cur..].char_indices()
                .filter(|&(_, ch)| !is_combining_mark(ch));

            for _ in 0..n {
                match chars.next() {
                    Some(_) => (),
                    None => return s.len()
                }
            }

            match chars.next() {
                Some((idx, _)) => cur + idx,
                None => s.len()
            }
        }

        pub fn backward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize> {
            let mut pos = None;

            for _ in 0..n {
                match buf[..cur].rfind(ch) {
                    Some(p) => {
                        cur = p;
                        pos = Some(cur);
                    }
                    None => break
                }
            }

            pos
        }

        pub fn forward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize> {
            let mut pos = None;

            for _ in 0..n {
                // Skip past the character under the cursor
                let off = match buf[cur..].chars().next() {
                    Some(ch) => ch.len_utf8(),
                    None => break
                };

                match buf[cur + off..].find(ch) {
                    Some(p) => {
                        cur += off + p;
                        pos = Some(cur);
                    }
                    None => break
                }
            }

            pos
        }

        pub fn backward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize {
            let mut chars = buf[..cur].char_indices().rev();

            for _ in 0..n {
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
            }

            match chars.next() {
                Some((ind, ch)) => ind + ch.len_utf8(),
                None => 0
            }
        }

        pub fn forward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize {
            let mut chars = buf[cur..].char_indices();

            for _ in 0..n {
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
            }

            match chars.next() {
                Some((ind, _)) => cur + ind,
                None => buf.len()
            }
        }

        pub fn back_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize> {
            let prev = backward_word(1, buf, cur, word_break);
            let end = word_end(&buf, prev, word_break);

            if n > 1 {
                let start = backward_word(n - 1, buf, prev, word_break);
                start..end
            } else {
                prev..end
            }
        }

        pub fn forward_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize> {
            let start = next_word(1, buf, cur, word_break);

            if n > 1 {
                let last = next_word(n - 1, buf, start, word_break);
                let end = word_end(buf, last, word_break);
                start..end
            } else {
                let end = word_end(buf, start, word_break);
                start..end
            }
        }
        /// Returns the first character in the buffer, if it contains any valid characters.
        pub fn first_char(buf: &[u8]) -> io::Result<Option<char>> {
            match from_utf8(buf) {
                Ok(s) => Ok(s.chars().next()),
                Err(e) => {
                    if e.error_len().is_some() {
                        return Err(io::Error::new(io::ErrorKind::InvalidData,
                            "invalid utf-8 input received"));
                    }

                    let valid = e.valid_up_to();

                    let s = unsafe { from_utf8_unchecked(&buf[..valid]) };
                    Ok(s.chars().next())
                }
            }
        }

        pub fn first_word(buf: &str, word_break: &str) -> Option<usize> {
            let mut chars = buf.char_indices();

            drop_while(&mut chars, |(_, ch)| word_break.contains(ch));

            chars.next().map(|(idx, _)| idx)
        }

        pub fn word_start(buf: &str, cur: usize, word_break: &str) -> usize {
            let fwd = match buf[cur..].chars().next() {
                Some(ch) => word_break.contains(ch),
                None => return buf.len()
            };

            if fwd {
                next_word(1, buf, cur, word_break)
            } else {
                let mut chars = buf[..cur].char_indices().rev();

                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

                match chars.next() {
                    Some((idx, ch)) => idx + ch.len_utf8(),
                    None => 0
                }
            }
        }

        pub fn next_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize {
            let mut chars = buf[cur..].char_indices();

            for _ in 0..n {
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
            }

            match chars.next() {
                Some((idx, _)) => cur + idx,
                None => buf.len()
            }
        }

        pub fn word_end(buf: &str, cur: usize, word_break: &str) -> usize {
            let mut chars = buf[cur..].char_indices();

            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

            match chars.next() {
                Some((idx, _)) => cur + idx,
                None => buf.len()
            }
        }

        pub fn drop_while<I, T, F>(iter: &mut I, mut f: F)  where I: Iterator<Item=T> + Clone, F: FnMut(T) -> bool {
            loop {
                let mut clone = iter.clone();

                match clone.next() {
                    None => break,
                    Some(t) => {
                        if f(t) {
                            *iter = clone;
                        } else {
                            break;
                        }
                    }
                }
            }
        }

        pub fn get_open_paren(ch: char) -> Option<char> {
            match ch {
                ')' => Some('('),
                ']' => Some('['),
                '}' => Some('{'),
                _ => None
            }
        }

        pub fn find_matching_paren(s: &str, quotes: &str, open: char, close: char) -> Option<usize> {
            let mut chars = s.char_indices().rev();
            let mut level = 0;
            let mut string_delim = None;

            while let Some((ind, ch)) = chars.next() {
                if string_delim == Some(ch) {
                    string_delim = None;
                } else if quotes.contains(ch) {
                    string_delim = Some(ch);
                } else if string_delim.is_none() && ch == close {
                    level += 1;
                } else if string_delim.is_none() && ch == open {
                    level -= 1;

                    if level == 0 {
                        return Some(ind);
                    }
                }
            }

            None
        }

        pub fn is_combining_mark(ch: char) -> bool {
            use mortal::util::is_combining_mark;

            is_combining_mark(ch)
        }

        pub fn is_wide(ch: char) -> bool {
            use mortal::util::char_width;

            char_width(ch) == Some(2)
        }

        pub fn match_name(name: &str, value: &str) -> bool {
            // A value of "foo" matches both "foo" and "foo-bar"
            name == value ||
                (name.starts_with(value) && name.as_bytes()[value.len()] == b'-')
        }
    }

    pub mod variables
    {
        //! Contains types associated with user-configurable variables
        use ::
        {
            *,
        };
        

        use std::borrow::Cow;
        use std::fmt;
        use std::mem::replace;
        use std::time::Duration;

        /// Default `keyseq_timeout`, in milliseconds
        const KEYSEQ_TIMEOUT_MS: u64 = 500;

        /// Iterator over `Reader` variable values
        #[derive(Clone)]
        pub struct VariableIter<'a> {
            vars: &'a Variables,
            n: usize,
        }
        /// Represents a `Reader` variable of a given type
        #[derive(Clone, Debug)]
        pub enum Variable {
            /// Boolean variable
            Boolean(bool),
            /// Integer variable
            Integer(i32),
            /// String variable
            String(Cow<'static, str>),
        }

        impl From<bool> for Variable {
            fn from(b: bool) -> Variable {
                Variable::Boolean(b)
            }
        }

        impl From<i32> for Variable {
            fn from(i: i32) -> Variable {
                Variable::Integer(i)
            }
        }

        impl From<&'static str> for Variable {
            fn from(s: &'static str) -> Variable {
                Variable::String(s.into())
            }
        }

        impl From<Cow<'static, str>> for Variable {
            fn from(s: Cow<'static, str>) -> Variable {
                Variable::String(s)
            }
        }

        impl From<String> for Variable {
            fn from(s: String) -> Variable {
                Variable::String(s.into())
            }
        }

        impl fmt::Display for Variable {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match *self {
                    Variable::Boolean(b) => f.write_str(if b { "on" } else { "off" }),
                    Variable::Integer(n) => fmt::Display::fmt(&n, f),
                    Variable::String(ref s) => fmt::Display::fmt(&s[..], f),
                }
            }
        }

        macro_rules! define_variables {
            ( $( $field:ident : $ty:ty => ( $name:expr , $conv:ident ,
                    |$gr:ident| $getter:expr , |$sr:ident, $v:ident| $setter:expr ) , )+ ) => {
                static VARIABLE_NAMES: &[&str] = &[ $( $name ),+ ];

                pub struct Variables {
                    $( pub $field : $ty ),*
                }

                impl Variables {
                    pub fn get_variable(&self, name: &str) -> Option<Variable> {
                        match name {
                            $( $name => {
                                let $gr = self;
                                Some(Variable::from($getter))
                            } )+
                            _ => None
                        }
                    }

                    pub fn set_variable(&mut self, name: &str, value: &str)
                            -> Option<Variable> {
                        match name {
                            $( $name => {
                                if let Some($v) = $conv(value) {
                                    let $sr = self;
                                    Some(Variable::from($setter))
                                } else {
                                    None
                                }
                            } )+
                            _ => None
                        }
                    }

                    pub fn iter(&self) -> VariableIter {
                        VariableIter{vars: self, n: 0}
                    }
                }

                impl<'a> Iterator for VariableIter<'a> {
                    type Item = (&'static str, Variable);

                    fn next(&mut self) -> Option<Self::Item> {
                        let res = match VARIABLE_NAMES.get(self.n).cloned() {
                            $( Some($name) => ($name, {
                                let $gr = self.vars;
                                Variable::from($getter)
                            }) , )+
                            _ => return None
                        };

                        self.n += 1;
                        Some(res)
                    }
                }
            }
        }

        define_variables!{
            blink_matching_paren: bool => ("blink-matching-paren", parse_bool,
                |r| r.blink_matching_paren,
                |r, v| replace(&mut r.blink_matching_paren, v)),
            comment_begin: Cow<'static, str> => ("comment-begin", parse_string,
                |r| r.comment_begin.clone(),
                |r, v| replace(&mut r.comment_begin, v.into())),
            completion_display_width: usize => ("completion-display-width", parse_usize,
                |r| usize_as_i32(r.completion_display_width),
                |r, v| usize_as_i32(replace(&mut r.completion_display_width, v))),
            completion_query_items: usize => ("completion-query-items", parse_usize,
                |r| usize_as_i32(r.completion_query_items),
                |r, v| usize_as_i32(replace(&mut r.completion_query_items, v))),
            disable_completion: bool => ("disable-completion", parse_bool,
                |r| r.disable_completion,
                |r, v| replace(&mut r.disable_completion, v)),
            echo_control_characters: bool => ("echo-control-characters", parse_bool,
                |r| r.echo_control_characters,
                |r, v| replace(&mut r.echo_control_characters, v)),
            keyseq_timeout: Option<Duration> => ("keyseq-timeout", parse_duration,
                |r| as_millis(r.keyseq_timeout),
                |r, v| as_millis(replace(&mut r.keyseq_timeout, v))),
            page_completions: bool => ("page-completions", parse_bool,
                |r| r.page_completions,
                |r, v| replace(&mut r.page_completions, v)),
            print_completions_horizontally: bool => ("print-completions-horizontally", parse_bool,
                |r| r.print_completions_horizontally,
                |r, v| replace(&mut r.print_completions_horizontally, v)),
        }

        impl Default for Variables {
            fn default() -> Variables {
                Variables{
                    blink_matching_paren: false,
                    comment_begin: "#".into(),
                    completion_display_width: usize::max_value(),
                    completion_query_items: 100,
                    disable_completion: false,
                    echo_control_characters: true,
                    keyseq_timeout: Some(Duration::from_millis(KEYSEQ_TIMEOUT_MS)),
                    page_completions: true,
                    print_completions_horizontally: false,
                }
            }
        }

        fn parse_bool(s: &str) -> Option<bool> {
            match s {
                "0" => Some(false),
                "1" => Some(true),
                s if s.eq_ignore_ascii_case("off") => Some(false),
                s if s.eq_ignore_ascii_case("on") => Some(true),
                _ => None
            }
        }

        fn parse_string(s: &str) -> Option<String> {
            Some(s.to_owned())
        }

        fn as_millis(timeout: Option<Duration>) -> i32 {
            match timeout {
                Some(t) => {
                    let s = (t.as_secs() * 1_000) as i32;
                    let ms = (t.subsec_nanos() / 1_000_000) as i32;

                    s + ms
                }
                None => -1
            }
        }

        fn parse_duration(s: &str) -> Option<Option<Duration>> {
            match s.parse::<i32>() {
                Ok(n) if n <= 0 => Some(None),
                Ok(n) => Some(Some(Duration::from_millis(n as u64))),
                Err(_) => Some(None)
            }
        }

        fn usize_as_i32(u: usize) -> i32 {
            match u {
                u if u > i32::max_value() as usize => -1,
                u => u as i32
            }
        }

        fn parse_usize(s: &str) -> Option<usize> {
            match s.parse::<i32>() {
                Ok(n) if n < 0 => Some(usize::max_value()),
                Ok(n) => Some(n as usize),
                Err(_) => None
            }
        }
    }

    pub mod writer
    {
        //! Provides access to terminal write operations
        use ::
        {
            *,
        };
        /*
        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::collections::{vec_deque, VecDeque};
        use std::fmt;
        use std::io;
        use std::iter::{repeat, Skip};
        use std::mem::swap;
        use std::ops::{Deref, DerefMut, Range};
        use std::sync::Arc;
        use std::sync::MutexGuard;
        use std::time::{Duration, Instant};

        use crate::chars::{is_ctrl, unctrl, ESCAPE, RUBOUT};
        use crate::highlighting::{Highlighter, Style, RESET_STYLE};
        use crate::reader::{START_INVISIBLE, END_INVISIBLE};
        use crate::terminal::{CursorMode, Size, Terminal, TerminalWriter};
        use crate::util::{
            backward_char, forward_char, backward_search_char, forward_search_char,
            filter_visible, is_combining_mark, is_wide, RangeArgument,
        };
        */

        /// Duration to wait for input when "blinking"
        pub const BLINK_DURATION: Duration = Duration::from_millis(500);

        const COMPLETE_MORE: &'static str = "--More--";

        /// Default maximum history size
        const MAX_HISTORY: usize = !0;

        /// Tab column interval
        const TAB_STOP: usize = 8;

        // Length of "(arg: "
        const PROMPT_NUM_PREFIX: usize = 6;
        // Length of ") "
        const PROMPT_NUM_SUFFIX: usize = 2;

        // Length of "(i-search)`"
        const PROMPT_SEARCH_PREFIX: usize = 11;
        // Length of "failed "
        const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
        // Length of "reverse-"
        const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
        // Length of "': "
        const PROMPT_SEARCH_SUFFIX: usize = 3;

        /// Provides an interface to write line-by-line output to the terminal device.
        ///
        /// Holds a lock on terminal write operations.
        /// See [`Interface`] for more information about concurrent operations.
        ///
        /// An instance of this type can be constructed using either the
        /// [`Interface::lock_writer_append`] or the [`Interface::lock_writer_erase`]
        /// method.
        ///
        /// [`Interface`]: ../interface/struct.Interface.html
        /// [`Interface::lock_writer_append`]: ../interface/struct.Interface.html#method.lock_writer_append
        /// [`Interface::lock_writer_erase`]: ../interface/struct.Interface.html#method.lock_writer_erase
        pub struct Writer<'a, 'b: 'a, Term: 'b + Terminal> {
            write: WriterImpl<'a, 'b, Term>,
        }

        enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminal> {
            Mutex(WriteLock<'b, Term>),
            MutRef(&'a mut WriteLock<'b, Term>),
        }

        #[derive(Debug)]
        pub struct Write {
            /// Input buffer
            pub buffer: String,
            /// Original buffer entered before searching through history
            pub backup_buffer: String,
            /// Position of the cursor
            pub cursor: usize,
            /// Position of the cursor if currently performing a blink
            blink: Option<Blink>,

            /// Stored history entries
            pub history: VecDeque<String>,
            /// History entry currently being edited;
            /// `None` if the new buffer is being edited
            pub history_index: Option<usize>,
            /// Maximum size of history
            history_size: usize,
            /// Number of history entries added since last loading history
            history_new_entries: usize,

            /// Whether the prompt is drawn; i.e. a `read_line` operation is in progress
            pub is_prompt_drawn: bool,

            /// Portion of prompt up to and including the final newline
            pub prompt_prefix: String,
            prompt_prefix_len: usize,
            /// Portion of prompt after the final newline
            pub prompt_suffix: String,
            prompt_suffix_len: usize,

            /// Current type of prompt
            pub prompt_type: PromptType,

            /// Whether a search in progress is a reverse search
            pub reverse_search: bool,
            /// Whether a search in progress has failed to find a match
            pub search_failed: bool,
            /// Current search string
            pub search_buffer: String,
            /// Last search string
            pub last_search: String,
            /// Selected history entry prior to a history search
            pub prev_history: Option<usize>,
            /// Position of the cursor prior to a history search
            pub prev_cursor: usize,

            /// Numerical argument
            pub input_arg: Digit,
            /// Whether a numerical argument was supplied
            pub explicit_arg: bool,

            /// Terminal size as of last draw operation
            pub screen_size: Size,
        }

        pub struct WriteLock<'a, Term: 'a + Terminal> {
            term: Box<dyn TerminalWriter<Term> + 'a>,
            data: MutexGuard<'a, Write>,
            highlighter: Option<Arc<dyn Highlighter + Send + Sync>>,
        }

        impl<'a, Term: Terminal> WriteLock<'a, Term> {
            pub fn new(term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write>,
                    highlighter: Option<Arc<dyn Highlighter + Send + Sync>>
                    ) -> WriteLock<'a, Term> {
                WriteLock{
                    term,
                    data,
                    highlighter,
                }
            }

            pub fn size(&self) -> io::Result<Size> {
                self.term.size()
            }

            pub fn flush(&mut self) -> io::Result<()> {
                self.term.flush()
            }

            pub fn update_size(&mut self) -> io::Result<()> {
                let size = self.size()?;
                self.screen_size = size;
                Ok(())
            }

            pub fn blink(&mut self, pos: usize) -> io::Result<()> {
                self.expire_blink()?;

                let orig = self.cursor;
                self.move_to(pos)?;
                self.cursor = orig;

                let expiry = Instant::now() + BLINK_DURATION;

                self.blink = Some(Blink{
                    pos,
                    expiry,
                });

                Ok(())
            }

            pub fn check_expire_blink(&mut self, now: Instant) -> io::Result<bool> {
                if let Some(blink) = self.data.blink {
                    if now >= blink.expiry {
                        self.expire_blink()?;
                    }
                }

                Ok(self.blink.is_none())
            }

            pub fn expire_blink(&mut self) -> io::Result<()> {
                if let Some(blink) = self.data.blink.take() {
                    self.move_from(blink.pos)?;
                }

                Ok(())
            }

            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
                self.expire_blink()?;

                let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

                if redraw {
                    self.clear_full_prompt()?;
                }

                self.data.set_prompt(prompt);

                if redraw {
                    self.draw_prompt()?;
                }

                Ok(())
            }
            /// Draws the prompt and current input, assuming the cursor is at column 0
            pub fn draw_prompt(&mut self) -> io::Result<()> {
                self.draw_prompt_prefix()?;
                self.draw_prompt_suffix()
            }

            pub fn draw_prompt_prefix(&mut self) -> io::Result<()> {
                match self.prompt_type {
                    // Prefix is not drawn when completions are shown
                    PromptType::CompleteMore => Ok(()),
                    _ => {
                        let pfx = self.prompt_prefix.clone();
                        self.draw_raw_prompt(&pfx, Vec::new())
                    }
                }
            }

            pub fn draw_prompt_suffix(&mut self) -> io::Result<()> {
                match self.prompt_type {
                    PromptType::Normal => {
                        let sfx = self.prompt_suffix.clone();

                        let styles = self.highlighter.as_ref().map(|h|
                            h.highlight(&sfx)
                        ).unwrap_or_default();

                        self.draw_raw_prompt(&sfx, styles)?;
                    }
                    PromptType::Number => {
                        let n = self.input_arg.to_i32();
                        let s = format!("(arg: {}) ", n);
                        self.draw_text(0, &s)?;
                    }
                    PromptType::Search => {
                        let pre = match (self.reverse_search, self.search_failed) {
                            (false, false) => "(i-search)",
                            (false, true)  => "(failed i-search)",
                            (true,  false) => "(reverse-i-search)",
                            (true,  true)  => "(failed reverse-i-search)",
                        };

                        let entry_str = self.get_history(self.history_index).to_owned();
                        let prefix_str = format!("{}`{}': ", pre, self.search_buffer);
                        let prefix_len = prefix_str.len();

                        // Calculate styles for the history entry part
                        let entry_styles = self.highlighter.as_ref()
                            .map(|h| h.highlight(&entry_str))
                            .unwrap_or_default();

                        // Adjust style ranges to account for the prefix string
                        let adjusted_styles: Vec<(Range<usize>, Style)> = entry_styles.into_iter()
                            .map(|(range, style)| (range.start + prefix_len .. range.end + prefix_len, style))
                            .collect();

                        let full_str = format!("{}{}", prefix_str, entry_str);

                        // Draw the full string with adjusted styles using draw_text_impl
                        // Use Display options similar to draw_raw_prompt for consistency
                        self.draw_text_impl(0, &full_str, Display {
                            allow_tab: true,
                            allow_newline: true,
                            allow_escape: true,
                        }, false, &adjusted_styles, 0)?;

                        // Calculate screen coordinates using start_col = 0 because full_str includes the prefix.
                        let (end_line, _end_col) = self.line_col_with(full_str.len(), &full_str, 0);
                        let target_cursor_pos_in_full_str = prefix_len + self.cursor;
                        let (target_line, target_col) = self.line_col_with(target_cursor_pos_in_full_str, &full_str, 0);

                        // Calculate relative movement directly
                        let lines = target_line as isize - end_line as isize;
                        // Calculate the column move: move to beginning of target line, then right by target_col.
                        // We know we ended at the beginning of the line *after* end_line (due to wrap or newline logic in draw_text_impl)
                        // or at _end_col if end_line == target_line and no wrap occurred.
                        // It's simpler to move to the beginning of the target line and then right.
                        let cols = target_col as isize; // We will move_up/down first, then move_to_first_column, then move_right.

                        // Apply movement
                        if lines > 0 {
                            self.term.move_down(lines as usize)?;
                        } else if lines < 0 {
                            self.term.move_up((-lines) as usize)?;
                        }
                        self.term.move_to_first_column()?;
                        if cols > 0 {
                            self.term.move_right(cols as usize)?;
                        }
                        // We don't need to call self.move_rel as we performed the terminal moves directly.
                        // Also, don't update self.cursor here, it's already correct (index within history entry).
                        return Ok(())
                    }
                    PromptType::CompleteIntro(n) => {
                        return self.term.write(&complete_intro(n));
                    }
                    PromptType::CompleteMore => {
                        return self.term.write(COMPLETE_MORE);
                    }
                }

                self.draw_buffer(0)?;
                let len = self.buffer.len();
                self.move_from(len)
            }

            pub fn redraw_prompt(&mut self, new_prompt: PromptType) -> io::Result<()> {
                self.clear_prompt()?;
                self.prompt_type = new_prompt;
                self.draw_prompt_suffix()
            }
            /// Draws a portion of the buffer, starting from the given cursor position
            pub fn draw_buffer(&mut self, pos: usize) -> io::Result<()> {
                let (_, col) = self.line_col(pos);

                let styles = self.highlighter.as_ref().map(|h|
                    h.highlight(&self.buffer)
                ).unwrap_or_default();

                let buf_slice = self.buffer[pos..].to_owned();

                self.draw_text_impl(col, &buf_slice, Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                }, false, &styles, pos)?;

                Ok(())
            }
            /// Draw some text with the cursor beginning at the given column.
            fn draw_text(&mut self, start_col: usize, text: &str) -> io::Result<()> {
                self.draw_text_impl(start_col, text, Display{
                    allow_newline: true,
                    .. Display::default()
                }, false, &[], 0)
            }

            fn draw_raw_prompt(&mut self, text: &str, styles: Vec<(Range<usize>, Style)>) -> io::Result<()> {
                self.draw_text_impl(0, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    allow_escape: true,
                }, true, &styles, 0)
            }

            fn draw_text_impl(&mut self, start_col: usize, text: &str, disp: Display,
                    handle_invisible: bool, styles: &[(Range<usize>, Style)], text_offset: usize) -> io::Result<()> {
                let width = self.screen_size.columns;
                let mut col = start_col;
                let mut out = String::with_capacity(text.len());

                let mut current_style = &Style::Default;
                let mut style_iter = styles.iter().peekable();
                let mut current_text_byte = 0;

                let mut clear = false;
                let mut hidden = false;

                for ch in text.chars() {
                    if handle_invisible && ch == START_INVISIBLE {
                        hidden = true;
                    } else if handle_invisible && ch == END_INVISIBLE {
                        hidden = false;
                    } else if hidden {
                        // Render the character, but assume it has 0 width.
                        out.push(ch);
                        current_text_byte += ch.len_utf8();
                    } else {
                        // Determine style for the current character
                        let absolute_byte_pos = text_offset + current_text_byte;
                        // Advance style iterator past ranges that end before the current position
                        while let Some((range, _)) = style_iter.peek() {
                            if range.end <= absolute_byte_pos {
                                style_iter.next();
                            } else {
                                break;
                            }
                        }

                        // Find the style that applies to the current position
                        let new_style = style_iter.peek()
                            .filter(|(range, _)| range.start <= absolute_byte_pos)
                            .map(|(_, style)| style)
                            .unwrap_or(&Style::Default);

                        // Apply style change if needed
                        if new_style != current_style {
                            if current_style != &Style::Default {
                                out.push_str(RESET_STYLE); // Reset previous style
                            }
                            if let Style::AnsiColor(ansi_code) = new_style {
                                out.push_str(ansi_code); // Apply new style
                            }
                            current_style = new_style;
                        }

                        // Apply style if changed
                        for ch in display(ch, disp) {
                            if ch == '\t' {
                                let n = TAB_STOP - (col % TAB_STOP);

                                if col + n > width {
                                    let pre = width - col;
                                    out.extend(repeat(' ').take(pre));
                                    out.push_str(" \r");
                                    out.extend(repeat(' ').take(n - pre));
                                    col = n - pre;
                                } else {
                                    out.extend(repeat(' ').take(n));
                                    col += n;

                                    if col == width {
                                        out.push_str(" \r");
                                        col = 0;
                                    }
                                }
                            } else if ch == '\n' {
                                if !clear {
                                    self.term.write(&out)?;
                                    out.clear();
                                    self.term.clear_to_screen_end()?;
                                    clear = true;
                                }

                                out.push('\n');
                                col = 0;
                            } else if is_combining_mark(ch) {
                                out.push(ch);
                            } else if is_wide(ch) {
                                if col == width - 1 {
                                    out.push_str("  \r");
                                    out.push(ch);
                                    col = 2;
                                } else {
                                    out.push(ch);
                                    col += 2;
                                }
                            } else {
                                out.push(ch);
                                col += 1;

                                if col == width {
                                    // Space pushes the cursor to the next line,
                                    // CR brings back to the start of the line.
                                    out.push_str(" \r");
                                    col = 0;
                                }
                            }
                        }
                        current_text_byte += ch.len_utf8(); // Advance byte counter *after* processing character
                    }
                }

                // Ensure style is reset at the end
                if current_style != &Style::Default {
                    // Check if the last applied style was actually from the styles vec
                    let last_applied_style = styles.iter().rev().find(|(range, _)| range.start < text_offset + text.len());
                    match last_applied_style {
                        Some((_, Style::Default)) => {}, // Already default
                        Some((_, Style::AnsiColor(_))) => out.push_str(RESET_STYLE),
                        None if !styles.is_empty() => out.push_str(RESET_STYLE), // Reset if styles were provided but didn't cover the end
                        _ => {} // No styles or last was default
                    }
                }

                if col == width {
                    out.push_str(" \r");
                }

                self.term.write(&out)
            }

            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
                self.expire_blink()?;

                self.move_to(0)?;
                self.buffer.clear();
                self.buffer.push_str(buf);
                self.new_buffer()
            }

            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
                self.expire_blink()?;

                if !self.buffer.is_char_boundary(pos) {
                    panic!("invalid cursor position {} in buffer {:?}",
                        pos, self.buffer);
                }

                self.move_to(pos)
            }

            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.term.set_cursor_mode(mode)
            }

            pub fn history_len(&self) -> usize {
                self.history.len()
            }

            pub fn history_size(&self) -> usize {
                self.history_size
            }

            pub fn set_history_size(&mut self, n: usize) {
                self.history_size = n;
                self.truncate_history(n);
            }

            pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                self.term.write(s)
            }

            pub fn start_history_search(&mut self, reverse: bool) -> io::Result<()> {
                self.search_buffer = self.buffer[..self.cursor].to_owned();

                self.continue_history_search(reverse)
            }

            pub fn continue_history_search(&mut self, reverse: bool) -> io::Result<()> {
                if let Some(idx) = self.find_history_search(reverse) {
                    let original_cursor = self.cursor;
                    self.set_history_entry(Some(idx));

                    // Clear the old line content visually
                    self.clear_prompt()?;
                    // Redraw the prompt and the entire new buffer content
                    self.draw_prompt_suffix()?;
                    // Move the cursor back to its original position
                    self.move_to(original_cursor)?; // This updates self.cursor and moves physical cursor
                }
                Ok(())
            }

            pub fn info(&self) -> String {
                format!(
                    "buffer: {:?}, cursor: {} hindex: {:?} pmt_suffix_len: {} pmt_type: {:?} search_buffer: {:?} last_s: {:?} prompt_p: {:?} ({}) prompt_s: {:?} ({})",
                    self.buffer, self.cursor, self.history_index,
                    self.prompt_suffix_len, self.prompt_type, self.search_buffer,
                    self.last_search, self.prompt_prefix, self.prompt_prefix_len,
                    self.prompt_suffix, self.prompt_suffix_len,
                )
            }

            fn find_history_search(&self, reverse: bool) -> Option<usize> {
                let len = self.history.len();
                let idx = self.history_index.unwrap_or(len);

                if reverse {
                    self.history.iter().rev().skip(len - idx)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx - (pos + 1))
                } else {
                    self.history.iter().skip(idx + 1)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx + (pos + 1))
                }
            }

            pub fn start_search_history(&mut self, reverse: bool) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;
                self.search_buffer.clear();
                self.prev_history = self.history_index;
                self.prev_cursor = self.cursor;

                self.redraw_prompt(PromptType::Search)
            }

            pub fn continue_search_history(&mut self, reverse: bool) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;

                {
                    let data = &mut *self.data;
                    data.search_buffer.clone_from(&data.last_search);
                }

                self.search_history_step()
            }

            pub fn end_search_history(&mut self) -> io::Result<()> {
                self.redraw_prompt(PromptType::Normal)
            }

            pub fn abort_search_history(&mut self) -> io::Result<()> {
                self.clear_prompt()?;

                let ent = self.prev_history;
                self.set_history_entry(ent);
                self.cursor = self.prev_cursor;

                self.prompt_type = PromptType::Normal;
                self.draw_prompt_suffix()
            }

            fn show_search_match(&mut self, next_match: Option<(Option<usize>, usize)>)
                    -> io::Result<()> {
                self.clear_prompt()?;

                if let Some((idx, pos)) = next_match {
                    self.search_failed = false;
                    self.set_history_entry(idx);
                    self.cursor = pos;
                } else {
                    self.search_failed = true;
                }


                self.prompt_type = PromptType::Search;
                self.draw_prompt_suffix()
            }

            pub fn search_history_update(&mut self) -> io::Result<()> {
                // Search for the next match, perhaps including the current position
                let next_match = if self.reverse_search {
                    self.search_history_backward(&self.search_buffer, true)
                } else {
                    self.search_history_forward(&self.search_buffer, true)
                };

                self.show_search_match(next_match)
            }

            fn search_history_step(&mut self) -> io::Result<()> {
                if self.search_buffer.is_empty() {
                    return self.redraw_prompt(PromptType::Search);
                }

                // Search for the next match
                let next_match = if self.reverse_search {
                    self.search_history_backward(&self.search_buffer, false)
                } else {
                    self.search_history_forward(&self.search_buffer, false)
                };

                self.show_search_match(next_match)
            }

            fn search_history_backward(&self, s: &str, include_cur: bool)
                    -> Option<(Option<usize>, usize)> {
                let mut idx = self.history_index;
                let mut pos = Some(self.cursor);

                if include_cur && !self.search_failed {
                    if let Some(p) = pos {
                        if self.get_history(idx).is_char_boundary(p + s.len()) {
                            pos = Some(p + s.len());
                        }
                    }
                }

                loop {
                    let line = self.get_history(idx);

                    match line[..pos.unwrap_or(line.len())].rfind(s) {
                        Some(found) => {
                            pos = Some(found);
                            break;
                        }
                        None => {
                            match idx {
                                Some(0) => return None,
                                Some(n) => {
                                    idx = Some(n - 1);
                                    pos = None;
                                }
                                None => {
                                    if self.history.is_empty() {
                                        return None;
                                    } else {
                                        idx = Some(self.history.len() - 1);
                                        pos = None;
                                    }
                                }
                            }
                        }
                    }
                }

                pos.map(|pos| (idx, pos))
            }

            fn search_history_forward(&self, s: &str, include_cur: bool)
                    -> Option<(Option<usize>, usize)> {
                let mut idx = self.history_index;
                let mut pos = Some(self.cursor);

                if !include_cur {
                    if let Some(p) = pos {
                        pos = Some(forward_char(1, self.get_history(idx), p));
                    }
                }

                loop {
                    let line = self.get_history(idx);

                    match line[pos.unwrap_or(0)..].find(s) {
                        Some(found) => {
                            pos = pos.map(|n| n + found).or(Some(found));
                            break;
                        }
                        None => {
                            if let Some(n) = idx {
                                if n + 1 == self.history.len() {
                                    idx = None;
                                } else {
                                    idx = Some(n + 1);
                                }
                                pos = None;
                            } else {
                                return None;
                            }
                        }
                    }
                }

                pos.map(|pos| (idx, pos))
            }

            pub fn add_history(&mut self, line: String) {
                if self.history.len() == self.history_size {
                    self.history.pop_front();
                }

                self.history.push_back(line);
                self.history_new_entries = self.history.len()
                    .min(self.history_new_entries + 1);
            }

            pub fn add_history_unique(&mut self, line: String) {
                let is_duplicate = self.history.back().map_or(false, |ent| *ent == line);

                if !is_duplicate {
                    self.add_history(line);
                }
            }

            pub fn clear_history(&mut self) {
                self.truncate_history(0);
                self.history_new_entries = 0;
            }

            pub fn remove_history(&mut self, n: usize) {
                if n < self.history.len() {
                    let first_new = self.history.len() - self.history_new_entries;

                    if n >= first_new {
                        self.history_new_entries -= 1;
                    }

                    self.history.remove(n);
                }
            }

            pub fn truncate_history(&mut self, n: usize) {
                let len = self.history.len();

                if n < len {
                    let _ = self.history.drain(..len - n);
                    self.history_new_entries = self.history_new_entries.max(n);
                }
            }

            pub fn next_history(&mut self, n: usize) -> io::Result<()> {
                if let Some(old) = self.history_index {
                    let new = old.saturating_add(n);

                    if new >= self.history.len() {
                        self.select_history_entry(None)?;
                    } else {
                        self.select_history_entry(Some(new))?;
                    }
                }

                Ok(())
            }

            pub fn prev_history(&mut self, n: usize) -> io::Result<()> {
                if !self.history.is_empty() && self.history_index != Some(0) {
                    let new = if let Some(old) = self.history_index {
                        old.saturating_sub(n)
                    } else {
                        self.history.len().saturating_sub(n)
                    };

                    self.select_history_entry(Some(new))?;
                }

                Ok(())
            }

            pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
                if new != self.history_index {
                    self.move_to(0)?;
                    self.set_history_entry(new);
                    self.new_buffer()?;
                }

                Ok(())
            }

            pub fn set_history_entry(&mut self, new: Option<usize>) {
                let old = self.history_index;

                if old != new {
                    let data = &mut *self.data;
                    data.history_index = new;

                    if let Some(old) = old {
                        data.history[old].clone_from(&data.buffer);
                    } else {
                        swap(&mut data.buffer, &mut data.backup_buffer);
                    }

                    if let Some(new) = new {
                        data.buffer.clone_from(&data.history[new]);
                    } else {
                        data.buffer.clear();
                        swap(&mut data.buffer, &mut data.backup_buffer);
                    }
                }
            }

            fn get_history(&self, n: Option<usize>) -> &str {
                if self.history_index == n {
                    &self.buffer
                } else if let Some(n) = n {
                    &self.history[n]
                } else {
                    &self.backup_buffer
                }
            }

            pub fn backward_char(&mut self, n: usize) -> io::Result<()> {
                let pos = backward_char(n, &self.buffer, self.cursor);
                self.move_to(pos)
            }

            pub fn forward_char(&mut self, n: usize) -> io::Result<()> {
                let pos = forward_char(n, &self.buffer, self.cursor);
                self.move_to(pos)
            }

            pub fn backward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> {
                if let Some(pos) = backward_search_char(n, &self.buffer, self.cursor, ch) {
                    self.move_to(pos)?;
                }

                Ok(())
            }

            pub fn forward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> {
                if let Some(pos) = forward_search_char(n, &self.buffer, self.cursor, ch) {
                    self.move_to(pos)?;
                }

                Ok(())
            }
            /// Deletes a range from the buffer; the cursor is moved to the end
            /// of the given range.
            pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.buffer.len());

                // Move to the start of the deletion range
                self.move_to(start)?;

                // Remove the characters in the range
                let _ = self.buffer.drain(start..end);

                // Move physical cursor to the beginning of the editable area
                let current_internal_cursor = self.cursor; // Save internal cursor state
                self.move_to(0)?; // Move physical cursor to start of input area
                self.cursor = current_internal_cursor; // Restore internal cursor state

                // Redraw the entire buffer from position 0 with updated highlighting
                self.draw_buffer(0)?;

                // Clear any leftover characters from the previous render
                self.term.clear_to_screen_end()?;

                // Update internal cursor state to the deletion point
                self.cursor = start;

                // Move physical cursor from the end of the drawn buffer back to deletion point
                let len = self.buffer.len();
                self.move_from(len)?;

                Ok(())
            }

            pub fn insert_str(&mut self, s: &str) -> io::Result<()> {
                let original_cursor = self.cursor;
                self.buffer.insert_str(original_cursor, s);
                let new_cursor = original_cursor + s.len();

                // Move physical cursor to the beginning of the editable area (position 0 relative to prompt suffix)
                // Need to use move_rel carefully or move_to(0) which recalculates absolute position.
                // Let's recalculate using move_to(0).
                let current_internal_cursor = self.cursor; // Save internal cursor state before move_to potentially changes it
                self.move_to(0)?; // Move physical cursor to the start of the input area
                self.cursor = current_internal_cursor; // Restore internal cursor state

                // Redraw the entire buffer from position 0 with updated highlighting
                self.draw_buffer(0)?; // This draws the text and leaves the physical cursor at the end


                // Clear any leftover characters from the previous render (if the line got shorter)
                // Although in insert_str it only gets longer or stays same. Still good practice.
                self.term.clear_to_screen_end()?;

                // Update the internal cursor state to the correct position after insertion
                self.cursor = new_cursor;

                // Move the physical cursor from the end of the drawn buffer
                // back to the correct internal cursor position.
                let len = self.buffer.len();
                self.move_from(len)?;

                Ok(())
            }

            pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                    -> io::Result<()> {
                // Ranges must not overlap
                assert!(src.end <= dest.start || src.start >= dest.end);

                // Final cursor position
                let final_cur = if src.start < dest.start {
                    dest.end
                } else {
                    dest.start + (src.end - src.start)
                };

                let (left, right) = if src.start < dest.start {
                    (src, dest)
                } else {
                    (dest, src)
                };

                self.move_to(left.start)?;

                let a = self.buffer[left.clone()].to_owned();
                let b = self.buffer[right.clone()].to_owned();

                let _ = self.buffer.drain(right.clone());
                self.buffer.insert_str(right.start, &a);

                let _ = self.buffer.drain(left.clone());
                self.buffer.insert_str(left.start, &b);

                let cursor = self.cursor;
                self.draw_buffer(cursor)?;
                self.term.clear_to_screen_end()?;

                self.cursor = final_cur;
                let len = self.buffer.len();
                self.move_from(len)
            }

            fn prompt_suffix_length(&self) -> usize {
                match self.prompt_type {
                    PromptType::Normal => self.prompt_suffix_len,
                    PromptType::Number => {
                        let n = number_len(self.input_arg.to_i32());
                        PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                    }
                    PromptType::Search => {
                        let mut prefix = PROMPT_SEARCH_PREFIX;

                        if self.reverse_search {
                            prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                        }
                        if self.search_failed {
                            prefix += PROMPT_SEARCH_FAILED_PREFIX;
                        }

                        let n = self.display_size(&self.search_buffer, prefix);
                        prefix + n + PROMPT_SEARCH_SUFFIX
                    }
                    PromptType::CompleteIntro(n) => complete_intro(n).len(),
                    PromptType::CompleteMore => COMPLETE_MORE.len(),
                }
            }

            fn line_col(&self, pos: usize) -> (usize, usize) {
                let prompt_len = self.prompt_suffix_length();

                match self.prompt_type {
                    PromptType::CompleteIntro(_) |
                    PromptType::CompleteMore => {
                        let width = self.screen_size.columns;
                        (prompt_len / width, prompt_len % width)
                    }
                    _ => self.line_col_with(pos, &self.buffer, prompt_len)
                }
            }

            fn line_col_with(&self, pos: usize, buf: &str, start_col: usize) -> (usize, usize) {
                let width = self.screen_size.columns;
                if width == 0 {
                    return (0, 0);
                }

                let n = start_col + self.display_size(&buf[..pos], start_col);

                (n / width, n % width)
            }

            pub fn clear_screen(&mut self) -> io::Result<()> {
                self.term.clear_screen()?;
                self.draw_prompt()?;

                Ok(())
            }

            pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
                self.term.clear_to_screen_end()
            }
            /// Draws a new buffer on the screen. Cursor position is assumed to be `0`.
            pub fn new_buffer(&mut self) -> io::Result<()> {
                self.draw_buffer(0)?;
                self.cursor = self.buffer.len();

                self.term.clear_to_screen_end()?;

                Ok(())
            }

            pub fn clear_full_prompt(&mut self) -> io::Result<()> {
                let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
                let (line, _) = self.line_col(self.cursor);
                self.term.move_up(prefix_lines + line)?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }

            pub fn clear_prompt(&mut self) -> io::Result<()> {
                let (line, _) = self.line_col(self.cursor);

                self.term.move_up(line)?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }
            /// Move back to true cursor position from some other position
            pub fn move_from(&mut self, pos: usize) -> io::Result<()> {
                let (lines, cols) = self.move_delta(pos, self.cursor, &self.buffer);
                self.move_rel(lines, cols)
            }

            pub fn move_to(&mut self, pos: usize) -> io::Result<()> {
                if pos != self.cursor {
                    let (lines, cols) = self.move_delta(self.cursor, pos, &self.buffer);
                    self.move_rel(lines, cols)?;
                    self.cursor = pos;
                }

                Ok(())
            }

            pub fn move_to_end(&mut self) -> io::Result<()> {
                let pos = self.buffer.len();
                self.move_to(pos)
            }

            pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                self.term.move_right(n)
            }
            /// Moves from `old` to `new` cursor position, using the given buffer
            /// as current input.
            fn move_delta(&self, old: usize, new: usize, buf: &str) -> (isize, isize) {
                let prompt_len = self.prompt_suffix_length();
                let (old_line, old_col) = self.line_col_with(old, buf, prompt_len);
                let (new_line, new_col) = self.line_col_with(new, buf, prompt_len);

                (new_line as isize - old_line as isize,
                new_col as isize - old_col as isize)
            }

            fn move_rel(&mut self, lines: isize, cols: isize) -> io::Result<()> {
                if lines > 0 {
                    self.term.move_down(lines as usize)?;
                } else if lines < 0 {
                    self.term.move_up((-lines) as usize)?;
                }

                if cols > 0 {
                    self.term.move_right(cols as usize)?;
                } else if cols < 0 {
                    self.term.move_left((-cols) as usize)?;
                }

                Ok(())
            }

            pub fn reset_data(&mut self) {
                self.data.reset_data();
            }

            pub fn set_digit_from_char(&mut self, ch: char) {
                let digit = match ch {
                    '-' => Digit::NegNone,
                    '0' ..= '9' => Digit::from(ch),
                    _ => Digit::None
                };

                self.input_arg = digit;
                self.explicit_arg = true;
            }
        }

        #[derive(Copy, Clone, Debug)]
        struct Blink {
            pos: usize,
            expiry: Instant,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Writer<'a, 'b, Term> {
            fn new(mut write: WriterImpl<'a, 'b, Term>, clear: bool) -> io::Result<Self> {
                write.expire_blink()?;

                if write.is_prompt_drawn {
                    if clear {
                        write.clear_full_prompt()?;
                    } else {
                        write.move_to_end()?;
                        write.write_str("\n")?;
                    }
                }

                Ok(Writer{write})
            }

            pub fn with_lock(write: WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
                Writer::new(WriterImpl::Mutex(write), clear)
            }

            pub fn with_ref(write: &'a mut WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
                Writer::new(WriterImpl::MutRef(write), clear)
            }
            /// Returns an iterator over history entries.
            pub fn history(&self) -> HistoryIter {
                self.write.history()
            }
            /// Writes some text to the terminal device.
            ///
            /// Before the `Writer` is dropped, any output written should be followed
            /// by a newline. A newline is automatically written if the `writeln!`
            /// macro is used.
            pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                self.write.write_str(s)
            }
            /// Writes formatted text to the terminal display.
            ///
            /// This method enables `Interface` to be used as the receiver to
            /// the [`writeln!`] macro.
            ///
            /// If the text contains any unprintable characters (e.g. escape sequences),
            /// those characters will be escaped before printing.
            ///
            /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
            /// [`writeln!`]: https://doc.rust-lang.org/std/macro.writeln.html
            pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Drop for Writer<'a, 'b, Term> {
            fn drop(&mut self) {
                if self.write.is_prompt_drawn {
                    // There's not really anything useful to be done with this error.
                    let _ = self.write.draw_prompt();
                }
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for WriteLock<'a, Term> {
            type Target = Write;

            fn deref(&self) -> &Write {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for WriteLock<'a, Term> {
            fn deref_mut(&mut self) -> &mut Write {
                &mut self.data
            }
        }

        impl Write {
            pub fn new(screen_size: Size) -> Write {
                Write{
                    buffer: String::new(),
                    backup_buffer: String::new(),
                    cursor: 0,
                    blink: None,

                    history: VecDeque::new(),
                    history_index: None,
                    history_size: MAX_HISTORY,
                    history_new_entries: 0,

                    is_prompt_drawn: false,

                    prompt_prefix: String::new(),
                    prompt_prefix_len: 0,
                    prompt_suffix: String::new(),
                    prompt_suffix_len: 0,

                    prompt_type: PromptType::Normal,

                    reverse_search: false,
                    search_failed: false,
                    search_buffer: String::new(),
                    last_search: String::new(),
                    prev_history: None,
                    prev_cursor: !0,

                    input_arg: Digit::None,
                    explicit_arg: false,

                    screen_size,
                }
            }

            pub fn history(&self) -> HistoryIter {
                HistoryIter(self.history.iter())
            }

            pub fn new_history(&self) -> Skip<HistoryIter> {
                let first_new = self.history.len() - self.history_new_entries;
                self.history().skip(first_new)
            }

            pub fn new_history_entries(&self) -> usize {
                self.history_new_entries
            }

            pub fn reset_data(&mut self) {
                self.buffer.clear();
                self.backup_buffer.clear();
                self.cursor = 0;
                self.history_index = None;

                self.prompt_type = PromptType::Normal;

                self.input_arg = Digit::None;
                self.explicit_arg = false;
            }

            pub fn reset_new_history(&mut self) {
                self.history_new_entries = 0;
            }

            pub fn set_buffer(&mut self, buf: &str) {
                self.buffer.clear();
                self.buffer.push_str(buf);
                self.cursor = buf.len();
            }

            pub fn set_cursor(&mut self, pos: usize) {
                if !self.buffer.is_char_boundary(pos) {
                    panic!("invalid cursor position {} in buffer {:?}",
                        pos, self.buffer);
                }

                self.cursor = pos;
            }

            pub fn set_prompt(&mut self, prompt: &str) {
                let (pre, suf) = match prompt.rfind('\n') {
                    Some(pos) => (&prompt[..pos + 1], &prompt[pos + 1..]),
                    None => (&prompt[..0], prompt)
                };

                self.prompt_prefix = pre.to_owned();
                self.prompt_suffix = suf.to_owned();

                let pre_virt = filter_visible(pre);
                self.prompt_prefix_len = self.display_size(&pre_virt, 0);

                let suf_virt = filter_visible(suf);
                self.prompt_suffix_len = self.display_size(&suf_virt, 0);
            }

            pub fn display_size(&self, s: &str, start_col: usize) -> usize {
                let width = self.screen_size.columns;
                let mut col = start_col;

                let disp = Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                };

                for ch in filter_visible(s).chars().flat_map(|ch| display(ch, disp)) {
                    let n = match ch {
                        '\n' => width - (col % width),
                        '\t' => TAB_STOP - (col % TAB_STOP),
                        ch if is_combining_mark(ch) => 0,
                        ch if is_wide(ch) => {
                            if col % width == width - 1 {
                                // Can't render a fullwidth character into last column
                                3
                            } else {
                                2
                            }
                        }
                        _ => 1
                    };

                    col += n;
                }

                col - start_col
            }
        }
        /// Maximum value of digit input
        const NUMBER_MAX: i32 = 1_000_000;

        #[derive(Copy, Clone, Debug)]
        pub enum Digit {
            None,
            NegNone,
            Num(i32),
            NegNum(i32),
        }

        impl Digit {
            pub fn input(&mut self, n: i32) {
                match *self {
                    Digit::None => *self = Digit::Num(n),
                    Digit::NegNone => *self = Digit::NegNum(n),
                    Digit::Num(ref mut m) | Digit::NegNum(ref mut m) => {
                        *m *= 10;
                        *m += n;
                    }
                }
            }

            pub fn is_out_of_bounds(&self) -> bool {
                match *self {
                    Digit::Num(n) | Digit::NegNum(n) if n > NUMBER_MAX => true,
                    _ => false
                }
            }

            pub fn to_i32(&self) -> i32 {
                match *self {
                    Digit::None => 1,
                    Digit::NegNone => -1,
                    Digit::Num(n) => n,
                    Digit::NegNum(n) => -n,
                }
            }
        }

        impl From<char> for Digit {
            /// Convert a decimal digit character to a `Digit` value.
            ///
            /// The input must be in the range `'0' ..= '9'`.
            fn from(ch: char) -> Digit {
                let n = (ch as u8) - b'0';
                Digit::Num(n as i32)
            }
        }

        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum PromptType {
            Normal,
            Number,
            Search,
            CompleteIntro(usize),
            CompleteMore,
        }

        impl PromptType {
            pub fn is_normal(&self) -> bool {
                *self == PromptType::Normal
            }
        }

        impl<'a, 'b, Term: 'b + Terminal> Deref for WriterImpl<'a, 'b, Term> {
            type Target = WriteLock<'b, Term>;

            fn deref(&self) -> &WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex(ref m) => m,
                    WriterImpl::MutRef(ref m) => m,
                }
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> DerefMut for WriterImpl<'a, 'b, Term> {
            fn deref_mut(&mut self) -> &mut WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex(ref mut m) => m,
                    WriterImpl::MutRef(ref mut m) => m,
                }
            }
        }
        /// Iterator over `Interface` history entries
        pub struct HistoryIter<'a>(vec_deque::Iter<'a, String>);

        impl<'a> ExactSizeIterator for HistoryIter<'a> {}

        impl<'a> Iterator for HistoryIter<'a> {
            type Item = &'a str;

            #[inline]
            fn next(&mut self) -> Option<&'a str> {
                self.0.next().map(|s| &s[..])
            }

            #[inline]
            fn nth(&mut self, n: usize) -> Option<&'a str> {
                self.0.nth(n).map(|s| &s[..])
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.0.size_hint()
            }
        }

        impl<'a> DoubleEndedIterator for HistoryIter<'a> {
            #[inline]
            fn next_back(&mut self) -> Option<&'a str> {
                self.0.next_back().map(|s| &s[..])
            }
        }

        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum DisplaySequence {
            Char(char),
            Escape(char),
            End,
        }

        impl Iterator for DisplaySequence {
            type Item = char;

            fn next(&mut self) -> Option<char> {
                use self::DisplaySequence::*;

                let (res, next) = match *self {
                    Char(ch) => (ch, End),
                    Escape(ch) => ('^', Char(ch)),
                    End => return None
                };

                *self = next;
                Some(res)
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                use self::DisplaySequence::*;

                let n = match *self {
                    Char(_) => 1,
                    Escape(_) => 2,
                    End => 0,
                };

                (n, Some(n))
            }
        }

        #[derive(Copy, Clone, Debug, Default)]
        pub struct Display {
            allow_tab: bool,
            allow_newline: bool,
            allow_escape: bool,
        }

        pub fn display(ch: char, style: Display) -> DisplaySequence {
            match ch {
                '\t' if style.allow_tab => DisplaySequence::Char(ch),
                '\n' if style.allow_newline => DisplaySequence::Char(ch),
                ESCAPE if style.allow_escape => DisplaySequence::Char(ch),
                '\0' => DisplaySequence::Escape('@'),
                RUBOUT => DisplaySequence::Escape('?'),
                ch if is_ctrl(ch) => DisplaySequence::Escape(unctrl(ch)),
                ch => DisplaySequence::Char(ch)
            }
        }

        pub fn display_str<'a>(s: &'a str, style: Display) -> Cow<'a, str> {
            if s.chars().all(|ch| display(ch, style) == DisplaySequence::Char(ch)) {
                Borrowed(s)
            } else {
                Owned(s.chars().flat_map(|ch| display(ch, style)).collect())
            }
        }

        fn complete_intro(n: usize) -> String {
            format!("Display all {} possibilities? (y/n)", n)
        }

        fn number_len(n: i32) -> usize {
            match n {
                -1_000_000              => 8,
                -  999_999 ..= -100_000 => 7,
                -   99_999 ..= - 10_000 => 6,
                -    9_999 ..= -  1_000 => 5,
                -      999 ..= -    100 => 4,
                -       99 ..= -     10 => 3,
                -        9 ..= -      1 => 2,
                        0 ..=        9 => 1,
                        10 ..=       99 => 2,
                    100 ..=      999 => 3,
                    1_000 ..=    9_999 => 4,
                    10_000 ..=   99_999 => 5,
                100_000 ..=  999_999 => 6,
                1_000_000              => 7,
                _ => unreachable!()
            }
        }
    }

    pub mod system
    {
        use ::
        {
            *,
        };

        pub mod unix
        {

        }

        pub mod windows
        {
            
        }
    }
    #[cfg(unix)] pub use self::system::unix as sys;
    #[cfg(windows)] pub use self::system::windows as sys;
    /*
    #[cfg(unix)]
    #[path = "unix/mod.rs"]
    mod sys;

    #[cfg(windows)]
    #[path = "windows/mod.rs"]
    mod sys;
    */
}

pub mod linked_hash_map
{
    //! A `HashMap` wrapper that holds key-value pairs in insertion order.
    use ::
    {
        *,
    };
    /*
    use std::borrow::Borrow;
    use std::cmp::Ordering;
    use std::collections::hash_map::{self, HashMap};
    use std::fmt;
    use std::hash::{BuildHasher, Hash, Hasher};
    use std::iter;
    use std::marker;
    use std::mem;
    use std::ops::{Index, IndexMut};
    use std::ptr::{self, addr_of_mut};
    */
    // Optional Heapsize support
    mod heapsize
    {
        use ::
        {
            heapsize::{ heap_size_of, HeapSizeOf },
            hash::{ BuildHasher, Hash },
            *,
        }; use { KeyRef, LinkedHashMap, Node };

        impl<K> HeapSizeOf for KeyRef<K> 
        {
            fn heap_size_of_children(&self) -> usize {
                0
            }
        }

        impl<K, V> HeapSizeOf for Node<K, V> where
        K: HeapSizeOf,
        V: HeapSizeOf
        {
            fn heap_size_of_children(&self) -> usize {
                self.key.heap_size_of_children() + self.value.heap_size_of_children()
            }
        }

        impl<K, V, S> HeapSizeOf for LinkedHashMap<K, V, S> where
        K: HeapSizeOf + Hash + Eq,
        V: HeapSizeOf,
        S: BuildHasher
        {
            fn heap_size_of_children(&self) -> usize {
                unsafe {
                    let mut size = self.map.heap_size_of_children();
                    for &value in self.map.values() {
                        size += (*value).heap_size_of_children();
                        size += heap_size_of(value as *const _ as *const _);
                    }

                    if !self.head.is_null() {
                        size += heap_size_of(self.head as *const _ as *const _);
                    }

                    let mut free = self.free;
                    while !free.is_null() {
                        size += heap_size_of(free as *const _ as *const _);
                        free = (*free).next
                    }

                    size
                }
            }
        }
    }

    struct KeyRef<K> {
        k: *const K,
    }

    struct Node<K, V> {
        next: *mut Node<K, V>,
        prev: *mut Node<K, V>,
        key: K,
        value: V,
    }
    /// A linked hash map.
    pub struct LinkedHashMap<K, V, S = hash_map::RandomState> {
        map: HashMap<KeyRef<K>, *mut Node<K, V>, S>,
        head: *mut Node<K, V>,
        free: *mut Node<K, V>,
    }

    impl<K: Hash> Hash for KeyRef<K> {
        fn hash<H: Hasher>(&self, state: &mut H) {
            unsafe { (*self.k).hash(state) }
        }
    }

    impl<K: PartialEq> PartialEq for KeyRef<K> {
        fn eq(&self, other: &Self) -> bool {
            unsafe { (*self.k).eq(&*other.k) }
        }
    }

    impl<K: Eq> Eq for KeyRef<K> {}

    #[derive(Hash, PartialEq, Eq)]
    #[repr(transparent)]
    struct Qey<Q: ?Sized>(Q);

    impl<Q: ?Sized> Qey<Q> {
        fn from_ref(q: &Q) -> &Self {
            unsafe { mem::transmute(q) }
        }
    }

    impl<K, Q: ?Sized> Borrow<Qey<Q>> for KeyRef<K> where
        K: Borrow<Q>,
    {
        fn borrow(&self) -> &Qey<Q> {
            Qey::from_ref(unsafe { (*self.k).borrow() })
        }
    }

    impl<K, V> Node<K, V> {
        fn new(k: K, v: V) -> Self {
            Node {
                key: k,
                value: v,
                next: ptr::null_mut(),
                prev: ptr::null_mut(),
            }
        }
    }
    
    unsafe fn drop_empty_node<K, V>(the_box: *mut Node<K, V>) {
        // Safety:
        // In this crate all `Node` is allocated via `Box` or `alloc`, and `Box` uses the
        // Global allocator for its allocation,
        // (https://doc.rust-lang.org/std/boxed/index.html#memory-layout) so we can safely
        // deallocate the pointer to `Node` by calling `dealloc` method
        let layout = std::alloc::Layout::new::<Node<K, V>>();
        std::alloc::dealloc(the_box as *mut u8, layout);
    }

    impl<K: Hash + Eq, V> LinkedHashMap<K, V> {
        /// Creates a linked hash map.
        pub fn new() -> Self {
            Self::with_map(HashMap::new())
        }
        /// Creates an empty linked hash map with the given initial capacity.
        pub fn with_capacity(capacity: usize) -> Self {
            Self::with_map(HashMap::with_capacity(capacity))
        }
    }

    impl<K, V, S> LinkedHashMap<K, V, S> {
        #[inline]
        fn detach(&mut self, node: *mut Node<K, V>) {
            unsafe {
                (*(*node).prev).next = (*node).next;
                (*(*node).next).prev = (*node).prev;
            }
        }

        #[inline]
        fn attach(&mut self, node: *mut Node<K, V>) {
            unsafe {
                (*node).next = (*self.head).next;
                (*node).prev = self.head;
                (*self.head).next = node;
                (*(*node).next).prev = node;
            }
        }

        // Caller must check `!self.head.is_null()`
        unsafe fn drop_entries(&mut self) {
            let mut cur = (*self.head).next;
            while cur != self.head {
                let next = (*cur).next;
                Box::from_raw(cur);
                cur = next;
            }
        }

        fn clear_free_list(&mut self) {
            unsafe {
                let mut free = self.free;
                while !free.is_null() {
                    let next_free = (*free).next;
                    drop_empty_node(free);
                    free = next_free;
                }
                self.free = ptr::null_mut();
            }
        }

        fn ensure_guard_node(&mut self) {
            if self.head.is_null() {
                // allocate the guard node if not present
                unsafe {
                    let node_layout = std::alloc::Layout::new::<Node<K, V>>();
                    self.head = std::alloc::alloc(node_layout) as *mut Node<K, V>;
                    (*self.head).next = self.head;
                    (*self.head).prev = self.head;
                }
            }
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher> LinkedHashMap<K, V, S> {
        fn with_map(map: HashMap<KeyRef<K>, *mut Node<K, V>, S>) -> Self {
            LinkedHashMap {
                map,
                head: ptr::null_mut(),
                free: ptr::null_mut(),
            }
        }
        /// Creates an empty linked hash map with the given initial hash builder.
        pub fn with_hasher(hash_builder: S) -> Self {
            Self::with_map(HashMap::with_hasher(hash_builder))
        }
        /// Creates an empty linked hash map with the given initial capacity and hash builder.
        pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> Self {
            Self::with_map(HashMap::with_capacity_and_hasher(capacity, hash_builder))
        }
        /// Reserves capacity for at least `additional` more elements to be inserted into the map.
        pub fn reserve(&mut self, additional: usize) {
            self.map.reserve(additional);
        }
        /// Shrinks the capacity of the map as much as possible.
        pub fn shrink_to_fit(&mut self) {
            self.map.shrink_to_fit();
            self.clear_free_list();
        }
        /// Gets the given key's corresponding entry in the map for in-place manipulation.
        pub fn entry(&mut self, k: K) -> Entry<K, V, S> {
            let self_ptr: *mut Self = self;

            if let Some(entry) = self.map.get_mut(&KeyRef { k: &k }) {
                return Entry::Occupied(OccupiedEntry {
                    entry: *entry,
                    map: self_ptr,
                    marker: marker::PhantomData,
                });
            }

            Entry::Vacant(VacantEntry { key: k, map: self })
        }
        /// Returns an iterator visiting all entries in insertion order.
        pub fn entries(&mut self) -> Entries<K, V, S> {
            let head = if !self.head.is_null() {
                unsafe { (*self.head).prev }
            } else {
                ptr::null_mut()
            };
            Entries {
                map: self,
                head,
                remaining: self.len(),
                marker: marker::PhantomData,
            }
        }
        /// Inserts a key-value pair into the map. If the key already existed, the old value is returned.
        pub fn insert(&mut self, k: K, v: V) -> Option<V> {
            self.ensure_guard_node();

            let (node, old_val) = match self.map.get(&KeyRef { k: &k }) {
                Some(node) => {
                    let old_val = unsafe { ptr::replace(&mut (**node).value, v) };
                    (*node, Some(old_val))
                }
                None => {
                    let node = if self.free.is_null() {
                        Box::into_raw(Box::new(Node::new(k, v)))
                    } else {
                        // use a recycled box
                        unsafe {
                            let free = self.free;
                            self.free = (*free).next;
                            ptr::write(free, Node::new(k, v));
                            free
                        }
                    };
                    (node, None)
                }
            };
            match old_val {
                Some(_) => {
                    // Existing node, just update LRU position
                    self.detach(node);
                    self.attach(node);
                }
                None => {
                    let keyref = unsafe { &(*node).key };
                    self.map.insert(KeyRef { k: keyref }, node);
                    self.attach(node);
                }
            }
            old_val
        }
        /// Checks if the map contains the given key.
        pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            self.map.contains_key(Qey::from_ref(k))
        }
        /// Returns the value corresponding to the key in the map.
        pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            self.map
                .get(Qey::from_ref(k))
                .map(|e| unsafe { &(**e).value })
        }
        /// Returns the mutable reference corresponding to the key in the map.
        pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            self.map
                .get(Qey::from_ref(k))
                .map(|e| unsafe { &mut (**e).value })
        }
        /// Returns the value corresponding to the key in the map.
        pub fn get_refresh<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            let (value, node_ptr_opt) = match self.map.get(Qey::from_ref(k)) {
                None => (None, None),
                Some(node) => (Some(unsafe { &mut (**node).value }), Some(*node)),
            };
            if let Some(node_ptr) = node_ptr_opt {
                self.detach(node_ptr);
                self.attach(node_ptr);
            }
            value
        }
        /// Removes and returns the value corresponding to the key from the map.
        pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            let removed = self.map.remove(Qey::from_ref(k));
            removed.map(|node| {
                self.detach(node);
                unsafe {
                    // add to free list
                    (*node).next = self.free;
                    self.free = node;
                    // drop the key and return the value
                    drop(ptr::read(&(*node).key));
                    ptr::read(&(*node).value)
                }
            })
        }
        /// Returns the maximum number of key-value pairs the map can hold without reallocating.
        pub fn capacity(&self) -> usize {
            self.map.capacity()
        }
        /// Removes the first entry.
        #[inline]
        pub fn pop_front(&mut self) -> Option<(K, V)> {
            if self.is_empty() {
                return None;
            }
            let lru = unsafe { (*self.head).prev };
            self.detach(lru);
            self.map
                .remove(&KeyRef {
                    k: unsafe { &(*lru).key },
                })
                .map(|e| {
                    let e = *unsafe { Box::from_raw(e) };
                    (e.key, e.value)
                })
        }
        /// Gets the first entry.
        #[inline]
        pub fn front(&self) -> Option<(&K, &V)> {
            if self.is_empty() {
                return None;
            }
            let lru = unsafe { (*self.head).prev };
            self.map
                .get(&KeyRef {
                    k: unsafe { &(*lru).key },
                })
                .map(|e| unsafe { (&(**e).key, &(**e).value) })
        }
        /// Removes the last entry.
        #[inline]
        pub fn pop_back(&mut self) -> Option<(K, V)> {
            if self.is_empty() {
                return None;
            }
            let mru = unsafe { (*self.head).next };
            self.detach(mru);
            self.map
                .remove(&KeyRef {
                    k: unsafe { &(*mru).key },
                })
                .map(|e| {
                    let e = *unsafe { Box::from_raw(e) };
                    (e.key, e.value)
                })
        }
        /// Gets the last entry.
        #[inline]
        pub fn back(&self) -> Option<(&K, &V)> {
            if self.is_empty() {
                return None;
            }
            let mru = unsafe { (*self.head).next };
            self.map
                .get(&KeyRef {
                    k: unsafe { &(*mru).key },
                })
                .map(|e| unsafe { (&(**e).key, &(**e).value) })
        }
        /// Returns the number of key-value pairs in the map.
        pub fn len(&self) -> usize {
            self.map.len()
        }
        /// Returns whether the map is currently empty.
        pub fn is_empty(&self) -> bool {
            self.len() == 0
        }
        /// Returns a reference to the map's hasher.
        pub fn hasher(&self) -> &S {
            self.map.hasher()
        }
        /// Clears the map of all key-value pairs.
        pub fn clear(&mut self) {
            self.map.clear();
            // update the guard node if present
            if !self.head.is_null() {
                unsafe {
                    self.drop_entries();
                    (*self.head).prev = self.head;
                    (*self.head).next = self.head;
                }
            }
        }
        /// Returns a double-ended iterator visiting all key-value pairs in order of insertion.
        pub fn iter(&self) -> Iter<K, V> {
            let head = if self.head.is_null() {
                ptr::null_mut()
            } else {
                unsafe { (*self.head).prev }
            };
            Iter {
                head,
                tail: self.head,
                remaining: self.len(),
                marker: marker::PhantomData,
            }
        }
        /// Returns a double-ended iterator visiting all key-value pairs in order of insertion.
        pub fn iter_mut(&mut self) -> IterMut<K, V> {
            let head = if self.head.is_null() {
                ptr::null_mut()
            } else {
                unsafe { (*self.head).prev }
            };
            IterMut {
                head,
                tail: self.head,
                remaining: self.len(),
                marker: marker::PhantomData,
            }
        }
        /// Clears the map, returning all key-value pairs as an iterator.
        pub fn drain(&mut self) -> Drain<K, V> {
            let len = self.len();
            // Map should be empty now, regardless of current state
            self.map.clear();
            let (head, tail) = if len != 0 {
                // This is basically the same as IntoIter's impl, but we don't
                // deallocate/drop anything. Instead we make the sentinel head node
                // point at itself (same state you get from removing the last element from a map),
                // and then append the entire list to the free list. At this point all the entries
                // have essentially been fed into mem::forget. The Drain iterator will then iterate
                // over those nodes in the freelist (using  `len` to know where to stop) and `read`
                // the values out of the nodes, "unforgetting" them.
                //
                // This design results in no observable consequences for mem::forgetting the
                // drain iterator, because the drain iterator has no responsibility to "fix up"
                // things during iteration/destruction. That said, you will effectively mem::forget
                // any elements that weren't yielded yet.
                unsafe {
                    debug_assert!(!self.head.is_null());
                    debug_assert!(!(*self.head).prev.is_null());
                    debug_assert!((*self.head).prev != self.head);
                    let head = (*self.head).prev;
                    let tail = (*self.head).next;
                    (*self.head).prev = self.head;
                    (*self.head).next = self.head;
                    (*head).next = self.free;
                    (*tail).prev = ptr::null_mut();
                    self.free = tail;
                    (head, tail)
                }
            } else {
                (ptr::null_mut(), ptr::null_mut())
            };

            Drain {
                head,
                tail,
                remaining: len,
                marker: marker::PhantomData,
            }
        }
        /// Returns a double-ended iterator visiting all key in order of insertion.
        pub fn keys(&self) -> Keys<K, V> {
            Keys { inner: self.iter() }
        }
        /// Returns a double-ended iterator visiting all values in order of insertion.
        pub fn values(&self) -> Values<K, V> {
            Values { inner: self.iter() }
        }
    }

    impl<'a, K, V, S, Q: ?Sized> Index<&'a Q> for LinkedHashMap<K, V, S> where
        K: Hash + Eq + Borrow<Q>,
        S: BuildHasher,
        Q: Eq + Hash,
    {
        type Output = V;

        fn index(&self, index: &'a Q) -> &V {
            self.get(index).expect("no entry found for key")
        }
    }

    impl<'a, K, V, S, Q: ?Sized> IndexMut<&'a Q> for LinkedHashMap<K, V, S> where
        K: Hash + Eq + Borrow<Q>,
        S: BuildHasher,
        Q: Eq + Hash,
    {
        fn index_mut(&mut self, index: &'a Q) -> &mut V {
            self.get_mut(index).expect("no entry found for key")
        }
    }

    impl<K: Hash + Eq + Clone, V: Clone, S: BuildHasher + Clone> Clone for LinkedHashMap<K, V, S> {
        fn clone(&self) -> Self {
            let mut map = Self::with_hasher(self.map.hasher().clone());
            map.extend(self.iter().map(|(k, v)| (k.clone(), v.clone())));
            map
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher + Default> Default for LinkedHashMap<K, V, S> {
        fn default() -> Self {
            Self::with_hasher(S::default())
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher> Extend<(K, V)> for LinkedHashMap<K, V, S> {
        fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, iter: I) {
            for (k, v) in iter {
                self.insert(k, v);
            }
        }
    }

    impl<'a, K, V, S> Extend<(&'a K, &'a V)> for LinkedHashMap<K, V, S> where
        K: 'a + Hash + Eq + Copy,
        V: 'a + Copy,
        S: BuildHasher,
    {
        fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {
            for (&k, &v) in iter {
                self.insert(k, v);
            }
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher + Default> iter::FromIterator<(K, V)>
        for LinkedHashMap<K, V, S>
    {
        fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {
            let iter = iter.into_iter();
            let mut map = Self::with_capacity_and_hasher(iter.size_hint().0, S::default());
            map.extend(iter);
            map
        }
    }

    impl<A: fmt::Debug + Hash + Eq, B: fmt::Debug, S: BuildHasher> fmt::Debug
        for LinkedHashMap<A, B, S>
    {
        /// Returns a string that lists the key-value pairs in insertion order.
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_map().entries(self).finish()
        }
    }

    impl<K: Hash + Eq, V: PartialEq, S: BuildHasher> PartialEq for LinkedHashMap<K, V, S> {
        fn eq(&self, other: &Self) -> bool {
            self.len() == other.len() && self.iter().eq(other)
        }
    }

    impl<K: Hash + Eq, V: Eq, S: BuildHasher> Eq for LinkedHashMap<K, V, S> {}

    impl<K: Hash + Eq + PartialOrd, V: PartialOrd, S: BuildHasher> PartialOrd
        for LinkedHashMap<K, V, S>
    {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            self.iter().partial_cmp(other)
        }

        fn lt(&self, other: &Self) -> bool {
            self.iter().lt(other)
        }

        fn le(&self, other: &Self) -> bool {
            self.iter().le(other)
        }

        fn ge(&self, other: &Self) -> bool {
            self.iter().ge(other)
        }

        fn gt(&self, other: &Self) -> bool {
            self.iter().gt(other)
        }
    }

    impl<K: Hash + Eq + Ord, V: Ord, S: BuildHasher> Ord for LinkedHashMap<K, V, S> {
        fn cmp(&self, other: &Self) -> Ordering {
            self.iter().cmp(other)
        }
    }

    impl<K: Hash + Eq, V: Hash, S: BuildHasher> Hash for LinkedHashMap<K, V, S> {
        fn hash<H: Hasher>(&self, h: &mut H) {
            for e in self.iter() {
                e.hash(h);
            }
        }
    }

    unsafe impl<K: Send, V: Send, S: Send> Send for LinkedHashMap<K, V, S> {}

    unsafe impl<K: Sync, V: Sync, S: Sync> Sync for LinkedHashMap<K, V, S> {}

    impl<K, V, S> Drop for LinkedHashMap<K, V, S> {
        fn drop(&mut self) {
            if !self.head.is_null() {
                unsafe {
                    self.drop_entries();
                    drop_empty_node(self.head);
                }
            }
            self.clear_free_list();
        }
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s entries, with immutable references to the
    /// values.
    pub struct Iter<'a, K: 'a, V: 'a> {
        head: *const Node<K, V>,
        tail: *const Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(&'a K, &'a V)>,
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s entries, with mutable references to the
    /// values.
    pub struct IterMut<'a, K: 'a, V: 'a> {
        head: *mut Node<K, V>,
        tail: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(&'a K, &'a mut V)>,
    }
    /// A consuming insertion-order iterator over a `LinkedHashMap`'s entries.
    pub struct IntoIter<K, V> {
        head: *mut Node<K, V>,
        tail: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(K, V)>,
    }
    /// A draining insertion-order iterator over a `LinkedHashMap`'s entries.
    pub struct Drain<'a, K, V> {
        head: *mut Node<K, V>,
        tail: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<&'a mut (K, V)>,
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s entries represented as
    /// an `OccupiedEntry`.
    pub struct Entries<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> {
        map: *mut LinkedHashMap<K, V, S>,
        head: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(&'a K, &'a mut V, &'a S)>,
    }

    unsafe impl<'a, K, V> Send for Iter<'a, K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<'a, K, V> Send for IterMut<'a, K, V> where
    K: Send,
    V: Send,
    {
    }

    unsafe impl<'a, K, V> Send for Drain<'a, K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<K, V> Send for IntoIter<K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<'a, K, V, S> Send for Entries<'a, K, V, S> where
        K: Send,
        V: Send,
        S: Send,
    {
    }

    unsafe impl<'a, K, V> Sync for Iter<'a, K, V> where
        K: Sync,
        V: Sync,
    {
    }

    unsafe impl<'a, K, V> Sync for IterMut<'a, K, V> where
        K: Sync,
        V: Sync,
    {
    }

    unsafe impl<'a, K, V> Sync for Drain<'a, K, V> where
        K: Sync,
        V: Sync,
    {
    }
    unsafe impl<K, V> Sync for IntoIter<K, V> where
        K: Sync,
        V: Sync,
    {
    }

    unsafe impl<'a, K, V, S> Sync for Entries<'a, K, V, S> where
        K: Sync,
        V: Sync,
        S: Sync,
    {
    }

    impl<'a, K, V> Clone for Iter<'a, K, V> 
    {
        fn clone(&self) -> Self {
            Iter { ..*self }
        }
    }

    impl<K, V> Clone for IntoIter<K, V> where
        K: Clone,
        V: Clone,
    {
        fn clone(&self) -> Self {
            if self.remaining == 0 {
                return IntoIter { ..*self };
            }

            fn clone_node<K, V>(e: *mut Node<K, V>) -> *mut Node<K, V>
            where
                K: Clone,
                V: Clone,
            {
                Box::into_raw(Box::new(Node::new(unsafe { (*e).key.clone() }, unsafe {
                    (*e).value.clone()
                })))
            }

            let mut cur = self.head;
            let head = clone_node(cur);
            let mut tail = head;
            for _ in 1..self.remaining {
                unsafe {
                    (*tail).prev = clone_node((*cur).prev);
                    (*(*tail).prev).next = tail;
                    tail = (*tail).prev;
                    cur = (*cur).prev;
                }
            }

            IntoIter {
                head,
                tail,
                remaining: self.remaining,
                marker: marker::PhantomData,
            }
        }
    }

    impl<'a, K, V> Iterator for Iter<'a, K, V> 
    {
        type Item = (&'a K, &'a V);

        fn next(&mut self) -> Option<(&'a K, &'a V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    let r = Some((&(*self.head).key, &(*self.head).value));
                    self.head = (*self.head).prev;
                    r
                }
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> Iterator for IterMut<'a, K, V> 
    {
        type Item = (&'a K, &'a mut V);

        fn next(&mut self) -> Option<(&'a K, &'a mut V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    let r = Some((&(*self.head).key, &mut (*self.head).value));
                    self.head = (*self.head).prev;
                    r
                }
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<K, V> Iterator for IntoIter<K, V> 
    {
        type Item = (K, V);

        fn next(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let prev = (*self.head).prev;
                let e = *Box::from_raw(self.head);
                self.head = prev;
                Some((e.key, e.value))
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> Iterator for Drain<'a, K, V> 
    {
        type Item = (K, V);

        fn next(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let prev = (*self.head).prev;
                // Read the values out, the node is in the free-list already so these will
                // be treated as uninit memory.
                let k = addr_of_mut!((*self.head).key).read();
                let v = addr_of_mut!((*self.head).value).read();
                self.head = prev;
                Some((k, v))
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Drain<'a, K, V> 
    {
        fn next_back(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let next = (*self.tail).next;
                // Read the values out, the node is in the free-list already so these will
                // be treated as uninit memory.
                let k = addr_of_mut!((*self.tail).key).read();
                let v = addr_of_mut!((*self.tail).value).read();
                self.tail = next;
                Some((k, v))
            }
        }
    }

    impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<'a, K, V, S: BuildHasher> Iterator for Entries<'a, K, V, S> 
    {
        type Item = OccupiedEntry<'a, K, V, S>;

        fn next(&mut self) -> Option<OccupiedEntry<'a, K, V, S>> {
            if self.remaining == 0 {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    let r = Some(OccupiedEntry {
                        map: self.map,
                        entry: self.head,
                        marker: marker::PhantomData,
                    });

                    self.head = (*self.head).prev;
                    r
                }
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> 
    {
        fn next_back(&mut self) -> Option<(&'a K, &'a V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    self.tail = (*self.tail).next;
                    Some((&(*self.tail).key, &(*self.tail).value))
                }
            }
        }
    }

    impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> 
    {
        fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    self.tail = (*self.tail).next;
                    Some((&(*self.tail).key, &mut (*self.tail).value))
                }
            }
        }
    }

    impl<K, V> DoubleEndedIterator for IntoIter<K, V> 
    {
        fn next_back(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let next = (*self.tail).next;
                let e = *Box::from_raw(self.tail);
                self.tail = next;
                Some((e.key, e.value))
            }
        }
    }

    impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<K, V> ExactSizeIterator for IntoIter<K, V> 
    {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<K, V> Drop for IntoIter<K, V> 
    {
        fn drop(&mut self) {
            for _ in 0..self.remaining {
                unsafe {
                    let next = (*self.tail).next;
                    Box::from_raw(self.tail);
                    self.tail = next;
                }
            }
        }
    }

    impl<'a, K, V> Drop for Drain<'a, K, V> 
    {
        fn drop(&mut self) {
            for _ in self {}
        }
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s keys.
    pub struct Keys<'a, K: 'a, V: 'a> 
    {
        inner: Iter<'a, K, V>,
    }

    impl<'a, K, V> Clone for Keys<'a, K, V> 
    {
        fn clone(&self) -> Self {
            Keys {
                inner: self.inner.clone(),
            }
        }
    }

    impl<'a, K, V> Iterator for Keys<'a, K, V> 
    {
        type Item = &'a K;

        #[inline]
        fn next(&mut self) -> Option<&'a K> {
            self.inner.next().map(|e| e.0)
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> 
    {
        #[inline]
        fn next_back(&mut self) -> Option<&'a K> {
            self.inner.next_back().map(|e| e.0)
        }
    }

    impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.inner.len()
        }
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s values.
    pub struct Values<'a, K: 'a, V: 'a> 
    {
        inner: Iter<'a, K, V>,
    }

    impl<'a, K, V> Clone for Values<'a, K, V> 
    {
        fn clone(&self) -> Self {
            Values {
                inner: self.inner.clone(),
            }
        }
    }

    impl<'a, K, V> Iterator for Values<'a, K, V> 
    {
        type Item = &'a V;

        #[inline]
        fn next(&mut self) -> Option<&'a V> {
            self.inner.next().map(|e| e.1)
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> 
    {
        #[inline]
        fn next_back(&mut self) -> Option<&'a V> {
            self.inner.next_back().map(|e| e.1)
        }
    }

    impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.inner.len()
        }
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> IntoIterator for &'a LinkedHashMap<K, V, S> 
    {
        type Item = (&'a K, &'a V);
        type IntoIter = Iter<'a, K, V>;
        fn into_iter(self) -> Iter<'a, K, V> {
            self.iter()
        }
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> IntoIterator for &'a mut LinkedHashMap<K, V, S> 
    {
        type Item = (&'a K, &'a mut V);
        type IntoIter = IterMut<'a, K, V>;
        fn into_iter(self) -> IterMut<'a, K, V> {
            self.iter_mut()
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher> IntoIterator for LinkedHashMap<K, V, S> 
    {
        type Item = (K, V);
        type IntoIter = IntoIter<K, V>;
        fn into_iter(mut self) -> IntoIter<K, V> {
            let (head, tail) = if !self.head.is_null() {
                unsafe { ((*self.head).prev, (*self.head).next) }
            } else {
                (ptr::null_mut(), ptr::null_mut())
            };
            let len = self.len();

            if !self.head.is_null() {
                unsafe { drop_empty_node(self.head) }
            }
            self.clear_free_list();
            // drop the HashMap but not the LinkedHashMap
            unsafe {
                ptr::drop_in_place(&mut self.map);
            }
            mem::forget(self);

            IntoIter {
                head,
                tail,
                remaining: len,
                marker: marker::PhantomData,
            }
        }
    }
    /// A view into a single location in a map, which may be vacant or occupied.
    pub enum Entry<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> 
    {
        /// An occupied Entry.
        Occupied(OccupiedEntry<'a, K, V, S>),
        /// A vacant Entry.
        Vacant(VacantEntry<'a, K, V, S>),
    }
    /// A view into a single occupied location in a `LinkedHashMap`.
    pub struct OccupiedEntry<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> 
    {
        entry: *mut Node<K, V>,
        map: *mut LinkedHashMap<K, V, S>,
        marker: marker::PhantomData<&'a K>,
    }
    /// A view into a single empty location in a `LinkedHashMap`.
    pub struct VacantEntry<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> 
    {
        key: K,
        map: &'a mut LinkedHashMap<K, V, S>,
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> Entry<'a, K, V, S> 
    {
        /// Returns the entry key.
        pub fn key(&self) -> &K {
            match *self {
                Entry::Occupied(ref e) => e.key(),
                Entry::Vacant(ref e) => e.key(),
            }
        }
        /// Ensures a value is in the entry by inserting the default if empty, and returns a mutable reference to the value in the entry.
        pub fn or_insert(self, default: V) -> &'a mut V {
            match self {
                Entry::Occupied(entry) => entry.into_mut(),
                Entry::Vacant(entry) => entry.insert(default),
            }
        }
        /// Ensures a value is in the entry by inserting the result of the default function if empty,
        /// and returns a mutable reference to the value in the entry.
        pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
            match self {
                Entry::Occupied(entry) => entry.into_mut(),
                Entry::Vacant(entry) => entry.insert(default()),
            }
        }
        /// Provides in-place mutable access to an occupied entry before any potential inserts into the map.
        pub fn and_modify<F>(self, f: F) -> Self
        where
            F: FnOnce(&mut V),
        {
            match self {
                Entry::Occupied(mut entry) => {
                    f(entry.get_mut());
                    Entry::Occupied(entry)
                }
                Entry::Vacant(entry) => Entry::Vacant(entry),
            }
        }
        /// Ensures a value is in the entry by inserting the default value if empty, and returns a mutable reference to the value in the entry.
        pub fn or_default(self) -> &'a mut V
        where
            V: Default,
        {
            match self {
                Entry::Occupied(entry) => entry.into_mut(),
                Entry::Vacant(entry) => entry.insert(V::default()),
            }
        }
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> OccupiedEntry<'a, K, V, S> 
    {
        /// Gets a reference to the entry key.
        pub fn key(&self) -> &K {
            unsafe { &(*self.entry).key }
        }
        /// Gets a reference to the value in the entry.
        pub fn get(&self) -> &V {
            unsafe { &(*self.entry).value }
        }
        /// Gets a mutable reference to the value in the entry.
        pub fn get_mut(&mut self) -> &mut V {
            unsafe { &mut (*self.entry).value }
        }
        /// Converts the OccupiedEntry into a mutable reference to the value in the entry
        /// with a lifetime bound to the map itself
        pub fn into_mut(self) -> &'a mut V {
            unsafe { &mut (*self.entry).value }
        }
        /// Sets the value of the entry, and returns the entry's old value
        pub fn insert(&mut self, value: V) -> V {
            unsafe {
                (*self.map).ensure_guard_node();

                let old_val = mem::replace(&mut (*self.entry).value, value);
                let node_ptr: *mut Node<K, V> = self.entry;

                // Existing node, just update LRU position
                (*self.map).detach(node_ptr);
                (*self.map).attach(node_ptr);

                old_val
            }
        }
        /// Takes the value out of the entry, and returns it
        pub fn remove(self) -> V {
            unsafe { (*self.map).remove(&(*self.entry).key) }.unwrap()
        }
    }

    impl<'a, K: 'a + Hash + Eq, V: 'a, S: BuildHasher> VacantEntry<'a, K, V, S> 
    {
        /// Gets a reference to the entry key.
        pub fn key(&self) -> &K {
            &self.key
        }
        /// Sets the value of the entry with the VacantEntry's key, and returns a mutable reference to it
        pub fn insert(self, value: V) -> &'a mut V {
            self.map.ensure_guard_node();

            let node = if self.map.free.is_null() {
                Box::into_raw(Box::new(Node::new(self.key, value)))
            } else {
                // use a recycled box
                unsafe {
                    let free = self.map.free;
                    self.map.free = (*free).next;
                    ptr::write(free, Node::new(self.key, value));
                    free
                }
            };

            let keyref = unsafe { &(*node).key };

            self.map.attach(node);

            let ret = self.map.map.entry(KeyRef { k: keyref }).or_insert(node);
            unsafe { &mut (**ret).value }
        }
    }
}

pub mod marker
{
    pub use std::marker::{ * };
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod num
{
    pub use std::num::{ * };
}

pub mod ops
{
    pub use std::ops::{ * };
}

pub mod os
{
    pub mod raw
    {
        //! Compatibility module for C platform-specific types. Use [`core::ffi`] instead.
        pub use std::os::raw::{ * };
    }

    pub mod uefi
    {
        use ::
        {
            *,
        };

        pub mod env
        {
            //! UEFI-specific extensions to the primitives in `std::env` module
            use ::
            {
                ffi::{ c_void },
                ptr::{ NonNull },
                sync::atomic::{ Atomic, AtomicBool, AtomicPtr, Ordering },
                *,
            };
            static SYSTEM_TABLE: Atomic<*mut c_void> = AtomicPtr::new( ::ptr::null_mut() );
            static IMAGE_HANDLE: Atomic<*mut c_void> = AtomicPtr::new( ::ptr::null_mut() );
            static BOOT_SERVICES_FLAG: Atomic<bool> = AtomicBool::new(false);

            /// Initializes the global System Table and Image Handle pointers.
            pub(crate) unsafe fn init_globals(handle: NonNull<c_void>, system_table: NonNull<c_void>) {
                IMAGE_HANDLE
                    .compare_exchange(
                        ::ptr::null_mut(),
                        handle.as_ptr(),
                        Ordering::Release,
                        Ordering::Acquire,
                    )
                    .unwrap();
                SYSTEM_TABLE
                    .compare_exchange(
                        ::ptr::null_mut(),
                        system_table.as_ptr(),
                        Ordering::Release,
                        Ordering::Acquire,
                    )
                    .unwrap();
                BOOT_SERVICES_FLAG.store(true, Ordering::Release)
            }

            /// Gets the SystemTable Pointer.
            pub fn system_table() -> NonNull<c_void> {
                try_system_table().unwrap()
            }

            /// Gets the ImageHandle Pointer.
            pub fn image_handle() -> NonNull<c_void> {
                try_image_handle().unwrap()
            }

            /// Gets the BootServices Pointer.
            pub fn boot_services() -> Option<NonNull<c_void>> {
                if BOOT_SERVICES_FLAG.load(Ordering::Acquire) {
                    let system_table: NonNull<r_efi::efi::SystemTable> = try_system_table()?.cast();
                    let boot_services = unsafe { (*system_table.as_ptr()).boot_services };
                    NonNull::new(boot_services).map(|x| x.cast())
                } else {
                    None
                }
            }

            /// Gets the SystemTable Pointer.
            pub(crate) fn try_system_table() -> Option<NonNull<c_void>> {
                NonNull::new(SYSTEM_TABLE.load(Ordering::Acquire))
            }

            /// Gets the SystemHandle Pointer.
            pub(crate) fn try_image_handle() -> Option<NonNull<c_void>> {
                NonNull::new(IMAGE_HANDLE.load(Ordering::Acquire))
            }

            pub(crate) fn disable_boot_services() {
                BOOT_SERVICES_FLAG.store(false, Ordering::Release)
            }
        }
    }

    pub mod unix
    {
        use ::
        {
            *,
        };
    }
    
    pub mod unsupported
    {
        use ::
        {
            *,
        };
    }
    
    pub mod windows
    {
        use ::
        {
            *,
        };
    }
    #[cfg(target_os = "uefi")] pub use self::uefi::{ * };
    #[cfg( unix )] pub use self::unix::{ * };
    #[cfg( windows )] pub use self::windows::{ * };

}

pub mod parsers
{
    use ::
    {
        *,
    };

    pub mod parser_line
    {
        /*
        WHITESPACE = _{ " " | "\t" }

        KW_IF = _{ "if " }
        KW_FI = _{ "fi" ~ (NEWLINE | EOI) }
        KW_FOR = _{ "for " }
        KW_ELSE = { "else" ~ NEWLINE }
        KW_ELSEIF = _{ "else if " }
        KW_WHILE = _{ "while " }
        KW_DONE = _{ "done" ~ (NEWLINE | EOI) }
        KW_LIST = _{ KW_IF | KW_FOR | KW_ELSEIF | KW_ELSE | KW_FI | KW_WHILE | KW_DONE }

        DUMMY_DO = _{ ";" ~ "do" ~ NEWLINE }
        DUMMY_THEN = _{ ";" ~ "then" ~ NEWLINE }

        TEST = {(!(NEWLINE|DUMMY_THEN|DUMMY_DO) ~ ANY)+}

        CMD_END = _{ !KW_LIST ~ (!NEWLINE ~ ANY)+ ~ EOI}
        CMD_NORMAL = _{ !KW_LIST ~ (!NEWLINE ~ ANY)* ~ NEWLINE}
        CMD = { CMD_NORMAL | CMD_END }

        IF_HEAD = { KW_IF ~ TEST ~ (DUMMY_THEN|NEWLINE) }
        EXP_BODY = { (CMD | EXP_IF | EXP_WHILE | EXP_FOR)+ }
        IF_ELSEIF_HEAD = { KW_ELSEIF ~ TEST ~ (DUMMY_THEN|NEWLINE) }
        IF_IF_BR = { IF_HEAD ~ EXP_BODY }
        IF_ELSEIF_BR = { IF_ELSEIF_HEAD ~ EXP_BODY }
        IF_ELSE_BR = { KW_ELSE ~ EXP_BODY }

        EXP_IF = {
            (SOI)? ~
            IF_IF_BR ~
            IF_ELSEIF_BR* ~
            IF_ELSE_BR? ~
            KW_FI
        }

        FOR_VAR = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
        FOR_INIT = { FOR_VAR ~ "in" ~ TEST ~ (DUMMY_DO|NEWLINE) }
        FOR_HEAD = { KW_FOR ~ FOR_INIT }

        EXP_FOR = {
            (SOI)? ~
            FOR_HEAD ~
                EXP_BODY ~
            KW_DONE
        }

        WHILE_HEAD = { KW_WHILE ~ TEST ~ (DUMMY_DO|NEWLINE) }

        EXP_WHILE = {
            (SOI)? ~
            WHILE_HEAD ~
                EXP_BODY ~
            KW_DONE
        }

        EXP = { (EXP_IF | EXP_FOR | EXP_WHILE | CMD)* }
        */
        use ::
        {
            *,
        };
        use regex::Regex;

        use crate::libs;
        use crate::tools;
        use crate::types::{LineInfo, Redirection, Tokens};

        pub fn line_to_plain_tokens(line: &str) -> Vec<String> {
            let mut result = Vec::new();
            let linfo = parse_line(line);
            for (_, r) in linfo.tokens {
                result.push(r.clone());
            }
            result
        }

        pub fn tokens_to_args(tokens: &Tokens) -> Vec<String> {
            let mut result = Vec::new();
            for s in tokens {
                result.push(s.1.clone());
            }
            result
        }

        pub fn tokens_to_line(tokens: &Tokens) -> String {
            let mut result = String::new();
            for t in tokens {
                if t.0.is_empty() {
                    result.push_str(&t.1);
                } else {
                    let s = tools::wrap_sep_string(&t.0, &t.1);
                    result.push_str(&s);
                }
                result.push(' ');
            }
            if result.ends_with(' ') {
                let len = result.len();
                result.truncate(len - 1);
            }
            result
        }
        /// Parse command line for multiple commands. Examples:
        /// >>> line_to_cmds("echo foo && echo bar; echo end");
        /// vec!["echo foo", "&&", "echo bar", ";", "echo end"]
        /// >>> line_to_cmds("man awk | grep version");
        /// vec!["man awk | grep version"]
        pub fn line_to_cmds(line: &str) -> Vec<String> {
            // Special characters: http://tldp.org/LDP/abs/html/special-chars.html
            let mut result = Vec::new();
            let mut sep = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let len = line.chars().count();
            for (i, c) in line.chars().enumerate() {
                if has_backslash {
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if c == '\\' && sep != "'" {
                    has_backslash = true;
                    continue;
                }

                if c == '#' {
                    if sep.is_empty() {
                        break;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '\'' || c == '"' || c == '`' {
                    if sep.is_empty() {
                        sep.push(c);
                        token.push(c);
                        continue;
                    } else if sep == c.to_string() {
                        token.push(c);
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '&' || c == '|' {
                    // needs watch ahead here
                    if sep.is_empty() {
                        if i + 1 == len {
                            // for bg commands, e.g. `ls &`
                            token.push(c);
                            continue;
                        } else {
                            let c_next = match line.chars().nth(i + 1) {
                                Some(x) => x,
                                None => {
                                    println!("chars nth error - should never happen");
                                    continue;
                                }
                            };

                            if c_next != c {
                                token.push(c);
                                continue;
                            }
                        }
                    }

                    if sep.is_empty() {
                        sep.push(c);
                        continue;
                    } else if c.to_string() == sep {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        token = String::new();
                        result.push(format!("{}{}", sep, sep));
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == ';' {
                    if sep.is_empty() {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        result.push(String::from(";"));
                        token = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                token.push(c);
            }
            if !token.is_empty() {
                result.push(token.trim().to_string());
            }
            result
        }
        /// parse command line to tokens
        /// >>> parse_line("echo 'hi yoo' | grep \"hi\"");
        /// LineInfo {
        ///    tokens: vec![
        ///        ("", "echo"),
        ///        ("'", "hi yoo"),
        ///        ("", "|"),
        ///        ("", "grep"),
        ///        ("\"", "hi"),
        ///    ],
        ///    is_complete: true
        /// }
        // #[allow(clippy::cyclomatic_complexity)]
        pub fn parse_line(line: &str) -> LineInfo {
            // FIXME: let rewrite this parse part and make it a separated lib
            let mut result = Vec::new();
            if tools::is_arithmetic(line) {
                for x in line.split(' ') {
                    result.push((String::from(""), x.to_string()));
                }
                return LineInfo::new(result);
            }

            let mut sep = String::new();
            // `sep_second` is for commands like this:
            //    export DIR=`brew --prefix openssl`/include
            // it only could have non-empty value when sep is empty.
            let mut sep_second = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let mut met_parenthesis = false;
            let mut new_round = true;
            let mut skip_next = false;
            let mut has_dollar = false;
            let mut parens_left_ignored = false;

            // for cmds like: `ll foo\>bar end` -> `ll 'foo>bar' end`
            let mut sep_made = String::new();

            // using semi_ok makes quite dirty here
            // it is mainly for path completion like:
            // $ ls "foo b<TAB>
            // # then got `"foo bar"/`, then hit tab again:
            // $ ls "foo bar"/<TAB>
            // # should got:
            // $ ls "foo bar/the-single-file.txt"
            // also using semi_ok makes the following command works as expected:
            // $ touch "foo"/bar.txt  # create bar.txt under ./foo directory
            let mut semi_ok = false;
            let count_chars = line.chars().count();
            for (i, c) in line.chars().enumerate() {
                if skip_next {
                    skip_next = false;
                    continue;
                }

                if has_backslash && sep.is_empty() && (c == '>' || c == '<') {
                    sep_made = String::from("'");
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash && sep == "\"" && c != '\"' {
                    // constant with bash: "\"" --> "; "\a" --> \a
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash {
                    if new_round && sep.is_empty() && (c == '|' || c == '$') && token.is_empty() {
                        sep = String::from("\\");
                        token = format!("{}", c);
                    } else {
                        token.push(c);
                    }
                    new_round = false;
                    has_backslash = false;
                    continue;
                }

                if c == '$' {
                    has_dollar = true;
                }

                // for cases like: echo $(foo bar)
                if c == '(' && sep.is_empty() {
                    if !has_dollar && token.is_empty() {
                        // temp solution for cmd like `(ls)`, `(ls -lh)`
                        parens_left_ignored = true;
                        continue;
                    }
                    met_parenthesis = true;
                }
                if c == ')' {
                    if parens_left_ignored && !has_dollar {
                        // temp solution for cmd like `(ls)`, `(ls -lh)`
                        if i == count_chars - 1 ||
                                (i + 1 < count_chars &&
                                line.chars().nth(i + 1).unwrap() == ' ') {
                            continue;
                        }
                    }
                    if sep.is_empty() {
                        met_parenthesis = false;
                    }
                }

                if c == '\\' {
                    if sep == "'" || !sep_second.is_empty() {
                        token.push(c)
                    } else {
                        has_backslash = true;
                    }
                    continue;
                }

                if new_round {
                    if c == ' ' {
                        continue;
                    } else if c == '"' || c == '\'' || c == '`' {
                        sep = c.to_string();
                        new_round = false;
                        continue;
                    }

                    sep = String::new();

                    if c == '#' {
                        // handle inline comments
                        break;
                    }

                    if c == '|' {
                        if i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == '|' {
                            result.push((String::from(""), "||".to_string()));
                            skip_next = true;
                        } else {
                            result.push((String::from(""), "|".to_string()));
                        }
                        new_round = true;
                        continue;
                    }

                    token.push(c);
                    new_round = false;
                    continue;
                }

                if c == '|' && !has_backslash {
                    if semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((sep.to_string(), token));
                        }
                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    } else if !met_parenthesis && sep_second.is_empty() && sep.is_empty() {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((String::from(""), token));
                        }
                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        continue;
                    }
                }

                if c == ' ' {
                    if semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((sep.to_string(), token));
                        }
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }

                    if has_backslash {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if met_parenthesis {
                        token.push(c);
                        continue;
                    }

                    if sep == "\\" {
                        result.push((String::from("\\"), token));
                        token = String::new();
                        new_round = true;
                        continue;
                    }

                    if sep.is_empty() {
                        if sep_second.is_empty() {
                            if sep.is_empty() && !sep_made.is_empty() {
                                result.push((sep_made.clone(), token));
                                sep_made = String::new();
                            } else {
                                result.push((String::from(""), token));
                            }
                            token = String::new();
                            new_round = true;
                            continue;
                        } else {
                            token.push(c);
                            continue;
                        }
                    } else {
                        token.push(c);
                        continue;
                    }
                }

                if c == '\'' || c == '"' || c == '`' {
                    if has_backslash {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if sep != c.to_string() && semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((sep.to_string(), token));
                        }
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        // do not use continue here!
                    }

                    if sep != c.to_string() && met_parenthesis {
                        token.push(c);
                        continue;
                    }
                    if sep.is_empty() && !sep_second.is_empty() && sep_second != c.to_string() {
                        token.push(c);
                        continue;
                    }

                    if sep.is_empty() {
                        let is_an_env = libs::re::re_contains(&token, r"^[a-zA-Z0-9_]+=.*$");
                        if !is_an_env && (c == '\'' || c == '"') {
                            sep = c.to_string();
                            continue;
                        }

                        token.push(c);
                        if sep_second.is_empty() {
                            sep_second = c.to_string();
                        } else if sep_second == c.to_string() {
                            sep_second = String::new();
                        }
                        continue;
                    } else if sep == c.to_string() {
                        semi_ok = true;
                        continue;
                    } else {
                        token.push(c);
                    }
                } else {
                    if has_backslash {
                        has_backslash = false;
                        if sep == "\"" || sep == "'" {
                            token.push('\\');
                        }
                    }
                    token.push(c);
                }
            }
            if !token.is_empty() || semi_ok {
                if sep.is_empty() && !sep_made.is_empty() {
                    result.push((sep_made.clone(), token));
                } else {
                    result.push((sep.clone(), token));
                }
            }

            let mut is_line_complete = true;
            if !result.is_empty() {
                let token_last = result[result.len() - 1].clone();
                if token_last.0.is_empty() && token_last.1 == "|" {
                    is_line_complete = false;
                }
            }

            if !sep.is_empty() {
                is_line_complete = semi_ok;
            }
            if has_backslash {
                is_line_complete = false;
            }

            LineInfo { tokens: result, is_complete: is_line_complete }
        }

        pub fn tokens_to_redirections(tokens: &Tokens) -> Result<(Tokens, Vec<Redirection>), String> {
            let mut tokens_new = Vec::new();
            let mut redirects = Vec::new();
            let mut to_be_continued = false;
            let mut to_be_continued_s1 = String::new();
            let mut to_be_continued_s2 = String::new();

            for token in tokens {
                let sep = &token.0;
                if !sep.is_empty() && !to_be_continued {
                    tokens_new.push(token.clone());
                    continue;
                }
                let word = &token.1;

                if to_be_continued {
                    if sep.is_empty() && word.starts_with('&') {
                        return Err(String::from("bad redirection syntax near &"));
                    }

                    let s3 = word.to_string();
                    if libs::re::re_contains(&to_be_continued_s1, r"^\d+$") {
                        if to_be_continued_s1 != "1" && to_be_continued_s1 != "2" {
                            return Err(String::from("Bad file descriptor #3"));
                        }
                        let s1 = to_be_continued_s1.clone();
                        let s2 = to_be_continued_s2.clone();
                        redirects.push((s1, s2, s3));
                    } else {
                        if !to_be_continued_s1.is_empty() {
                            tokens_new.push((sep.clone(), to_be_continued_s1.to_string()));
                        }
                        redirects.push(("1".to_string(), to_be_continued_s2.clone(), s3));
                    }

                    to_be_continued = false;
                    continue;
                }

                let ptn1 = r"^([^>]*)(>>?)([^>]+)$";
                let ptn2 = r"^([^>]*)(>>?)$";
                if !libs::re::re_contains(word, r">") {
                    tokens_new.push(token.clone());
                } else if libs::re::re_contains(word, ptn1) {
                    let re;
                    if let Ok(x) = Regex::new(ptn1) {
                        re = x;
                    } else {
                        return Err(String::from("Failed to build Regex"));
                    }

                    if let Some(caps) = re.captures(word) {
                        let s1 = caps.get(1).unwrap().as_str();
                        let s2 = caps.get(2).unwrap().as_str();
                        let s3 = caps.get(3).unwrap().as_str();
                        if s3.starts_with('&') && s3 != "&1" && s3 != "&2" {
                            return Err(String::from("Bad file descriptor #1"));
                        }

                        if libs::re::re_contains(s1, r"^\d+$") {
                            if s1 != "1" && s1 != "2" {
                                return Err(String::from("Bad file descriptor #2"));
                            }
                            redirects.push((s1.to_string(), s2.to_string(), s3.to_string()));
                        } else {
                            if !s1.is_empty() {
                                tokens_new.push((sep.clone(), s1.to_string()));
                            }
                            redirects.push((String::from("1"), s2.to_string(), s3.to_string()));
                        }
                    }
                } else if libs::re::re_contains(word, ptn2) {
                    let re;
                    if let Ok(x) = Regex::new(ptn2) {
                        re = x;
                    } else {
                        return Err(String::from("Failed to build Regex"));
                    }

                    if let Some(caps) = re.captures(word) {
                        let s1 = caps.get(1).unwrap().as_str();
                        let s2 = caps.get(2).unwrap().as_str();

                        to_be_continued = true;
                        to_be_continued_s1 = s1.to_string();
                        to_be_continued_s2 = s2.to_string();
                    }
                }
            }

            if to_be_continued {
                return Err(String::from("redirection syntax error"));
            }

            Ok((tokens_new, redirects))
        }

        pub fn unquote(text: &str) -> String {
            let mut new_str = String::from(text);
            for &c in ['"', '\''].iter() {
                if text.starts_with(c) && text.ends_with(c) {
                    new_str.remove(0);
                    new_str.pop();
                    break;
                }
            }
            new_str
        }
    }

    pub mod locust
    {
        use ::
        {
            *,
        };
        use pest::Parser;
        use pest::iterators::Pairs;
        use pest::error::Error;

        #[derive(Parser)]
        #[grammar = "parsers/grammar.pest"]
        struct Locust;

        pub fn parse_lines(lines: &str) -> Result<Pairs<crate::parsers::locust::Rule>, Error<crate::parsers::locust::Rule>> {
            Locust::parse(Rule::EXP, lines)
        }
    }
}

pub mod pest
{
    //! # pest. The Elegant Parser
    use ::
    {
        *,
    };

    pub mod derive
    {
        use ::
        {
            *,
        };
    }

    pub use crate::parser::Parser;
    pub use crate::parser_state::{
        set_call_limit, set_error_detail, state, Atomicity, Lookahead, MatchDir, ParseResult,
        ParserState,
    };
    pub use crate::position::Position;
    pub use crate::span::{merge_spans, Lines, LinesSpan, Span};
    pub use crate::stack::Stack;
    pub use crate::token::Token;
    use core::fmt::Debug;
    use core::hash::Hash;

    pub mod error
    {
        //! Types for different kinds of parsing failures.
        use ::
        {
            *,
        };
        

        

        use crate::parser_state::{ParseAttempts, ParsingToken, RulesCallStack};
        use alloc::borrow::Cow;
        use alloc::borrow::ToOwned;
        use alloc::boxed::Box;
        use alloc::collections::{BTreeMap, BTreeSet};
        use alloc::format;
        use alloc::string::String;
        use alloc::string::ToString;
        use alloc::vec;
        use alloc::vec::Vec;
        use core::cmp;
        use core::fmt;
        use core::mem;

        use crate::position::Position;
        use crate::span::Span;
        use crate::RuleType;

        /// Parse-related error type.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        #[cfg_attr(feature = "std", derive(thiserror::Error))]
        pub struct Error<R> {
            /// Variant of the error
            pub variant: ErrorVariant<R>,
            /// Location within the input string
            pub location: InputLocation,
            /// Line/column within the input string
            pub line_col: LineColLocation,
            path: Option<String>,
            line: String,
            continued_line: Option<String>,
            parse_attempts: Option<ParseAttempts<R>>,
        }
        /// Different kinds of parsing errors.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        #[cfg_attr(feature = "std", derive(thiserror::Error))]
        pub enum ErrorVariant<R> {
            /// Generated parsing error with expected and unexpected `Rule`s
            ParsingError {
                /// Positive attempts
                positives: Vec<R>,
                /// Negative attempts
                negatives: Vec<R>,
            },
            /// Custom error with a message
            CustomError {
                /// Short explanation
                message: String,
            },
        }
        /// Where an `Error` has occurred.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub enum InputLocation {
            /// `Error` was created by `Error::new_from_pos`
            Pos(usize),
            /// `Error` was created by `Error::new_from_span`
            Span((usize, usize)),
        }
        /// Line/column where an `Error` has occurred.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub enum LineColLocation {
            /// Line/column pair if `Error` was created by `Error::new_from_pos`
            Pos((usize, usize)),
            /// Line/column pairs if `Error` was created by `Error::new_from_span`
            Span((usize, usize), (usize, usize)),
        }

        impl From<Position<'_>> for LineColLocation {
            fn from(value: Position<'_>) -> Self {
                Self::Pos(value.line_col())
            }
        }

        impl From<Span<'_>> for LineColLocation {
            fn from(value: Span<'_>) -> Self {
                let (start, end) = value.split();
                Self::Span(start.line_col(), end.line_col())
            }
        }
        /// Function mapping rule to its helper message defined by user.
        pub type RuleToMessageFn<R> = Box<dyn Fn(&R) -> Option<String>>;
        /// Function mapping string element to bool denoting whether it's a whitespace defined by user.
        pub type IsWhitespaceFn = Box<dyn Fn(String) -> bool>;

        impl ParsingToken {
            pub fn is_whitespace(&self, is_whitespace: &IsWhitespaceFn) -> bool {
                match self {
                    ParsingToken::Sensitive { token } => is_whitespace(token.clone()),
                    ParsingToken::Insensitive { token } => is_whitespace(token.clone()),
                    ParsingToken::Range { .. } => false,
                    ParsingToken::BuiltInRule => false,
                }
            }
        }

        impl<R: RuleType> ParseAttempts<R> {
            /// Helper formatting function to get message informing about tokens we've
            /// (un)expected to see.
            /// Used as a part of `parse_attempts_error`.
            fn tokens_helper_messages(
                &self,
                is_whitespace_fn: &IsWhitespaceFn,
                spacing: &str,
            ) -> Vec<String> {
                let mut helper_messages = Vec::new();
                let tokens_header_pairs = vec![
                    (self.expected_tokens(), "expected"),
                    (self.unexpected_tokens(), "unexpected"),
                ];

                for (tokens, header) in &tokens_header_pairs {
                    if tokens.is_empty() {
                        continue;
                    }

                    let mut helper_tokens_message = format!("{spacing}note: {header} ");
                    helper_tokens_message.push_str(if tokens.len() == 1 {
                        "token: "
                    } else {
                        "one of tokens: "
                    });

                    let expected_tokens_set: BTreeSet<String> = tokens
                        .iter()
                        .map(|token| {
                            if token.is_whitespace(is_whitespace_fn) {
                                String::from("WHITESPACE")
                            } else {
                                format!("`{}`", token)
                            }
                        })
                        .collect();

                    helper_tokens_message.push_str(
                        &expected_tokens_set
                            .iter()
                            .cloned()
                            .collect::<Vec<String>>()
                            .join(", "),
                    );
                    helper_messages.push(helper_tokens_message);
                }

                helper_messages
            }
        }

        impl<R: RuleType> Error<R> {
            /// Creates `Error` from `ErrorVariant` and `Position`.
            pub fn new_from_pos(variant: ErrorVariant<R>, pos: Position<'_>) -> Error<R> {
                let visualize_ws = pos.match_char('\n') || pos.match_char('\r');
                let line_of = pos.line_of();
                let line = if visualize_ws {
                    visualize_whitespace(line_of)
                } else {
                    line_of.replace(&['\r', '\n'][..], "")
                };
                Error {
                    variant,
                    location: InputLocation::Pos(pos.pos()),
                    path: None,
                    line,
                    continued_line: None,
                    line_col: LineColLocation::Pos(pos.line_col()),
                    parse_attempts: None,
                }
            }
            /// Wrapper function to track `parse_attempts` as a result of `state` function call in `parser_state.rs`.
            pub fn new_from_pos_with_parsing_attempts(
                variant: ErrorVariant<R>,
                pos: Position<'_>,
                parse_attempts: ParseAttempts<R>,
            ) -> Error<R> {
                let mut error = Self::new_from_pos(variant, pos);
                error.parse_attempts = Some(parse_attempts);
                error
            }
            /// Creates `Error` from `ErrorVariant` and `Span`.
            pub fn new_from_span(variant: ErrorVariant<R>, span: Span<'_>) -> Error<R> {
                let end = span.end_pos();
                let mut end_line_col = end.line_col();
                // end position is after a \n, so we want to point to the visual lf symbol
                if end_line_col.1 == 1 {
                    let mut visual_end = end;
                    visual_end.skip_back(1);
                    let lc = visual_end.line_col();
                    end_line_col = (lc.0, lc.1 + 1);
                };

                let mut line_iter = span.lines();
                let sl = line_iter.next().unwrap_or("");
                let mut chars = span.as_str().chars();
                let visualize_ws = matches!(chars.next(), Some('\n') | Some('\r'))
                    || matches!(chars.last(), Some('\n') | Some('\r'));
                let start_line = if visualize_ws {
                    visualize_whitespace(sl)
                } else {
                    sl.to_owned().replace(&['\r', '\n'][..], "")
                };
                let ll = line_iter.last();
                let continued_line = if visualize_ws {
                    ll.map(str::to_owned)
                } else {
                    ll.map(visualize_whitespace)
                };

                Error {
                    variant,
                    location: InputLocation::Span((span.start(), end.pos())),
                    path: None,
                    line: start_line,
                    continued_line,
                    line_col: LineColLocation::Span(span.start_pos().line_col(), end_line_col),
                    parse_attempts: None,
                }
            }
            /// Returns `Error` variant with `path` which is shown when formatted with `Display`.
            pub fn with_path(mut self, path: &str) -> Error<R> {
                self.path = Some(path.to_owned());

                self
            }
            /// Returns the path set using [`Error::with_path()`].
            pub fn path(&self) -> Option<&str> {
                self.path.as_deref()
            }
            /// Returns the line that the error is on.
            pub fn line(&self) -> &str {
                self.line.as_str()
            }
            /// Renames all `Rule`s if this is a [`ParsingError`]. It does nothing when called on a [`CustomError`].
            pub fn renamed_rules<F>(mut self, f: F) -> Error<R>
            where
                F: FnMut(&R) -> String,
            {
                let variant = match self.variant {
                    ErrorVariant::ParsingError {
                        positives,
                        negatives,
                    } => {
                        let message = Error::parsing_error_message(&positives, &negatives, f);
                        ErrorVariant::CustomError { message }
                    }
                    variant => variant,
                };

                self.variant = variant;

                self
            }
            /// Get detailed information about errored rules sequence.
            pub fn parse_attempts(&self) -> Option<ParseAttempts<R>> {
                self.parse_attempts.clone()
            }
            /// Get error message based on parsing attempts.
            pub fn parse_attempts_error(
                &self,
                input: &str,
                rule_to_message: &RuleToMessageFn<R>,
                is_whitespace: &IsWhitespaceFn,
            ) -> Option<Error<R>> {
                let attempts = if let Some(ref parse_attempts) = self.parse_attempts {
                    parse_attempts.clone()
                } else {
                    return None;
                };

                let spacing = self.spacing() + "   ";
                let error_position = attempts.max_position;
                let message = {
                    let mut help_lines: Vec<String> = Vec::new();
                    help_lines.push(String::from("error: parsing error occurred."));

                    // Note: at least one of `(un)expected_tokens` must not be empty.
                    for tokens_helper_message in attempts.tokens_helper_messages(is_whitespace, &spacing) {
                        help_lines.push(tokens_helper_message);
                    }

                    let call_stacks = attempts.call_stacks();
                    // Group call stacks by their parents so that we can print common header and
                    // several sub helper messages.
                    let mut call_stacks_parents_groups: BTreeMap<Option<R>, Vec<RulesCallStack<R>>> =
                        BTreeMap::new();
                    for call_stack in call_stacks {
                        call_stacks_parents_groups
                            .entry(call_stack.parent)
                            .or_default()
                            .push(call_stack);
                    }

                    for (group_parent, group) in call_stacks_parents_groups {
                        if let Some(parent_rule) = group_parent {
                            let mut contains_meaningful_info = false;
                            help_lines.push(format!(
                                "{spacing}help: {}",
                                if let Some(message) = rule_to_message(&parent_rule) {
                                    contains_meaningful_info = true;
                                    message
                                } else {
                                    String::from("[Unknown parent rule]")
                                }
                            ));
                            for call_stack in group {
                                if let Some(r) = call_stack.deepest.get_rule() {
                                    if let Some(message) = rule_to_message(r) {
                                        contains_meaningful_info = true;
                                        help_lines.push(format!("{spacing}      - {message}"));
                                    }
                                }
                            }
                            if !contains_meaningful_info {
                                // Have to remove useless line for unknown parent rule.
                                help_lines.pop();
                            }
                        } else {
                            for call_stack in group {
                                // Note that `deepest` rule may be `None`. E.g. in case it corresponds
                                // to WHITESPACE expected token which has no parent rule (on the top level
                                // parsing).
                                if let Some(r) = call_stack.deepest.get_rule() {
                                    let helper_message = rule_to_message(r);
                                    if let Some(helper_message) = helper_message {
                                        help_lines.push(format!("{spacing}help: {helper_message}"));
                                    }
                                }
                            }
                        }
                    }

                    help_lines.join("\n")
                };
                let error = Error::new_from_pos(
                    ErrorVariant::CustomError { message },
                    Position::new_internal(input, error_position),
                );
                Some(error)
            }

            fn start(&self) -> (usize, usize) {
                match self.line_col {
                    LineColLocation::Pos(line_col) => line_col,
                    LineColLocation::Span(start_line_col, _) => start_line_col,
                }
            }

            fn spacing(&self) -> String {
                let line = match self.line_col {
                    LineColLocation::Pos((line, _)) => line,
                    LineColLocation::Span((start_line, _), (end_line, _)) => cmp::max(start_line, end_line),
                };

                let line_str_len = format!("{}", line).len();

                let mut spacing = String::new();
                for _ in 0..line_str_len {
                    spacing.push(' ');
                }

                spacing
            }

            fn underline(&self) -> String {
                let mut underline = String::new();

                let mut start = self.start().1;
                let end = match self.line_col {
                    LineColLocation::Span(_, (_, mut end)) => {
                        let inverted_cols = start > end;
                        if inverted_cols {
                            mem::swap(&mut start, &mut end);
                            start -= 1;
                            end += 1;
                        }

                        Some(end)
                    }
                    _ => None,
                };
                let offset = start - 1;
                let line_chars = self.line.chars();

                for c in line_chars.take(offset) {
                    match c {
                        '\t' => underline.push('\t'),
                        _ => underline.push(' '),
                    }
                }

                if let Some(end) = end {
                    underline.push('^');
                    if end - start > 1 {
                        for _ in 2..(end - start) {
                            underline.push('-');
                        }
                        underline.push('^');
                    }
                } else {
                    underline.push_str("^---")
                }

                underline
            }

            fn message(&self) -> String {
                self.variant.message().to_string()
            }

            fn parsing_error_message<F>(positives: &[R], negatives: &[R], mut f: F) -> String
            where
                F: FnMut(&R) -> String,
            {
                match (negatives.is_empty(), positives.is_empty()) {
                    (false, false) => format!(
                        "unexpected {}; expected {}",
                        Error::enumerate(negatives, &mut f),
                        Error::enumerate(positives, &mut f)
                    ),
                    (false, true) => format!("unexpected {}", Error::enumerate(negatives, &mut f)),
                    (true, false) => format!("expected {}", Error::enumerate(positives, &mut f)),
                    (true, true) => "unknown parsing error".to_owned(),
                }
            }

            fn enumerate<F>(rules: &[R], f: &mut F) -> String
            where
                F: FnMut(&R) -> String,
            {
                match rules.len() {
                    1 => f(&rules[0]),
                    2 => format!("{} or {}", f(&rules[0]), f(&rules[1])),
                    l => {
                        let non_separated = f(&rules[l - 1]);
                        let separated = rules
                            .iter()
                            .take(l - 1)
                            .map(f)
                            .collect::<Vec<_>>()
                            .join(", ");
                        format!("{}, or {}", separated, non_separated)
                    }
                }
            }

            pub fn format(&self) -> String {
                let spacing = self.spacing();
                let path = self
                    .path
                    .as_ref()
                    .map(|path| format!("{}:", path))
                    .unwrap_or_default();

                let pair = (self.line_col.clone(), &self.continued_line);
                if let (LineColLocation::Span(_, end), Some(ref continued_line)) = pair {
                    let has_line_gap = end.0 - self.start().0 > 1;
                    if has_line_gap {
                        format!(
                            "{s    }--> {p}{ls}:{c}\n\
                            {s    } |\n\
                            {ls:w$} | {line}\n\
                            {s    } | ...\n\
                            {le:w$} | {continued_line}\n\
                            {s    } | {underline}\n\
                            {s    } |\n\
                            {s    } = {message}",
                            s = spacing,
                            w = spacing.len(),
                            p = path,
                            ls = self.start().0,
                            le = end.0,
                            c = self.start().1,
                            line = self.line,
                            continued_line = continued_line,
                            underline = self.underline(),
                            message = self.message()
                        )
                    } else {
                        format!(
                            "{s    }--> {p}{ls}:{c}\n\
                            {s    } |\n\
                            {ls:w$} | {line}\n\
                            {le:w$} | {continued_line}\n\
                            {s    } | {underline}\n\
                            {s    } |\n\
                            {s    } = {message}",
                            s = spacing,
                            w = spacing.len(),
                            p = path,
                            ls = self.start().0,
                            le = end.0,
                            c = self.start().1,
                            line = self.line,
                            continued_line = continued_line,
                            underline = self.underline(),
                            message = self.message()
                        )
                    }
                } else {
                    format!(
                        "{s}--> {p}{l}:{c}\n\
                        {s} |\n\
                        {l} | {line}\n\
                        {s} | {underline}\n\
                        {s} |\n\
                        {s} = {message}",
                        s = spacing,
                        p = path,
                        l = self.start().0,
                        c = self.start().1,
                        line = self.line,
                        underline = self.underline(),
                        message = self.message()
                    )
                }
            }

            #[cfg(feature = "miette-error")]
            /// Turns an error into a [miette](crates.io/miette) Diagnostic.
            pub fn into_miette(self) -> impl ::miette::Diagnostic {
                miette_adapter::MietteAdapter(self)
            }
        }

        impl<R: RuleType> ErrorVariant<R> {
            ///
            /// Returns the error message for [`ErrorVariant`].
            pub fn message(&self) -> Cow<'_, str> {
                match self {
                    ErrorVariant::ParsingError {
                        ref positives,
                        ref negatives,
                    } => Cow::Owned(Error::parsing_error_message(positives, negatives, |r| {
                        format!("{:?}", r)
                    })),
                    ErrorVariant::CustomError { ref message } => Cow::Borrowed(message),
                }
            }
        }

        impl<R: RuleType> fmt::Display for Error<R> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, "{}", self.format())
            }
        }

        impl<R: RuleType> fmt::Display for ErrorVariant<R> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    ErrorVariant::ParsingError { .. } => write!(f, "parsing error: {}", self.message()),
                    ErrorVariant::CustomError { .. } => write!(f, "{}", self.message()),
                }
            }
        }

        fn visualize_whitespace(input: &str) -> String {
            input.to_owned().replace('\r', "␍").replace('\n', "␊")
        }

        #[cfg(feature = "miette-error")]
        mod miette_adapter {
            use alloc::string::ToString;
            use std::boxed::Box;

            use crate::error::LineColLocation;

            use super::{Error, RuleType};

            use miette::{Diagnostic, LabeledSpan, SourceCode};

            #[derive(thiserror::Error, Debug)]
            #[error("Failure to parse at {:?}", self.0.line_col)]
            pub struct MietteAdapter<R: RuleType>(pub Error<R>);

            impl<R: RuleType> Diagnostic for MietteAdapter<R> {
                fn source_code(&self) -> Option<&dyn SourceCode> {
                    Some(&self.0.line)
                }

                fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan>>> {
                    let message = self.0.variant.message().to_string();

                    let (offset, length) = match self.0.line_col {
                        LineColLocation::Pos((_, c)) => (c - 1, 1),
                        LineColLocation::Span((_, start_c), (_, end_c)) => {
                            (start_c - 1, end_c - start_c + 1)
                        }
                    };

                    let span = LabeledSpan::new(Some(message), offset, length);

                    Some(Box::new(std::iter::once(span)))
                }

                fn help<'a>(&'a self) -> Option<Box<dyn core::fmt::Display + 'a>> {
                    Some(Box::new(self.0.message()))
                }
            }
        }
    }

    pub mod iterators
    {
        //! Types and iterators for parser output.
        use ::
        {
            *,
        };
        

        

        pub mod flat_pairs
        {
            use ::
            {
                *,
            };
            // pest. The Elegant Parser
            // Copyright (c) 2018 Dragoș Tiselice
            //
            // Licensed under the Apache License, Version 2.0
            // <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
            // license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. All files in the project carrying such notice may not be copied,
            // modified, or distributed except according to those terms.

            use alloc::rc::Rc;
            use alloc::vec::Vec;
            use core::fmt;

            use super::line_index::LineIndex;
            use super::pair::{self, Pair};
            use super::queueable_token::QueueableToken;
            use super::tokens::{self, Tokens};
            use crate::RuleType;

            /// An iterator over [`Pair`]s. It is created by [`Pairs::flatten`].
            ///
            /// [`Pair`]: struct.Pair.html
            /// [`Pairs::flatten`]: struct.Pairs.html#method.flatten
            pub struct FlatPairs<'i, R> {
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                start: usize,
                end: usize,
                line_index: Rc<LineIndex>,
            }

            pub fn new<'i, R: RuleType>(
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                line_index: Rc<LineIndex>,
                start: usize,
                end: usize,
            ) -> FlatPairs<'i, R> {
                FlatPairs {
                    queue,
                    input,
                    line_index,
                    start,
                    end,
                }
            }

            impl<'i, R: RuleType> FlatPairs<'i, R> {
                /// Returns the `Tokens` for these pairs.
                #[inline]
                pub fn tokens(self) -> Tokens<'i, R> {
                    tokens::new(self.queue, self.input, self.start, self.end)
                }

                fn next_start(&mut self) {
                    self.start += 1;

                    while self.start < self.end && !self.is_start(self.start) {
                        self.start += 1;
                    }
                }

                fn next_start_from_end(&mut self) {
                    self.end -= 1;

                    while self.end >= self.start && !self.is_start(self.end) {
                        self.end -= 1;
                    }
                }

                fn is_start(&self, index: usize) -> bool {
                    match self.queue[index] {
                        QueueableToken::Start { .. } => true,
                        QueueableToken::End { .. } => false,
                    }
                }
            }

            impl<'i, R: RuleType> ExactSizeIterator for FlatPairs<'i, R> {
                fn len(&self) -> usize {
                    // Tokens len is exactly twice as flatten pairs len
                    (self.end - self.start) >> 1
                }
            }

            impl<'i, R: RuleType> Iterator for FlatPairs<'i, R> {
                type Item = Pair<'i, R>;

                fn next(&mut self) -> Option<Self::Item> {
                    if self.start >= self.end {
                        return None;
                    }

                    let pair = pair::new(
                        Rc::clone(&self.queue),
                        self.input,
                        Rc::clone(&self.line_index),
                        self.start,
                    );
                    self.next_start();

                    Some(pair)
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    let len = <Self as ExactSizeIterator>::len(self);
                    (len, Some(len))
                }
            }

            impl<'i, R: RuleType> DoubleEndedIterator for FlatPairs<'i, R> {
                fn next_back(&mut self) -> Option<Self::Item> {
                    if self.end <= self.start {
                        return None;
                    }

                    self.next_start_from_end();

                    let pair = pair::new(
                        Rc::clone(&self.queue),
                        self.input,
                        Rc::clone(&self.line_index),
                        self.end,
                    );

                    Some(pair)
                }
            }

            impl<'i, R: RuleType> fmt::Debug for FlatPairs<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_struct("FlatPairs")
                        .field("pairs", &self.clone().collect::<Vec<_>>())
                        .finish()
                }
            }

            impl<'i, R: Clone> Clone for FlatPairs<'i, R> {
                fn clone(&self) -> FlatPairs<'i, R> {
                    FlatPairs {
                        queue: Rc::clone(&self.queue),
                        input: self.input,
                        line_index: Rc::clone(&self.line_index),
                        start: self.start,
                        end: self.end,
                    }
                }
            }
        }

        pub mod line_index
        {
            //! `LineIndex` to make a line_offsets, each item is an byte offset (start from 0) of the beginning of the line.
            use ::
            {
                *,
            };
            
            use alloc::vec::Vec;

            #[derive(Clone)]
            pub struct LineIndex {
                /// Offset (bytes) the the beginning of each line, zero-based
                line_offsets: Vec<usize>,
            }

            impl LineIndex {
                pub fn new(text: &str) -> LineIndex {
                    let mut line_offsets: Vec<usize> = alloc::vec![0];

                    let mut offset = 0;

                    for c in text.chars() {
                        offset += c.len_utf8();
                        if c == '\n' {
                            line_offsets.push(offset);
                        }
                    }

                    LineIndex { line_offsets }
                }
                /// Returns (line, col) of pos.
                ///
                /// The pos is a byte offset, start from 0, e.g. "ab" is 2, "你好" is 6
                pub fn line_col(&self, input: &str, pos: usize) -> (usize, usize) {
                    let line = self.line_offsets.partition_point(|&it| it <= pos) - 1;
                    let first_offset = self.line_offsets[line];

                    // Get line str from original input, then we can get column offset
                    let line_str = &input[first_offset..pos];
                    let col = line_str.chars().count();

                    (line + 1, col + 1)
                }
            }
        }

        pub mod pair
        {
            use ::
            {
                *,
            };
            // pest. The Elegant Parser
            // Copyright (c) 2018 Dragoș Tiselice
            //
            // Licensed under the Apache License, Version 2.0
            // <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
            // license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. All files in the project carrying such notice may not be copied,
            // modified, or distributed except according to those terms.

            use alloc::format;
            use alloc::rc::Rc;
            #[cfg(feature = "pretty-print")]
            use alloc::string::String;
            use alloc::vec::Vec;
            use core::borrow::Borrow;
            use core::fmt;
            use core::hash::{Hash, Hasher};
            use core::ptr;
            use core::str;

            use super::line_index::LineIndex;
            use super::pairs::{self, Pairs};
            use super::queueable_token::QueueableToken;
            use super::tokens::{self, Tokens};
            use crate::span::Span;
            use crate::RuleType;

            /// A matching pair of [`Token`]s and everything between them.
            #[derive(Clone)]
            pub struct Pair<'i, R> {
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                /// Token index into `queue`.
                start: usize,
                line_index: Rc<LineIndex>,
            }

            pub fn new<'i, R: RuleType>(
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                line_index: Rc<LineIndex>,
                start: usize,
            ) -> Pair<'i, R> {
                Pair {
                    queue,
                    input,
                    start,
                    line_index,
                }
            }

            impl<'i, R: RuleType> Pair<'i, R> {
                /// Returns the `Rule` of the `Pair`.
                #[inline]
                pub fn as_rule(&self) -> R {
                    match self.queue[self.pair()] {
                        QueueableToken::End { rule, .. } => rule,
                        _ => unreachable!(),
                    }
                }
                /// Captures a slice from the `&str` defined by the token `Pair`.
                #[inline]
                pub fn as_str(&self) -> &'i str {
                    let start = self.pos(self.start);
                    let end = self.pos(self.pair());

                    // Generated positions always come from Positions and are UTF-8 borders.
                    &self.input[start..end]
                }
                /// Returns the input string of the `Pair`.
                pub fn get_input(&self) -> &'i str {
                    self.input
                }
                /// Returns the `Span` defined by the `Pair`, consuming it.
                #[inline]
                #[deprecated(since = "2.0.0", note = "Please use `as_span` instead")]
                pub fn into_span(self) -> Span<'i> {
                    self.as_span()
                }
                /// Returns the `Span` defined by the `Pair`, **without** consuming it.
                #[inline]
                pub fn as_span(&self) -> Span<'i> {
                    let start = self.pos(self.start);
                    let end = self.pos(self.pair());

                    Span::new_internal(self.input, start, end)
                }
                /// Get current node tag
                #[inline]
                pub fn as_node_tag(&self) -> Option<&str> {
                    match &self.queue[self.pair()] {
                        QueueableToken::End { tag, .. } => tag.as_ref().map(|x| x.borrow()),
                        _ => None,
                    }
                }
                /// Returns the inner `Pairs` between the `Pair`, consuming it.
                #[inline]
                pub fn into_inner(self) -> Pairs<'i, R> {
                    let pair = self.pair();

                    pairs::new(
                        self.queue,
                        self.input,
                        Some(self.line_index),
                        self.start + 1,
                        pair,
                    )
                }
                /// Returns the `Tokens` for the `Pair`.
                #[inline]
                pub fn tokens(self) -> Tokens<'i, R> {
                    let end = self.pair();

                    tokens::new(self.queue, self.input, self.start, end + 1)
                }
                /// Returns the `line`, `col` of this pair start.
                pub fn line_col(&self) -> (usize, usize) {
                    let pos = self.pos(self.start);
                    self.line_index.line_col(self.input, pos)
                }

                fn pair(&self) -> usize {
                    match self.queue[self.start] {
                        QueueableToken::Start {
                            end_token_index, ..
                        } => end_token_index,
                        _ => unreachable!(),
                    }
                }

                fn pos(&self, index: usize) -> usize {
                    match self.queue[index] {
                        QueueableToken::Start { input_pos, .. } | QueueableToken::End { input_pos, .. } => {
                            input_pos
                        }
                    }
                }
            }

            impl<'i, R: RuleType> Pairs<'i, R> {
                /// Create a new `Pairs` iterator containing just the single `Pair`.
                pub fn single(pair: Pair<'i, R>) -> Self {
                    let end = pair.pair();
                    pairs::new(
                        pair.queue,
                        pair.input,
                        Some(pair.line_index),
                        pair.start,
                        end,
                    )
                }
            }

            impl<'i, R: RuleType> fmt::Debug for Pair<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let pair = &mut f.debug_struct("Pair");
                    pair.field("rule", &self.as_rule());
                    // In order not to break compatibility
                    if let Some(s) = self.as_node_tag() {
                        pair.field("node_tag", &s);
                    }
                    pair.field("span", &self.as_span())
                        .field("inner", &self.clone().into_inner().collect::<Vec<_>>())
                        .finish()
                }
            }

            impl<'i, R: RuleType> fmt::Display for Pair<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let rule = self.as_rule();
                    let start = self.pos(self.start);
                    let end = self.pos(self.pair());
                    let mut pairs = self.clone().into_inner().peekable();

                    if pairs.peek().is_none() {
                        write!(f, "{:?}({}, {})", rule, start, end)
                    } else {
                        write!(
                            f,
                            "{:?}({}, {}, [{}])",
                            rule,
                            start,
                            end,
                            pairs
                                .map(|pair| format!("{}", pair))
                                .collect::<Vec<_>>()
                                .join(", ")
                        )
                    }
                }
            }

            impl<'i, R: PartialEq> PartialEq for Pair<'i, R> {
                fn eq(&self, other: &Pair<'i, R>) -> bool {
                    Rc::ptr_eq(&self.queue, &other.queue)
                        && ptr::eq(self.input, other.input)
                        && self.start == other.start
                }
            }

            impl<'i, R: Eq> Eq for Pair<'i, R> {}

            impl<'i, R: Hash> Hash for Pair<'i, R> {
                fn hash<H: Hasher>(&self, state: &mut H) {
                    (&*self.queue as *const Vec<QueueableToken<'i, R>>).hash(state);
                    (self.input as *const str).hash(state);
                    self.start.hash(state);
                }
            }
        }

        pub mod pairs
        {
            use ::
            {
                *,
            };
            // pest. The Elegant Parser
            // Copyright (c) 2018 Dragoș Tiselice
            //
            // Licensed under the Apache License, Version 2.0
            // <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
            // license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. All files in the project carrying such notice may not be copied,
            // modified, or distributed except according to those terms.

            use alloc::format;
            use alloc::rc::Rc;
            use alloc::string::String;
            use alloc::vec::Vec;
            use core::fmt;
            use core::hash::{Hash, Hasher};
            use core::iter::Filter;
            use core::ptr;
            use core::str;

            use super::flat_pairs::{self, FlatPairs};
            use super::line_index::LineIndex;
            use super::pair::{self, Pair};
            use super::queueable_token::QueueableToken;
            use super::tokens::{self, Tokens};
            use crate::RuleType;

            /// An iterator over [`Pair`]s. It is created by [`pest::state`] and [`Pair::into_inner`].
            ///
            /// [`Pair`]: struct.Pair.html
            /// [`pest::state`]: ../fn.state.html
            /// [`Pair::into_inner`]: struct.Pair.html#method.into_inner
            #[derive(Clone)]
            pub struct Pairs<'i, R> {
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                start: usize,
                end: usize,
                pairs_count: usize,
                line_index: Rc<LineIndex>,
            }

            pub fn new<'i, R: RuleType>(
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                line_index: Option<Rc<LineIndex>>,
                start: usize,
                end: usize,
            ) -> Pairs<'i, R> {
                let line_index = match line_index {
                    Some(line_index) => line_index,
                    None => {
                        let last_input_pos = queue
                            .last()
                            .map(|token| match *token {
                                QueueableToken::Start { input_pos, .. }
                                | QueueableToken::End { input_pos, .. } => input_pos,
                            })
                            .unwrap_or(0);

                        Rc::new(LineIndex::new(&input[..last_input_pos]))
                    }
                };

                let mut pairs_count = 0;
                let mut cursor = start;
                while cursor < end {
                    cursor = match queue[cursor] {
                        QueueableToken::Start {
                            end_token_index, ..
                        } => end_token_index,
                        _ => unreachable!(),
                    } + 1;
                    pairs_count += 1;
                }

                Pairs {
                    queue,
                    input,
                    start,
                    end,
                    pairs_count,
                    line_index,
                }
            }

            impl<'i, R: RuleType> Pairs<'i, R> {
                /// Captures a slice from the `&str` defined by the starting position of the first token `Pair`
                /// and the ending position of the last token `Pair` of the `Pairs`.
                #[inline]
                pub fn as_str(&self) -> &'i str {
                    if self.start < self.end {
                        let start = self.pos(self.start);
                        let end = self.pos(self.end - 1);
                        // Generated positions always come from Positions and are UTF-8 borders.
                        &self.input[start..end]
                    } else {
                        ""
                    }
                }
                /// Returns the input string of `Pairs`.
                pub fn get_input(&self) -> &'i str {
                    self.input
                }
                /// Captures inner token `Pair`s and concatenates resulting `&str`s. This does not capture
                /// the input between token `Pair`s.
                #[inline]
                pub fn concat(&self) -> String {
                    self.clone()
                        .fold(String::new(), |string, pair| string + pair.as_str())
                }
                /// Flattens the `Pairs`.
                #[inline]
                pub fn flatten(self) -> FlatPairs<'i, R> {
                    flat_pairs::new(
                        self.queue,
                        self.input,
                        self.line_index,
                        self.start,
                        self.end,
                    )
                }
                /// Finds the first pair that has its node or branch tagged with the provided
                /// label. Searches in the flattened [`Pairs`] iterator.
                #[inline]
                pub fn find_first_tagged(&self, tag: &'i str) -> Option<Pair<'i, R>> {
                    self.clone().find_tagged(tag).next()
                }
                /// Returns the iterator over pairs that have their node or branch tagged
                /// with the provided label. The iterator is built from a flattened [`Pairs`] iterator.
                #[inline]
                pub fn find_tagged(
                    self,
                    tag: &'i str,
                ) -> Filter<FlatPairs<'i, R>, impl FnMut(&Pair<'i, R>) -> bool + '_> {
                    self.flatten()
                        .filter(move |pair: &Pair<'i, R>| matches!(pair.as_node_tag(), Some(nt) if nt == tag))
                }
                /// Returns the `Tokens` for the `Pairs`.
                #[inline]
                pub fn tokens(self) -> Tokens<'i, R> {
                    tokens::new(self.queue, self.input, self.start, self.end)
                }
                /// Peek at the first inner `Pair` without changing the position of this iterator.
                #[inline]
                pub fn peek(&self) -> Option<Pair<'i, R>> {
                    if self.start < self.end {
                        Some(pair::new(
                            Rc::clone(&self.queue),
                            self.input,
                            Rc::clone(&self.line_index),
                            self.start,
                        ))
                    } else {
                        None
                    }
                }

                fn pair(&self) -> usize {
                    match self.queue[self.start] {
                        QueueableToken::Start {
                            end_token_index, ..
                        } => end_token_index,
                        _ => unreachable!(),
                    }
                }

                fn pair_from_end(&self) -> usize {
                    match self.queue[self.end - 1] {
                        QueueableToken::End {
                            start_token_index, ..
                        } => start_token_index,
                        _ => unreachable!(),
                    }
                }

                fn pos(&self, index: usize) -> usize {
                    match self.queue[index] {
                        QueueableToken::Start { input_pos, .. } | QueueableToken::End { input_pos, .. } => {
                            input_pos
                        }
                    }
                }
            }

            impl<'i, R: RuleType> ExactSizeIterator for Pairs<'i, R> {
                #[inline]
                fn len(&self) -> usize {
                    self.pairs_count
                }
            }

            impl<'i, R: RuleType> Iterator for Pairs<'i, R> {
                type Item = Pair<'i, R>;

                fn next(&mut self) -> Option<Self::Item> {
                    let pair = self.peek()?;

                    self.start = self.pair() + 1;
                    self.pairs_count -= 1;
                    Some(pair)
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    let len = <Self as ExactSizeIterator>::len(self);
                    (len, Some(len))
                }
            }

            impl<'i, R: RuleType> DoubleEndedIterator for Pairs<'i, R> {
                fn next_back(&mut self) -> Option<Self::Item> {
                    if self.end <= self.start {
                        return None;
                    }

                    self.end = self.pair_from_end();
                    self.pairs_count -= 1;

                    let pair = pair::new(
                        Rc::clone(&self.queue),
                        self.input,
                        Rc::clone(&self.line_index),
                        self.end,
                    );

                    Some(pair)
                }
            }

            impl<'i, R: RuleType> fmt::Debug for Pairs<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_list().entries(self.clone()).finish()
                }
            }

            impl<'i, R: RuleType> fmt::Display for Pairs<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    write!(
                        f,
                        "[{}]",
                        self.clone()
                            .map(|pair| format!("{}", pair))
                            .collect::<Vec<_>>()
                            .join(", ")
                    )
                }
            }

            impl<'i, R: PartialEq> PartialEq for Pairs<'i, R> {
                fn eq(&self, other: &Pairs<'i, R>) -> bool {
                    Rc::ptr_eq(&self.queue, &other.queue)
                        && ptr::eq(self.input, other.input)
                        && self.start == other.start
                        && self.end == other.end
                }
            }

            impl<'i, R: Eq> Eq for Pairs<'i, R> {}

            impl<'i, R: Hash> Hash for Pairs<'i, R> {
                fn hash<H: Hasher>(&self, state: &mut H) {
                    (&*self.queue as *const Vec<QueueableToken<'i, R>>).hash(state);
                    (self.input as *const str).hash(state);
                    self.start.hash(state);
                    self.end.hash(state);
                }
            }
        }

        pub mod queueable_token
        {
            use ::
            {
                *,
            };

            #[derive(Debug)]
            pub enum QueueableToken<'i, R> {
                Start {
                    /// Queue (as a vec) contains both `Start` token and `End` for the same rule.
                    /// This field is an index of corresponding `End` token in vec.
                    end_token_index: usize,
                    /// Position from which rule was tried to parse (or successfully parsed).
                    input_pos: usize,
                },
                End {
                    /// Queue (as a vec) contains both `Start` token and `End` for the same rule.
                    /// This filed is an index of corresponding `Start` token in vec.
                    start_token_index: usize,
                    rule: R,
                    tag: Option<&'i str>,
                    /// Position at which successfully parsed rule finished (ended).
                    input_pos: usize,
                },
            }
        }

        pub mod tokens
        {
            use ::
            {
                *,
            };
            // pest. The Elegant Parser
            // Copyright (c) 2018 Dragoș Tiselice
            //
            // Licensed under the Apache License, Version 2.0
            // <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
            // license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. All files in the project carrying such notice may not be copied,
            // modified, or distributed except according to those terms.

            use alloc::rc::Rc;
            use alloc::vec::Vec;
            use core::fmt;
            use core::str;

            use super::queueable_token::QueueableToken;
            use crate::position;
            use crate::token::Token;
            use crate::RuleType;

            /// An iterator over [`Token`]s. It is created by [`Pair::tokens`] and [`Pairs::tokens`].
            ///
            /// [`Token`]: ../enum.Token.html
            /// [`Pair::tokens`]: struct.Pair.html#method.tokens
            /// [`Pairs::tokens`]: struct.Pairs.html#method.tokens
            #[derive(Clone)]
            pub struct Tokens<'i, R> {
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                start: usize,
                end: usize,
            }

            pub fn new<'i, R: RuleType>(
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                start: usize,
                end: usize,
            ) -> Tokens<'i, R> {
                if cfg!(debug_assertions) {
                    for tok in queue.iter() {
                        match *tok {
                            QueueableToken::Start { input_pos, .. } | QueueableToken::End { input_pos, .. } => {
                                assert!(
                                    input.get(input_pos..).is_some(),
                                    "💥 INVALID `Tokens` CREATED 💥"
                                )
                            }
                        }
                    }
                }

                Tokens {
                    queue,
                    input,
                    start,
                    end,
                }
            }

            impl<'i, R: RuleType> Tokens<'i, R> {
                fn create_token(&self, index: usize) -> Token<'i, R> {
                    match self.queue[index] {
                        QueueableToken::Start {
                            end_token_index,
                            input_pos,
                        } => {
                            let rule = match self.queue[end_token_index] {
                                QueueableToken::End { rule, .. } => rule,
                                _ => unreachable!(),
                            };

                            Token::Start {
                                rule,
                                pos: position::Position::new_internal(self.input, input_pos),
                            }
                        }
                        QueueableToken::End {
                            rule, input_pos, ..
                        } => Token::End {
                            rule,
                            pos: position::Position::new_internal(self.input, input_pos),
                        },
                    }
                }
            }

            impl<'i, R: RuleType> ExactSizeIterator for Tokens<'i, R> {
                fn len(&self) -> usize {
                    self.end - self.start
                }
            }

            impl<'i, R: RuleType> Iterator for Tokens<'i, R> {
                type Item = Token<'i, R>;

                fn next(&mut self) -> Option<Self::Item> {
                    if self.start >= self.end {
                        return None;
                    }

                    let token = self.create_token(self.start);

                    self.start += 1;

                    Some(token)
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    let len = <Self as ExactSizeIterator>::len(self);
                    (len, Some(len))
                }
            }

            impl<'i, R: RuleType> DoubleEndedIterator for Tokens<'i, R> {
                fn next_back(&mut self) -> Option<Self::Item> {
                    if self.end <= self.start {
                        return None;
                    }

                    let token = self.create_token(self.end - 1);

                    self.end -= 1;

                    Some(token)
                }
            }

            impl<'i, R: RuleType> fmt::Debug for Tokens<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_list().entries(self.clone()).finish()
                }
            }
        }
        
        pub use self::flat_pairs::FlatPairs;
        pub use self::pair::Pair;
        pub use self::pairs::Pairs;
        pub use self::queueable_token::QueueableToken;
        pub use self::tokens::Tokens;
    }

    pub mod macros
    {
        use ::
        {
            *,
        };
        

        #[doc(hidden)]
        #[macro_export]
        macro_rules! consumes_to {
            ( $_rules:ident, $tokens:expr, [] ) => ();
            ( $rules:ident, $tokens:expr, [ $name:ident ( $start:expr, $end:expr ) ] ) => {
                let expected = format!("expected Start {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $start);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::Start { rule, pos } => {
                        assert!(
                            rule == $rules::$name && pos.pos() == $start,
                            "{} but found Start {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        )
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                let expected = format!("expected End {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $end);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::End { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $end,
                            "{} but found End {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };
            };
            ( $rules:ident, $tokens:expr, [ $name:ident ( $start:expr, $end:expr ),
                                            $( $names:ident $calls:tt ),* $(,)* ] ) => {

                let expected = format!("expected Start {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $start);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::Start { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $start,
                            "{} but found Start {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                let expected = format!("expected End {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $end);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::End { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $end,
                            "{} but found End {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                consumes_to!($rules, $tokens, [ $( $names $calls ),* ]);
            };
            ( $rules:ident, $tokens:expr, [ $name:ident ( $start:expr, $end:expr,
                                                        [ $( $names:ident $calls:tt ),* $(,)* ] ) ] ) => {
                let expected = format!("expected Start {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $start);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::Start { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $start,
                            "{} but found Start {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                consumes_to!($rules, $tokens, [ $( $names $calls ),* ]);

                let expected = format!("expected End {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $end);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::End { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $end,
                            "{} but found End {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };
            };
            ( $rules:ident, $tokens:expr, [ $name:ident ( $start:expr, $end:expr,
                                                        [ $( $nested_names:ident $nested_calls:tt ),*
                                                        $(,)* ] ),
                                            $( $names:ident $calls:tt ),* ] ) => {

                let expected = format!("expected Start {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $start);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::Start { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $start,
                            "{} but found Start {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                consumes_to!($rules, $tokens, [ $( $nested_names $nested_calls ),* ]);

                let expected = format!("expected End {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $end);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::End { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $end,
                            "{} but found End {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                consumes_to!($rules, $tokens, [ $( $names $calls ),* ]);
            };
        }
        /// Testing tool that compares produced tokens.
        #[macro_export]
        macro_rules! parses_to {
            ( parser: $parser:ident, input: $string:expr, rule: $rules:tt :: $rule:tt,
            tokens: [ $( $names:ident $calls:tt ),* $(,)* ] ) => {

                #[allow(unused_mut)]
                {
                    use $crate::Parser;

                    let mut tokens = $parser::parse($rules::$rule, $string).unwrap().tokens();

                    consumes_to!($rules, &mut tokens, [ $( $names $calls ),* ]);

                    let rest: Vec<_> = tokens.collect();

                    match rest.len() {
                        0 => (),
                        2 => {
                            let (first, second) = (&rest[0], &rest[1]);

                            match (first, second) {
                                (
                                    &$crate::Token::Start { rule: ref first_rule, .. },
                                    &$crate::Token::End { rule: ref second_rule, .. }
                                ) => {
                                    assert!(
                                        format!("{:?}", first_rule) == "EOI",
                                        "expected end of input, but found {:?}", rest
                                    );
                                    assert!(
                                        format!("{:?}", second_rule) == "EOI",
                                        "expected end of input, but found {:?}", rest
                                    );
                                }
                                _ => panic!("expected end of input, but found {:?}", rest)
                            }
                        }
                        _ => panic!("expected end of input, but found {:?}", rest)
                    };
                }
            };
        }
        /// Testing tool that compares produced errors.
        #[macro_export]
        macro_rules! fails_with {
            ( parser: $parser:ident, input: $string:expr, rule: $rules:tt :: $rule:tt,
            positives: $positives:expr, negatives: $negatives:expr, pos: $pos:expr ) => {
                #[allow(unused_mut)]
                {
                    use $crate::Parser;

                    let error = $parser::parse($rules::$rule, $string).unwrap_err();

                    match error.variant {
                        $crate::error::ErrorVariant::ParsingError {
                            positives,
                            negatives,
                        } => {
                            assert_eq!(positives, $positives, "positives");
                            assert_eq!(negatives, $negatives, "negatives");
                        }
                        _ => unreachable!(),
                    };

                    match error.location {
                        $crate::error::InputLocation::Pos(pos) => assert_eq!(pos, $pos, "pos"),
                        _ => unreachable!(),
                    }
                }
            };
        }
    }

    pub mod parser
    {
        use ::
        {
            *,
        };
        

        use crate::error::Error;
        use crate::iterators::Pairs;
        use crate::RuleType;

        /// A trait with a single method that parses strings.
        pub trait Parser<R: RuleType> {
            /// Parses a `&str` starting from `rule`.
            #[allow(clippy::perf)]
            fn parse(rule: R, input: &str) -> Result<Pairs<'_, R>, Error<R>>;
        }
    }

    pub mod parser_state
    {
        //! The core functionality of parsing grammar.
        use ::
        {
            *,
        };
        

        

        use alloc::borrow::ToOwned;
        use alloc::boxed::Box;
        use alloc::collections::BTreeSet;
        use alloc::rc::Rc;
        use alloc::string::String;
        use alloc::vec;
        use alloc::vec::Vec;
        use core::fmt::{Debug, Display, Formatter};
        use core::num::NonZeroUsize;
        use core::ops::Range;
        use core::sync::atomic::{AtomicBool, AtomicUsize, Ordering};

        use crate::error::{Error, ErrorVariant};
        use crate::iterators::pairs::new;
        use crate::iterators::{pairs, QueueableToken};
        use crate::position::Position;
        use crate::span::Span;
        use crate::stack::Stack;
        use crate::RuleType;

        /// The current lookahead status of a [`ParserState`].
        ///
        /// [`ParserState`]: struct.ParserState.html
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum Lookahead {
            /// The positive predicate, written as an ampersand &,
            /// attempts to match its inner expression.
            /// If the inner expression succeeds, parsing continues,
            /// but at the same position as the predicate —
            /// &foo ~ bar is thus a kind of "AND" statement:
            /// "the input string must match foo AND bar".
            /// If the inner expression fails,
            /// the whole expression fails too.
            Positive,
            /// The negative predicate, written as an exclamation mark !,
            /// attempts to match its inner expression.
            /// If the inner expression fails, the predicate succeeds
            /// and parsing continues at the same position as the predicate.
            /// If the inner expression succeeds, the predicate fails —
            /// !foo ~ bar is thus a kind of "NOT" statement:
            /// "the input string must match bar but NOT foo".
            Negative,
            /// No lookahead (i.e. it will consume input).
            None,
        }
        /// The current atomicity of a [`ParserState`].
        ///
        /// [`ParserState`]: struct.ParserState.html
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum Atomicity {
            /// prevents implicit whitespace: inside an atomic rule,
            /// the tilde ~ means "immediately followed by",
            /// and repetition operators (asterisk * and plus sign +)
            /// have no implicit separation. In addition, all other rules
            /// called from an atomic rule are also treated as atomic.
            /// (interior matching rules are silent)
            Atomic,
            /// The same as atomic, but inner tokens are produced as normal.
            CompoundAtomic,
            /// implicit whitespace is enabled
            NonAtomic,
        }
        /// Type alias to simplify specifying the return value of chained closures.
        pub type ParseResult<S> = Result<S, S>;

        /// Match direction for the stack. Used in `PEEK[a..b]`/`stack_match_peek_slice`.
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum MatchDir {
            /// from the bottom to the top of the stack
            BottomToTop,
            /// from the top to the bottom of the stack
            TopToBottom,
        }

        static CALL_LIMIT: AtomicUsize = AtomicUsize::new(0);

        /// Sets the maximum call limit for the parser state
        /// to prevent stack overflows or excessive execution times
        /// in some grammars.
        /// If set, the calls are tracked as a running total
        /// over all non-terminal rules that can nest closures
        /// (which are passed to transform the parser state).
        ///
        /// # Arguments
        ///
        /// * `limit` - The maximum number of calls. If None,
        ///             the number of calls is unlimited.
        pub fn set_call_limit(limit: Option<NonZeroUsize>) {
            CALL_LIMIT.store(limit.map(|f| f.get()).unwrap_or(0), Ordering::Relaxed);
        }

        static ERROR_DETAIL: AtomicBool = AtomicBool::new(false);

        /// Sets whether information for more error details
        /// should be collected. This is useful for debugging
        /// parser errors (as it leads to more comprehensive
        /// error messages), but it has a higher performance cost.
        /// (hence, it's off by default)
        ///
        /// # Arguments
        ///
        /// * `enabled` - Whether to enable the collection for
        ///               more error details.
        pub fn set_error_detail(enabled: bool) {
            ERROR_DETAIL.store(enabled, Ordering::Relaxed);
        }

        #[derive(Debug)]
        struct CallLimitTracker {
            current_call_limit: Option<(usize, usize)>,
        }

        impl Default for CallLimitTracker {
            fn default() -> Self {
                let limit = CALL_LIMIT.load(Ordering::Relaxed);
                let current_call_limit = if limit > 0 { Some((0, limit)) } else { None };
                Self { current_call_limit }
            }
        }

        impl CallLimitTracker {
            fn limit_reached(&self) -> bool {
                self.current_call_limit
                    .map_or(false, |(current, limit)| current >= limit)
            }

            fn increment_depth(&mut self) {
                if let Some((current, _)) = &mut self.current_call_limit {
                    *current += 1;
                }
            }
        }
        /// Number of call stacks that may result from a sequence of rules parsing.
        const CALL_STACK_INITIAL_CAPACITY: usize = 20;
        /// Max (un)expected number of tokens that we may see on the parsing error position.
        const EXPECTED_TOKENS_INITIAL_CAPACITY: usize = 30;
        /// Max rule children number for which we'll extend calls stacks.
        ///
        /// In case rule we're working with has too many children rules that failed in parsing,
        /// we don't want to store long stacks for all of them. If rule has more than this number
        /// of failed children, they all will be collapsed in a parent rule.
        const CALL_STACK_CHILDREN_THRESHOLD: usize = 4;

        /// Structure tracking errored parsing call (associated with specific `ParserState` function).
        #[derive(Debug, Hash, PartialEq, Eq, Clone, PartialOrd, Ord)]
        pub enum ParseAttempt<R> {
            /// Call of `rule` errored.
            Rule(R),
            /// Call of token element (e.g., `match_string` or `match_insensitive`) errored.
            /// Works as indicator of that leaf node is not a rule. In order to get the token value we
            /// can address `ParseAttempts` `(un)expected_tokens`.
            Token,
        }

        impl<R> ParseAttempt<R> {
            pub fn get_rule(&self) -> Option<&R> {
                match self {
                    ParseAttempt::Rule(r) => Some(r),
                    ParseAttempt::Token => None,
                }
            }
        }
        /// Rules call stack.
        /// Contains sequence of rule calls that resulted in new parsing attempt.
        #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub struct RulesCallStack<R> {
            /// Deepest rule caused a parsing error (ParseAttempt::Token transformed into a rule).
            pub deepest: ParseAttempt<R>,
            /// Most top rule covering `deepest`.
            pub parent: Option<R>,
        }

        impl<R> RulesCallStack<R> {
            fn new(deepest: ParseAttempt<R>) -> RulesCallStack<R> {
                RulesCallStack {
                    deepest,
                    parent: None,
                }
            }
        }

        #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum ParsingToken {
            Sensitive { token: String },
            Insensitive { token: String },
            Range { start: char, end: char },
            BuiltInRule,
        }

        impl Display for ParsingToken {
            fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
                match self {
                    ParsingToken::Sensitive { token } => write!(f, "{token}"),
                    ParsingToken::Insensitive { token } => write!(f, "{}", token.to_uppercase()),
                    ParsingToken::Range { start, end } => write!(f, "{start}..{end}"),
                    ParsingToken::BuiltInRule => write!(f, "BUILTIN_RULE"),
                }
            }
        }
        /// Structure that tracks all the parsing attempts made on the max position.
        #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub struct ParseAttempts<R> {
            /// Indicates whether the parsing attempts are tracked.
            enabled: bool,
            /// Vec of rule calls sequences awaiting tokens at the same `max_position`.
            /// If there are several stacks in vec, it means all those rule stacks are "equal"
            /// because their attempts occurred on the same position.
            pub call_stacks: Vec<RulesCallStack<R>>,
            /// Tokens that could be putted at `max_position`
            /// in order to get a valid grammar query.
            expected_tokens: Vec<ParsingToken>,
            /// Tokens that we've prohibited to be putted at `max_position`
            /// in order to get a valid grammar query.
            unexpected_tokens: Vec<ParsingToken>,
            /// Max position at which we were expecting to see one of `expected_tokens`.
            pub max_position: usize,
        }

        impl<R: RuleType> ParseAttempts<R> {
            /// Create new `ParseAttempts` instance with `call_stacks` and `expected_tokens`
            /// initialized with capacity.
            pub fn new() -> Self {
                Self {
                    call_stacks: Vec::with_capacity(CALL_STACK_INITIAL_CAPACITY),
                    expected_tokens: Vec::with_capacity(EXPECTED_TOKENS_INITIAL_CAPACITY),
                    unexpected_tokens: Vec::with_capacity(EXPECTED_TOKENS_INITIAL_CAPACITY),
                    max_position: 0,
                    enabled: ERROR_DETAIL.load(Ordering::Relaxed),
                }
            }
            /// Get number of currently present call stacks.
            fn call_stacks_number(&self) -> usize {
                self.call_stacks.len()
            }

            pub fn expected_tokens(&self) -> Vec<ParsingToken> {
                self.expected_tokens
                    .iter()
                    .cloned()
                    .collect::<BTreeSet<_>>()
                    .into_iter()
                    .collect()
            }

            pub fn unexpected_tokens(&self) -> Vec<ParsingToken> {
                self.unexpected_tokens
                    .iter()
                    .cloned()
                    .collect::<BTreeSet<_>>()
                    .into_iter()
                    .collect()
            }
            /// Retrieve call stacks.
            pub fn call_stacks(&self) -> Vec<RulesCallStack<R>> {
                self.call_stacks
                    .iter()
                    .cloned()
                    .collect::<BTreeSet<_>>()
                    .into_iter()
                    .collect()
            }
            /// In case we've tried to parse a rule, which start position is bigger than previous
            /// `max_position` it means that we've advanced in our parsing and found better candidate.
            ///
            /// `start_index` is:
            /// * Number of call stacks present in state at the moment current `rule` was called. The idea
            ///   is that we'd like to update only those stacks that originated from the current `rule` and
            ///   not from those that were called previously.
            /// * 0 in case we've successfully parsed some token since the moment `rule` was called.
            fn try_add_new_stack_rule(&mut self, rule: R, start_index: usize) {
                let mut non_token_call_stacks = Vec::new();
                let mut token_call_stack_met = false;
                for call_stack in self.call_stacks.iter().skip(start_index) {
                    if matches!(call_stack.deepest, ParseAttempt::Token) {
                        token_call_stack_met = true;
                    } else {
                        non_token_call_stacks.push(call_stack.clone())
                    }
                }
                if token_call_stack_met && non_token_call_stacks.is_empty() {
                    // If `non_token_call_stacks` is not empty we wouldn't like to add a new standalone
                    // `RulesCallStack::new(ParseAttempt::Token)` (that will later be transformed into a
                    // rule) as soon as it doesn't give us any useful additional info.
                    non_token_call_stacks.push(RulesCallStack::new(ParseAttempt::Token));
                }
                self.call_stacks
                    .splice(start_index.., non_token_call_stacks);

                let children_number_over_threshold =
                    self.call_stacks_number() - start_index >= CALL_STACK_CHILDREN_THRESHOLD;
                if children_number_over_threshold {
                    self.call_stacks.truncate(start_index);
                    self.call_stacks
                        .push(RulesCallStack::new(ParseAttempt::Rule(rule)));
                } else {
                    for call_stack in self.call_stacks.iter_mut().skip(start_index) {
                        if matches!(call_stack.deepest, ParseAttempt::Token) {
                            call_stack.deepest = ParseAttempt::Rule(rule);
                        } else {
                            call_stack.parent = Some(rule);
                        }
                    }
                }
            }
            /// If `expected` flag is set to false, it means we've successfully parsed token being in the
            /// state of negative lookahead and want to track `token` in the `unexpected_tokens`. Otherwise,
            /// we want to track it the `expected_tokens`. Let's call chosen vec a `target_vec`.
            ///
            /// In case `position` is:
            /// * Equal to `max_position`, add `token` to `target_vec`,
            /// * Bigger than `max_position`, set `token` as the only new element of `target_vec`.
            #[allow(clippy::comparison_chain)]
            fn try_add_new_token(
                &mut self,
                token: ParsingToken,
                start_position: usize,
                position: usize,
                negative_lookahead: bool,
            ) {
                let target_vec_push_token = |attempts: &mut ParseAttempts<R>| {
                    let target_vec = if negative_lookahead {
                        &mut attempts.unexpected_tokens
                    } else {
                        &mut attempts.expected_tokens
                    };
                    target_vec.push(token);
                };

                if position > self.max_position {
                    if negative_lookahead && start_position > self.max_position {
                        // We encountered a sequence under negative lookahead.
                        // We would like to track only first failed token in this sequence (which
                        // `start_position` should be equal to `self.max_position`).
                        return;
                    }
                    target_vec_push_token(self);

                    if negative_lookahead {
                        // In case of successful parsing of token under negative lookahead the only
                        // thing we'd like to do is to track the token in the `unexpected_tokens`.
                        return;
                    }
                    self.max_position = position;
                    self.expected_tokens.clear();
                    self.unexpected_tokens.clear();
                    self.call_stacks.clear();
                    self.call_stacks
                        .push(RulesCallStack::new(ParseAttempt::Token));
                } else if position == self.max_position {
                    target_vec_push_token(self);
                    self.call_stacks
                        .push(RulesCallStack::new(ParseAttempt::Token));
                }
            }
            /// Reset state in case we've successfully parsed some token in
            /// `match_string` or `match_insensetive`.
            fn nullify_expected_tokens(&mut self, new_max_position: usize) {
                self.call_stacks.clear();
                self.expected_tokens.clear();
                self.unexpected_tokens.clear();
                self.max_position = new_max_position;
            }
        }

        impl<R: RuleType> Default for ParseAttempts<R> {
            fn default() -> Self {
                Self::new()
            }
        }
        /// The complete state of a [`Parser`].
        #[derive(Debug)]
        pub struct ParserState<'i, R: RuleType> {
            /// Current position from which we try to apply some parser function.
            /// Initially is 0.
            /// E.g., we are parsing `create user 'Bobby'` query, we parsed "create" via `match_insensitive`
            /// and switched our `position` from 0 to the length of "create".
            ///
            /// E.g., see `match_string` -> `self.position.match_string(string)` which updates `self.pos`.
            position: Position<'i>,
            /// Queue representing rules partially (`QueueableToken::Start`) and
            /// totally (`QueueableToken::End`) parsed. When entering rule we put it in the queue in a state
            /// of `Start` and after all its sublogic (subrules or strings) are parsed, we change it to
            /// `End` state.
            queue: Vec<QueueableToken<'i, R>>,
            /// Status set in case specific lookahead logic is used in grammar.
            /// See `Lookahead` for more information.
            lookahead: Lookahead,
            /// Rules that we HAVE expected, tried to parse, but failed.
            pos_attempts: Vec<R>,
            /// Rules that we have NOT expected, tried to parse, but failed.
            neg_attempts: Vec<R>,
            /// Max position in the query from which we've tried to parse some rule but failed.
            attempt_pos: usize,
            /// Current atomicity status. For more information see `Atomicity`.
            atomicity: Atomicity,
            /// Helper structure tracking `Stack` status (used in case grammar contains stack PUSH/POP
            /// invocations).
            stack: Stack<Span<'i>>,
            /// Used for setting max parser calls limit.
            call_tracker: CallLimitTracker,
            /// Together with tracking of `pos_attempts` and `attempt_pos`
            /// as a pair of (list of rules that we've tried to parse but failed, max parsed position)
            /// we track those rules (which we've tried to parse at the same max pos) at this helper struct.
            ///
            /// Note, that we may try to parse several rules on different positions. We want to track only
            /// those rules, which attempt position is bigger, because we consider that it's nearer to the
            /// query that user really wanted to pass.
            ///
            /// E.g. we have a query `create user "Bobby"` and two root rules:
            /// * CreateUser  = { "create" ~ "user"  ~ Name }
            /// * CreateTable = { "create" ~ "table" ~ Name }
            /// * Name = { SOME_DEFINITION }
            ///
            /// While parsing the query we'll update tracker position to the start of "Bobby", because we'd
            /// successfully parse "create" + "user" (and not "table").
            parse_attempts: ParseAttempts<R>,
        }
        /// Creates a `ParserState` from a `&str`, supplying it to a closure `f`.
        #[allow(clippy::perf)]
        pub fn state<'i, R: RuleType, F>(input: &'i str, f: F) -> Result<pairs::Pairs<'i, R>, Error<R>>
        where
            F: FnOnce(Box<ParserState<'i, R>>) -> ParseResult<Box<ParserState<'i, R>>>,
        {
            let state = ParserState::new(input);

            match f(state) {
                Ok(state) => {
                    let len = state.queue.len();
                    Ok(new(Rc::new(state.queue), input, None, 0, len))
                }
                Err(mut state) => {
                    let variant = if state.reached_call_limit() {
                        ErrorVariant::CustomError {
                            message: "call limit reached".to_owned(),
                        }
                    } else {
                        state.pos_attempts.sort();
                        state.pos_attempts.dedup();
                        state.neg_attempts.sort();
                        state.neg_attempts.dedup();
                        ErrorVariant::ParsingError {
                            positives: state.pos_attempts.clone(),
                            negatives: state.neg_attempts.clone(),
                        }
                    };

                    if state.parse_attempts.enabled {
                        Err(Error::new_from_pos_with_parsing_attempts(
                            variant,
                            Position::new_internal(input, state.attempt_pos),
                            state.parse_attempts.clone(),
                        ))
                    } else {
                        Err(Error::new_from_pos(
                            variant,
                            Position::new_internal(input, state.attempt_pos),
                        ))
                    }
                }
            }
        }

        impl<'i, R: RuleType> ParserState<'i, R> {
            /// Allocates a fresh `ParserState` object to the heap and returns the owned `Box`.
            pub fn new(input: &'i str) -> Box<Self> {
                Box::new(ParserState {
                    position: Position::from_start(input),
                    queue: vec![],
                    lookahead: Lookahead::None,
                    pos_attempts: vec![],
                    neg_attempts: vec![],
                    attempt_pos: 0,
                    atomicity: Atomicity::NonAtomic,
                    stack: Stack::new(),
                    call_tracker: Default::default(),
                    parse_attempts: ParseAttempts::new(),
                })
            }
            /// Get all parse attempts after process of parsing is finished.
            pub fn get_parse_attempts(&self) -> &ParseAttempts<R> {
                &self.parse_attempts
            }
            /// Returns a reference to the current `Position` of the `ParserState`.
            pub fn position(&self) -> &Position<'i> {
                &self.position
            }
            /// Returns the current atomicity of the `ParserState`.
            pub fn atomicity(&self) -> Atomicity {
                self.atomicity
            }

            #[inline]
            fn inc_call_check_limit(mut self: Box<Self>) -> ParseResult<Box<Self>> {
                if self.call_tracker.limit_reached() {
                    return Err(self);
                }
                self.call_tracker.increment_depth();
                Ok(self)
            }

            #[inline]
            fn reached_call_limit(&self) -> bool {
                self.call_tracker.limit_reached()
            }
            /// Wrapper needed to generate tokens. This will associate the `R` type rule to the closure meant to match the rule.
            #[inline]
            pub fn rule<F>(mut self: Box<Self>, rule: R, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                // Position from which this `rule` starts parsing.
                let actual_pos = self.position.pos();
                // Remember index of the `self.queue` element that will be associated with this `rule`.
                let index = self.queue.len();

                let (pos_attempts_index, neg_attempts_index) = if actual_pos == self.attempt_pos {
                    (self.pos_attempts.len(), self.neg_attempts.len())
                } else {
                    // Attempts have not been cleared yet since the attempt_pos is older.
                    (0, 0)
                };

                if self.lookahead == Lookahead::None && self.atomicity != Atomicity::Atomic {
                    // Pair's position will only be known after running the closure.
                    self.queue.push(QueueableToken::Start {
                        end_token_index: 0,
                        input_pos: actual_pos,
                    });
                }

                // Remember attempts number before `f` call.
                // In `track` using this variable we can say, how many attempts were added
                // during children rules traversal.
                let attempts = self.attempts_at(actual_pos);
                // Number of call stacks present in `self.parse_attempts` before `f` call.
                // We need to remember this number only in case there wasn't found any farther attempt.
                // E.g. we are handling rule, on start position of which may be tested two
                // children rules. At the moment we'll return from `f` call below,
                // there will be two more children rules in `self.parse_attempts` that we'll
                // consider to be the children of current `rule`.
                let mut remember_call_stacks_number = self.parse_attempts.call_stacks_number();
                // Max parsing attempt position at the moment of `rule` handling.
                // It case it's raised during children rules handling, it means
                // we've made a parsing progress.
                let remember_max_position = self.parse_attempts.max_position;

                let result = f(self);

                let mut try_add_rule_to_stack = |new_state: &mut Box<ParserState<'_, R>>| {
                    if new_state.parse_attempts.max_position > remember_max_position {
                        // It means that one of `match_string` or e.g. `match_insensetive` function calls
                        // have already erased `self.parse_attempts.call_stacks` and that previously
                        // remembered values are not valid anymore.
                        remember_call_stacks_number = 0;
                    }
                    if !matches!(new_state.atomicity, Atomicity::Atomic) {
                        new_state
                            .parse_attempts
                            .try_add_new_stack_rule(rule, remember_call_stacks_number);
                    }
                };

                match result {
                    Ok(mut new_state) => {
                        if new_state.lookahead == Lookahead::Negative {
                            new_state.track(
                                rule,
                                actual_pos,
                                pos_attempts_index,
                                neg_attempts_index,
                                attempts,
                            );
                        }

                        if new_state.lookahead == Lookahead::None
                            && new_state.atomicity != Atomicity::Atomic
                        {
                            // Index of `QueueableToken::End` token added below
                            // that corresponds to previously added `QueueableToken::Start` token.
                            let new_index = new_state.queue.len();
                            match new_state.queue[index] {
                                QueueableToken::Start {
                                    ref mut end_token_index,
                                    ..
                                } => *end_token_index = new_index,
                                _ => unreachable!(),
                            };

                            let new_pos = new_state.position.pos();

                            new_state.queue.push(QueueableToken::End {
                                start_token_index: index,
                                rule,
                                tag: None,
                                input_pos: new_pos,
                            });
                        }

                        // Note, that we need to count positive parsing results too, because we can fail in
                        // optional rule call inside which may lie the farthest
                        // parsed token.
                        if new_state.parse_attempts.enabled {
                            try_add_rule_to_stack(&mut new_state);
                        }
                        Ok(new_state)
                    }
                    Err(mut new_state) => {
                        if new_state.lookahead != Lookahead::Negative {
                            new_state.track(
                                rule,
                                actual_pos,
                                pos_attempts_index,
                                neg_attempts_index,
                                attempts,
                            );
                            if new_state.parse_attempts.enabled {
                                try_add_rule_to_stack(&mut new_state);
                            }
                        }

                        if new_state.lookahead == Lookahead::None
                            && new_state.atomicity != Atomicity::Atomic
                        {
                            new_state.queue.truncate(index);
                        }

                        Err(new_state)
                    }
                }
            }
            /// Tag current node.
            #[inline]
            pub fn tag_node(mut self: Box<Self>, tag: &'i str) -> ParseResult<Box<Self>> {
                if let Some(QueueableToken::End { tag: old, .. }) = self.queue.last_mut() {
                    *old = Some(tag)
                }
                Ok(self)
            }
            /// Get number of allowed rules attempts + prohibited rules attempts.
            fn attempts_at(&self, pos: usize) -> usize {
                if self.attempt_pos == pos {
                    self.pos_attempts.len() + self.neg_attempts.len()
                } else {
                    0
                }
            }

            fn track(
                &mut self,
                rule: R,
                pos: usize,
                pos_attempts_index: usize,
                neg_attempts_index: usize,
                prev_attempts: usize,
            ) {
                if self.atomicity == Atomicity::Atomic {
                    return;
                }

                // If nested rules made no progress, there is no use to report them; it's only useful to
                // track the current rule, the exception being when only one attempt has been made during
                // the children rules.
                let curr_attempts = self.attempts_at(pos);
                if curr_attempts > prev_attempts && curr_attempts - prev_attempts == 1 {
                    return;
                }

                if pos == self.attempt_pos {
                    self.pos_attempts.truncate(pos_attempts_index);
                    self.neg_attempts.truncate(neg_attempts_index);
                }

                if pos > self.attempt_pos {
                    self.pos_attempts.clear();
                    self.neg_attempts.clear();
                    self.attempt_pos = pos;
                }

                let attempts = if self.lookahead != Lookahead::Negative {
                    &mut self.pos_attempts
                } else {
                    &mut self.neg_attempts
                };

                if pos == self.attempt_pos {
                    attempts.push(rule);
                }
            }
            /// Starts a sequence of transformations provided by `f` from the `Box<ParserState>`.
            #[inline]
            pub fn sequence<F>(mut self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                let token_index = self.queue.len();
                let initial_pos = self.position;

                let result = f(self);

                match result {
                    Ok(new_state) => Ok(new_state),
                    Err(mut new_state) => {
                        // Restore the initial position and truncate the token queue.
                        new_state.position = initial_pos;
                        new_state.queue.truncate(token_index);
                        Err(new_state)
                    }
                }
            }
            /// Repeatedly applies the transformation provided by `f` from the `Box<ParserState>`.
            #[inline]
            pub fn repeat<F>(mut self: Box<Self>, mut f: F) -> ParseResult<Box<Self>>
            where
                F: FnMut(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                let mut result = f(self);

                loop {
                    match result {
                        Ok(state) => result = f(state),
                        Err(state) => return Ok(state),
                    };
                }
            }
            /// Optionally applies the transformation provided by `f` from the `Box<ParserState>`.
            #[inline]
            pub fn optional<F>(mut self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                match f(self) {
                    Ok(state) | Err(state) => Ok(state),
                }
            }
            /// Generic function to handle result of char/string/range parsing in order to track (un)expected tokens.
            fn handle_token_parse_result(
                &mut self,
                start_position: usize,
                token: ParsingToken,
                parse_succeeded: bool,
            ) {
                // New position after tracked parsed element for case of `parse_succeded` is true.
                // Position of parsing failure otherwise.
                let current_pos = self.position.pos();

                if parse_succeeded {
                    if self.lookahead == Lookahead::Negative {
                        self.parse_attempts
                            .try_add_new_token(token, start_position, current_pos, true);
                    } else if current_pos > self.parse_attempts.max_position {
                        self.parse_attempts.nullify_expected_tokens(current_pos);
                    }
                } else if self.lookahead != Lookahead::Negative {
                    self.parse_attempts
                        .try_add_new_token(token, start_position, current_pos, false);
                }
            }
            /// Attempts to match a single character based on a filter function.
            #[inline]
            pub fn match_char_by<F>(mut self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(char) -> bool,
            {
                let start_position = self.position.pos();
                let succeeded = self.position.match_char_by(f);
                if self.parse_attempts.enabled {
                    let token = ParsingToken::BuiltInRule;
                    self.handle_token_parse_result(start_position, token, succeeded);
                }
                if succeeded {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to match the given string.
            #[inline]
            pub fn match_string(mut self: Box<Self>, string: &str) -> ParseResult<Box<Self>> {
                let start_position = self.position.pos();
                let succeeded = self.position.match_string(string);
                if self.parse_attempts.enabled {
                    let token = ParsingToken::Sensitive {
                        token: String::from(string),
                    };
                    self.handle_token_parse_result(start_position, token, succeeded);
                }
                if succeeded {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to case-insensitively match the given string. 
            #[inline]
            pub fn match_insensitive(mut self: Box<Self>, string: &str) -> ParseResult<Box<Self>> {
                let start_position: usize = self.position().pos();
                let succeeded = self.position.match_insensitive(string);
                if self.parse_attempts.enabled {
                    let token = ParsingToken::Insensitive {
                        token: String::from(string),
                    };
                    self.handle_token_parse_result(start_position, token, succeeded);
                }
                if succeeded {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to match a single character from the given range.
            #[inline]
            pub fn match_range(mut self: Box<Self>, range: Range<char>) -> ParseResult<Box<Self>> {
                let start_position = self.position().pos();
                let token = ParsingToken::Range {
                    start: range.start,
                    end: range.end,
                };
                let succeeded = self.position.match_range(range);
                if self.parse_attempts.enabled {
                    self.handle_token_parse_result(start_position, token, succeeded);
                }
                if succeeded {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to skip `n` characters forward.
            #[inline]
            pub fn skip(mut self: Box<Self>, n: usize) -> ParseResult<Box<Self>> {
                if self.position.skip(n) {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to skip forward until one of the given strings is found.
            #[inline]
            pub fn skip_until(mut self: Box<Self>, strings: &[&str]) -> ParseResult<Box<Self>> {
                self.position.skip_until(strings);
                Ok(self)
            }
            /// Attempts to match the start of the input.
            #[inline]
            pub fn start_of_input(self: Box<Self>) -> ParseResult<Box<Self>> {
                if self.position.at_start() {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to match the end of the input.
            #[inline]
            pub fn end_of_input(self: Box<Self>) -> ParseResult<Box<Self>> {
                if self.position.at_end() {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Starts a lookahead transformation provided by `f` from the `Box<ParserState>`.
            #[inline]
            pub fn lookahead<F>(mut self: Box<Self>, is_positive: bool, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                let initial_lookahead = self.lookahead;

                self.lookahead = if is_positive {
                    match initial_lookahead {
                        Lookahead::None | Lookahead::Positive => Lookahead::Positive,
                        Lookahead::Negative => Lookahead::Negative,
                    }
                } else {
                    match initial_lookahead {
                        Lookahead::None | Lookahead::Positive => Lookahead::Negative,
                        Lookahead::Negative => Lookahead::Positive,
                    }
                };

                let initial_pos = self.position;

                let result = f(self.checkpoint());

                let result_state = match result {
                    Ok(mut new_state) => {
                        new_state.position = initial_pos;
                        new_state.lookahead = initial_lookahead;
                        Ok(new_state.restore())
                    }
                    Err(mut new_state) => {
                        new_state.position = initial_pos;
                        new_state.lookahead = initial_lookahead;
                        Err(new_state.restore())
                    }
                };

                if is_positive {
                    result_state
                } else {
                    match result_state {
                        Ok(state) => Err(state),
                        Err(state) => Ok(state),
                    }
                }
            }
            /// Transformation which stops `Token`s from being generated according to `is_atomic`.
            #[inline]
            pub fn atomic<F>(mut self: Box<Self>, atomicity: Atomicity, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                // In case child parsing call is another `atomic` it will have its own atomicity status.
                let initial_atomicity = self.atomicity;
                // In case child atomicity is the same as we've demanded, we shouldn't do nothing.
                // E.g. we have the following rules:
                // * RootRule = @{ InnerRule }
                // * InnerRule = @{ ... }
                let should_toggle = self.atomicity != atomicity;

                // Note that we take atomicity of the top rule and not of the leaf (inner).
                if should_toggle {
                    self.atomicity = atomicity;
                }

                let result = f(self);

                match result {
                    Ok(mut new_state) => {
                        if should_toggle {
                            new_state.atomicity = initial_atomicity;
                        }
                        Ok(new_state)
                    }
                    Err(mut new_state) => {
                        if should_toggle {
                            new_state.atomicity = initial_atomicity;
                        }
                        Err(new_state)
                    }
                }
            }
            /// Evaluates the result of closure `f` and pushes the span of the input consumed from before
            /// `f` is called to after `f` is called to the stack. 
            #[inline]
            pub fn stack_push<F>(mut self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                let start = self.position;

                let result = f(self);

                match result {
                    Ok(mut state) => {
                        let end = state.position;
                        state.stack.push(start.span(&end));
                        Ok(state)
                    }
                    Err(state) => Err(state),
                }
            }
            /// Peeks the top of the stack and attempts to match the string.
            #[inline]
            pub fn stack_peek(self: Box<Self>) -> ParseResult<Box<Self>> {
                let string = self
                    .stack
                    .peek()
                    .expect("peek was called on empty stack")
                    .as_str();
                self.match_string(string)
            }
            /// Pops the top of the stack and attempts to match the string.
            #[inline]
            pub fn stack_pop(mut self: Box<Self>) -> ParseResult<Box<Self>> {
                let string = self
                    .stack
                    .pop()
                    .expect("pop was called on empty stack")
                    .as_str();
                self.match_string(string)
            }
            /// Matches part of the state of the stack.
            #[inline]
            pub fn stack_match_peek_slice(
                mut self: Box<Self>,
                start: i32,
                end: Option<i32>,
                match_dir: MatchDir,
            ) -> ParseResult<Box<Self>> {
                let range = match constrain_idxs(start, end, self.stack.len()) {
                    Some(r) => r,
                    None => return Err(self),
                };
                // return true if an empty sequence is requested
                if range.end <= range.start {
                    return Ok(self);
                }

                let mut position = self.position;
                let result = {
                    let mut iter_b2t = self.stack[range].iter();
                    let matcher = |span: &Span<'_>| position.match_string(span.as_str());
                    match match_dir {
                        MatchDir::BottomToTop => iter_b2t.all(matcher),
                        MatchDir::TopToBottom => iter_b2t.rev().all(matcher),
                    }
                };
                if result {
                    self.position = position;
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Matches the full state of the stack.
            #[inline]
            pub fn stack_match_peek(self: Box<Self>) -> ParseResult<Box<Self>> {
                self.stack_match_peek_slice(0, None, MatchDir::TopToBottom)
            }
            /// Matches the full state of the stack.
            #[inline]
            pub fn stack_match_pop(mut self: Box<Self>) -> ParseResult<Box<Self>> {
                let mut position = self.position;
                let mut result = true;
                while let Some(span) = self.stack.pop() {
                    result = position.match_string(span.as_str());
                    if !result {
                        break;
                    }
                }

                if result {
                    self.position = position;
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Drops the top of the stack.
            #[inline]
            pub fn stack_drop(mut self: Box<Self>) -> ParseResult<Box<Self>> {
                match self.stack.pop() {
                    Some(_) => Ok(self),
                    None => Err(self),
                }
            }
            /// Restores the original state of the `ParserState` when `f` returns an `Err`.
            #[inline]
            pub fn restore_on_err<F>(self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                match f(self.checkpoint()) {
                    Ok(state) => Ok(state.checkpoint_ok()),
                    Err(state) => Err(state.restore()),
                }
            }
            /// Mark the current state as a checkpoint and return the `Box`.
            #[inline]
            pub fn checkpoint(mut self: Box<Self>) -> Box<Self> {
                self.stack.snapshot();
                self
            }
            /// The checkpoint was cleared successfully so remove it without touching other stack state.
            #[inline]
            pub fn checkpoint_ok(mut self: Box<Self>) -> Box<Self> {
                self.stack.clear_snapshot();
                self
            }
            /// Restore the current state to the most recent checkpoint.
            #[inline]
            pub fn restore(mut self: Box<Self>) -> Box<Self> {
                self.stack.restore();
                self
            }
        }
        /// Helper function used only in case stack operations (PUSH/POP) are used in grammar.
        fn constrain_idxs(start: i32, end: Option<i32>, len: usize) -> Option<Range<usize>> {
            let start_norm = normalize_index(start, len)?;
            let end_norm = end.map_or(Some(len), |e| normalize_index(e, len))?;
            Some(start_norm..end_norm)
        }
        /// `constrain_idxs` helper function.
        fn normalize_index(i: i32, len: usize) -> Option<usize> {
            if i > len as i32 {
                None
            } else if i >= 0 {
                Some(i as usize)
            } else {
                let real_i = len as i32 + i;
                if real_i >= 0 {
                    Some(real_i as usize)
                } else {
                    None
                }
            }
        }
    }

    pub mod position
    {
        use ::
        {
            *,
        };
        

        use core::cmp::Ordering;
        use core::fmt;
        use core::hash::{Hash, Hasher};
        use core::ops::Range;
        use core::ptr;
        use core::str;

        use crate::span;

        /// A cursor position in a `&str` which provides useful methods to manually parse that string.
        #[derive(Clone, Copy)]
        pub struct Position<'i> {
            input: &'i str,
            pos: usize,
        }

        impl<'i> Position<'i> {
            /// Create a new `Position` without checking invariants. (Checked with `debug_assertions`.)
            pub fn new_internal(input: &str, pos: usize) -> Position<'_> {
                debug_assert!(input.get(pos..).is_some());
                Position { input, pos }
            }
            /// Attempts to create a new `Position` at the given position.
            pub fn new(input: &str, pos: usize) -> Option<Position<'_>> {
                input.get(pos..).map(|_| Position { input, pos })
            }
            /// Creates a `Position` at the start of a `&str`.
            #[inline]
            pub fn from_start(input: &'i str) -> Position<'i> {
                // Position 0 is always safe because it's always a valid UTF-8 border.
                Position { input, pos: 0 }
            }
            /// Returns the byte position of this `Position` as a `usize`.
            #[inline]
            pub fn pos(&self) -> usize {
                self.pos
            }
            /// Creates a `Span` from two `Position`s.
            #[inline]
            pub fn span(&self, other: &Position<'i>) -> span::Span<'i> {
                if ptr::eq(self.input, other.input)
                /* && self.input.get(self.pos..other.pos).is_some() */
                {
                    span::Span::new_internal(self.input, self.pos, other.pos)
                } else {
                    // TODO: maybe a panic if self.pos < other.pos
                    panic!("span created from positions from different inputs")
                }
            }
            /// Returns the line and column number of this `Position`.
            #[inline]
            pub fn line_col(&self) -> (usize, usize) {
                if self.pos > self.input.len() {
                    panic!("position out of bounds");
                }
                let mut pos = self.pos;
                let slice = &self.input[..pos];
                let mut chars = slice.chars().peekable();

                let mut line_col = (1, 1);

                while pos != 0 {
                    match chars.next() {
                        Some('\r') => {
                            if let Some(&'\n') = chars.peek() {
                                chars.next();

                                if pos == 1 {
                                    pos -= 1;
                                } else {
                                    pos -= 2;
                                }

                                line_col = (line_col.0 + 1, 1);
                            } else {
                                pos -= 1;
                                line_col = (line_col.0, line_col.1 + 1);
                            }
                        }
                        Some('\n') => {
                            pos -= 1;
                            line_col = (line_col.0 + 1, 1);
                        }
                        Some(c) => {
                            pos -= c.len_utf8();
                            line_col = (line_col.0, line_col.1 + 1);
                        }
                        None => unreachable!(),
                    }
                }

                line_col
            }
            /// Returns the entire line of the input that contains this `Position`.
            #[inline]
            pub fn line_of(&self) -> &'i str {
                if self.pos > self.input.len() {
                    panic!("position out of bounds");
                };
                // Safe since start and end can only be valid UTF-8 borders.
                &self.input[self.find_line_start()..self.find_line_end()]
            }

            pub fn find_line_start(&self) -> usize {
                if self.input.is_empty() {
                    return 0;
                };
                // Position's pos is always a UTF-8 border.
                let start = self
                    .input
                    .char_indices()
                    .rev()
                    .skip_while(|&(i, _)| i >= self.pos)
                    .find(|&(_, c)| c == '\n');
                match start {
                    Some((i, _)) => i + 1,
                    None => 0,
                }
            }

            pub fn find_line_end(&self) -> usize {
                if self.input.is_empty() {
                    0
                } else if self.pos == self.input.len() - 1 {
                    self.input.len()
                } else {
                    // Position's pos is always a UTF-8 border.
                    let end = self
                        .input
                        .char_indices()
                        .skip_while(|&(i, _)| i < self.pos)
                        .find(|&(_, c)| c == '\n');
                    match end {
                        Some((i, _)) => i + 1,
                        None => self.input.len(),
                    }
                }
            }
            /// Returns `true` when the `Position` points to the start of the input `&str`.
            #[inline]
            pub fn at_start(&self) -> bool {
                self.pos == 0
            }
            /// Returns `true` when the `Position` points to the end of the input `&str`.
            #[inline]
            pub fn at_end(&self) -> bool {
                self.pos == self.input.len()
            }
            /// Skips `n` `char`s from the `Position` and returns `true` if the skip was possible or `false`
            /// otherwise. If the return value is `false`, `pos` will not be updated.
            #[inline]
            pub fn skip(&mut self, n: usize) -> bool {
                let skipped = {
                    let mut len = 0;
                    // Position's pos is always a UTF-8 border.
                    let mut chars = self.input[self.pos..].chars();
                    for _ in 0..n {
                        if let Some(c) = chars.next() {
                            len += c.len_utf8();
                        } else {
                            return false;
                        }
                    }
                    len
                };

                self.pos += skipped;
                true
            }
            /// Goes back `n` `char`s from the `Position` and returns `true` if the skip was possible or `false`
            /// otherwise. If the return value is `false`, `pos` will not be updated.
            #[inline]
            pub fn skip_back(&mut self, n: usize) -> bool {
                let skipped = {
                    let mut len = 0;
                    // Position's pos is always a UTF-8 border.
                    let mut chars = self.input[..self.pos].chars().rev();
                    for _ in 0..n {
                        if let Some(c) = chars.next() {
                            len += c.len_utf8();
                        } else {
                            return false;
                        }
                    }
                    len
                };

                self.pos -= skipped;
                true
            }
            /// Skips until one of the given `strings` is found. If none of the `strings` can be found,
            /// this function will return `false` but its `pos` will *still* be updated.
            #[inline]
            pub fn skip_until(&mut self, strings: &[&str]) -> bool {
                #[cfg(not(feature = "memchr"))]
                {
                    self.skip_until_basic(strings)
                }
                #[cfg(feature = "memchr")]
                {
                    match strings {
                        [] => (),
                        [s1] => {
                            if let Some(from) =
                                memchr::memmem::find(&self.input.as_bytes()[self.pos..], s1.as_bytes())
                            {
                                self.pos += from;
                                return true;
                            }
                        }
                        [s1, s2] if !s1.is_empty() && !s2.is_empty() => {
                            let b1 = s1.as_bytes()[0];
                            let b2 = s2.as_bytes()[0];
                            let miter = memchr::memchr2_iter(b1, b2, &self.input.as_bytes()[self.pos..]);
                            for from in miter {
                                let start = &self.input[self.pos + from..];
                                if start.starts_with(s1) || start.starts_with(s2) {
                                    self.pos += from;
                                    return true;
                                }
                            }
                        }
                        [s1, s2, s3] if !s1.is_empty() && !s2.is_empty() && s3.is_empty() => {
                            let b1 = s1.as_bytes()[0];
                            let b2 = s2.as_bytes()[0];
                            let b3 = s2.as_bytes()[0];
                            let miter =
                                memchr::memchr3_iter(b1, b2, b3, &self.input.as_bytes()[self.pos..]);
                            for from in miter {
                                let start = &self.input[self.pos + from..];
                                if start.starts_with(s1) || start.starts_with(s2) || start.starts_with(s3) {
                                    self.pos += from;
                                    return true;
                                }
                            }
                        }
                        _ => {
                            return self.skip_until_basic(strings);
                        }
                    }
                    self.pos = self.input.len();
                    false
                }
            }

            #[inline]
            fn skip_until_basic(&mut self, strings: &[&str]) -> bool {
                // TODO: optimize with Aho-Corasick, e.g. https://crates.io/crates/daachorse?
                for from in self.pos..self.input.len() {
                    let bytes = if let Some(string) = self.input.get(from..) {
                        string.as_bytes()
                    } else {
                        continue;
                    };

                    for slice in strings.iter() {
                        let to = slice.len();
                        if Some(slice.as_bytes()) == bytes.get(0..to) {
                            self.pos = from;
                            return true;
                        }
                    }
                }

                self.pos = self.input.len();
                false
            }
            /// Matches the char at the `Position` against a specified character and returns `true` if a match
            /// was made. If no match was made, returns `false`.
            /// `pos` will not be updated in either case.
            #[inline]
            pub fn match_char(&self, c: char) -> bool {
                matches!(self.input[self.pos..].chars().next(), Some(cc) if c == cc)
            }
            /// Matches the char at the `Position` against a filter function and returns `true` if a match
            /// was made. If no match was made, returns `false` and `pos` will not be updated.
            #[inline]
            pub fn match_char_by<F>(&mut self, f: F) -> bool
            where
                F: FnOnce(char) -> bool,
            {
                if let Some(c) = self.input[self.pos..].chars().next() {
                    if f(c) {
                        self.pos += c.len_utf8();
                        true
                    } else {
                        false
                    }
                } else {
                    false
                }
            }
            /// Matches `string` from the `Position` and returns `true` if a match was made or `false`
            /// otherwise. If no match was made, `pos` will not be updated.
            #[inline]
            pub fn match_string(&mut self, string: &str) -> bool {
                let to = self.pos + string.len();

                if Some(string.as_bytes()) == self.input.as_bytes().get(self.pos..to) {
                    self.pos = to;
                    true
                } else {
                    false
                }
            }
            /// Case-insensitively matches `string` from the `Position` and returns `true` if a match was
            /// made or `false` otherwise. If no match was made, `pos` will not be updated.
            #[inline]
            pub fn match_insensitive(&mut self, string: &str) -> bool {
                let matched = {
                    let slice = &self.input[self.pos..];
                    if let Some(slice) = slice.get(0..string.len()) {
                        slice.eq_ignore_ascii_case(string)
                    } else {
                        false
                    }
                };

                if matched {
                    self.pos += string.len();
                    true
                } else {
                    false
                }
            }
            /// Matches `char` `range` from the `Position` and returns `true` if a match was made or `false`
            /// otherwise. If no match was made, `pos` will not be updated.
            #[inline]
            pub fn match_range(&mut self, range: Range<char>) -> bool {
                if let Some(c) = self.input[self.pos..].chars().next() {
                    if range.start <= c && c <= range.end {
                        self.pos += c.len_utf8();
                        return true;
                    }
                }

                false
            }
        }

        impl<'i> fmt::Debug for Position<'i> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("Position").field("pos", &self.pos).finish()
            }
        }

        impl<'i> PartialEq for Position<'i> {
            fn eq(&self, other: &Position<'i>) -> bool {
                ptr::eq(self.input, other.input) && self.pos == other.pos
            }
        }

        impl<'i> Eq for Position<'i> {}

        #[allow(clippy::non_canonical_partial_ord_impl)]
        impl<'i> PartialOrd for Position<'i> {
            fn partial_cmp(&self, other: &Position<'i>) -> Option<Ordering> {
                if ptr::eq(self.input, other.input) {
                    self.pos.partial_cmp(&other.pos)
                } else {
                    None
                }
            }
        }

        impl<'i> Ord for Position<'i> {
            fn cmp(&self, other: &Position<'i>) -> Ordering {
                self.partial_cmp(other)
                    .expect("cannot compare positions from different strs")
            }
        }

        impl<'i> Hash for Position<'i> {
            fn hash<H: Hasher>(&self, state: &mut H) {
                (self.input as *const str).hash(state);
                self.pos.hash(state);
            }
        }
    }

    pub mod pratt_parser
    {
        //! Constructs useful in prefix, postfix, and infix operator parsing with the Pratt parsing method.
        use ::
        {
            *,
        };
        

        

        use core::iter::Peekable;
        use core::marker::PhantomData;
        use core::ops::BitOr;

        use alloc::boxed::Box;
        use alloc::collections::BTreeMap;

        use crate::iterators::Pair;
        use crate::RuleType;

        /// Associativity of an infix binary operator, used by [`Op::infix(Assoc)`].
        ///
        /// [`Op::infix(Assoc)`]: struct.Op.html
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum Assoc {
            /// Left operator associativity. Evaluate expressions from left-to-right.
            Left,
            /// Right operator associativity. Evaluate expressions from right-to-left.
            Right,
        }

        type Prec = u32;
        const PREC_STEP: Prec = 10;

        /// An operator that corresponds to a rule.
        pub struct Op<R: RuleType> {
            rule: R,
            affix: Affix,
            next: Option<Box<Op<R>>>,
        }

        enum Affix {
            Prefix,
            Postfix,
            Infix(Assoc),
        }

        impl<R: RuleType> Op<R> {
            /// Defines `rule` as a prefix unary operator.
            pub fn prefix(rule: R) -> Self {
                Self {
                    rule,
                    affix: Affix::Prefix,
                    next: None,
                }
            }
            /// Defines `rule` as a postfix unary operator.
            pub fn postfix(rule: R) -> Self {
                Self {
                    rule,
                    affix: Affix::Postfix,
                    next: None,
                }
            }
            /// Defines `rule` as an infix binary operator with associativity `assoc`.
            pub fn infix(rule: R, assoc: Assoc) -> Self {
                Self {
                    rule,
                    affix: Affix::Infix(assoc),
                    next: None,
                }
            }
        }

        impl<R: RuleType> BitOr for Op<R> {
            type Output = Self;

            fn bitor(mut self, rhs: Self) -> Self {
                fn assign_next<R: RuleType>(op: &mut Op<R>, next: Op<R>) {
                    if let Some(ref mut child) = op.next {
                        assign_next(child, next);
                    } else {
                        op.next = Some(Box::new(next));
                    }
                }

                assign_next(&mut self, rhs);
                self
            }
        }
        /// Struct containing operators and precedences, which can perform [Pratt parsing][1] on
        /// primary, prefix, postfix and infix expressions over [`Pairs`].
        pub struct PrattParser<R: RuleType> {
            prec: Prec,
            ops: BTreeMap<R, (Affix, Prec)>,
            has_prefix: bool,
            has_postfix: bool,
            has_infix: bool,
        }

        impl<R: RuleType> Default for PrattParser<R> {
            fn default() -> Self {
                Self::new()
            }
        }

        impl<R: RuleType> PrattParser<R> {
            /// Instantiate a new `PrattParser`.
            pub fn new() -> Self {
                Self {
                    prec: PREC_STEP,
                    ops: BTreeMap::new(),
                    has_prefix: false,
                    has_postfix: false,
                    has_infix: false,
                }
            }
            /// Add `op` to `PrattParser`.
            pub fn op(mut self, op: Op<R>) -> Self {
                self.prec += PREC_STEP;
                let mut iter = Some(op);
                while let Some(Op { rule, affix, next }) = iter.take() {
                    match affix {
                        Affix::Prefix => self.has_prefix = true,
                        Affix::Postfix => self.has_postfix = true,
                        Affix::Infix(_) => self.has_infix = true,
                    }
                    self.ops.insert(rule, (affix, self.prec));
                    iter = next.map(|op| *op);
                }
                self
            }
            /// Maps primary expressions with a closure `primary`.
            pub fn map_primary<'pratt, 'a, 'i, X, T>(
                &'pratt self,
                primary: X,
            ) -> PrattParserMap<'pratt, 'a, 'i, R, X, T>
            where
                X: FnMut(Pair<'i, R>) -> T,
                R: 'pratt,
            {
                PrattParserMap {
                    pratt: self,
                    primary,
                    prefix: None,
                    postfix: None,
                    infix: None,
                    phantom: PhantomData,
                }
            }
        }

        type PrefixFn<'a, 'i, R, T> = Box<dyn FnMut(Pair<'i, R>, T) -> T + 'a>;
        type PostfixFn<'a, 'i, R, T> = Box<dyn FnMut(T, Pair<'i, R>) -> T + 'a>;
        type InfixFn<'a, 'i, R, T> = Box<dyn FnMut(T, Pair<'i, R>, T) -> T + 'a>;

        /// Product of calling [`map_primary`] on [`PrattParser`], defines how expressions should be mapped.
        pub struct PrattParserMap<'pratt, 'a, 'i, R, F, T>
        where
            R: RuleType,
            F: FnMut(Pair<'i, R>) -> T,
        {
            pratt: &'pratt PrattParser<R>,
            primary: F,
            prefix: Option<PrefixFn<'a, 'i, R, T>>,
            postfix: Option<PostfixFn<'a, 'i, R, T>>,
            infix: Option<InfixFn<'a, 'i, R, T>>,
            phantom: PhantomData<T>,
        }

        impl<'pratt, 'a, 'i, R, F, T> PrattParserMap<'pratt, 'a, 'i, R, F, T>
        where
            R: RuleType + 'pratt,
            F: FnMut(Pair<'i, R>) -> T,
        {
            /// Maps prefix operators with closure `prefix`.
            pub fn map_prefix<X>(mut self, prefix: X) -> Self
            where
                X: FnMut(Pair<'i, R>, T) -> T + 'a,
            {
                self.prefix = Some(Box::new(prefix));
                self
            }
            /// Maps postfix operators with closure `postfix`.
            pub fn map_postfix<X>(mut self, postfix: X) -> Self
            where
                X: FnMut(T, Pair<'i, R>) -> T + 'a,
            {
                self.postfix = Some(Box::new(postfix));
                self
            }
            /// Maps infix operators with a closure `infix`.
            pub fn map_infix<X>(mut self, infix: X) -> Self
            where
                X: FnMut(T, Pair<'i, R>, T) -> T + 'a,
            {
                self.infix = Some(Box::new(infix));
                self
            }
            /// The last method to call on the provided pairs to execute the Pratt
            /// parser (previously defined using [`map_primary`], [`map_prefix`], [`map_postfix`],
            /// and [`map_infix`] methods).
            ///
            /// [`map_primary`]: struct.PrattParser.html#method.map_primary
            /// [`map_prefix`]: struct.PrattParserMap.html#method.map_prefix
            /// [`map_postfix`]: struct.PrattParserMap.html#method.map_postfix
            /// [`map_infix`]: struct.PrattParserMap.html#method.map_infix
            pub fn parse<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: P) -> T {
                self.expr(&mut pairs.peekable(), 0)
            }

            fn expr<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: &mut Peekable<P>, rbp: Prec) -> T {
                let mut lhs = self.nud(pairs);
                while rbp < self.lbp(pairs) {
                    lhs = self.led(pairs, lhs);
                }
                lhs
            }
            /// Null-Denotation
            ///
            /// "the action that should happen when the symbol is encountered
            ///  as start of an expression (most notably, prefix operators)
            fn nud<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: &mut Peekable<P>) -> T {
                let pair = pairs.next().expect("Pratt parsing expects non-empty Pairs");
                match self.pratt.ops.get(&pair.as_rule()) {
                    Some((Affix::Prefix, prec)) => {
                        let rhs = self.expr(pairs, *prec - 1);
                        match self.prefix.as_mut() {
                            Some(prefix) => prefix(pair, rhs),
                            None => panic!("Could not map {}, no `.map_prefix(...)` specified", pair),
                        }
                    }
                    None => (self.primary)(pair),
                    _ => panic!("Expected prefix or primary expression, found {}", pair),
                }
            }
            /// Left-Denotation
            ///
            /// "the action that should happen when the symbol is encountered
            /// after the start of an expression (most notably, infix and postfix operators)"
            fn led<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: &mut Peekable<P>, lhs: T) -> T {
                let pair = pairs.next().unwrap();
                match self.pratt.ops.get(&pair.as_rule()) {
                    Some((Affix::Infix(assoc), prec)) => {
                        let rhs = match *assoc {
                            Assoc::Left => self.expr(pairs, *prec),
                            Assoc::Right => self.expr(pairs, *prec - 1),
                        };
                        match self.infix.as_mut() {
                            Some(infix) => infix(lhs, pair, rhs),
                            None => panic!("Could not map {}, no `.map_infix(...)` specified", pair),
                        }
                    }
                    Some((Affix::Postfix, _)) => match self.postfix.as_mut() {
                        Some(postfix) => postfix(lhs, pair),
                        None => panic!("Could not map {}, no `.map_postfix(...)` specified", pair),
                    },
                    _ => panic!("Expected postfix or infix expression, found {}", pair),
                }
            }
            /// Left-Binding-Power
            ///
            /// "describes the symbol's precedence in infix form (most notably, operator precedence)"
            fn lbp<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: &mut Peekable<P>) -> Prec {
                match pairs.peek() {
                    Some(pair) => match self.pratt.ops.get(&pair.as_rule()) {
                        Some((_, prec)) => *prec,
                        None => panic!("Expected operator, found {}", pair),
                    },
                    None => 0,
                }
            }
        }
    }

    pub mod prec_climber
    {
        //! Constructs useful in infix operator parsing with the precedence climbing method.
        use ::
        {
            *,
        };
        

        

        use alloc::borrow::Cow;
        use alloc::boxed::Box;
        use alloc::vec::Vec;
        use core::iter::Peekable;
        use core::ops::BitOr;

        use crate::iterators::Pair;
        use crate::RuleType;

        /// Macro for more convenient const fn definition of `prec_climber::PrecClimber`.
        #[cfg(feature = "const_prec_climber")]
        #[macro_export]
        macro_rules! prec_climber {
            (
                $( $assoc:ident $rule:ident $( | $rules:ident )* ),+ $(,)?
            ) => {{
                prec_climber!(
                    @precedences { 1u32 }
                    $( [ $rule $( $rules )* ] )*
                );

                $crate::prec_climber::PrecClimber::new_const(
                    prec_climber!(
                        @array
                        $( $assoc $rule $(, $assoc $rules )* ),*
                    )
                )
            }};

            ( @assoc L ) => { $crate::prec_climber::Assoc::Left };
            ( @assoc R ) => { $crate::prec_climber::Assoc::Right };

            (
                @array
                $(
                    $assoc:ident $rule:ident
                ),*
            ) => {
                &[
                    $(
                        (
                            Rule::$rule,
                            $rule,
                            prec_climber!( @assoc $assoc ),
                        )
                    ),*
                ]
            };

            (
                @precedences { $precedence:expr }
            ) => {};

            (
                @precedences { $precedence:expr }
                [ $( $rule:ident )* ]
                $( [ $( $rules:ident )* ] )*
            ) => {
                $(
                    #[allow(non_upper_case_globals)]
                    const $rule: u32 = $precedence;
                )*
                prec_climber!(
                    @precedences { 1u32 + $precedence }
                    $( [ $( $rules )* ] )*
                );
            };
        }
        /// Associativity of an [`Operator`].
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum Assoc {
            /// Left `Operator` associativity
            Left,
            /// Right `Operator` associativity
            Right,
        }
        /// Infix operator used in [`PrecClimber`].
        #[derive(Debug)]
        pub struct Operator<R: RuleType> {
            rule: R,
            assoc: Assoc,
            next: Option<Box<Operator<R>>>,
        }

        impl<R: RuleType> Operator<R> {
            /// Creates a new `Operator` from a `Rule` and `Assoc`.
            pub fn new(rule: R, assoc: Assoc) -> Operator<R> {
                Operator {
                    rule,
                    assoc,
                    next: None,
                }
            }
        }

        impl<R: RuleType> BitOr for Operator<R> {
            type Output = Self;

            fn bitor(mut self, rhs: Self) -> Self {
                fn assign_next<R: RuleType>(op: &mut Operator<R>, next: Operator<R>) {
                    if let Some(ref mut child) = op.next {
                        assign_next(child, next);
                    } else {
                        op.next = Some(Box::new(next));
                    }
                }

                assign_next(&mut self, rhs);
                self
            }
        }
        /// List of operators and precedences, which can perform [precedence climbing] on infix expressions contained in a [`Pairs`].
        #[derive(Debug)]
        pub struct PrecClimber<R: Clone + 'static> {
            ops: Cow<'static, [(R, u32, Assoc)]>,
        }

        #[cfg(feature = "const_prec_climber")]
        impl<R: Clone + 'static> PrecClimber<R> {
            /// Creates a new `PrecClimber` directly from a static slice of  `(rule: Rule, precedence: u32, associativity: Assoc)` tuples.
            pub const fn new_const(ops: &'static [(R, u32, Assoc)]) -> PrecClimber<R> {
                PrecClimber {
                    ops: Cow::Borrowed(ops),
                }
            }
        }

        impl<R: RuleType> PrecClimber<R> {
            // find matching operator by `rule`
            fn get(&self, rule: &R) -> Option<(u32, Assoc)> {
                self.ops
                    .iter()
                    .find(|(r, _, _)| r == rule)
                    .map(|(_, precedence, assoc)| (*precedence, *assoc))
            }
            /// Creates a new `PrecClimber` from the `Operator`s contained in `ops`.
            pub fn new(ops: Vec<Operator<R>>) -> PrecClimber<R> {
                let ops = ops
                    .into_iter()
                    .zip(1..)
                    .fold(Vec::new(), |mut vec, (op, prec)| {
                        let mut next = Some(op);

                        while let Some(op) = next.take() {
                            let Operator {
                                rule,
                                assoc,
                                next: op_next,
                            } = op;

                            vec.push((rule, prec, assoc));
                            next = op_next.map(|op| *op);
                        }

                        vec
                    });

                PrecClimber {
                    ops: Cow::Owned(ops),
                }
            }
            /// Performs the precedence climbing algorithm on the `pairs` in a similar manner to map-reduce.
            pub fn climb<'i, P, F, G, T>(&self, mut pairs: P, mut primary: F, mut infix: G) -> T
            where
                P: Iterator<Item = Pair<'i, R>>,
                F: FnMut(Pair<'i, R>) -> T,
                G: FnMut(T, Pair<'i, R>, T) -> T,
            {
                let lhs = primary(
                    pairs
                        .next()
                        .expect("precedence climbing requires a non-empty Pairs"),
                );
                self.climb_rec(lhs, 0, &mut pairs.peekable(), &mut primary, &mut infix)
            }

            fn climb_rec<'i, P, F, G, T>(
                &self,
                mut lhs: T,
                min_prec: u32,
                pairs: &mut Peekable<P>,
                primary: &mut F,
                infix: &mut G,
            ) -> T
            where
                P: Iterator<Item = Pair<'i, R>>,
                F: FnMut(Pair<'i, R>) -> T,
                G: FnMut(T, Pair<'i, R>, T) -> T,
            {
                while pairs.peek().is_some() {
                    let rule = pairs.peek().unwrap().as_rule();
                    if let Some((prec, _)) = self.get(&rule) {
                        if prec >= min_prec {
                            let op = pairs.next().unwrap();
                            let mut rhs = primary(pairs.next().expect(
                                "infix operator must be followed by \
                                a primary expression",
                            ));

                            while pairs.peek().is_some() {
                                let rule = pairs.peek().unwrap().as_rule();
                                if let Some((new_prec, assoc)) = self.get(&rule) {
                                    if new_prec > prec || assoc == Assoc::Right && new_prec == prec {
                                        rhs = self.climb_rec(rhs, new_prec, pairs, primary, infix);
                                    } else {
                                        break;
                                    }
                                } else {
                                    break;
                                }
                            }

                            lhs = infix(lhs, op, rhs);
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                lhs
            }
        }
    }

    pub mod span
    {
        use ::
        {
            *,
        };
        

        use core::fmt;
        use core::hash::{Hash, Hasher};
        use core::ops::{Bound, RangeBounds};
        use core::ptr;
        use core::str;

        use crate::position;

        /// A span over a `&str`. It is created from either [two `Position`s] or from a [`Pair`].
        ///
        /// [two `Position`s]: struct.Position.html#method.span
        /// [`Pair`]: ../iterators/struct.Pair.html#method.span
        #[derive(Clone, Copy)]
        pub struct Span<'i> {
            input: &'i str,
            start: usize,
            end: usize,
        }

        impl<'i> Span<'i> {
            /// Create a new `Span` without checking invariants. (Checked with `debug_assertions`.)
            pub fn new_internal(input: &str, start: usize, end: usize) -> Span<'_> {
                debug_assert!(input.get(start..end).is_some());
                Span { input, start, end }
            }
            /// Attempts to create a new span. Will return `None` if `input[start..end]` is an invalid index
            /// into `input`.
            pub fn new(input: &str, start: usize, end: usize) -> Option<Span<'_>> {
                if input.get(start..end).is_some() {
                    Some(Span { input, start, end })
                } else {
                    None
                }
            }
            /// Attempts to create a new span based on a sub-range.
            pub fn get(&self, range: impl RangeBounds<usize>) -> Option<Span<'i>> {
                let start = match range.start_bound() {
                    Bound::Included(offset) => *offset,
                    Bound::Excluded(offset) => *offset + 1,
                    Bound::Unbounded => 0,
                };
                let end = match range.end_bound() {
                    Bound::Included(offset) => *offset + 1,
                    Bound::Excluded(offset) => *offset,
                    Bound::Unbounded => self.as_str().len(),
                };

                self.as_str().get(start..end).map(|_| Span {
                    input: self.input,
                    start: self.start + start,
                    end: self.start + end,
                })
            }
            /// Returns the `Span`'s start byte position as a `usize`.
            #[inline]
            pub fn start(&self) -> usize {
                self.start
            }
            /// Returns the `Span`'s end byte position as a `usize`.
            #[inline]
            pub fn end(&self) -> usize {
                self.end
            }
            /// Returns the `Span`'s start `Position`.
            #[inline]
            pub fn start_pos(&self) -> position::Position<'i> {
                position::Position::new_internal(self.input, self.start)
            }
            /// Returns the `Span`'s end `Position`.
            #[inline]
            pub fn end_pos(&self) -> position::Position<'i> {
                position::Position::new_internal(self.input, self.end)
            }
            /// Splits the `Span` into a pair of `Position`s.
            #[inline]
            pub fn split(self) -> (position::Position<'i>, position::Position<'i>) {
                let pos1 = position::Position::new_internal(self.input, self.start);
                let pos2 = position::Position::new_internal(self.input, self.end);

                (pos1, pos2)
            }
            /// Captures a slice from the `&str` defined by the `Span`.
            #[inline]
            pub fn as_str(&self) -> &'i str {
                // Span's start and end positions are always a UTF-8 borders.
                &self.input[self.start..self.end]
            }
            /// Returns the input string of the `Span`.
            pub fn get_input(&self) -> &'i str {
                self.input
            }
            /// Iterates over all lines (partially) covered by this span. Yielding a `&str` for each line.
            #[inline]
            pub fn lines(&self) -> Lines<'_> {
                Lines {
                    inner: self.lines_span(),
                }
            }
            /// Iterates over all lines (partially) covered by this span. Yielding a `Span` for each line.
            pub fn lines_span(&self) -> LinesSpan<'_> {
                LinesSpan {
                    span: self,
                    pos: self.start,
                }
            }
        }

        impl<'i> fmt::Debug for Span<'i> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("Span")
                    .field("str", &self.as_str())
                    .field("start", &self.start)
                    .field("end", &self.end)
                    .finish()
            }
        }

        impl<'i> PartialEq for Span<'i> {
            fn eq(&self, other: &Span<'i>) -> bool {
                ptr::eq(self.input, other.input) && self.start == other.start && self.end == other.end
            }
        }

        impl<'i> Eq for Span<'i> {}

        impl<'i> Hash for Span<'i> {
            fn hash<H: Hasher>(&self, state: &mut H) {
                (self.input as *const str).hash(state);
                self.start.hash(state);
                self.end.hash(state);
            }
        }
        /// Merges two spans into one.
        pub fn merge_spans<'i>(a: &Span<'i>, b: &Span<'i>) -> Option<Span<'i>> {
            if a.end() >= b.start() && a.start() <= b.end() {
                // The spans overlap or are contiguous, so they can be merged.
                Span::new(
                    a.get_input(),
                    core::cmp::min(a.start(), b.start()),
                    core::cmp::max(a.end(), b.end()),
                )
            } else {
                // The spans don't overlap and aren't contiguous, so they can't be merged.
                None
            }
        }
        /// Line iterator for Spans, created by [`Span::lines_span()`].
        pub struct LinesSpan<'i> {
            span: &'i Span<'i>,
            pos: usize,
        }

        impl<'i> Iterator for LinesSpan<'i> {
            type Item = Span<'i>;
            fn next(&mut self) -> Option<Self::Item> {
                if self.pos > self.span.end {
                    return None;
                }
                let pos = position::Position::new(self.span.input, self.pos)?;
                if pos.at_end() {
                    return None;
                }

                let line_start = pos.find_line_start();
                self.pos = pos.find_line_end();

                Span::new(self.span.input, line_start, self.pos)
            }
        }
        /// Line iterator for Spans, created by [`Span::lines()`].
        pub struct Lines<'i> {
            inner: LinesSpan<'i>,
        }

        impl<'i> Iterator for Lines<'i> {
            type Item = &'i str;
            fn next(&mut self) -> Option<Self::Item> {
                self.inner.next().map(|span| span.as_str())
            }
        }
    }

    pub mod stack
    {
        use ::
        {
            *,
        };
        

        use alloc::vec;
        use alloc::vec::Vec;
        use core::ops::{Index, Range};

        /// Implementation of a `Stack` which maintains popped elements and length of previous states
        /// in order to rewind the stack to a previous state.
        #[derive(Debug)]
        pub struct Stack<T: Clone> {
            /// All elements in the stack.
            cache: Vec<T>,
            /// All elements that are in previous snapshots but may not be in the next state.
            /// They will be pushed back to `cache` if the snapshot is restored,
            /// otherwise be dropped if the snapshot is cleared.
            ///
            /// Those elements from a sequence of snapshots are stacked in one [`Vec`], and
            /// `popped.len() == lengths.iter().map(|(len, remained)| len - remained).sum()`
            popped: Vec<T>,
            /// Every element corresponds to a snapshot, and each element has two fields:
            /// - Length of `cache` when corresponding snapshot is taken (AKA `len`).
            /// - Count of elements that come from corresponding snapshot
            ///   and are still in next snapshot or current state (AKA `remained`).
            ///
            /// And `len` is never less than `remained`.
            ///
            /// On restoring, the `cache` can be divided into two parts:
            /// - `0..remained` are untouched since the snapshot is taken.
            ///
            ///   There's nothing to do with those elements. Just let them stay where they are.
            ///
            /// - `remained..cache.len()` are pushed after the snapshot is taken.
            lengths: Vec<(usize, usize)>,
        }

        impl<T: Clone> Default for Stack<T> {
            fn default() -> Self {
                Self::new()
            }
        }

        impl<T: Clone> Stack<T> {
            /// Creates a new `Stack`.
            pub fn new() -> Self {
                Stack {
                    cache: vec![],
                    popped: vec![],
                    lengths: vec![],
                }
            }
            /// Returns `true` if the stack is currently empty.
            
            pub fn is_empty(&self) -> bool {
                self.cache.is_empty()
            }
            /// Returns the top-most `&T` in the `Stack`.
            pub fn peek(&self) -> Option<&T> {
                self.cache.last()
            }
            /// Pushes a `T` onto the `Stack`.
            pub fn push(&mut self, elem: T) {
                self.cache.push(elem);
            }
            /// Pops the top-most `T` from the `Stack`.
            pub fn pop(&mut self) -> Option<T> {
                let len = self.cache.len();
                let popped = self.cache.pop();
                if let Some(popped) = &popped {
                    if let Some((_, remained_count)) = self.lengths.last_mut() {
                        // `len >= *unpopped_count`
                        if len == *remained_count {
                            *remained_count -= 1;
                            self.popped.push(popped.clone());
                        }
                    }
                }
                popped
            }
            /// Returns the size of the stack
            pub fn len(&self) -> usize {
                self.cache.len()
            }
            /// Takes a snapshot of the current `Stack`.
            pub fn snapshot(&mut self) {
                self.lengths.push((self.cache.len(), self.cache.len()))
            }
            /// The parsing after the last snapshot was successful so clearing it.
            pub fn clear_snapshot(&mut self) {
                if let Some((len, unpopped)) = self.lengths.pop() {
                    // Popped elements from previous state are no longer needed.
                    self.popped.truncate(self.popped.len() - (len - unpopped));
                }
            }
            /// Rewinds the `Stack` to the most recent `snapshot()`. If no `snapshot()` has been taken, this
            /// function return the stack to its initial state.
            pub fn restore(&mut self) {
                match self.lengths.pop() {
                    Some((len_stack, remained)) => {
                        if remained < self.cache.len() {
                            // Remove those elements that are pushed after the snapshot.
                            self.cache.truncate(remained);
                        }
                        if len_stack > remained {
                            let rewind_count = len_stack - remained;
                            let new_len = self.popped.len() - rewind_count;
                            let recovered_elements = self.popped.drain(new_len..);
                            self.cache.extend(recovered_elements.rev());
                            debug_assert_eq!(self.popped.len(), new_len);
                        }
                    }
                    None => {
                        self.cache.clear();
                        // As `self.popped` and `self.lengths` should already be empty,
                        // there is no need to clear it.
                        debug_assert!(self.popped.is_empty());
                        debug_assert!(self.lengths.is_empty());
                    }
                }
            }
        }

        impl<T: Clone> Index<Range<usize>> for Stack<T> {
            type Output = [T];

            fn index(&self, range: Range<usize>) -> &[T] {
                self.cache.index(range)
            }
        }
    }

    pub mod token
    {
        use ::
        {
            *,
        };
        

        use crate::position::Position;

        /// A token generated by a `Parser`.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub enum Token<'i, R> {
            /// The starting `Position` of a matched `Rule`
            Start {
                /// matched rule
                rule: R,
                /// starting position
                pos: Position<'i>,
            },
            /// The ending `Position` of a matched `Rule`
            End {
                /// matched rule
                rule: R,
                /// ending position
                pos: Position<'i>,
            },
        }
    }
    
    pub mod unicode
    {
        //! Character inclusion in binary or General_Category value Unicode sets.
        use ::
        {
            boxed::{ Box },
            *,
        };
        
        macro_rules! property_functions {
            ($module:ident, $property_names:ident, [$(
                $prop:ident,
            )*]) => {
                #[allow(unused)]
                mod $module;
                // unicode::ALPHABETIC('a')
                $(pub fn $prop(c: char) -> bool {
                    self::$module::$prop.contains_char(c)
                })*

                pub static $property_names: &[&str] = &[
                    $(stringify!($prop),)*
                ];
            };
        }

        macro_rules! char_property_functions {
            // For define custom property names
            {$(
                mod $module:ident;
                static $property_names:ident = [$(
                    $prop:ident,
                )*];
            )*} => {$(
                property_functions!($module, $property_names, [$(
                    $prop,
                )*]);
            )*};
            // For define property by copy BY_NAME values from `ucd-generate` generated.
            {$(
                mod $module:ident;
                static $property_names:ident = [$(
                    ($_name:tt, $prop:ident),
                )*];
            )*} => {$(
                property_functions!($module, $property_names, [$(
                    $prop,
                )*]);
            )*};
        }

        char_property_functions! {
            mod binary {
                // DO NOT EDIT THIS FILE. IT WAS AUTOMATICALLY GENERATED BY:
                //
                //   ucd-generate property-bool --trie-set ./target/ucd/
                //
                // Unicode version: 16.0.0.
                //
                // ucd-generate 0.3.1 is available on crates.io.

                pub const BY_NAME: &'static [(&'static str, &'static ::ucd_trie::TrieSet)] = &[
                ("ASCII_Hex_Digit", ASCII_HEX_DIGIT), ("Alphabetic", ALPHABETIC),
                ("Bidi_Control", BIDI_CONTROL), ("Bidi_Mirrored", BIDI_MIRRORED),
                ("Case_Ignorable", CASE_IGNORABLE), ("Cased", CASED),
                ("Changes_When_Casefolded", CHANGES_WHEN_CASEFOLDED),
                ("Changes_When_Casemapped", CHANGES_WHEN_CASEMAPPED),
                ("Changes_When_Lowercased", CHANGES_WHEN_LOWERCASED),
                ("Changes_When_Titlecased", CHANGES_WHEN_TITLECASED),
                ("Changes_When_Uppercased", CHANGES_WHEN_UPPERCASED), ("Dash", DASH),
                ("Default_Ignorable_Code_Point", DEFAULT_IGNORABLE_CODE_POINT),
                ("Deprecated", DEPRECATED), ("Diacritic", DIACRITIC), ("Emoji", EMOJI),
                ("Emoji_Component", EMOJI_COMPONENT), ("Emoji_Modifier", EMOJI_MODIFIER),
                ("Emoji_Modifier_Base", EMOJI_MODIFIER_BASE),
                ("Emoji_Presentation", EMOJI_PRESENTATION),
                ("Extended_Pictographic", EXTENDED_PICTOGRAPHIC), ("Extender", EXTENDER),
                ("Grapheme_Base", GRAPHEME_BASE), ("Grapheme_Extend", GRAPHEME_EXTEND),
                ("Grapheme_Link", GRAPHEME_LINK), ("Hex_Digit", HEX_DIGIT),
                ("Hyphen", HYPHEN), ("IDS_Binary_Operator", IDS_BINARY_OPERATOR),
                ("IDS_Trinary_Operator", IDS_TRINARY_OPERATOR),
                ("IDS_Unary_Operator", IDS_UNARY_OPERATOR),
                ("ID_Compat_Math_Continue", ID_COMPAT_MATH_CONTINUE),
                ("ID_Compat_Math_Start", ID_COMPAT_MATH_START),
                ("ID_Continue", ID_CONTINUE), ("ID_Start", ID_START),
                ("Ideographic", IDEOGRAPHIC), ("InCB", INCB),
                ("Join_Control", JOIN_CONTROL),
                ("Logical_Order_Exception", LOGICAL_ORDER_EXCEPTION),
                ("Lowercase", LOWERCASE), ("Math", MATH),
                ("Modifier_Combining_Mark", MODIFIER_COMBINING_MARK),
                ("Noncharacter_Code_Point", NONCHARACTER_CODE_POINT),
                ("Other_Alphabetic", OTHER_ALPHABETIC),
                ("Other_Default_Ignorable_Code_Point", OTHER_DEFAULT_IGNORABLE_CODE_POINT),
                ("Other_Grapheme_Extend", OTHER_GRAPHEME_EXTEND),
                ("Other_ID_Continue", OTHER_ID_CONTINUE),
                ("Other_ID_Start", OTHER_ID_START), ("Other_Lowercase", OTHER_LOWERCASE),
                ("Other_Math", OTHER_MATH), ("Other_Uppercase", OTHER_UPPERCASE),
                ("Pattern_Syntax", PATTERN_SYNTAX),
                ("Pattern_White_Space", PATTERN_WHITE_SPACE),
                ("Prepended_Concatenation_Mark", PREPENDED_CONCATENATION_MARK),
                ("Quotation_Mark", QUOTATION_MARK), ("Radical", RADICAL),
                ("Regional_Indicator", REGIONAL_INDICATOR),
                ("Sentence_Terminal", SENTENCE_TERMINAL), ("Soft_Dotted", SOFT_DOTTED),
                ("Terminal_Punctuation", TERMINAL_PUNCTUATION),
                ("Unified_Ideograph", UNIFIED_IDEOGRAPH), ("Uppercase", UPPERCASE),
                ("Variation_Selector", VARIATION_SELECTOR), ("White_Space", WHITE_SPACE),
                ("XID_Continue", XID_CONTINUE), ("XID_Start", XID_START),
                ];

                pub const ASCII_HEX_DIGIT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0x7E0000007E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const ALPHABETIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3, 0, 0xBCDFFFF800000020,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF027FFFFF, 0xBFFF0000000001FF,
                    0x787FFFFFF00B6, 0xFFFFFFFF07FF0000, 0xFFFFC000FEFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x9C00E1FE1FEFFFFF, 0xFFFFFFFFFFFF0000,
                    0xFFFFFFFFFFFFE000, 0x3FFFFFFFFFFFF, 0x43007FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36,
                    36, 36, 37, 38, 39, 40, 41, 42, 43, 44, 36, 36, 36, 36, 36, 36, 36, 36,
                    45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
                    63, 64, 65, 66, 67, 68, 69, 70, 71, 36, 36, 36, 72, 36, 36, 36, 36, 73,
                    74, 75, 76, 31, 77, 78, 31, 79, 80, 81, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 82, 83, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 36, 36, 36,
                    84, 85, 86, 87, 88, 89, 31, 31, 31, 31, 31, 31, 31, 90, 44, 91, 92, 93,
                    36, 94, 95, 31, 31, 31, 31, 31, 31, 31, 31, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 31, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 96, 97, 36, 36, 36, 36, 98,
                    99, 36, 100, 101, 36, 102, 103, 104, 105, 36, 106, 107, 108, 109, 110, 68,
                    111, 112, 113, 114, 115, 36, 116, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 117, 118, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 36, 36, 36, 36, 36, 119, 36, 120,
                    121, 122, 123, 124, 36, 36, 36, 36, 125, 33, 126, 127, 31, 128, 36, 129,
                    130, 131, 112, 132,
                ],
                tree2_level2: &[
                    0x1FFFFCFFFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00807EFF,
                    0xFFFF03F8FFF003FF, 0xEFFFFFFFFFFFFFFF, 0xFFFE000FFFE1DFFF,
                    0xE3C5FDFFFFF99FEF, 0x1003000FB080599F, 0xC36DFDFFFFF987EE,
                    0x3F00005E021987, 0xE3EDFDFFFFFBBFEE, 0x1E00000F00011BBF,
                    0xE3EDFDFFFFF99FEE, 0x2000FB0C0199F, 0xC3FFC718D63DC7EC, 0x811DC7,
                    0xE3FFFDFFFFFDDFFF, 0xF27601DDF, 0xE3EFFDFFFFFDDFEF, 0xE000F60601DDF,
                    0xE7FFFFFFFFFDDFFF, 0xFC00000F80F05DDF, 0x2FFBFFFFFC7FFFEE,
                    0xC0000FF5F807F, 0x7FFFFFFFFFFFFFE, 0x207F, 0x3BFFFFAFFFFFF7D6,
                    0xF000205F, 0x1, 0xFFFE1FFFFFFFFEFF, 0x1FFFFFFFFEFFFF0F, 0,
                    0xF97FFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFF3C00FFFF,
                    0xF7FFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF,
                    0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x7FFFFFF,
                    0xFFFFFFFF0000FFFF, 0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF,
                    0xFFFFF800FFFFF, 0xDDFFF000FFFFF, 0xFFCFFFFFFFFFFFFF, 0x108001FF,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFFF, 0xFFFF07FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0x1FF0FFF7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF,
                    0x3FF, 0xFFFFFFFF0FFFFFFF, 0x1FFFFE7FFFFFFF, 0x8000008000000000, 0x7001,
                    0xFFEFFFFFFFFFFFFF, 0x1FEF, 0xFC00F3FFFFFFFFFF, 0x3FFBFFFFFFFFF,
                    0x7FFFFFFFFFFFFF, 0x3FFFFFFFFC00E000, 0xE7FFFFFFFFFF07FF,
                    0x46FDE0000000000, 0x1FFFFFFFF80000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF3FFBD503E2FFC84, 0xFFFFFFFF000043E0,
                    0x1FF, 0xFFC0000000000000, 0x3FFFFFFFFFF, 0xC781FFFFFFFFF,
                    0xFFFF20BFFFFFFFFF, 0x80FFFFFFFFFF, 0x7F7F7F7F007FFFFF,
                    0xFFFFFFFF7F7F7F7F, 0x800000000000, 0x1F3E03FE000000E0,
                    0xFFFFFFFEE07FFFFF, 0xF7FFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFE0,
                    0xFFFFFFFF00007FFF, 0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000,
                    0xC00FFFF1FFF, 0x8FF07FFFFFFFFFFF, 0xFFFFFFFFFFFF, 0xFFFFFFFCFF800000,
                    0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0xFFFFFFFFBF, 0xFFFFFFFFFFFFF,
                    0xE8FC00000000002F, 0xFFFF07FFFFFFFC00, 0x1FFFFFFF0007FFFF,
                    0xFFF7FFFFFFFFFFFF, 0x7C00FFFF00008000, 0xFC7FFFFF00003FFF,
                    0x7FFFFFFFFFFFFFFF, 0x3CFFFF38000005, 0xFFFF7F7F007E7E7E,
                    0xFFFF03FFF7FFFFFF, 0x7FFFFFFFFFF, 0xFFFF000FFFFFFFFF, 0xFFFFFFFFFFFF87F,
                    0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFE0F8007F, 0xFFFFFFFFFFFFFFDB,
                    0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000, 0x3FFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFCFFFF, 0xFFF0000000000FF, 0xFFDF000000000000,
                    0x1FFFFFFFFFFFFFFF, 0x7FFFFFE00000000, 0xFFFFFFC007FFFFFE, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 5, 11, 12, 13, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 14, 15, 16, 7, 17, 18, 7, 19, 20, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15,
                    16, 17, 2, 2, 2, 2, 18, 19, 20, 4, 21, 22, 23, 24, 25, 4, 26, 4, 27, 28,
                    29, 30, 31, 32, 33, 4, 2, 34, 35, 35, 36, 37, 38, 4, 4, 4, 39, 40, 41, 42,
                    43, 44, 2, 45, 46, 47, 35, 48, 2, 49, 50, 51, 52, 53, 54, 55, 56, 57, 2,
                    58, 2, 59, 4, 4, 60, 61, 62, 63, 64, 4, 65, 66, 4, 4, 46, 4, 67, 68, 69,
                    70, 71, 72, 73, 74, 75, 46, 4, 4, 4, 76, 77, 78, 79, 4, 80, 81, 82, 4, 4,
                    4, 4, 83, 84, 85, 86, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 87, 4,
                    2, 88, 2, 2, 2, 89, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 74, 90,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 91, 92, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 66, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 88,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 46, 93, 62, 94, 91, 95, 96, 4, 4, 4, 4, 4,
                    4, 97, 4, 4, 4, 2, 4, 4, 2, 98, 99, 100, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 101, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 102, 34, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 103, 2, 2, 2, 2, 104, 105, 2, 2, 2, 2, 2, 106, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 107, 108, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 109, 110, 111,
                    112, 113, 2, 2, 2, 2, 114, 115, 116, 117, 118, 119, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 120, 4, 4,
                    4, 121, 122, 123, 4, 124, 125, 4, 4, 4, 4, 94, 126, 4, 4, 4, 4, 4, 4, 4,
                    127, 4, 4, 4, 128, 4, 4, 4, 4, 4, 4, 4, 129, 2, 2, 2, 130, 2, 131, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 132, 133, 134, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 135, 136, 137, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 138, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 139, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 140, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 141, 2, 2, 2, 2, 2, 2, 2, 2, 2, 142, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 142, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 143, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 91, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF,
                    0x7FFFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F, 0xFFFF00003FFFFFFF,
                    0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF, 0xF7FF000FFFFFFFFF,
                    0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                    0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF,
                    0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEFF06F,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF, 0xFFFFFFFFFF,
                    0xFFFF823FFFFFFC00, 0x3F, 0x31BFFFFFFFFFF, 0x100000000000001C,
                    0xFFFF00801FFFFFFF, 0xFFFF00000000003F, 0xFFFF000000000003,
                    0x7FFFFF0000001F, 0x3E00000000003F, 0x1FFFFFFFFFFFFFF, 0x1FFFFFF0004,
                    0x47FFFFFFFF00F0, 0x1400C01E, 0xC09FFFFFFFFBFFFF, 0x3, 0xFFFF01FFBFFFBD7F,
                    0x1FFFFFFFFFF, 0xE3EDFDFFFFF99FEF, 0xFE081199F, 0xFFBFFFFFFFFF4BFF,
                    0xA37A5, 0x3800007BB, 0xB3, 0x7F3FFFFFFFFFFFFF, 0x3F000000,
                    0x7FFFFFFFFFFFFFFF, 0x11, 0x13FFFFFFFFFFFFF, 0x7FFE7FFFFFF, 0x7F,
                    0xFFFFFFFF00000000, 0x80000000FFFFFFFF, 0x99BFFFFFFF6FF27F, 0x7,
                    0xFFFFFCFF00000000, 0x1AFCFFFFFF, 0x7FE7FFFFFFFFFFFF, 0xFFFFFFFFFFFF0000,
                    0xFFFF000020FFFFFF, 0x1FFFFFFFF, 0x7F7FFFFFFFFFFDFF, 0xFFFC000000000001,
                    0x7FFEFFFFFCFFFF, 0xB47FFFFFFFFFFB7F, 0xFFFFFDBF000000CB, 0x17B7FFF,
                    0x7FFFFF00000000, 0xC7FFFFFFFFFDFFFF, 0x1, 0x1000000000000, 0x3FFFFFF,
                    0x7FFFFFFFFFFF, 0xF, 0x1FFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0xFFFFFFFF0000007E,
                    0xFFFF00007FFFFFFF, 0x3FFFFFFF0000, 0xE0FFFFF80000000F, 0xFFFF,
                    0x1FFFFFFFFFFF, 0xFFFFFFFFFFFF87FF, 0xFFFF80FF, 0x3000B00000000,
                    0xFFFFFFFFFFFFFF, 0x80000000003FFFFF, 0x6FEF000000000000, 0x40007FFFFFFFF,
                    0xFFFF00F000270000, 0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x43FF01FF,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFFFF, 0xFFFF07DBF9FFFF7F,
                    0x3FFFFFFFFFFF, 0x8000, 0x3F801FFFFFFFFFFF, 0x4000, 0xFFFFFFFFFFF,
                    0xFFFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F, 0x88F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF,
                    0xFFFF000000000000, 0xFFFF03FFFFFF03FF, 0x3FF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const BIDI_CONTROL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x10000000, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7C000000C000, 0x3C000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BIDI_MIRRORED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x5000030000000000, 0x2800000028000000, 0x800080000000000, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0,
                    0, 6, 0, 0, 7, 8, 9, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 12, 0, 13, 0, 0, 0, 0, 0, 0, 14, 15, 16, 17, 18, 19, 0, 0, 0, 20, 0, 0,
                    0, 0, 0, 0, 0, 0, 21, 22, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 25, 26, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3C00000000000000, 0x18000000, 0x600000000000000, 0x6000000000000060,
                    0x6000, 0x1, 0xFA0FF857BC623F1E, 0xFFFFEFF5803C1FFF, 0xC1FFFFCC01079FFF,
                    0xFFFF3FFFFFC33E00, 0x60300000F00, 0x3FFF0000000000, 0xFFFC70783B79,
                    0x100FFFDF9FFFFF8, 0x33F0033A1F37C23F, 0x70307A53DFFFFC00,
                    0xFE19BC3001800000, 0xFFFFBFCFFFFFFFFF, 0x2F88707C507FFFFF,
                    0x4000000000000000, 0x3FF3000363C, 0x1FE00000, 0xFF3FF00, 0x307E000000,
                    0x2800000050000300, 0xDA8000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x8000000, 0x200000, 0x8000, 0x200, 0x8,
                ],
                };

                pub const CASE_IGNORABLE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x400408000000000, 0x140000000, 0x190A10000000000, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFF000000000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x430FFFFFFFFFFFF, 0xB0, 0, 0, 0, 0x3F8, 0, 0, 0x82000000,
                    0xBFFFFFFFFFFE0000, 0x100000000000B6, 0x17FF003F, 0x10000FFFFF801, 0,
                    0x3DFFBFC00000, 0xFFFF000000028000, 0x7FF, 0x1FFC000000000,
                    0x243FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 10, 11, 12, 13, 14, 15, 16, 11, 17, 18,
                    19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 35, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 36, 37, 38, 39, 40, 41, 42, 34, 43, 34, 34, 34, 44, 45, 46,
                    47, 48, 49, 50, 51, 52, 53, 34, 54, 55, 56, 57, 58, 34, 34, 34, 34, 34,
                    34, 59, 60, 61, 62, 63, 64, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 65, 34,
                    66, 34, 67, 34, 68, 69, 34, 34, 34, 34, 34, 34, 34, 70, 34, 71, 72, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 73, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 53, 34, 34, 34, 34, 74,
                    75, 76, 77, 78, 79, 80, 81, 82, 34, 34, 83, 84, 85, 86, 87, 88, 89, 90,
                    91, 34, 92, 34, 93, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 94, 34, 95,
                    96, 34, 34, 34, 34, 34, 34, 34, 34, 97, 98, 34, 99, 100, 101, 102, 103,
                ],
                tree2_level2: &[
                    0x3FFFFFC00000, 0xE000000, 0xFF830100, 0xFFFFFFFFFFFFFE00,
                    0x1400000000000007, 0x2000C00FE21FE, 0x1000000000000002,
                    0x4000000C0000201E, 0x1000000000000006, 0x23000000023986,
                    0xFC00000C000021BE, 0x9000000000000002, 0xC0060201E, 0x4, 0x2001,
                    0xD000000000000011, 0xC00603DC1, 0xC00003040, 0x1800000000000003,
                    0xC0000201E, 0x2, 0x5C0400, 0x7F2000000000000, 0x7FC0, 0x1FF2000000000000,
                    0x7F40, 0x2A0000003000000, 0x7FFE000000000000, 0x1FFFFFFFFEFFE0DF, 0x40,
                    0x66FDE00000000000, 0x1E0001C3000000, 0x20002064, 0x1000000000000000, 0,
                    0xE0000000, 0xC0000001C0000, 0xC0000000C0000, 0x3FB0000000000000,
                    0x208FFE40, 0xF800, 0x8, 0x20000000060, 0xE04018700000000, 0x9800000,
                    0x9FF81FE57F400000, 0xFFFF008000000000, 0x7FFF, 0x17D000000000000F,
                    0xFF80000000004, 0x3B3C00000003, 0x3A34000000000, 0xCFF00000000000,
                    0x3F00000000000000, 0x31021FDFFF70000, 0xFFFFF00000000000,
                    0x10007FFFFFFFFFF, 0xFFFFFFFFF8000000, 0xFFFFFFFFFFFFFFFF,
                    0xA000000000000000, 0x6000E000E000E003, 0x7C900300F800,
                    0x8002FFDF00000000, 0x1FFF0000, 0x1FFFFFFFF0000, 0x3000000000000000,
                    0x3800000000000, 0x8000800000000000, 0xFFFFFFFF00000000, 0x800000000000,
                    0x83E3C0000000020, 0x7E000000, 0x7000000000000000, 0x200000, 0x1000,
                    0xBFF7800000000000, 0xF0000000, 0x3000000000000, 0x3FFFFFFFF,
                    0x1000000000000, 0x700, 0x31C000000000000, 0x106000000844,
                    0x8003FFFF00000030, 0x3FC000000000, 0x3FF80, 0x33C8000000000007,
                    0x6000008000, 0x667E0000000000, 0x1001000000001008, 0xC19D000000000000,
                    0x58300020000002, 0xE00F8000000, 0x212000000000, 0x40000000,
                    0xFFFC000000000000, 0x7, 0xFFFF0008FFFF, 0x240000, 0x8000000000000000,
                    0x4000000004004080, 0x1000000000001, 0xC0000000, 0xE00000800000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 5, 6, 7, 8, 9, 10, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 6, 0, 0, 0, 0, 0, 0,
                    0, 0, 7, 8, 0, 0, 0, 0, 9, 10, 0, 11, 12, 0, 13, 14, 15, 16, 17, 18, 19,
                    20, 21, 22, 0, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 32, 33, 34, 35,
                    36, 0, 37, 0, 0, 0, 38, 0, 0, 0, 39, 40, 0, 41, 42, 43, 44, 0, 0, 0, 0, 0,
                    45, 0, 46, 0, 47, 48, 49, 0, 0, 0, 0, 50, 51, 52, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    53, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 58, 0, 0, 0,
                    0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 60, 61, 62, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 65, 66, 0, 0, 0, 0, 0, 0, 0, 67, 68, 0, 0, 69, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 70, 71, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 73, 74, 60, 0, 75, 0, 0, 0, 0, 0, 76, 77, 0, 0, 0, 0, 0, 0, 0,
                    78, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 81, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 83, 0, 0, 83, 83, 83, 84, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x7FDFFFFFFFFFFBF,
                    0x870000000000F06E, 0x6000000000, 0xF000000000, 0xBE0000004000,
                    0x180000000000, 0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000002,
                    0x801900000000007F, 0x2678000000000003, 0x2004, 0x1FEF8000000007,
                    0x8000000000000, 0x7FC0000000000003, 0x9E00, 0x40D3800000000000, 0x2,
                    0x7F880000000, 0x1800000000000003, 0x1F1FC000000001, 0xF800000000000000,
                    0x600054001, 0xFF00000000000000, 0x4000005C, 0x85F8000000000000, 0xD,
                    0xB03C000000000000, 0x30000001, 0xA7F8000000000000, 0x1, 0xBF280000000000,
                    0xFBCA0000000, 0x6FF800000000000, 0x5800000000000000, 0x8, 0x10CF00000,
                    0x79F80000000007FE, 0xE7E0080, 0x37FFC00, 0xBF7F000000000000,
                    0x6DFCFFFFFC0000, 0xB47E000000000000, 0xBF, 0xA30000, 0x18000000000000,
                    0x7C0000000000003, 0x4000005, 0xFFFF000000000000, 0x3FFF81,
                    0xE3FFC0000000, 0x1F000000000000, 0x7F000000000000, 0xF, 0x180000000007,
                    0x8000, 0xFFFF8000, 0x1B00000000, 0x6FEF000000000000, 0xF60000000,
                    0xFFFF3FFFFFFFFFFF, 0x7F, 0xFFF8038000000000, 0x3C0000000FE7, 0x1C,
                    0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0xFFFF07DBF9FFFF7F,
                    0x3FFFFFFFFFFF, 0x3FFF000000000000, 0x400000000000, 0xF00000000000,
                    0xF80000000000, 0xC00000000000, 0x7F0000, 0xFF0, 0xFFFFFFFF00000002,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const CASED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xF7FFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFF0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x1FFFFFFFFEFFFFF, 0x1F00000003, 0, 0xBCCF000000000020,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF007FFFFF, 0x1FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 5, 5, 0, 5, 5, 5, 5, 6, 7, 8, 9, 0, 10, 11,
                    0, 12, 13, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 16, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5,
                    17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 5, 22, 23, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 24, 25, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xF7FFFFFFFFFF20BF, 0x3F3FFFFFFFFFFFFF,
                    0xE7FFFFFFFFFF07FF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF21FBD503E2FFC84, 0xFFFFFFFF000043E0,
                    0x18, 0xFFC0000000000000, 0x3FFFFFFFFFF, 0xC781FFFFFFFFF, 0x20BFFFFFFFFF,
                    0x3FFFFFFFFFFF, 0x3FFFFFFF, 0xFFFFFFFC00000000, 0xFFFFFFFFFFFF78FF,
                    0x77C00001FEB3FFF, 0xFFFF000000000000, 0xFFFF03FFF7FFFFFF, 0xF8007F,
                    0x7FFFFFE00000000, 0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 5, 6, 0, 0,
                    0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    8, 8, 0, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    11, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 13, 14, 15, 16, 17, 1, 1, 1, 1, 18, 19, 20, 21, 22, 23, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24,
                    0, 0, 0, 3, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 26, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
                    27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF, 0xFFFF000000000000, 0xFFFFFFFFF0FFFFF,
                    0xF7FF000000000000, 0x1BFBFFFBFFB7F7FF, 0x7FDFFFFFFFFFFB9,
                    0x7FFFFFFFFFFFF, 0xFFFF003FFFFF0000, 0x3F, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFBFF, 0x3FFFFFFFFFFF, 0xF,
                    0xFFFF03FFFFFF03FF, 0x3FF,
                ],
                };

                pub const CHANGES_WHEN_CASEFOLDED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE, 0x20000000000000, 0xFF7FFFFF, 0xAA55555555555555,
                    0xAB555555555556AA, 0x11AED2D5B1DBCED6, 0x55D655554AAAADB0,
                    0x6C05555555555555, 0x557A, 0, 0, 0, 0x8045000000000020, 0xFFBFFFED740,
                    0xE6B3555555638004, 0xFFFFFFFFFFFF, 0x5555555500000000,
                    0x5555555555555401, 0x5555555555552AAB, 0xFFFE555555555555, 0x7FFFFF,
                    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 11, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17,
                    5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0,
                    0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x20BF, 0x3F00000000000000, 0xE7FFFFFFFFFF03FF,
                    0x5555555555555555, 0x555555554C155555, 0xFF00FF003F00FF00,
                    0xFF00AA003F00, 0x1F9CFFFFFFFFFFFF, 0x1F9C1F000F001F9C, 0x40C4000000000,
                    0xFFFF00000000, 0x8, 0xFFC0000000000000, 0xFFFF, 0xFFFFFFFFFFFF,
                    0xC025EA9D00000000, 0x4280555555555, 0x155555555555, 0x5555555,
                    0x5554555400000000, 0x6A00555555555555, 0x555F7D5555452855,
                    0x20000015411AF5, 0xFFFF000000000000, 0xFFFFFFFFFFFFFFFF, 0xF8007F,
                    0x7FFFFFE00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF, 0xFFFF000000000000, 0xFFFFF, 0xF7FF000000000000,
                    0x37F7FF, 0x7FFFFFFFFFFFF, 0x3FFFFF0000, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0x3FFFFFFFF,
                ],
                };

                pub const CHANGES_WHEN_CASEMAPPED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x20000000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFEFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xB3FFF3FFFFFFDFFF,
                    0xFFFFFFFFFFFFFFF0, 0xFC0FFFFDFFFFFFFF, 0x20269F7B1ADFFFFF, 0x60041F8D, 0,
                    0, 0xB8CF000000000020, 0xFFFFFFFBFFFFD740, 0xEFBFFFFFFFE3FFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03,
                    0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF, 0xFFFFFFFE007FFFFF, 0xFF, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 6, 0, 7, 7, 8, 7, 9, 10, 11, 12, 0, 0, 0,
                    0, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 18,
                    7, 19, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22, 0, 23, 24, 25, 26, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 30, 0,
                    0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xE7FFFFFFFFFF20BF, 0x3F3FFFFFFFFFFFFF,
                    0xE7FFFFFFFFFF07FF, 0x2200000000000000, 0x4000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFF4FFFFFFF, 0xFFFFFFFF3F3FFFFF, 0x3FFFFFFFAAFF3F3F,
                    0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC, 0x40C4000000000,
                    0xFFFFFFFF00004000, 0x18, 0xFFC0000000000000, 0x3FFFFFFFFFF,
                    0xC06DFFFFFFFFFFFF, 0xC780FFFFFFFFF, 0x20BFFFFFFFFF, 0x3FFFFFFFFFFF,
                    0xFFFFFFF, 0xFFFCFFFC00000000, 0xFE00FFFFFFFFFFFF, 0xFFFF7FFFFFDF38FF,
                    0x6000001FC33FFF, 0xFFFF000000080000, 0xF8007F, 0x7FFFFFE00000000,
                    0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 5, 6, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    7, 7, 0, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,
                    11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 12, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF, 0xFFFF000000000000, 0xFFFFFFFFF0FFFFF,
                    0xF7FF000000000000, 0x1BFBFFFBFFB7F7FF, 0x7FFFFFFFFFFFF,
                    0xFFFF003FFFFF0000, 0x3F, 0xFFFFFFFF00000000, 0xFFFFFFFF, 0xF,
                ],
                };

                pub const CHANGES_WHEN_LOWERCASED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE, 0, 0x7F7FFFFF, 0xAA55555555555555, 0x2B555555555554AA,
                    0x11AED2D5B1DBCED6, 0x55D655554AAAADB0, 0x6C05555555555555, 0x557A, 0, 0,
                    0, 0x8045000000000000, 0xFFBFFFED740, 0xE690555555008000, 0xFFFFFFFFFFFF,
                    0x5555555500000000, 0x5555555555555401, 0x5555555555552AAB,
                    0xFFFE555555555555, 0x7FFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 11, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17,
                    5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x20BF, 0x3FFFFFFFFFFFFF, 0xE7FFFFFFFFFF0200,
                    0x5555555555555555, 0x5555555540155555, 0xFF00FF003F00FF00,
                    0xFF00AA003F00, 0x1F00FF00FF00FF00, 0x1F001F000F001F00, 0x40C4000000000,
                    0xFFFF00000000, 0x8, 0xFFC0000000000000, 0xFFFF, 0xFFFFFFFFFFFF,
                    0xC025EA9D00000000, 0x4280555555555, 0x155555555555, 0x5555555,
                    0x5554555400000000, 0x6A00555555555555, 0x555F7D5555452855,
                    0x20000015411AF5, 0x7FFFFFE00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF, 0xFFFF000000000000, 0xFFFFF, 0xF7FF000000000000,
                    0x37F7FF, 0x7FFFFFFFFFFFF, 0x3FFFFF0000, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0x3FFFFFFFF,
                ],
                };

                pub const CHANGES_WHEN_TITLECASED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE00000000, 0x20000000000000, 0xFF7FFFFF80000000,
                    0x54AAAAAAAAAAAAAA, 0xD4AAAAAAAAAAAB55, 0xA251212A4E241129,
                    0xAA2BAAAAB55556D0, 0x900AAAA8AAAAAAAA, 0x20269F7B1ADFAA85, 0x60041F8D, 0,
                    0, 0x388A000000000020, 0xFFFFF00000010000, 0x92FAAAAAAE37FFF,
                    0xFFFF000000000000, 0xAAAAAAAAFFFFFFFF, 0xAAAAAAAAAAAAA802,
                    0xAAAAAAAAAAAAD554, 0xAAAAAAAAAAAA, 0xFFFFFFFE00000000, 0xFF, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 4, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 0, 11, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 5,
                    16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 19, 0, 20, 21, 22, 23, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3F00000000000000, 0x5FF, 0x2200000000000000, 0x4000,
                    0xAAAAAAAAAAAAAAAA, 0xAAAAAAAA0FEAAAAA, 0xFF00FF003F00FF,
                    0x3FFF00FF00FF003F, 0x40DF00FF00FF00FF, 0xDC00FF00CF00DC,
                    0xFFFF000000004000, 0x10, 0x3FFFFFF0000, 0xFFFF000000000000,
                    0x481562FFFFFFFF, 0x8500AAAAAAAAA, 0x20BFFFFFFFFF, 0x2AAAAAAAAAAA,
                    0xAAAAAAA, 0xAAA8AAA800000000, 0x9400AAAAAAAAAAAA, 0xAAA002AAAA9A10AA,
                    0x4000000A82250A, 0xFFFF000000080000, 0xFFFFFFFFFFFFFFFF, 0xF8007F,
                    0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFF0000000000, 0xFFFF, 0xFFFFFFFFF000000, 0x1BFBFFFBFF800000,
                    0x7FFFFFFFFFFFF, 0xFFFF000000000000, 0x3F, 0xFFFFFFFF, 0xFFFFFFFF00000000,
                    0xFFFFFFFC00000000, 0xF,
                ],
                };

                pub const CHANGES_WHEN_UPPERCASED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE00000000, 0x20000000000000, 0xFF7FFFFF80000000,
                    0x54AAAAAAAAAAAAAA, 0xD4AAAAAAAAAAAB55, 0xA251212A4E241129,
                    0xAA2DAAAAB5555B60, 0x900AAAA8AAAAAAAA, 0x20269F7B1ADFAA85, 0x60041F8D, 0,
                    0, 0x388A000000000020, 0xFFFFF00000010000, 0x92FAAAAAAE37FFF,
                    0xFFFF000000000000, 0xAAAAAAAAFFFFFFFF, 0xAAAAAAAAAAAAA802,
                    0xAAAAAAAAAAAAD554, 0xAAAAAAAAAAAA, 0xFFFFFFFE00000000, 0xFF, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 5, 0, 6, 6, 7, 6, 8, 9, 10, 11, 0, 0, 0,
                    0, 0, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 16, 6,
                    17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xE7FFFFFFFFFF0000, 0x3F00000000000000, 0x5FF, 0x2200000000000000,
                    0x4000, 0xAAAAAAAAAAAAAAAA, 0xAAAAAAAA0FEAAAAA, 0xFF00FF003F00FF,
                    0x3FFF00FF00FF003F, 0x50DFFFFFFFFFFFFF, 0x10DC00FF00CF10DC,
                    0xFFFF000000004000, 0x10, 0x3FFFFFF0000, 0xFFFF000000000000,
                    0x481562FFFFFFFF, 0x8500AAAAAAAAA, 0x20BFFFFFFFFF, 0x2AAAAAAAAAAA,
                    0xAAAAAAA, 0xAAA8AAA800000000, 0x9400AAAAAAAAAAAA, 0xAAA002AAAA9A10AA,
                    0x4000000A82250A, 0xFFFF000000080000, 0xFFFFFFFFFFFFFFFF, 0xF8007F,
                    0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFF0000000000, 0xFFFF, 0xFFFFFFFFF000000, 0x1BFBFFFBFF800000,
                    0x7FFFFFFFFFFFF, 0xFFFF000000000000, 0x3F, 0xFFFFFFFF, 0xFFFFFFFF00000000,
                    0xFFFFFFFC00000000, 0xF,
                ],
                };

                pub const DASH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0x4000000000000400, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0,
                    0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 7, 8, 0, 0, 0, 0, 0, 0, 9, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 0, 0, 13, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x40, 0x3F0000, 0x800000000080000, 0x800, 0x40000,
                    0xC00000004800000, 0x20000001, 0x1000010000000, 0x100000000,
                    0x6000000000000, 0x801000000, 0x2000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x400000000000, 0x200000000000,
                ],
                };

                pub const DEFAULT_IGNORABLE_CODE_POINT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x8000, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0x10000000, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 8, 0, 0, 9, 10,
                ],
                tree2_level2: &[
                    0, 0x180000000, 0x30000000000000, 0xF800, 0x7C000000F800, 0xFFFF00000000,
                    0x1000000000, 0xFFFF, 0x8000000000000000, 0x100000000, 0x1FF000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level3: &[
                    0, 0xF00000000, 0x7F8000000000000, 0xFFFFFFFFFFFFFFFF,
                ],
                };

                pub const DEPRECATED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0x200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0x8000000000000, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x280000000000000, 0x1800000000, 0xFC0000000000, 0x60000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2,
                ],
                };

                pub const DIACRITIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x140000000, 0x190810000000000, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFF000000000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x4300007E0FF7FFF, 0x30, 0, 0, 0, 0xF8, 0, 0, 0x2000000,
                    0xBFFFFFFBFFFE0000, 0x16, 0, 0x187F800, 0, 0x1C6180000000,
                    0xFFFF000000000000, 0x7FF, 0x1FFC000000000, 0x3FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 4, 6, 4, 6, 4, 7, 4, 8, 1, 6, 4, 6, 4, 6, 9, 6, 1, 10,
                    11, 12, 11, 13, 14, 1, 15, 16, 17, 18, 19, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    20, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21, 1, 1, 22, 1, 1, 1, 1,
                    23, 1, 1, 1, 1, 24, 25, 26, 27, 28, 29, 30, 31, 32, 1, 33, 34, 35, 1, 36,
                    1, 1, 1, 1, 1, 1, 37, 38, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 39, 1, 1, 1, 1, 40, 1, 1, 1, 1, 1, 1, 1, 41,
                    1, 42, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 43,
                    44, 45, 46, 1, 47, 48, 49, 1, 1, 50, 51, 52, 53, 54, 1, 55, 56, 57, 1, 58,
                    1, 59, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 60, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 61, 1, 1, 1, 62, 63, 64, 65,
                ],
                tree2_level2: &[
                    0x3000000, 0, 0xFF000000, 0x7FFFFFF80007FE00, 0x1000000000000000,
                    0x20000001E2000, 0x2000, 0xE000000000002000, 0x202000, 0x1800000000000000,
                    0x400, 0x400000000000000, 0x5F80, 0x1F00, 0xC2A0000003000000, 0xDC, 0x40,
                    0x680000000000000, 0x3E1800000000, 0xC00BF80, 0xE0000000,
                    0x10000000300000, 0x200FFE00, 0xE00000000000000, 0x9FE0000100000000,
                    0x7FFF000000000000, 0xFFE, 0x10000000000000, 0xFF80000000010,
                    0xC0000000000, 0xC004000000000, 0xC0000000000000, 0x3F00000000000000,
                    0x39021FFFFFF0000, 0xFFFFF00000000000, 0x7FFFFFFFFFF, 0xFFE000000000FFF0,
                    0xA000000000000000, 0x6000E000E000E003, 0x3800000000000, 0x800000000000,
                    0xFC0000000000, 0x1E000000, 0xB000800000000000, 0x30000000,
                    0x3000000000000, 0x3FFFFFFFF, 0x700, 0x300000000000000, 0x100000000040,
                    0x3FFFF00000010, 0x780000000000, 0x80000, 0x8000000000000, 0x2000000001,
                    0x3800000000000000, 0x8000000000000000, 0x40000000000007, 0xE00F8000000,
                    0x300000000000, 0x40000000, 0xFFFF00000000, 0x4000000000000000,
                    0x1000000000001, 0xC0000000, 0x800000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 5, 2, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0, 0, 0, 0,
                    0, 0, 5, 6, 0, 0, 0, 0, 0, 7, 0, 8, 9, 0, 0, 10, 11, 0, 12, 13, 0, 14, 15,
                    0, 0, 16, 17, 18, 0, 19, 0, 20, 0, 21, 0, 0, 22, 23, 22, 0, 24, 0, 25, 0,
                    0, 0, 11, 0, 0, 0, 26, 27, 0, 1, 28, 29, 30, 0, 0, 0, 0, 0, 22, 0, 0, 0,
                    0, 31, 32, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 37, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0,
                    0, 0, 0, 0, 0, 0, 39, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 0, 0, 0, 0, 0, 0, 0, 44, 45, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 46, 47, 0, 0, 37, 0, 0, 0, 0, 0, 48, 49, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 52, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x100000000, 0x7FDFFFFFFFFFFBF, 0x8700000000000000, 0x6000000000,
                    0xFC00000000, 0x3E0000004000, 0xE000000000000000, 0x1FFC0, 0x3C,
                    0x1000000000040, 0x600000000000000, 0x18000000000000, 0x8000000000000,
                    0x1C01, 0x60000000000000, 0x60000000000, 0x1800000000000000,
                    0x1F1FC000002000, 0x6000DC000, 0x44, 0xC, 0x8000000000000000, 0x1,
                    0xC0000000000000, 0x80000000000, 0x6000000000000000, 0x8,
                    0x10000000000000, 0x80, 0x2000000, 0x34, 0x800000, 0x4000006, 0x3FFF80,
                    0x800000000000, 0x1F000000000000, 0x7F000000000000, 0x180000000000,
                    0xFFFF8000, 0x3000000000000, 0x6FEF000000000000, 0xFFFF3FFFFFFFFFFF, 0x7F,
                    0xF807E38000000000, 0x3C0000000FE7, 0xFFFF000000000000, 0x3FFFFFFFFFFF,
                    0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x770,
                ],
                };

                pub const EMOJI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF040800000000, 0, 0x420000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    3, 0, 4, 0, 0, 0, 0, 0, 5, 0, 0, 6, 0, 0, 0, 7, 0, 0, 8, 9, 10, 11, 12,
                    13, 14, 15, 16, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 18, 19, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1000000000000000, 0x200, 0x200000400000000, 0x60003F00000,
                    0x1000C000000, 0x70FFE0000008000, 0x4, 0x400C0000000000,
                    0x7800000000000001, 0x700C44D2132401F, 0xC8000169800FFF05,
                    0x60030C831AFC0000, 0x27BF0600001AC130, 0x1801022054BF24, 0x1800B85090,
                    0x8001000200E00000, 0x30000000000000, 0x180000E0, 0x210000,
                    0x2001000000000000, 0x2800000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 4, 5, 6, 7, 0,
                    0, 8, 9, 10, 11, 9, 9, 9, 12, 13, 14, 15, 16, 9, 17, 9, 18, 0, 0, 0, 19,
                    0, 0, 0, 0, 20, 21, 9, 9, 0, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x10, 0x8000, 0xC003000000000000, 0x7FE4000, 0xFFFFFFC000000000,
                    0x7FC800004000006, 0x30000, 0xFFFFFFF3FFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFCECFFFFF, 0xFFB9FFFFFFFFFFFF, 0xBFFFFFFFFFFFFFFF,
                    0x3FFFFFFFFFFFFFFF, 0x7F980FFFFFF7E00, 0x1006013000613C80,
                    0xFC08810A700E001C, 0xFFFF, 0x1FF91A3FF0E7F83F, 0x10FFF00000000,
                    0xF7FFFFFFFFFFF000, 0xFFFFFFFFFFFFFFBF, 0x1FFF000000000000,
                    0xFFFFFFFFFFFF83FF, 0x1FF03FF9FFFC07F,
                ],
                };

                pub const EMOJI_COMPONENT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF040800000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2000, 0x800000000, 0x8000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFC000000000, 0xF800000000000000, 0xF000000000000,
                    0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFF,
                ],
                };

                pub const EMOJI_MODIFIER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF800000000000000,
                ],
                };

                pub const EMOJI_MODIFIER_BASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 3,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x20000000, 0x200000000000000, 0x3C00,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 2, 0, 3, 4, 0, 0, 5, 6, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0,
                    10, 11, 12, 13, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x20, 0x1C9C, 0x11FFFFC00001FFCC, 0x400000280EE, 0x430000000000000,
                    0x610000, 0xF8E0, 0x70000800000000, 0x1001, 0x73FF0040FF009000,
                    0x80000000000000, 0xB60000000000000, 0x3FFEE000, 0x1FF000000000038,
                ],
                };

                pub const EMOJI_PRESENTATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6, 7, 8,
                    9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC000000, 0x91E0000000000, 0x6000000000000000, 0x300000,
                    0x80000000000FFF00, 0x60000C0200080000, 0x242C040000104030, 0x10000000C20,
                    0xB85000, 0x8001000000E00000, 0x18000000, 0x210000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 4, 5, 6, 0,
                    0, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 13, 19, 13, 20, 0, 0, 0,
                    21, 0, 0, 0, 0, 22, 23, 13, 13, 0, 24, 25, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x10, 0x8000, 0x7FE4000, 0xFFFFFFC000000000, 0x77C800004000002,
                    0x30000, 0xFFBFE001FFFFFFFF, 0xDFFFFFFFFFFFFFFF, 0xFFFFFFFF000FFFFF,
                    0xFF11FFFF000F87FF, 0x7FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFD,
                    0xFFFFFFFFFFFFFFFF, 0x9FFFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFF,
                    0x40000FFFFFF7800, 0x1000600000, 0xF800000000000000, 0xFFFF,
                    0x1FF01800F0E7103F, 0x10FFF00000000, 0xF7FFFFFFFFFFF000,
                    0xFFFFFFFFFFFFFFBF, 0x1FFF000000000000, 0xFFFFFFFFFFFF83FF,
                    0x1FF03FF9FFFC07F,
                ],
                };

                pub const EXTENDED_PICTOGRAPHIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x420000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    3, 0, 4, 0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 0, 0, 8, 0, 0, 9, 10, 11, 12, 13,
                    12, 14, 15, 16, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 18, 19, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1000000000000000, 0x200, 0x200000400000000, 0x60003F00000,
                    0x1000C000000, 0x100, 0x70FFE0000008000, 0x4, 0x400C0000000000,
                    0x7800000000000001, 0xFFFFFFFFFFF7FFBF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF003F, 0x1801022057FF3F, 0xF800B85090, 0x8001000200E00000,
                    0x30000000000000, 0x180000E0, 0x210000, 0x2001000000000000, 0x2800000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 1,
                    1, 1, 1, 1, 8, 1, 1, 1, 1, 9, 10, 1, 1, 1, 11, 1, 1, 0, 12, 0, 13, 14, 15,
                    16, 1, 17, 18, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 9,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x80000000E000, 0xC003F00000000000,
                    0xFFFFE00007FE4000, 0x3FFFFFFFFF, 0xF7FC80000400FFFE, 0xFFFFFFFFFFFFFE00,
                    0x7FFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFC0, 0xFFFF,
                    0xFFF0000000000000, 0xFFFFFFFFFFE00000, 0xF000, 0xFC00FF00,
                    0xFFFFC0000000FF00, 0xF7FFFFFFFFFFF000, 0xFFFFFFFFFFFFFFBF,
                ],
                };

                pub const EXTENDER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x80000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0x30000, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0x1, 0, 0, 0, 0, 0, 0x400000000000000,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 7,
                    0, 0, 0, 0, 0, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13,
                    0, 14, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2000000000000, 0x800000000000000, 0x200000, 0x40, 0x400, 0x8,
                    0x8000000000, 0x40000000000000, 0x3E000000000020, 0x60000000,
                    0x7000000000000000, 0x1000, 0x4000008000, 0x1000000000000,
                    0x18000020000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,
                    0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x6, 0x840000004000, 0x80000000000000, 0x20000000, 0xC0000, 0x1C0,
                    0x1000000, 0xC, 0xB00000000, 0x3000000000000000, 0x800000000000, 0x70,
                ],
                };

                pub const GRAPHEME_BASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFFFFFFFF00000000, 0x7FFFFFFFFFFFFFFF, 0xFFFFDFFF00000000,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0,
                    0xFCFF000000000000, 0xFFFFFFFBFFFFD7F0, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC07,
                    0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF, 0xFFFFFFFFFE7FFFFF,
                    0x400000000000E7FF, 0x1F87FFFFFF0049, 0xFFFFFFFFE800FFC0,
                    0xFFFEFFFF000007FF, 0xFFFFFFFFFFFFFFFF, 0xFFFFC260403FFFFF,
                    0xFFFFFFFD3FFF, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF, 0xC7F007FFFFFFFFFF,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36,
                    36, 36, 37, 38, 39, 40, 41, 42, 43, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 44, 45, 46, 47, 48, 49, 50, 45, 51, 52, 53, 54, 55, 56, 57, 58, 59,
                    60, 61, 62, 63, 64, 65, 66, 67, 68, 36, 36, 36, 60, 36, 36, 36, 36, 69,
                    70, 71, 72, 73, 74, 75, 76, 36, 36, 77, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 78, 79, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 80, 81, 36, 36, 36, 36,
                    82, 83, 84, 85, 86, 36, 87, 88, 89, 36, 36, 36, 90, 91, 92, 93, 36, 94,
                    36, 95, 96, 97, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 98, 99, 36, 36, 36, 36, 100,
                    101, 102, 103, 36, 36, 36, 104, 105, 106, 36, 107, 108, 109, 110, 111,
                    112, 113, 114, 115, 116, 55, 36, 117, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 118, 119, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 36, 36, 36, 36, 36, 120, 36,
                    121, 122, 123, 36, 124, 36, 36, 36, 36, 36, 36, 125, 126, 127, 128, 36,
                    129, 92, 36, 130, 131,
                ],
                tree2_level2: &[
                    0x7FFF0110043FFFFF, 0xFFFF07FF41FFFFFF, 0xFFFFFFFF00007FFF, 0x3FF,
                    0xEBFFFFFFFFFFFFF8, 0xFFFFFFF3FF01DE01, 0xA3C5FDFFFFF99FED,
                    0x3FFFFFC3B0005981, 0xC36DFDFFFFF987E8, 0x5CFFC05E000001,
                    0xE3EDFDFFFFFBBFE8, 0x203FFC300011A01, 0x23EDFDFFFFF99FEC,
                    0xFFFFC3B0001981, 0x83FFC718D63DC7E8, 0x7FFFFC000011DC6,
                    0x23FFFDFFFFFDDFEE, 0xFF80FFC32700001E, 0x63EFFDFFFFFDDFFD,
                    0xEFFC36000001A, 0xA7FFFFFFFFFDDFFC, 0xFFFFFFC3FF70DDC1,
                    0x2FFBFFFFFC7FFFEC, 0x1CFFC07F03007F, 0x800DFFFFFFFFFFFE, 0xFFF807F,
                    0x200DFFAFFFFFF7D6, 0xF3FF005F, 0xFD5FFFFFFCFFFFFF, 0x80001FFFFFFFFEFF,
                    0xC000000000001F20, 0x7FFDFBF, 0x99021FFFFFFFFFFF, 0xFFE1FFFE3CFFFFFF,
                    0xFFFFFFFFDFFFDF9B, 0xFFFFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D,
                    0xFFFFFFFFFF3DFFFF, 0x1FFFFFFF07FFFFFF, 0xFFFFFFFF03FFFFFF,
                    0x3F3FFFFFFFFFFFFF, 0xFFFFFFFF1FFFFFFF, 0x1FFFFFFFFFFFFFF,
                    0x63FFFF8003FFFF, 0x1DFFF0003FFFF, 0xC04FFFFFFFFFFFFF, 0x3FF03FF1FF001BF,
                    0xFFFFFFFF03FF07FF, 0xFFFF05FFFFFFFF9F, 0x3FFFFFFFFFFFFF,
                    0x1FB0E787FFFFFFF, 0x1F3FFFFFFFFFF1, 0xFFFF0FFFFFFFFFFF,
                    0xFFFFFFFFC7FF03FF, 0xFFFFFFFFC67FFFFF, 0x7E01A00BFFFFF, 0x3FFF03FF03FF,
                    0, 0xC00FFFFFFFFFFFF0, 0xFFF007FFFFFFDFE3, 0xFFFFC0C3FFFFFFFC,
                    0xF0005CBFFFFFFFFF, 0xF8300FFFFFFFFFFF, 0xFFFFFFFFFFFFE3FF,
                    0xE7FFFFFFFFFF07FF, 0x4EFDE02000800FF, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0xFFDFFFFFFFFFFFFF, 0x7FDCFFFFEFCFFFDF,
                    0xFFFF80FFFFFF07FF, 0xFFF30000FFFFFFFF, 0xFFFFFFFF1FFF7FFF, 0x1,
                    0xFFFFFFFFFFFF0FFF, 0x3FFFFFFFFFF, 0xFFFFFFFF000007FF, 0xFFCFFFFFFFFFFFFF,
                    0xFFFFFFFFFFBFFFFF, 0xFE0C7FFFFFFFFFFF, 0xFFFF20BFFFFFFFFF,
                    0x180FFFFFFFFFF, 0x7F7F7F7F007FFFFF, 0x7F7F7F7F, 0x3FFFFFFF,
                    0xFFFFFFFFFBFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFF0000003FFFFF,
                    0xFFFF03FFFFFFFFFF, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFF87FFFFF,
                    0xFFFEFFFFFFFFFFE0, 0xFFFFFFFFFFFF7FFF, 0xFFFF803FFFFFFFFF,
                    0xFFFFFFFF7FFFFFFF, 0xFFFFFFFFFFFF1FFF, 0xFFFFFFFFFFFF007F, 0xFFFFFFFFFFF,
                    0xC0087FFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFCFFFFFFFFFFFF,
                    0xFFFC00001FEB3FFF, 0x3FF0F9FFFFFF7BB, 0xFFFFFFFFFFFFFF,
                    0x7FFC000003FFC00F, 0xFFFFC03FFFFFFFFF, 0x1FFFFFFF8004007F,
                    0xCC37FFFFFFFFFFF8, 0x7FFFFFDFC3FFBFFE, 0x1981FFFFFFFFFF,
                    0xEFFFFFFFF3FF2FF7, 0x3E62FFFFFFFFFFFF, 0x3FCFFFF8000005,
                    0xFFFF7F7F007E7E7E, 0x3FF1EDFFFFFFFFF, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFFFFA0F8007F,
                    0xFFFFFFFFFFFFFFDB, 0xFFFFFFFFFFF80007, 0xFFFFFFFFFFFCFFFF,
                    0xFFFF0000000080FF, 0xFFFF000003FF0000, 0xFFDF0F7FFFF7FFFF,
                    0x1FFFFFFFFFFFFFFF, 0x7FFFFFFF3FFFFFFF, 0x30007F7F1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 2, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 2, 2, 14, 15, 16, 17,
                    18, 19, 2, 2, 2, 2, 20, 21, 22, 7, 23, 24, 25, 26, 27, 7, 28, 29, 30, 31,
                    32, 33, 34, 35, 36, 7, 2, 37, 38, 39, 40, 41, 42, 7, 7, 43, 44, 45, 16,
                    46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
                    64, 65, 66, 67, 68, 7, 7, 69, 70, 71, 72, 73, 74, 75, 76, 7, 7, 77, 7, 78,
                    79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 7, 7, 89, 90, 91, 92, 7, 93, 94,
                    95, 7, 7, 7, 7, 96, 97, 98, 99, 100, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 101, 7, 2, 102, 2, 2, 2, 103, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 104, 38, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 105, 106,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 76, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 107, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 87, 108, 109, 110, 111,
                    112, 113, 7, 7, 7, 7, 7, 7, 114, 7, 7, 7, 2, 115, 7, 2, 116, 117, 118, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 65, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 119, 37, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 120, 2, 2, 2, 2, 121,
                    122, 2, 2, 2, 2, 2, 123, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 124, 125,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 114, 2, 2, 2, 2, 2, 2, 19, 7, 7,
                    104, 2, 103, 2, 2, 2, 126, 127, 128, 129, 130, 2, 131, 7, 132, 2, 133, 7,
                    7, 2, 134, 135, 136, 137, 138, 2, 2, 2, 2, 139, 2, 2, 2, 2, 140, 2, 2, 2,
                    2, 2, 2, 2, 2, 141, 142, 143, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 144, 7, 7, 7, 145, 146, 7, 7, 147, 148, 7, 7, 7, 7, 149, 150, 7, 7,
                    7, 7, 7, 7, 7, 151, 7, 7, 7, 152, 7, 7, 7, 7, 7, 7, 7, 153, 2, 2, 2, 154,
                    2, 155, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 156, 157, 7, 158, 7, 7, 7, 159,
                    160, 161, 162, 7, 7, 7, 7, 163, 2, 164, 165, 2, 2, 146, 166, 167, 168, 7,
                    7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 169, 2, 170, 2, 171, 172,
                    173, 174, 175, 2, 2, 2, 2, 2, 176, 177, 178, 2, 2, 179, 114, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 114, 2, 2, 2, 180, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 181, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 182, 2, 2, 2, 2, 2, 2, 2, 2, 2, 183, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 183, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 116, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 105, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF,
                    0xFF8FFFFFFFFFFF87, 0x11FFF7FFF, 0x1FFFFFFFFFFF0000, 0,
                    0xFFFFFFFF1FFFFFFF, 0xFFFFFFE0001FFFF, 0xFFFFE00FFFFFFFFF,
                    0x3FFFFFFFFF07FF, 0xFFFFFFFFBFFFFFFF, 0x3FFF0F, 0xFFFF03FF3FFFFFFF,
                    0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF, 0xF7FF800FFFFFFFFF,
                    0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                    0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0xFFFFFFFFFFBFFFFF, 0xFF807FFFFFFF,
                    0xF837FFFF00000000, 0x83FFFFFF8FFFFFFF, 0xF0FFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFCFFFF, 0x3FFFFFFEEF0001, 0xFFFFFFFF01FF01FF, 0xFFFFFFFF,
                    0x7FF81FFFFFFFFF, 0xFE3FFFFFFFFFFFFF, 0xFF07FFFFFF3FFFFF, 0xFE001E03FFFF,
                    0x1FF, 0x7FFFFFFFFFFFF, 0xFC07FFFFFFFFFFFF, 0x3FF000FFFFFFFFF,
                    0xFFFFC03FFFFFFFFF, 0xC03F, 0x7FFFFFFF00000000, 0x323FFFFFFFFFF, 0x1C,
                    0xFFFF000003FE003F, 0xFFFF0000000003C3, 0x7FFFFF00000FFF,
                    0xFFFFFFFFFFFFFD, 0x26FFFFFFFC3F80, 0xD987FFFFFFFFFFFC, 0x3FF01FFFFFF0003,
                    0xFFC0107FFFFFFFF8, 0x77FFFFFFFF00FF, 0x803FFFFFFFFFFFFC,
                    0x1FFFFEFFFF61FE, 0xBF0C7FFFFFFBFFFF, 0x1, 0xFFFF03FFBFFFBD7F,
                    0x3FF00077FFFFFFF, 0xA3EDFDFFFFF99FEC, 0xFE001199E, 0x6BFFFFFFFFF4BFF,
                    0x1BA3400, 0xFFFFFFFFFFFFFF, 0x3AFFFFFA3, 0x5A06FFFFFFFFFFFF, 0x3FF00F2,
                    0x4F037FFFFFFFFFFF, 0xFFFFFFE, 0x5807FFFFFFFFFFFF, 0x1FFF03FF001E,
                    0x300D7FFFFFFFFFF, 0xFFFFF03FF, 0xFFFF004347FFFFFF, 0x7F,
                    0x9007FFFFFFFFFFF, 0xFFFFFFFF00000000, 0x8007FFFFFFFFFFFF,
                    0x81BEFFFFFF6FF27F, 0x3FF0077, 0xFFFFFCFF00000000, 0x1EF00FFFFF,
                    0x8607FFFFFFFFF801, 0xFFFFFFFFF181007F, 0xFFFF0007FC8003FF,
                    0x1FFFFFFFFFFFFFF, 0x3FF, 0x3FF0003FFFFFFFF, 0x4000FFFFFFFFFDFF,
                    0xFFFF1FFFFFFF003F, 0x1202000000FFFF, 0x1FFFFFFFFFB7F, 0xFFFFFDBF03FF0040,
                    0x3FF01587FFF, 0x1E7FFFF00000000, 0xC03FFFFFFFFDFFFC, 0x3FFFFF8,
                    0x1000000000000, 0x8003FFFFFFFFFFFF, 0x3FFFFFF, 0x1F7FFFFFFFFFFF, 0xF,
                    0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFF, 0xFFFFFFFF0000007E, 0x3FF1C003FFFFFFF,
                    0xFFFFC3FF7FFFFFFF, 0x7FFFFFFFFFFFFFFF, 0x203FFFFFFF03FF,
                    0xFF80FFFFFFFFFFFF, 0xE0FFFFFBFBFF003F, 0xFFFF, 0x3FFFFFFFFFFFFFF,
                    0x7FFFFFF, 0xFFFFFFFFFFFF07FF, 0xFFF800FF, 0xF00000000,
                    0x80000000003FFFFF, 0x6FEF000000000000, 0x40007FFFFFFFF,
                    0xFFFF00F000270000, 0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x93FF01FF,
                    0x3FFFFFFFFFFFFF, 0xFFFFFE7FFFFFFFFF, 0x1C1FFFFFFFFF, 0xFFFFC3FFFFFFF018,
                    0x7FFFFFFFFFF, 0x23, 0xFFFFF000FFFFF, 0x1FFFFFF007FFFFF,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xFFFFFFFFFFFFCFFF, 0x780000000000000, 0xFFDFE00000000000, 0xFEF,
                    0x7E07FFFFFFF, 0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x3F801FFFFFFFFFFF,
                    0xC3FF, 0x3FFFFFFF0000, 0x83FF0FFFFFFFFFFF, 0x3FF0FFFFFFF0000,
                    0x87FF3FFFFFFF0000, 0x7FFF6F7F00000000, 0xFF9F, 0xC3FF080F,
                    0xFFFE000000000000, 0x1FFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFE,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0x3000000000000,
                    0xFFFF0FFFFFFFFFFF, 0xFFFE7FFF000FFFFF, 0x3FFFFFFFFEFFFE,
                    0xFFFFFFC000000000, 0xFFFFFFFFFFF0007, 0x3F000301FF, 0x1FFF1FFFF0FFFFFF,
                    0xF87FFFFFFFFFFFFF, 0x10FFF03FFFFFF, 0xFFFFFFFFFFFF0FFF,
                    0xFFFFFFFF03FF00FF, 0xFFF3FFFFFFF00FF, 0x3, 0x1FFF3FFF000FFFFF,
                    0xFFFFFFFFFFFF83FF, 0x1FF03FF9FFFC07F, 0xFFFFFFFFFFF7FFFF,
                    0xFFFFFFFF3FFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                ],
                };

                pub const GRAPHEME_EXTEND: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0x3F8, 0, 0, 0, 0xBFFFFFFFFFFE0000, 0xB6, 0x7FF0000,
                    0x10000FFFFF800, 0, 0x3D9F9FC00000, 0xFFFF000000020000, 0x7FF,
                    0x1FFC000000000, 0x200FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 35, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 36, 37, 38, 39, 40, 34, 41, 34, 42, 34, 34, 34, 43, 44, 45,
                    46, 47, 48, 49, 50, 51, 34, 34, 52, 34, 34, 34, 53, 34, 34, 34, 34, 34,
                    34, 34, 34, 54, 34, 34, 55, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    56, 34, 57, 34, 58, 34, 34, 34, 34, 34, 34, 34, 34, 59, 34, 60, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    61, 62, 63, 34, 34, 34, 34, 64, 34, 34, 65, 66, 67, 68, 69, 70, 71, 72,
                    73, 34, 34, 34, 74, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 75, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 76, 34, 34, 34, 34, 34, 62, 34,
                ],
                tree2_level2: &[
                    0x3EEFFBC00000, 0xE000000, 0xFF800000, 0xFFFFFFFBFFFFFC00,
                    0x1400000000000007, 0xC00FE21FE, 0x5000000000000002, 0x4000000C0080201E,
                    0x1000000000000006, 0x23000000023986, 0xFC00000C000021BE,
                    0xD000000000000002, 0xC00E0201E, 0x4000000000000004, 0x802001,
                    0xD000000000000011, 0xC00603DC1, 0x9000000000000002, 0xC00603DC5,
                    0x5800000000000003, 0xC0080201E, 0x2, 0x805C8400, 0x7F2000000000000,
                    0x7F80, 0x1FF2000000000000, 0x7F00, 0x2A0000003000000, 0x7FFE000000000000,
                    0x1FFFFFFFFEFFE0DF, 0x40, 0x66FDE00000000000, 0x1E0001C3000000,
                    0x20002064, 0, 0xE0000000, 0x1C0000003C0000, 0xC0000000C0000,
                    0x3FB0000000000000, 0x200FFE40, 0xB800, 0x20000000060, 0xE04018700000000,
                    0x9800000, 0x9FF81FE57F400000, 0xFFFF000000000000, 0x7FFF,
                    0x3FF000000000000F, 0xFF8000000001C, 0x3F3C00000003, 0xFA34000000000,
                    0xCFF00000000000, 0x31021FDFFF70000, 0xFFFFFFFFFFFFFFFF, 0x1000,
                    0x1FFFFFFFF0000, 0x3800000000000, 0x8000000000000000, 0xFFFFFFFF00000000,
                    0xFC0000000000, 0x6000000, 0x3FF7800000000000, 0xC0000000,
                    0x3000000000000, 0x106000000844, 0x8003FFFF00000030, 0x3FC000000000,
                    0xBFF80, 0x33C8000000000007, 0x2000000001, 0x667E0000000000,
                    0x1000000000001008, 0xC19D000000000000, 0x40300000000002, 0x212000000000,
                    0x40000000, 0xFFFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 2, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0,
                    0, 0, 6, 7, 0, 0, 0, 0, 8, 9, 0, 10, 11, 0, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0, 0, 31, 32, 33, 34,
                    35, 0, 36, 0, 0, 0, 37, 0, 0, 0, 38, 39, 0, 40, 41, 42, 43, 0, 0, 0, 0, 0,
                    44, 0, 45, 0, 46, 47, 48, 0, 0, 0, 0, 49, 50, 51, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 55, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 61, 0, 0, 0, 0, 0, 0, 0,
                    62, 63, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 66, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 56, 0, 55, 0, 0, 0, 0, 0, 69, 70,
                    0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72,
                    0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 74, 75, 0, 0, 75, 75, 75, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x870000000000F06E,
                    0x6000000000, 0xF000000000, 0x3E0000000000, 0x180000000000,
                    0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000002, 0x801900000000007F,
                    0x678000000000003, 0x4, 0x1FEF8000000007, 0x8000000000000,
                    0x7FC0000000000003, 0x9E01, 0x40F3800000000000, 0x2, 0x7F880000000,
                    0x5800000000000003, 0x1F1FC000802001, 0xF900000000000000, 0x60005C3A5,
                    0xFF00000000000000, 0x4000005C, 0xA5F9000000000000, 0xD,
                    0xB03C800000000000, 0x30000001, 0xA7F8000000000000, 0x1, 0xFF280000000000,
                    0xFBCA0000000, 0x6FF800000000000, 0x7801000000000000, 0x8, 0x10CF00000,
                    0x79F80000000007FE, 0xE7E0080, 0x37FFC00, 0xBF7F000000000000,
                    0x6DFCFFFFFC0000, 0xB47E000000000000, 0xBF, 0xA30000, 0x18000000000000,
                    0x7C0000000000003, 0x4000007, 0x3FFF81, 0xE3FFC0000000, 0x1F000000000000,
                    0x7F000000000000, 0x8000, 0x78000, 0x3001000000000, 0x60000000,
                    0xFFFF3FFFFFFFFFFF, 0x7F, 0xF807E3E000000000, 0x3C0000000FE7, 0x1C,
                    0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7DBF9FFFF7F,
                    0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x7F0,
                    0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const GRAPHEME_LINK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 1, 0, 3, 4,
                    0, 4, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0,
                    0, 0, 5, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 5, 0, 14, 0,
                    15, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2000, 0x1800000000000000, 0x400, 0x400000000000000, 0x10,
                    0x600000000000000, 0x10000000300000, 0x40000, 0x100000000, 0xC0000000000,
                    0xC000000000000, 0x8000000000000000, 0x100000000040, 0x80000, 0x1,
                    0x40000000000000, 0x200000000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 4, 0, 0, 5, 6, 0, 0,
                    7, 0, 8, 0, 9, 0, 10, 0, 10, 0, 0, 1, 0, 1, 0, 11, 0, 12, 0, 0, 0, 3, 0,
                    0, 0, 13, 0, 0, 14, 15, 16, 17, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 19, 0,
                    0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x8000000000000000, 0x8001000000000040, 0x200000000000000,
                    0x18000000000000, 0x1, 0x20000000000000, 0x40000000000, 0x2000, 0x1C000,
                    0x4, 0x40000000000000, 0x80000000000, 0x6000000000000000, 0x100000000,
                    0x10000000000000, 0x80, 0x2000000, 0x30, 0x800000, 0x6, 0x800000000000,
                ],
                };

                pub const HEX_DIGIT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0x7E0000007E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7E03FF0000, 0x7E,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const HYPHEN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x200000000000, 0, 0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0x400, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 6, 7, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x40, 0x30000, 0x800000, 0x800000000000000, 0x800000000, 0x2000,
                    0x2000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const IDS_BINARY_OPERATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3FF3000000000000, 0x800000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const IDS_TRINARY_OPERATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC000000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const IDS_UNARY_OPERATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC000000000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const ID_COMPAT_MATH_CONTINUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x20C000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FF1000000000000, 0x7FFF, 0x40000084,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x800000008000002, 0x20000000200000, 0x800000008000, 0x20000000200,
                    0x8,
                ],
                };

                pub const ID_COMPAT_MATH_START: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x40000084,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x800000008000002, 0x20000000200000, 0x800000008000, 0x20000000200,
                    0x8,
                ],
                };

                pub const ID_CONTINUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0x7FFFFFE87FFFFFE, 0x4A0040000000000,
                    0xFF7FFFFFFF7FFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3,
                    0xFFFFFFFFFFFFFFFF, 0xBCDFFFFFFFFFFFFF, 0xFFFFFFFBFFFFD7C0,
                    0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFCFB, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF,
                    0xFFFFFFFF027FFFFF, 0xBFFFFFFFFFFE01FF, 0x787FFFFFF00B6,
                    0xFFFFFFFF07FF0000, 0xFFFFC3FFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x9FFFFDFF9FEFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFFE7FF,
                    0x3FFFFFFFFFFFF, 0x243FFFFFFFFFFFFF,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 4, 32, 33, 34, 4, 4, 4, 4, 4,
                    35, 36, 37, 38, 39, 40, 41, 42, 4, 4, 4, 4, 4, 4, 4, 4, 43, 44, 45, 46,
                    47, 4, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 4, 61, 4, 62,
                    63, 64, 65, 66, 4, 4, 4, 4, 4, 4, 4, 4, 67, 68, 69, 70, 71, 72, 73, 74,
                    75, 76, 77, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 4, 4, 4, 79, 80, 81, 82, 83, 78, 78, 78,
                    78, 78, 78, 78, 78, 84, 42, 85, 4, 86, 4, 87, 88, 78, 78, 78, 78, 78, 78,
                    78, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 89, 90, 4, 4, 4, 4, 91, 92, 4, 93, 94, 4, 95, 96, 97, 62, 4,
                    98, 99, 100, 4, 101, 102, 103, 4, 104, 105, 106, 4, 107, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 108, 109, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 4, 4, 4, 4, 4, 99, 4, 110, 111, 112, 93, 113, 4, 4, 4, 4,
                    114, 115, 116, 117, 118, 119, 4, 120, 121, 122, 123, 124,
                ],
                tree2_level2: &[
                    0x3FFFFFFFFFFF, 0xFFFF07FF0FFFFFFF, 0xFFFFFFFFFF807EFF,
                    0xFFFFFFFBFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFCFFFFFFFFF,
                    0xF3C5FDFFFFF99FEF, 0x5003FFCFB080799F, 0xD36DFDFFFFF987EE,
                    0x3FFFC05E023987, 0xF3EDFDFFFFFBBFEE, 0xFE00FFCF00013BBF,
                    0xF3EDFDFFFFF99FEE, 0x2FFCFB0E0399F, 0xC3FFC718D63DC7EC, 0xFFC000813DC7,
                    0xF3FFFDFFFFFDDFFF, 0xFFCF27603DDF, 0xF3EFFDFFFFFDDFEF, 0xEFFCF60603DDF,
                    0xFFFFFFFFFFFDDFFF, 0xFC00FFCF80F07DDF, 0x2FFBFFFFFC7FFFEE,
                    0xCFFC0FF5F847F, 0x7FFFFFFFFFFFFFE, 0x3FF7FFF, 0x3FFFFFAFFFFFF7D6,
                    0xF3FF7F5F, 0xC2A003FF03000001, 0xFFFE1FFFFFFFFEFF, 0x1FFFFFFFFEFFFFDF,
                    0x40, 0xFFFFFFFFFFFF03FF, 0xFFFFFFFF3FFFFFFF, 0xF7FFFFFFFFFF20BF,
                    0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D,
                    0xFFFFFFFFFF3DFFFF, 0x3FE00E7FFFFFF, 0xFFFFFFFF0000FFFF,
                    0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE, 0xFFFF9FFFFFFFFFFF,
                    0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF, 0x1FFFFF803FFFFF, 0xDDFFF000FFFFF,
                    0x3FF308FFFFF, 0xFFFFFFFF03FFB800, 0x1FFFFFFFFFFFFFF, 0xFFFF07FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0xFFF0FFF7FFFFFFF, 0x1F3FFFFFFFFFC0, 0xFFFF0FFFFFFFFFFF,
                    0x7FF03FF, 0xFFFFFFFF0FFFFFFF, 0x9FFFFFFF7FFFFFFF, 0xBFFF008003FF03FF,
                    0x7FFF, 0xFF80003FF1FFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF,
                    0x3FFFFFFFFFFFE3FF, 0xE7FFFFFFFFFF07FF, 0x7FFFFFFFFF70000,
                    0xFFFFFFFF3F3FFFFF, 0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF,
                    0x1FDC1FFF0FCF1FDC, 0x8000000000003000, 0x8002000000100001, 0x1FFF0000,
                    0x1FFE21FFF0000, 0xF3FFFD503F2FFC84, 0xFFFFFFFF000043E0, 0x1FF, 0,
                    0xFF81FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x800080FFFFFFFFFF,
                    0x7F7F7F7F007FFFFF, 0xFFFFFFFF7F7F7F7F, 0x1F3EFFFE000000E0,
                    0xFFFFFFFEFE7FFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xFFFFFFF1FFF,
                    0xBFF0FFFFFFFFFFFF, 0x3FFFFFFFFFFFF, 0xFFFFFFFCFF800000,
                    0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x10FFFFFFFFFF,
                    0xE8FFFFFF03FF003F, 0xFFFF3FFFFFFFFFFF, 0x1FFFFFFF000FFFFF,
                    0x7FFFFFFF03FF8001, 0x7FFFFFFFFFFFFF, 0xFC7FFFFF03FF3FFF,
                    0x7CFFFF38000007, 0xFFFF7F7F007E7E7E, 0xFFFF03FFF7FFFFFF,
                    0x3FF37FFFFFFFFFF, 0xFFFF000FFFFFFFFF, 0xFFFFFFFFFFFF87F, 0x3FFFFFF,
                    0x5F7FFDFFE0F8007F, 0xFFFFFFFFFFFFFFDB, 0xFFFFFFFFFFF80000,
                    0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFCFFFF,
                    0xFFF0000000000FF, 0x18FFFF0000FFFF, 0xFFDF00000000E000,
                    0x1FFFFFFFFFFFFFFF, 0x87FFFFFE03FF0000, 0xFFFFFFE007FFFFFE,
                    0x7FFFFFFFFFFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 6, 4, 4, 7, 8, 9, 10, 11, 12, 2, 2, 13, 14, 15, 16,
                    17, 18, 2, 2, 2, 2, 19, 20, 21, 4, 22, 23, 24, 25, 26, 4, 27, 4, 28, 29,
                    30, 31, 32, 33, 34, 4, 2, 35, 36, 36, 37, 38, 39, 4, 4, 4, 40, 41, 42, 43,
                    44, 45, 2, 46, 3, 47, 48, 49, 2, 50, 51, 52, 53, 54, 55, 56, 57, 58, 2,
                    59, 2, 60, 4, 4, 61, 62, 2, 63, 64, 65, 66, 67, 4, 4, 3, 4, 68, 69, 70,
                    71, 72, 73, 74, 75, 76, 64, 4, 4, 4, 77, 78, 79, 80, 4, 81, 82, 83, 4, 4,
                    4, 4, 84, 85, 86, 87, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 88, 4,
                    2, 89, 2, 2, 2, 90, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 91, 92,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 93, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 67, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 64, 96, 74, 97, 19, 98, 99, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 35, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 112, 4, 4, 4, 4, 4, 4, 4, 4, 113, 67, 4, 4, 4, 4, 4, 4, 4,
                    114, 115, 4, 4, 116, 4, 4, 4, 4, 4, 4, 2, 117, 118, 119, 120, 121, 2, 2,
                    2, 2, 122, 123, 124, 125, 126, 127, 4, 4, 4, 4, 4, 4, 4, 4, 128, 129, 130,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 131, 4, 4, 4, 132, 133,
                    134, 4, 135, 136, 4, 4, 4, 4, 137, 95, 4, 4, 4, 4, 4, 4, 4, 138, 4, 4, 4,
                    139, 4, 4, 4, 4, 4, 4, 4, 140, 2, 2, 2, 141, 2, 142, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 143, 144, 145, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 112, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 146, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 95, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    147, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 148, 2, 2, 2, 2, 2, 2, 2, 2, 2, 149, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 149, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 150, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 93, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2,
                    93, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0x2000000000000000, 0xFFFFFFFF1FFFFFFF, 0x10001FFFF,
                    0xFFFFE000FFFFFFFF, 0x7FFFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F,
                    0xFFFF03FF3FFFFFFF, 0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF,
                    0xF7FF000FFFFFFFFF, 0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF,
                    0xFF003FFFFF, 0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF,
                    0x7FFFFFFF, 0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF,
                    0x873FFFFFFEEFF06F, 0x1FFFFFFF00000000, 0x1FFFFFFF, 0x7FFFFFFEFF,
                    0x3FFFFFFFFFFFFF, 0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF,
                    0x3FF00FFFFFFFFFF, 0xFFFFBE3FFFFFFFFF, 0x3F, 0x31BFFFFFFFFFF,
                    0xF00000000000001C, 0xFFFF00801FFFFFFF, 0xFFFF00000001FFFF,
                    0xFFFF00000000003F, 0x7FFFFF0000001F, 0x803FFFC00000007F,
                    0x3FF01FFFFFF0004, 0xFFDFFFFFFFFFFFFF, 0x4FFFFFFFFF00F0, 0x17FFDE1F,
                    0xC0FFFFFFFFFBFFFF, 0x3, 0xFFFF01FFBFFFBD7F, 0x3FF07FFFFFFFFFF,
                    0xFBEDFDFFFFF99FEF, 0x1F1FCFE081399F, 0xFFBFFFFFFFFF4BFF, 0x6000FF7A5,
                    0x3C3FF07FF, 0x3FF00BF, 0xFF3FFFFFFFFFFFFF, 0x3F000001, 0x3FF0011,
                    0x1FFFFFFFFFFFFFF, 0xFFFFF03FF, 0x3FF0FFFE7FFFFFF, 0x7F,
                    0xFFFFFFFF00000000, 0x800003FFFFFFFFFF, 0xF9BFFFFFFF6FF27F, 0x3FF000F,
                    0xFFFFFCFF00000000, 0x1BFCFFFFFF, 0x7FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0080,
                    0xFFFF000023FFFFFF, 0x3FF0001FFFFFFFF, 0xFF7FFFFFFFFFFDFF,
                    0xFFFC000003FF0001, 0x7FFEFFFFFCFFFF, 0xB47FFFFFFFFFFB7F,
                    0xFFFFFDBF03FF00FF, 0x3FF01FB7FFF, 0x7FFFFF00000000, 0xC7FFFFFFFFFDFFFF,
                    0x7FF0007, 0x1000000000000, 0x3FFFFFF, 0x7FFFFFFFFFFF, 0xF,
                    0xFFFFFFFFFFFF0000, 0x1FFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0xFFFFFFFF003FFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF03FF7FFFFFFF, 0x1F3FFFFFFF03FF,
                    0xE0FFFFF803FF000F, 0xFFFF, 0x3FF1FFFFFFFFFFF, 0xFFFFFFFFFFFF87FF,
                    0xFFFF80FF, 0x3001B00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                    0x6FEF000000000000, 0x40007FFFFFFFF, 0xFFFF00F000270000,
                    0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x63FF01FF, 0x3FF000000000000,
                    0xFFFF3FFFFFFFFFFF, 0xF807E3E000000000, 0x3C0000000FE7, 0x1C,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFFFFFFFFFFFFCFF7, 0xF87FFFFFFFFFFFFF,
                    0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7E07FFFFFFF, 0xFFFF07DBF9FFFF7F,
                    0x3FFFFFFFFFFF, 0x8000, 0x3FFF1FFFFFFFFFFF, 0x43FF, 0x7FFFFFFF0000,
                    0x3FFFFFFFFFF0000, 0x7FFFFFFFFFF0000, 0x7FFF6F7F00000000, 0x7F001F,
                    0x3FF0FFF, 0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF,
                    0xFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const ID_START: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3, 0, 0xBCDF000000000000,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF027FFFFF, 0x1FF, 0x787FFFFFF0000,
                    0xFFFFFFFF00000000, 0xFFFEC000000007FF, 0xFFFFFFFFFFFFFFFF,
                    0x9C00C060002FFFFF, 0xFFFFFFFD0000, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF,
                    0x43007FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 35, 35,
                    35, 35, 36, 37, 38, 39, 40, 41, 42, 43, 35, 35, 35, 35, 35, 35, 35, 35,
                    44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 3, 58, 59, 60, 30,
                    61, 62, 63, 64, 65, 66, 67, 68, 35, 35, 35, 30, 35, 35, 35, 35, 69, 70,
                    71, 72, 30, 73, 74, 30, 75, 76, 77, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 78,
                    79, 80, 81, 82, 30, 30, 30, 30, 30, 30, 30, 30, 83, 43, 84, 85, 86, 35,
                    87, 88, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 30, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 89, 90, 35, 35, 35, 35, 91, 92,
                    93, 94, 95, 35, 96, 97, 98, 49, 99, 100, 101, 102, 103, 104, 105, 106,
                    107, 108, 109, 110, 35, 111, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 112, 113, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 114, 35, 115, 116,
                    117, 118, 119, 35, 35, 35, 35, 120, 121, 122, 123, 30, 124, 35, 125, 126,
                    127, 128, 129,
                ],
                tree2_level2: &[
                    0x110043FFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00007EFF, 0x3FF,
                    0x23FFFFFFFFFFFFF0, 0xFFFE0003FF010000, 0x23C5FDFFFFF99FE1,
                    0x10030003B0004000, 0x36DFDFFFFF987E0, 0x1C00005E000000,
                    0x23EDFDFFFFFBBFE0, 0x200000300010000, 0x23EDFDFFFFF99FE0,
                    0x20003B0000000, 0x3FFC718D63DC7E8, 0x10000, 0x23FFFDFFFFFDDFE0,
                    0x327000000, 0x23EFFDFFFFFDDFE1, 0x6000360000000, 0x27FFFFFFFFFDDFF0,
                    0xFC00000380704000, 0x2FFBFFFFFC7FFFE0, 0x7F, 0xDFFFFFFFFFFFE,
                    0x200DFFAFFFFFF7D6, 0xF000005F, 0x1, 0x1FFFFFFFFEFF, 0x1F00, 0,
                    0x800007FFFFFFFFFF, 0xFFE1C0623C3F0000, 0xFFFFFFFF00004003,
                    0xF7FFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF,
                    0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x7FFFFFF,
                    0xFFFFFFFF0000FFFF, 0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF,
                    0x3FFFF8003FFFF, 0x1DFFF0003FFFF, 0xFFFFFFFFFFFFF, 0x10800000,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFFF, 0xFFFF05FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0x7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF,
                    0xFFFFFFFF007FFFFF, 0x1FFFFF, 0x8000000000, 0xFFFFFFFFFFFE0, 0x1FE0,
                    0xFC00C001FFFFFFF8, 0x3FFFFFFFFF, 0xFFFFFFFFF, 0x3FFFFFFFFC00E000,
                    0xE7FFFFFFFFFF07FF, 0x46FDE0000000000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF3FFFD503F2FFC84, 0xFFFFFFFF000043E0,
                    0x1FF, 0xC781FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x80FFFFFFFFFF,
                    0x7F7F7F7F007FFFFF, 0x7F7F7F7F, 0x1F3E03FE000000E0, 0xFFFFFFFEF87FFFFF,
                    0xF7FFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xC00FFFF1FFF,
                    0x80007FFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFFFFFFFFFFFF,
                    0xFFFFFFFCFF800000, 0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x7FFFFF7BB,
                    0xFFFFFFFFFFFFC, 0x68FC000000000000, 0xFFFF003FFFFFFC00,
                    0x1FFFFFFF0000007F, 0x7FFFFFFFFFFF0, 0x7C00FFDF00008000, 0x1FFFFFFFFFF,
                    0xC47FFFFF00000FF7, 0x3E62FFFFFFFFFFFF, 0x1C07FF38000005,
                    0xFFFF7F7F007E7E7E, 0xFFFF03FFF7FFFFFF, 0x7FFFFFFFF, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFA0F8007F,
                    0xFFFFFFFFFFFFFFDB, 0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000,
                    0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFCFFFF,
                    0xFFF0000000000FF, 0xFFDF000000000000, 0x1FFFFFFFFFFFFFFF,
                    0x7FFFFFE00000000, 0xFFFFFFC007FFFFFE, 0x7FFFFFFFFFFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 5, 11, 12, 5, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 13, 14, 15, 7, 16, 17, 7, 18, 19, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15,
                    16, 17, 2, 2, 2, 2, 18, 19, 20, 4, 21, 22, 23, 24, 25, 4, 26, 4, 27, 28,
                    29, 30, 31, 32, 33, 4, 2, 34, 35, 35, 36, 37, 38, 4, 4, 4, 39, 40, 41, 42,
                    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 23, 56, 57, 58, 59, 5,
                    60, 61, 62, 4, 4, 63, 64, 61, 65, 66, 4, 67, 68, 4, 4, 69, 4, 70, 71, 72,
                    73, 74, 75, 76, 77, 78, 79, 4, 4, 4, 80, 81, 82, 83, 4, 84, 85, 86, 4, 4,
                    4, 4, 87, 88, 4, 89, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 4,
                    2, 63, 2, 2, 2, 91, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 92, 93,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 61, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 68, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 79, 96, 97, 98, 61, 99, 83, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 34, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 112, 113, 114,
                    115, 116, 2, 2, 2, 2, 117, 118, 119, 120, 121, 122, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 123, 4, 4,
                    4, 124, 125, 4, 4, 126, 127, 4, 4, 4, 4, 98, 69, 4, 4, 4, 4, 4, 4, 4, 128,
                    4, 4, 4, 129, 4, 4, 4, 4, 4, 4, 4, 130, 2, 2, 2, 131, 2, 132, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 133, 134, 135, 4, 4, 4, 4, 4, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 136, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 137, 2, 2, 2, 10, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 138, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 139, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2,
                    95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 140, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 61, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF,
                    0x3FFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F, 0xFFFF00003FFFFFFF,
                    0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF, 0xF7FF000FFFFFFFFF,
                    0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                    0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF,
                    0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEF0001,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF, 0xFFFFFFFFF,
                    0xFFFF803FFFFFFC00, 0x3F, 0x303FFFFFFFFFF, 0x1C, 0xFFFF00801FFFFFFF,
                    0xFFFF00000000003F, 0xFFFF000000000003, 0x7FFFFF0000001F,
                    0xFFFFFFFFFFFFF8, 0x26000000000000, 0xFFFFFFFFFFF8, 0x1FFFFFF0000,
                    0x7FFFFFFFF8, 0x47FFFFFFFF0090, 0x7FFFFFFFFFFF8, 0x1400001E,
                    0x80000FFFFFFBFFFF, 0x1, 0xFFFF01FFBFFFBD7F, 0x23EDFDFFFFF99FE0,
                    0x3E0010000, 0xBFFFFFFFFF4BFF, 0xA0000, 0x380000780, 0xFFFFFFFFFFFF, 0xB0,
                    0x7FFFFFFFFFFF, 0xF000000, 0x10, 0x10007FFFFFFFFFF, 0x7FFFFFF, 0x7F,
                    0xFFFFFFFFFFF, 0xFFFFFFFF00000000, 0x80000000FFFFFFFF, 0x8000FFFFFF6FF27F,
                    0x2, 0xFFFFFCFF00000000, 0xA0001FFFF, 0x407FFFFFFFFF801,
                    0xFFFFFFFFF0010000, 0xFFFF0000200003FF, 0x1FFFFFFFFFFFFFF, 0x1FFFFFFFF,
                    0x7FFFFFFFFDFF, 0xFFFC000000000001, 0xFFFF, 0x1FFFFFFFFFB7F,
                    0xFFFFFDBF00000040, 0x10003FF, 0x7FFFF00000000, 0xFFFFFFFFDFFF4,
                    0x1000000000000, 0x3FFFFFF, 0xF, 0xFFFFFFFFFFFF0000, 0x1FFFFFFFFFFFF,
                    0xFFFFFFFF0000007E, 0x3FFFFFFF, 0xFFFF00007FFFFFFF, 0x7FFFFFFFFFFFFFFF,
                    0x3FFFFFFF0000, 0xE0FFFFF80000000F, 0x1FFFFFFFFFFF, 0x107FF, 0xFFF80000,
                    0xB00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF, 0x6FEF000000000000,
                    0x40007FFFFFFFF, 0xFFFF00F000270000, 0xFFFFFFFFFFFFFFF,
                    0x1FFF07FFFFFFFFFF, 0x3FF01FF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF,
                    0xFFFF7FFFFFFF7FFF, 0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFFFF,
                    0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x3F801FFFFFFFFFFF, 0x4000,
                    0xFFFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F, 0x80F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const IDEOGRAPHIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 3, 2, 4, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x70003FE000000C0, 0xFFFFFFFFFFFFFFFF, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 4, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 5, 6, 7, 2, 8, 9, 2, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 5, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 2, 2, 2, 2, 7, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 12, 2, 2, 2, 2, 2, 2, 2, 2, 2, 13, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 13, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 14, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 15,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1000000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                    0x1FF, 0xFFFF000000000000, 0xFFFFFFFFFFFFFFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFFFF0003FFFFFFFF,
                    0xFFFF0001FFFFFFFF, 0x3FFFFFFF, 0xFFFFFFFFFFFF07FF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const INCB: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0x3F8, 0, 0, 0, 0xBFFFFFFFFFFE0000, 0xB6, 0x7FF0000,
                    0x10000FFFFF800, 0, 0x3D9F9FC00000, 0xFFFF000000020000, 0x7FF,
                    0x1FFC000000000, 0x200FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 36, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 37, 38, 39, 40, 41, 35, 42, 35, 43, 35, 35, 35, 44, 45, 46,
                    47, 48, 49, 50, 51, 52, 35, 35, 53, 35, 35, 35, 54, 35, 35, 35, 35, 35,
                    35, 35, 35, 55, 35, 35, 56, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    57, 35, 58, 35, 59, 35, 35, 35, 35, 35, 35, 35, 35, 60, 35, 61, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    62, 63, 64, 35, 35, 35, 35, 65, 35, 35, 66, 67, 68, 69, 70, 71, 72, 73,
                    74, 35, 35, 35, 75, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 76, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 77, 35, 35, 35, 35, 35, 63, 35,
                ],
                tree2_level2: &[
                    0x3EEFFBC00000, 0xE000000, 0xFF800000, 0xFFFFFFFBFFFFFC00,
                    0x17FFFFFFFFE00007, 0xFF00000CFFFE21FE, 0x53C5FDFFFFE00002,
                    0x4003000CB080201E, 0x1000000000000006, 0x23000000023986,
                    0x13EDFDFFFFE00006, 0xFE00000C000021BE, 0xD3EDFDFFFFE00002,
                    0x2000CB0E0201E, 0x4000000000000004, 0x802001, 0xD3FFFDFFFFE00011,
                    0xC07603DC1, 0x9000000000000002, 0xC00603DC5, 0x5FFFFFFFFFE00003,
                    0xC0080201E, 0x2, 0x805C8400, 0x7F2000000000000, 0x7F80,
                    0x1FF2000000000000, 0x7F00, 0x2A0000003000000, 0x7FFE000000000000,
                    0x1FFFFFFFFEFFE0DF, 0x40, 0x66FDE00000000000, 0x1E0001C3000000,
                    0x20002064, 0, 0xE0000000, 0x1C0000003C0000, 0xC0000000C0000,
                    0x3FB0000000000000, 0x200FFE40, 0xB800, 0x20000000060, 0xE04018700000000,
                    0x9800000, 0x9FF81FE57F400000, 0xFFFF000000000000, 0x7FFF,
                    0x3FF000000000000F, 0xFF8000000001C, 0x3F3C00000003, 0xFA34000000000,
                    0xCFF00000000000, 0x31021FDFFF70000, 0xFFFFFFFFFFFFFFFF, 0x2000,
                    0x1FFFFFFFF0000, 0x3800000000000, 0x8000000000000000, 0xFFFFFFFF00000000,
                    0xFC0000000000, 0x6000000, 0x3FF7800000000000, 0xC0000000,
                    0x3000000000000, 0x106000000844, 0x8003FFFF00000030, 0x3FC000000000,
                    0xBFF80, 0x33C8000000000007, 0x2000000001, 0x667E0000000000,
                    0x1000000000001008, 0xC19D000000000000, 0x40300000000002, 0x212000000000,
                    0x40000000, 0xFFFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 2, 5, 6, 7, 8, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0,
                    0, 0, 6, 7, 0, 0, 0, 0, 8, 9, 0, 10, 11, 0, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0, 0, 31, 32, 33, 34,
                    35, 0, 36, 0, 0, 0, 37, 0, 0, 0, 38, 39, 0, 40, 41, 42, 43, 0, 0, 0, 0, 0,
                    44, 0, 45, 0, 46, 47, 48, 0, 0, 0, 0, 49, 50, 51, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 55, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 61, 0, 0, 0, 0, 0, 0, 0,
                    62, 63, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 66, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 56, 0, 55, 0, 0, 0, 0, 0, 69, 70,
                    0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72,
                    0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 76, 0, 0, 76,
                    76, 76, 77, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x870000000000F06E,
                    0x6000000000, 0xF000000000, 0x3E0000000000, 0x180000000000,
                    0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000002, 0x801900000000007F,
                    0x678000000000003, 0x4, 0x1FEF8000000007, 0x8000000000000,
                    0x7FC0000000000003, 0x9E01, 0x40F3800000000000, 0x2, 0x7F880000000,
                    0x5800000000000003, 0x1F1FC000802001, 0xF900000000000000, 0x60005C3A5,
                    0xFF00000000000000, 0x4000005C, 0xA5F9000000000000, 0xD,
                    0xB03C800000000000, 0x30000001, 0xA7F8000000000000, 0x1, 0xFF280000000000,
                    0xFBCA0000000, 0x6FF800000000000, 0x7801000000000000, 0x8, 0x10CF00000,
                    0x79F80000000007FE, 0xE7E0080, 0x37FFC00, 0xBF7F000000000000,
                    0x6DFCFFFFFC0000, 0xB47E000000000000, 0xBF, 0xA30000, 0x18000000000000,
                    0x7C0000000000003, 0x4000007, 0x3FFF81, 0xE3FFC0000000, 0x1F000000000000,
                    0x7F000000000000, 0x8000, 0x78000, 0x3001000000000, 0x60000000,
                    0xFFFF3FFFFFFFFFFF, 0x7F, 0xF807E3E000000000, 0x3C0000000FE7, 0x1C,
                    0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7DBF9FFFF7F,
                    0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x7F0,
                    0xF800000000000000, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF,
                ],
                };

                pub const JOIN_CONTROL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LOGICAL_ORDER_EXCEPTION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1F, 0x4E0000000000000, 0x1A60000000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LOWERCASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE00000000, 0x420040000000000, 0xFF7FFFFF80000000,
                    0x55AAAAAAAAAAAAAA, 0xD4AAAAAAAAAAAB55, 0xE6512D2A4E243129,
                    0xAA29AAAAB5555240, 0x93FAAAAAAAAAAAAA, 0xFFFFFFFFFFFFAA85,
                    0x1FFFFFFFFEFFFFF, 0x1F00000003, 0, 0x3C8A000000000020,
                    0xFFFFF00000010000, 0x192FAAAAAAE37FFF, 0xFFFF000000000000,
                    0xAAAAAAAAFFFFFFFF, 0xAAAAAAAAAAAAA802, 0xAAAAAAAAAAAAD554,
                    0xAAAAAAAAAAAA, 0xFFFFFFFF00000000, 0x1FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 4, 4, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 11, 12,
                    0, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18,
                    5, 19, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22, 0, 23, 24, 25, 26, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 27, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0,
                    0,
                ],
                tree2_level2: &[
                    0, 0xF7FFFFFFFFFF0000, 0x3F00000000000000, 0x5FF, 0xFFFFFFFFFFFFFFFF,
                    0xAAAAAAAAAAAAAAAA, 0xAAAAAAAABFEAAAAA, 0xFF00FF003F00FF,
                    0x3FFF00FF00FF003F, 0x40DF00FF00FF00FF, 0xDC00FF00CF00DC,
                    0x8002000000000000, 0x1FFF0000, 0x321080000008C400, 0xFFFF0000000043C0,
                    0x10, 0x3FFFFFF0000, 0xFFFF000000000000, 0x3FDA1562FFFFFFFF,
                    0x8501AAAAAAAAA, 0x20BFFFFFFFFF, 0x2AAAAAAAAAAA, 0x3AAAAAAA,
                    0xAAABAAA800000000, 0x95FFAAAAAAAAAAAA, 0xAAA082AAAABA50AA,
                    0x75C00000AAA250A, 0xFFFF03FFF7FFFFFF, 0xF8007F, 0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0,
                    0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 6, 0, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11,
                    12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27,
                    0, 0, 0, 7, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 30, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFF0000000000, 0xFFFF, 0xFFFFFFFFF000000, 0x1BFBFFFBFF800000,
                    0x7FDFFFFFFFFFFB9, 0x7FFFFFFFFFFFF, 0xFFFF000000000000, 0x3F, 0xFFFFFFFF,
                    0xFFFFFFFF00000000, 0xFFFFFFC000000, 0xFFFFDFC000, 0xEBC000000FFFFFFC,
                    0xFFFFFC000000FFEF, 0xFFFFFFC000000F, 0xFFFFFFC0000, 0xFC000000FFFFFFC0,
                    0xFFFFC000000FFFFF, 0xFFFFFFC000000FF, 0xFFFFFFC00000, 0x3FFFFFFC00,
                    0xF0000003F7FFFFFC, 0xFFC000000FDFFFFF, 0xFFFF0000003F7FFF,
                    0xFFFFFC000000FDFF, 0xBF7, 0x7E07FFFFBFF, 0x3FFFFFFFFFFF,
                    0xFFFFFFFC00000000, 0xF,
                ],
                };

                pub const MATH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x7000080000000000, 0x5000000040000000, 0x2100000000000, 0x80000000800000,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x73000000270000, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x1C0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4,
                    5, 6, 7, 8, 9, 9, 9, 9, 10, 11, 12, 13, 0, 0, 0, 0, 0, 0, 14, 15, 16, 17,
                    0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 18, 19, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 22, 23, 0, 24,
                ],
                tree2_level2: &[
                    0, 0x1C000000400000, 0x7C00001E00040011, 0x7C00, 0xF8621FFF0000,
                    0xF1FBB3103F2FFC84, 0xBFF, 0xF0C37EFFFFFF0000, 0xFFF000302FFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x300000F00, 0x1000000000000000, 0xBFFFFFF8000000,
                    0x7F0010000, 0xF0FFC00300000000, 0xFF001F94000F8CC3, 0x60, 0xE00F00000005,
                    0xFFFF000000000000, 0x1F9F, 0x20000000000, 0x17E00000000,
                    0x5000000070000800, 0x50000000, 0x1E0400000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7,
                    2, 2, 2, 2, 8, 2, 2, 2, 2, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,
                    11, 12, 13, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xFFFFFFFFFFFFCFFF, 0xAF7FE96FFFFFFEF,
                    0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0x3000000000000,
                ],
                };

                pub const MODIFIER_COMBINING_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x1300000, 0, 0x18810000000, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x800000008EC00,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const NONCHARACTER_CODE_POINT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF0000, 0xC000000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1,
                ],
                tree3_level3: &[
                    0, 0xC000000000000000,
                ],
                };

                pub const OTHER_ALPHABETIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFF800000020, 0, 0, 0, 0, 0, 0,
                    0, 0, 0xBFFF000000000000, 0xB6, 0x7FF0000, 0x10000FEFFF800, 0,
                    0x219E1FC00000, 0xFFFF000000020000, 0, 0x1FFC000000000, 0,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 6, 8, 6, 9, 6, 10, 11, 12, 13, 14, 6, 15, 16, 17,
                    18, 19, 20, 21, 22, 21, 1, 23, 24, 1, 25, 26, 27, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 28, 28, 29, 30, 1, 1,
                    31, 1, 32, 1, 1, 1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 1, 1, 1, 1, 1, 1,
                    42, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 29, 43, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 44, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    45, 46, 1, 1, 1, 1, 1, 47, 1, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 1,
                    1, 1, 58, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 59, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                ],
                tree2_level2: &[
                    0x1EEFF8C00000, 0, 0x800000, 0xFFFF03F8FFF00000, 0xCC0000000000000F,
                    0xC00E0DFFF, 0xC00000000000000E, 0xC0080199F, 0x23000000021987,
                    0x1C00000C00001BBF, 0xC00C0199F, 0xC000000000000004, 0x801DC7,
                    0xC00000000000001F, 0xC00601DDF, 0x8000C00601DDF, 0xC00000000000000F,
                    0xC00801DDF, 0xE, 0xC0000FF5F8000, 0x7F2000000000000, 0x2000,
                    0x1BF2000000000000, 0xFFFE000000000000, 0x1FFFFFFFFEFFE00F,
                    0x797FF80000000000, 0x1E3F9DC3C00000, 0x3C00BFFC, 0xC0000000C0000,
                    0xFFC0000000000000, 0x1FF, 0x20000000060, 0x1FF0FFF00000000, 0xF800000,
                    0x1FFFFE7FE00000, 0x8000000000000000, 0x7001, 0xFFE000000000001F, 0xF,
                    0x33FE00000007, 0x3FF8000000000, 0x7FFFF000000000, 0x1FFFFFFFF80000,
                    0x3FFFFFFFFFF, 0xFFFFFFFF00000000, 0xFF0000000000000, 0xC0000000,
                    0xF800000804, 0xFFF0000000000003, 0x800000000000002F, 0x7C000000000,
                    0x7FF80, 0xFFF000000000000F, 0x2000000000, 0x7FFE0000000000,
                    0x3800000000003008, 0x419D000000000000, 0x20F80000000000, 0x7F800000000,
                    0x40000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 2, 2, 5, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 3, 4, 0, 0, 0, 0, 5, 6, 0, 0, 0, 0, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                    16, 0, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 26, 27, 28, 29, 30, 0,
                    31, 0, 0, 0, 32, 0, 0, 0, 33, 34, 0, 35, 36, 37, 38, 0, 0, 0, 0, 0, 39, 0,
                    40, 0, 41, 42, 43, 0, 0, 0, 0, 44, 45, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 48, 49, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 24, 54, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7C0000000000000, 0xF06E, 0xF000000000, 0x20000000000, 0x180000000000,
                    0x1000000000000000, 0xFF00000000000007, 0x1800000000003F,
                    0x1FF000000000007, 0x4, 0x7FF8000000007, 0x60, 0xFFF8000000000007, 0xC000,
                    0x409FF00000000000, 0x2, 0x1FF80000000, 0xC00000000000000F, 0xC0080199F,
                    0xFF00000000000000, 0x37A5, 0xFFE0000000000000, 0x3B, 0xFFFF000000000000,
                    0x3, 0x7F3F800000000000, 0x30000000, 0x7FFF000000000000, 0x1,
                    0x3FF80000000000, 0x7FFE0000000, 0x1FFF00000000000, 0x19BF000000000000,
                    0x5, 0x10FCFE0000, 0x7BE00000000007FE, 0xFFE0000, 0xFFFC00,
                    0x7F7F800000000000, 0x7FFEFFFFFC0000, 0xB47E000000000000, 0x8B, 0x7B7C00,
                    0x78000000000000, 0xC7F000000000000B, 0x7FFFC0000000, 0xFFFFFFFFFFFE8000,
                    0x780FF, 0x3000000000000, 0x40000000, 0x7DBF9FFFF7F, 0x8000, 0x80,
                    0xFFFF03FFFFFF03FF, 0x3FF,
                ],
                };

                pub const OTHER_DEFAULT_IGNORABLE_CODE_POINT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x8000, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6,
                ],
                tree2_level2: &[
                    0, 0x180000000, 0x30000000000000, 0x2000000000, 0x1000000000, 0x100000000,
                    0x1FF000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 2, 0, 0, 0, 3, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFD, 0xFFFFFFFFFFFFFFFF, 0xFFFF000000000000,
                ],
                };

                pub const OTHER_GRAPHEME_EXTEND: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 2, 0, 0, 0, 3, 1, 2, 0, 4, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0,
                    13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0,
                ],
                tree2_level2: &[
                    0, 0x4000000000000000, 0x800000, 0x600D85, 0x80008000, 0x10000000200000,
                    0x2820000000000000, 0x18, 0x40000000000, 0xC000000000000, 0x1000,
                    0xC00000000000, 0x80000, 0x1, 0xC0000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 3, 4, 5, 6, 0, 0, 7, 0, 0, 0, 8, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 12,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 13, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1, 0x20000000000000, 0x4000000000000000, 0x802000, 0x100000000000000,
                    0x83A4, 0x2001000000000000, 0x800000000000, 0x40000000000000, 0x2,
                    0x3000000000000, 0x7E06000000000, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFF,
                ],
                };

                pub const OTHER_ID_CONTINUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x80000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3FE0000000000, 0x4000000, 0x3000, 0x800000000000000, 0x2000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OTHER_ID_START: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x60, 0x400001000000, 0x18000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OTHER_LOWERCASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x400040000000000, 0, 0, 0, 0, 0, 0, 0, 0x1FF000000000000,
                    0x1F00000003, 0, 0x400000000000020, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 0,
                    0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 11, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1000000000000000, 0xFFFFF00000000000, 0x10007FFFFFFFFFF,
                    0xFFFFFFFFF8000000, 0x8002000000000000, 0x1FFF0000, 0xFFFF000000000000,
                    0x3FFFFFF0000, 0x3000000000000000, 0x30000000, 0x1000000000000,
                    0x31C000000000000, 0x200F0000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FDFFFFFFFFFFB9, 0xFFFF000000000000, 0x3FFFFFFFFFFF,
                ],
                };

                pub const OTHER_MATH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x40000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x33000000270000, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4,
                    5, 6, 7, 8, 0, 0, 0, 0, 9, 0, 10, 11, 0, 0, 0, 0, 0, 0, 12, 13, 14, 15, 0,
                    0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 20, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1C000000400000, 0x6000001E00000001, 0x6000, 0xF8621FFF0000,
                    0xF1FBB3103E2FFC84, 0x3E0, 0xF0C33EB6F3E00000, 0x302FEB3FFF, 0xF00,
                    0xB0000000000000, 0x400010000, 0xF07FC00300000000, 0x1F94000F8CC1, 0x60,
                    0x600F00000005, 0xFFC000000060, 0x1FFFFF8, 0x300000000F000000,
                    0x10A00000000, 0x5000000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 1, 1, 1, 1, 7, 8, 9, 10, 11, 12, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 14, 15, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF,
                    0xFFFF7FFFFFFF7FFF, 0xFFFFFDFFFFFFFDFF, 0xFFFFFFFFFFFFCFF7,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF,
                ],
                };

                pub const OTHER_UPPERCASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF00000000, 0xFFC0000000000000, 0xFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0xFFFF03FFFFFF03FF, 0x3FF,
                ],
                };

                pub const PATTERN_SYNTAX: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFC00FFFE00000000, 0x7800000178000001, 0x88435AFE00000000,
                    0x80000000800000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    6, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0,
                    0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FFF00FFFFFF0000, 0x7FEFFFFE, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFF, 0x3FFFFFFFFFFFFF, 0xFFFFFFFFFFF00000, 0x10001FFFFFF0E,
                    0xC000000000000000, 0x60,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const PATTERN_WHITE_SPACE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x100003E00, 0, 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3000000C000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const PREPENDED_CONCATENATION_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x3F, 0, 0, 0x20000000, 0x8000, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x30000, 0x400000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x2000,
                ],
                };

                pub const QUOTATION_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8400000000, 0, 0x800080000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 6, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x6000000FF000000, 0x4, 0xE000F000, 0x1E, 0x84, 0xC00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const RADICAL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFBFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x3FFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const REGIONAL_INDICATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFC000000000,
                ],
                };

                pub const SENTENCE_TERMINAL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8000400200000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0x200, 0, 0xE0000000, 0, 0, 0x100000, 0x7, 0, 0,
                    0x200000000000000,
                ],
                tree2_level1: &[
                    0, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 6, 1, 1, 7, 8, 1, 1, 1, 1, 9, 1, 1, 1, 1,
                    10, 1, 1, 11, 1, 1, 12, 13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14,
                    15, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 16, 1, 1, 1, 1, 17, 18, 1, 1, 1, 1, 1, 1, 19, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 20, 1, 1, 1, 1, 21, 1, 1, 22, 1, 1, 1, 1, 1, 23,
                    1, 21, 24, 1, 1, 25, 1, 26, 1, 27, 1, 1, 1, 28, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 29, 30, 1, 1, 31,
                    32, 1, 1,
                ],
                tree2_level2: &[
                    0x6280000000000000, 0, 0x3000000000, 0xC00, 0x18400000000, 0x400000000000,
                    0x60000000000000, 0x300000, 0x208, 0x30, 0xF0000000000,
                    0xE0000000CC00C000, 0x1800000000000000, 0xC000000000000000,
                    0x3000001000000000, 0x380, 0xE00000000000000, 0x1000400000000000,
                    0x180000, 0x4, 0x8000000000000000, 0xC000, 0x88000000000000,
                    0xC0000000000000, 0x800000000000, 0x300, 0xE0000000, 0x3000000000000,
                    0x80000000000, 0x640000, 0xC40000, 0x80004002, 0x200000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 4, 5, 6, 0, 7, 0, 8, 9, 0,
                    10, 0, 0, 0, 0, 11, 0, 12, 0, 0, 0, 0, 0, 13, 0, 14, 0, 0, 15, 0, 0, 0, 0,
                    0, 0, 0, 0, 16, 0, 0, 0, 17, 18, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 19, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 22, 19, 23, 0, 0, 0, 0,
                    0, 0, 0, 21, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC00000, 0x3E00000, 0x3C0, 0x180, 0xC000000000000000, 0x3, 0xE,
                    0xC0002060, 0x1B00000000000000, 0x20000000000, 0x300000, 0x1800, 0xFFFE0C,
                    0x6, 0x7000000000000000, 0x50, 0xC, 0x18000000, 0x180000000000000, 0x18,
                    0xC00000000000, 0x20000000000000, 0x10, 0x1000000, 0x80000000, 0x100,
                ],
                };

                pub const SOFT_DOTTED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x60000000000, 0, 0, 0x800000000000, 0, 0, 0, 0, 0x10000000200,
                    0x4000020000000, 0, 0, 0, 0, 0x8000000000000, 0, 0x1400000, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0, 0, 0, 0, 5, 0, 0,
                    0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x400000000, 0x11000400000, 0x200000000000, 0x800, 0x2000000000000,
                    0x300, 0x1000000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    12, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC00000000, 0xC00000, 0xC000000000000C00, 0xC000000000000,
                    0xC000000000, 0xC000000, 0xC000, 0xC000000000000C, 0xC0000000000,
                    0xC0000000, 0xC0000, 0x4000000, 0x10000003000,
                ],
                };

                pub const TERMINAL_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8C00500200000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x4000000000000000, 0x80, 0, 0, 0, 0, 0, 0, 0, 0x200, 0x8, 0xE8001000, 0,
                    0, 0x100000, 0x17FF, 0, 0, 0x300000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    4, 2, 2, 5, 2, 2, 2, 2, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 8, 2, 9, 10, 2, 2, 11, 12, 2, 2, 2, 2, 13, 2, 2, 2,
                    2, 14, 2, 2, 15, 2, 2, 16, 17, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    18, 19, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 20, 2, 2, 2, 2, 21, 22, 2, 2, 2, 2, 2, 2, 23, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 17, 2, 2, 2, 2, 24, 2, 2, 25, 2, 2, 2, 2, 2,
                    26, 2, 27, 28, 2, 2, 19, 2, 29, 2, 30, 2, 2, 2, 31, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 33, 2,
                    2, 34, 35, 2, 2,
                ],
                tree2_level2: &[
                    0x7FBF000000000000, 0x40000000, 0, 0x3000000000, 0xC000000, 0x7E100,
                    0xC00, 0x1FE00000000, 0x400000000000, 0x380000000000, 0x60000000000000,
                    0x4700000, 0x33C, 0x30, 0xF0000000000, 0xE0000000EC00C000,
                    0xF800000000000000, 0xC000000000000000, 0x3000001000000000, 0x380,
                    0xE00000000000000, 0x1000400000000000, 0x18D002, 0x6, 0xE000,
                    0xF8000000000000, 0xC0000000000000, 0xC000, 0x800000000000, 0xE0000000,
                    0x3000080000000, 0x80000000000, 0x640000, 0xF70000, 0x8C005002,
                    0x1200000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 3, 3, 3, 3, 5, 3, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 4, 0, 5, 6, 0, 7, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 10, 11, 12, 0, 13, 0, 14, 15,
                    0, 16, 0, 0, 0, 0, 17, 0, 18, 0, 0, 0, 0, 0, 19, 0, 20, 0, 0, 21, 0, 0, 0,
                    0, 0, 0, 0, 0, 22, 0, 0, 0, 23, 24, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 26, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 33,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x80000000, 0x10000, 0x800000, 0xC00000, 0x3F000000000000,
                    0xFC00000000000000, 0x1E000000, 0x3E00000, 0x3C0, 0x3F80,
                    0xC000000000000000, 0x3, 0xE, 0xC0002060, 0x1F00000000000000,
                    0x20000000000, 0x300000, 0xC003800, 0xFFFE3C, 0x6, 0x7000000000000000,
                    0x50, 0xC, 0x618000000, 0x200000000000E, 0x180000000000000, 0x18,
                    0x1F000000000000, 0xC00000000000, 0x20000000000000, 0x380000000000000,
                    0x10, 0x1800000, 0x780,
                ],
                };

                pub const UNIFIED_IDEOGRAPH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x39A801AC000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 2, 3, 4, 1, 5, 0, 1, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 7, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF, 0x3FFFFFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF,
                    0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF, 0xFFFFFFFFFFFF07FF,
                    0xFFFFFFFFFFFF,
                ],
                };

                pub const UPPERCASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE, 0, 0x7F7FFFFF, 0xAA55555555555555, 0x2B555555555554AA,
                    0x11AED2D5B1DBCED6, 0x55D255554AAAA490, 0x6C05555555555555, 0x557A, 0, 0,
                    0, 0x8045000000000000, 0xFFBFFFED740, 0xE6905555551C8000, 0xFFFFFFFFFFFF,
                    0x5555555500000000, 0x5555555555555401, 0x5555555555552AAB,
                    0xFFFE555555555555, 0x7FFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 11, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17,
                    5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x20BF, 0x3FFFFFFFFFFFFF, 0xE7FFFFFFFFFF0200,
                    0x5555555555555555, 0x5555555540155555, 0xFF00FF003F00FF00,
                    0xFF00AA003F00, 0xF00000000000000, 0xF001F000F000F00, 0xC00F3D503E273884,
                    0xFFFF00000020, 0x8, 0xFFC0000000000000, 0xFFFF, 0xFFFFFFFFFFFF,
                    0xC025EA9D00000000, 0x4280555555555, 0x155555555555, 0x5555555,
                    0x5554555400000000, 0x6A00555555555555, 0x555F7D5555452855,
                    0x20000015411AF5, 0x7FFFFFE00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11,
                    12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 27, 28, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF, 0xFFFF000000000000, 0xFFFFF, 0xF7FF000000000000,
                    0x37F7FF, 0x7FFFFFFFFFFFF, 0x3FFFFF0000, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0xFFF0000003FFFFFF, 0xFFFFFF0000003FFF, 0x3FDE64D0000003, 0x3FFFFFF0000,
                    0x7B0000001FDFE7B0, 0xFFFFF0000001FC5F, 0x3FFFFFF0000003F, 0x3FFFFFF00000,
                    0xF0000003FFFFFF00, 0xFFFF0000003FFFFF, 0xFFFFFF00000003FF,
                    0x7FFFFFC00000001, 0x1FFFFFF0000000, 0x7FFFFFC00000, 0x1FFFFFF0000, 0x400,
                    0x3FFFFFFFF, 0xFFFF03FFFFFF03FF, 0x3FF,
                ],
                };

                pub const VARIATION_SELECTOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xB800, 0xFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const WHITE_SPACE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x100003E00, 0, 0x100000020, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x8300000007FF, 0x80000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const XID_CONTINUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0x7FFFFFE87FFFFFE, 0x4A0040000000000,
                    0xFF7FFFFFFF7FFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3,
                    0xFFFFFFFFFFFFFFFF, 0xB8DFFFFFFFFFFFFF, 0xFFFFFFFBFFFFD7C0,
                    0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFCFB, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF,
                    0xFFFFFFFF027FFFFF, 0xBFFFFFFFFFFE01FF, 0x787FFFFFF00B6,
                    0xFFFFFFFF07FF0000, 0xFFFFC3FFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x9FFFFDFF9FEFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFFE7FF,
                    0x3FFFFFFFFFFFF, 0x243FFFFFFFFFFFFF,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 4, 32, 33, 34, 4, 4, 4, 4, 4,
                    35, 36, 37, 38, 39, 40, 41, 42, 4, 4, 4, 4, 4, 4, 4, 4, 43, 44, 45, 46,
                    47, 4, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 4, 61, 4, 62,
                    63, 64, 65, 66, 4, 4, 4, 4, 4, 4, 4, 4, 67, 68, 69, 70, 71, 72, 73, 74,
                    75, 76, 77, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 4, 4, 4, 79, 80, 81, 82, 83, 78, 78, 78,
                    78, 78, 78, 78, 78, 84, 42, 85, 4, 86, 4, 87, 88, 78, 78, 78, 78, 78, 78,
                    78, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 89, 90, 4, 4, 4, 4, 91, 92, 4, 93, 94, 4, 95, 96, 97, 62, 4,
                    98, 99, 100, 4, 101, 102, 103, 4, 104, 105, 106, 4, 107, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 108, 109, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 4, 4, 4, 4, 4, 99, 4, 110, 111, 112, 93, 113, 4, 114, 4,
                    4, 115, 116, 117, 118, 119, 120, 4, 121, 122, 123, 124, 125,
                ],
                tree2_level2: &[
                    0x3FFFFFFFFFFF, 0xFFFF07FF0FFFFFFF, 0xFFFFFFFFFF807EFF,
                    0xFFFFFFFBFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFCFFFFFFFFF,
                    0xF3C5FDFFFFF99FEF, 0x5003FFCFB080799F, 0xD36DFDFFFFF987EE,
                    0x3FFFC05E023987, 0xF3EDFDFFFFFBBFEE, 0xFE00FFCF00013BBF,
                    0xF3EDFDFFFFF99FEE, 0x2FFCFB0E0399F, 0xC3FFC718D63DC7EC, 0xFFC000813DC7,
                    0xF3FFFDFFFFFDDFFF, 0xFFCF27603DDF, 0xF3EFFDFFFFFDDFEF, 0xEFFCF60603DDF,
                    0xFFFFFFFFFFFDDFFF, 0xFC00FFCF80F07DDF, 0x2FFBFFFFFC7FFFEE,
                    0xCFFC0FF5F847F, 0x7FFFFFFFFFFFFFE, 0x3FF7FFF, 0x3FFFFFAFFFFFF7D6,
                    0xF3FF7F5F, 0xC2A003FF03000001, 0xFFFE1FFFFFFFFEFF, 0x1FFFFFFFFEFFFFDF,
                    0x40, 0xFFFFFFFFFFFF03FF, 0xFFFFFFFF3FFFFFFF, 0xF7FFFFFFFFFF20BF,
                    0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D,
                    0xFFFFFFFFFF3DFFFF, 0x3FE00E7FFFFFF, 0xFFFFFFFF0000FFFF,
                    0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE, 0xFFFF9FFFFFFFFFFF,
                    0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF, 0x1FFFFF803FFFFF, 0xDDFFF000FFFFF,
                    0x3FF308FFFFF, 0xFFFFFFFF03FFB800, 0x1FFFFFFFFFFFFFF, 0xFFFF07FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0xFFF0FFF7FFFFFFF, 0x1F3FFFFFFFFFC0, 0xFFFF0FFFFFFFFFFF,
                    0x7FF03FF, 0xFFFFFFFF0FFFFFFF, 0x9FFFFFFF7FFFFFFF, 0xBFFF008003FF03FF,
                    0x7FFF, 0xFF80003FF1FFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF,
                    0x3FFFFFFFFFFFE3FF, 0xE7FFFFFFFFFF07FF, 0x7FFFFFFFFF70000,
                    0xFFFFFFFF3F3FFFFF, 0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF,
                    0x1FDC1FFF0FCF1FDC, 0x8000000000003000, 0x8002000000100001, 0x1FFF0000,
                    0x1FFE21FFF0000, 0xF3FFFD503F2FFC84, 0xFFFFFFFF000043E0, 0x1FF, 0,
                    0xFF81FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x800080FFFFFFFFFF,
                    0x7F7F7F7F007FFFFF, 0xFFFFFFFF7F7F7F7F, 0x1F3EFFFE000000E0,
                    0xFFFFFFFEE67FFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xFFFFFFF1FFF,
                    0xBFF0FFFFFFFFFFFF, 0x3FFFFFFFFFFFF, 0xFFFFFFFCFF800000,
                    0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x10FFFFFFFFFF,
                    0xE8FFFFFF03FF003F, 0xFFFF3FFFFFFFFFFF, 0x1FFFFFFF000FFFFF,
                    0x7FFFFFFF03FF8001, 0x7FFFFFFFFFFFFF, 0xFC7FFFFF03FF3FFF,
                    0x7CFFFF38000007, 0xFFFF7F7F007E7E7E, 0xFFFF03FFF7FFFFFF,
                    0x3FF37FFFFFFFFFF, 0xFFFF000FFFFFFFFF, 0xFFFFFFFFFFFF87F, 0x3FFFFFF,
                    0x5F7FFDFFE0F8007F, 0xFFFFFFFFFFFFFFDB, 0xFFFFFFFFFFF80000,
                    0xFFFFFFF03FFFFFFF, 0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000,
                    0xFFFFFFFFFFFCFFFF, 0x3FF0000000000FF, 0x18FFFF0000FFFF,
                    0xAA8A00000000E000, 0x1FFFFFFFFFFFFFFF, 0x87FFFFFE03FF0000,
                    0xFFFFFFE007FFFFFE, 0x7FFFFFFFFFFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 6, 4, 4, 7, 8, 9, 10, 11, 12, 2, 2, 13, 14, 15, 16,
                    17, 18, 2, 2, 2, 2, 19, 20, 21, 4, 22, 23, 24, 25, 26, 4, 27, 4, 28, 29,
                    30, 31, 32, 33, 34, 4, 2, 35, 36, 36, 37, 38, 39, 4, 4, 4, 40, 41, 42, 43,
                    44, 45, 2, 46, 3, 47, 48, 49, 2, 50, 51, 52, 53, 54, 55, 56, 57, 58, 2,
                    59, 2, 60, 4, 4, 61, 62, 2, 63, 64, 65, 66, 67, 4, 4, 3, 4, 68, 69, 70,
                    71, 72, 73, 74, 75, 76, 64, 4, 4, 4, 77, 78, 79, 80, 4, 81, 82, 83, 4, 4,
                    4, 4, 84, 85, 86, 87, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 88, 4,
                    2, 89, 2, 2, 2, 90, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 91, 92,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 93, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 67, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 64, 96, 74, 97, 19, 98, 99, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 35, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 112, 4, 4, 4, 4, 4, 4, 4, 4, 113, 67, 4, 4, 4, 4, 4, 4, 4,
                    114, 115, 4, 4, 116, 4, 4, 4, 4, 4, 4, 2, 117, 118, 119, 120, 121, 2, 2,
                    2, 2, 122, 123, 124, 125, 126, 127, 4, 4, 4, 4, 4, 4, 4, 4, 128, 129, 130,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 131, 4, 4, 4, 132, 133,
                    134, 4, 135, 136, 4, 4, 4, 4, 137, 95, 4, 4, 4, 4, 4, 4, 4, 138, 4, 4, 4,
                    139, 4, 4, 4, 4, 4, 4, 4, 140, 2, 2, 2, 141, 2, 142, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 143, 144, 145, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 112, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 146, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 95, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    147, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 148, 2, 2, 2, 2, 2, 2, 2, 2, 2, 149, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 149, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 150, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 93, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2,
                    93, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0x2000000000000000, 0xFFFFFFFF1FFFFFFF, 0x10001FFFF,
                    0xFFFFE000FFFFFFFF, 0x7FFFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F,
                    0xFFFF03FF3FFFFFFF, 0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF,
                    0xF7FF000FFFFFFFFF, 0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF,
                    0xFF003FFFFF, 0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF,
                    0x7FFFFFFF, 0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF,
                    0x873FFFFFFEEFF06F, 0x1FFFFFFF00000000, 0x1FFFFFFF, 0x7FFFFFFEFF,
                    0x3FFFFFFFFFFFFF, 0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF,
                    0x3FF00FFFFFFFFFF, 0xFFFFBE3FFFFFFFFF, 0x3F, 0x31BFFFFFFFFFF,
                    0xF00000000000001C, 0xFFFF00801FFFFFFF, 0xFFFF00000001FFFF,
                    0xFFFF00000000003F, 0x7FFFFF0000001F, 0x803FFFC00000007F,
                    0x3FF01FFFFFF0004, 0xFFDFFFFFFFFFFFFF, 0x4FFFFFFFFF00F0, 0x17FFDE1F,
                    0xC0FFFFFFFFFBFFFF, 0x3, 0xFFFF01FFBFFFBD7F, 0x3FF07FFFFFFFFFF,
                    0xFBEDFDFFFFF99FEF, 0x1F1FCFE081399F, 0xFFBFFFFFFFFF4BFF, 0x6000FF7A5,
                    0x3C3FF07FF, 0x3FF00BF, 0xFF3FFFFFFFFFFFFF, 0x3F000001, 0x3FF0011,
                    0x1FFFFFFFFFFFFFF, 0xFFFFF03FF, 0x3FF0FFFE7FFFFFF, 0x7F,
                    0xFFFFFFFF00000000, 0x800003FFFFFFFFFF, 0xF9BFFFFFFF6FF27F, 0x3FF000F,
                    0xFFFFFCFF00000000, 0x1BFCFFFFFF, 0x7FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0080,
                    0xFFFF000023FFFFFF, 0x3FF0001FFFFFFFF, 0xFF7FFFFFFFFFFDFF,
                    0xFFFC000003FF0001, 0x7FFEFFFFFCFFFF, 0xB47FFFFFFFFFFB7F,
                    0xFFFFFDBF03FF00FF, 0x3FF01FB7FFF, 0x7FFFFF00000000, 0xC7FFFFFFFFFDFFFF,
                    0x7FF0007, 0x1000000000000, 0x3FFFFFF, 0x7FFFFFFFFFFF, 0xF,
                    0xFFFFFFFFFFFF0000, 0x1FFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0xFFFFFFFF003FFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF03FF7FFFFFFF, 0x1F3FFFFFFF03FF,
                    0xE0FFFFF803FF000F, 0xFFFF, 0x3FF1FFFFFFFFFFF, 0xFFFFFFFFFFFF87FF,
                    0xFFFF80FF, 0x3001B00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                    0x6FEF000000000000, 0x40007FFFFFFFF, 0xFFFF00F000270000,
                    0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x63FF01FF, 0x3FF000000000000,
                    0xFFFF3FFFFFFFFFFF, 0xF807E3E000000000, 0x3C0000000FE7, 0x1C,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFFFFFFFFFFFFCFF7, 0xF87FFFFFFFFFFFFF,
                    0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7E07FFFFFFF, 0xFFFF07DBF9FFFF7F,
                    0x3FFFFFFFFFFF, 0x8000, 0x3FFF1FFFFFFFFFFF, 0x43FF, 0x7FFFFFFF0000,
                    0x3FFFFFFFFFF0000, 0x7FFFFFFFFFF0000, 0x7FFF6F7F00000000, 0x7F001F,
                    0x3FF0FFF, 0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF,
                    0xFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const XID_START: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3, 0, 0xB8DF000000000000,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF027FFFFF, 0x1FF, 0x787FFFFFF0000,
                    0xFFFFFFFF00000000, 0xFFFEC000000007FF, 0xFFFFFFFFFFFFFFFF,
                    0x9C00C060002FFFFF, 0xFFFFFFFD0000, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF,
                    0x43007FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 35, 35,
                    35, 35, 36, 37, 38, 39, 40, 41, 42, 43, 35, 35, 35, 35, 35, 35, 35, 35,
                    44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 3, 58, 59, 60, 30,
                    61, 62, 63, 64, 65, 66, 67, 68, 35, 35, 35, 30, 35, 35, 35, 35, 69, 70,
                    71, 72, 30, 73, 74, 30, 75, 76, 77, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 78,
                    79, 80, 81, 82, 30, 30, 30, 30, 30, 30, 30, 30, 83, 43, 84, 85, 86, 35,
                    87, 88, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 30, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 89, 90, 35, 35, 35, 35, 91, 92,
                    93, 94, 95, 35, 96, 97, 98, 49, 99, 100, 101, 102, 103, 104, 105, 106,
                    107, 108, 109, 110, 35, 111, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 112, 113, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 114, 35, 115, 116,
                    117, 118, 119, 35, 120, 35, 35, 121, 122, 123, 124, 30, 125, 35, 126, 127,
                    128, 129, 130,
                ],
                tree2_level2: &[
                    0x110043FFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00007EFF, 0x3FF,
                    0x23FFFFFFFFFFFFF0, 0xFFFE0003FF010000, 0x23C5FDFFFFF99FE1,
                    0x10030003B0004000, 0x36DFDFFFFF987E0, 0x1C00005E000000,
                    0x23EDFDFFFFFBBFE0, 0x200000300010000, 0x23EDFDFFFFF99FE0,
                    0x20003B0000000, 0x3FFC718D63DC7E8, 0x10000, 0x23FFFDFFFFFDDFE0,
                    0x327000000, 0x23EFFDFFFFFDDFE1, 0x6000360000000, 0x27FFFFFFFFFDDFF0,
                    0xFC00000380704000, 0x2FFBFFFFFC7FFFE0, 0x7F, 0x5FFFFFFFFFFFE,
                    0x2005FFAFFFFFF7D6, 0xF000005F, 0x1, 0x1FFFFFFFFEFF, 0x1F00, 0,
                    0x800007FFFFFFFFFF, 0xFFE1C0623C3F0000, 0xFFFFFFFF00004003,
                    0xF7FFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF,
                    0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x7FFFFFF,
                    0xFFFFFFFF0000FFFF, 0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF,
                    0x3FFFF8003FFFF, 0x1DFFF0003FFFF, 0xFFFFFFFFFFFFF, 0x10800000,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFFF, 0xFFFF05FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0x7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF,
                    0xFFFFFFFF007FFFFF, 0x1FFFFF, 0x8000000000, 0xFFFFFFFFFFFE0, 0x1FE0,
                    0xFC00C001FFFFFFF8, 0x3FFFFFFFFF, 0xFFFFFFFFF, 0x3FFFFFFFFC00E000,
                    0xE7FFFFFFFFFF07FF, 0x46FDE0000000000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF3FFFD503F2FFC84, 0xFFFFFFFF000043E0,
                    0x1FF, 0xC781FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x80FFFFFFFFFF,
                    0x7F7F7F7F007FFFFF, 0x7F7F7F7F, 0x1F3E03FE000000E0, 0xFFFFFFFEE07FFFFF,
                    0xF7FFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xC00FFFF1FFF,
                    0x80007FFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFFFFFFFFFFFF,
                    0xFFFFFFFCFF800000, 0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x7FFFFF7BB,
                    0xFFFFFFFFFFFFC, 0x68FC000000000000, 0xFFFF003FFFFFFC00,
                    0x1FFFFFFF0000007F, 0x7FFFFFFFFFFF0, 0x7C00FFDF00008000, 0x1FFFFFFFFFF,
                    0xC47FFFFF00000FF7, 0x3E62FFFFFFFFFFFF, 0x1C07FF38000005,
                    0xFFFF7F7F007E7E7E, 0xFFFF03FFF7FFFFFF, 0x7FFFFFFFF, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFA0F8007F,
                    0xFFFFFFFFFFFFFFDB, 0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000,
                    0xFFFFFFF03FFFFFFF, 0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000,
                    0xFFFFFFFFFFFCFFFF, 0x3FF0000000000FF, 0xAA8A000000000000,
                    0x1FFFFFFFFFFFFFFF, 0x7FFFFFE00000000, 0xFFFFFFC007FFFFFE,
                    0x7FFFFFFF3FFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 5, 11, 12, 5, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 13, 14, 15, 7, 16, 17, 7, 18, 19, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15,
                    16, 17, 2, 2, 2, 2, 18, 19, 20, 4, 21, 22, 23, 24, 25, 4, 26, 4, 27, 28,
                    29, 30, 31, 32, 33, 4, 2, 34, 35, 35, 36, 37, 38, 4, 4, 4, 39, 40, 41, 42,
                    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 23, 56, 57, 58, 59, 5,
                    60, 61, 62, 4, 4, 63, 64, 61, 65, 66, 4, 67, 68, 4, 4, 69, 4, 70, 71, 72,
                    73, 74, 75, 76, 77, 78, 79, 4, 4, 4, 80, 81, 82, 83, 4, 84, 85, 86, 4, 4,
                    4, 4, 87, 88, 4, 89, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 4,
                    2, 63, 2, 2, 2, 91, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 92, 93,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 61, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 68, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 79, 96, 97, 98, 61, 99, 83, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 34, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 112, 113, 114,
                    115, 116, 2, 2, 2, 2, 117, 118, 119, 120, 121, 122, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 123, 4, 4,
                    4, 124, 125, 4, 4, 126, 127, 4, 4, 4, 4, 98, 69, 4, 4, 4, 4, 4, 4, 4, 128,
                    4, 4, 4, 129, 4, 4, 4, 4, 4, 4, 4, 130, 2, 2, 2, 131, 2, 132, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 133, 134, 135, 4, 4, 4, 4, 4, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 136, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 137, 2, 2, 2, 10, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 138, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 139, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2,
                    95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 140, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 61, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF,
                    0x3FFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F, 0xFFFF00003FFFFFFF,
                    0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF, 0xF7FF000FFFFFFFFF,
                    0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                    0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF,
                    0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEF0001,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF, 0xFFFFFFFFF,
                    0xFFFF803FFFFFFC00, 0x3F, 0x303FFFFFFFFFF, 0x1C, 0xFFFF00801FFFFFFF,
                    0xFFFF00000000003F, 0xFFFF000000000003, 0x7FFFFF0000001F,
                    0xFFFFFFFFFFFFF8, 0x26000000000000, 0xFFFFFFFFFFF8, 0x1FFFFFF0000,
                    0x7FFFFFFFF8, 0x47FFFFFFFF0090, 0x7FFFFFFFFFFF8, 0x1400001E,
                    0x80000FFFFFFBFFFF, 0x1, 0xFFFF01FFBFFFBD7F, 0x23EDFDFFFFF99FE0,
                    0x3E0010000, 0xBFFFFFFFFF4BFF, 0xA0000, 0x380000780, 0xFFFFFFFFFFFF, 0xB0,
                    0x7FFFFFFFFFFF, 0xF000000, 0x10, 0x10007FFFFFFFFFF, 0x7FFFFFF, 0x7F,
                    0xFFFFFFFFFFF, 0xFFFFFFFF00000000, 0x80000000FFFFFFFF, 0x8000FFFFFF6FF27F,
                    0x2, 0xFFFFFCFF00000000, 0xA0001FFFF, 0x407FFFFFFFFF801,
                    0xFFFFFFFFF0010000, 0xFFFF0000200003FF, 0x1FFFFFFFFFFFFFF, 0x1FFFFFFFF,
                    0x7FFFFFFFFDFF, 0xFFFC000000000001, 0xFFFF, 0x1FFFFFFFFFB7F,
                    0xFFFFFDBF00000040, 0x10003FF, 0x7FFFF00000000, 0xFFFFFFFFDFFF4,
                    0x1000000000000, 0x3FFFFFF, 0xF, 0xFFFFFFFFFFFF0000, 0x1FFFFFFFFFFFF,
                    0xFFFFFFFF0000007E, 0x3FFFFFFF, 0xFFFF00007FFFFFFF, 0x7FFFFFFFFFFFFFFF,
                    0x3FFFFFFF0000, 0xE0FFFFF80000000F, 0x1FFFFFFFFFFF, 0x107FF, 0xFFF80000,
                    0xB00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF, 0x6FEF000000000000,
                    0x40007FFFFFFFF, 0xFFFF00F000270000, 0xFFFFFFFFFFFFFFF,
                    0x1FFF07FFFFFFFFFF, 0x3FF01FF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF,
                    0xFFFF7FFFFFFF7FFF, 0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFFFF,
                    0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x3F801FFFFFFFFFFF, 0x4000,
                    0xFFFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F, 0x80F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };
            }
            static BINARY_PROPERTY_NAMES = [
                // ASCII_HEX_DIGIT, // let this one be stripped out -- the full trie is wasteful for ASCII
                ALPHABETIC, BIDI_CONTROL, CASE_IGNORABLE, CASED, CHANGES_WHEN_CASEFOLDED,
                CHANGES_WHEN_CASEMAPPED, CHANGES_WHEN_LOWERCASED, CHANGES_WHEN_TITLECASED,
                CHANGES_WHEN_UPPERCASED, DASH, DEFAULT_IGNORABLE_CODE_POINT, DEPRECATED, DIACRITIC,
                EMOJI, EMOJI_COMPONENT, EMOJI_MODIFIER, EMOJI_MODIFIER_BASE, EMOJI_PRESENTATION, EXTENDED_PICTOGRAPHIC,
                EXTENDER, GRAPHEME_BASE, GRAPHEME_EXTEND, GRAPHEME_LINK, HEX_DIGIT, HYPHEN,
                IDS_BINARY_OPERATOR, IDS_TRINARY_OPERATOR, ID_CONTINUE, ID_START, IDEOGRAPHIC, JOIN_CONTROL,
                LOGICAL_ORDER_EXCEPTION, LOWERCASE, MATH, NONCHARACTER_CODE_POINT, OTHER_ALPHABETIC,
                OTHER_DEFAULT_IGNORABLE_CODE_POINT, OTHER_GRAPHEME_EXTEND, OTHER_ID_CONTINUE,
                OTHER_ID_START, OTHER_LOWERCASE, OTHER_MATH, OTHER_UPPERCASE, PATTERN_SYNTAX,
                PATTERN_WHITE_SPACE, PREPENDED_CONCATENATION_MARK, QUOTATION_MARK, RADICAL,
                REGIONAL_INDICATOR, SENTENCE_TERMINAL, SOFT_DOTTED, TERMINAL_PUNCTUATION, UNIFIED_IDEOGRAPH,
                UPPERCASE, VARIATION_SELECTOR, WHITE_SPACE, XID_CONTINUE, XID_START,
            ];
        }

        char_property_functions! {
            mod category
            {
                // DO NOT EDIT THIS FILE. IT WAS AUTOMATICALLY GENERATED BY:
                //
                //   ucd-generate general-category --trie-set ./target/ucd/
                //
                // Unicode version: 16.0.0.
                //
                // ucd-generate 0.3.1 is available on crates.io.

                pub const BY_NAME: &'static [(&'static str, &'static ::ucd_trie::TrieSet)] = &[
                ("Cased_Letter", CASED_LETTER), ("Close_Punctuation", CLOSE_PUNCTUATION),
                ("Connector_Punctuation", CONNECTOR_PUNCTUATION), ("Control", CONTROL),
                ("Currency_Symbol", CURRENCY_SYMBOL),
                ("Dash_Punctuation", DASH_PUNCTUATION), ("Decimal_Number", DECIMAL_NUMBER),
                ("Enclosing_Mark", ENCLOSING_MARK),
                ("Final_Punctuation", FINAL_PUNCTUATION), ("Format", FORMAT),
                ("Initial_Punctuation", INITIAL_PUNCTUATION), ("Letter", LETTER),
                ("Letter_Number", LETTER_NUMBER), ("Line_Separator", LINE_SEPARATOR),
                ("Lowercase_Letter", LOWERCASE_LETTER), ("Mark", MARK),
                ("Math_Symbol", MATH_SYMBOL), ("Modifier_Letter", MODIFIER_LETTER),
                ("Modifier_Symbol", MODIFIER_SYMBOL), ("Nonspacing_Mark", NONSPACING_MARK),
                ("Number", NUMBER), ("Open_Punctuation", OPEN_PUNCTUATION),
                ("Other", OTHER), ("Other_Letter", OTHER_LETTER),
                ("Other_Number", OTHER_NUMBER), ("Other_Punctuation", OTHER_PUNCTUATION),
                ("Other_Symbol", OTHER_SYMBOL),
                ("Paragraph_Separator", PARAGRAPH_SEPARATOR), ("Private_Use", PRIVATE_USE),
                ("Punctuation", PUNCTUATION), ("Separator", SEPARATOR),
                ("Space_Separator", SPACE_SEPARATOR), ("Spacing_Mark", SPACING_MARK),
                ("Surrogate", SURROGATE), ("Symbol", SYMBOL),
                ("Titlecase_Letter", TITLECASE_LETTER), ("Unassigned", UNASSIGNED),
                ("Uppercase_Letter", UPPERCASE_LETTER),
                ];

                pub const CASED_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x20000000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xF7FFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFF0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFEFFFFF, 0, 0, 0xB8CF000000000000, 0xFFFFFFFBFFFFD740,
                    0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF,
                    0xFFFFFFFF007FFFFF, 0x1FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 6, 7, 0, 8, 8, 8, 8, 9, 10, 11, 12, 0, 0, 0,
                    0, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 16, 8,
                    17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 25, 26, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 29, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xE7FFFFFFFFFF20BF, 0x3F3FFFFFFFFFFFFF,
                    0xE7FFFFFFFFFF07FF, 0xFFFFFFFFFFF, 0xFEFFF80000000000, 0x7FFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3F3FFFFF, 0x3FFFFFFFAAFF3F3F,
                    0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC, 0xF21FBD503E2FFC84, 0x43E0, 0x18,
                    0xCFFFFFFFFFFFFFFF, 0xC781FFFFFFFFF, 0x20BFFFFFFFFF, 0x3FFFFFFFFFFF,
                    0xFFFFFFF, 0xFFFFFFFC00000000, 0xFFFEFFFFFFFFFFFF, 0xFFFFFFFFFFFF78FF,
                    0x46000001FEB3FFF, 0xFFFF000000000000, 0xFFFF01FF07FFFFFF, 0xF8007F,
                    0x7FFFFFE00000000, 0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 5, 6, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    7, 7, 0, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,
                    11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    12, 13, 14, 15, 16, 1, 1, 1, 1, 17, 18, 19, 20, 21, 22, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF, 0xFFFF000000000000, 0xFFFFFFFFF0FFFFF,
                    0xF7FF000000000000, 0x1BFBFFFBFFB7F7FF, 0x7FFFFFFFFFFFF,
                    0xFFFF003FFFFF0000, 0x3F, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFBFF, 0xF,
                ],
                };

                pub const CLOSE_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x20000000000, 0x2000000020000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 7, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 10, 11, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 14, 15, 0, 0, 16, 17, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2800000000000000, 0x10000000, 0x4000000000000040, 0x4000,
                    0x40000000A00, 0x2AAA0000000000, 0xAA8000000040, 0x1555550,
                    0x200000000A000000, 0x2A800000000, 0x15400000, 0xCAA2AA00,
                    0x4000000000000000, 0x5540000001000000, 0x54000115, 0x2000000000000200,
                    0x920000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CONNECTOR_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x80000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 0, 0, 1, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x8000000000000000, 0x100001, 0x18000000000000, 0xE000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CONTROL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFFFFFFFF, 0x8000000000000000, 0xFFFFFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CURRENCY_SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x1000000000, 0, 0x3C00000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0x8000, 0, 0x800, 0, 0, 0, 0, 0, 0, 0xC000000000000000,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 10, 0, 0, 11, 0, 0, 12,
                ],
                tree2_level2: &[
                    0, 0x80C000000000000, 0x2000000000000, 0x200000000000000,
                    0x8000000000000000, 0x8000000, 0xFFFFFFFF00000000, 0x1, 0x100000000000000,
                    0x1000000000000000, 0x20000000000, 0x10, 0x6300000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1E0000000, 0x8000000000000000, 0x1000000000000,
                ],
                };

                pub const DASH_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0x4000000000000400, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 4, 5, 0, 0, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 10, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x40, 0x3F0000, 0xC00000004800000, 0x20000001, 0x1000010000000,
                    0x100000000, 0x6000000000000, 0x801000000, 0x2000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x400000000000, 0x200000000000,
                ],
                };

                pub const DECIMAL_NUMBER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0x3FF00000000, 0, 0x3FF000000000000, 0, 0, 0, 0x3FF,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
                    2, 0, 2, 3, 0, 0, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0, 0, 5, 0, 2, 0, 0, 6,
                    0, 0, 2, 7, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0, 8, 0, 2,
                    0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFC000000000, 0x3FF0000, 0x3FF00000000, 0x3FF, 0xFFC0, 0x3FF03FF,
                    0x3FF000000000000, 0x3FF000003FF0000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 4, 5, 6, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 5, 0, 0, 6, 0, 0, 0,
                    2, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 6, 0, 7, 2, 0, 0, 0, 0, 0, 0, 1,
                    0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 6, 1, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
                    0, 0, 0, 2, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF00000000, 0x3FF000000000000, 0x3FF, 0xFFC000000000,
                    0xFFC0000000000000, 0x3FF0000, 0xFFFFF03FF, 0xFFFFFFFFFFFFC000,
                    0x7FE000000000000,
                ],
                };

                pub const ENCLOSING_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x300, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x4000000000000000, 0x1DE0000000, 0x7000000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const FINAL_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x800000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x400000022000000, 0x220002428,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const FORMAT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0x1000003F, 0, 0, 0x20000000, 0x8000, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 7,
                ],
                tree2_level2: &[
                    0, 0x30000, 0x400000000, 0x4000, 0x7C000000F800, 0xFFDF00000000,
                    0x8000000000000000, 0xE00000000000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x2000, 0xFFFF000000000000, 0xF00000000,
                    0x7F8000000000000, 0xFFFFFFFF00000002, 0xFFFFFFFFFFFFFFFF,
                ],
                };

                pub const INITIAL_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x80000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x200000099000000, 0x110001214,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3, 0, 0xBCDF000000000000,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF027FFFFF, 0x1FF, 0x787FFFFFF0000,
                    0xFFFFFFFF00000000, 0xFFFEC000000007FF, 0xFFFFFFFFFFFFFFFF,
                    0x9C00C060002FFFFF, 0xFFFFFFFD0000, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF,
                    0x43007FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 35, 35,
                    35, 35, 36, 37, 38, 39, 40, 41, 42, 43, 35, 35, 35, 35, 35, 35, 35, 35,
                    44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 3, 58, 59, 60, 30,
                    61, 62, 63, 64, 65, 66, 67, 68, 35, 35, 35, 30, 35, 35, 35, 35, 69, 70,
                    71, 72, 30, 73, 74, 30, 75, 76, 77, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 78,
                    79, 80, 81, 82, 83, 30, 30, 30, 30, 30, 30, 30, 84, 43, 85, 86, 87, 35,
                    88, 89, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 30, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 90, 91, 35, 35, 35, 35, 92, 93,
                    94, 64, 95, 35, 96, 97, 98, 49, 99, 100, 101, 102, 103, 104, 105, 106,
                    107, 108, 109, 110, 35, 111, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 112, 113, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 114, 35, 115, 116,
                    117, 118, 119, 35, 35, 35, 35, 120, 121, 122, 123, 30, 124, 35, 125, 126,
                    127, 128, 129,
                ],
                tree2_level2: &[
                    0x110043FFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00007EFF, 0x3FF,
                    0x23FFFFFFFFFFFFF0, 0xFFFE0003FF010000, 0x23C5FDFFFFF99FE1,
                    0x10030003B0004000, 0x36DFDFFFFF987E0, 0x1C00005E000000,
                    0x23EDFDFFFFFBBFE0, 0x200000300010000, 0x23EDFDFFFFF99FE0,
                    0x20003B0000000, 0x3FFC718D63DC7E8, 0x10000, 0x23FFFDFFFFFDDFE0,
                    0x327000000, 0x23EFFDFFFFFDDFE1, 0x6000360000000, 0x27FFFFFFFFFDDFF0,
                    0xFC00000380704000, 0x2FFBFFFFFC7FFFE0, 0x7F, 0xDFFFFFFFFFFFE,
                    0x200DFFAFFFFFF7D6, 0xF000005F, 0x1, 0x1FFFFFFFFEFF, 0x1F00, 0,
                    0x800007FFFFFFFFFF, 0xFFE1C0623C3F0000, 0xFFFFFFFF00004003,
                    0xF7FFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF,
                    0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x7FFFFFF,
                    0xFFFFFFFF0000FFFF, 0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FE07FFFFFFFFFF,
                    0x3FFFF8003FFFF, 0x1DFFF0003FFFF, 0xFFFFFFFFFFFFF, 0x10800000,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFFF, 0xFFFF05FFFFFFFF9F,
                    0x3FFFFFFFFFFFFF, 0x7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF,
                    0xFFFFFFFF007FFFFF, 0x1FFFFF, 0x8000000000, 0xFFFFFFFFFFFE0, 0x1FE0,
                    0xFC00C001FFFFFFF8, 0x3FFFFFFFFF, 0xFFFFFFFFF, 0x3FFFFFFFFC00E000,
                    0xE7FFFFFFFFFF07FF, 0x46FDE0000000000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF3FFBD503E2FFC84, 0x43E0, 0x18,
                    0xC781FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x80FFFFFFFFFF, 0x7F7F7F7F007FFFFF,
                    0x7F7F7F7F, 0x800000000000, 0x183E000000000060, 0xFFFFFFFEE07FFFFF,
                    0xF7FFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xC00FFFF1FFF,
                    0x80007FFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFFFFFFFCFF800000,
                    0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x7FFFFF7BB, 0xFFFFFFFFFFFFC,
                    0x68FC000000000000, 0xFFFF003FFFFFFC00, 0x1FFFFFFF0000007F,
                    0x7FFFFFFFFFFF0, 0x7C00FFDF00008000, 0x1FFFFFFFFFF, 0xC47FFFFF00000FF7,
                    0x3E62FFFFFFFFFFFF, 0x1C07FF38000005, 0xFFFF7F7F007E7E7E,
                    0xFFFF03FFF7FFFFFF, 0x7FFFFFFFF, 0xFFFF000FFFFFFFFF, 0xFFFFFFFFFFFF87F,
                    0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFA0F8007F, 0xFFFFFFFFFFFFFFDB,
                    0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000, 0x3FFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFCFFFF, 0xFFF0000000000FF,
                    0xFFDF000000000000, 0x1FFFFFFFFFFFFFFF, 0x7FFFFFE00000000,
                    0xFFFFFFC007FFFFFE, 0x7FFFFFFFFFFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 5, 11, 12, 5, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 13, 14, 15, 7, 16, 17, 7, 18, 19, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 2, 2, 11, 12, 13, 14, 15,
                    16, 2, 2, 2, 2, 17, 18, 19, 4, 20, 21, 22, 23, 24, 4, 25, 4, 26, 27, 28,
                    29, 30, 31, 32, 4, 2, 33, 34, 34, 35, 36, 37, 4, 4, 4, 38, 39, 40, 41, 42,
                    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 22, 55, 56, 57, 58, 59,
                    60, 61, 62, 4, 4, 63, 64, 61, 65, 66, 4, 67, 68, 4, 4, 69, 4, 70, 71, 72,
                    73, 74, 75, 76, 77, 78, 79, 4, 4, 4, 80, 81, 82, 83, 4, 84, 85, 86, 4, 4,
                    4, 4, 87, 88, 4, 89, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 4,
                    4, 4, 2, 2, 2, 91, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 92, 93,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 61, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 68, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 79, 96, 97, 98, 61, 99, 83, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 33, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 112, 113, 114,
                    115, 116, 2, 2, 2, 2, 117, 118, 119, 120, 121, 122, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 123, 4, 4,
                    4, 124, 125, 4, 4, 126, 127, 4, 4, 4, 4, 98, 69, 4, 4, 4, 4, 4, 4, 4, 128,
                    4, 4, 4, 129, 4, 4, 4, 4, 4, 4, 4, 130, 2, 2, 2, 131, 2, 132, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 133, 134, 135, 4, 4, 4, 4, 4, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 136, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 137, 2, 2, 2, 9, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 138, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 139, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2,
                    95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 140, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 61, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF, 0x3FFFFFFFFF03FD,
                    0xFFFFFFFF3FFFFFFF, 0xFF0F, 0xFFFF00003FFFFFFF, 0xFFFFFFFFF0FFFFF,
                    0xFFFF00FFFFFFFFFF, 0xF7FF000FFFFFFFFF, 0x1BFBFFFBFFB7F7FF,
                    0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF, 0x7FDFFFFFFFFFFBF,
                    0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF, 0x37FFFF00000000,
                    0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEF0001,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF, 0xFFFFFFFFF,
                    0xFFFF803FFFFFFC00, 0x3F, 0x303FFFFFFFFFF, 0x1C, 0xFFFF00801FFFFFFF,
                    0xFFFF00000000003F, 0xFFFF000000000003, 0x7FFFFF0000001F,
                    0xFFFFFFFFFFFFF8, 0x26000000000000, 0xFFFFFFFFFFF8, 0x1FFFFFF0000,
                    0x7FFFFFFFF8, 0x47FFFFFFFF0090, 0x7FFFFFFFFFFF8, 0x1400001E,
                    0x80000FFFFFFBFFFF, 0x1, 0xFFFF01FFBFFFBD7F, 0x23EDFDFFFFF99FE0,
                    0x3E0010000, 0xBFFFFFFFFF4BFF, 0xA0000, 0x1FFFFFFFFFFFFF, 0x380000780,
                    0xFFFFFFFFFFFF, 0xB0, 0x7FFFFFFFFFFF, 0xF000000, 0x10, 0x10007FFFFFFFFFF,
                    0x7FFFFFF, 0x7F, 0xFFFFFFFFFFF, 0xFFFFFFFF00000000, 0x80000000FFFFFFFF,
                    0x8000FFFFFF6FF27F, 0x2, 0xFFFFFCFF00000000, 0xA0001FFFF,
                    0x407FFFFFFFFF801, 0xFFFFFFFFF0010000, 0xFFFF0000200003FF,
                    0x1FFFFFFFFFFFFFF, 0x1FFFFFFFF, 0x7FFFFFFFFDFF, 0xFFFC000000000001,
                    0xFFFF, 0x1FFFFFFFFFB7F, 0xFFFFFDBF00000040, 0x10003FF, 0x7FFFF00000000,
                    0xFFFFFFFFDFFF4, 0x1000000000000, 0x3FFFFFF, 0xF, 0xFFFFFFFFFFFF0000,
                    0x1FFFFFFFFFFFF, 0xFFFFFFFF0000007E, 0x3FFFFFFF, 0xFFFF00007FFFFFFF,
                    0x7FFFFFFFFFFFFFFF, 0x3FFFFFFF0000, 0xE0FFFFF80000000F, 0x1FFFFFFFFFFF,
                    0x107FF, 0xFFF80000, 0xB00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                    0x6FEF000000000000, 0x40007FFFFFFFF, 0xFFFF00F000270000,
                    0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x3FF01FF, 0xFFFFFFFFFFDFFFFF,
                    0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF,
                    0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF, 0xF7FFFFFFF7FFFFFD,
                    0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF, 0xFFFFFDFFFFFFFDFF, 0xFF7,
                    0x7E07FFFFFFF, 0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x3F801FFFFFFFFFFF,
                    0x4000, 0xFFFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F, 0x80F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const LETTER_NUMBER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1C00000000000, 0xFFFFFFFF00000000, 0x1E7, 0x70003FE00000080,
                    0xFFC000000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFFFFFFFFFF, 0x402, 0x3E0000, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFF,
                ],
                };

                pub const LINE_SEPARATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x10000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LOWERCASE_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE00000000, 0x20000000000000, 0xFF7FFFFF80000000,
                    0x55AAAAAAAAAAAAAA, 0xD4AAAAAAAAAAAB55, 0xE6512D2A4E243129,
                    0xAA29AAAAB5555240, 0x93FAAAAAAAAAAAAA, 0xFFFFFFFFFFFFAA85,
                    0xFFFFFFEFFFFF, 0, 0, 0x388A000000000000, 0xFFFFF00000010000,
                    0x192FAAAAAAE37FFF, 0xFFFF000000000000, 0xAAAAAAAAFFFFFFFF,
                    0xAAAAAAAAAAAAA802, 0xAAAAAAAAAAAAD554, 0xAAAAAAAAAAAA,
                    0xFFFFFFFF00000000, 0x1FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 5, 6, 0, 7, 7, 8, 7, 9, 10, 11, 12, 0, 0, 0,
                    0, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17, 7,
                    18, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 0, 22, 23, 24, 25, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 16, 26, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xE7FFFFFFFFFF0000, 0x3F00000000000000, 0x5FF, 0xFFFFFFFFFFF,
                    0xFEFFF80000000000, 0x7FFFFFF, 0xAAAAAAAAAAAAAAAA, 0xAAAAAAAABFEAAAAA,
                    0xFF00FF003F00FF, 0x3FFF00FF00FF003F, 0x40DF00FF00FF00FF,
                    0xDC00FF00CF00DC, 0x321080000008C400, 0x43C0, 0x10, 0xFFFF000000000000,
                    0xFDA1562FFFFFFFF, 0x8501AAAAAAAAA, 0x20BFFFFFFFFF, 0x2AAAAAAAAAAA,
                    0xAAAAAAA, 0xAAABAAA800000000, 0x95FEAAAAAAAAAAAA, 0xAAA082AAAABA50AA,
                    0x44000000AAA250A, 0xFFFF01FF07FFFFFF, 0xFFFFFFFFFFFFFFFF, 0xF8007F,
                    0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11,
                    12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFF0000000000, 0xFFFF, 0xFFFFFFFFF000000, 0x1BFBFFFBFF800000,
                    0x7FFFFFFFFFFFF, 0xFFFF000000000000, 0x3F, 0xFFFFFFFF, 0xFFFFFFFF00000000,
                    0xFFFFFFC000000, 0xFFFFDFC000, 0xEBC000000FFFFFFC, 0xFFFFFC000000FFEF,
                    0xFFFFFFC000000F, 0xFFFFFFC0000, 0xFC000000FFFFFFC0, 0xFFFFC000000FFFFF,
                    0xFFFFFFC000000FF, 0xFFFFFFC00000, 0x3FFFFFFC00, 0xF0000003F7FFFFFC,
                    0xFFC000000FDFFFFF, 0xFFFF0000003F7FFF, 0xFFFFFC000000FDFF, 0xBF7,
                    0x7E07FFFFBFF, 0xFFFFFFFC00000000, 0xF,
                ],
                };

                pub const MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0x3F8, 0, 0, 0, 0xBFFFFFFFFFFE0000, 0xB6, 0x7FF0000,
                    0x10000FFFFF800, 0, 0x3D9F9FC00000, 0xFFFF000000020000, 0x7FF,
                    0x1FFC000000000, 0x200FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 6, 8, 6, 9, 6, 10, 11, 12, 13, 14, 6, 15, 16, 17,
                    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 32, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 33, 34, 35, 36, 37, 31, 38, 31, 39, 31, 31, 31, 40, 41, 42, 43,
                    44, 45, 46, 47, 48, 31, 31, 49, 31, 31, 31, 50, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 51, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 52,
                    31, 53, 31, 54, 31, 31, 31, 31, 31, 31, 31, 31, 55, 31, 56, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 57,
                    58, 59, 31, 31, 31, 31, 60, 31, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
                    31, 31, 31, 71, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 72, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 73, 31, 31, 31, 31, 31, 31, 31,
                ],
                tree2_level2: &[
                    0x3EEFFBC00000, 0xE000000, 0xFF800000, 0xFFFFFFFBFFFFFC00,
                    0xDC0000000000000F, 0xC00FEFFFF, 0xD00000000000000E, 0x4000000C0080399F,
                    0x23000000023987, 0xFC00000C00003BBF, 0xC00E0399F, 0xC000000000000004,
                    0x803DC7, 0xD00000000000001F, 0xC00603DDF, 0x8000C00603DDF,
                    0xD80000000000000F, 0xC00803DDF, 0xE, 0xC0000FF5F8400, 0x7F2000000000000,
                    0x7F80, 0x1FF2000000000000, 0x7F00, 0xC2A0000003000000,
                    0xFFFE000000000000, 0x1FFFFFFFFEFFE0DF, 0x40, 0x7FFFF80000000000,
                    0x1E3F9DC3C00000, 0x3C00BFFC, 0, 0xE0000000, 0x1C0000003C0000,
                    0xC0000000C0000, 0xFFF0000000000000, 0x200FFFFF, 0xB800, 0x20000000060,
                    0xFFF0FFF00000000, 0xF800000, 0x9FFFFFFF7FE00000, 0xFFFF000000000000,
                    0x7FFF, 0xFFF000000000001F, 0xFF8000000001F, 0x3FFE00000007,
                    0xFFFC000000000, 0xFFFFF000000000, 0x39021FFFFF70000, 0xFFFFFFFFFFFFFFFF,
                    0x1FFFFFFFF0000, 0x3800000000000, 0x8000000000000000, 0xFFFFFFFF00000000,
                    0xFC0000000000, 0x6000000, 0x3FF7800000000000, 0xC0000000,
                    0x3000000000000, 0x10F800000844, 0xFFF0000000000003, 0x8003FFFF0000003F,
                    0x3FC000000000, 0xFFF80, 0xFFF800000000000F, 0x2000000001,
                    0x7FFE0000000000, 0x3800000000003008, 0xC19D000000000000,
                    0x60F80000000002, 0x37F800000000, 0x40000000, 0xFFFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 2, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0,
                    0, 0, 6, 7, 0, 0, 0, 0, 8, 9, 0, 10, 11, 0, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0, 0, 31, 32, 29, 33,
                    34, 0, 35, 0, 0, 0, 36, 0, 0, 0, 37, 38, 0, 39, 40, 41, 42, 0, 0, 0, 0, 0,
                    43, 0, 44, 0, 45, 46, 47, 0, 0, 0, 0, 48, 49, 50, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 54, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 60, 0, 0, 0, 0, 0, 0, 0,
                    61, 62, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 65, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 68, 0, 54, 0, 0, 0, 0, 0, 69, 70,
                    0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72,
                    0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 74, 74, 74, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x870000000000F06E,
                    0x6000000000, 0xF000000000, 0x3E0000000000, 0x180000000000,
                    0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000007, 0x801900000000007F,
                    0x7FF000000000007, 0x4, 0x1FFF8000000007, 0x8000000000060,
                    0xFFF8000000000007, 0xDE01, 0x40FFF00000000000, 0x2, 0x7FF80000000,
                    0xD80000000000000F, 0x1F1FCC0080399F, 0xFF00000000000000, 0x60005F7A5,
                    0xFFE0000000000000, 0x4000007F, 0xFFFF000000000000, 0xF,
                    0xFF3F800000000000, 0x30000001, 0x1, 0xFFF80000000000, 0xFFFE0000000,
                    0x7FFF00000000000, 0x79BF000000000000, 0xD, 0x11FCFE0000,
                    0x7BF80000000007FE, 0xFFE0080, 0x3FFFC00, 0xFF7F800000000000,
                    0x7FFEFFFFFC0000, 0xB47E000000000000, 0xBF, 0xFB7C00, 0x78000000000000,
                    0xC7F000000000000B, 0x4000007, 0x3FFF81, 0xFFFFC0000000, 0x1F000000000000,
                    0x7F000000000000, 0xFFFFFFFFFFFE8000, 0x780FF, 0x3001000000000,
                    0x60000000, 0xFFFF3FFFFFFFFFFF, 0x7F, 0xF807E3E000000000, 0x3C0000000FE7,
                    0x1C, 0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7DBF9FFFF7F,
                    0x8000, 0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x7F0,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const MATH_SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x7000080000000000, 0x5000000000000000, 0x2100000000000, 0x80000000800000,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x40000000000000, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x1C0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    3, 4, 5, 6, 7, 7, 7, 7, 8, 9, 10, 11, 0, 0, 0, 0, 0, 0, 12, 13, 0, 14, 0,
                    0, 0, 0, 0, 15, 0, 0, 0, 0, 7, 7, 16, 17, 7, 7, 7, 7, 18, 19, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 22, 23, 0, 24,
                ],
                tree2_level2: &[
                    0, 0x1C00000000040010, 0x1C00, 0x1000000, 0x81F, 0x40490C1F0000,
                    0xFFF000000014C000, 0xFFFFFFFFFFFFFFFF, 0x300000000, 0x1000000000000000,
                    0xFFFFFF8000000, 0x3F0000000, 0x80000000000000, 0xFF00000000000002,
                    0x800000000000, 0xFFFF003FFFFFFF9F, 0xFFFFFFFFFE000007,
                    0xCFFFFFFFF0FFFFFF, 0xFFFF000000000000, 0x1F9F, 0x20000000000,
                    0x7400000000, 0x70000800, 0x50000000, 0x1E0400000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 7, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC000, 0x800000008000002, 0x20000000200000, 0x800000008000,
                    0x20000000200, 0x8, 0x3000000000000,
                ],
                };

                pub const MODIFIER_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFF000000000000, 0x501F0003FFC3, 0,
                    0x410000000000000, 0, 0, 0, 0, 0, 0, 0, 0x2000000, 0, 0, 0, 0x1, 0,
                    0x6000000000, 0, 0, 0, 0x430000000000000,
                ],
                tree2_level1: &[
                    0, 1, 1, 2, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    4, 1, 4, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 7, 1, 1, 1, 1, 1, 1, 1, 1, 8,
                    1, 1, 1, 1, 1, 1, 9, 1, 1, 10, 11, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13,
                    14, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15,
                    1, 1, 1, 16, 1, 1, 16, 1, 1, 1, 1, 1, 1, 1, 17, 1, 18, 19, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 21, 22, 23, 1, 24, 25, 26, 27,
                    1, 1, 1, 1, 1, 1, 1, 28, 1, 25, 1, 29, 1, 30, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 25, 31, 1,
                ],
                tree2_level2: &[
                    0x11004000000, 0, 0x200, 0x2000000000000, 0x40, 0x1000000000000000,
                    0x800000, 0x8, 0x8000000000, 0x3F00000000000000, 0xFFFFF00000000000,
                    0x10007FFFFFFFFFF, 0xFFFFFFFFF8000000, 0x8002000000000000, 0x1FFF0000,
                    0x3000000000000000, 0x800000000000, 0x83E000000000020, 0x60000000,
                    0x7000000000000000, 0x200000, 0x1000, 0x8000000000000000, 0x30000000,
                    0xFF800000, 0x1000000000000, 0x100, 0x31C000000000000, 0x4000008000,
                    0x18000020000000, 0x200F0000000, 0xC0000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,
                    0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 7, 8, 9, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FDFFFFFFFFFFBF, 0x800000004000, 0xF, 0x180000000007, 0xFFF80000,
                    0xB00000000, 0x6FEF000000000000, 0xFFFF000000000000, 0x3FFFFFFFFFFF,
                    0x3F80000000000000, 0x80000000000, 0x800,
                ],
                };

                pub const MODIFIER_SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x140000000, 0x110810000000000, 0, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFFAFE0FFFC003C, 0, 0x20000000000000, 0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 0, 12,
                ],
                tree2_level2: &[
                    0, 0x100, 0xA000000000000000, 0x6000E000E000E003, 0x18000000, 0x3007FFFFF,
                    0x600, 0xC0008000000, 0xFFFC000000000000, 0x7, 0x4000000000000000, 0x1,
                    0x800000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF800000000000000,
                ],
                };

                pub const NONSPACING_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0xF8, 0, 0, 0, 0xBFFFFFFFFFFE0000, 0xB6, 0x7FF0000,
                    0x10000FFFFF800, 0, 0x3D9F9FC00000, 0xFFFF000000020000, 0x7FF,
                    0x1FFC000000000, 0x200FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 10, 11, 12, 13, 14, 15, 16, 11, 17, 18,
                    19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 34, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 35, 36, 37, 38, 39, 33, 40, 33, 41, 33, 33, 33, 42, 43, 44,
                    45, 46, 47, 48, 49, 50, 33, 33, 51, 33, 33, 33, 52, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 53, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    54, 33, 55, 33, 56, 33, 33, 33, 33, 33, 33, 33, 33, 57, 33, 58, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    59, 60, 61, 33, 33, 33, 33, 62, 33, 33, 63, 64, 65, 66, 67, 68, 69, 70,
                    71, 33, 33, 33, 72, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 73, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 74, 33, 33, 33, 33, 33, 33, 33,
                ],
                tree2_level2: &[
                    0x3EEFFBC00000, 0xE000000, 0xFF800000, 0xFFFFFFFBFFFFFC00,
                    0x1400000000000007, 0xC00FE21FE, 0x1000000000000002, 0x4000000C0000201E,
                    0x1000000000000006, 0x23000000023986, 0xFC00000C000021BE,
                    0x9000000000000002, 0xC0060201E, 0x4, 0x2001, 0xD000000000000011,
                    0xC00603DC1, 0xC00003040, 0x1800000000000003, 0xC0000201E, 0x2, 0x5C0400,
                    0x7F2000000000000, 0x7F80, 0x1FF2000000000000, 0x7F00, 0x2A0000003000000,
                    0x7FFE000000000000, 0x1FFFFFFFFEFFE0DF, 0x40, 0x66FDE00000000000,
                    0x1E0001C3000000, 0x20002064, 0, 0xE0000000, 0xC0000001C0000,
                    0xC0000000C0000, 0x3FB0000000000000, 0x200FFE40, 0xB800, 0x20000000060,
                    0xE04018700000000, 0x9800000, 0x9FF81FE57F400000, 0xBFFF000000000000,
                    0x7FFF, 0x17D000000000000F, 0xFF80000000004, 0x3B3C00000003,
                    0x3A34000000000, 0xCFF00000000000, 0x31021FDFFF70000, 0xFFFFFFFFFFFFFFFF,
                    0x1FFE21FFF0000, 0x3800000000000, 0x8000000000000000, 0xFFFFFFFF00000000,
                    0x3C0000000000, 0x6000000, 0x3FF0800000000000, 0xC0000000,
                    0x3000000000000, 0x106000000844, 0x8003FFFF00000030, 0x3FC000000000,
                    0x3FF80, 0x33C8000000000007, 0x2000000000, 0x667E0000000000,
                    0x1000000000001008, 0xC19D000000000000, 0x40300000000002, 0x212000000000,
                    0x40000000, 0xFFFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 2, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0,
                    0, 0, 6, 7, 0, 0, 0, 0, 8, 9, 0, 10, 11, 0, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0, 0, 31, 32, 33, 34,
                    35, 0, 36, 0, 0, 0, 37, 0, 0, 0, 38, 39, 0, 40, 41, 42, 43, 0, 0, 0, 0, 0,
                    44, 0, 45, 0, 46, 47, 48, 0, 0, 0, 0, 49, 50, 51, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 55, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 61, 0, 0, 0, 0, 0, 0, 0,
                    62, 63, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 66, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 56, 0, 55, 0, 0, 0, 0, 0, 69, 70,
                    0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72,
                    0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 74, 74, 74, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x870000000000F06E,
                    0x6000000000, 0xF000000000, 0x3E0000000000, 0x180000000000,
                    0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000002, 0x801900000000007F,
                    0x678000000000003, 0x4, 0x1FEF8000000007, 0x8000000000000,
                    0x7FC0000000000003, 0x9E00, 0x40D3800000000000, 0x2, 0x7F880000000,
                    0x1800000000000003, 0x1F1FC000000001, 0xF800000000000000, 0x600054001,
                    0xFF00000000000000, 0x4000005C, 0x85F8000000000000, 0xD,
                    0xB03C000000000000, 0x30000001, 0xA7F8000000000000, 0x1, 0xBF280000000000,
                    0xFBCA0000000, 0x6FF800000000000, 0x5800000000000000, 0x8, 0x10CF00000,
                    0x79F80000000007FE, 0xE7E0080, 0x37FFC00, 0xBF7F000000000000,
                    0x6DFCFFFFFC0000, 0xB47E000000000000, 0xBF, 0xA30000, 0x18000000000000,
                    0x7C0000000000003, 0x4000005, 0x3FFF81, 0xE3FFC0000000, 0x1F000000000000,
                    0x7F000000000000, 0x8000, 0x78000, 0x1000000000, 0x60000000,
                    0xFFFF3FFFFFFFFFFF, 0x7F, 0xF800038000000000, 0x3C0000000FE7, 0x1C,
                    0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7DBF9FFFF7F,
                    0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x7F0,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const NUMBER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0, 0x720C000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x3FF00000000, 0, 0x3FF000000000000, 0,
                    0, 0, 0x3FF,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 1, 0, 2, 0, 1, 0, 1, 0, 3, 0, 4, 0, 5, 0, 1, 0, 6, 0, 1, 0,
                    7, 0, 7, 8, 0, 0, 0, 0, 9, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 12, 7, 0, 0, 0, 0, 13, 0, 14,
                    0, 0, 15, 0, 0, 7, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 17, 9, 0, 0, 18, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 27,
                    0, 28, 29, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 1, 0, 0, 0, 0,
                    31, 0, 0, 7, 9, 0, 0, 32, 0, 7, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,
                    0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFC000000000, 0x3F0FFC000000000, 0xFCFFC000000000, 0x7FFC000000000,
                    0x7F00FFC000000000, 0x1FFFFC07F000000, 0x3FF0000, 0xFFFFF00000000, 0x3FF,
                    0x1FFFFE0000000000, 0x1C00000000000, 0x3FF03FF00000000, 0xFFC0, 0x7FF0000,
                    0x3FF03FF, 0x3FF000000000000, 0x3F1000000000000, 0xFFFFFFFFFFFF0000,
                    0x3E7, 0xFFFFFFFF00000000, 0xFFFFFFF, 0xFFFFFC0000000000,
                    0xFFC0000000000000, 0xFFFFF, 0x2000000000000000, 0x70003FE00000080,
                    0x3C0000, 0x3FF00000000, 0xFFFEFF00, 0xFFFE0000000003FF, 0x3F000000000000,
                    0x3FF000003FF0000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 3, 3, 3, 3, 3, 5, 6, 7, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 4, 5, 6, 0, 7, 0, 0, 8, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 11, 12, 0, 13, 14, 0, 15, 16, 17, 0, 18,
                    19, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 24, 25, 0, 26, 0, 27, 0,
                    21, 28, 0, 0, 29, 0, 0, 0, 21, 0, 0, 0, 0, 0, 30, 0, 30, 0, 0, 0, 0, 0,
                    30, 0, 31, 32, 0, 0, 0, 0, 0, 0, 33, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21,
                    0, 34, 0, 0, 0, 30, 8, 0, 0, 0, 0, 0, 0, 30, 0, 35, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 22, 0, 38, 0, 0, 0, 0, 0,
                    0, 0, 21, 0, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 41, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    22, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 43, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 44, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 46,
                    0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFF80, 0x1FFFFFFFFFFFFFF, 0xC00, 0xFFFFFFE00000000,
                    0xF00000000, 0x402, 0x3E0000, 0x3FF00000000, 0xFE000000FF000000,
                    0xFF8000000000, 0xF800000000000000, 0xFC00000, 0x3000000000000000,
                    0xFFFFFFFFFFFCFFFF, 0x60000000000001FF, 0xE0000000, 0xF80000000000,
                    0xFF000000FF000000, 0xFE0000000000, 0xFC00000000000000, 0x3FF000000000000,
                    0x3FF, 0x7FFFFFFF00000000, 0x7FE0000000, 0x1E0000, 0xFE0, 0xFFFFFFFC0000,
                    0xFFC0000000000000, 0x1FFFFE03FF0000, 0x3FF0000, 0xFFFFF03FF,
                    0xFFF000000000000, 0x7FFFF00000000, 0x1FFFFFFF0000, 0x1FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFF, 0x3FBFF0000, 0x7FFFFF,
                    0xFFFFF000FFFFF, 0x1FFFFFF00000000, 0xFFFFFFFFFFFFC000, 0x7FE000000000000,
                    0xFF80, 0xFFFE000000000000, 0x1EEFFFFFFFFFFF, 0x3FFFBFFFFFFFFFFE, 0x1FFF,
                ],
                };

                pub const OPEN_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x10000000000, 0x800000008000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    7, 0, 8, 0, 0, 0, 0, 0, 0, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 11, 12, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 15, 16, 0, 0, 17, 18, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1400000000000000, 0x8000000, 0x44000000, 0x2000000000000020, 0x2000,
                    0x20000000500, 0x15550000000000, 0x554000000020, 0xAAAAA8,
                    0x1000000005000000, 0x15400000000, 0xAA00004, 0x25515500,
                    0x8000000000000000, 0xAAA0000000800000, 0x2A00008A, 0x800000000000100,
                    0x488000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OTHER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFFFFFFFF, 0x8000000000000000, 0x2000FFFFFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0x300000000000000, 0x40000280F, 0, 0, 0, 0, 0, 0x1000000000000,
                    0x1800000, 0x11800, 0xFFE078000000FF00, 0x1000003F, 0, 0, 0x20000000,
                    0xC000, 0x1800, 0xFFFC000000000000, 0x1800000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                    20, 21, 22, 23, 24, 25, 26, 4, 27, 28, 29, 4, 4, 4, 30, 4, 4, 4, 4, 4, 31,
                    32, 33, 34, 35, 36, 37, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 38, 39, 40, 41, 4,
                    42, 43, 39, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 4, 54, 4, 55, 56, 57,
                    58, 59, 4, 4, 4, 4, 4, 4, 4, 4, 60, 61, 62, 63, 64, 65, 66, 67, 4, 4, 68,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 69, 70, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 71, 72, 4, 4, 4, 4, 73, 74, 75,
                    76, 77, 4, 78, 79, 80, 4, 4, 4, 81, 4, 82, 83, 4, 84, 4, 85, 86, 87, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 88, 89, 4, 4, 4, 4, 90, 4, 4, 91, 4, 4, 4, 92, 93, 91, 4,
                    94, 4, 95, 4, 96, 97, 98, 4, 99, 100, 48, 4, 101, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 102, 103, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 4, 4, 4, 4, 4, 105, 4, 106,
                    107, 108, 4, 109, 4, 4, 4, 4, 4, 4, 110, 111, 36, 112, 4, 113, 82, 4, 114,
                    115,
                ],
                tree2_level2: &[
                    0x8000C00000000000, 0xF800B0000000, 0x7F8000, 0x400000000, 0,
                    0xC3A020000066010, 0x800000304F7F8660, 0x2C92020000067811,
                    0xFF80003FA1FDC678, 0xC12020000044011, 0x1FC0030FFFEC440,
                    0xC12020000066011, 0xFF0000304F1FC660, 0x3C0038E729C23813,
                    0xF800003FFF7EC238, 0xC00020000022000, 0x7F0030D89FC220,
                    0xC10020000022000, 0xFFF100309F9FC220, 0x22000, 0x30000F0220,
                    0xD004000003800011, 0xFFE3003F00A07B80, 0x7800000000000001,
                    0xFFFFFFFFF0000000, 0xC000005000000829, 0xFFFFFFFF0C0080A0,
                    0x1E00000000100, 0x2000000001000000, 0xFFFFFFFFF8002000, 0xDF40,
                    0xC280C200, 0x80C200000000C200, 0x8000C2, 0xC20000, 0xE000000018000000,
                    0xFC000000, 0xC0C0000000000000, 0xE0000000, 0xFE00000000000000,
                    0xFF8000007FC00000, 0xFFF22000FFF00000, 0xFC00FC00C0000000, 0xFC004000,
                    0xF80000000000, 0xFFC0000000000000, 0xF000F00080000000,
                    0xFFE0C0000000000E, 0xF00000000000, 0x3800FC00, 0x30000000,
                    0x6000000080000000, 0xC000FC00FC00, 0xFFFFFFFFFFFF8000, 0x2000,
                    0xFF0000000000000, 0x700000000000000, 0x1C00, 0x180000000000F800,
                    0xF80000000000FF00, 0xC0C00000, 0xC00000005500C0C0, 0x20000000000000,
                    0x8023000010300020, 0x7C000000F800, 0xCFFFF00000000, 0xE0008000,
                    0xFFFE00000000FFFE, 0xF000, 0xFFFFFC0000000000, 0xFFFFF800,
                    0x30000000000000, 0x400000, 0x1F0000000000000, 0xDF4000000000,
                    0x7FFE7F0000000000, 0x80808080FF800000, 0x80808080, 0xFFFFFFFFC0000000,
                    0x4000000, 0xFFF0000000000000, 0xFFFFFFC00000, 0x1, 0x1800000,
                    0x100000000001F, 0x8000, 0x7FC000000000, 0x80000000, 0xE000, 0xFF80,
                    0xFFFFF00000000000, 0xFF00000000000000, 0x3FFFFE014C000,
                    0xFC00E00000000000, 0xFC003FC0, 0xE00000007FF00000, 0x800000003C004000,
                    0xFF80000000000000, 0xC00C000, 0xFF80000007FFFFF8, 0x8080FF818181,
                    0xFC00C00000000000, 0xFFF000000000, 0xF000000000000780,
                    0xFFFFFFFFFFFFFFFF, 0xC00000000000, 0xFFFFFFFFFC000000,
                    0xA08000001F07FF80, 0x24, 0x7FFF8, 0x30000, 0xFFFFFFFF7F00,
                    0x20F08000080000, 0xE000000000000000, 0x8000000000000000,
                    0xCFFF8080E3030303,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 2, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 2, 2, 14, 15, 16, 17,
                    18, 19, 2, 2, 2, 2, 20, 21, 22, 7, 23, 24, 25, 26, 27, 7, 28, 29, 30, 31,
                    32, 33, 34, 35, 36, 7, 2, 37, 38, 39, 40, 41, 42, 7, 7, 43, 44, 45, 16,
                    46, 47, 48, 2, 49, 50, 51, 52, 53, 2, 54, 55, 56, 57, 58, 59, 60, 61, 62,
                    2, 63, 2, 64, 7, 7, 65, 66, 2, 67, 68, 69, 70, 71, 7, 7, 72, 7, 73, 74,
                    75, 76, 77, 78, 2, 79, 80, 81, 82, 7, 7, 83, 84, 85, 86, 7, 87, 88, 89, 7,
                    7, 7, 7, 90, 91, 92, 93, 94, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 95,
                    7, 2, 96, 2, 2, 2, 97, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 98,
                    38, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 99, 100, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 71, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    68, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 81, 101, 102, 103, 2, 104, 105, 7, 7,
                    7, 7, 7, 7, 68, 7, 7, 7, 2, 92, 7, 2, 106, 107, 108, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 109, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 110, 37, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 111, 2, 2, 2, 2, 112, 113, 2, 2, 2, 2, 2,
                    72, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 114, 115, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 2, 2, 2, 68, 2, 2, 2, 2, 2, 2, 19, 7, 116, 117, 2, 97, 2, 2,
                    2, 118, 119, 120, 2, 121, 2, 122, 7, 123, 2, 124, 7, 7, 2, 125, 126, 127,
                    128, 129, 2, 2, 2, 2, 130, 2, 2, 2, 2, 131, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    132, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 133, 7, 7, 7, 134,
                    135, 136, 7, 137, 138, 7, 7, 7, 7, 139, 140, 7, 7, 7, 7, 7, 7, 7, 141, 7,
                    7, 7, 142, 7, 7, 7, 7, 7, 7, 7, 143, 2, 2, 2, 144, 2, 145, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 146, 147, 7, 148, 7, 7, 7, 149, 150, 151, 152, 7, 7, 7,
                    7, 153, 2, 154, 155, 2, 2, 135, 156, 157, 158, 7, 7, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 159, 2, 160, 2, 161, 162, 163, 164, 56, 2, 2, 2,
                    2, 2, 165, 166, 167, 2, 2, 168, 68, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 32, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 68, 2, 2,
                    2, 169, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 170, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 171, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 66, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2,
                    2, 2, 2, 2, 2, 66, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 172, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 99, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 99, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                ],
                tree3_level3: &[
                    0x4800008000001000, 0xFFFFFFFFC000C000, 0, 0xF800000000000000,
                    0x70000000000078, 0xFFFFFFFEE0008000, 0xC00000000000FFFF,
                    0xFFFFFFFFFFFFFFFF, 0xE0000000, 0xF0000000FFFE0000, 0x1FF000000000,
                    0xF80000000000F800, 0x40000000, 0xFFFFFFFFFFC000F0, 0xFC00C0000000,
                    0xF000000000F00000, 0xFF0000000000, 0x8007FF000000000, 0xE404000400480800,
                    0xFFF0000000000000, 0xFF80000000000000, 0xFFFFFF00FFC00000,
                    0xF802000000000040, 0x6E400000000002C0, 0x400000, 0xFFFF007F80000000,
                    0x7C80000FFFFFFFF, 0x7C00000070000000, 0xF00000000000000, 0x30000,
                    0x78C0000001100F90, 0xFE00FE00, 0xFFFFFFFF00000000, 0xFF80078000000000,
                    0x1C0000000000000, 0xF8000000C00000, 0xFFFF01FFE1FC0000,
                    0xFFFFFFFFFFFFFE00, 0xFFF8000000000000, 0x3F8000000000000,
                    0xFC00FF0000000000, 0x1C000000000, 0xFFFFFFFFFFFF3FC0, 0x80000000FFFFFFFF,
                    0xFFFCC40000000000, 0xFFFFFFFFFFFFFE3, 0xFFFFFC000000, 0xFFFFFFFFFC00,
                    0xFF800000FFFFF000, 0x7FC000000003C000, 0x2000000000000000,
                    0xFC00FE000000FFF8, 0x20000000000000, 0xFF8000000000FF00,
                    0xFFE0000100000000, 0x40000, 0xFFFFFFFFFFFFFFFC, 0xFC0040004280,
                    0xFC00F80000000000, 0x412020000066010, 0xFFE0E0301F7EC660,
                    0x4000000000B400, 0xFFFFFFF9FE40085A, 0xFFFFFFFC10000000,
                    0xFFFFFFFFFC00FF00, 0xC0000000000000, 0xFFFFFFFFC0000000,
                    0xFFFFE000FC00FFE0, 0xFC00000000000000, 0xFFFFFFF00000FC00,
                    0xF00018000000, 0xFFFFFFFFFFFFFF80, 0xF000000000000000, 0xFFFFFFFF,
                    0x7FF8000000000000, 0x640000000900D80, 0xFFFFFFFFFC00FF80, 0x300FFFFFFFF,
                    0xFFFFFFE003000000, 0xFF00, 0xFFF800000000, 0xFE00000000000000,
                    0xFFFFFFFFFFFFFC00, 0xFC00FFFC00000000, 0x80000000000200, 0xE0000000FFC0,
                    0xFF80010000030000, 0x4B80000000000480, 0x240FC00FF00, 0xFFFFFC00FE048000,
                    0xFE000000FFFFFFFF, 0x3800000000020000, 0xFFFFFFFFF8000000,
                    0xFFFEFFFFFFFFFFFF, 0x7FFC000000000000, 0xFFFFFFFFFC000000,
                    0xFFE0800000000000, 0xFFFFFFFFFFFFFFF0, 0xFFFF, 0xFFFF000000000000,
                    0xFFC00000, 0x3C0080000000, 0x8000000000000000, 0xFFC0C0000000FC00,
                    0x1F0000040400FFC0, 0xFFFFFFFFFFFF0000, 0x7800, 0xFFFFFFFF00007F00,
                    0xFFFCFFE0FFFFFFFF, 0xFF00000000000000, 0x7FFFFFFFFFC00000,
                    0x9010FFFFFFFFFFFF, 0xFFFBFFF800000000, 0xFF0FFFD8FFFF,
                    0xE000F80000000000, 0xFFFFFFFF0C00FE00, 0xC00000000000, 0xFF80,
                    0xFFC0000000000000, 0x18000000000, 0x7F8000000000000, 0xFFFFF80000000000,
                    0xFFFFFFFFFFFFFFC0, 0xFFF00000FFF00000, 0xFE000000FF800000, 0x200000,
                    0x1400219B20000000, 0x10, 0x8400000020201840, 0x203A0, 0xC000000000,
                    0x3000, 0xFFFF000107FFF000, 0xFFFFF81F80000000, 0xF82406000080,
                    0xFFFFC00000000000, 0xFFFFFFFFFFFF7FFF, 0xC000E00000000000,
                    0xFFFFFFFFFFFF3C00, 0xFFFF80000000FFFF, 0x7C00000000000000,
                    0xFC0000000000FFFF, 0x780000000000FFFF, 0x80009080FFFFFFFF,
                    0xFFFFFFFFFF800060, 0xFFFFFFFF3C00F000, 0x1FFFFFFFFFFFF,
                    0xFFE0000000000000, 0xC000000000000001, 0xF508016900000010,
                    0xA10808695569157B, 0xF0000411F0000400, 0xFFFCFFFFFFFFFFFF,
                    0xF00000000000, 0x18000FFF00000, 0xFFC0000000010001, 0x3FFFFFFFFF,
                    0xF00000000000FFF8, 0xFFFFFFC0FFFCFE00, 0xE000E0000F000000,
                    0x780000000000000, 0xFFFEF000FC000000, 0xF000, 0xFC00FF00,
                    0xF000C0000000FF00, 0xE000C000FFF00000, 0x7C00, 0xFE00FC0060003F80,
                    0x80000, 0xC0000000, 0xFFFC00000000, 0xFFFE00000000, 0xF800,
                ],
                };

                pub const OTHER_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x400040000000000, 0, 0, 0, 0x800000000000000, 0xF, 0, 0, 0x100000,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x787FFFFFF0000, 0xFFFFFFFF00000000,
                    0xFFFEC000000007FE, 0xFFFFFFFFFFFFFFFF, 0x9C00C000002FFFFF,
                    0xFFFFFFFD0000, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF, 0x7FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 31, 35, 35, 35,
                    35, 35, 36, 37, 38, 39, 40, 41, 31, 42, 35, 35, 35, 35, 35, 35, 35, 35,
                    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 31,
                    31, 60, 61, 62, 63, 64, 65, 31, 66, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 67, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 68, 69, 70, 71, 31, 31, 31, 31, 31, 31, 31, 31, 72, 42, 73, 74, 75,
                    35, 76, 68, 31, 31, 31, 31, 31, 31, 31, 31, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 31, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 77, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 78, 79, 35, 35, 35, 35, 80,
                    81, 50, 63, 31, 31, 82, 83, 84, 48, 85, 86, 87, 88, 89, 90, 91, 92, 93,
                    94, 95, 31, 31, 96, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 97,
                    98, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 35, 35, 35, 35, 35, 99, 35, 100, 101, 102,
                    103, 104, 35, 35, 35, 35, 105, 106, 107, 108, 31, 109, 35, 110, 31, 111,
                    112, 113,
                ],
                tree2_level2: &[
                    0x3FFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00007EFF, 0x1FF,
                    0x23FFFFFFFFFFFFF0, 0xFFFC0003FF010000, 0x23C5FDFFFFF99FE1,
                    0x10030003B0004000, 0x36DFDFFFFF987E0, 0x1C00005E000000,
                    0x23EDFDFFFFFBBFE0, 0x200000300010000, 0x23EDFDFFFFF99FE0,
                    0x20003B0000000, 0x3FFC718D63DC7E8, 0x10000, 0x23FFFDFFFFFDDFE0,
                    0x327000000, 0x23EFFDFFFFFDDFE1, 0x6000360000000, 0x27FFFFFFFFFDDFF0,
                    0xFC00000380704000, 0x2FFBFFFFFC7FFFE0, 0x7F, 0xDFFFFFFFFFFFE, 0x3F,
                    0x200DFFAFFFFFF7D6, 0xF000001F, 0x1, 0x1FFFFFFFFEFF, 0x1F00, 0,
                    0x800007FFFFFFFFFF, 0xFFE1C0623C3F0000, 0x4003, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D,
                    0xFFFFFFFFFF3DFFFF, 0x7FFFFFF, 0xFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FE07FFFFFFFFFF,
                    0x3FFFF8003FFFF, 0x1DFFF0003FFFF, 0xFFFFFFFFFFFFF, 0x10000000,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFF7, 0xFFFF05FFFFFFFF9F,
                    0x3FFFFFFFFFFFFF, 0x7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF, 0x3FF,
                    0xFFFFFFFF007FFFFF, 0x1FFFFF, 0xFFFFFFFFFFFE0, 0x1FE0, 0xFC00C001FFFFFFF8,
                    0x3FFFFFFFFF, 0xFFFFFFFFF, 0xFFFFFFFC00E000, 0x46FDE0000000000,
                    0x1E0000000000000, 0xFFFF000000000000, 0xFFFFFFFFFF, 0x7F7F7F7F007FFFFF,
                    0x7F7F7F7F, 0x1000000000000040, 0xFFFFFFFE807FFFFF, 0x87FFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF, 0xFFFFFFFFFFDFFFFF, 0x1FFF,
                    0xFFFFFFFFFF0000, 0xC00FFFF0FFF, 0x400000000000, 0x8000,
                    0xF880000000000000, 0x7FFFFF7BB, 0xFFFFFFFFFFFFC, 0x68FC000000000000,
                    0xFFFF003FFFFFFC00, 0x1FFFFFFF0000007F, 0x7FFFFFFFFFFF0,
                    0x7C00FF9F00000000, 0x1FFFFFFFFFF, 0xC47EFFFF00000FF7, 0x3E62FFFFFFFFFFFF,
                    0x407FF18000005, 0x7F7F007E7E7E, 0x7FFFFFFFF, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFA0000000,
                    0xFFFFFFFFFFFFFFDB, 0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000,
                    0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFCFFFF,
                    0xFFF0000000000FF, 0xFFDF000000000000, 0x1FFFFFFFFFFFFFFF,
                    0xFFFEFFC000000000, 0x7FFFFFFF3FFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 12, 13, 14, 7, 15, 16, 7, 17, 18, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 4, 11, 12, 4, 13, 14, 4,
                    15, 2, 2, 2, 2, 16, 17, 4, 4, 18, 19, 20, 21, 22, 4, 23, 4, 24, 25, 26,
                    27, 28, 29, 30, 4, 2, 31, 4, 4, 14, 32, 4, 4, 4, 4, 33, 34, 35, 36, 37,
                    38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 20, 50, 51, 52, 53, 54,
                    55, 56, 57, 4, 4, 58, 59, 56, 60, 61, 4, 62, 63, 4, 4, 64, 4, 4, 65, 66,
                    67, 68, 69, 70, 71, 72, 73, 4, 4, 4, 74, 75, 76, 77, 4, 78, 79, 80, 4, 4,
                    4, 4, 81, 82, 4, 83, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 84, 4,
                    4, 4, 2, 2, 2, 85, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 11, 86,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 56, 87, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 63, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 12,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 73, 88, 89, 90, 56, 91, 77, 4, 4, 4, 4, 4,
                    4, 92, 4, 4, 4, 4, 4, 4, 2, 93, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 94, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 95, 31, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 96, 97,
                    2, 2, 2, 2, 2, 98, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 99, 100, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 101, 4, 4, 4,
                    4, 4, 4, 4, 102, 103, 4, 4, 4, 4, 90, 64, 4, 4, 4, 4, 4, 4, 4, 104, 4, 4,
                    4, 105, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 107, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 108, 109, 110, 4, 4, 4, 4, 4, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 111,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 112, 2, 2, 2, 9, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 113, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 114, 2, 2, 2, 2, 2, 2, 2, 2, 2, 12,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 12, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 115, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    56, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF, 0x3FFFFFFFFF03FD,
                    0xFFFFFFFF3FFFFFFF, 0xFF0F, 0xFFFFFFFFFFFF0000, 0x3FFFFFFF,
                    0xFFFF00FFFFFFFFFF, 0xFFFFFFFFF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF,
                    0xFF003FFFFF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF,
                    0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEF0001,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0xBC00, 0x303FFFFFFFFFF, 0x1C,
                    0xFFFF00801FFFFFFF, 0xFFFF00000000003F, 0xFFFF000000000003,
                    0x7FFFFF0000001F, 0xFFFFFFFFFFFFF8, 0x26000000000000, 0xFFFFFFFFFFF8,
                    0x1FFFFFF0000, 0x7FFFFFFFF8, 0x47FFFFFFFF0090, 0x7FFFFFFFFFFF8,
                    0x1400001E, 0x80000FFFFFFBFFFF, 0x1, 0xFFFF01FFBFFFBD7F,
                    0x23EDFDFFFFF99FE0, 0x3E0010000, 0xBFFFFFFFFF4BFF, 0xA0000,
                    0x1FFFFFFFFFFFFF, 0x380000780, 0xFFFFFFFFFFFF, 0xB0, 0x7FFFFFFFFFFF,
                    0xF000000, 0x10, 0x10007FFFFFFFFFF, 0x7FFFFFF, 0x7F, 0xFFFFFFFFFFF,
                    0x8000000000000000, 0x8000FFFFFF6FF27F, 0x2, 0xFFFFFCFF00000000,
                    0xA0001FFFF, 0x407FFFFFFFFF801, 0xFFFFFFFFF0010000, 0xFFFF0000200003FF,
                    0x1FFFFFFFFFFFFFF, 0x1FFFFFFFF, 0x7FFFFFFFFDFF, 0xFFFC000000000001,
                    0xFFFF, 0x1FFFFFFFFFB7F, 0xFFFFFDBF00000040, 0x10003FF, 0x7FFFF00000000,
                    0xFFFFFFFFDFFF4, 0x1000000000000, 0x3FFFFFF, 0xF, 0x1FFFFFFFFFFFF,
                    0xFFFFFFFF0000007E, 0xFFFF00007FFFFFFF, 0x7FFFFFFFFFFFFFFF,
                    0x3FFFFFFF0000, 0xE0FFFFF800000000, 0x7FFFFFFFFF8, 0x107FF,
                    0xFFFFFFFFFFFFFF, 0x80000000003FFFFF, 0x40007FFFFFFFF, 0xFFFF00F000270000,
                    0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x3FF01FF, 0x400, 0x1FFFFFFFFFFF,
                    0x4000, 0x7FFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const OTHER_NUMBER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x720C000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 3, 0, 4, 0, 0, 0, 5, 0, 0, 0,
                    0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11,
                    0, 0, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 16, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 21,
                    22, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3F0000000000000, 0xFC000000000000, 0x7000000000000,
                    0x7F00000000000000, 0x1FF00007F000000, 0xFFC0000000000,
                    0x1FFFFE0000000000, 0x3FF000000000000, 0x4000000, 0x3F1000000000000,
                    0x3FF, 0xFFFF0000, 0x200, 0xFFFFFFFF00000000, 0xFFFFFFF,
                    0xFFFFFC0000000000, 0xFFC0000000000000, 0xFFFFF, 0x2000000000000000,
                    0x3C0000, 0x3FF00000000, 0xFFFEFF00, 0xFFFE0000000003FF, 0x3F000000000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 8, 9, 0, 10, 11, 0, 12, 13, 14, 0, 15, 16,
                    0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 18, 0, 0, 19, 20, 0, 21, 0, 22, 0, 0, 0, 0,
                    0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0,
                    0, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 30, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 33, 34, 0, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFF80, 0x1E0000000000000, 0xC00, 0xFFFFFFE00000000,
                    0xF00000000, 0xFE000000FF000000, 0xFF8000000000, 0xF800000000000000,
                    0xFC00000, 0x3000000000000000, 0xFFFFFFFFFFFCFFFF, 0x60000000000001FF,
                    0xE0000000, 0xF80000000000, 0xFF000000FF000000, 0xFE0000000000,
                    0xFC00000000000000, 0x7FFFFFFF00000000, 0x7FE0000000, 0x1E0000, 0xFE0,
                    0x3FFFFC0000, 0x1FFFFE00000000, 0xC00000000000000, 0x7FC0000000000,
                    0x1FFFFC000000, 0x1FFFFF, 0x3F8000000, 0x7FFFFF, 0xFFFFF000FFFFF,
                    0x1FFFFFF00000000, 0xFF80, 0xFFFE000000000000, 0x1EEFFFFFFFFFFF,
                    0x3FFFBFFFFFFFFFFE, 0x1FFF,
                ],
                };

                pub const OTHER_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8C00D4EE00000000, 0x10000001, 0x80C0008200000000, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0x4000000000000000, 0x80, 0, 0, 0, 0, 0, 0, 0xFC000000, 0x200,
                    0x18000000000049, 0xE8003600, 0x3C0000000000, 0, 0x100000, 0x3FFF, 0, 0,
                    0x380000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 2, 2, 2, 2, 7, 8, 2, 2, 2, 2, 9, 2,
                    10, 2, 2, 11, 2, 12, 13, 2, 14, 2, 15, 2, 2, 2, 2, 2, 2, 2, 2, 2, 16, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 17, 2, 18, 19, 2, 2, 20, 21, 2, 2, 2, 2, 22,
                    2, 2, 23, 2, 24, 2, 2, 25, 2, 26, 27, 28, 2, 29, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 30, 31, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 32, 2, 6, 2, 2, 33, 34, 2, 2, 2, 2, 2, 2, 35, 2, 2, 15,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 28, 2, 2, 2, 2, 36, 37, 2, 38, 2,
                    2, 2, 2, 2, 39, 2, 40, 41, 42, 2, 43, 2, 44, 2, 45, 2, 2, 2, 46, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    47, 48, 2, 2, 49, 50, 2, 2,
                ],
                tree2_level2: &[
                    0x7FFF000000000000, 0x40000000, 0, 0x1003000000000, 0x2000000000000000,
                    0x40000000000000, 0x1000000000000, 0x80000000000000, 0x10,
                    0x10000000000000, 0xC008000, 0x17FFF0, 0x20, 0x61F0000, 0xFC00,
                    0x800000000000000, 0x1FF00000000, 0x400000000000, 0x380000000000,
                    0x60000000000000, 0x7700000, 0x7BF, 0x30, 0xC0000000, 0x3F7F00000000,
                    0xE0000001FC00C000, 0xF000000000000000, 0xF800000000000000,
                    0xC000000000000000, 0x800FF, 0x79FF00FF00C00000, 0x7FEBFF8E,
                    0xDE00000000000000, 0xF3FF7C00CB7FC9C3, 0x1CFFFA, 0x200000000000000E,
                    0xE000, 0x4008000000000000, 0xFC000000000000, 0xF0000000000000,
                    0x170000000000C000, 0xC00000000000, 0x80000000, 0xC0003FFE, 0xF0000000,
                    0x30000C0000000, 0x80000000000, 0x10000027F0000, 0xD0380F71E60,
                    0x100000018C00D4EE, 0x3200000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 3, 3, 3, 3, 5, 3, 6, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 4, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 6, 0, 0, 0, 0, 7, 0, 8, 9, 0, 10, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 0, 0, 13, 14, 15, 0, 16, 0,
                    17, 18, 0, 19, 0, 0, 0, 0, 20, 0, 21, 0, 22, 0, 0, 0, 23, 0, 24, 25, 0,
                    26, 0, 0, 0, 27, 0, 0, 0, 0, 28, 0, 29, 30, 31, 32, 0, 33, 0, 0, 34, 0,
                    35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 37, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 41, 42, 43, 0, 0, 0, 0, 0,
                    0, 0, 44, 0, 0, 0, 0, 45, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7, 0x80000000, 0x10000, 0x800000000000, 0x800000, 0x8000000080000000,
                    0x8000000001FF0000, 0x7F000000000000, 0xFE00000000000000, 0x1E000000,
                    0x3E00000, 0x3C0, 0x3F80, 0xD800000000000000, 0x3, 0x3000000000000F,
                    0xE80021E0, 0x3F00000000000000, 0x20000000000, 0x1B00000, 0x2C00F800,
                    0x40, 0xFFFFFE, 0x1FFF0000000E, 0x200000000000000, 0x7000000000000000,
                    0x800000000000000, 0x70, 0x400000000, 0x8000000000000000, 0x7F,
                    0x7DC000000, 0x3FF, 0x200000000, 0x300000000003E, 0x180000000000000,
                    0xFFF8, 0x1F000000000000, 0x6000000000000, 0xC00000000000,
                    0x20000000000000, 0xF80000000000000, 0x10, 0xE00000000000, 0x7800000,
                    0xF80, 0xC0000000,
                ],
                };

                pub const OTHER_SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x1424000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4,
                    0, 0, 0, 0x6000, 0, 0xC000, 0, 0, 0x6000020040000000, 0, 0, 0,
                    0x40000000000000,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 3, 0, 4, 0, 0, 0, 5, 0, 0, 0,
                    0, 0, 0, 6, 0, 7, 8, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 13, 0,
                    0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 15, 16, 17, 18, 0, 0, 0, 0, 19, 20, 21, 22, 23, 24, 25, 23, 26,
                    26, 27, 28, 26, 29, 26, 26, 26, 30, 31, 0, 26, 26, 26, 26, 0, 0, 0, 0, 0,
                    0, 0, 0, 32, 33, 34, 26, 0, 0, 0, 35, 0, 0, 0, 0, 0, 36, 37, 38, 26, 26,
                    26, 39, 40, 0, 0, 0, 0, 0, 41, 42, 43, 44, 45, 26, 26, 26, 26, 26, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    46, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0,
                    49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 51, 0, 0, 0, 0, 0, 0, 0, 52,
                ],
                tree2_level2: &[
                    0, 0x400000000000000, 0x1000000000000, 0x5F8000000000000,
                    0x8000000000000000, 0x200000000008000, 0x1500000FCE8000E,
                    0xC000000000000000, 0x1E0DFBF, 0xC0000000, 0x3FF0000, 0x200000000000, 0x1,
                    0xFFFFFFFFC0000000, 0x1FF007FE00000000, 0xC0042AFC0D0037B, 0xB400,
                    0xFFFFBFB6F3E00C00, 0xFFFFFFFEB3FFF, 0xFFFFF9FCFFFFF0FF,
                    0xEFFFFFFFFFFFFFFF, 0xFFF0000007FFFFFF, 0xFFFFFFFC0FFFFFFF, 0x3FFFFFFFFFF,
                    0x7FF, 0xFFFFFFFFF0000000, 0xFFFFFFFFFFFFFFFF, 0xFF7FFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFD, 0xFFFF7FFFFFFFFFFF, 0xFFFFFFFFFF, 0xFFFFFFFFFFF00000,
                    0xFFFFFFFFFFFF, 0xFFCFFFFFFFFFE060, 0xFFFFFFFFFFBFFFFF, 0x7E000000000,
                    0x30000, 0xFFFFFFFFFBFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFF0000003FFFFF,
                    0xC0C00001000C0010, 0xFFC30000, 0x803FFFFFFFFF, 0xFFFFFC007FFFFFFF,
                    0xFFFFFFFF000100FF, 0x1FFFFFFFFFC00, 0xFFFFFFFFFFFF0000, 0x7F,
                    0x2C00F0000000000, 0x380000000000000, 0xFFFF, 0xE000000000008000,
                    0x3000611000000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12,
                    13, 12, 12, 12, 12, 12, 12, 14, 0, 0, 15, 12, 16, 12, 12, 12, 17, 18, 19,
                    20, 21, 12, 22, 0, 0, 12, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 24, 25, 26, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 29, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 30, 12, 31, 32, 33, 12, 34, 35, 36, 37, 0, 0, 12, 12, 12,
                    38, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 39, 12, 40, 12, 41, 42,
                    43, 44, 45, 12, 12, 12, 12, 12, 46, 47, 48, 12, 12, 49, 13, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF80000000000000, 0xFE00000000000000, 0x11FFF73FF,
                    0x1FFFFFFFFFFF0000, 0x180000000000000, 0x100, 0x8000000000000000,
                    0x3FFFE1FE00000, 0xF000000000000000, 0x20, 0x10000000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xF,
                    0x3FFFFFFFFFFFFF, 0xFFFFFE7FFFFFFFFF, 0x1C1FFFFFFFFF, 0xFFFFC3FFFFFFF018,
                    0x7FFFFFFFFFF, 0x23, 0x7FFFFF, 0x780000000000000, 0xFFDFE00000000000,
                    0x6F, 0x8000, 0x100000000000, 0x400000000000, 0xFFFF0FFFFFFFFFFF,
                    0xFFFE7FFF000FFFFF, 0x3FFFFFFFFEFFFE, 0xFFFFFFFFFFFFE000, 0x3FFFFFFFFFFF,
                    0xFFFFFFC000000000, 0xFFFFFFFFFFF0007, 0x3F000301FF, 0x7FFFFFFFFFFFFFF,
                    0x1FFF1FFFF0FFFFFF, 0xF87FFFFFFFFFFFFF, 0x10FFF03FFFFFF,
                    0xFFFFFFFFFFFF0FFF, 0xFFFFFFFF03FF00FF, 0xFFF3FFFFFFF00FF, 0x3,
                    0x1FFF3FFF000FFFFF, 0xFFFFFFFFFFFF83FF, 0x1FF03FF9FFFC07F,
                    0xFFFFFFFFFFF7FFFF,
                ],
                };

                pub const PARAGRAPH_SEPARATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x20000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const PRIVATE_USE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFF,
                ],
                };

                pub const PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8C00F7EE00000000, 0x28000000B8000001, 0x88C0088200000000, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0x4000000000000000, 0x80, 0, 0, 0, 0, 0, 0, 0xFC000000,
                    0x4000000000000600, 0x18000000000049, 0xE8003600, 0x3C0000000000, 0,
                    0x100000, 0x3FFF, 0, 0, 0x380000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 2, 2, 2, 2, 7, 8, 2, 2, 2, 2, 9, 2,
                    10, 2, 2, 11, 2, 12, 13, 2, 14, 2, 15, 2, 2, 2, 2, 2, 2, 2, 2, 2, 16, 2,
                    2, 17, 2, 2, 2, 2, 2, 2, 2, 2, 18, 19, 20, 21, 2, 2, 22, 23, 2, 2, 2, 2,
                    24, 2, 2, 25, 2, 26, 2, 2, 27, 2, 28, 29, 30, 2, 31, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 32, 33, 34, 2, 2, 2, 2, 2, 2, 2, 2, 2, 35, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 36, 2, 37, 2, 2, 2, 2, 2, 2, 38, 39, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 40, 2, 6, 2, 2, 41, 42, 2, 2, 2, 2, 2, 2,
                    43, 2, 44, 15, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 30, 2, 2, 2, 2, 45,
                    46, 2, 47, 2, 2, 2, 2, 2, 48, 2, 49, 50, 51, 2, 52, 2, 53, 2, 54, 2, 2, 2,
                    55, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 30, 2, 2, 2, 56, 57, 2, 2, 58, 59, 2, 2,
                ],
                tree2_level2: &[
                    0x7FFF000000000000, 0x40000000, 0, 0x1003000000000, 0x2000000000000000,
                    0x40000000000000, 0x1000000000000, 0x80000000000000, 0x10,
                    0x10000000000000, 0xC008000, 0x3C0000000017FFF0, 0x20, 0x61F0000, 0xFC00,
                    0x800000000000000, 0x1FF00000000, 0x1, 0x400000000000, 0x18000000,
                    0x380000000000, 0x60000000000000, 0x7700000, 0x7FF, 0x30, 0xC0000000,
                    0x3F7F00000000, 0xE0000001FC00C000, 0xF000000000000000,
                    0xF800000000000000, 0xC000000000000000, 0x800FF, 0xFFFF00FFFFFF0000,
                    0x600000007FFBFFEF, 0x6000, 0x60000000F00, 0x3FFF0000000000,
                    0xFFC000000060, 0x1FFFFF8, 0x300000000F000000, 0xDE00000000000000,
                    0xFFFF7FFFFFFFFFFF, 0x3FFCFFFF, 0x20010000FFF3FF0E, 0x100000000, 0xE000,
                    0x4008000000000000, 0xFC000000000000, 0xF0000000000000,
                    0x170000000000C000, 0xC00000000000, 0x80000000, 0xC0003FFE, 0xF0000000,
                    0x30000C0000000, 0x80000000000, 0xFFFF000003FF0000, 0xD0BFFF7FFFF,
                    0xB80000018C00F7EE, 0x3FA8000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 3, 3, 3, 3, 5, 3, 6, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 4, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 6, 0, 0, 0, 0, 7, 0, 8, 9, 0, 10, 0, 0,
                    0, 0, 0, 0, 11, 0, 0, 0, 0, 12, 0, 0, 13, 14, 0, 0, 15, 16, 17, 0, 18, 0,
                    19, 20, 0, 21, 0, 0, 0, 0, 22, 0, 23, 0, 24, 0, 0, 0, 25, 0, 26, 27, 0,
                    28, 0, 0, 0, 29, 0, 0, 0, 0, 30, 0, 31, 32, 33, 34, 0, 35, 0, 0, 36, 0,
                    37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 39, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 0, 43, 44, 45, 0, 0, 0, 0, 0,
                    0, 0, 46, 0, 0, 0, 0, 47, 0, 0, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7, 0x80000000, 0x10000, 0x800000000000, 0x800000, 0x8000000080000000,
                    0x8000000001FF0000, 0x7F000000000000, 0xFE00000000000000, 0x1E000000,
                    0x400000000000, 0x200000000000, 0x3E00000, 0x3C0, 0x3F80,
                    0xD800000000000000, 0x3, 0x3000000000000F, 0xE80021E0, 0x3F00000000000000,
                    0x20000000000, 0x1B00000, 0x2C00F800, 0x40, 0xFFFFFE, 0x1FFF0000000E,
                    0x200000000000000, 0x7000000000000000, 0x800000000000000, 0x70,
                    0x400000000, 0x8000000000000000, 0x7F, 0x7DC000000, 0x3FF, 0x200000000,
                    0x300000000003E, 0x180000000000000, 0xFFF8, 0x1F000000000000,
                    0x6000000000000, 0xC00000000000, 0x20000000000000, 0xF80000000000000,
                    0x10, 0xE00000000000, 0x7800000, 0xF80, 0xC0000000,
                ],
                };

                pub const SEPARATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x100000000, 0, 0x100000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x8300000007FF, 0x80000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SPACE_SEPARATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x100000000, 0, 0x100000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x8000000007FF, 0x80000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SPACING_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 5, 7, 8, 4, 9, 10, 11, 12, 8, 13, 3, 14, 15,
                    16, 0, 0, 0, 0, 9, 17, 0, 0, 18, 19, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 22, 23, 0, 0, 0, 0, 24,
                    0, 0, 0, 25, 26, 0, 0, 27, 28, 29, 30, 31, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    34, 0, 35, 36, 0, 37, 38, 6, 39, 40, 0, 41, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC800000000000008, 0xDE01, 0xC00000000000000C, 0x801981,
                    0xC000000000000008, 0x1, 0x1A01, 0x400000000000000C, 0xC000000000000000,
                    0x801DC6, 0xE, 0x1E, 0x8000000600D9F, 0x801DC1, 0xC, 0xC0000FF038000,
                    0x8000000000000000, 0x1902180000000000, 0x3F9C00C00000, 0x1C009F98,
                    0x10000000200000, 0xC040000000000000, 0x1BF, 0x1FB0E7800000000, 0x6000000,
                    0x7E01A00A00000, 0xE820000000000010, 0x1B, 0x4C200000004, 0xC5C8000000000,
                    0x300FF000000000, 0x80000200000000, 0xC00000000000, 0x9800000000,
                    0xFFF0000000000003, 0xF, 0xC0000, 0xCC30000000000008, 0x19800000000000,
                    0x2800000000002000, 0x20C80000000000, 0x16D800000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 3, 4, 5, 6, 7, 0, 0,
                    8, 9, 10, 11, 12, 13, 14, 15, 16, 0, 0, 17, 0, 18, 0, 19, 0, 20, 0, 0, 0,
                    21, 0, 0, 0, 22, 1, 0, 23, 24, 25, 26, 0, 0, 0, 0, 0, 27, 0, 28, 0, 0, 0,
                    29, 0, 0, 0, 0, 30, 31, 16, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33,
                    34, 35, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x5, 0x187000000000004, 0x100000000000, 0x60, 0x8038000000000004,
                    0x4001, 0x2C700000000000, 0x700000000, 0xC00000000000000C, 0xC0080399E,
                    0x700000000000000, 0xB7A4, 0xE0000000000000, 0x23, 0x7A07000000000000,
                    0x2, 0x4F03800000000000, 0x5807000000000000, 0x40D00000000000,
                    0x4340000000, 0x100700000000000, 0x21BF000000000000, 0x10F00E0000,
                    0x200000000000000, 0x1800000, 0x800000, 0x4000800000000000,
                    0x12020000000000, 0x587C00, 0x60000000000000, 0xC030000000000008,
                    0x1C0000000000, 0xFFFFFFFFFFFE0000, 0xFF, 0x3000000000000,
                    0x7E06000000000,
                ],
                };

                pub const SURROGATE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x7000081000000000, 0x5000000140000000, 0x113D37C00000000,
                    0x80000000800000, 0, 0, 0, 0, 0, 0, 0, 0xFFFFAFE0FFFC003C, 0,
                    0x20000000000000, 0x30, 0x40000000000000, 0, 0, 0x4, 0, 0, 0, 0xE000, 0,
                    0xC9C0, 0, 0, 0x6000020040000000, 0, 0, 0, 0xC040000000000000,
                ],
                tree2_level1: &[
                    0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 4, 0, 5, 0, 6, 0, 0, 0, 7, 0, 0, 6,
                    0, 0, 0, 8, 0, 9, 10, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 15, 0, 16,
                    0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 19,
                    0, 20, 21, 15, 22, 23, 24, 25, 25, 25, 25, 25, 26, 25, 25, 25, 27, 28, 29,
                    27, 25, 25, 25, 25, 25, 25, 25, 25, 25, 30, 31, 32, 25, 25, 25, 25, 25,
                    25, 33, 34, 25, 25, 25, 25, 25, 35, 36, 25, 0, 0, 0, 37, 0, 0, 0, 0, 0,
                    38, 39, 40, 25, 25, 25, 41, 42, 0, 43, 0, 0, 0, 44, 45, 46, 47, 48, 25,
                    25, 25, 25, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 49, 50, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 52, 0, 53, 0,
                    0, 0, 0, 0, 0, 0, 0, 54, 0, 0, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 56, 0, 57, 58, 0, 0, 0, 0, 0, 59, 0, 60, 0, 61, 0, 0,
                    62, 63, 0, 64,
                ],
                tree2_level2: &[
                    0, 0x100, 0xC0C000000000000, 0x2000000000000, 0x1000000000000,
                    0x7F8000000000000, 0x8000000000000000, 0x200000000008000,
                    0x1500000FCE8000E, 0xC000000000000000, 0x1E0DFBF, 0xC0000000, 0x3FF0000,
                    0x200000000000, 0x8000000, 0x1, 0xFFFFFFFFC0000000, 0x1FF007FE00000000,
                    0xA000000000000000, 0x6000E000E000E003, 0x1C00000000040010,
                    0xFFFFFFFF00001C00, 0xC0042AFC1D0037B, 0xBC1F, 0xFFFFFFFFFFFF0C00,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFF9FFFFFFF0FF, 0x3FFFFFFFFFF, 0x7FF,
                    0xFFFFFFFFF0000000, 0xFFFFFFFFFF, 0xFFFFFFFFFFF00000, 0xFFFF003FFFFFFF9F,
                    0xFFFFFFFFFE000007, 0xCFFFFFFFF0FFFFFF, 0xFFCFFFFFFFFFFFFF,
                    0xFFFFFFFFFFBFFFFF, 0x7E000000000, 0x30000, 0xFFFFFFFFFBFFFFFF,
                    0xFFFFFFFFFFFFF, 0xFFFF0000003FFFFF, 0xC0C00001000C0010, 0x18000000,
                    0xFFC30000, 0x803FFFFFFFFF, 0xFFFFFC007FFFFFFF, 0xFFFFFFFF000100FF,
                    0x1FFFFFFFFFC00, 0xFFFFFFFFFFFF0000, 0x7F, 0x3007FFFFF, 0x600,
                    0x3C00F0000000000, 0x380000000000000, 0xC0008000000, 0x20000000000,
                    0xFFFC000000000000, 0x7, 0xFFFF, 0xF000000000008000, 0x27400000000,
                    0x4000000070000810, 0x50000001, 0x30007F7F00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 13, 13,
                    14, 13, 13, 13, 13, 13, 13, 15, 0, 0, 16, 13, 17, 13, 13, 13, 18, 19, 20,
                    21, 22, 13, 23, 0, 0, 13, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25,
                    26, 27, 28, 29, 13, 13, 13, 13, 13, 13, 13, 13, 30, 31, 32, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0,
                    0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 35, 0, 0, 0, 0,
                    0, 0, 36, 0, 0, 0, 0, 37, 13, 38, 39, 40, 13, 41, 42, 43, 44, 0, 0, 13,
                    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 45, 13, 46, 13,
                    47, 48, 49, 50, 51, 13, 13, 13, 13, 13, 52, 53, 54, 13, 13, 55, 14, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF80000000000000, 0xFE00000000000000, 0x11FFF73FF,
                    0x1FFFFFFFFFFF0000, 0x180000000000000, 0x100, 0xC000, 0x8000000000000000,
                    0x3FFFFFFE00000, 0xF000000000000000, 0x20, 0x10000000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xF,
                    0x3FFFFFFFFFFFFF, 0xFFFFFE7FFFFFFFFF, 0x1C1FFFFFFFFF, 0xFFFFC3FFFFFFF018,
                    0x7FFFFFFFFFF, 0x23, 0x7FFFFF, 0x800000008000002, 0x20000000200000,
                    0x800000008000, 0x20000000200, 0x8, 0x780000000000000, 0xFFDFE00000000000,
                    0x6F, 0x8000, 0x1100000000000, 0x400000000000, 0x3000000000000,
                    0xFFFF0FFFFFFFFFFF, 0xFFFE7FFF000FFFFF, 0x3FFFFFFFFEFFFE,
                    0xFFFFFFFFFFFFE000, 0x3FFFFFFFFFFF, 0xFFFFFFC000000000, 0xFFFFFFFFFFF0007,
                    0x3F000301FF, 0x1FFF1FFFF0FFFFFF, 0xF87FFFFFFFFFFFFF, 0x10FFF03FFFFFF,
                    0xFFFFFFFFFFFF0FFF, 0xFFFFFFFF03FF00FF, 0xFFF3FFFFFFF00FF, 0x3,
                    0x1FFF3FFF000FFFFF, 0xFFFFFFFFFFFF83FF, 0x1FF03FF9FFFC07F,
                    0xFFFFFFFFFFF7FFFF,
                ],
                };

                pub const TITLECASE_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0x4000000000920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1000FF00FF00FF00, 0x1000000000001000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const UNASSIGNED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x300000000000000, 0x40000280F, 0,
                    0, 0, 0, 0, 0x1000000000000, 0x1800000, 0x11800, 0xFFE078000000FF00, 0, 0,
                    0, 0, 0x4000, 0x1800, 0xFFFC000000000000, 0x1800000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 22, 23, 24, 25, 3, 26, 27, 28, 3, 3, 3, 29, 3, 3, 3, 3, 3, 30,
                    31, 32, 33, 34, 35, 36, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 37, 38, 39, 40, 3,
                    41, 35, 38, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 3, 52, 3, 53, 54, 55,
                    56, 57, 3, 3, 3, 3, 3, 3, 3, 3, 58, 59, 60, 61, 3, 62, 63, 64, 3, 3, 65,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 66, 67, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 69, 3, 3, 3, 3, 70, 71, 72,
                    73, 74, 3, 75, 76, 77, 3, 3, 3, 78, 3, 79, 80, 3, 81, 3, 82, 83, 84, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 85, 86, 3, 3, 3, 3, 87, 3, 3, 88, 3, 3, 3, 89, 90, 88, 3,
                    91, 3, 92, 3, 93, 94, 95, 3, 96, 97, 46, 3, 98, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 99, 100, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 101, 3, 102, 103, 104, 3, 105, 3, 3, 3, 3, 3, 3, 106, 107,
                    35, 108, 3, 109, 79, 3, 110, 111,
                ],
                tree2_level2: &[
                    0x8000C00000000000, 0xF800B0000000, 0x7C8000, 0, 0xC3A020000066010,
                    0x800000304F7F8660, 0x2C92020000067811, 0xFF80003FA1FDC678,
                    0xC12020000044011, 0x1FC0030FFFEC440, 0xC12020000066011,
                    0xFF0000304F1FC660, 0x3C0038E729C23813, 0xF800003FFF7EC238,
                    0xC00020000022000, 0x7F0030D89FC220, 0xC10020000022000,
                    0xFFF100309F9FC220, 0x22000, 0x30000F0220, 0xD004000003800011,
                    0xFFE3003F00A07B80, 0x7800000000000001, 0xFFFFFFFFF0000000,
                    0xC000005000000829, 0xFFFFFFFF0C0080A0, 0x1E00000000100,
                    0x2000000001000000, 0xFFFFFFFFF8002000, 0xDF40, 0xC280C200,
                    0x80C200000000C200, 0x8000C2, 0xC20000, 0xE000000018000000, 0xFC000000,
                    0xC0C0000000000000, 0xE0000000, 0xFE00000000000000, 0xFF8000007FC00000,
                    0xFFF22000FFF00000, 0xFC00FC00C0000000, 0xF80000000000,
                    0xFFC0000000000000, 0xF000F00080000000, 0xFFE0C0000000000E,
                    0xF00000000000, 0x3800FC00, 0x30000000, 0x6000000080000000,
                    0xC000FC00FC00, 0xFFFFFFFFFFFF8000, 0x2000, 0xFF0000000000000,
                    0x700000000000000, 0x1C00, 0x180000000000F800, 0xF80000000000FF00,
                    0xC0C00000, 0xC00000005500C0C0, 0x20000000000000, 0x8023000010300020,
                    0xC002000000000, 0xE0008000, 0xFFFE00000000FFFE, 0xF000,
                    0xFFFFFC0000000000, 0xFFFFF800, 0x30000000000000, 0x400000,
                    0x1F0000000000000, 0xDF4000000000, 0x7FFE7F0000000000, 0x80808080FF800000,
                    0x80808080, 0xFFFFFFFFC0000000, 0x4000000, 0xFFF0000000000000,
                    0xFFFFFFC00000, 0x1, 0x1800000, 0x100000000001F, 0x8000, 0x7FC000000000,
                    0x80000000, 0xE000, 0xFF80, 0xFFFFF00000000000, 0xFF00000000000000,
                    0x3FFFFE014C000, 0xFC00E00000000000, 0xFC003FC0, 0xE00000007FF00000,
                    0x800000003C004000, 0xFF80000000000000, 0xC00C000, 0xFF80000007FFFFF8,
                    0x8080FF818181, 0xFC00C00000000000, 0xFFF000000000, 0xF000000000000780,
                    0xC00000000000, 0xFFFFFFFFFC000000, 0xA08000001F07FF80, 0x24, 0x7FFF8,
                    0x30000, 0xFFFFFFFF7F00, 0x20F08000080000, 0x6000000000000000,
                    0x8000000000000000, 0xC1FF8080E3030303,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 23, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 23,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 2, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 2, 2, 14, 15, 16, 17,
                    18, 19, 2, 2, 2, 2, 20, 21, 22, 7, 23, 24, 25, 26, 27, 7, 28, 29, 30, 31,
                    32, 33, 34, 35, 36, 7, 2, 37, 38, 39, 40, 41, 42, 7, 7, 43, 44, 45, 16,
                    46, 47, 48, 2, 49, 2, 50, 51, 52, 2, 53, 54, 55, 56, 57, 58, 59, 60, 61,
                    2, 62, 2, 63, 7, 7, 64, 65, 2, 66, 67, 68, 69, 70, 7, 7, 71, 7, 72, 73,
                    74, 75, 76, 77, 2, 78, 79, 80, 81, 7, 7, 82, 83, 84, 85, 7, 86, 87, 88, 7,
                    7, 7, 7, 89, 90, 91, 92, 93, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 94,
                    7, 2, 95, 2, 2, 2, 96, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 97,
                    38, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 70, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    67, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 80, 99, 100, 101, 2, 102, 103, 7, 7,
                    7, 7, 7, 7, 67, 7, 7, 7, 2, 91, 7, 2, 104, 105, 106, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 107, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 108, 37, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 109, 2, 2, 2, 2, 110, 111, 2, 2, 2, 2, 2,
                    71, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 112, 113, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 2, 2, 2, 67, 2, 2, 2, 2, 2, 2, 19, 7, 114, 115, 2, 96, 2, 2,
                    2, 116, 117, 2, 2, 118, 2, 119, 7, 120, 2, 121, 7, 7, 2, 122, 123, 124,
                    125, 126, 2, 2, 2, 2, 127, 2, 2, 2, 2, 128, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    129, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 130, 7, 7, 7, 131,
                    132, 133, 7, 134, 135, 7, 7, 7, 7, 136, 137, 7, 7, 7, 7, 7, 7, 7, 138, 7,
                    7, 7, 139, 7, 7, 7, 7, 7, 7, 7, 140, 2, 2, 2, 141, 2, 142, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 143, 144, 7, 145, 7, 7, 7, 146, 147, 148, 149, 7, 7, 7,
                    7, 150, 2, 151, 152, 2, 2, 132, 153, 154, 155, 7, 7, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 156, 2, 157, 2, 158, 159, 160, 161, 55, 2, 2, 2,
                    2, 2, 162, 163, 164, 2, 2, 165, 67, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 32, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 67, 2, 2,
                    2, 166, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 167, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 168, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 65, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2,
                    2, 2, 2, 2, 2, 65, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 169, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 170, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 171, 2, 7, 7, 2, 2, 2, 170, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 172,
                ],
                tree3_level3: &[
                    0x4800008000001000, 0xFFFFFFFFC000C000, 0, 0xF800000000000000,
                    0x70000000000078, 0xFFFFFFFEE0008000, 0xC00000000000FFFF,
                    0xFFFFFFFFFFFFFFFF, 0xE0000000, 0xF0000000FFFE0000, 0x1FF000000000,
                    0xF80000000000F800, 0x40000000, 0xFFFFFFFFFFC000F0, 0xFC00C0000000,
                    0xF000000000F00000, 0xFF0000000000, 0x8007FF000000000, 0xE404000400480800,
                    0xFFF0000000000000, 0xFF80000000000000, 0xFFFFFF00FFC00000,
                    0xF802000000000040, 0x6E400000000002C0, 0x400000, 0xFFFF007F80000000,
                    0x7C80000FFFFFFFF, 0x7C00000070000000, 0xF00000000000000, 0x30000,
                    0x78C0000001100F90, 0xFE00FE00, 0xFFFFFFFF00000000, 0xFF80078000000000,
                    0x1C0000000000000, 0xF8000000C00000, 0xFFFF01FFE1FC0000,
                    0xFFFFFFFFFFFFFE00, 0xFFF8000000000000, 0x3F8000000000000,
                    0xFC00FF0000000000, 0x1C000000000, 0xFFFFFFFFFFFF3FC0, 0x80000000FFFFFFFF,
                    0xFFFCC40000000000, 0xFFFFFFFFFFFFFE3, 0xFFFFFC000000, 0xFFFFFFFFFC00,
                    0xFF800000FFFFF000, 0x7FC000000003C000, 0xFC00FE000000DFF8,
                    0x20000000000000, 0xFF8000000000FF00, 0xFFE0000100000000, 0x40000,
                    0xFFFFFFFFFFFFFFFC, 0xFC0040004280, 0xFC00F80000000000, 0x412020000066010,
                    0xFFE0E0301F7EC660, 0x4000000000B400, 0xFFFFFFF9FE40085A,
                    0xFFFFFFFC10000000, 0xFFFFFFFFFC00FF00, 0xC0000000000000,
                    0xFFFFFFFFC0000000, 0xFFFFE000FC00FFE0, 0xFC00000000000000,
                    0xFFFFFFF00000FC00, 0xF00018000000, 0xFFFFFFFFFFFFFF80,
                    0xF000000000000000, 0xFFFFFFFF, 0x7FF8000000000000, 0x640000000900D80,
                    0xFFFFFFFFFC00FF80, 0x300FFFFFFFF, 0xFFFFFFE003000000, 0xFF00,
                    0xFFF800000000, 0xFE00000000000000, 0xFFFFFFFFFFFFFC00,
                    0xFC00FFFC00000000, 0x80000000000200, 0xE0000000FFC0, 0xFF80010000030000,
                    0x4B80000000000480, 0x240FC00FF00, 0xFFFFFC00FE048000, 0xFE000000FFFFFFFF,
                    0x3800000000020000, 0xFFFFFFFFF8000000, 0xFFFEFFFFFFFFFFFF,
                    0x7FFC000000000000, 0xFFFFFFFFFC000000, 0xFFE0800000000000,
                    0xFFFFFFFFFFFFFFF0, 0xFFFF, 0xFFC00000, 0x3C0080000000,
                    0x8000000000000000, 0xFFC0C0000000FC00, 0x1F0000040400FFC0,
                    0xFFFFFFFFFFFF0000, 0x7800, 0xFFFFFFFF00007F00, 0xFFFCFFE0FFFFFFFF,
                    0xFF00000000000000, 0x7FFFFFFFFFC00000, 0x9010FFFFFFFFFFFF,
                    0xFFFBFFF800000000, 0xFF0FFFD8FFFF, 0xE000F80000000000,
                    0xFFFFFFF00C00FE00, 0xC00000000000, 0xFF80, 0xFFC0000000000000,
                    0x18000000000, 0xFFFFF80000000000, 0xFFFFFFFFFFFFFFC0, 0xFFF00000FFF00000,
                    0xFE000000FF800000, 0x200000, 0x1400219B20000000, 0x10,
                    0x8400000020201840, 0x203A0, 0xC000000000, 0x3000, 0xFFFF000107FFF000,
                    0xFFFFF81F80000000, 0xF82406000080, 0xFFFFC00000000000,
                    0xFFFFFFFFFFFF7FFF, 0xC000E00000000000, 0xFFFFFFFFFFFF3C00,
                    0xFFFF80000000FFFF, 0x7C00000000000000, 0xFC0000000000FFFF,
                    0x780000000000FFFF, 0x80009080FFFFFFFF, 0xFFFFFFFFFF800060,
                    0xFFFFFFFF3C00F000, 0x1FFFFFFFFFFFF, 0xFFE0000000000000,
                    0xC000000000000001, 0xF508016900000010, 0xA10808695569157B,
                    0xF0000411F0000400, 0xFFFCFFFFFFFFFFFF, 0xF00000000000, 0x18000FFF00000,
                    0xFFC0000000010001, 0x3FFFFFFFFF, 0xF00000000000FFF8, 0xFFFFFFC0FFFCFE00,
                    0xE000E0000F000000, 0x780000000000000, 0xFFFEF000FC000000, 0xF000,
                    0xFC00FF00, 0xF000C0000000FF00, 0xE000C000FFF00000, 0x7C00,
                    0xFE00FC0060003F80, 0x80000, 0xC0000000, 0xFFFC00000000, 0xFFFE00000000,
                    0xF800, 0xFFFF000000000000, 0xFFFFFFFD, 0xC000000000000000,
                ],
                };

                pub const UPPERCASE_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE, 0, 0x7F7FFFFF, 0xAA55555555555555, 0x2B555555555554AA,
                    0x11AED2D5B1DBCED6, 0x55D255554AAAA490, 0x6C05555555555555, 0x557A, 0, 0,
                    0, 0x8045000000000000, 0xFFBFFFED740, 0xE6905555551C8000, 0xFFFFFFFFFFFF,
                    0x5555555500000000, 0x5555555555555401, 0x5555555555552AAB,
                    0xFFFE555555555555, 0x7FFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 11, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 5,
                    16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 0, 19, 20, 21, 22, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x20BF, 0x3FFFFFFFFFFFFF, 0xE7FFFFFFFFFF0200,
                    0x5555555555555555, 0x5555555540155555, 0xFF00FF003F00FF00,
                    0xFF00AA003F00, 0xF00000000000000, 0xF001F000F000F00, 0xC00F3D503E273884,
                    0x20, 0x8, 0xFFFFFFFFFFFF, 0xC025EA9D00000000, 0x4280555555555,
                    0x155555555555, 0x5555555, 0x5554555400000000, 0x6A00555555555555,
                    0x555F7D5555452855, 0x20000015411AF5, 0x7FFFFFE00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11,
                    12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF, 0xFFFF000000000000, 0xFFFFF, 0xF7FF000000000000,
                    0x37F7FF, 0x7FFFFFFFFFFFF, 0x3FFFFF0000, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0xFFF0000003FFFFFF, 0xFFFFFF0000003FFF, 0x3FDE64D0000003, 0x3FFFFFF0000,
                    0x7B0000001FDFE7B0, 0xFFFFF0000001FC5F, 0x3FFFFFF0000003F, 0x3FFFFFF00000,
                    0xF0000003FFFFFF00, 0xFFFF0000003FFFFF, 0xFFFFFF00000003FF,
                    0x7FFFFFC00000001, 0x1FFFFFF0000000, 0x7FFFFFC00000, 0x1FFFFFF0000, 0x400,
                    0x3FFFFFFFF,
                ],
                };
            }
            // Copy from category::BY_NAME
            static CATEGORY_PROPERTY_NAMES = [
                ("Cased_Letter", CASED_LETTER), ("Close_Punctuation", CLOSE_PUNCTUATION),
                ("Connector_Punctuation", CONNECTOR_PUNCTUATION), ("Control", CONTROL),
                ("Currency_Symbol", CURRENCY_SYMBOL),
                ("Dash_Punctuation", DASH_PUNCTUATION), ("Decimal_Number", DECIMAL_NUMBER),
                ("Enclosing_Mark", ENCLOSING_MARK),
                ("Final_Punctuation", FINAL_PUNCTUATION), ("Format", FORMAT),
                ("Initial_Punctuation", INITIAL_PUNCTUATION), ("Letter", LETTER),
                ("Letter_Number", LETTER_NUMBER), ("Line_Separator", LINE_SEPARATOR),
                ("Lowercase_Letter", LOWERCASE_LETTER), ("Mark", MARK),
                ("Math_Symbol", MATH_SYMBOL), ("Modifier_Letter", MODIFIER_LETTER),
                ("Modifier_Symbol", MODIFIER_SYMBOL), ("Nonspacing_Mark", NONSPACING_MARK),
                ("Number", NUMBER), ("Open_Punctuation", OPEN_PUNCTUATION),
                ("Other", OTHER), ("Other_Letter", OTHER_LETTER),
                ("Other_Number", OTHER_NUMBER), ("Other_Punctuation", OTHER_PUNCTUATION),
                ("Other_Symbol", OTHER_SYMBOL),
                ("Paragraph_Separator", PARAGRAPH_SEPARATOR), ("Private_Use", PRIVATE_USE),
                ("Punctuation", PUNCTUATION), ("Separator", SEPARATOR),
                ("Space_Separator", SPACE_SEPARATOR), ("Spacing_Mark", SPACING_MARK),
                ("Surrogate", SURROGATE), ("Symbol", SYMBOL),
                ("Titlecase_Letter", TITLECASE_LETTER), ("Unassigned", UNASSIGNED),
                ("Uppercase_Letter", UPPERCASE_LETTER),
            ];

            mod script
            {
                // DO NOT EDIT THIS FILE. IT WAS AUTOMATICALLY GENERATED BY:
                //
                //   ucd-generate script --trie-set ./target/ucd/
                //
                // Unicode version: 16.0.0.
                //
                // ucd-generate 0.3.1 is available on crates.io.

                pub const BY_NAME: &'static [(&'static str, &'static ::ucd_trie::TrieSet)] = &[
                ("Adlam", ADLAM), ("Ahom", AHOM),
                ("Anatolian_Hieroglyphs", ANATOLIAN_HIEROGLYPHS), ("Arabic", ARABIC),
                ("Armenian", ARMENIAN), ("Avestan", AVESTAN), ("Balinese", BALINESE),
                ("Bamum", BAMUM), ("Bassa_Vah", BASSA_VAH), ("Batak", BATAK),
                ("Bengali", BENGALI), ("Bhaiksuki", BHAIKSUKI), ("Bopomofo", BOPOMOFO),
                ("Brahmi", BRAHMI), ("Braille", BRAILLE), ("Buginese", BUGINESE),
                ("Buhid", BUHID), ("Canadian_Aboriginal", CANADIAN_ABORIGINAL),
                ("Carian", CARIAN), ("Caucasian_Albanian", CAUCASIAN_ALBANIAN),
                ("Chakma", CHAKMA), ("Cham", CHAM), ("Cherokee", CHEROKEE),
                ("Chorasmian", CHORASMIAN), ("Common", COMMON), ("Coptic", COPTIC),
                ("Cuneiform", CUNEIFORM), ("Cypriot", CYPRIOT),
                ("Cypro_Minoan", CYPRO_MINOAN), ("Cyrillic", CYRILLIC),
                ("Deseret", DESERET), ("Devanagari", DEVANAGARI),
                ("Dives_Akuru", DIVES_AKURU), ("Dogra", DOGRA), ("Duployan", DUPLOYAN),
                ("Egyptian_Hieroglyphs", EGYPTIAN_HIEROGLYPHS), ("Elbasan", ELBASAN),
                ("Elymaic", ELYMAIC), ("Ethiopic", ETHIOPIC), ("Garay", GARAY),
                ("Georgian", GEORGIAN), ("Glagolitic", GLAGOLITIC), ("Gothic", GOTHIC),
                ("Grantha", GRANTHA), ("Greek", GREEK), ("Gujarati", GUJARATI),
                ("Gunjala_Gondi", GUNJALA_GONDI), ("Gurmukhi", GURMUKHI),
                ("Gurung_Khema", GURUNG_KHEMA), ("Han", HAN), ("Hangul", HANGUL),
                ("Hanifi_Rohingya", HANIFI_ROHINGYA), ("Hanunoo", HANUNOO),
                ("Hatran", HATRAN), ("Hebrew", HEBREW), ("Hiragana", HIRAGANA),
                ("Imperial_Aramaic", IMPERIAL_ARAMAIC), ("Inherited", INHERITED),
                ("Inscriptional_Pahlavi", INSCRIPTIONAL_PAHLAVI),
                ("Inscriptional_Parthian", INSCRIPTIONAL_PARTHIAN), ("Javanese", JAVANESE),
                ("Kaithi", KAITHI), ("Kannada", KANNADA), ("Katakana", KATAKANA),
                ("Kawi", KAWI), ("Kayah_Li", KAYAH_LI), ("Kharoshthi", KHAROSHTHI),
                ("Khitan_Small_Script", KHITAN_SMALL_SCRIPT), ("Khmer", KHMER),
                ("Khojki", KHOJKI), ("Khudawadi", KHUDAWADI), ("Kirat_Rai", KIRAT_RAI),
                ("Lao", LAO), ("Latin", LATIN), ("Lepcha", LEPCHA), ("Limbu", LIMBU),
                ("Linear_A", LINEAR_A), ("Linear_B", LINEAR_B), ("Lisu", LISU),
                ("Lycian", LYCIAN), ("Lydian", LYDIAN), ("Mahajani", MAHAJANI),
                ("Makasar", MAKASAR), ("Malayalam", MALAYALAM), ("Mandaic", MANDAIC),
                ("Manichaean", MANICHAEAN), ("Marchen", MARCHEN),
                ("Masaram_Gondi", MASARAM_GONDI), ("Medefaidrin", MEDEFAIDRIN),
                ("Meetei_Mayek", MEETEI_MAYEK), ("Mende_Kikakui", MENDE_KIKAKUI),
                ("Meroitic_Cursive", MEROITIC_CURSIVE),
                ("Meroitic_Hieroglyphs", MEROITIC_HIEROGLYPHS), ("Miao", MIAO),
                ("Modi", MODI), ("Mongolian", MONGOLIAN), ("Mro", MRO),
                ("Multani", MULTANI), ("Myanmar", MYANMAR), ("Nabataean", NABATAEAN),
                ("Nag_Mundari", NAG_MUNDARI), ("Nandinagari", NANDINAGARI),
                ("New_Tai_Lue", NEW_TAI_LUE), ("Newa", NEWA), ("Nko", NKO),
                ("Nushu", NUSHU), ("Nyiakeng_Puachue_Hmong", NYIAKENG_PUACHUE_HMONG),
                ("Ogham", OGHAM), ("Ol_Chiki", OL_CHIKI), ("Ol_Onal", OL_ONAL),
                ("Old_Hungarian", OLD_HUNGARIAN), ("Old_Italic", OLD_ITALIC),
                ("Old_North_Arabian", OLD_NORTH_ARABIAN), ("Old_Permic", OLD_PERMIC),
                ("Old_Persian", OLD_PERSIAN), ("Old_Sogdian", OLD_SOGDIAN),
                ("Old_South_Arabian", OLD_SOUTH_ARABIAN), ("Old_Turkic", OLD_TURKIC),
                ("Old_Uyghur", OLD_UYGHUR), ("Oriya", ORIYA), ("Osage", OSAGE),
                ("Osmanya", OSMANYA), ("Pahawh_Hmong", PAHAWH_HMONG),
                ("Palmyrene", PALMYRENE), ("Pau_Cin_Hau", PAU_CIN_HAU),
                ("Phags_Pa", PHAGS_PA), ("Phoenician", PHOENICIAN),
                ("Psalter_Pahlavi", PSALTER_PAHLAVI), ("Rejang", REJANG), ("Runic", RUNIC),
                ("Samaritan", SAMARITAN), ("Saurashtra", SAURASHTRA), ("Sharada", SHARADA),
                ("Shavian", SHAVIAN), ("Siddham", SIDDHAM), ("SignWriting", SIGNWRITING),
                ("Sinhala", SINHALA), ("Sogdian", SOGDIAN), ("Sora_Sompeng", SORA_SOMPENG),
                ("Soyombo", SOYOMBO), ("Sundanese", SUNDANESE), ("Sunuwar", SUNUWAR),
                ("Syloti_Nagri", SYLOTI_NAGRI), ("Syriac", SYRIAC), ("Tagalog", TAGALOG),
                ("Tagbanwa", TAGBANWA), ("Tai_Le", TAI_LE), ("Tai_Tham", TAI_THAM),
                ("Tai_Viet", TAI_VIET), ("Takri", TAKRI), ("Tamil", TAMIL),
                ("Tangsa", TANGSA), ("Tangut", TANGUT), ("Telugu", TELUGU),
                ("Thaana", THAANA), ("Thai", THAI), ("Tibetan", TIBETAN),
                ("Tifinagh", TIFINAGH), ("Tirhuta", TIRHUTA), ("Todhri", TODHRI),
                ("Toto", TOTO), ("Tulu_Tigalari", TULU_TIGALARI), ("Ugaritic", UGARITIC),
                ("Vai", VAI), ("Vithkuqi", VITHKUQI), ("Wancho", WANCHO),
                ("Warang_Citi", WARANG_CITI), ("Yezidi", YEZIDI), ("Yi", YI),
                ("Zanabazar_Square", ZANABAZAR_SQUARE),
                ];

                pub const ADLAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xC3FF0FFF,
                ],
                };

                pub const AHOM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF0FFFE7FFFFFF, 0x7F,
                ],
                };

                pub const ANATOLIAN_HIEROGLYPHS: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x7F,
                ],
                };

                pub const ARABIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFFFFFF77FFEFDF, 0xFFFEFFFFFFC007FE, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFDFFFFFFF, 0, 0xFFFFFFFFFFFF0000, 0, 0,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5,
                    6, 5, 5, 5, 5, 7, 5, 8, 9, 0, 10, 5, 11, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF000000000000, 0xFFFFFFFFFF837FFF, 0xFFFFFFFBFFFFFFFF,
                    0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFF80007,
                    0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFCFFFF, 0xFFFF0000000080FF,
                    0xFFDF000000000000, 0x1FFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFF00000000, 0xF00000000000001C, 0xAF7FE96FFFFFFEF,
                    0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0x3000000000000,
                ],
                };

                pub const ARMENIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFE000000000000, 0xFFFFFFFFFE7FFFFF, 0xE7FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF80000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const AVESTAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFE3FFFFFFFFFFFFF,
                ],
                };

                pub const BALINESE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFDFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BAMUM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                    1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x1FFFFFFFFFFFFFF,
                ],
                };

                pub const BASSA_VAH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3F3FFFFFFF0000,
                ],
                };

                pub const BATAK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF00FFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BENGALI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3C5FDFFFFF99FEF, 0x7FFFFFCFB080799F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BHAIKSUKI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF7FFFFFFFFFFDFF, 0x1FFFFFFF003F,
                ],
                };

                pub const BOPOMOFO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xC0000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFE0, 0xFFFFFFFF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BRAHMI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x803FFFFFFFFC3FFF,
                ],
                };

                pub const BRAILLE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BUGINESE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xCFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BUHID: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CANADIAN_ABORIGINAL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF000000000000, 0x3FFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000,
                ],
                };

                pub const CARIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000, 0x1FFFF,
                ],
                };

                pub const CAUCASIAN_ALBANIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x800FFFFFFFFF,
                ],
                };

                pub const CHAKMA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFDFFFFFFFFFFFFF, 0xFF,
                ],
                };

                pub const CHAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FFFFFFFFFFFFF, 0xF3FF3FFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CHEROKEE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x3F3FFFFFFFFFFFFF, 0xFFFF000000000000,
                    0xFFFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CHORASMIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0xFFF,
                ],
                };

                pub const COMMON: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFFFFFFFFFFFFFFFF, 0xF8000001F8000001, 0xFBFFFBFFFFFFFFFF,
                    0x80000000800000, 0, 0, 0, 0, 0, 0, 0xFE00000000000000,
                    0xFFFFF3E0FFFFFFFF, 0, 0x4010000000000000, 0xA0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0x88001020, 0x1, 0, 0x20000000, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
                    0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 12,
                    13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 17, 17, 17,
                    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 17, 17, 17, 17,
                    17, 17, 17, 17, 17, 20, 21, 17, 0, 0, 0, 0, 0, 0, 0, 0, 17, 22, 0, 0, 0,
                    0, 0, 23, 24, 0, 25, 26, 0, 0, 27, 28, 29, 30, 17, 31, 0, 32, 17, 17, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 34, 0, 35, 0, 0, 0, 36, 0, 0, 37, 0,
                    0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 39, 0, 0, 0, 40, 41, 0, 3, 42, 43, 44, 45,
                ],
                tree2_level2: &[
                    0, 0x400000000, 0x3000000000, 0x8000000000000000, 0x1E00000,
                    0x800000000000000, 0x380000000000, 0x60000000000000, 0x2C,
                    0x4EFDE0200080000, 0xFFFFFFFFFFFFCFFF, 0x7FF1FFDFFFFFFFFF,
                    0xFFFFFFFF00007FFF, 0x1, 0xFFFBF3BFFFFFFFFF, 0xFFFFBFFF,
                    0xFFFFFFFFFFFF0E00, 0xFFFFFFFFFFFFFFFF, 0x3FFFFFFFFFF, 0xFFFFFFFF000007FF,
                    0xFFCFFFFFFFFFFFFF, 0xFFFFFFFFFFBFFFFF, 0x3FFFFFFF, 0xFFFF000000000000,
                    0xF0FF0001FFFFFF5F, 0x118000000, 0x1800000000000000, 0xFFFF0000,
                    0x803FFFFFFFFF, 0xFFFFFFFF00000000, 0x80000000FFFFFFFF,
                    0x800000000000FFFF, 0xFFFFFFFFFF000000, 0x3FFFFFFFF, 0x700,
                    0x3FF000000000000, 0x400000000000, 0x8000, 0xC0008000000,
                    0xC000000000000000, 0xFFFF000003FF0000, 0xF7FFFF7FFFF, 0xF8000001FFFFFFFE,
                    0x1003FF8000001, 0xC0000000, 0x3E007F7F00000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 0, 2, 3, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6,
                    8, 0, 0, 9, 6, 10, 6, 6, 6, 11, 12, 13, 14, 15, 0, 0, 0, 16, 6, 17, 0, 0,
                    6, 18, 19, 20, 21, 22, 6, 6, 6, 6, 23, 6, 6, 6, 6, 24, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    25, 26, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 6, 29, 30, 6, 6, 31,
                    32, 33, 34, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 35, 6, 36,
                    6, 37, 38, 39, 40, 41, 6, 6, 6, 6, 6, 42, 43, 44, 6, 6, 45, 7, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF8FFFFFFFFFFF87, 0x1FFF0000, 0x1FFFFFFFFFFF0000, 0xFFFFFFE00000000,
                    0xF00000000, 0xFFFFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFF, 0xFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF0000, 0xF, 0x3FFFFFFFFFFFFF, 0xFFFFFE7FFFFFFFFF,
                    0x7FFFC7FFFFFFFFF, 0xFFFFC3FFFFFFF018, 0x7FFFFFFFFFF, 0xFFFFF000FFFFF,
                    0x1FFFFFF007FFFFF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xFFFFFFFFFFFFCFFF, 0xFFFE000000000000,
                    0x1FFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFE, 0xFFFF0FFFFFFFFFFF,
                    0xFFFE7FFF000FFFFF, 0x3FFFFFFFFEFFFE, 0x3FFFFFFFFFFF, 0xFFFFFFC000000000,
                    0xFFFFFFFFFFF0006, 0x3F000301FF, 0x1FFF1FFFF0FFFFFF, 0xF87FFFFFFFFFFFFF,
                    0x10FFF03FFFFFF, 0xFFFFFFFFFFFF0FFF, 0xFFFFFFFF03FF00FF,
                    0xFFF3FFFFFFF00FF, 0x3, 0x1FFF3FFF000FFFFF, 0xFFFFFFFFFFFF83FF,
                    0x1FF03FF9FFFC07F, 0xFFFFFFFFFFF7FFFF, 0xFFFFFFFF00000002,
                ],
                };

                pub const COPTIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFC00000000, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFE0FFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CUNEIFORM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 2, 0, 1, 3, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FFFFFF, 0x1F7FFFFFFFFFFF, 0xF,
                ],
                };

                pub const CYPRIOT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x91BFFFFFFFFFFD3F,
                ],
                };

                pub const CYPRO_MINOAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 2,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFF0000, 0x7FFFFFFFFFFFF,
                ],
                };

                pub const CYRILLIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF9F, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FF, 0x80000000000, 0x100000000000000, 0xFFFFFFFF00000000,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF, 0xC00000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x8000,
                ],
                };

                pub const DESERET: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF,
                ],
                };

                pub const DEVANAGARI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFCFFFE1FFFF, 0xFFFFFFFF00000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF,
                ],
                };

                pub const DIVES_AKURU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF9BFFFFFFF6FF27F, 0x3FF007F,
                ],
                };

                pub const DOGRA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFF,
                ],
                };

                pub const DUPLOYAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0xF3FF01FF,
                ],
                };

                pub const EGYPTIAN_HIEROGLYPHS: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF003FFFFF, 0x7FFFFFFFFFFFFFF,
                ],
                };

                pub const ELBASAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF,
                ],
                };

                pub const ELYMAIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFF00000000,
                ],
                };

                pub const ETHIOPIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF,
                    0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x1FFFFFFFE7FFFFFF, 0x3FFFFFF,
                    0x7F7F7F7F007FFFFF, 0x7F7F7F7F, 0x7F7F007E7E7E,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFF6F7F00000000,
                ],
                };

                pub const GARAY: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFE3FFFFFFFFF, 0xC03F,
                ],
                };

                pub const GEORGIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xF7FFFFFFFFFF20BF, 0xE7FFFFFFFFFF0000,
                    0x20BFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const GLAGOLITIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7DBF9FFFF7F,
                ],
                };

                pub const GOTHIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x7FF,
                ],
                };

                pub const GRANTHA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF3EDFDFFFFF99FEF, 0x1F1FCFE081399F,
                ],
                };

                pub const GREEK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xBCEF000000000000,
                    0xFFFFFFFBFFFFD750, 0xFFFF0003FFFFFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 4, 5, 6, 7, 0, 0, 0, 0,
                    8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7C000000000, 0x7C3E0000000, 0x8000000000000000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0xFFDFFFFFFFFFFFFF, 0x7FDCFFFFEFCFFFDF, 0x4000000000,
                    0x2000000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x100007FFF, 0x3F,
                ],
                };

                pub const GUJARATI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3EDFDFFFFFBBFEE, 0xFE03FFCF00013BBF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const GUNJALA_GONDI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFDBF00000000, 0x3FF01FB7FFF,
                ],
                };

                pub const GURMUKHI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xD36DFDFFFFF987EE, 0x7FFFC05E023987,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const GURUNG_KHEMA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFFFFFFFFFFFFF,
                ],
                };

                pub const HAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 6, 3, 7, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFBFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x3FFFFF,
                    0xF0003FE000000A0, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 3, 4, 5, 2, 6, 7, 2, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 10, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3000C00000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF, 0x3FFFFFFFFFFFFFF,
                    0xFFFFFFFF3FFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                    0xFFFFFFFFFFFF07FF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const HANGUL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 1, 4, 0, 5, 6, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 10,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xC00000000000, 0xFFFE000000000000, 0x7FFF,
                    0x7FFFFFFF, 0x7FFFFFFF00000000, 0x1FFFFFFF00000000, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const HANIFI_ROHINGYA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF00FFFFFFFFFF,
                ],
                };

                pub const HANUNOO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1FFFFF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const HATRAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF837FFFF00000000,
                ],
                };

                pub const HEBREW: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFFFFFFFFFE0000, 0x1F87FFFFFF00FF, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x5F7FFFFFE0000000, 0xFFDB,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const HIRAGANA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFE, 0xE07FFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, 4, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 0x40000FFFFFFFF, 0x70000, 0x1,
                ],
                };

                pub const IMPERIAL_ARAMAIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFBFFFFF,
                ],
                };

                pub const INHERITED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0x60, 0, 0, 0, 0, 0, 0, 0x10000003FF800, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
                    3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 7,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1E0000, 0xFFFF000000000000, 0x7FFF, 0x31021FDFFF70000,
                    0xFFFFFFFFFFFFFFFF, 0x3000, 0x1FFFFFFFF0000, 0x3C0000000000, 0x6000000,
                    0x3FFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 4, 5, 0, 0, 0, 0, 0, 0, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x800000000000000, 0xFFFF3FFFFFFFFFFF,
                    0x7F, 0xF800038000000000, 0x3C0000000FE7, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF,
                ],
                };

                pub const INSCRIPTIONAL_PAHLAVI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF07FFFF00000000,
                ],
                };

                pub const INSCRIPTIONAL_PARTHIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF3FFFFF,
                ],
                };

                pub const JAVANESE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xC3FF3FFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const KAITHI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x2007,
                ],
                };

                pub const KANNADA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3EFFDFFFFFDDFFF, 0xEFFCF60603DDF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const KATAKANA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 3, 0, 0, 0, 4, 5, 6, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFE00000000, 0xE7FFFFFFFFFFFFFF, 0xFFFF000000000000,
                    0x7FFFFFFFFFFF0000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFF, 0xFFFEFFC000000000,
                    0x3FFFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x6FEF000000000000, 0x1, 0x700000000, 0xF000200000,
                ],
                };

                pub const KAWI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    2, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC7FFFFFFFFFDFFFF, 0x7FFFFFF,
                ],
                };

                pub const KAYAH_LI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xBFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const KHAROSHTHI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x873FFFFFFEEFF06F, 0x1FF01FF,
                ],
                };

                pub const KHITAN_SMALL_SCRIPT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2,
                    2, 2, 2, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1000000000, 0xFFFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                ],
                };

                pub const KHMER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FF03FF3FFFFFFF, 0xFFFFFFFF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const KHOJKI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFBFFFF, 0x3,
                ],
                };

                pub const KHUDAWADI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x3FF07FFFFFFFFFF,
                ],
                };

                pub const KIRAT_RAI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFFFFFFFFFFFFF,
                ],
                };

                pub const LAO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3FFFFFAFFFFFF7D6, 0xF3FF7F5F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LATIN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x400040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x1FFFFFFFFFFFFFF, 0x1F00000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 5, 6, 0,
                    7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 4, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFF03FFFFFFFFF, 0xFEFFF83C1FFFFFFF, 0x7FFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x8002000000000000, 0x1FFF0000, 0x40C0000000000,
                    0xFFFFFFFF00004000, 0x1FF, 0xFFFFFFFF00000000, 0xFFFFFFFC00000000,
                    0xFFFFFFFFFFFFF8FF, 0xFFFC00001FEB3FFF, 0xFFFF000000000000, 0x3DFF7FFFFFF,
                    0x7F, 0x7FFFFFE00000000, 0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FDFFFFFFFFFFBF, 0x7E07FFFFFFF,
                ],
                };

                pub const LEPCHA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF8FFFFFFFFFFFFFF, 0xE3FF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LIMBU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFF0FFF7FFFFFFF, 0xFFF1,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LINEAR_A: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    1, 1, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                ],
                };

                pub const LINEAR_B: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                ],
                };

                pub const LISU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFF0000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0,
                ],
                tree3_level3: &[
                    0, 0x1000000000000,
                ],
                };

                pub const LYCIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFFFF,
                ],
                };

                pub const LYDIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x83FFFFFF00000000,
                ],
                };

                pub const MAHAJANI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFFFF0000,
                ],
                };

                pub const MAKASAR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFFF00000000,
                ],
                };

                pub const MALAYALAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFDDFFF, 0xFFFFFFCFFFF0FDDF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const MANDAIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x4FFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const MANICHAEAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FF87FFFFFFFFF,
                ],
                };

                pub const MARCHEN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x7FFEFFFFFCFFFF,
                ],
                };

                pub const MASARAM_GONDI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xB47FFFFFFFFFFB7F, 0x3FF00FF,
                ],
                };

                pub const MEDEFAIDRIN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFF,
                ],
                };

                pub const MEETEI_MAYEK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FFFFF00000000, 0x3FF3FFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const MENDE_KIKAKUI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x7FFF9F,
                ],
                };

                pub const MEROITIC_CURSIVE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF0FFFFFF00000000, 0xFFFFFFFFFFFCFFFF,
                ],
                };

                pub const MEROITIC_HIEROGLYPHS: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF,
                ],
                };

                pub const MIAO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    2, 3, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF87FF, 0xFFFF80FF,
                ],
                };

                pub const MODI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FF001F,
                ],
                };

                pub const MONGOLIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF03FFFFD3, 0x1FFFFFFFFFFFFFF, 0x7FFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFF00000000,
                ],
                };

                pub const MRO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC3FF7FFFFFFF,
                ],
                };

                pub const MULTANI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFBFFFBD7F,
                ],
                };

                pub const MYANMAR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF00000000, 0xFFFFFFFF00000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFF0000,
                ],
                };

                pub const NABATAEAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF807FFFFFFF,
                ],
                };

                pub const NAG_MUNDARI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFFFFFFFFF0000,
                ],
                };

                pub const NANDINAGARI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFCFF00000000, 0x1FFCFFFFFF,
                ],
                };

                pub const NEW_TAI_LUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF0FFFFFFFFFFF, 0xC7FF03FF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const NEWA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3EFFFFFFF,
                ],
                };

                pub const NKO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0xE7FFFFFFFFFFFFFF,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const NUSHU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x200000000, 0xFFFF000000000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFF,
                ],
                };

                pub const NYIAKENG_PUACHUE_HMONG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFF1FFFFFFFFFFF, 0xC3FF,
                ],
                };

                pub const OGHAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1FFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OL_CHIKI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFF0000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OL_ONAL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x87FFFFFFFFFF0000,
                ],
                };

                pub const OLD_HUNGARIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFFFFFFF, 0xFC07FFFFFFFFFFFF,
                ],
                };

                pub const OLD_ITALIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xE00FFFFFFFFF,
                ],
                };

                pub const OLD_NORTH_ARABIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF,
                ],
                };

                pub const OLD_PERMIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFFFFF0000,
                ],
                };

                pub const OLD_PERSIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000, 0x3FFF0F,
                ],
                };

                pub const OLD_SOGDIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF,
                ],
                };

                pub const OLD_SOUTH_ARABIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000,
                ],
                };

                pub const OLD_TURKIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x1FF,
                ],
                };

                pub const OLD_UYGHUR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x3FF,
                ],
                };

                pub const ORIYA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3EDFDFFFFF99FEE, 0xFFFFCFB0E0399F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OSAGE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0xFFFFFFFFF0FFFFF,
                ],
                };

                pub const OSMANYA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF3FFFFFFF,
                ],
                };

                pub const PAHAWH_HMONG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xE0FFFFFBFBFF003F, 0xFFFF,
                ],
                };

                pub const PALMYRENE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000,
                ],
                };

                pub const PAU_CIN_HAU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFFFFFFFFFFF,
                ],
                };

                pub const PHAGS_PA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const PHOENICIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x8FFFFFFF,
                ],
                };

                pub const PSALTER_PAHLAVI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFE001E03FFFF,
                ],
                };

                pub const REJANG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF000000000000, 0x800FFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const RUNIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x1FFC7FFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SAMARITAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                ],
                tree2_level2: &[
                    0x7FFF3FFFFFFFFFFF, 0,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SAURASHTRA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FFC03F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SHARADA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF,
                ],
                };

                pub const SHAVIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFF0000,
                ],
                };

                pub const SIDDHAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF3FFFFFFFFFFFFF, 0x3FFFFFFF,
                ],
                };

                pub const SIGNWRITING: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFEF8000FFF,
                ],
                };

                pub const SINHALA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2FFBFFFFFC7FFFEE, 0x1CFFC0FF5F847F,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFE00000000,
                ],
                };

                pub const SOGDIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x3FFFFFF,
                ],
                };

                pub const SORA_SOMPENG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF01FFFFFF0000,
                ],
                };

                pub const SOYOMBO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFF0000, 0x7FFFFFFFF,
                ],
                };

                pub const SUNDANESE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SUNUWAR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF0003FFFFFFFF,
                ],
                };

                pub const SYLOTI_NAGRI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1FFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SYRIAC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0xFFFFFFFFFFFFBFFF, 0xE7FF, 0, 0,
                ],
                tree2_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAGALOG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x803FFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAGBANWA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xDDFFF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAI_LE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1F3FFFFFFF0000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAI_THAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x9FFFFFFF7FFFFFFF, 0x3FFF03FF03FF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAI_VIET: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xF8000007,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAKRI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFFFFFFFFFFFFF, 0x3FF,
                ],
                };

                pub const TAMIL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC3FFC718D63DC7EC, 0x7FFFFC000813DC7,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1,
                ],
                tree3_level3: &[
                    0, 0x8003FFFFFFFFFFFF,
                ],
                };

                pub const TANGSA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x7FFFFFFFFFFFFFFF, 0x3FF,
                ],
                };

                pub const TANGUT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x100000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF, 0x1FF,
                ],
                };

                pub const TELUGU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3FFFDFFFFFDDFFF, 0xFF80FFCF27603DDF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const THAANA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0x3FFFFFFFFFFFF, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const THAI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FFFFFFFFFFFFFE, 0xFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TIBETAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFE1FFFFFFFFEFF, 0xDFFFFFFFFEFFFFFF, 0x61FDFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TIFINAGH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF000000000000, 0x800180FFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TIRHUTA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FF00FF,
                ],
                };

                pub const TODHRI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFF,
                ],
                };

                pub const TOTO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFF0000,
                ],
                };

                pub const TULU_TIGALARI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFBFFFFFFFFF4BFF, 0x601BFF7A5,
                ],
                };

                pub const UGARITIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xBFFFFFFF,
                ],
                };

                pub const VAI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const VITHKUQI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF7FF000000000000, 0x1BFBFFFBFFB7F7FF,
                ],
                };

                pub const WANCHO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x83FFFFFFFFFFFFFF,
                ],
                };

                pub const WARANG_CITI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000, 0x8007FFFFFFFFFFFF,
                ],
                };

                pub const YEZIDI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x33BFFFFFFFFFF,
                ],
                };

                pub const YI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF1FFF, 0x7F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const ZANABAZAR_SQUARE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFF,
                ],
                };
            }
            // Copy from script::BY_NAME
            static SCRIPT_PROPERTY_NAMES = [
                ("Adlam", ADLAM),
                ("Ahom", AHOM),
                ("Anatolian_Hieroglyphs", ANATOLIAN_HIEROGLYPHS),
                ("Arabic", ARABIC),
                ("Armenian", ARMENIAN),
                ("Avestan", AVESTAN),
                ("Balinese", BALINESE),
                ("Bamum", BAMUM),
                ("Bassa_Vah", BASSA_VAH),
                ("Batak", BATAK),
                ("Bengali", BENGALI),
                ("Bhaiksuki", BHAIKSUKI),
                ("Bopomofo", BOPOMOFO),
                ("Brahmi", BRAHMI),
                ("Braille", BRAILLE),
                ("Buginese", BUGINESE),
                ("Buhid", BUHID),
                ("Canadian_Aboriginal", CANADIAN_ABORIGINAL),
                ("Carian", CARIAN),
                ("Caucasian_Albanian", CAUCASIAN_ALBANIAN),
                ("Chakma", CHAKMA),
                ("Cham", CHAM),
                ("Cherokee", CHEROKEE),
                ("Chorasmian", CHORASMIAN),
                ("Common", COMMON),
                ("Coptic", COPTIC),
                ("Cuneiform", CUNEIFORM),
                ("Cypriot", CYPRIOT),
                ("Cypro_Minoan", CYPRO_MINOAN),
                ("Cyrillic", CYRILLIC),
                ("Deseret", DESERET),
                ("Devanagari", DEVANAGARI),
                ("Dives_Akuru", DIVES_AKURU),
                ("Dogra", DOGRA),
                ("Duployan", DUPLOYAN),
                ("Egyptian_Hieroglyphs", EGYPTIAN_HIEROGLYPHS),
                ("Elbasan", ELBASAN),
                ("Elymaic", ELYMAIC),
                ("Ethiopic", ETHIOPIC),
                ("Georgian", GEORGIAN),
                ("Glagolitic", GLAGOLITIC),
                ("Gothic", GOTHIC),
                ("Grantha", GRANTHA),
                ("Greek", GREEK),
                ("Gujarati", GUJARATI),
                ("Gunjala_Gondi", GUNJALA_GONDI),
                ("Gurmukhi", GURMUKHI),
                ("Han", HAN),
                ("Hangul", HANGUL),
                ("Hanifi_Rohingya", HANIFI_ROHINGYA),
                ("Hanunoo", HANUNOO),
                ("Hatran", HATRAN),
                ("Hebrew", HEBREW),
                ("Hiragana", HIRAGANA),
                ("Imperial_Aramaic", IMPERIAL_ARAMAIC),
                ("Inherited", INHERITED),
                ("Inscriptional_Pahlavi", INSCRIPTIONAL_PAHLAVI),
                ("Inscriptional_Parthian", INSCRIPTIONAL_PARTHIAN),
                ("Javanese", JAVANESE),
                ("Kaithi", KAITHI),
                ("Kannada", KANNADA),
                ("Katakana", KATAKANA),
                ("Kawi", KAWI),
                ("Kayah_Li", KAYAH_LI),
                ("Kharoshthi", KHAROSHTHI),
                ("Khitan_Small_Script", KHITAN_SMALL_SCRIPT),
                ("Khmer", KHMER),
                ("Khojki", KHOJKI),
                ("Khudawadi", KHUDAWADI),
                ("Lao", LAO),
                ("Latin", LATIN),
                ("Lepcha", LEPCHA),
                ("Limbu", LIMBU),
                ("Linear_A", LINEAR_A),
                ("Linear_B", LINEAR_B),
                ("Lisu", LISU),
                ("Lycian", LYCIAN),
                ("Lydian", LYDIAN),
                ("Mahajani", MAHAJANI),
                ("Makasar", MAKASAR),
                ("Malayalam", MALAYALAM),
                ("Mandaic", MANDAIC),
                ("Manichaean", MANICHAEAN),
                ("Marchen", MARCHEN),
                ("Masaram_Gondi", MASARAM_GONDI),
                ("Medefaidrin", MEDEFAIDRIN),
                ("Meetei_Mayek", MEETEI_MAYEK),
                ("Mende_Kikakui", MENDE_KIKAKUI),
                ("Meroitic_Cursive", MEROITIC_CURSIVE),
                ("Meroitic_Hieroglyphs", MEROITIC_HIEROGLYPHS),
                ("Miao", MIAO),
                ("Modi", MODI),
                ("Mongolian", MONGOLIAN),
                ("Mro", MRO),
                ("Multani", MULTANI),
                ("Myanmar", MYANMAR),
                ("Nabataean", NABATAEAN),
                ("Nag_Mundari", NAG_MUNDARI),
                ("Nandinagari", NANDINAGARI),
                ("New_Tai_Lue", NEW_TAI_LUE),
                ("Newa", NEWA),
                ("Nko", NKO),
                ("Nushu", NUSHU),
                ("Nyiakeng_Puachue_Hmong", NYIAKENG_PUACHUE_HMONG),
                ("Ogham", OGHAM),
                ("Ol_Chiki", OL_CHIKI),
                ("Old_Hungarian", OLD_HUNGARIAN),
                ("Old_Italic", OLD_ITALIC),
                ("Old_North_Arabian", OLD_NORTH_ARABIAN),
                ("Old_Permic", OLD_PERMIC),
                ("Old_Persian", OLD_PERSIAN),
                ("Old_Sogdian", OLD_SOGDIAN),
                ("Old_South_Arabian", OLD_SOUTH_ARABIAN),
                ("Old_Turkic", OLD_TURKIC),
                ("Old_Uyghur", OLD_UYGHUR),
                ("Oriya", ORIYA),
                ("Osage", OSAGE),
                ("Osmanya", OSMANYA),
                ("Pahawh_Hmong", PAHAWH_HMONG),
                ("Palmyrene", PALMYRENE),
                ("Pau_Cin_Hau", PAU_CIN_HAU),
                ("Phags_Pa", PHAGS_PA),
                ("Phoenician", PHOENICIAN),
                ("Psalter_Pahlavi", PSALTER_PAHLAVI),
                ("Rejang", REJANG),
                ("Runic", RUNIC),
                ("Samaritan", SAMARITAN),
                ("Saurashtra", SAURASHTRA),
                ("Sharada", SHARADA),
                ("Shavian", SHAVIAN),
                ("Siddham", SIDDHAM),
                ("SignWriting", SIGNWRITING),
                ("Sinhala", SINHALA),
                ("Sogdian", SOGDIAN),
                ("Sora_Sompeng", SORA_SOMPENG),
                ("Soyombo", SOYOMBO),
                ("Sundanese", SUNDANESE),
                ("Syloti_Nagri", SYLOTI_NAGRI),
                ("Syriac", SYRIAC),
                ("Tagalog", TAGALOG),
                ("Tagbanwa", TAGBANWA),
                ("Tai_Le", TAI_LE),
                ("Tai_Tham", TAI_THAM),
                ("Tai_Viet", TAI_VIET),
                ("Takri", TAKRI),
                ("Tamil", TAMIL),
                ("Tangsa", TANGSA),
                ("Tangut", TANGUT),
                ("Telugu", TELUGU),
                ("Thaana", THAANA),
                ("Thai", THAI),
                ("Tibetan", TIBETAN),
                ("Tifinagh", TIFINAGH),
                ("Tirhuta", TIRHUTA),
                ("Toto", TOTO),
                ("Ugaritic", UGARITIC),
                ("Vai", VAI),
                ("Vithkuqi", VITHKUQI),
                ("Wancho", WANCHO),
                ("Warang_Citi", WARANG_CITI),
                ("Yezidi", YEZIDI),
                ("Yi", YI),
                ("Zanabazar_Square", ZANABAZAR_SQUARE),
            ];
        }
        /// Return all available unicode property names
        pub fn unicode_property_names() -> Box<dyn Iterator<Item = &'static str>>
        {
            Box::new(
                BINARY_PROPERTY_NAMES
                    .iter()
                    .map(|name| *name)
                    .chain(CATEGORY_PROPERTY_NAMES.iter().map(|name| *name))
                    .chain(SCRIPT_PROPERTY_NAMES.iter().map(|name| *name)),
            )
        }

        pub fn by_name(name: &str) -> Option<Box<dyn Fn(char) -> bool>>
        {
            for property in binary::BY_NAME {
                if name == property.0.to_uppercase() {
                    return Some(Box::new(move |c| property.1.contains_char(c)));
                }
            }

            for property in category::BY_NAME {
                if name == property.0.to_uppercase() {
                    return Some(Box::new(move |c| property.1.contains_char(c)));
                }
            }

            for property in script::BY_NAME {
                if name == property.0.to_uppercase() {
                    return Some(Box::new(move |c| property.1.contains_char(c)));
                }
            }

            None
        }
    }
    /// A trait which parser rules must implement.
    pub trait RuleType: Copy + Debug + Eq + Hash + Ord {}

    impl<T: Copy + Debug + Eq + Hash + Ord> RuleType for T {}
}

pub mod process
{
    pub use std::process::{*};
    pub fn getpid() -> i32 { unsafe { libc::getpid() } }
}

pub mod prompt
{
    use ::
    {
        *,
    };

    pub mod main
    {
        use ::
        {
            *
        };

        use std::env;

        use crate::execute;
        use crate::libs;
        use crate::shell;

        const DEFAULT_PROMPT: &str = "${COLOR_STATUS}$USER${RESET}\
            @${COLOR_STATUS}$HOSTNAME${RESET}: \
            ${COLOR_STATUS}$CWD${RESET}$ ";
        use super::preset::apply_preset_item;
        use super::preset::apply_pyenv;

        fn is_prefix_char(c: char) -> bool {
            c == '[' || c == '{'
        }

        fn is_suffix_char(c: char) -> bool {
            c == ']' || c == '}'
        }

        fn is_prompt_item_char(c: char, token: &str) -> bool {
            let s = c.to_string();
            if token.is_empty() {
                libs::re::re_contains(&s, r#"^[a-zA-Z_]$"#)
            } else {
                libs::re::re_contains(&s, r#"^[a-zA-Z0-9_]$"#)
            }
        }

        pub fn get_prompt_string() -> String {
            if let Ok(x) = env::var("PROMPT") {
                return x;
            }
            DEFAULT_PROMPT.to_string()
        }

        fn apply_prompt_item(sh: &shell::Shell, result: &mut String, token: &str) {
            if let Some(x) = sh.get_env(token) {
                result.push_str(&x);
                return;
            }
            apply_preset_item(sh, result, token);
        }

        fn apply_command(result: &mut String, token: &str, prefix: &str, suffix: &str) {
            let cr = execute::run(token);
            let output = cr.stdout.trim();
            if !output.is_empty() {
                result.push_str(prefix);
                result.push_str(output);
                result.push_str(suffix);
            }
        }

        pub fn render_prompt(sh: &shell::Shell, ps: &str) -> String {
            let mut prompt = String::new();
            apply_pyenv(&mut prompt);

            let mut met_dollar = false;
            let mut met_brace = false;
            let mut met_paren = false;
            let mut token = String::new();
            let mut prefix = String::new();
            let mut suffix = String::new();
            for c in ps.chars() {
                if met_dollar {
                    if c == '(' && !met_brace && !met_paren {
                        met_paren = true;
                        continue;
                    }
                    if c == ')' && met_paren {
                        apply_command(&mut prompt, &token, &prefix, &suffix);
                        token.clear();
                        prefix.clear();
                        suffix.clear();
                        met_dollar = false;
                        met_paren = false;
                        continue;
                    }
                    if c == '{' && !met_brace && !met_paren {
                        met_brace = true;
                        continue;
                    } else if c == '}' && met_brace {
                        apply_prompt_item(sh, &mut prompt, &token);
                        token.clear();
                        met_dollar = false;
                        met_brace = false;
                        continue;
                    } else if c == '$' {
                        if token.is_empty() {
                            // to make single $ as a plain $
                            prompt.push('$');
                            met_dollar = true;
                            continue;
                        } else {
                            apply_prompt_item(sh, &mut prompt, &token);
                            token.clear();
                            // met_dollar is still true
                            continue;
                        }
                    } else if met_paren {
                        if is_prefix_char(c) {
                            prefix.push(c);
                        } else if is_suffix_char(c) {
                            suffix.push(c);
                        } else {
                            token.push(c);
                        }
                        continue;
                    } else if is_prompt_item_char(c, &token) {
                        token.push(c);
                        continue;
                    } else if token.is_empty() {
                        prompt.push('$');
                        prompt.push(c);
                        met_dollar = false;
                        continue;
                    }
                }

                if c == '$' {
                    met_dollar = true;
                    continue;
                }

                if !token.is_empty() {
                    apply_prompt_item(sh, &mut prompt, &token);
                    token.clear();
                }
                prompt.push(c);
                met_dollar = false;
            }

            if !token.is_empty() {
                apply_prompt_item(sh, &mut prompt, &token);
                met_dollar = false;
            }

            if met_dollar {
                // for cases like PROMPT='$$'
                prompt.push('$');
            }

            if prompt.trim().is_empty() { return format!(":: >>"); }
            prompt
        }
    }

    pub mod preset
    {
        use ::
        {
            *
        };

        use std::env;
        use std::fs::File;
        use std::io::{Read, Write};
        use std::path::Path;

        use crate::libs;
        use crate::shell;
        use crate::tools;

        fn apply_seq(prompt: &mut String) {
            prompt.push_str(libs::colored::SEQ);
        }

        fn apply_end_seq(prompt: &mut String) {
            prompt.push_str(libs::colored::END_SEQ);
        }

        fn apply_esc(prompt: &mut String) {
            prompt.push_str(libs::colored::ESC);
        }

        fn apply_underlined(prompt: &mut String) {
            prompt.push_str(libs::colored::UNDERLINED);
        }

        fn apply_user(prompt: &mut String) {
            let username = tools::get_user_name();
            prompt.push_str(&username);
        }

        fn apply_black(prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK);
        }

        fn apply_black_b(prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_B);
        }

        fn apply_black_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_BG);
        }

        fn apply_blue(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE);
        }

        fn apply_blue_b(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_B);
        }

        fn apply_blue_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_BG);
        }

        fn apply_bold(prompt: &mut String) {
            prompt.push_str(libs::colored::BOLD);
        }

        fn apply_green(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN);
        }

        fn apply_green_b(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_B);
        }

        fn apply_green_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_BG);
        }

        fn apply_red(prompt: &mut String) {
            prompt.push_str(libs::colored::RED);
        }

        fn apply_red_b(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_B);
        }

        fn apply_red_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_BG);
        }

        fn apply_white(prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE);
        }

        fn apply_white_b(prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_B);
        }

        fn apply_white_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_BG);
        }

        fn apply_hidden(prompt: &mut String) {
            prompt.push_str(libs::colored::HIDDEN);
        }

        fn apply_reset(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET);
        }

        fn apply_reverse(prompt: &mut String) {
            prompt.push_str(libs::colored::REVERSE);
        }

        fn apply_dim(prompt: &mut String) {
            prompt.push_str(libs::colored::DIM);
        }

        fn apply_blink(prompt: &mut String) {
            prompt.push_str(libs::colored::BLINK);
        }

        fn apply_reset_underlined(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_UNDERLINED);
        }

        fn apply_reset_dim(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_DIM);
        }

        fn apply_reset_reverse(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_REVERSE);
        }

        fn apply_reset_hidden(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_HIDDEN);
        }

        fn apply_reset_blink(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BLINK);
        }

        fn apply_reset_bold(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BOLD);
        }

        fn apply_default(prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULT);
        }

        fn apply_default_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULT_BG);
        }

        fn apply_cyan(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN);
        }

        fn apply_cyan_l(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L);
        }

        fn apply_cyan_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_BG);
        }

        fn apply_cyan_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L_BG);
        }

        fn apply_red_l(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L);
        }

        fn apply_red_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L_BG);
        }

        fn apply_green_l(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L);
        }

        fn apply_green_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L_BG);
        }

        fn apply_gray_l(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L);
        }

        fn apply_gray_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L_BG);
        }

        fn apply_gray_d(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D);
        }

        fn apply_gray_d_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D_BG);
        }

        fn apply_magenta(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA);
        }

        fn apply_magenta_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_BG);
        }

        fn apply_magenta_l(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L);
        }

        fn apply_magenta_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L_BG);
        }

        fn apply_yellow(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW);
        }

        fn apply_yellow_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_BG);
        }

        fn apply_yellow_l(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L);
        }

        fn apply_yellow_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L_BG);
        }

        fn apply_blue_l(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L);
        }

        fn apply_blue_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L_BG);
        }

        fn apply_color_status(sh: &shell::Shell, prompt: &mut String) {
            if sh.previous_status == 0 {
                prompt.push_str(libs::colored::GREEN_B);
            } else {
                prompt.push_str(libs::colored::RED_B);
            }
        }

        fn _find_git_root() -> String {
            let current_dir = libs::path::current_dir();
            let dir_git = format!("{}/.git", current_dir);
            if Path::new(&dir_git).exists() {
                return current_dir;
            }

            let mut _dir = current_dir.clone();
            while Path::new(&_dir).parent().is_some() {
                match Path::new(&_dir).parent() {
                    Some(p) => {
                        _dir = p.to_string_lossy().to_string();
                        let dir_git = format!("{}/.git", _dir);
                        if Path::new(&dir_git).exists() {
                            return _dir;
                        }
                    }
                    None => {
                        break;
                    }
                }
            }

            String::new()
        }

        fn apply_gitbr(prompt: &mut String) {
            let git_root = _find_git_root();
            if git_root.is_empty() {
                return;
            }

            let file_head = format!("{}/.git/HEAD", git_root);
            if !Path::new(&file_head).exists() {
                return;
            }

            let mut file;
            match File::open(&file_head) {
                Ok(x) => file = x,
                Err(e) => {
                    println!(":: .git/HEAD err: {:?}", e);
                    return;
                }
            }
            let mut text = String::new();
            match file.read_to_string(&mut text) {
                Ok(_) => {}
                Err(e) => {
                    println!(":: read_to_string error: {:?}", e);
                    return;
                }
            }

            if let Some(branch) = libs::re::find_first_group(r"^[a-z]+: ?[a-z]+/[a-z]+/(.+)$", text.trim())
            {
                apply_blue_b(prompt);
                if let Ok(x) = env::var("CICADA_GITBR_PREFIX") {
                    prompt.push_str(&x);
                }

                let _len_default: i32 = 32;
                let mut len_max = if let Ok(x) = env::var("CICADA_GITBR_MAX_LEN") {
                    match x.parse::<i32>() {
                        Ok(n) => n,
                        Err(_) => _len_default,
                    }
                } else {
                    _len_default
                };
                if len_max <= 0 {
                    len_max = _len_default;
                }

                if branch.len() as i32 <= len_max {
                    prompt.push_str(&branch);
                } else {
                    let len = branch.len() as i32;
                    let offset = (len - len_max + 2) as usize;
                    let branch_short = format!("..{}", &branch[offset..]);
                    prompt.push_str(&branch_short);
                }
                if let Ok(x) = env::var("CICADA_GITBR_SUFFIX") {
                    prompt.push_str(&x);
                }
                apply_reset(prompt);
            }
        }

        fn apply_cwd(prompt: &mut String) {
            let _current_dir = match env::current_dir() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!(":: PROMPT: env current_dir error: {}", e);
                    return;
                }
            };
            let current_dir = match _current_dir.to_str() {
                Some(x) => x,
                None => {
                    println_stderr!(":: PROMPT: to_str error");
                    return;
                }
            };
            let _tokens: Vec<&str> = current_dir.split('/').collect();

            let last = match _tokens.last() {
                Some(x) => x,
                None => {
                    log!(":: PROMPT: token last error");
                    return;
                }
            };

            let home = tools::get_user_home();
            let pwd = if last.is_empty() {
                "/"
            } else if current_dir == home {
                "~"
            } else {
                last
            };
            prompt.push_str(pwd);
        }

        fn apply_hostname(prompt: &mut String) {
            let hostname = tools::get_hostname();
            prompt.push_str(&hostname);
        }

        fn apply_newline(prompt: &mut String) {
            prompt.push('\n');
        }

        pub fn apply_pyenv(prompt: &mut String) {
            if let Ok(x) = env::var("VIRTUAL_ENV") {
                if !x.is_empty() {
                    let _tokens: Vec<&str> = x.split('/').collect();
                    let env_name = match _tokens.last() {
                        Some(x) => x,
                        None => {
                            log!("prompt token last error");
                            return;
                        }
                    };

                    apply_blue_b(prompt);
                    prompt.push('(');
                    prompt.push_str(env_name);
                    prompt.push(')');
                    apply_reset(prompt);
                }
            }
        }

        pub fn apply_preset_item(sh: &shell::Shell, prompt: &mut String, token: &str) {
            match token.to_ascii_lowercase().as_ref() {
                "black" => apply_black(prompt),
                "black_b" => apply_black_b(prompt),
                "black_bg" => apply_black_bg(prompt),
                "blink" => apply_blink(prompt),
                "blue" => apply_blue(prompt),
                "blue_b" => apply_blue_b(prompt),
                "blue_bg" => apply_blue_bg(prompt),
                "blue_l" => apply_blue_l(prompt),
                "blue_l_bg" => apply_blue_l_bg(prompt),
                "bold" => apply_bold(prompt),
                "color_status" => apply_color_status(sh, prompt),
                "cwd" => apply_cwd(prompt),
                "cyan" => apply_cyan(prompt),
                "cyan_bg" => apply_cyan_bg(prompt),
                "cyan_l" => apply_cyan_l(prompt),
                "cyan_l_bg" => apply_cyan_l_bg(prompt),
                "default" => apply_default(prompt),
                "default_bg" => apply_default_bg(prompt),
                "dim" => apply_dim(prompt),
                "end_seq" => apply_end_seq(prompt),
                "esc" => apply_esc(prompt),
                "gitbr" => apply_gitbr(prompt),
                "gray_d" => apply_gray_d(prompt),
                "gray_d_bg" => apply_gray_d_bg(prompt),
                "gray_l" => apply_gray_l(prompt),
                "gray_l_bg" => apply_gray_l_bg(prompt),
                "green" => apply_green(prompt),
                "green_b" => apply_green_b(prompt),
                "green_bg" => apply_green_bg(prompt),
                "green_l" => apply_green_l(prompt),
                "green_l_bg" => apply_green_l_bg(prompt),
                "hidden" => apply_hidden(prompt),
                "hostname" => apply_hostname(prompt),
                "magenta" => apply_magenta(prompt),
                "magenta_bg" => apply_magenta_bg(prompt),
                "magenta_l" => apply_magenta_l(prompt),
                "magenta_l_bg" => apply_magenta_l_bg(prompt),
                "newline" => apply_newline(prompt),
                "red" => apply_red(prompt),
                "red_b" => apply_red_b(prompt),
                "red_bg" => apply_red_bg(prompt),
                "red_l" => apply_red_l(prompt),
                "red_l_bg" => apply_red_l_bg(prompt),
                "reset" => apply_reset(prompt),
                "reset_blink" => apply_reset_blink(prompt),
                "reset_bold" => apply_reset_bold(prompt),
                "reset_dim" => apply_reset_dim(prompt),
                "reset_hidden" => apply_reset_hidden(prompt),
                "reset_reverse" => apply_reset_reverse(prompt),
                "reset_underlined" => apply_reset_underlined(prompt),
                "reverse" => apply_reverse(prompt),
                "seq" => apply_seq(prompt),
                "underlined" => apply_underlined(prompt),
                "user" => apply_user(prompt),
                "white" => apply_white(prompt),
                "white_b" => apply_white_b(prompt),
                "white_bg" => apply_white_bg(prompt),
                "yellow" => apply_yellow(prompt),
                "yellow_bg" => apply_yellow_bg(prompt),
                "yellow_l" => apply_yellow_l(prompt),
                "yellow_l_bg" => apply_yellow_l_bg(prompt),
                _ => (),
            }
        }
    }

    pub mod multilines
    {
        use ::
        {
            *
        };

        use std::io;
        use lineread::{Function, Prompter, Terminal};

        use crate::parsers::parser_line;

        pub struct EnterFunction;

        impl<T: Terminal> Function<T> for EnterFunction {
            fn execute(&self, prompter: &mut Prompter<T>, count: i32, _ch: char) -> io::Result<()> {
                let buf = prompter.buffer();
                let linfo = parser_line::parse_line(buf);
                if linfo.is_complete {
                    prompter.accept_input()
                } else if count > 0 {
                    match prompter.insert(count as usize, '\n') {
                        Ok(_) => {},
                        Err(e) => {
                            println!("sub-prompt error: {}", e);
                        }
                    }
                    prompter.insert_str(">> ")
                } else {
                    Ok(())
                }
            }
        }
    }

    use crate::libs;
    use crate::shell;

    use self::main::get_prompt_string;
    use self::main::render_prompt;
    pub use self::multilines::EnterFunction;

    fn get_prompt_len(prompt: &str) -> i32 {
        let mut count = 0;
        let mut met_x01 = false;
        for c in prompt.chars() {
            if c == '\x01' {
                met_x01 = true;
                continue;
            } else if c == '\x02' {
                met_x01 = false;
                continue;
            }
            if !met_x01 {
                count += 1;
            }
        }
        count
    }

    pub fn get_prompt(sh: &shell::Shell) -> String {
        let ps = get_prompt_string();
        let mut prompt = render_prompt(sh, &ps);
        if let Some((w, _h)) = libs::term_size::dimensions() {
            if get_prompt_len(&prompt) > (w / 2) as i32
                && !libs::re::re_contains(&ps, r#"(?i)\$\{?newline.\}?"#)
            {
                prompt.push_str("\n$ ");
            }
        } else {
            log!("ERROR: Failed to get term size");
        }
        prompt
    }
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod rcfile
{
    use ::
    {
        *,
    };
    use std::path::Path;

    use crate::scripting;
    use crate::shell;
    use crate::tools;

    pub fn get_rc_file() -> String {
        let dir_config = tools::get_config_dir();
        let rc_file = format!("{}/cicadarc", dir_config);
        if Path::new(&rc_file).exists() {
            return rc_file;
        }

        // fail back to $HOME/.cicadarc
        let home = tools::get_user_home();
        let rc_file_home = format!("{}/{}", home, ".cicadarc");
        if Path::new(&rc_file_home).exists() {
            return rc_file_home;
        }

        // use std path if both absent
        rc_file
    }

    pub fn load_rc_files(sh: &mut shell::Shell) {
        let rc_file = get_rc_file();
        if !Path::new(&rc_file).exists() {
            return;
        }

        let args = vec!["source".to_string(), rc_file];
        scripting::run_script(sh, &args);
    }
}

pub mod rusqlite
{
    //! Rusqlite is an ergonomic wrapper for using SQLite from Rust.
    use ::
    {
        *,
    };
    /*
    pub use libsqlite3_sys as ffi;
    use std::cell::RefCell;
    use std::default::Default;
    use std::ffi::{CStr, CString};
    use std::fmt;
    use std::os::raw::{c_char, c_int};
    use std::path::Path;
    use std::result;
    use std::str;
    use std::sync::{Arc, Mutex};
    use crate::cache::StatementCache;
    use crate::inner_connection::InnerConnection;
    use crate::raw_statement::RawStatement;
    use crate::types::ValueRef;
    pub use crate::cache::CachedStatement;
    #[cfg(feature = "column_decltype")]
    pub use crate::column::Column;
    pub use crate::error::{to_sqlite_error, Error};
    pub use crate::ffi::ErrorCode;
    #[cfg(feature = "load_extension")]
    pub use crate::load_extension_guard::LoadExtensionGuard;
    pub use crate::params::{params_from_iter, Params, ParamsFromIter};
    pub use crate::row::{AndThenRows, Map, MappedRows, Row, RowIndex, Rows};
    pub use crate::statement::{Statement, StatementStatus};
    #[cfg(feature = "modern_sqlite")]
    pub use crate::transaction::TransactionState;
    pub use crate::transaction::{DropBehavior, Savepoint, Transaction, TransactionBehavior};
    pub use crate::types::ToSql;
    pub use crate::version::*;
    #[cfg(feature = "rusqlite-macros")]
    #[doc(hidden)]
    pub use rusqlite_macros::__bind;
    */
    mod error
    {
        use ::
        {
            *,
        };
        use crate::types::FromSqlError;
        use crate::types::Type;
        use crate::{errmsg_to_string, ffi, Result};
        use std::error;
        use std::fmt;
        use std::os::raw::c_int;
        use std::path::PathBuf;
        use std::str;

        /// Enum listing possible errors from rusqlite.
        #[derive(Debug)]
        #[allow(clippy::enum_variant_names)]
        #[non_exhaustive]
        pub enum Error {
            /// An error from an underlying SQLite call.
            SqliteFailure(ffi::Error, Option<String>),

            /// Error reported when attempting to open a connection when SQLite was
            /// configured to allow single-threaded use only.
            SqliteSingleThreadedMode,

            /// Error when the value of a particular column is requested, but it cannot
            /// be converted to the requested Rust type.
            FromSqlConversionFailure(usize, Type, Box<dyn error::Error + Send + Sync + 'static>),

            /// Error when SQLite gives us an integral value outside the range of the
            /// requested type (e.g., trying to get the value 1000 into a `u8`).
            /// The associated `usize` is the column index,
            /// and the associated `i64` is the value returned by SQLite.
            IntegralValueOutOfRange(usize, i64),

            /// Error converting a string to UTF-8.
            Utf8Error(str::Utf8Error),

            /// Error converting a string to a C-compatible string because it contained
            /// an embedded nul.
            NulError(std::ffi::NulError),

            /// Error when using SQL named parameters and passing a parameter name not
            /// present in the SQL.
            InvalidParameterName(String),

            /// Error converting a file path to a string.
            InvalidPath(PathBuf),

            /// Error returned when an [`execute`](crate::Connection::execute) call
            /// returns rows.
            ExecuteReturnedResults,

            /// Error when a query that was expected to return at least one row (e.g.,
            /// for [`query_row`](crate::Connection::query_row)) did not return any.
            QueryReturnedNoRows,

            /// Error when the value of a particular column is requested, but the index
            /// is out of range for the statement.
            InvalidColumnIndex(usize),

            /// Error when the value of a named column is requested, but no column
            /// matches the name for the statement.
            InvalidColumnName(String),

            /// Error when the value of a particular column is requested, but the type
            /// of the result in that column cannot be converted to the requested
            /// Rust type.
            InvalidColumnType(usize, String, Type),

            /// Error when a query that was expected to insert one row did not insert
            /// any or insert many.
            StatementChangedRows(usize),

            /// Error returned by
            /// [`functions::Context::get`](crate::functions::Context::get) when the
            /// function argument cannot be converted to the requested type.
            #[cfg(feature = "functions")]
            #[cfg_attr(docsrs, doc(cfg(feature = "functions")))]
            InvalidFunctionParameterType(usize, Type),
            /// Error returned by [`vtab::Values::get`](crate::vtab::Values::get) when
            /// the filter argument cannot be converted to the requested type.
            #[cfg(feature = "vtab")]
            #[cfg_attr(docsrs, doc(cfg(feature = "vtab")))]
            InvalidFilterParameterType(usize, Type),

            /// An error case available for implementors of custom user functions (e.g.,
            /// [`create_scalar_function`](crate::Connection::create_scalar_function)).
            #[cfg(feature = "functions")]
            #[cfg_attr(docsrs, doc(cfg(feature = "functions")))]
            
            UserFunctionError(Box<dyn error::Error + Send + Sync + 'static>),

            /// Error available for the implementors of the
            /// [`ToSql`](crate::types::ToSql) trait.
            ToSqlConversionFailure(Box<dyn error::Error + Send + Sync + 'static>),

            /// Error when the SQL is not a `SELECT`, is not read-only.
            InvalidQuery,

            /// An error case available for implementors of custom modules (e.g.,
            /// [`create_module`](crate::Connection::create_module)).
            #[cfg(feature = "vtab")]
            #[cfg_attr(docsrs, doc(cfg(feature = "vtab")))]
            
            ModuleError(String),

            /// An unwinding panic occurs in a UDF (user-defined function).
            UnwindingPanic,

            /// An error returned when
            /// [`Context::get_aux`](crate::functions::Context::get_aux) attempts to
            /// retrieve data of a different type than what had been stored using
            /// [`Context::set_aux`](crate::functions::Context::set_aux).
            #[cfg(feature = "functions")]
            #[cfg_attr(docsrs, doc(cfg(feature = "functions")))]
            GetAuxWrongType,

            /// Error when the SQL contains multiple statements.
            MultipleStatement,
            /// Error when the number of bound parameters does not match the number of
            /// parameters in the query. The first `usize` is how many parameters were
            /// given, the 2nd is how many were expected.
            InvalidParameterCount(usize, usize),

            /// Returned from various functions in the Blob IO positional API. For
            /// example,
            /// [`Blob::raw_read_at_exact`](crate::blob::Blob::raw_read_at_exact) will
            /// return it if the blob has insufficient data.
            #[cfg(feature = "blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "blob")))]
            BlobSizeError,
            /// Error referencing a specific token in the input SQL
            #[cfg(feature = "modern_sqlite")] // 3.38.0
            #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
            SqlInputError {
                /// error code
                error: ffi::Error,
                /// error message
                msg: String,
                /// SQL input
                sql: String,
                /// byte offset of the start of invalid token
                offset: c_int,
            },
            /// Loadable extension initialization error
            #[cfg(feature = "loadable_extension")]
            #[cfg_attr(docsrs, doc(cfg(feature = "loadable_extension")))]
            InitError(ffi::InitError),
            /// Error when the schema of a particular database is requested, but the index
            /// is out of range.
            #[cfg(feature = "modern_sqlite")] // 3.39.0
            #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
            InvalidDatabaseIndex(usize),
        }

        impl PartialEq for Error {
            fn eq(&self, other: &Error) -> bool {
                match (self, other) {
                    (Error::SqliteFailure(e1, s1), Error::SqliteFailure(e2, s2)) => e1 == e2 && s1 == s2,
                    (Error::SqliteSingleThreadedMode, Error::SqliteSingleThreadedMode) => true,
                    (Error::IntegralValueOutOfRange(i1, n1), Error::IntegralValueOutOfRange(i2, n2)) => {
                        i1 == i2 && n1 == n2
                    }
                    (Error::Utf8Error(e1), Error::Utf8Error(e2)) => e1 == e2,
                    (Error::NulError(e1), Error::NulError(e2)) => e1 == e2,
                    (Error::InvalidParameterName(n1), Error::InvalidParameterName(n2)) => n1 == n2,
                    (Error::InvalidPath(p1), Error::InvalidPath(p2)) => p1 == p2,
                    (Error::ExecuteReturnedResults, Error::ExecuteReturnedResults) => true,
                    (Error::QueryReturnedNoRows, Error::QueryReturnedNoRows) => true,
                    (Error::InvalidColumnIndex(i1), Error::InvalidColumnIndex(i2)) => i1 == i2,
                    (Error::InvalidColumnName(n1), Error::InvalidColumnName(n2)) => n1 == n2,
                    (Error::InvalidColumnType(i1, n1, t1), Error::InvalidColumnType(i2, n2, t2)) => {
                        i1 == i2 && t1 == t2 && n1 == n2
                    }
                    (Error::StatementChangedRows(n1), Error::StatementChangedRows(n2)) => n1 == n2,
                    #[cfg(feature = "functions")]
                    (
                        Error::InvalidFunctionParameterType(i1, t1),
                        Error::InvalidFunctionParameterType(i2, t2),
                    ) => i1 == i2 && t1 == t2,
                    #[cfg(feature = "vtab")]
                    (
                        Error::InvalidFilterParameterType(i1, t1),
                        Error::InvalidFilterParameterType(i2, t2),
                    ) => i1 == i2 && t1 == t2,
                    (Error::InvalidQuery, Error::InvalidQuery) => true,
                    #[cfg(feature = "vtab")]
                    (Error::ModuleError(s1), Error::ModuleError(s2)) => s1 == s2,
                    (Error::UnwindingPanic, Error::UnwindingPanic) => true,
                    #[cfg(feature = "functions")]
                    (Error::GetAuxWrongType, Error::GetAuxWrongType) => true,
                    (Error::InvalidParameterCount(i1, n1), Error::InvalidParameterCount(i2, n2)) => {
                        i1 == i2 && n1 == n2
                    }
                    #[cfg(feature = "blob")]
                    (Error::BlobSizeError, Error::BlobSizeError) => true,
                    #[cfg(feature = "modern_sqlite")]
                    (
                        Error::SqlInputError {
                            error: e1,
                            msg: m1,
                            sql: s1,
                            offset: o1,
                        },
                        Error::SqlInputError {
                            error: e2,
                            msg: m2,
                            sql: s2,
                            offset: o2,
                        },
                    ) => e1 == e2 && m1 == m2 && s1 == s2 && o1 == o2,
                    #[cfg(feature = "loadable_extension")]
                    (Error::InitError(e1), Error::InitError(e2)) => e1 == e2,
                    #[cfg(feature = "modern_sqlite")]
                    (Error::InvalidDatabaseIndex(i1), Error::InvalidDatabaseIndex(i2)) => i1 == i2,
                    (..) => false,
                }
            }
        }

        impl From<str::Utf8Error> for Error {
            #[cold]
            fn from(err: str::Utf8Error) -> Error {
                Error::Utf8Error(err)
            }
        }

        impl From<std::ffi::NulError> for Error {
            #[cold]
            fn from(err: std::ffi::NulError) -> Error {
                Error::NulError(err)
            }
        }

        const UNKNOWN_COLUMN: usize = usize::MAX;

        /// The conversion isn't precise, but it's convenient to have it
        /// to allow use of `get_raw(…).as_…()?` in callbacks that take `Error`.
        impl From<FromSqlError> for Error {
            #[cold]
            fn from(err: FromSqlError) -> Error {
                // The error type requires index and type fields, but they aren't known in this
                // context.
                match err {
                    FromSqlError::OutOfRange(val) => Error::IntegralValueOutOfRange(UNKNOWN_COLUMN, val),
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Blob, Box::new(err))
                    }
                    FromSqlError::Other(source) => {
                        Error::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, source)
                    }
                    _ => Error::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, Box::new(err)),
                }
            }
        }

        #[cfg(feature = "loadable_extension")]
        impl From<ffi::InitError> for Error {
            #[cold]
            fn from(err: ffi::InitError) -> Error {
                Error::InitError(err)
            }
        }

        impl fmt::Display for Error {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match *self {
                    Error::SqliteFailure(ref err, None) => err.fmt(f),
                    Error::SqliteFailure(_, Some(ref s)) => write!(f, "{s}"),
                    Error::SqliteSingleThreadedMode => write!(
                        f,
                        "SQLite was compiled or configured for single-threaded use only"
                    ),
                    Error::FromSqlConversionFailure(i, ref t, ref err) => {
                        if i != UNKNOWN_COLUMN {
                            write!(f, "Conversion error from type {t} at index: {i}, {err}")
                        } else {
                            err.fmt(f)
                        }
                    }
                    Error::IntegralValueOutOfRange(col, val) => {
                        if col != UNKNOWN_COLUMN {
                            write!(f, "Integer {val} out of range at index {col}")
                        } else {
                            write!(f, "Integer {val} out of range")
                        }
                    }
                    Error::Utf8Error(ref err) => err.fmt(f),
                    Error::NulError(ref err) => err.fmt(f),
                    Error::InvalidParameterName(ref name) => write!(f, "Invalid parameter name: {name}"),
                    Error::InvalidPath(ref p) => write!(f, "Invalid path: {}", p.to_string_lossy()),
                    Error::ExecuteReturnedResults => {
                        write!(f, "Execute returned results - did you mean to call query?")
                    }
                    Error::QueryReturnedNoRows => write!(f, "Query returned no rows"),
                    Error::InvalidColumnIndex(i) => write!(f, "Invalid column index: {i}"),
                    Error::InvalidColumnName(ref name) => write!(f, "Invalid column name: {name}"),
                    Error::InvalidColumnType(i, ref name, ref t) => {
                        write!(f, "Invalid column type {t} at index: {i}, name: {name}")
                    }
                    Error::InvalidParameterCount(i1, n1) => write!(
                        f,
                        "Wrong number of parameters passed to query. Got {i1}, needed {n1}"
                    ),
                    Error::StatementChangedRows(i) => write!(f, "Query changed {i} rows"),

                    #[cfg(feature = "functions")]
                    Error::InvalidFunctionParameterType(i, ref t) => {
                        write!(f, "Invalid function parameter type {t} at index {i}")
                    }
                    #[cfg(feature = "vtab")]
                    Error::InvalidFilterParameterType(i, ref t) => {
                        write!(f, "Invalid filter parameter type {t} at index {i}")
                    }
                    #[cfg(feature = "functions")]
                    Error::UserFunctionError(ref err) => err.fmt(f),
                    Error::ToSqlConversionFailure(ref err) => err.fmt(f),
                    Error::InvalidQuery => write!(f, "Query is not read-only"),
                    #[cfg(feature = "vtab")]
                    Error::ModuleError(ref desc) => write!(f, "{desc}"),
                    Error::UnwindingPanic => write!(f, "unwinding panic"),
                    #[cfg(feature = "functions")]
                    Error::GetAuxWrongType => write!(f, "get_aux called with wrong type"),
                    Error::MultipleStatement => write!(f, "Multiple statements provided"),
                    #[cfg(feature = "blob")]
                    Error::BlobSizeError => "Blob size is insufficient".fmt(f),
                    #[cfg(feature = "modern_sqlite")]
                    Error::SqlInputError {
                        ref msg,
                        offset,
                        ref sql,
                        ..
                    } => write!(f, "{msg} in {sql} at offset {offset}"),
                    #[cfg(feature = "loadable_extension")]
                    Error::InitError(ref err) => err.fmt(f),
                    #[cfg(feature = "modern_sqlite")]
                    Error::InvalidDatabaseIndex(i) => write!(f, "Invalid database index: {i}"),
                }
            }
        }

        impl error::Error for Error {
            fn source(&self) -> Option<&(dyn error::Error + 'static)> {
                match *self {
                    Error::SqliteFailure(ref err, _) => Some(err),
                    Error::Utf8Error(ref err) => Some(err),
                    Error::NulError(ref err) => Some(err),

                    Error::IntegralValueOutOfRange(..)
                    | Error::SqliteSingleThreadedMode
                    | Error::InvalidParameterName(_)
                    | Error::ExecuteReturnedResults
                    | Error::QueryReturnedNoRows
                    | Error::InvalidColumnIndex(_)
                    | Error::InvalidColumnName(_)
                    | Error::InvalidColumnType(..)
                    | Error::InvalidPath(_)
                    | Error::InvalidParameterCount(..)
                    | Error::StatementChangedRows(_)
                    | Error::InvalidQuery
                    | Error::MultipleStatement => None,

                    #[cfg(feature = "functions")]
                    Error::InvalidFunctionParameterType(..) => None,
                    #[cfg(feature = "vtab")]
                    Error::InvalidFilterParameterType(..) => None,

                    #[cfg(feature = "functions")]
                    Error::UserFunctionError(ref err) => Some(&**err),

                    Error::FromSqlConversionFailure(_, _, ref err)
                    | Error::ToSqlConversionFailure(ref err) => Some(&**err),

                    #[cfg(feature = "vtab")]
                    Error::ModuleError(_) => None,

                    Error::UnwindingPanic => None,

                    #[cfg(feature = "functions")]
                    Error::GetAuxWrongType => None,

                    #[cfg(feature = "blob")]
                    Error::BlobSizeError => None,
                    #[cfg(feature = "modern_sqlite")]
                    Error::SqlInputError { ref error, .. } => Some(error),
                    #[cfg(feature = "loadable_extension")]
                    Error::InitError(ref err) => Some(err),
                    #[cfg(feature = "modern_sqlite")]
                    Error::InvalidDatabaseIndex(_) => None,
                }
            }
        }

        impl Error {
            /// Returns the underlying SQLite error if this is [`Error::SqliteFailure`].
            #[inline]
            #[must_use]
            pub fn sqlite_error(&self) -> Option<&ffi::Error> {
                match self {
                    Self::SqliteFailure(error, _) => Some(error),
                    _ => None,
                }
            }
            /// Returns the underlying SQLite error code if this is
            /// [`Error::SqliteFailure`].
            #[inline]
            #[must_use]
            pub fn sqlite_error_code(&self) -> Option<ffi::ErrorCode> {
                self.sqlite_error().map(|error| error.code)
            }
        }

        // These are public but not re-exported by lib.rs, so only visible within crate.

        #[cold]
        pub fn error_from_sqlite_code(code: c_int, message: Option<String>) -> Error {
            Error::SqliteFailure(ffi::Error::new(code), message)
        }

        #[cold]
        pub unsafe fn error_from_handle(db: *mut ffi::sqlite3, code: c_int) -> Error {
            let message = if db.is_null() {
                None
            } else {
                Some(errmsg_to_string(ffi::sqlite3_errmsg(db)))
            };
            error_from_sqlite_code(code, message)
        }

        #[cold]
        #[cfg(not(feature = "modern_sqlite"))] // SQLite >= 3.38.0
        pub unsafe fn error_with_offset(db: *mut ffi::sqlite3, code: c_int, _sql: &str) -> Error {
            error_from_handle(db, code)
        }

        #[cold]
        #[cfg(feature = "modern_sqlite")] // SQLite >= 3.38.0
        pub unsafe fn error_with_offset(db: *mut ffi::sqlite3, code: c_int, sql: &str) -> Error {
            if db.is_null() {
                error_from_sqlite_code(code, None)
            } else {
                let error = ffi::Error::new(code);
                let msg = errmsg_to_string(ffi::sqlite3_errmsg(db));
                if ffi::ErrorCode::Unknown == error.code {
                    let offset = ffi::sqlite3_error_offset(db);
                    if offset >= 0 {
                        return Error::SqlInputError {
                            error,
                            msg,
                            sql: sql.to_owned(),
                            offset,
                        };
                    }
                }
                Error::SqliteFailure(error, Some(msg))
            }
        }

        pub fn check(code: c_int) -> Result<()> {
            if code != crate::ffi::SQLITE_OK {
                Err(error_from_sqlite_code(code, None))
            } else {
                Ok(())
            }
        }
        /// Transform Rust error to SQLite error (message and code).
        /// # Safety
        /// This function is unsafe because it uses raw pointer
        pub unsafe fn to_sqlite_error(e: &Error, err_msg: *mut *mut std::os::raw::c_char) -> c_int {
            use crate::util::alloc;
            match e {
                Error::SqliteFailure(err, s) => {
                    if let Some(s) = s {
                        *err_msg = alloc(s);
                    }
                    err.extended_code
                }
                err => {
                    *err_msg = alloc(&err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }
    }
    
    pub mod auto_extension
    {
        //! Automatic extension loading
        use ::
        {
            *,
        };
        
        use super::ffi;
        use crate::error::{check, to_sqlite_error};
        use crate::{Connection, Error, Result};
        use std::os::raw::{c_char, c_int};
        use std::panic::catch_unwind;

        /// Automatic extension initialization routine
        pub type AutoExtension = fn(Connection) -> Result<()>;

        /// Raw automatic extension initialization routine
        pub type RawAutoExtension = unsafe extern "C" fn(
            db: *mut ffi::sqlite3,
            pz_err_msg: *mut *mut c_char,
            _: *const ffi::sqlite3_api_routines,
        ) -> c_int;

        /// Bridge between `RawAutoExtension` and `AutoExtension`
        ///
        /// # Safety
        /// * Opening a database from an auto-extension handler will lead to
        ///   an endless recursion of the auto-handler triggering itself
        ///   indirectly for each newly-opened database.
        /// * Results are undefined if the given db is closed by an auto-extension.
        /// * The list of auto-extensions should not be manipulated from an auto-extension.
        pub unsafe fn init_auto_extension(
            db: *mut ffi::sqlite3,
            pz_err_msg: *mut *mut c_char,
            ax: AutoExtension,
        ) -> c_int {
            let r = catch_unwind(|| {
                let c = Connection::from_handle(db);
                c.and_then(ax)
            })
            .unwrap_or_else(|_| Err(Error::UnwindingPanic));
            match r {
                Err(e) => to_sqlite_error(&e, pz_err_msg),
                _ => ffi::SQLITE_OK,
            }
        }
        /// Register au auto-extension
        ///
        /// # Safety
        /// * Opening a database from an auto-extension handler will lead to
        ///   an endless recursion of the auto-handler triggering itself
        ///   indirectly for each newly-opened database.
        /// * Results are undefined if the given db is closed by an auto-extension.
        /// * The list of auto-extensions should not be manipulated from an auto-extension.
        pub unsafe fn register_auto_extension(ax: RawAutoExtension) -> Result<()> {
            check(ffi::sqlite3_auto_extension(Some(ax)))
        }
        /// Unregister the initialization routine
        pub fn cancel_auto_extension(ax: RawAutoExtension) -> bool {
            unsafe { ffi::sqlite3_cancel_auto_extension(Some(ax)) == 1 }
        }
        /// Disable all automatic extensions previously registered
        pub fn reset_auto_extension() {
            unsafe { ffi::sqlite3_reset_auto_extension() }
        }
    }
    
    pub mod backup
    {
        //! Online SQLite backup API.
        use ::
        {
            *,
        };
        
        use std::marker::PhantomData;
        use std::path::Path;
        use std::ptr;

        use std::os::raw::c_int;
        use std::thread;
        use std::time::Duration;

        use crate::ffi;

        use crate::error::error_from_handle;
        use crate::{Connection, DatabaseName, Result};

        impl Connection {
            /// Back up the `name` database to the given
            /// destination path.
            ///
            /// If `progress` is not `None`, it will be called periodically
            /// until the backup completes.
            ///
            /// For more fine-grained control over the backup process (e.g.,
            /// to sleep periodically during the backup or to back up to an
            /// already-open database connection), see the `backup` module.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the destination path cannot be opened
            /// or if the backup fails.
            pub fn backup<P: AsRef<Path>>(
                &self,
                name: DatabaseName<'_>,
                dst_path: P,
                progress: Option<fn(Progress)>,
            ) -> Result<()> {
                use self::StepResult::{Busy, Done, Locked, More};
                let mut dst = Connection::open(dst_path)?;
                let backup = Backup::new_with_names(self, name, &mut dst, DatabaseName::Main)?;

                let mut r = More;
                while r == More {
                    r = backup.step(100)?;
                    if let Some(f) = progress {
                        f(backup.progress());
                    }
                }

                match r {
                    Done => Ok(()),
                    Busy => Err(unsafe { error_from_handle(ptr::null_mut(), ffi::SQLITE_BUSY) }),
                    Locked => Err(unsafe { error_from_handle(ptr::null_mut(), ffi::SQLITE_LOCKED) }),
                    More => unreachable!(),
                }
            }
            /// Restore the given source path into the
            /// `name` database. If `progress` is not `None`, it will be
            /// called periodically until the restore completes.
            ///
            /// For more fine-grained control over the restore process (e.g.,
            /// to sleep periodically during the restore or to restore from an
            /// already-open database connection), see the `backup` module.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the destination path cannot be opened
            /// or if the restore fails.
            pub fn restore<P: AsRef<Path>, F: Fn(Progress)>(
                &mut self,
                name: DatabaseName<'_>,
                src_path: P,
                progress: Option<F>,
            ) -> Result<()> {
                use self::StepResult::{Busy, Done, Locked, More};
                let src = Connection::open(src_path)?;
                let restore = Backup::new_with_names(&src, DatabaseName::Main, self, name)?;

                let mut r = More;
                let mut busy_count = 0_i32;
                'restore_loop: while r == More || r == Busy {
                    r = restore.step(100)?;
                    if let Some(ref f) = progress {
                        f(restore.progress());
                    }
                    if r == Busy {
                        busy_count += 1;
                        if busy_count >= 3 {
                            break 'restore_loop;
                        }
                        thread::sleep(Duration::from_millis(100));
                    }
                }

                match r {
                    Done => Ok(()),
                    Busy => Err(unsafe { error_from_handle(ptr::null_mut(), ffi::SQLITE_BUSY) }),
                    Locked => Err(unsafe { error_from_handle(ptr::null_mut(), ffi::SQLITE_LOCKED) }),
                    More => unreachable!(),
                }
            }
        }
        /// Possible successful results of calling
        /// [`Backup::step`].
        #[derive(Copy, Clone, Debug, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum StepResult {
            /// The backup is complete.
            Done,

            /// The step was successful but there are still more pages that need to be
            /// backed up.
            More,

            /// The step failed because appropriate locks could not be acquired. This is
            /// not a fatal error - the step can be retried.
            Busy,

            /// The step failed because the source connection was writing to the
            /// database. This is not a fatal error - the step can be retried.
            Locked,
        }
        /// Struct specifying the progress of a backup. The
        /// percentage completion can be calculated as `(pagecount - remaining) /
        /// pagecount`. The progress of a backup is as of the last call to
        /// [`step`](Backup::step) - if the source database is modified after a call to
        /// [`step`](Backup::step), the progress value will become outdated and
        /// potentially incorrect.
        #[derive(Copy, Clone, Debug)]
        pub struct Progress {
            /// Number of pages in the source database that still need to be backed up.
            pub remaining: c_int,
            /// Total number of pages in the source database.
            pub pagecount: c_int,
        }
        /// A handle to an online backup.
        pub struct Backup<'a, 'b> {
            phantom_from: PhantomData<&'a Connection>,
            to: &'b Connection,
            b: *mut ffi::sqlite3_backup,
        }

        impl Backup<'_, '_> {
            /// Attempt to create a new handle that will allow backups from `from` to
            /// `to`. Note that `to` is a `&mut` - this is because SQLite forbids any
            /// API calls on the destination of a backup while the backup is taking
            /// place.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying `sqlite3_backup_init` call returns
            /// `NULL`.
            #[inline]
            pub fn new<'a, 'b>(from: &'a Connection, to: &'b mut Connection) -> Result<Backup<'a, 'b>> {
                Backup::new_with_names(from, DatabaseName::Main, to, DatabaseName::Main)
            }
            /// Attempt to create a new handle that will allow backups from the
            /// `from_name` database of `from` to the `to_name` database of `to`. Note
            /// that `to` is a `&mut` - this is because SQLite forbids any API calls on
            /// the destination of a backup while the backup is taking place.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying `sqlite3_backup_init` call returns
            /// `NULL`.
            pub fn new_with_names<'a, 'b>(
                from: &'a Connection,
                from_name: DatabaseName<'_>,
                to: &'b mut Connection,
                to_name: DatabaseName<'_>,
            ) -> Result<Backup<'a, 'b>> {
                let to_name = to_name.as_cstring()?;
                let from_name = from_name.as_cstring()?;

                let to_db = to.db.borrow_mut().db;

                let b = unsafe {
                    let b = ffi::sqlite3_backup_init(
                        to_db,
                        to_name.as_ptr(),
                        from.db.borrow_mut().db,
                        from_name.as_ptr(),
                    );
                    if b.is_null() {
                        return Err(error_from_handle(to_db, ffi::sqlite3_errcode(to_db)));
                    }
                    b
                };

                Ok(Backup {
                    phantom_from: PhantomData,
                    to,
                    b,
                })
            }
            /// Gets the progress of the backup as of the last call to
            /// [`step`](Backup::step).
            #[inline]
            #[must_use]
            pub fn progress(&self) -> Progress {
                unsafe {
                    Progress {
                        remaining: ffi::sqlite3_backup_remaining(self.b),
                        pagecount: ffi::sqlite3_backup_pagecount(self.b),
                    }
                }
            }
            /// Attempts to back up the given number of pages. If `num_pages` is
            /// negative, will attempt to back up all remaining pages. This will hold a
            /// lock on the source database for the duration, so it is probably not
            /// what you want for databases that are currently active (see
            /// [`run_to_completion`](Backup::run_to_completion) for a better
            /// alternative).
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying `sqlite3_backup_step` call returns
            /// an error code other than `DONE`, `OK`, `BUSY`, or `LOCKED`. `BUSY` and
            /// `LOCKED` are transient errors and are therefore returned as possible
            /// `Ok` values.
            #[inline]
            pub fn step(&self, num_pages: c_int) -> Result<StepResult> {
                use self::StepResult::{Busy, Done, Locked, More};

                let rc = unsafe { ffi::sqlite3_backup_step(self.b, num_pages) };
                match rc {
                    ffi::SQLITE_DONE => Ok(Done),
                    ffi::SQLITE_OK => Ok(More),
                    ffi::SQLITE_BUSY => Ok(Busy),
                    ffi::SQLITE_LOCKED => Ok(Locked),
                    _ => self.to.decode_result(rc).map(|_| More),
                }
            }
            /// Attempts to run the entire backup. Will call
            /// [`step(pages_per_step)`](Backup::step) as many times as necessary,
            /// sleeping for `pause_between_pages` between each call to give the
            /// source database time to process any pending queries. This is a
            /// direct implementation of "Example 2: Online Backup of a Running
            /// Database" from [SQLite's Online Backup API documentation](https://www.sqlite.org/backup.html).
            ///
            /// If `progress` is not `None`, it will be called after each step with the
            /// current progress of the backup. Note that is possible the progress may
            /// not change if the step returns `Busy` or `Locked` even though the
            /// backup is still running.
            ///
            /// # Failure
            ///
            /// Will return `Err` if any of the calls to [`step`](Backup::step) return
            /// `Err`.
            pub fn run_to_completion(
                &self,
                pages_per_step: c_int,
                pause_between_pages: Duration,
                progress: Option<fn(Progress)>,
            ) -> Result<()> {
                use self::StepResult::{Busy, Done, Locked, More};

                assert!(pages_per_step > 0, "pages_per_step must be positive");

                loop {
                    let r = self.step(pages_per_step)?;
                    if let Some(progress) = progress {
                        progress(self.progress());
                    }
                    match r {
                        More | Busy | Locked => thread::sleep(pause_between_pages),
                        Done => return Ok(()),
                    }
                }
            }
        }

        impl Drop for Backup<'_, '_> {
            #[inline]
            fn drop(&mut self) {
                unsafe { ffi::sqlite3_backup_finish(self.b) };
            }
        }
    }
    
    pub mod blob
    {
        //! Incremental BLOB I/O.
        use ::
        {
            *,
        };
        
        use std::cmp::min;
        use std::io;
        use std::ptr;

        use super::ffi;
        use super::types::{ToSql, ToSqlOutput};
        use crate::{Connection, DatabaseName, Result};

        mod pos_io
        {
            use ::
            {
                *,
            };
            use super::Blob;

            use std::mem::MaybeUninit;
            use std::slice::from_raw_parts_mut;

            use crate::ffi;
            use crate::{Error, Result};

            impl<'conn> Blob<'conn> {
                /// Write `buf` to `self` starting at `write_start`, returning an error if
                /// `write_start + buf.len()` is past the end of the blob.
                ///
                /// If an error is returned, no data is written.
                ///
                /// Note: the blob cannot be resized using this function -- that must be
                /// done using SQL (for example, an `UPDATE` statement).
                ///
                /// Note: This is part of the positional I/O API, and thus takes an absolute
                /// position write to, instead of using the internal position that can be
                /// manipulated by the `std::io` traits.
                ///
                /// Unlike the similarly named [`FileExt::write_at`][fext_write_at] function
                /// (from `std::os::unix`), it's always an error to perform a "short write".
                ///
                /// [fext_write_at]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#tymethod.write_at
                #[inline]
                pub fn write_at(&mut self, buf: &[u8], write_start: usize) -> Result<()> {
                    let len = self.len();

                    if buf.len().saturating_add(write_start) > len {
                        return Err(Error::BlobSizeError);
                    }
                    // We know `len` fits in an `i32`, so either:
                    //
                    // 1. `buf.len() + write_start` overflows, in which case we'd hit the
                    //    return above (courtesy of `saturating_add`).
                    //
                    // 2. `buf.len() + write_start` doesn't overflow but is larger than len,
                    //    in which case ditto.
                    //
                    // 3. `buf.len() + write_start` doesn't overflow but is less than len.
                    //    This means that both `buf.len()` and `write_start` can also be
                    //    losslessly converted to i32, since `len` came from an i32.
                    // Sanity check the above.
                    debug_assert!(i32::try_from(write_start).is_ok() && i32::try_from(buf.len()).is_ok());
                    self.conn.decode_result(unsafe {
                        ffi::sqlite3_blob_write(
                            self.blob,
                            buf.as_ptr().cast(),
                            buf.len() as i32,
                            write_start as i32,
                        )
                    })
                }
                /// An alias for `write_at` provided for compatibility with the conceptually
                /// equivalent [`std::os::unix::FileExt::write_all_at`][write_all_at]
                /// function from libstd:
                ///
                /// [write_all_at]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at
                #[inline]
                pub fn write_all_at(&mut self, buf: &[u8], write_start: usize) -> Result<()> {
                    self.write_at(buf, write_start)
                }
                /// Read as much as possible from `offset` to `offset + buf.len()` out of
                /// `self`, writing into `buf`. On success, returns the number of bytes
                /// written.
                ///
                /// If there's insufficient data in `self`, then the returned value will be
                /// less than `buf.len()`.
                ///
                /// See also [`Blob::raw_read_at`], which can take an uninitialized buffer,
                /// or [`Blob::read_at_exact`] which returns an error if the entire `buf` is
                /// not read.
                ///
                /// Note: This is part of the positional I/O API, and thus takes an absolute
                /// position to read from, instead of using the internal position that can
                /// be manipulated by the `std::io` traits. Consequently, it does not change
                /// that value either.
                #[inline]
                pub fn read_at(&self, buf: &mut [u8], read_start: usize) -> Result<usize> {
                    // Safety: this is safe because `raw_read_at` never stores uninitialized
                    // data into `as_uninit`.
                    let as_uninit: &mut [MaybeUninit<u8>] =
                        unsafe { from_raw_parts_mut(buf.as_mut_ptr().cast(), buf.len()) };
                    self.raw_read_at(as_uninit, read_start).map(|s| s.len())
                }
                /// Read as much as possible from `offset` to `offset + buf.len()` out of
                /// `self`, writing into `buf`. On success, returns the portion of `buf`
                /// which was initialized by this call.
                ///
                /// If there's insufficient data in `self`, then the returned value will be
                /// shorter than `buf`.
                ///
                /// See also [`Blob::read_at`], which takes a `&mut [u8]` buffer instead of
                /// a slice of `MaybeUninit<u8>`.
                ///
                /// Note: This is part of the positional I/O API, and thus takes an absolute
                /// position to read from, instead of using the internal position that can
                /// be manipulated by the `std::io` traits. Consequently, it does not change
                /// that value either.
                #[inline]
                pub fn raw_read_at<'a>(
                    &self,
                    buf: &'a mut [MaybeUninit<u8>],
                    read_start: usize,
                ) -> Result<&'a mut [u8]> {
                    let len = self.len();

                    let read_len = match len.checked_sub(read_start) {
                        None | Some(0) => 0,
                        Some(v) => v.min(buf.len()),
                    };

                    if read_len == 0 {
                        // We could return `Ok(&mut [])`, but it seems confusing that the
                        // pointers don't match, so fabricate an empty slice of u8 with the
                        // same base pointer as `buf`.
                        let empty = unsafe { from_raw_parts_mut(buf.as_mut_ptr().cast::<u8>(), 0) };
                        return Ok(empty);
                    }

                    // At this point we believe `read_start as i32` is lossless because:
                    //
                    // 1. `len as i32` is known to be lossless, since it comes from a SQLite
                    //    api returning an i32.
                    //
                    // 2. If we got here, `len.checked_sub(read_start)` was Some (or else
                    //    we'd have hit the `if read_len == 0` early return), so `len` must
                    //    be larger than `read_start`, and so it must fit in i32 as well.
                    debug_assert!(i32::try_from(read_start).is_ok());

                    // We also believe that `read_start + read_len <= len` because:
                    //
                    // 1. This is equivalent to `read_len <= len - read_start` via algebra.
                    // 2. We know that `read_len` is `min(len - read_start, buf.len())`
                    // 3. Expanding, this is `min(len - read_start, buf.len()) <= len - read_start`,
                    //    or `min(A, B) <= A` which is clearly true.
                    //
                    // Note that this stuff is in debug_assert so no need to use checked_add
                    // and such -- we'll always panic on overflow in debug builds.
                    debug_assert!(read_start + read_len <= len);

                    // These follow naturally.
                    debug_assert!(buf.len() >= read_len);
                    debug_assert!(i32::try_from(buf.len()).is_ok());
                    debug_assert!(i32::try_from(read_len).is_ok());

                    unsafe {
                        self.conn.decode_result(ffi::sqlite3_blob_read(
                            self.blob,
                            buf.as_mut_ptr().cast(),
                            read_len as i32,
                            read_start as i32,
                        ))?;

                        Ok(from_raw_parts_mut(buf.as_mut_ptr().cast::<u8>(), read_len))
                    }
                }
                /// Equivalent to [`Blob::read_at`], but returns a `BlobSizeError` if `buf`
                /// is not fully initialized.
                #[inline]
                pub fn read_at_exact(&self, buf: &mut [u8], read_start: usize) -> Result<()> {
                    let n = self.read_at(buf, read_start)?;
                    if n != buf.len() {
                        Err(Error::BlobSizeError)
                    } else {
                        Ok(())
                    }
                }
                /// Equivalent to [`Blob::raw_read_at`], but returns a `BlobSizeError` if
                /// `buf` is not fully initialized.
                #[inline]
                pub fn raw_read_at_exact<'a>(
                    &self,
                    buf: &'a mut [MaybeUninit<u8>],
                    read_start: usize,
                ) -> Result<&'a mut [u8]> {
                    let buflen = buf.len();
                    let initted = self.raw_read_at(buf, read_start)?;
                    if initted.len() != buflen {
                        Err(Error::BlobSizeError)
                    } else {
                        Ok(initted)
                    }
                }
            }
        }
        /// Handle to an open BLOB. See
        /// [`rusqlite::blob`](crate::blob) documentation for in-depth discussion.
        pub struct Blob<'conn> {
            conn: &'conn Connection,
            blob: *mut ffi::sqlite3_blob,
            // used by std::io implementations,
            pos: i32,
        }

        impl Connection {
            /// Open a handle to the BLOB located in `row_id`,
            /// `column`, `table` in database `db`.
            ///
            /// # Failure
            ///
            /// Will return `Err` if `db`/`table`/`column` cannot be converted to a
            /// C-compatible string or if the underlying SQLite BLOB open call
            /// fails.
            #[inline]
            pub fn blob_open<'a>(
                &'a self,
                db: DatabaseName<'_>,
                table: &str,
                column: &str,
                row_id: i64,
                read_only: bool,
            ) -> Result<Blob<'a>> {
                let c = self.db.borrow_mut();
                let mut blob = ptr::null_mut();
                let db = db.as_cstring()?;
                let table = super::str_to_cstring(table)?;
                let column = super::str_to_cstring(column)?;
                let rc = unsafe {
                    ffi::sqlite3_blob_open(
                        c.db(),
                        db.as_ptr(),
                        table.as_ptr(),
                        column.as_ptr(),
                        row_id,
                        !read_only as std::os::raw::c_int,
                        &mut blob,
                    )
                };
                c.decode_result(rc).map(|_| Blob {
                    conn: self,
                    blob,
                    pos: 0,
                })
            }
        }

        impl Blob<'_> {
            /// Move a BLOB handle to a new row.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying SQLite BLOB reopen call fails.
            #[inline]
            pub fn reopen(&mut self, row: i64) -> Result<()> {
                let rc = unsafe { ffi::sqlite3_blob_reopen(self.blob, row) };
                if rc != ffi::SQLITE_OK {
                    return self.conn.decode_result(rc);
                }
                self.pos = 0;
                Ok(())
            }
            /// Return the size in bytes of the BLOB.
            #[inline]
            #[must_use]
            pub fn size(&self) -> i32 {
                unsafe { ffi::sqlite3_blob_bytes(self.blob) }
            }
            /// Return the current size in bytes of the BLOB.
            #[inline]
            #[must_use]
            pub fn len(&self) -> usize {
                self.size().try_into().unwrap()
            }
            /// Return true if the BLOB is empty.
            #[inline]
            #[must_use]
            pub fn is_empty(&self) -> bool {
                self.size() == 0
            }
            /// Close a BLOB handle.
            ///
            /// Calling `close` explicitly is not required (the BLOB will be closed
            /// when the `Blob` is dropped), but it is available, so you can get any
            /// errors that occur.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying SQLite close call fails.
            #[inline]
            pub fn close(mut self) -> Result<()> {
                self.close_()
            }

            #[inline]
            fn close_(&mut self) -> Result<()> {
                let rc = unsafe { ffi::sqlite3_blob_close(self.blob) };
                self.blob = ptr::null_mut();
                self.conn.decode_result(rc)
            }
        }

        impl io::Read for Blob<'_> {
            /// Read data from a BLOB incrementally. Will return Ok(0) if the end of
            /// the blob has been reached.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying SQLite read call fails.
            #[inline]
            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
                let max_allowed_len = (self.size() - self.pos) as usize;
                let n = min(buf.len(), max_allowed_len) as i32;
                if n <= 0 {
                    return Ok(0);
                }
                let rc = unsafe { ffi::sqlite3_blob_read(self.blob, buf.as_mut_ptr().cast(), n, self.pos) };
                self.conn
                    .decode_result(rc)
                    .map(|_| {
                        self.pos += n;
                        n as usize
                    })
                    .map_err(|err| io::Error::new(io::ErrorKind::Other, err))
            }
        }

        impl io::Write for Blob<'_> {
            /// Write data into a BLOB incrementally. Will return `Ok(0)` if the end of
            /// the blob has been reached; consider using `Write::write_all(buf)`
            /// if you want to get an error if the entirety of the buffer cannot be
            /// written.
            ///
            /// This function may only modify the contents of the BLOB; it is not
            /// possible to increase the size of a BLOB using this API.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying SQLite write call fails.
            #[inline]
            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
                let max_allowed_len = (self.size() - self.pos) as usize;
                let n = min(buf.len(), max_allowed_len) as i32;
                if n <= 0 {
                    return Ok(0);
                }
                let rc = unsafe { ffi::sqlite3_blob_write(self.blob, buf.as_ptr() as *mut _, n, self.pos) };
                self.conn
                    .decode_result(rc)
                    .map(|_| {
                        self.pos += n;
                        n as usize
                    })
                    .map_err(|err| io::Error::new(io::ErrorKind::Other, err))
            }

            #[inline]
            fn flush(&mut self) -> io::Result<()> {
                Ok(())
            }
        }

        impl io::Seek for Blob<'_> {
            /// Seek to an offset, in bytes, in BLOB.
            #[inline]
            fn seek(&mut self, pos: io::SeekFrom) -> io::Result<u64> {
                let pos = match pos {
                    io::SeekFrom::Start(offset) => offset as i64,
                    io::SeekFrom::Current(offset) => i64::from(self.pos) + offset,
                    io::SeekFrom::End(offset) => i64::from(self.size()) + offset,
                };

                if pos < 0 {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidInput,
                        "invalid seek to negative position",
                    ))
                } else if pos > i64::from(self.size()) {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidInput,
                        "invalid seek to position past end of blob",
                    ))
                } else {
                    self.pos = pos as i32;
                    Ok(pos as u64)
                }
            }
        }

        #[allow(unused_must_use)]
        impl Drop for Blob<'_> {
            #[inline]
            fn drop(&mut self) {
                self.close_();
            }
        }
        /// BLOB of length N that is filled with zeroes.
        ///
        /// Zeroblobs are intended to serve as placeholders for BLOBs whose content is
        /// later written using incremental BLOB I/O routines.
        ///
        /// A negative value for the zeroblob results in a zero-length BLOB.
        #[derive(Copy, Clone)]
        pub struct ZeroBlob(pub i32);

        impl ToSql for ZeroBlob {
            #[inline]
            fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                let ZeroBlob(length) = *self;
                Ok(ToSqlOutput::ZeroBlob(length))
            }
        }
    }

    mod busy
    {
        //! Busy handler (when the database is locked)
        use ::
        {
            *,
        };
        
        use std::mem;
        use std::os::raw::{c_int, c_void};
        use std::panic::catch_unwind;
        use std::ptr;
        use std::time::Duration;

        use crate::ffi;
        use crate::{Connection, InnerConnection, Result};

        impl Connection {
            /// Set a busy handler that sleeps for a specified amount of time when a
            /// table is locked. The handler will sleep multiple times until at
            /// least "ms" milliseconds of sleeping have accumulated.
            ///
            /// Calling this routine with an argument equal to zero turns off all busy
            /// handlers.
            ///
            /// There can only be a single busy handler for a particular database
            /// connection at any given moment. If another busy handler was defined
            /// (using [`busy_handler`](Connection::busy_handler)) prior to calling this
            /// routine, that other busy handler is cleared.
            ///
            /// Newly created connections currently have a default busy timeout of
            /// 5000ms, but this may be subject to change.
            pub fn busy_timeout(&self, timeout: Duration) -> Result<()> {
                let ms: i32 = timeout
                    .as_secs()
                    .checked_mul(1000)
                    .and_then(|t| t.checked_add(timeout.subsec_millis().into()))
                    .and_then(|t| t.try_into().ok())
                    .expect("too big");
                self.db.borrow_mut().busy_timeout(ms)
            }
            /// Register a callback to handle `SQLITE_BUSY` errors.
            ///
            /// If the busy callback is `None`, then `SQLITE_BUSY` is returned
            /// immediately upon encountering the lock. The argument to the busy
            /// handler callback is the number of times that the
            /// busy handler has been invoked previously for the
            /// same locking event. If the busy callback returns `false`, then no
            /// additional attempts are made to access the
            /// database and `SQLITE_BUSY` is returned to the
            /// application. If the callback returns `true`, then another attempt
            /// is made to access the database and the cycle repeats.
            ///
            /// There can only be a single busy handler defined for each database
            /// connection. Setting a new busy handler clears any previously set
            /// handler. Note that calling [`busy_timeout()`](Connection::busy_timeout)
            /// or evaluating `PRAGMA busy_timeout=N` will change the busy handler
            /// and thus clear any previously set busy handler.
            ///
            /// Newly created connections default to a
            /// [`busy_timeout()`](Connection::busy_timeout) handler with a timeout
            /// of 5000ms, although this is subject to change.
            pub fn busy_handler(&self, callback: Option<fn(i32) -> bool>) -> Result<()> {
                unsafe extern "C" fn busy_handler_callback(p_arg: *mut c_void, count: c_int) -> c_int {
                    let handler_fn: fn(i32) -> bool = mem::transmute(p_arg);
                    c_int::from(catch_unwind(|| handler_fn(count)).unwrap_or_default())
                }
                let c = self.db.borrow_mut();
                let r = match callback {
                    Some(f) => unsafe {
                        ffi::sqlite3_busy_handler(c.db(), Some(busy_handler_callback), f as *mut c_void)
                    },
                    None => unsafe { ffi::sqlite3_busy_handler(c.db(), None, ptr::null_mut()) },
                };
                c.decode_result(r)
            }
        }

        impl InnerConnection {
            #[inline]
            fn busy_timeout(&mut self, timeout: c_int) -> Result<()> {
                let r = unsafe { ffi::sqlite3_busy_timeout(self.db, timeout) };
                self.decode_result(r)
            }
        }
    }

    mod cache
    {
        //! Prepared statements cache for faster execution.
        use ::
        {
            *,
        };
        

        use crate::raw_statement::RawStatement;
        use crate::{Connection, PrepFlags, Result, Statement};
        use hashlink::LruCache;
        use std::cell::RefCell;
        use std::ops::{Deref, DerefMut};
        use std::sync::Arc;

        impl Connection {
            /// Prepare a SQL statement for execution, returning a previously prepared
            /// (but not currently in-use) statement if one is available.
            #[inline]
            pub fn prepare_cached(&self, sql: &str) -> Result<CachedStatement<'_>> {
                self.cache.get(self, sql)
            }
            /// Set the maximum number of cached prepared statements this connection
            /// will hold.
            #[inline]
            pub fn set_prepared_statement_cache_capacity(&self, capacity: usize) {
                self.cache.set_capacity(capacity);
            }
            /// Remove/finalize all prepared statements currently in the cache.
            #[inline]
            pub fn flush_prepared_statement_cache(&self) {
                self.cache.flush();
            }
        }
        /// Prepared statements LRU cache.
        #[derive(Debug)]
        pub struct StatementCache(RefCell<LruCache<Arc<str>, RawStatement>>);

        #[allow(clippy::non_send_fields_in_send_ty)]
        unsafe impl Send for StatementCache {}
        /// Cacheable statement.
        ///
        /// Statement will return automatically to the cache by default.
        /// If you want the statement to be discarded, call
        /// [`discard()`](CachedStatement::discard) on it.
        pub struct CachedStatement<'conn> {
            stmt: Option<Statement<'conn>>,
            cache: &'conn StatementCache,
        }

        impl<'conn> Deref for CachedStatement<'conn> {
            type Target = Statement<'conn>;

            #[inline]
            fn deref(&self) -> &Statement<'conn> {
                self.stmt.as_ref().unwrap()
            }
        }

        impl<'conn> DerefMut for CachedStatement<'conn> {
            #[inline]
            fn deref_mut(&mut self) -> &mut Statement<'conn> {
                self.stmt.as_mut().unwrap()
            }
        }

        impl Drop for CachedStatement<'_> {
            #[allow(unused_must_use)]
            #[inline]
            fn drop(&mut self) {
                if let Some(stmt) = self.stmt.take() {
                    self.cache.cache_stmt(unsafe { stmt.into_raw() });
                }
            }
        }

        impl CachedStatement<'_> {
            #[inline]
            fn new<'conn>(stmt: Statement<'conn>, cache: &'conn StatementCache) -> CachedStatement<'conn> {
                CachedStatement {
                    stmt: Some(stmt),
                    cache,
                }
            }
            /// Discard the statement, preventing it from being returned to its
            /// [`Connection`]'s collection of cached statements.
            #[inline]
            pub fn discard(mut self) {
                self.stmt = None;
            }
        }

        impl StatementCache {
            /// Create a statement cache.
            #[inline]
            pub fn with_capacity(capacity: usize) -> StatementCache {
                StatementCache(RefCell::new(LruCache::new(capacity)))
            }

            #[inline]
            fn set_capacity(&self, capacity: usize) {
                self.0.borrow_mut().set_capacity(capacity);
            }
            
            fn get<'conn>(
                &'conn self,
                conn: &'conn Connection,
                sql: &str,
            ) -> Result<CachedStatement<'conn>> {
                let trimmed = sql.trim();
                let mut cache = self.0.borrow_mut();
                let stmt = match cache.remove(trimmed) {
                    Some(raw_stmt) => Ok(Statement::new(conn, raw_stmt)),
                    None => conn.prepare_with_flags(trimmed, PrepFlags::SQLITE_PREPARE_PERSISTENT),
                };
                stmt.map(|mut stmt| {
                    stmt.stmt.set_statement_cache_key(trimmed);
                    CachedStatement::new(stmt, self)
                })
            }
            
            fn cache_stmt(&self, mut stmt: RawStatement) {
                if stmt.is_null() {
                    return;
                }
                let mut cache = self.0.borrow_mut();
                stmt.clear_bindings();
                if let Some(sql) = stmt.statement_cache_key() {
                    cache.insert(sql, stmt);
                } else {
                    debug_assert!(
                        false,
                        "bug in statement cache code, statement returned to cache that without key"
                    );
                }
            }

            #[inline]
            fn flush(&self) {
                let mut cache = self.0.borrow_mut();
                cache.clear();
            }
        }
    }
    
    mod collation
    {
        //! Add, remove, or modify a collation
        use ::
        {
            *,
        };
        
        use std::cmp::Ordering;
        use std::os::raw::{c_char, c_int, c_void};
        use std::panic::catch_unwind;
        use std::ptr;
        use std::slice;

        use crate::ffi;
        use crate::{str_to_cstring, Connection, InnerConnection, Result};

        // FIXME copy/paste from function.rs
        unsafe extern "C" fn free_boxed_value<T>(p: *mut c_void) {
            drop(Box::from_raw(p.cast::<T>()));
        }

        impl Connection {
            /// Add or modify a collation.
            #[inline]
            pub fn create_collation<C>(&self, collation_name: &str, x_compare: C) -> Result<()>
            where
                C: Fn(&str, &str) -> Ordering + Send + 'static,
            {
                self.db
                    .borrow_mut()
                    .create_collation(collation_name, x_compare)
            }
            /// Collation needed callback
            #[inline]
            pub fn collation_needed(
                &self,
                x_coll_needed: fn(&Connection, &str) -> Result<()>,
            ) -> Result<()> {
                self.db.borrow_mut().collation_needed(x_coll_needed)
            }
            /// Remove collation.
            #[inline]
            pub fn remove_collation(&self, collation_name: &str) -> Result<()> {
                self.db.borrow_mut().remove_collation(collation_name)
            }
        }

        impl InnerConnection {
            fn create_collation<C>(&mut self, collation_name: &str, x_compare: C) -> Result<()>
            where
                C: Fn(&str, &str) -> Ordering + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<C>(
                    arg1: *mut c_void,
                    arg2: c_int,
                    arg3: *const c_void,
                    arg4: c_int,
                    arg5: *const c_void,
                ) -> c_int
                where
                    C: Fn(&str, &str) -> Ordering,
                {
                    let r = catch_unwind(|| {
                        let boxed_f: *mut C = arg1.cast::<C>();
                        assert!(!boxed_f.is_null(), "Internal error - null function pointer");
                        let s1 = {
                            let c_slice = slice::from_raw_parts(arg3.cast::<u8>(), arg2 as usize);
                            String::from_utf8_lossy(c_slice)
                        };
                        let s2 = {
                            let c_slice = slice::from_raw_parts(arg5.cast::<u8>(), arg4 as usize);
                            String::from_utf8_lossy(c_slice)
                        };
                        (*boxed_f)(s1.as_ref(), s2.as_ref())
                    });
                    let t = match r {
                        Err(_) => {
                            return -1; // FIXME How ?
                        }
                        Ok(r) => r,
                    };

                    match t {
                        Ordering::Less => -1,
                        Ordering::Equal => 0,
                        Ordering::Greater => 1,
                    }
                }

                let boxed_f: *mut C = Box::into_raw(Box::new(x_compare));
                let c_name = str_to_cstring(collation_name)?;
                let flags = ffi::SQLITE_UTF8;
                let r = unsafe {
                    ffi::sqlite3_create_collation_v2(
                        self.db(),
                        c_name.as_ptr(),
                        flags,
                        boxed_f.cast::<c_void>(),
                        Some(call_boxed_closure::<C>),
                        Some(free_boxed_value::<C>),
                    )
                };
                let res = self.decode_result(r);
                // The xDestroy callback is not called if the sqlite3_create_collation_v2()
                // function fails.
                if res.is_err() {
                    drop(unsafe { Box::from_raw(boxed_f) });
                }
                res
            }

            fn collation_needed(
                &mut self,
                x_coll_needed: fn(&Connection, &str) -> Result<()>,
            ) -> Result<()> {
                use std::mem;
                #[allow(clippy::needless_return)]
                unsafe extern "C" fn collation_needed_callback(
                    arg1: *mut c_void,
                    arg2: *mut ffi::sqlite3,
                    e_text_rep: c_int,
                    arg3: *const c_char,
                ) {
                    use std::ffi::CStr;
                    use std::str;

                    if e_text_rep != ffi::SQLITE_UTF8 {
                        // TODO: validate
                        return;
                    }

                    let callback: fn(&Connection, &str) -> Result<()> = mem::transmute(arg1);
                    let res = catch_unwind(|| {
                        let conn = Connection::from_handle(arg2).unwrap();
                        let collation_name = CStr::from_ptr(arg3)
                            .to_str()
                            .expect("illegal collation sequence name");
                        callback(&conn, collation_name)
                    });
                    if res.is_err() {
                        return; // FIXME How ?
                    }
                }

                let r = unsafe {
                    ffi::sqlite3_collation_needed(
                        self.db(),
                        x_coll_needed as *mut c_void,
                        Some(collation_needed_callback),
                    )
                };
                self.decode_result(r)
            }

            #[inline]
            fn remove_collation(&mut self, collation_name: &str) -> Result<()> {
                let c_name = str_to_cstring(collation_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_collation_v2(
                        self.db(),
                        c_name.as_ptr(),
                        ffi::SQLITE_UTF8,
                        ptr::null_mut(),
                        None,
                        None,
                    )
                };
                self.decode_result(r)
            }
        }
    }

    mod column
    {
        use ::
        {
            *,
        };
        use std::str;

        use crate::{Error, Result, Statement};

        /// Information about a column of a SQLite query.
        #[cfg(feature = "column_decltype")]
        #[cfg_attr(docsrs, doc(cfg(feature = "column_decltype")))]
        #[derive(Debug)]
        pub struct Column<'stmt> {
            name: &'stmt str,
            decl_type: Option<&'stmt str>,
        }

        #[cfg(feature = "column_decltype")]
        #[cfg_attr(docsrs, doc(cfg(feature = "column_decltype")))]
        impl Column<'_> {
            /// Returns the name of the column.
            #[inline]
            #[must_use]
            pub fn name(&self) -> &str {
                self.name
            }
            /// Returns the type of the column (`None` for expression).
            #[inline]
            #[must_use]
            pub fn decl_type(&self) -> Option<&str> {
                self.decl_type
            }
        }

        impl Statement<'_> {
            /// Get all the column names in the result set of the prepared statement.
            pub fn column_names(&self) -> Vec<&str> {
                let n = self.column_count();
                let mut cols = Vec::with_capacity(n);
                for i in 0..n {
                    let s = self.column_name_unwrap(i);
                    cols.push(s);
                }
                cols
            }
            /// Return the number of columns in the result set returned by the prepared statement.
            #[inline]
            pub fn column_count(&self) -> usize {
                self.stmt.column_count()
            }
            /// Check that column name reference lifetime is limited:
            /// https://www.sqlite.org/c3ref/column_name.html
            #[inline]
            pub(super) fn column_name_unwrap(&self, col: usize) -> &str {
                // Just panic if the bounds are wrong for now, we never call this
                // without checking first.
                self.column_name(col).expect("Column out of bounds")
            }
            /// Returns the name assigned to a particular column in the result set returned by the prepared statement.
            #[inline]
            pub fn column_name(&self, col: usize) -> Result<&str> {
                self.stmt
                    .column_name(col)
                    // clippy::or_fun_call (nightly) vs clippy::unnecessary-lazy-evaluations (stable)
                    .ok_or(Error::InvalidColumnIndex(col))
                    .map(|slice| {
                        slice
                            .to_str()
                            .expect("Invalid UTF-8 sequence in column name")
                    })
            }
            /// Returns the column index in the result set for a given column name.
            #[inline]
            pub fn column_index(&self, name: &str) -> Result<usize> {
                let bytes = name.as_bytes();
                let n = self.column_count();
                for i in 0..n {
                    // Note: `column_name` is only fallible if `i` is out of bounds,
                    // which we've already checked.
                    if bytes.eq_ignore_ascii_case(self.stmt.column_name(i).unwrap().to_bytes()) {
                        return Ok(i);
                    }
                }
                Err(Error::InvalidColumnName(String::from(name)))
            }
            /// Returns a slice describing the columns of the result of the query.
            pub fn columns(&self) -> Vec<Column> {
                let n = self.column_count();
                let mut cols = Vec::with_capacity(n);
                for i in 0..n {
                    let name = self.column_name_unwrap(i);
                    let slice = self.stmt.column_decltype(i);
                    let decl_type = slice.map(|s| {
                        s.to_str()
                            .expect("Invalid UTF-8 sequence in column declaration")
                    });
                    cols.push(Column { name, decl_type });
                }
                cols
            }
        }
    }

    pub mod config
    {
        //! Configure database connections
        use ::
        {
            *,
        };
        

        use std::os::raw::c_int;

        use crate::error::check;
        use crate::ffi;
        use crate::{Connection, Result};

        /// Database Connection Configuration Options
        /// See [Database Connection Configuration Options](https://sqlite.org/c3ref/c_dbconfig_enable_fkey.html) for details.
        #[repr(i32)]
        #[derive(Copy, Clone, Debug)]
        #[allow(non_snake_case, non_camel_case_types)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms)]
        pub enum DbConfig {
            //SQLITE_DBCONFIG_MAINDBNAME = 1000, /* const char* */
            //SQLITE_DBCONFIG_LOOKASIDE = 1001,  /* void* int int */
            /// Enable or disable the enforcement of foreign key constraints.
            SQLITE_DBCONFIG_ENABLE_FKEY = ffi::SQLITE_DBCONFIG_ENABLE_FKEY,
            /// Enable or disable triggers.
            SQLITE_DBCONFIG_ENABLE_TRIGGER = ffi::SQLITE_DBCONFIG_ENABLE_TRIGGER,
            /// Enable or disable the fts3_tokenizer() function which is part of the
            /// FTS3 full-text search engine extension.
            SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = ffi::SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, // 3.12.0
            //SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005,
            /// In WAL mode, enable or disable the checkpoint operation before closing
            /// the connection.
            SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE = 1006, // 3.16.2
            /// Activates or deactivates the query planner stability guarantee (QPSG).
            SQLITE_DBCONFIG_ENABLE_QPSG = 1007, // 3.20.0
            /// Includes or excludes output for any operations performed by trigger
            /// programs from the output of EXPLAIN QUERY PLAN commands.
            SQLITE_DBCONFIG_TRIGGER_EQP = 1008, // 3.22.0
            /// Activates or deactivates the "reset" flag for a database connection.
            /// Run VACUUM with this flag set to reset the database.
            SQLITE_DBCONFIG_RESET_DATABASE = 1009, // 3.24.0
            /// Activates or deactivates the "defensive" flag for a database connection.
            SQLITE_DBCONFIG_DEFENSIVE = 1010, // 3.26.0
            /// Activates or deactivates the "writable_schema" flag.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_WRITABLE_SCHEMA = 1011, // 3.28.0
            /// Activates or deactivates the legacy behavior of the ALTER TABLE RENAME
            /// command.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_LEGACY_ALTER_TABLE = 1012, // 3.29
            /// Activates or deactivates the legacy double-quoted string literal
            /// misfeature for DML statements only.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_DQS_DML = 1013, // 3.29.0
            /// Activates or deactivates the legacy double-quoted string literal
            /// misfeature for DDL statements.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_DQS_DDL = 1014, // 3.29.0
            /// Enable or disable views.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_ENABLE_VIEW = 1015, // 3.30.0
            /// Activates or deactivates the legacy file format flag.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_LEGACY_FILE_FORMAT = 1016, // 3.31.0
            /// Tells SQLite to assume that database schemas (the contents of the
            /// sqlite_master tables) are untainted by malicious content.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_TRUSTED_SCHEMA = 1017, // 3.31.0
            /// Sets or clears a flag that enables collection of the
            /// sqlite3_stmt_scanstatus_v2() statistics
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_STMT_SCANSTATUS = 1018, // 3.42.0
            /// Changes the default order in which tables and indexes are scanned
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_REVERSE_SCANORDER = 1019, // 3.42.0
        }

        impl Connection {
            /// Returns the current value of a `config`.
            ///
            /// - `SQLITE_DBCONFIG_ENABLE_FKEY`: return `false` or `true` to indicate
            ///   whether FK enforcement is off or on
            /// - `SQLITE_DBCONFIG_ENABLE_TRIGGER`: return `false` or `true` to indicate
            ///   whether triggers are disabled or enabled
            /// - `SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER`: return `false` or `true` to
            ///   indicate whether `fts3_tokenizer` are disabled or enabled
            /// - `SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE`: return `false` to indicate
            ///   checkpoints-on-close are not disabled or `true` if they are
            /// - `SQLITE_DBCONFIG_ENABLE_QPSG`: return `false` or `true` to indicate
            ///   whether the QPSG is disabled or enabled
            /// - `SQLITE_DBCONFIG_TRIGGER_EQP`: return `false` to indicate
            ///   output-for-trigger are not disabled or `true` if it is
            #[inline]
            pub fn db_config(&self, config: DbConfig) -> Result<bool> {
                let c = self.db.borrow();
                unsafe {
                    let mut val = 0;
                    check(ffi::sqlite3_db_config(
                        c.db(),
                        config as c_int,
                        -1,
                        &mut val,
                    ))?;
                    Ok(val != 0)
                }
            }
            /// Make configuration changes to a database connection
            ///
            /// - `SQLITE_DBCONFIG_ENABLE_FKEY`: `false` to disable FK enforcement,
            ///   `true` to enable FK enforcement
            /// - `SQLITE_DBCONFIG_ENABLE_TRIGGER`: `false` to disable triggers, `true`
            ///   to enable triggers
            /// - `SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER`: `false` to disable
            ///   `fts3_tokenizer()`, `true` to enable `fts3_tokenizer()`
            /// - `SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE`: `false` (the default) to enable
            ///   checkpoints-on-close, `true` to disable them
            /// - `SQLITE_DBCONFIG_ENABLE_QPSG`: `false` to disable the QPSG, `true` to
            ///   enable QPSG
            /// - `SQLITE_DBCONFIG_TRIGGER_EQP`: `false` to disable output for trigger
            ///   programs, `true` to enable it
            #[inline]
            pub fn set_db_config(&self, config: DbConfig, new_val: bool) -> Result<bool> {
                let c = self.db.borrow_mut();
                unsafe {
                    let mut val = 0;
                    check(ffi::sqlite3_db_config(
                        c.db(),
                        config as c_int,
                        new_val as c_int,
                        &mut val,
                    ))?;
                    Ok(val != 0)
                }
            }
        }
    }
    
    mod context
    {
        //! Code related to `sqlite3_context` common to `functions` and `vtab` modules.
        use ::
        {
            *,
        };
        

        use libsqlite3_sys::sqlite3_value;
        use std::os::raw::{c_int, c_void};
        #[cfg(feature = "array")]
        use std::rc::Rc;

        use crate::ffi;
        use crate::ffi::sqlite3_context;

        use crate::str_for_sqlite;
        use crate::types::{ToSqlOutput, ValueRef};
        #[cfg(feature = "array")]
        use crate::vtab::array::{free_array, ARRAY_TYPE};

        // This function is inline despite it's size because what's in the ToSqlOutput
        // is often known to the compiler, and thus const prop/DCE can substantially
        // simplify the function.
        #[inline]
        pub(super) unsafe fn set_result(
            ctx: *mut sqlite3_context,
            #[allow(unused_variables)] args: &[*mut sqlite3_value],
            result: &ToSqlOutput<'_>,
        ) {
            let value = match *result {
                ToSqlOutput::Borrowed(v) => v,
                ToSqlOutput::Owned(ref v) => ValueRef::from(v),

                #[cfg(feature = "blob")]
                ToSqlOutput::ZeroBlob(len) => {
                    // TODO sqlite3_result_zeroblob64 // 3.8.11
                    return ffi::sqlite3_result_zeroblob(ctx, len);
                }
                #[cfg(feature = "functions")]
                ToSqlOutput::Arg(i) => {
                    return ffi::sqlite3_result_value(ctx, args[i]);
                }
                #[cfg(feature = "array")]
                ToSqlOutput::Array(ref a) => {
                    return ffi::sqlite3_result_pointer(
                        ctx,
                        Rc::into_raw(a.clone()) as *mut c_void,
                        ARRAY_TYPE,
                        Some(free_array),
                    );
                }
            };

            match value {
                ValueRef::Null => ffi::sqlite3_result_null(ctx),
                ValueRef::Integer(i) => ffi::sqlite3_result_int64(ctx, i),
                ValueRef::Real(r) => ffi::sqlite3_result_double(ctx, r),
                ValueRef::Text(s) => {
                    let length = s.len();
                    if length > c_int::MAX as usize {
                        ffi::sqlite3_result_error_toobig(ctx);
                    } else {
                        let (c_str, len, destructor) = match str_for_sqlite(s) {
                            Ok(c_str) => c_str,
                            // TODO sqlite3_result_error
                            Err(_) => return ffi::sqlite3_result_error_code(ctx, ffi::SQLITE_MISUSE),
                        };
                        // TODO sqlite3_result_text64 // 3.8.7
                        ffi::sqlite3_result_text(ctx, c_str, len, destructor);
                    }
                }
                ValueRef::Blob(b) => {
                    let length = b.len();
                    if length > c_int::MAX as usize {
                        ffi::sqlite3_result_error_toobig(ctx);
                    } else if length == 0 {
                        ffi::sqlite3_result_zeroblob(ctx, 0);
                    } else {
                        // TODO sqlite3_result_blob64 // 3.8.7
                        ffi::sqlite3_result_blob(
                            ctx,
                            b.as_ptr().cast::<c_void>(),
                            length as c_int,
                            ffi::SQLITE_TRANSIENT(),
                        );
                    }
                }
            }
        }
    }
    
    pub mod functions
    {
        //! Create or redefine SQL functions.
        use ::
        {
            *,
        };
        
        use std::any::Any;
        use std::marker::PhantomData;
        use std::ops::Deref;
        use std::os::raw::{c_int, c_void};
        use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};
        use std::ptr;
        use std::slice;
        use std::sync::Arc;

        use crate::ffi;
        use crate::ffi::sqlite3_context;
        use crate::ffi::sqlite3_value;

        use crate::context::set_result;
        use crate::types::{FromSql, FromSqlError, ToSql, ToSqlOutput, ValueRef};

        use crate::{str_to_cstring, Connection, Error, InnerConnection, Result};

        unsafe fn report_error(ctx: *mut sqlite3_context, err: &Error) {
            if let Error::SqliteFailure(ref err, ref s) = *err {
                ffi::sqlite3_result_error_code(ctx, err.extended_code);
                if let Some(Ok(cstr)) = s.as_ref().map(|s| str_to_cstring(s)) {
                    ffi::sqlite3_result_error(ctx, cstr.as_ptr(), -1);
                }
            } else {
                ffi::sqlite3_result_error_code(ctx, ffi::SQLITE_CONSTRAINT_FUNCTION);
                if let Ok(cstr) = str_to_cstring(&err.to_string()) {
                    ffi::sqlite3_result_error(ctx, cstr.as_ptr(), -1);
                }
            }
        }

        unsafe extern "C" fn free_boxed_value<T>(p: *mut c_void) {
            drop(Box::from_raw(p.cast::<T>()));
        }
        /// Context is a wrapper for the SQLite function
        /// evaluation context.
        pub struct Context<'a> {
            ctx: *mut sqlite3_context,
            args: &'a [*mut sqlite3_value],
        }

        impl Context<'_> {
            /// Returns the number of arguments to the function.
            #[inline]
            #[must_use]
            pub fn len(&self) -> usize {
                self.args.len()
            }
            /// Returns `true` when there is no argument.
            #[inline]
            #[must_use]
            pub fn is_empty(&self) -> bool {
                self.args.is_empty()
            }
            /// Returns the `idx`th argument as a `T`.
            ///
            /// # Failure
            ///
            /// Will panic if `idx` is greater than or equal to
            /// [`self.len()`](Context::len).
            ///
            /// Will return Err if the underlying SQLite type cannot be converted to a
            /// `T`.
            pub fn get<T: FromSql>(&self, idx: usize) -> Result<T> {
                let arg = self.args[idx];
                let value = unsafe { ValueRef::from_value(arg) };
                FromSql::column_result(value).map_err(|err| match err {
                    FromSqlError::InvalidType => {
                        Error::InvalidFunctionParameterType(idx, value.data_type())
                    }
                    FromSqlError::OutOfRange(i) => Error::IntegralValueOutOfRange(idx, i),
                    FromSqlError::Other(err) => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), err)
                    }
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), Box::new(err))
                    }
                })
            }
            /// Returns the `idx`th argument as a `ValueRef`.
            ///
            /// # Failure
            ///
            /// Will panic if `idx` is greater than or equal to
            /// [`self.len()`](Context::len).
            #[inline]
            #[must_use]
            pub fn get_raw(&self, idx: usize) -> ValueRef<'_> {
                let arg = self.args[idx];
                unsafe { ValueRef::from_value(arg) }
            }
            /// Returns the `idx`th argument as a `SqlFnArg`.
            /// To be used when the SQL function result is one of its arguments.
            #[inline]
            #[must_use]
            pub fn get_arg(&self, idx: usize) -> SqlFnArg {
                assert!(idx < self.len());
                SqlFnArg { idx }
            }
            /// Returns the subtype of `idx`th argument.
            ///
            /// # Failure
            ///
            /// Will panic if `idx` is greater than or equal to
            /// [`self.len()`](Context::len).
            pub fn get_subtype(&self, idx: usize) -> std::os::raw::c_uint {
                let arg = self.args[idx];
                unsafe { ffi::sqlite3_value_subtype(arg) }
            }
            /// Fetch or insert the auxiliary data associated with a particular
            /// parameter. This is intended to be an easier-to-use way of fetching it
            /// compared to calling [`get_aux`](Context::get_aux) and
            /// [`set_aux`](Context::set_aux) separately.
            ///
            /// See `https://www.sqlite.org/c3ref/get_auxdata.html` for a discussion of
            /// this feature, or the unit tests of this module for an example.
            pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>
            where
                T: Send + Sync + 'static,
                E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
                F: FnOnce(ValueRef<'_>) -> Result<T, E>,
            {
                if let Some(v) = self.get_aux(arg)? {
                    Ok(v)
                } else {
                    let vr = self.get_raw(arg as usize);
                    self.set_aux(
                        arg,
                        func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,
                    )
                }
            }
            /// Sets the auxiliary data associated with a particular parameter. See
            /// `https://www.sqlite.org/c3ref/get_auxdata.html` for a discussion of
            /// this feature, or the unit tests of this module for an example.
            pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {
                let orig: Arc<T> = Arc::new(value);
                let inner: AuxInner = orig.clone();
                let outer = Box::new(inner);
                let raw: *mut AuxInner = Box::into_raw(outer);
                unsafe {
                    ffi::sqlite3_set_auxdata(
                        self.ctx,
                        arg,
                        raw.cast(),
                        Some(free_boxed_value::<AuxInner>),
                    );
                };
                Ok(orig)
            }
            /// Gets the auxiliary data that was associated with a given parameter via
            /// [`set_aux`](Context::set_aux). Returns `Ok(None)` if no data has been
            /// associated, and Ok(Some(v)) if it has. Returns an error if the
            /// requested type does not match.
            pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {
                let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };
                if p.is_null() {
                    Ok(None)
                } else {
                    let v: AuxInner = AuxInner::clone(unsafe { &*p });
                    v.downcast::<T>()
                        .map(Some)
                        .map_err(|_| Error::GetAuxWrongType)
                }
            }
            /// Get the db connection handle via [sqlite3_context_db_handle](https://www.sqlite.org/c3ref/context_db_handle.html)
            ///
            /// # Safety
            ///
            /// This function is marked unsafe because there is a potential for other
            /// references to the connection to be sent across threads, [see this comment](https://github.com/rusqlite/rusqlite/issues/643#issuecomment-640181213).
            pub unsafe fn get_connection(&self) -> Result<ConnectionRef<'_>> {
                let handle = ffi::sqlite3_context_db_handle(self.ctx);
                Ok(ConnectionRef {
                    conn: Connection::from_handle(handle)?,
                    phantom: PhantomData,
                })
            }
        }
        /// A reference to a connection handle with a lifetime bound to something.
        pub struct ConnectionRef<'ctx> {
            // comes from Connection::from_handle(sqlite3_context_db_handle(...))
            // and is non-owning
            conn: Connection,
            phantom: PhantomData<&'ctx Context<'ctx>>,
        }

        impl Deref for ConnectionRef<'_> {
            type Target = Connection;

            #[inline]
            fn deref(&self) -> &Connection {
                &self.conn
            }
        }

        type AuxInner = Arc<dyn Any + Send + Sync + 'static>;

        /// Subtype of an SQL function
        pub type SubType = Option<std::os::raw::c_uint>;

        /// Result of an SQL function
        pub trait SqlFnOutput {
            /// Converts Rust value to SQLite value with an optional subtype
            fn to_sql(&self) -> Result<(ToSqlOutput<'_>, SubType)>;
        }

        impl<T: ToSql> SqlFnOutput for T {
            #[inline]
            fn to_sql(&self) -> Result<(ToSqlOutput<'_>, SubType)> {
                ToSql::to_sql(self).map(|o| (o, None))
            }
        }

        impl<T: ToSql> SqlFnOutput for (T, SubType) {
            fn to_sql(&self) -> Result<(ToSqlOutput<'_>, SubType)> {
                ToSql::to_sql(&self.0).map(|o| (o, self.1))
            }
        }
        /// n-th arg of an SQL scalar function
        pub struct SqlFnArg {
            idx: usize,
        }
        impl ToSql for SqlFnArg {
            fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                Ok(ToSqlOutput::Arg(self.idx))
            }
        }

        unsafe fn sql_result<T: SqlFnOutput>(
            ctx: *mut sqlite3_context,
            args: &[*mut sqlite3_value],
            r: Result<T>,
        ) {
            let t = r.as_ref().map(SqlFnOutput::to_sql);

            match t {
                Ok(Ok((ref value, sub_type))) => {
                    set_result(ctx, args, value);
                    if let Some(sub_type) = sub_type {
                        ffi::sqlite3_result_subtype(ctx, sub_type);
                    }
                }
                Ok(Err(err)) => report_error(ctx, &err),
                Err(err) => report_error(ctx, err),
            };
        }
        /// Aggregate is the callback interface for user-defined
        /// aggregate function.
        ///
        /// `A` is the type of the aggregation context and `T` is the type of the final
        /// result. Implementations should be stateless.
        pub trait Aggregate<A, T>
        where
            A: RefUnwindSafe + UnwindSafe,
            T: SqlFnOutput,
        {
            /// Initializes the aggregation context. Will be called prior to the first
            /// call to [`step()`](Aggregate::step) to set up the context for an
            /// invocation of the function. (Note: `init()` will not be called if
            /// there are no rows.)
            fn init(&self, ctx: &mut Context<'_>) -> Result<A>;

            /// "step" function called once for each row in an aggregate group. May be
            /// called 0 times if there are no rows.
            fn step(&self, ctx: &mut Context<'_>, acc: &mut A) -> Result<()>;

            /// Computes and returns the final result. Will be called exactly once for
            /// each invocation of the function. If [`step()`](Aggregate::step) was
            /// called at least once, will be given `Some(A)` (the same `A` as was
            /// created by [`init`](Aggregate::init) and given to
            /// [`step`](Aggregate::step)); if [`step()`](Aggregate::step) was not
            /// called (because the function is running against 0 rows), will be
            /// given `None`.
            ///
            /// The passed context will have no arguments.
            fn finalize(&self, ctx: &mut Context<'_>, acc: Option<A>) -> Result<T>;
        }
        /// `WindowAggregate` is the callback interface for
        /// user-defined aggregate window function.
        #[cfg(feature = "window")]
        #[cfg_attr(docsrs, doc(cfg(feature = "window")))]
        pub trait WindowAggregate<A, T>: Aggregate<A, T>
        where
            A: RefUnwindSafe + UnwindSafe,
            T: SqlFnOutput,
        {
            /// Returns the current value of the aggregate. Unlike xFinal, the
            /// implementation should not delete any context.
            fn value(&self, acc: Option<&mut A>) -> Result<T>;

            /// Removes a row from the current window.
            fn inverse(&self, ctx: &mut Context<'_>, acc: &mut A) -> Result<()>;
        }

        bitflags::bitflags! {
            /// Function Flags.
            /// See [sqlite3_create_function](https://sqlite.org/c3ref/create_function.html)
            /// and [Function Flags](https://sqlite.org/c3ref/c_deterministic.html) for details.
            #[derive(Clone, Copy, Debug)]
            #[repr(C)]
            pub struct FunctionFlags: ::std::os::raw::c_int {
                /// Specifies UTF-8 as the text encoding this SQL function prefers for its parameters.
                const SQLITE_UTF8     = ffi::SQLITE_UTF8;
                /// Specifies UTF-16 using little-endian byte order as the text encoding this SQL function prefers for its parameters.
                const SQLITE_UTF16LE  = ffi::SQLITE_UTF16LE;
                /// Specifies UTF-16 using big-endian byte order as the text encoding this SQL function prefers for its parameters.
                const SQLITE_UTF16BE  = ffi::SQLITE_UTF16BE;
                /// Specifies UTF-16 using native byte order as the text encoding this SQL function prefers for its parameters.
                const SQLITE_UTF16    = ffi::SQLITE_UTF16;
                /// Means that the function always gives the same output when the input parameters are the same.
                const SQLITE_DETERMINISTIC = ffi::SQLITE_DETERMINISTIC; // 3.8.3
                /// Means that the function may only be invoked from top-level SQL.
                const SQLITE_DIRECTONLY    = 0x0000_0008_0000; // 3.30.0
                /// Indicates to SQLite that a function may call `sqlite3_value_subtype()` to inspect the subtypes of its arguments.
                const SQLITE_SUBTYPE       = 0x0000_0010_0000; // 3.30.0
                /// Means that the function is unlikely to cause problems even if misused.
                const SQLITE_INNOCUOUS     = 0x0000_0020_0000; // 3.31.0
                /// Indicates to SQLite that a function might call `sqlite3_result_subtype()` to cause a subtype to be associated with its result.
                const SQLITE_RESULT_SUBTYPE     = 0x0000_0100_0000; // 3.45.0
            }
        }

        impl Default for FunctionFlags {
            #[inline]
            fn default() -> FunctionFlags {
                FunctionFlags::SQLITE_UTF8
            }
        }

        impl Connection {
            /// Attach a user-defined scalar function to this database connection.
            #[inline]
            pub fn create_scalar_function<F, T>(
                &self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                x_func: F,
            ) -> Result<()>
            where
                F: FnMut(&Context<'_>) -> Result<T> + Send + 'static,
                T: SqlFnOutput,
            {
                self.db
                    .borrow_mut()
                    .create_scalar_function(fn_name, n_arg, flags, x_func)
            }
            /// Attach a user-defined aggregate function to this database connection.
            #[inline]
            pub fn create_aggregate_function<A, D, T>(
                &self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                aggr: D,
            ) -> Result<()>
            where
                A: RefUnwindSafe + UnwindSafe,
                D: Aggregate<A, T> + 'static,
                T: SqlFnOutput,
            {
                self.db
                    .borrow_mut()
                    .create_aggregate_function(fn_name, n_arg, flags, aggr)
            }
            /// Attach a user-defined aggregate window function to this database connection.
            #[cfg(feature = "window")]
            #[cfg_attr(docsrs, doc(cfg(feature = "window")))]
            #[inline]
            pub fn create_window_function<A, W, T>(
                &self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                aggr: W,
            ) -> Result<()>
            where
                A: RefUnwindSafe + UnwindSafe,
                W: WindowAggregate<A, T> + 'static,
                T: SqlFnOutput,
            {
                self.db
                    .borrow_mut()
                    .create_window_function(fn_name, n_arg, flags, aggr)
            }
            /// Removes a user-defined function from this database connection.
            #[inline]
            pub fn remove_function(&self, fn_name: &str, n_arg: c_int) -> Result<()> {
                self.db.borrow_mut().remove_function(fn_name, n_arg)
            }
        }

        impl InnerConnection {
            fn create_scalar_function<F, T>(
                &mut self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                x_func: F,
            ) -> Result<()>
            where
                F: FnMut(&Context<'_>) -> Result<T> + Send + 'static,
                T: SqlFnOutput,
            {
                unsafe extern "C" fn call_boxed_closure<F, T>(
                    ctx: *mut sqlite3_context,
                    argc: c_int,
                    argv: *mut *mut sqlite3_value,
                ) where
                    F: FnMut(&Context<'_>) -> Result<T>,
                    T: SqlFnOutput,
                {
                    let args = slice::from_raw_parts(argv, argc as usize);
                    let r = catch_unwind(|| {
                        let boxed_f: *mut F = ffi::sqlite3_user_data(ctx).cast::<F>();
                        assert!(!boxed_f.is_null(), "Internal error - null function pointer");
                        let ctx = Context { ctx, args };
                        (*boxed_f)(&ctx)
                    });
                    let t = match r {
                        Err(_) => {
                            report_error(ctx, &Error::UnwindingPanic);
                            return;
                        }
                        Ok(r) => r,
                    };
                    sql_result(ctx, args, t);
                }

                let boxed_f: *mut F = Box::into_raw(Box::new(x_func));
                let c_name = str_to_cstring(fn_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_function_v2(
                        self.db(),
                        c_name.as_ptr(),
                        n_arg,
                        flags.bits(),
                        boxed_f.cast::<c_void>(),
                        Some(call_boxed_closure::<F, T>),
                        None,
                        None,
                        Some(free_boxed_value::<F>),
                    )
                };
                self.decode_result(r)
            }

            fn create_aggregate_function<A, D, T>(
                &mut self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                aggr: D,
            ) -> Result<()>
            where
                A: RefUnwindSafe + UnwindSafe,
                D: Aggregate<A, T> + 'static,
                T: SqlFnOutput,
            {
                let boxed_aggr: *mut D = Box::into_raw(Box::new(aggr));
                let c_name = str_to_cstring(fn_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_function_v2(
                        self.db(),
                        c_name.as_ptr(),
                        n_arg,
                        flags.bits(),
                        boxed_aggr.cast::<c_void>(),
                        None,
                        Some(call_boxed_step::<A, D, T>),
                        Some(call_boxed_final::<A, D, T>),
                        Some(free_boxed_value::<D>),
                    )
                };
                self.decode_result(r)
            }

            #[cfg(feature = "window")]
            fn create_window_function<A, W, T>(
                &mut self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                aggr: W,
            ) -> Result<()>
            where
                A: RefUnwindSafe + UnwindSafe,
                W: WindowAggregate<A, T> + 'static,
                T: SqlFnOutput,
            {
                let boxed_aggr: *mut W = Box::into_raw(Box::new(aggr));
                let c_name = str_to_cstring(fn_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_window_function(
                        self.db(),
                        c_name.as_ptr(),
                        n_arg,
                        flags.bits(),
                        boxed_aggr.cast::<c_void>(),
                        Some(call_boxed_step::<A, W, T>),
                        Some(call_boxed_final::<A, W, T>),
                        Some(call_boxed_value::<A, W, T>),
                        Some(call_boxed_inverse::<A, W, T>),
                        Some(free_boxed_value::<W>),
                    )
                };
                self.decode_result(r)
            }

            fn remove_function(&mut self, fn_name: &str, n_arg: c_int) -> Result<()> {
                let c_name = str_to_cstring(fn_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_function_v2(
                        self.db(),
                        c_name.as_ptr(),
                        n_arg,
                        ffi::SQLITE_UTF8,
                        ptr::null_mut(),
                        None,
                        None,
                        None,
                        None,
                    )
                };
                self.decode_result(r)
            }
        }

        unsafe fn aggregate_context<A>(ctx: *mut sqlite3_context, bytes: usize) -> Option<*mut *mut A> {
            let pac = ffi::sqlite3_aggregate_context(ctx, bytes as c_int) as *mut *mut A;
            if pac.is_null() {
                return None;
            }
            Some(pac)
        }

        unsafe extern "C" fn call_boxed_step<A, D, T>(
            ctx: *mut sqlite3_context,
            argc: c_int,
            argv: *mut *mut sqlite3_value,
        ) where
            A: RefUnwindSafe + UnwindSafe,
            D: Aggregate<A, T>,
            T: SqlFnOutput,
        {
            let pac = if let Some(pac) = aggregate_context(ctx, std::mem::size_of::<*mut A>()) {
                pac
            } else {
                ffi::sqlite3_result_error_nomem(ctx);
                return;
            };

            let r = catch_unwind(|| {
                let boxed_aggr: *mut D = ffi::sqlite3_user_data(ctx).cast::<D>();
                assert!(
                    !boxed_aggr.is_null(),
                    "Internal error - null aggregate pointer"
                );
                let mut ctx = Context {
                    ctx,
                    args: slice::from_raw_parts(argv, argc as usize),
                };

                #[allow(clippy::unnecessary_cast)]
                if (*pac as *mut A).is_null() {
                    *pac = Box::into_raw(Box::new((*boxed_aggr).init(&mut ctx)?));
                }

                (*boxed_aggr).step(&mut ctx, &mut **pac)
            });
            let r = match r {
                Err(_) => {
                    report_error(ctx, &Error::UnwindingPanic);
                    return;
                }
                Ok(r) => r,
            };
            match r {
                Ok(_) => {}
                Err(err) => report_error(ctx, &err),
            };
        }

        #[cfg(feature = "window")]
        unsafe extern "C" fn call_boxed_inverse<A, W, T>(
            ctx: *mut sqlite3_context,
            argc: c_int,
            argv: *mut *mut sqlite3_value,
        ) where
            A: RefUnwindSafe + UnwindSafe,
            W: WindowAggregate<A, T>,
            T: SqlFnOutput,
        {
            let pac = if let Some(pac) = aggregate_context(ctx, std::mem::size_of::<*mut A>()) {
                pac
            } else {
                ffi::sqlite3_result_error_nomem(ctx);
                return;
            };

            let r = catch_unwind(|| {
                let boxed_aggr: *mut W = ffi::sqlite3_user_data(ctx).cast::<W>();
                assert!(
                    !boxed_aggr.is_null(),
                    "Internal error - null aggregate pointer"
                );
                let mut ctx = Context {
                    ctx,
                    args: slice::from_raw_parts(argv, argc as usize),
                };
                (*boxed_aggr).inverse(&mut ctx, &mut **pac)
            });
            let r = match r {
                Err(_) => {
                    report_error(ctx, &Error::UnwindingPanic);
                    return;
                }
                Ok(r) => r,
            };
            match r {
                Ok(_) => {}
                Err(err) => report_error(ctx, &err),
            };
        }

        unsafe extern "C" fn call_boxed_final<A, D, T>(ctx: *mut sqlite3_context)
        where
            A: RefUnwindSafe + UnwindSafe,
            D: Aggregate<A, T>,
            T: SqlFnOutput,
        {
            // Within the xFinal callback, it is customary to set N=0 in calls to
            // sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.
            let a: Option<A> = match aggregate_context(ctx, 0) {
                Some(pac) =>
                {
                    #[allow(clippy::unnecessary_cast)]
                    if (*pac as *mut A).is_null() {
                        None
                    } else {
                        let a = Box::from_raw(*pac);
                        Some(*a)
                    }
                }
                None => None,
            };

            let r = catch_unwind(|| {
                let boxed_aggr: *mut D = ffi::sqlite3_user_data(ctx).cast::<D>();
                assert!(
                    !boxed_aggr.is_null(),
                    "Internal error - null aggregate pointer"
                );
                let mut ctx = Context { ctx, args: &mut [] };
                (*boxed_aggr).finalize(&mut ctx, a)
            });
            let t = match r {
                Err(_) => {
                    report_error(ctx, &Error::UnwindingPanic);
                    return;
                }
                Ok(r) => r,
            };
            sql_result(ctx, &[], t);
        }

        #[cfg(feature = "window")]
        unsafe extern "C" fn call_boxed_value<A, W, T>(ctx: *mut sqlite3_context)
        where
            A: RefUnwindSafe + UnwindSafe,
            W: WindowAggregate<A, T>,
            T: SqlFnOutput,
        {
            // Within the xValue callback, it is customary to set N=0 in calls to
            // sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.
            let pac = aggregate_context(ctx, 0).filter(|&pac| {
                #[allow(clippy::unnecessary_cast)]
                !(*pac as *mut A).is_null()
            });

            let r = catch_unwind(|| {
                let boxed_aggr: *mut W = ffi::sqlite3_user_data(ctx).cast::<W>();
                assert!(
                    !boxed_aggr.is_null(),
                    "Internal error - null aggregate pointer"
                );
                (*boxed_aggr).value(pac.map(|pac| &mut **pac))
            });
            let t = match r {
                Err(_) => {
                    report_error(ctx, &Error::UnwindingPanic);
                    return;
                }
                Ok(r) => r,
            };
            sql_result(ctx, &[], t);
        }
    }
    
    pub mod hooks
    {
        //! Commit, Data Change and Rollback Notification Callbacks
        use ::
        {
            *,
        }; 
        /*
        use std::os::raw::{c_char, c_int, c_void};
        use std::panic::catch_unwind;
        use std::ptr;

        use crate::ffi;

        use crate::{Connection, InnerConnection}; */
        mod preupdate_hook
        {
            use ::
            {
                *,
            };
            use std::fmt::Debug;
            use std::os::raw::{c_char, c_int, c_void};
            use std::panic::catch_unwind;
            use std::ptr;

            use super::expect_utf8;
            use super::free_boxed_hook;
            use super::Action;
            use crate::error::check;
            use crate::ffi;
            use crate::inner_connection::InnerConnection;
            use crate::types::ValueRef;
            use crate::Connection;
            use crate::Result;

            /// The possible cases for when a PreUpdateHook gets triggered. Allows access to the relevant
            /// functions for each case through the contained values.
            #[derive(Debug)]
            pub enum PreUpdateCase {
                /// Pre-update hook was triggered by an insert.
                Insert(PreUpdateNewValueAccessor),
                /// Pre-update hook was triggered by a delete.
                Delete(PreUpdateOldValueAccessor),
                /// Pre-update hook was triggered by an update.
                Update {
                    #[allow(missing_docs)]
                    old_value_accessor: PreUpdateOldValueAccessor,
                    #[allow(missing_docs)]
                    new_value_accessor: PreUpdateNewValueAccessor,
                },
                /// This variant is not normally produced by SQLite. You may encounter it
                /// if you're using a different version than what's supported by this library.
                Unknown,
            }

            impl From<PreUpdateCase> for Action {
                fn from(puc: PreUpdateCase) -> Action {
                    match puc {
                        PreUpdateCase::Insert(_) => Action::SQLITE_INSERT,
                        PreUpdateCase::Delete(_) => Action::SQLITE_DELETE,
                        PreUpdateCase::Update { .. } => Action::SQLITE_UPDATE,
                        PreUpdateCase::Unknown => Action::UNKNOWN,
                    }
                }
            }
            /// An accessor to access the old values of the row being deleted/updated during the preupdate callback.
            #[derive(Debug)]
            pub struct PreUpdateOldValueAccessor {
                db: *mut ffi::sqlite3,
                old_row_id: i64,
            }

            impl PreUpdateOldValueAccessor {
                /// Get the amount of columns in the row being deleted/updated.
                pub fn get_column_count(&self) -> i32 {
                    unsafe { ffi::sqlite3_preupdate_count(self.db) }
                }
                /// Get the depth of the query that triggered the preupdate hook.
                /// Returns 0 if the preupdate callback was invoked as a result of
                /// a direct insert, update, or delete operation;
                /// 1 for inserts, updates, or deletes invoked by top-level triggers;
                /// 2 for changes resulting from triggers called by top-level triggers; and so forth.
                pub fn get_query_depth(&self) -> i32 {
                    unsafe { ffi::sqlite3_preupdate_depth(self.db) }
                }
                /// Get the row id of the row being updated/deleted.
                pub fn get_old_row_id(&self) -> i64 {
                    self.old_row_id
                }
                /// Get the value of the row being updated/deleted at the specified index.
                pub fn get_old_column_value(&self, i: i32) -> Result<ValueRef> {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    unsafe {
                        check(ffi::sqlite3_preupdate_old(self.db, i, &mut p_value))?;
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }
            /// An accessor to access the new values of the row being inserted/updated
            /// during the preupdate callback.
            #[derive(Debug)]
            pub struct PreUpdateNewValueAccessor {
                db: *mut ffi::sqlite3,
                new_row_id: i64,
            }

            impl PreUpdateNewValueAccessor {
                /// Get the amount of columns in the row being inserted/updated.
                pub fn get_column_count(&self) -> i32 {
                    unsafe { ffi::sqlite3_preupdate_count(self.db) }
                }
                /// Get the depth of the query that triggered the preupdate hook.
                /// Returns 0 if the preupdate callback was invoked as a result of
                /// a direct insert, update, or delete operation;
                /// 1 for inserts, updates, or deletes invoked by top-level triggers;
                /// 2 for changes resulting from triggers called by top-level triggers; and so forth.
                pub fn get_query_depth(&self) -> i32 {
                    unsafe { ffi::sqlite3_preupdate_depth(self.db) }
                }
                /// Get the row id of the row being inserted/updated.
                pub fn get_new_row_id(&self) -> i64 {
                    self.new_row_id
                }
                /// Get the value of the row being updated/deleted at the specified index.
                pub fn get_new_column_value(&self, i: i32) -> Result<ValueRef> {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    unsafe {
                        check(ffi::sqlite3_preupdate_new(self.db, i, &mut p_value))?;
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }

            impl Connection {
                /// Register a callback function to be invoked before
                /// a row is updated, inserted or deleted.
                ///
                /// The callback parameters are:
                ///
                /// - the name of the database ("main", "temp", ...),
                /// - the name of the table that is updated,
                /// - a variant of the PreUpdateCase enum which allows access to extra functions depending
                /// on whether it's an update, delete or insert.
                #[inline]
                pub fn preupdate_hook<F>(&self, hook: Option<F>)  where
                    F: FnMut(Action, &str, &str, &PreUpdateCase) + Send + 'static,
                {
                    self.db.borrow_mut().preupdate_hook(hook);
                }
            }

            impl InnerConnection {
                #[inline]
                pub fn remove_preupdate_hook(&mut self) {
                    self.preupdate_hook(None::<fn(Action, &str, &str, &PreUpdateCase)>);
                }
                
                fn preupdate_hook<F>(&mut self, hook: Option<F>)  where
                    F: FnMut(Action, &str, &str, &PreUpdateCase) + Send + 'static,
                {
                    unsafe extern "C" fn call_boxed_closure<F>(
                        p_arg: *mut c_void,
                        sqlite: *mut ffi::sqlite3,
                        action_code: c_int,
                        db_name: *const c_char,
                        tbl_name: *const c_char,
                        old_row_id: i64,
                        new_row_id: i64,
                    ) where
                        F: FnMut(Action, &str, &str, &PreUpdateCase),
                    {
                        let action = Action::from(action_code);

                        let preupdate_case = match action {
                            Action::SQLITE_INSERT => PreUpdateCase::Insert(PreUpdateNewValueAccessor {
                                db: sqlite,
                                new_row_id,
                            }),
                            Action::SQLITE_DELETE => PreUpdateCase::Delete(PreUpdateOldValueAccessor {
                                db: sqlite,
                                old_row_id,
                            }),
                            Action::SQLITE_UPDATE => PreUpdateCase::Update {
                                old_value_accessor: PreUpdateOldValueAccessor {
                                    db: sqlite,
                                    old_row_id,
                                },
                                new_value_accessor: PreUpdateNewValueAccessor {
                                    db: sqlite,
                                    new_row_id,
                                },
                            },
                            Action::UNKNOWN => PreUpdateCase::Unknown,
                        };

                        drop(catch_unwind(|| {
                            let boxed_hook: *mut F = p_arg.cast::<F>();
                            (*boxed_hook)(
                                action,
                                expect_utf8(db_name, "database name"),
                                expect_utf8(tbl_name, "table name"),
                                &preupdate_case,
                            );
                        }));
                    }

                    let free_preupdate_hook = if hook.is_some() {
                        Some(free_boxed_hook::<F> as unsafe fn(*mut c_void))
                    } else {
                        None
                    };

                    let previous_hook = match hook {
                        Some(hook) => {
                            let boxed_hook: *mut F = Box::into_raw(Box::new(hook));
                            unsafe {
                                ffi::sqlite3_preupdate_hook(
                                    self.db(),
                                    Some(call_boxed_closure::<F>),
                                    boxed_hook.cast(),
                                )
                            }
                        }
                        _ => unsafe { ffi::sqlite3_preupdate_hook(self.db(), None, ptr::null_mut()) },
                    };
                    if !previous_hook.is_null() {
                        if let Some(free_boxed_hook) = self.free_preupdate_hook {
                            unsafe { free_boxed_hook(previous_hook) };
                        }
                    }
                    self.free_preupdate_hook = free_preupdate_hook;
                }
            }
        } pub use preupdate_hook::*;
        /// Action Codes
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        #[repr(i32)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms)]
        pub enum Action {
            /// Unsupported / unexpected action
            UNKNOWN = -1,
            /// DELETE command
            SQLITE_DELETE = ffi::SQLITE_DELETE,
            /// INSERT command
            SQLITE_INSERT = ffi::SQLITE_INSERT,
            /// UPDATE command
            SQLITE_UPDATE = ffi::SQLITE_UPDATE,
        }

        impl From<i32> for Action {
            #[inline]
            fn from(code: i32) -> Action {
                match code {
                    ffi::SQLITE_DELETE => Action::SQLITE_DELETE,
                    ffi::SQLITE_INSERT => Action::SQLITE_INSERT,
                    ffi::SQLITE_UPDATE => Action::SQLITE_UPDATE,
                    _ => Action::UNKNOWN,
                }
            }
        }
        /// The context received by an authorizer hook.
        ///
        /// See <https://sqlite.org/c3ref/set_authorizer.html> for more info.
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub struct AuthContext<'c> {
            /// The action to be authorized.
            pub action: AuthAction<'c>,

            /// The database name, if applicable.
            pub database_name: Option<&'c str>,

            /// The inner-most trigger or view responsible for the access attempt.
            /// `None` if the access attempt was made by top-level SQL code.
            pub accessor: Option<&'c str>,
        }
        /// Actions and arguments found within a statement during
        /// preparation.
        ///
        /// See <https://sqlite.org/c3ref/c_alter_table.html> for more info.
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        #[non_exhaustive]
        #[allow(missing_docs)]
        pub enum AuthAction<'c> {
            /// This variant is not normally produced by SQLite. You may encounter it
            // if you're using a different version than what's supported by this library.
            Unknown {
                /// The unknown authorization action code.
                code: i32,
                /// The third arg to the authorizer callback.
                arg1: Option<&'c str>,
                /// The fourth arg to the authorizer callback.
                arg2: Option<&'c str>,
            },
            CreateIndex {
                index_name: &'c str,
                table_name: &'c str,
            },
            CreateTable {
                table_name: &'c str,
            },
            CreateTempIndex {
                index_name: &'c str,
                table_name: &'c str,
            },
            CreateTempTable {
                table_name: &'c str,
            },
            CreateTempTrigger {
                trigger_name: &'c str,
                table_name: &'c str,
            },
            CreateTempView {
                view_name: &'c str,
            },
            CreateTrigger {
                trigger_name: &'c str,
                table_name: &'c str,
            },
            CreateView {
                view_name: &'c str,
            },
            Delete {
                table_name: &'c str,
            },
            DropIndex {
                index_name: &'c str,
                table_name: &'c str,
            },
            DropTable {
                table_name: &'c str,
            },
            DropTempIndex {
                index_name: &'c str,
                table_name: &'c str,
            },
            DropTempTable {
                table_name: &'c str,
            },
            DropTempTrigger {
                trigger_name: &'c str,
                table_name: &'c str,
            },
            DropTempView {
                view_name: &'c str,
            },
            DropTrigger {
                trigger_name: &'c str,
                table_name: &'c str,
            },
            DropView {
                view_name: &'c str,
            },
            Insert {
                table_name: &'c str,
            },
            Pragma {
                pragma_name: &'c str,
                /// The pragma value, if present (e.g., `PRAGMA name = value;`).
                pragma_value: Option<&'c str>,
            },
            Read {
                table_name: &'c str,
                column_name: &'c str,
            },
            Select,
            Transaction {
                operation: TransactionOperation,
            },
            Update {
                table_name: &'c str,
                column_name: &'c str,
            },
            Attach {
                filename: &'c str,
            },
            Detach {
                database_name: &'c str,
            },
            AlterTable {
                database_name: &'c str,
                table_name: &'c str,
            },
            Reindex {
                index_name: &'c str,
            },
            Analyze {
                table_name: &'c str,
            },
            CreateVtable {
                table_name: &'c str,
                module_name: &'c str,
            },
            DropVtable {
                table_name: &'c str,
                module_name: &'c str,
            },
            Function {
                function_name: &'c str,
            },
            Savepoint {
                operation: TransactionOperation,
                savepoint_name: &'c str,
            },
            Recursive,
        }

        impl<'c> AuthAction<'c> {
            fn from_raw(code: i32, arg1: Option<&'c str>, arg2: Option<&'c str>) -> Self {
                match (code, arg1, arg2) {
                    (ffi::SQLITE_CREATE_INDEX, Some(index_name), Some(table_name)) => Self::CreateIndex {
                        index_name,
                        table_name,
                    },
                    (ffi::SQLITE_CREATE_TABLE, Some(table_name), _) => Self::CreateTable { table_name },
                    (ffi::SQLITE_CREATE_TEMP_INDEX, Some(index_name), Some(table_name)) => {
                        Self::CreateTempIndex {
                            index_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_CREATE_TEMP_TABLE, Some(table_name), _) => {
                        Self::CreateTempTable { table_name }
                    }
                    (ffi::SQLITE_CREATE_TEMP_TRIGGER, Some(trigger_name), Some(table_name)) => {
                        Self::CreateTempTrigger {
                            trigger_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_CREATE_TEMP_VIEW, Some(view_name), _) => {
                        Self::CreateTempView { view_name }
                    }
                    (ffi::SQLITE_CREATE_TRIGGER, Some(trigger_name), Some(table_name)) => {
                        Self::CreateTrigger {
                            trigger_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_CREATE_VIEW, Some(view_name), _) => Self::CreateView { view_name },
                    (ffi::SQLITE_DELETE, Some(table_name), None) => Self::Delete { table_name },
                    (ffi::SQLITE_DROP_INDEX, Some(index_name), Some(table_name)) => Self::DropIndex {
                        index_name,
                        table_name,
                    },
                    (ffi::SQLITE_DROP_TABLE, Some(table_name), _) => Self::DropTable { table_name },
                    (ffi::SQLITE_DROP_TEMP_INDEX, Some(index_name), Some(table_name)) => {
                        Self::DropTempIndex {
                            index_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_DROP_TEMP_TABLE, Some(table_name), _) => {
                        Self::DropTempTable { table_name }
                    }
                    (ffi::SQLITE_DROP_TEMP_TRIGGER, Some(trigger_name), Some(table_name)) => {
                        Self::DropTempTrigger {
                            trigger_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_DROP_TEMP_VIEW, Some(view_name), _) => Self::DropTempView { view_name },
                    (ffi::SQLITE_DROP_TRIGGER, Some(trigger_name), Some(table_name)) => Self::DropTrigger {
                        trigger_name,
                        table_name,
                    },
                    (ffi::SQLITE_DROP_VIEW, Some(view_name), _) => Self::DropView { view_name },
                    (ffi::SQLITE_INSERT, Some(table_name), _) => Self::Insert { table_name },
                    (ffi::SQLITE_PRAGMA, Some(pragma_name), pragma_value) => Self::Pragma {
                        pragma_name,
                        pragma_value,
                    },
                    (ffi::SQLITE_READ, Some(table_name), Some(column_name)) => Self::Read {
                        table_name,
                        column_name,
                    },
                    (ffi::SQLITE_SELECT, ..) => Self::Select,
                    (ffi::SQLITE_TRANSACTION, Some(operation_str), _) => Self::Transaction {
                        operation: TransactionOperation::from_str(operation_str),
                    },
                    (ffi::SQLITE_UPDATE, Some(table_name), Some(column_name)) => Self::Update {
                        table_name,
                        column_name,
                    },
                    (ffi::SQLITE_ATTACH, Some(filename), _) => Self::Attach { filename },
                    (ffi::SQLITE_DETACH, Some(database_name), _) => Self::Detach { database_name },
                    (ffi::SQLITE_ALTER_TABLE, Some(database_name), Some(table_name)) => Self::AlterTable {
                        database_name,
                        table_name,
                    },
                    (ffi::SQLITE_REINDEX, Some(index_name), _) => Self::Reindex { index_name },
                    (ffi::SQLITE_ANALYZE, Some(table_name), _) => Self::Analyze { table_name },
                    (ffi::SQLITE_CREATE_VTABLE, Some(table_name), Some(module_name)) => {
                        Self::CreateVtable {
                            table_name,
                            module_name,
                        }
                    }
                    (ffi::SQLITE_DROP_VTABLE, Some(table_name), Some(module_name)) => Self::DropVtable {
                        table_name,
                        module_name,
                    },
                    (ffi::SQLITE_FUNCTION, _, Some(function_name)) => Self::Function { function_name },
                    (ffi::SQLITE_SAVEPOINT, Some(operation_str), Some(savepoint_name)) => Self::Savepoint {
                        operation: TransactionOperation::from_str(operation_str),
                        savepoint_name,
                    },
                    (ffi::SQLITE_RECURSIVE, ..) => Self::Recursive,
                    (code, arg1, arg2) => Self::Unknown { code, arg1, arg2 },
                }
            }
        }

        pub type BoxedAuthorizer =
            Box<dyn for<'c> FnMut(AuthContext<'c>) -> Authorization + Send + 'static>;

        /// A transaction operation.
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        #[non_exhaustive]
        #[allow(missing_docs)]
        pub enum TransactionOperation {
            Unknown,
            Begin,
            Release,
            Rollback,
        }

        impl TransactionOperation {
            fn from_str(op_str: &str) -> Self {
                match op_str {
                    "BEGIN" => Self::Begin,
                    "RELEASE" => Self::Release,
                    "ROLLBACK" => Self::Rollback,
                    _ => Self::Unknown,
                }
            }
        }
        /// [`authorizer`](Connection::authorizer) return code
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        #[non_exhaustive]
        pub enum Authorization {
            /// Authorize the action.
            Allow,
            /// Don't allow access, but don't trigger an error either.
            Ignore,
            /// Trigger an error.
            Deny,
        }

        impl Authorization {
            fn into_raw(self) -> c_int {
                match self {
                    Self::Allow => ffi::SQLITE_OK,
                    Self::Ignore => ffi::SQLITE_IGNORE,
                    Self::Deny => ffi::SQLITE_DENY,
                }
            }
        }

        impl Connection {
            /// Register a callback function to be invoked whenever
            /// a transaction is committed.
            ///
            /// The callback returns `true` to rollback.
            #[inline]
            pub fn commit_hook<F>(&self, hook: Option<F>)
            where
                F: FnMut() -> bool + Send + 'static,
            {
                self.db.borrow_mut().commit_hook(hook);
            }
            /// Register a callback function to be invoked whenever
            /// a transaction is committed.
            #[inline]
            pub fn rollback_hook<F>(&self, hook: Option<F>)
            where
                F: FnMut() + Send + 'static,
            {
                self.db.borrow_mut().rollback_hook(hook);
            }
            /// Register a callback function to be invoked whenever
            /// a row is updated, inserted or deleted in a rowid table.
            ///
            /// The callback parameters are:
            ///
            /// - the type of database update (`SQLITE_INSERT`, `SQLITE_UPDATE` or
            /// `SQLITE_DELETE`),
            /// - the name of the database ("main", "temp", ...),
            /// - the name of the table that is updated,
            /// - the ROWID of the row that is updated.
            #[inline]
            pub fn update_hook<F>(&self, hook: Option<F>)
            where
                F: FnMut(Action, &str, &str, i64) + Send + 'static,
            {
                self.db.borrow_mut().update_hook(hook);
            }
            /// Register a query progress callback.
            ///
            /// The parameter `num_ops` is the approximate number of virtual machine
            /// instructions that are evaluated between successive invocations of the
            /// `handler`. If `num_ops` is less than one then the progress handler
            /// is disabled.
            ///
            /// If the progress callback returns `true`, the operation is interrupted.
            pub fn progress_handler<F>(&self, num_ops: c_int, handler: Option<F>)
            where
                F: FnMut() -> bool + Send + 'static,
            {
                self.db.borrow_mut().progress_handler(num_ops, handler);
            }
            /// Register an authorizer callback that's invoked
            /// as a statement is being prepared.
            #[inline]
            pub fn authorizer<'c, F>(&self, hook: Option<F>)
            where
                F: for<'r> FnMut(AuthContext<'r>) -> Authorization + Send + 'static,
            {
                self.db.borrow_mut().authorizer(hook);
            }
        }

        impl InnerConnection {
            #[inline]
            pub fn remove_hooks(&mut self) {
                self.update_hook(None::<fn(Action, &str, &str, i64)>);
                self.commit_hook(None::<fn() -> bool>);
                self.rollback_hook(None::<fn()>);
                self.progress_handler(0, None::<fn() -> bool>);
                self.authorizer(None::<fn(AuthContext<'_>) -> Authorization>);
            }
            
            fn commit_hook<F>(&mut self, hook: Option<F>)
            where
                F: FnMut() -> bool + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(p_arg: *mut c_void) -> c_int
                where
                    F: FnMut() -> bool,
                {
                    let r = catch_unwind(|| {
                        let boxed_hook: *mut F = p_arg.cast::<F>();
                        (*boxed_hook)()
                    });
                    c_int::from(r.unwrap_or_default())
                }

                // unlike `sqlite3_create_function_v2`, we cannot specify a `xDestroy` with
                // `sqlite3_commit_hook`. so we keep the `xDestroy` function in
                // `InnerConnection.free_boxed_hook`.
                let free_commit_hook = if hook.is_some() {
                    Some(free_boxed_hook::<F> as unsafe fn(*mut c_void))
                } else {
                    None
                };

                let previous_hook = match hook {
                    Some(hook) => {
                        let boxed_hook: *mut F = Box::into_raw(Box::new(hook));
                        unsafe {
                            ffi::sqlite3_commit_hook(
                                self.db(),
                                Some(call_boxed_closure::<F>),
                                boxed_hook.cast(),
                            )
                        }
                    }
                    _ => unsafe { ffi::sqlite3_commit_hook(self.db(), None, ptr::null_mut()) },
                };
                if !previous_hook.is_null() {
                    if let Some(free_boxed_hook) = self.free_commit_hook {
                        unsafe { free_boxed_hook(previous_hook) };
                    }
                }
                self.free_commit_hook = free_commit_hook;
            }
            
            fn rollback_hook<F>(&mut self, hook: Option<F>)
            where
                F: FnMut() + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(p_arg: *mut c_void)  where
                    F: FnMut(),
                {
                    drop(catch_unwind(|| {
                        let boxed_hook: *mut F = p_arg.cast::<F>();
                        (*boxed_hook)();
                    }));
                }

                let free_rollback_hook = if hook.is_some() {
                    Some(free_boxed_hook::<F> as unsafe fn(*mut c_void))
                } else {
                    None
                };

                let previous_hook = match hook {
                    Some(hook) => {
                        let boxed_hook: *mut F = Box::into_raw(Box::new(hook));
                        unsafe {
                            ffi::sqlite3_rollback_hook(
                                self.db(),
                                Some(call_boxed_closure::<F>),
                                boxed_hook.cast(),
                            )
                        }
                    }
                    _ => unsafe { ffi::sqlite3_rollback_hook(self.db(), None, ptr::null_mut()) },
                };
                if !previous_hook.is_null() {
                    if let Some(free_boxed_hook) = self.free_rollback_hook {
                        unsafe { free_boxed_hook(previous_hook) };
                    }
                }
                self.free_rollback_hook = free_rollback_hook;
            }
            
            fn update_hook<F>(&mut self, hook: Option<F>)
            where
                F: FnMut(Action, &str, &str, i64) + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(
                    p_arg: *mut c_void,
                    action_code: c_int,
                    p_db_name: *const c_char,
                    p_table_name: *const c_char,
                    row_id: i64,
                ) where
                    F: FnMut(Action, &str, &str, i64),
                {
                    let action = Action::from(action_code);
                    drop(catch_unwind(|| {
                        let boxed_hook: *mut F = p_arg.cast::<F>();
                        (*boxed_hook)(
                            action,
                            expect_utf8(p_db_name, "database name"),
                            expect_utf8(p_table_name, "table name"),
                            row_id,
                        );
                    }));
                }

                let free_update_hook = if hook.is_some() {
                    Some(free_boxed_hook::<F> as unsafe fn(*mut c_void))
                } else {
                    None
                };

                let previous_hook = match hook {
                    Some(hook) => {
                        let boxed_hook: *mut F = Box::into_raw(Box::new(hook));
                        unsafe {
                            ffi::sqlite3_update_hook(
                                self.db(),
                                Some(call_boxed_closure::<F>),
                                boxed_hook.cast(),
                            )
                        }
                    }
                    _ => unsafe { ffi::sqlite3_update_hook(self.db(), None, ptr::null_mut()) },
                };
                if !previous_hook.is_null() {
                    if let Some(free_boxed_hook) = self.free_update_hook {
                        unsafe { free_boxed_hook(previous_hook) };
                    }
                }
                self.free_update_hook = free_update_hook;
            }
            fn progress_handler<F>(&mut self, num_ops: c_int, handler: Option<F>)
            where
                F: FnMut() -> bool + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(p_arg: *mut c_void) -> c_int
                where
                    F: FnMut() -> bool,
                {
                    let r = catch_unwind(|| {
                        let boxed_handler: *mut F = p_arg.cast::<F>();
                        (*boxed_handler)()
                    });
                    c_int::from(r.unwrap_or_default())
                }

                if let Some(handler) = handler {
                    let boxed_handler = Box::new(handler);
                    unsafe {
                        ffi::sqlite3_progress_handler(
                            self.db(),
                            num_ops,
                            Some(call_boxed_closure::<F>),
                            &*boxed_handler as *const F as *mut _,
                        );
                    }
                    self.progress_handler = Some(boxed_handler);
                } else {
                    unsafe { ffi::sqlite3_progress_handler(self.db(), num_ops, None, ptr::null_mut()) }
                    self.progress_handler = None;
                };
            }
            
            fn authorizer<'c, F>(&'c mut self, authorizer: Option<F>)
            where
                F: for<'r> FnMut(AuthContext<'r>) -> Authorization + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<'c, F>(
                    p_arg: *mut c_void,
                    action_code: c_int,
                    param1: *const c_char,
                    param2: *const c_char,
                    db_name: *const c_char,
                    trigger_or_view_name: *const c_char,
                ) -> c_int
                where
                    F: FnMut(AuthContext<'c>) -> Authorization + Send + 'static,
                {
                    catch_unwind(|| {
                        let action = AuthAction::from_raw(
                            action_code,
                            expect_optional_utf8(param1, "authorizer param 1"),
                            expect_optional_utf8(param2, "authorizer param 2"),
                        );
                        let auth_ctx = AuthContext {
                            action,
                            database_name: expect_optional_utf8(db_name, "database name"),
                            accessor: expect_optional_utf8(
                                trigger_or_view_name,
                                "accessor (inner-most trigger or view)",
                            ),
                        };
                        let boxed_hook: *mut F = p_arg.cast::<F>();
                        (*boxed_hook)(auth_ctx)
                    })
                    .map_or_else(|_| ffi::SQLITE_ERROR, Authorization::into_raw)
                }

                let callback_fn = authorizer
                    .as_ref()
                    .map(|_| call_boxed_closure::<'c, F> as unsafe extern "C" fn(_, _, _, _, _, _) -> _);
                let boxed_authorizer = authorizer.map(Box::new);

                match unsafe {
                    ffi::sqlite3_set_authorizer(
                        self.db(),
                        callback_fn,
                        boxed_authorizer
                            .as_ref()
                            .map_or_else(ptr::null_mut, |f| &**f as *const F as *mut _),
                    )
                } {
                    ffi::SQLITE_OK => {
                        self.authorizer = boxed_authorizer.map(|ba| ba as _);
                    }
                    err_code => {
                        // The only error that `sqlite3_set_authorizer` returns is `SQLITE_MISUSE`
                        // when compiled with `ENABLE_API_ARMOR` and the db pointer is invalid.
                        // This library does not allow constructing a null db ptr, so if this branch
                        // is hit, something very bad has happened. Panicking instead of returning
                        // `Result` keeps this hook's API consistent with the others.
                        panic!("unexpectedly failed to set_authorizer: {}", unsafe {
                            crate::error::error_from_handle(self.db(), err_code)
                        });
                    }
                }
            }
        }

        unsafe fn free_boxed_hook<F>(p: *mut c_void) {
            drop(Box::from_raw(p.cast::<F>()));
        }

        unsafe fn expect_utf8<'a>(p_str: *const c_char, description: &'static str) -> &'a str {
            expect_optional_utf8(p_str, description)
                .unwrap_or_else(|| panic!("received empty {description}"))
        }

        unsafe fn expect_optional_utf8<'a>(
            p_str: *const c_char,
            description: &'static str,
        ) -> Option<&'a str> {
            if p_str.is_null() {
                return None;
            }
            std::ffi::CStr::from_ptr(p_str)
                .to_str()
                .unwrap_or_else(|_| panic!("received non-utf8 string as {description}"))
                .into()
        }
    }

    mod inner_connection
    {
        use ::
        {
            *,
        };
        use std::ffi::CStr;
        use std::os::raw::{c_char, c_int};
        #[cfg(feature = "load_extension")]
        use std::path::Path;
        use std::ptr;
        use std::str;
        use std::sync::{Arc, Mutex};

        use super::ffi;
        use super::str_for_sqlite;
        use super::{Connection, InterruptHandle, OpenFlags, PrepFlags, Result};
        use crate::error::{error_from_handle, error_from_sqlite_code, error_with_offset, Error};
        use crate::raw_statement::RawStatement;
        use crate::statement::Statement;
        use crate::version_number;

        pub struct InnerConnection {
            pub db: *mut ffi::sqlite3,
            // It's unsafe to call `sqlite3_close` while another thread is performing
            // a `sqlite3_interrupt`, and vice versa, so we take this mutex during
            // those functions. This protects a copy of the `db` pointer (which is
            // cleared on closing), however the main copy, `db`, is unprotected.
            // Otherwise, a long-running query would prevent calling interrupt, as
            // interrupt would only acquire the lock after the query's completion.
            interrupt_lock: Arc<Mutex<*mut ffi::sqlite3>>,
            #[cfg(feature = "hooks")]
            pub free_commit_hook: Option<unsafe fn(*mut std::os::raw::c_void)>,
            #[cfg(feature = "hooks")]
            pub free_rollback_hook: Option<unsafe fn(*mut std::os::raw::c_void)>,
            #[cfg(feature = "hooks")]
            pub free_update_hook: Option<unsafe fn(*mut std::os::raw::c_void)>,
            #[cfg(feature = "hooks")]
            pub progress_handler: Option<Box<dyn FnMut() -> bool + Send>>,
            #[cfg(feature = "hooks")]
            pub authorizer: Option<crate::hooks::BoxedAuthorizer>,
            #[cfg(feature = "preupdate_hook")]
            pub free_preupdate_hook: Option<unsafe fn(*mut ::std::os::raw::c_void)>,
            owned: bool,
        }

        unsafe impl Send for InnerConnection {}

        impl InnerConnection {
            #[allow(clippy::mutex_atomic, clippy::arc_with_non_send_sync)] // See unsafe impl Send / Sync for InterruptHandle
            #[inline]
            pub unsafe fn new(db: *mut ffi::sqlite3, owned: bool) -> InnerConnection {
                InnerConnection {
                    db,
                    interrupt_lock: Arc::new(Mutex::new(db)),
                    #[cfg(feature = "hooks")]
                    free_commit_hook: None,
                    #[cfg(feature = "hooks")]
                    free_rollback_hook: None,
                    #[cfg(feature = "hooks")]
                    free_update_hook: None,
                    #[cfg(feature = "hooks")]
                    progress_handler: None,
                    #[cfg(feature = "hooks")]
                    authorizer: None,
                    #[cfg(feature = "preupdate_hook")]
                    free_preupdate_hook: None,
                    owned,
                }
            }

            pub fn open_with_flags(
                c_path: &CStr,
                mut flags: OpenFlags,
                vfs: Option<&CStr>,
            ) -> Result<InnerConnection> {
                ensure_safe_sqlite_threading_mode()?;

                let z_vfs = match vfs {
                    Some(c_vfs) => c_vfs.as_ptr(),
                    None => ptr::null(),
                };

                // turn on extended results code before opening database to have a better diagnostic if a failure happens
                let exrescode = if version_number() >= 3_037_000 {
                    flags |= OpenFlags::SQLITE_OPEN_EXRESCODE;
                    true
                } else {
                    false // flag SQLITE_OPEN_EXRESCODE is ignored by SQLite version < 3.37.0
                };

                unsafe {
                    let mut db: *mut ffi::sqlite3 = ptr::null_mut();
                    let r = ffi::sqlite3_open_v2(c_path.as_ptr(), &mut db, flags.bits(), z_vfs);
                    if r != ffi::SQLITE_OK {
                        let e = if db.is_null() {
                            error_from_sqlite_code(r, Some(c_path.to_string_lossy().to_string()))
                        } else {
                            let mut e = error_from_handle(db, r);
                            if let Error::SqliteFailure(
                                ffi::Error {
                                    code: ffi::ErrorCode::CannotOpen,
                                    ..
                                },
                                Some(msg),
                            ) = e
                            {
                                e = Error::SqliteFailure(
                                    ffi::Error::new(r),
                                    Some(format!("{msg}: {}", c_path.to_string_lossy())),
                                );
                            }
                            ffi::sqlite3_close(db);
                            e
                        };

                        return Err(e);
                    }

                    // attempt to turn on extended results code; don't fail if we can't.
                    if !exrescode {
                        ffi::sqlite3_extended_result_codes(db, 1);
                    }

                    let r = ffi::sqlite3_busy_timeout(db, 5000);
                    if r != ffi::SQLITE_OK {
                        let e = error_from_handle(db, r);
                        ffi::sqlite3_close(db);
                        return Err(e);
                    }

                    Ok(InnerConnection::new(db, true))
                }
            }

            #[inline]
            pub fn db(&self) -> *mut ffi::sqlite3 {
                self.db
            }

            #[inline]
            pub fn decode_result(&self, code: c_int) -> Result<()> {
                unsafe { InnerConnection::decode_result_raw(self.db(), code) }
            }

            #[inline]
            unsafe fn decode_result_raw(db: *mut ffi::sqlite3, code: c_int) -> Result<()> {
                if code == ffi::SQLITE_OK {
                    Ok(())
                } else {
                    Err(error_from_handle(db, code))
                }
            }

            #[allow(clippy::mutex_atomic)]
            pub fn close(&mut self) -> Result<()> {
                if self.db.is_null() {
                    return Ok(());
                }
                self.remove_hooks();
                self.remove_preupdate_hook();
                let mut shared_handle = self.interrupt_lock.lock().unwrap();
                assert!(
                    !shared_handle.is_null(),
                    "Bug: Somehow interrupt_lock was cleared before the DB was closed"
                );
                if !self.owned {
                    self.db = ptr::null_mut();
                    return Ok(());
                }
                unsafe {
                    let r = ffi::sqlite3_close(self.db);
                    // Need to use _raw because _guard has a reference out, and
                    // decode_result takes &mut self.
                    let r = InnerConnection::decode_result_raw(self.db, r);
                    if r.is_ok() {
                        *shared_handle = ptr::null_mut();
                        self.db = ptr::null_mut();
                    }
                    r
                }
            }

            #[inline]
            pub fn get_interrupt_handle(&self) -> InterruptHandle {
                InterruptHandle {
                    db_lock: Arc::clone(&self.interrupt_lock),
                }
            }

            #[inline]
            #[cfg(feature = "load_extension")]
            pub unsafe fn enable_load_extension(&mut self, onoff: c_int) -> Result<()> {
                let r = ffi::sqlite3_enable_load_extension(self.db, onoff);
                self.decode_result(r)
            }

            #[cfg(feature = "load_extension")]
            pub unsafe fn load_extension(
                &self,
                dylib_path: &Path,
                entry_point: Option<&str>,
            ) -> Result<()> {
                let dylib_str = super::path_to_cstring(dylib_path)?;
                let mut errmsg: *mut c_char = ptr::null_mut();
                let r = if let Some(entry_point) = entry_point {
                    let c_entry = crate::str_to_cstring(entry_point)?;
                    ffi::sqlite3_load_extension(self.db, dylib_str.as_ptr(), c_entry.as_ptr(), &mut errmsg)
                } else {
                    ffi::sqlite3_load_extension(self.db, dylib_str.as_ptr(), ptr::null(), &mut errmsg)
                };
                if r == ffi::SQLITE_OK {
                    Ok(())
                } else {
                    let message = super::errmsg_to_string(errmsg);
                    ffi::sqlite3_free(errmsg.cast::<std::os::raw::c_void>());
                    Err(error_from_sqlite_code(r, Some(message)))
                }
            }

            #[inline]
            pub fn last_insert_rowid(&self) -> i64 {
                unsafe { ffi::sqlite3_last_insert_rowid(self.db()) }
            }

            pub fn prepare<'a>(
                &mut self,
                conn: &'a Connection,
                sql: &str,
                flags: PrepFlags,
            ) -> Result<Statement<'a>> {
                let mut c_stmt: *mut ffi::sqlite3_stmt = ptr::null_mut();
                let (c_sql, len, _) = str_for_sqlite(sql.as_bytes())?;
                let mut c_tail: *const c_char = ptr::null();
                #[cfg(not(feature = "unlock_notify"))]
                let r = unsafe { self.prepare_(c_sql, len, flags, &mut c_stmt, &mut c_tail) };
                #[cfg(feature = "unlock_notify")]
                let r = unsafe {
                    use crate::unlock_notify;
                    let mut rc;
                    loop {
                        rc = self.prepare_(c_sql, len, flags, &mut c_stmt, &mut c_tail);
                        if !unlock_notify::is_locked(self.db, rc) {
                            break;
                        }
                        rc = unlock_notify::wait_for_unlock_notify(self.db);
                        if rc != ffi::SQLITE_OK {
                            break;
                        }
                    }
                    rc
                };
                // If there is an error, *ppStmt is set to NULL.
                if r != ffi::SQLITE_OK {
                    return Err(unsafe { error_with_offset(self.db, r, sql) });
                }
                // If the input text contains no SQL (if the input is an empty string or a
                // comment) then *ppStmt is set to NULL.
                let tail = if c_tail.is_null() {
                    0
                } else {
                    let n = (c_tail as isize) - (c_sql as isize);
                    if n <= 0 || n >= len as isize {
                        0
                    } else {
                        n as usize
                    }
                };
                Ok(Statement::new(conn, unsafe {
                    RawStatement::new(c_stmt, tail)
                }))
            }

            #[inline]
            #[cfg(not(feature = "modern_sqlite"))]
            unsafe fn prepare_(
                &self,
                z_sql: *const c_char,
                n_byte: c_int,
                _: PrepFlags,
                pp_stmt: *mut *mut ffi::sqlite3_stmt,
                pz_tail: *mut *const c_char,
            ) -> c_int {
                ffi::sqlite3_prepare_v2(self.db(), z_sql, n_byte, pp_stmt, pz_tail)
            }

            #[inline]
            #[cfg(feature = "modern_sqlite")]
            unsafe fn prepare_(
                &self,
                z_sql: *const c_char,
                n_byte: c_int,
                flags: PrepFlags,
                pp_stmt: *mut *mut ffi::sqlite3_stmt,
                pz_tail: *mut *const c_char,
            ) -> c_int {
                ffi::sqlite3_prepare_v3(self.db(), z_sql, n_byte, flags.bits(), pp_stmt, pz_tail)
            }

            #[inline]
            pub fn changes(&self) -> u64 {
                #[cfg(not(feature = "modern_sqlite"))]
                unsafe {
                    ffi::sqlite3_changes(self.db()) as u64
                }
                #[cfg(feature = "modern_sqlite")] // 3.37.0
                unsafe {
                    ffi::sqlite3_changes64(self.db()) as u64
                }
            }

            #[inline]
            pub fn total_changes(&self) -> u64 {
                #[cfg(not(feature = "modern_sqlite"))]
                unsafe {
                    ffi::sqlite3_total_changes(self.db()) as u64
                }
                #[cfg(feature = "modern_sqlite")] // 3.37.0
                unsafe {
                    ffi::sqlite3_total_changes64(self.db()) as u64
                }
            }

            #[inline]
            pub fn is_autocommit(&self) -> bool {
                unsafe { ffi::sqlite3_get_autocommit(self.db()) != 0 }
            }

            pub fn is_busy(&self) -> bool {
                let db = self.db();
                unsafe {
                    let mut stmt = ffi::sqlite3_next_stmt(db, ptr::null_mut());
                    while !stmt.is_null() {
                        if ffi::sqlite3_stmt_busy(stmt) != 0 {
                            return true;
                        }
                        stmt = ffi::sqlite3_next_stmt(db, stmt);
                    }
                }
                false
            }

            pub fn cache_flush(&mut self) -> Result<()> {
                crate::error::check(unsafe { ffi::sqlite3_db_cacheflush(self.db()) })
            }

            #[cfg(not(feature = "hooks"))]
            #[inline]
            fn remove_hooks(&mut self) {}

            #[cfg(not(feature = "preupdate_hook"))]
            #[inline]
            fn remove_preupdate_hook(&mut self) {}

            pub fn db_readonly(&self, db_name: super::DatabaseName<'_>) -> Result<bool> {
                let name = db_name.as_cstring()?;
                let r = unsafe { ffi::sqlite3_db_readonly(self.db, name.as_ptr()) };
                match r {
                    0 => Ok(false),
                    1 => Ok(true),
                    -1 => Err(Error::SqliteFailure(
                        ffi::Error::new(ffi::SQLITE_MISUSE),
                        Some(format!("{db_name:?} is not the name of a database")),
                    )),
                    _ => Err(error_from_sqlite_code(
                        r,
                        Some("Unexpected result".to_owned()),
                    )),
                }
            }

            #[cfg(feature = "modern_sqlite")] // 3.37.0
            pub fn txn_state(
                &self,
                db_name: Option<super::DatabaseName<'_>>,
            ) -> Result<super::transaction::TransactionState> {
                let r = if let Some(ref name) = db_name {
                    let name = name.as_cstring()?;
                    unsafe { ffi::sqlite3_txn_state(self.db, name.as_ptr()) }
                } else {
                    unsafe { ffi::sqlite3_txn_state(self.db, ptr::null()) }
                };
                match r {
                    0 => Ok(super::transaction::TransactionState::None),
                    1 => Ok(super::transaction::TransactionState::Read),
                    2 => Ok(super::transaction::TransactionState::Write),
                    -1 => Err(Error::SqliteFailure(
                        ffi::Error::new(ffi::SQLITE_MISUSE),
                        Some(format!("{db_name:?} is not the name of a valid schema")),
                    )),
                    _ => Err(error_from_sqlite_code(
                        r,
                        Some("Unexpected result".to_owned()),
                    )),
                }
            }

            #[inline]
            #[cfg(feature = "release_memory")]
            pub fn release_memory(&self) -> Result<()> {
                self.decode_result(unsafe { ffi::sqlite3_db_release_memory(self.db) })
            }

            #[cfg(feature = "modern_sqlite")] // 3.41.0
            pub fn is_interrupted(&self) -> bool {
                unsafe { ffi::sqlite3_is_interrupted(self.db) == 1 }
            }
        }

        impl Drop for InnerConnection {
            #[allow(unused_must_use)]
            #[inline]
            fn drop(&mut self) {
                self.close();
            }
        }
        
        fn ensure_safe_sqlite_threading_mode() -> Result<()> {
            if unsafe { ffi::sqlite3_threadsafe() == 0 } {
                return Err(Error::SqliteSingleThreadedMode);
            }

            const SQLITE_SINGLETHREADED_MUTEX_MAGIC: usize = 8;
            let is_singlethreaded = unsafe {
                let mutex_ptr = ffi::sqlite3_mutex_alloc(0);
                let is_singlethreaded = mutex_ptr as usize == SQLITE_SINGLETHREADED_MUTEX_MAGIC;
                ffi::sqlite3_mutex_free(mutex_ptr);
                is_singlethreaded
            };
            if is_singlethreaded {
                Err(Error::SqliteSingleThreadedMode)
            } else {
                Ok(())
            }
        }
    }
    
    pub mod limits
    {
        //! Run-Time Limits
        use ::
        {
            *,
        };
        

        use crate::{ffi, Connection};
        use std::os::raw::c_int;

        /// Run-Time limit categories, for use with [`Connection::limit`] and
        /// [`Connection::set_limit`].
        ///
        /// See the official documentation for more information:
        /// - <https://www.sqlite.org/c3ref/c_limit_attached.html>
        /// - <https://www.sqlite.org/limits.html>
        #[derive(Copy, Clone, Debug)]
        #[repr(i32)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms, non_camel_case_types)]
        #[cfg_attr(docsrs, doc(cfg(feature = "limits")))]
        pub enum Limit {
            /// The maximum size of any string or BLOB or table row, in bytes.
            SQLITE_LIMIT_LENGTH = ffi::SQLITE_LIMIT_LENGTH,
            /// The maximum length of an SQL statement, in bytes.
            SQLITE_LIMIT_SQL_LENGTH = ffi::SQLITE_LIMIT_SQL_LENGTH,
            /// The maximum number of columns in a table definition or in the result set
            /// of a SELECT or the maximum number of columns in an index or in an
            /// ORDER BY or GROUP BY clause.
            SQLITE_LIMIT_COLUMN = ffi::SQLITE_LIMIT_COLUMN,
            /// The maximum depth of the parse tree on any expression.
            SQLITE_LIMIT_EXPR_DEPTH = ffi::SQLITE_LIMIT_EXPR_DEPTH,
            /// The maximum number of terms in a compound SELECT statement.
            SQLITE_LIMIT_COMPOUND_SELECT = ffi::SQLITE_LIMIT_COMPOUND_SELECT,
            /// The maximum number of instructions in a virtual machine program used to
            /// implement an SQL statement.
            SQLITE_LIMIT_VDBE_OP = ffi::SQLITE_LIMIT_VDBE_OP,
            /// The maximum number of arguments on a function.
            SQLITE_LIMIT_FUNCTION_ARG = ffi::SQLITE_LIMIT_FUNCTION_ARG,
            /// The maximum number of attached databases.
            SQLITE_LIMIT_ATTACHED = ffi::SQLITE_LIMIT_ATTACHED,
            /// The maximum length of the pattern argument to the LIKE or GLOB
            /// operators.
            SQLITE_LIMIT_LIKE_PATTERN_LENGTH = ffi::SQLITE_LIMIT_LIKE_PATTERN_LENGTH,
            /// The maximum index number of any parameter in an SQL statement.
            SQLITE_LIMIT_VARIABLE_NUMBER = ffi::SQLITE_LIMIT_VARIABLE_NUMBER,
            /// The maximum depth of recursion for triggers.
            SQLITE_LIMIT_TRIGGER_DEPTH = ffi::SQLITE_LIMIT_TRIGGER_DEPTH,
            /// The maximum number of auxiliary worker threads that a single prepared
            /// statement may start.
            SQLITE_LIMIT_WORKER_THREADS = ffi::SQLITE_LIMIT_WORKER_THREADS,
        }

        impl Connection {
            /// Returns the current value of a [`Limit`].
            #[inline]
            #[cfg_attr(docsrs, doc(cfg(feature = "limits")))]
            pub fn limit(&self, limit: Limit) -> i32 {
                let c = self.db.borrow();
                unsafe { ffi::sqlite3_limit(c.db(), limit as c_int, -1) }
            }
            /// Changes the [`Limit`] to `new_val`, returning the prior
            /// value of the limit.
            #[inline]
            #[cfg_attr(docsrs, doc(cfg(feature = "limits")))]
            pub fn set_limit(&self, limit: Limit, new_val: i32) -> i32 {
                let c = self.db.borrow_mut();
                unsafe { ffi::sqlite3_limit(c.db(), limit as c_int, new_val) }
            }
        }
    }

    mod params
    {
        use ::
        {
            *,
        };
        use crate::{Result, Statement, ToSql};

        mod sealed {
            /// This trait exists just to ensure that the only impls of `trait Params`
            /// that are allowed are ones in this crate.
            pub trait Sealed {}
        }
        use sealed::Sealed;

        /// Trait used for [sets of parameter][params] passed into SQL statements/queries.
        pub trait Params: Sealed {
            // XXX not public api, might not need to expose.
            //
            // Binds the parameters to the statement. It is unlikely calling this
            // explicitly will do what you want. Please use `Statement::query` or
            // similar directly.
            //
            // For now, just hide the function in the docs...
            #[doc(hidden)]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()>;
        }
        
        impl Sealed for [&(dyn ToSql + Send + Sync); 0] {}
        impl Params for [&(dyn ToSql + Send + Sync); 0] {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.ensure_parameter_count(0)
            }
        }

        impl Sealed for &[&dyn ToSql] {}
        impl Params for &[&dyn ToSql] {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.bind_parameters(self)
            }
        }

        impl Sealed for &[(&str, &dyn ToSql)] {}
        impl Params for &[(&str, &dyn ToSql)] {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.bind_parameters_named(self)
            }
        }
        
        impl Sealed for () {}
        impl Params for () {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.ensure_parameter_count(0)
            }
        }
        
        impl<T: ToSql> Sealed for (T,) {}
        impl<T: ToSql> Params for (T,) {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.ensure_parameter_count(1)?;
                stmt.raw_bind_parameter(1, self.0)?;
                Ok(())
            }
        }

        macro_rules! single_tuple_impl {
            ($count:literal : $(($field:tt $ftype:ident)),* $(,)?) => {
                impl<$($ftype,)*> Sealed for ($($ftype,)*) where $($ftype: ToSql,)* {}
                impl<$($ftype,)*> Params for ($($ftype,)*) where $($ftype: ToSql,)* {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.ensure_parameter_count($count)?;
                        $({
                            debug_assert!($field < $count);
                            stmt.raw_bind_parameter($field + 1, self.$field)?;
                        })+
                        Ok(())
                    }
                }
            }
        }
        
        single_tuple_impl!(2: (0 A), (1 B));
        single_tuple_impl!(3: (0 A), (1 B), (2 C));
        single_tuple_impl!(4: (0 A), (1 B), (2 C), (3 D));
        single_tuple_impl!(5: (0 A), (1 B), (2 C), (3 D), (4 E));
        single_tuple_impl!(6: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F));
        single_tuple_impl!(7: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G));
        single_tuple_impl!(8: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H));
        single_tuple_impl!(9: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I));
        single_tuple_impl!(10: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J));
        single_tuple_impl!(11: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K));
        single_tuple_impl!(12: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L));
        single_tuple_impl!(13: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M));
        single_tuple_impl!(14: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N));
        single_tuple_impl!(15: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N), (14 O));
        single_tuple_impl!(16: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N), (14 O), (15 P));

        macro_rules! impl_for_array_ref {
            ($($N:literal)+) => {$(
                // These are already generic, and there's a shedload of them, so lets
                // avoid the compile time hit from making them all inline for now.
                impl<T: ToSql + ?Sized> Sealed for &[&T; $N] {}
                impl<T: ToSql + ?Sized> Params for &[&T; $N] {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters(self)
                    }
                }
                impl<T: ToSql + ?Sized> Sealed for &[(&str, &T); $N] {}
                impl<T: ToSql + ?Sized> Params for &[(&str, &T); $N] {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters_named(self)
                    }
                }
                impl<T: ToSql> Sealed for [T; $N] {}
                impl<T: ToSql> Params for [T; $N] {
                    #[inline]
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters(&self)
                    }
                }
            )+};
        }
        
        impl_for_array_ref!(
            1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
            18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
        );

        /// Adapter type which allows any iterator over [`ToSql`] values to implement [`Params`].
        #[derive(Clone, Debug)]
        pub struct ParamsFromIter<I>(I);

        /// Constructor function for a [`ParamsFromIter`]. See its documentation for more.
        #[inline]
        pub fn params_from_iter<I>(iter: I) -> ParamsFromIter<I>
        where
            I: IntoIterator,
            I::Item: ToSql,
        {
            ParamsFromIter(iter)
        }

        impl<I> Sealed for ParamsFromIter<I>
        where
            I: IntoIterator,
            I::Item: ToSql,
        {
        }

        impl<I> Params for ParamsFromIter<I>
        where
            I: IntoIterator,
            I::Item: ToSql,
        {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.bind_parameters(self.0)
            }
        }
    }

    mod pragma
    {
        //! Pragma helpers
        use ::
        {
            *,
        };
        

        use std::ops::Deref;

        use crate::error::Error;
        use crate::ffi;
        use crate::types::{ToSql, ToSqlOutput, ValueRef};
        use crate::{Connection, DatabaseName, Result, Row};

        pub struct Sql {
            buf: String,
        }

        impl Sql {
            pub fn new() -> Sql {
                Sql { buf: String::new() }
            }

            pub fn push_pragma(
                &mut self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
            ) -> Result<()> {
                self.push_keyword("PRAGMA")?;
                self.push_space();
                if let Some(schema_name) = schema_name {
                    self.push_schema_name(schema_name);
                    self.push_dot();
                }
                self.push_keyword(pragma_name)
            }

            pub fn push_keyword(&mut self, keyword: &str) -> Result<()> {
                if !keyword.is_empty() && is_identifier(keyword) {
                    self.buf.push_str(keyword);
                    Ok(())
                } else {
                    Err(Error::SqliteFailure(
                        ffi::Error::new(ffi::SQLITE_MISUSE),
                        Some(format!("Invalid keyword \"{keyword}\"")),
                    ))
                }
            }

            pub fn push_schema_name(&mut self, schema_name: DatabaseName<'_>) {
                match schema_name {
                    DatabaseName::Main => self.buf.push_str("main"),
                    DatabaseName::Temp => self.buf.push_str("temp"),
                    DatabaseName::Attached(s) => self.push_identifier(s),
                };
            }

            pub fn push_identifier(&mut self, s: &str) {
                if is_identifier(s) {
                    self.buf.push_str(s);
                } else {
                    self.wrap_and_escape(s, '"');
                }
            }

            pub fn push_value(&mut self, value: &dyn ToSql) -> Result<()> {
                let value = value.to_sql()?;
                let value = match value {
                    ToSqlOutput::Borrowed(v) => v,
                    ToSqlOutput::Owned(ref v) => ValueRef::from(v),
                    #[cfg(feature = "blob")]
                    ToSqlOutput::ZeroBlob(_) => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                    #[cfg(feature = "functions")]
                    ToSqlOutput::Arg(_) => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                    #[cfg(feature = "array")]
                    ToSqlOutput::Array(_) => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                };
                match value {
                    ValueRef::Integer(i) => {
                        self.push_int(i);
                    }
                    ValueRef::Real(r) => {
                        self.push_real(r);
                    }
                    ValueRef::Text(s) => {
                        let s = std::str::from_utf8(s)?;
                        self.push_string_literal(s);
                    }
                    _ => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                };
                Ok(())
            }

            pub fn push_string_literal(&mut self, s: &str) {
                self.wrap_and_escape(s, '\'');
            }

            pub fn push_int(&mut self, i: i64) {
                self.buf.push_str(&i.to_string());
            }

            pub fn push_real(&mut self, f: f64) {
                self.buf.push_str(&f.to_string());
            }

            pub fn push_space(&mut self) {
                self.buf.push(' ');
            }

            pub fn push_dot(&mut self) {
                self.buf.push('.');
            }

            pub fn push_equal_sign(&mut self) {
                self.buf.push('=');
            }

            pub fn open_brace(&mut self) {
                self.buf.push('(');
            }

            pub fn close_brace(&mut self) {
                self.buf.push(')');
            }

            pub fn as_str(&self) -> &str {
                &self.buf
            }

            fn wrap_and_escape(&mut self, s: &str, quote: char) {
                self.buf.push(quote);
                let chars = s.chars();
                for ch in chars {
                    // escape `quote` by doubling it
                    if ch == quote {
                        self.buf.push(ch);
                    }
                    self.buf.push(ch);
                }
                self.buf.push(quote);
            }
        }

        impl Deref for Sql {
            type Target = str;

            fn deref(&self) -> &str {
                self.as_str()
            }
        }

        impl Connection {
            /// Query the current value of `pragma_name`.
            ///
            /// Some pragmas will return multiple rows/values which cannot be retrieved
            /// with this method.
            ///
            /// Prefer [PRAGMA function](https://sqlite.org/pragma.html#pragfunc) introduced in SQLite 3.20:
            /// `SELECT user_version FROM pragma_user_version;`
            pub fn pragma_query_value<T, F>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                f: F,
            ) -> Result<T>
            where
                F: FnOnce(&Row<'_>) -> Result<T>,
            {
                let mut query = Sql::new();
                query.push_pragma(schema_name, pragma_name)?;
                self.query_row(&query, [], f)
            }
            /// Query the current rows/values of `pragma_name`.
            ///
            /// Prefer [PRAGMA function](https://sqlite.org/pragma.html#pragfunc) introduced in SQLite 3.20:
            /// `SELECT * FROM pragma_collation_list;`
            pub fn pragma_query<F>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                mut f: F,
            ) -> Result<()>
            where
                F: FnMut(&Row<'_>) -> Result<()>,
            {
                let mut query = Sql::new();
                query.push_pragma(schema_name, pragma_name)?;
                let mut stmt = self.prepare(&query)?;
                let mut rows = stmt.query([])?;
                while let Some(result_row) = rows.next()? {
                    let row = result_row;
                    f(row)?;
                }
                Ok(())
            }
            /// Query the current value(s) of `pragma_name` associated to
            /// `pragma_value`.
            ///
            /// This method can be used with query-only pragmas which need an argument
            /// (e.g. `table_info('one_tbl')`) or pragmas which returns value(s)
            /// (e.g. `integrity_check`).
            ///
            /// Prefer [PRAGMA function](https://sqlite.org/pragma.html#pragfunc) introduced in SQLite 3.20:
            /// `SELECT * FROM pragma_table_info(?1);`
            pub fn pragma<F, V>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                pragma_value: V,
                mut f: F,
            ) -> Result<()>
            where
                F: FnMut(&Row<'_>) -> Result<()>,
                V: ToSql,
            {
                let mut sql = Sql::new();
                sql.push_pragma(schema_name, pragma_name)?;
                // The argument may be either in parentheses
                // or it may be separated from the pragma name by an equal sign.
                // The two syntaxes yield identical results.
                sql.open_brace();
                sql.push_value(&pragma_value)?;
                sql.close_brace();
                let mut stmt = self.prepare(&sql)?;
                let mut rows = stmt.query([])?;
                while let Some(result_row) = rows.next()? {
                    let row = result_row;
                    f(row)?;
                }
                Ok(())
            }
            /// Set a new value to `pragma_name`.
            ///
            /// Some pragmas will return the updated value which cannot be retrieved
            /// with this method.
            pub fn pragma_update<V>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                pragma_value: V,
            ) -> Result<()>
            where
                V: ToSql,
            {
                let mut sql = Sql::new();
                sql.push_pragma(schema_name, pragma_name)?;
                // The argument may be either in parentheses
                // or it may be separated from the pragma name by an equal sign.
                // The two syntaxes yield identical results.
                sql.push_equal_sign();
                sql.push_value(&pragma_value)?;
                self.execute_batch(&sql)
            }
            /// Set a new value to `pragma_name` and return the updated value.
            ///
            /// Only few pragmas automatically return the updated value.
            pub fn pragma_update_and_check<F, T, V>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                pragma_value: V,
                f: F,
            ) -> Result<T>
            where
                F: FnOnce(&Row<'_>) -> Result<T>,
                V: ToSql,
            {
                let mut sql = Sql::new();
                sql.push_pragma(schema_name, pragma_name)?;
                // The argument may be either in parentheses
                // or it may be separated from the pragma name by an equal sign.
                // The two syntaxes yield identical results.
                sql.push_equal_sign();
                sql.push_value(&pragma_value)?;
                self.query_row(&sql, [], f)
            }
        }

        fn is_identifier(s: &str) -> bool {
            let chars = s.char_indices();
            for (i, ch) in chars {
                if i == 0 {
                    if !is_identifier_start(ch) {
                        return false;
                    }
                } else if !is_identifier_continue(ch) {
                    return false;
                }
            }
            true
        }

        fn is_identifier_start(c: char) -> bool {
            c.is_ascii_uppercase() || c == '_' || c.is_ascii_lowercase() || c > '\x7F'
        }

        fn is_identifier_continue(c: char) -> bool {
            c == '$'
                || c.is_ascii_digit()
                || c.is_ascii_uppercase()
                || c == '_'
                || c.is_ascii_lowercase()
                || c > '\x7F'
        }
    }

    mod raw_statement
    {
        use ::
        {
            *,
        };
        use super::ffi;
        use super::StatementStatus;
        use crate::util::ParamIndexCache;
        use crate::util::SqliteMallocString;
        use std::ffi::CStr;
        use std::os::raw::c_int;
        use std::ptr;
        use std::sync::Arc;

        // Private newtype for raw sqlite3_stmts that finalize themselves when dropped.
        #[derive(Debug)]
        pub struct RawStatement {
            ptr: *mut ffi::sqlite3_stmt,
            tail: usize,
            // Cached indices of named parameters, computed on the fly.
            cache: ParamIndexCache,
            // Cached SQL (trimmed) that we use as the key when we're in the statement
            // cache. This is None for statements which didn't come from the statement
            // cache.
            //
            // This is probably the same as `self.sql()` in most cases, but we don't
            // care either way -- It's a better cache key as it is anyway since it's the
            // actual source we got from rust.
            //
            // One example of a case where the result of `sqlite_sql` and the value in
            // `statement_cache_key` might differ is if the statement has a `tail`.
            statement_cache_key: Option<Arc<str>>,
        }

        impl RawStatement {
            #[inline]
            pub unsafe fn new(stmt: *mut ffi::sqlite3_stmt, tail: usize) -> RawStatement {
                RawStatement {
                    ptr: stmt,
                    tail,
                    cache: ParamIndexCache::default(),
                    statement_cache_key: None,
                }
            }

            #[inline]
            pub fn is_null(&self) -> bool {
                self.ptr.is_null()
            }

            #[inline]
            pub fn set_statement_cache_key(&mut self, p: impl Into<Arc<str>>) {
                self.statement_cache_key = Some(p.into());
            }

            #[inline]
            pub fn statement_cache_key(&self) -> Option<Arc<str>> {
                self.statement_cache_key.clone()
            }

            #[inline]
            pub unsafe fn ptr(&self) -> *mut ffi::sqlite3_stmt {
                self.ptr
            }

            #[inline]
            pub fn column_count(&self) -> usize {
                // Note: Can't cache this as it changes if the schema is altered.
                unsafe { ffi::sqlite3_column_count(self.ptr) as usize }
            }

            #[inline]
            pub fn column_type(&self, idx: usize) -> c_int {
                unsafe { ffi::sqlite3_column_type(self.ptr, idx as c_int) }
            }

            #[inline]
            #[cfg(feature = "column_decltype")]
            pub fn column_decltype(&self, idx: usize) -> Option<&CStr> {
                unsafe {
                    let decltype = ffi::sqlite3_column_decltype(self.ptr, idx as c_int);
                    if decltype.is_null() {
                        None
                    } else {
                        Some(CStr::from_ptr(decltype))
                    }
                }
            }

            #[inline]
            pub fn column_name(&self, idx: usize) -> Option<&CStr> {
                let idx = idx as c_int;
                if idx < 0 || idx >= self.column_count() as c_int {
                    return None;
                }
                unsafe {
                    let ptr = ffi::sqlite3_column_name(self.ptr, idx);
                    // If ptr is null here, it's an OOM, so there's probably nothing
                    // meaningful we can do. Just assert instead of returning None.
                    assert!(
                        !ptr.is_null(),
                        "Null pointer from sqlite3_column_name: Out of memory?"
                    );
                    Some(CStr::from_ptr(ptr))
                }
            }

            #[inline]
            #[cfg(not(feature = "unlock_notify"))]
            pub fn step(&self) -> c_int {
                unsafe { ffi::sqlite3_step(self.ptr) }
            }

            #[cfg(feature = "unlock_notify")]
            pub fn step(&self) -> c_int {
                use crate::unlock_notify;
                let mut db = ptr::null_mut::<ffi::sqlite3>();
                loop {
                    unsafe {
                        let mut rc = ffi::sqlite3_step(self.ptr);
                        // Bail out early for success and errors unrelated to locking. We
                        // still need check `is_locked` after this, but checking now lets us
                        // avoid one or two (admittedly cheap) calls into SQLite that we
                        // don't need to make.
                        if (rc & 0xff) != ffi::SQLITE_LOCKED {
                            break rc;
                        }
                        if db.is_null() {
                            db = ffi::sqlite3_db_handle(self.ptr);
                        }
                        if !unlock_notify::is_locked(db, rc) {
                            break rc;
                        }
                        rc = unlock_notify::wait_for_unlock_notify(db);
                        if rc != ffi::SQLITE_OK {
                            break rc;
                        }
                        self.reset();
                    }
                }
            }

            #[inline]
            pub fn reset(&self) -> c_int {
                unsafe { ffi::sqlite3_reset(self.ptr) }
            }

            #[inline]
            pub fn bind_parameter_count(&self) -> usize {
                unsafe { ffi::sqlite3_bind_parameter_count(self.ptr) as usize }
            }

            #[inline]
            pub fn bind_parameter_index(&self, name: &str) -> Option<usize> {
                self.cache.get_or_insert_with(name, |param_cstr| {
                    let r = unsafe { ffi::sqlite3_bind_parameter_index(self.ptr, param_cstr.as_ptr()) };
                    match r {
                        0 => None,
                        i => Some(i as usize),
                    }
                })
            }

            #[inline]
            pub fn bind_parameter_name(&self, index: i32) -> Option<&CStr> {
                unsafe {
                    let name = ffi::sqlite3_bind_parameter_name(self.ptr, index);
                    if name.is_null() {
                        None
                    } else {
                        Some(CStr::from_ptr(name))
                    }
                }
            }

            #[inline]
            pub fn clear_bindings(&mut self) {
                unsafe {
                    ffi::sqlite3_clear_bindings(self.ptr);
                } // rc is always SQLITE_OK
            }

            #[inline]
            pub fn sql(&self) -> Option<&CStr> {
                if self.ptr.is_null() {
                    None
                } else {
                    Some(unsafe { CStr::from_ptr(ffi::sqlite3_sql(self.ptr)) })
                }
            }

            #[inline]
            pub fn finalize(mut self) -> c_int {
                self.finalize_()
            }

            #[inline]
            fn finalize_(&mut self) -> c_int {
                let r = unsafe { ffi::sqlite3_finalize(self.ptr) };
                self.ptr = ptr::null_mut();
                r
            }

            // does not work for PRAGMA
            #[inline]
            pub fn readonly(&self) -> bool {
                unsafe { ffi::sqlite3_stmt_readonly(self.ptr) != 0 }
            }

            #[inline]
            pub fn expanded_sql(&self) -> Option<SqliteMallocString> {
                unsafe { SqliteMallocString::from_raw(ffi::sqlite3_expanded_sql(self.ptr)) }
            }

            #[inline]
            pub fn get_status(&self, status: StatementStatus, reset: bool) -> i32 {
                assert!(!self.ptr.is_null());
                unsafe { ffi::sqlite3_stmt_status(self.ptr, status as i32, reset as i32) }
            }

            #[inline]
            #[cfg(feature = "extra_check")]
            pub fn has_tail(&self) -> bool {
                self.tail != 0
            }

            #[inline]
            pub fn tail(&self) -> usize {
                self.tail
            }

            #[inline]
            #[cfg(feature = "modern_sqlite")] // 3.28.0
            pub fn is_explain(&self) -> i32 {
                unsafe { ffi::sqlite3_stmt_isexplain(self.ptr) }
            }

            // TODO sqlite3_normalized_sql (https://sqlite.org/c3ref/expanded_sql.html) // 3.27.0 + SQLITE_ENABLE_NORMALIZE
        }

        impl Drop for RawStatement {
            fn drop(&mut self) {
                self.finalize_();
            }
        }
    }

    mod row
    {
        use ::
        {
            *,
        };
        /*
        use fallible_iterator::FallibleIterator;
        use fallible_streaming_iterator::FallibleStreamingIterator;
        use std::convert;

        use super::{Error, Result, Statement};
        use crate::types::{FromSql, FromSqlError, ValueRef}; */

        /// A handle for the resulting rows of a query.
        #[must_use = "Rows is lazy and will do nothing unless consumed"]
        pub struct Rows<'stmt> {
            pub stmt: Option<&'stmt Statement<'stmt>>,
            row: Option<Row<'stmt>>,
        }

        impl<'stmt> Rows<'stmt> {
            #[inline]
            fn reset(&mut self) -> Result<()> {
                if let Some(stmt) = self.stmt.take() {
                    stmt.reset()
                } else {
                    Ok(())
                }
            }
            /// Attempt to get the next row from the query. Returns `Ok(Some(Row))` if
            /// there is another row, `Err(...)` if there was an error
            /// getting the next row, and `Ok(None)` if all rows have been retrieved.
            #[inline]
            pub fn next(&mut self) -> Result<Option<&Row<'stmt>>> {
                self.advance()?;
                Ok((*self).get())
            }
            /// Map over this `Rows`, converting it to a [`Map`], which implements `FallibleIterator`.
            #[inline]
            pub fn map<F, B>(self, f: F) -> Map<'stmt, F>
            where
                F: FnMut(&Row<'_>) -> Result<B>,
            {
                Map { rows: self, f }
            }
            /// Map over this `Rows`, converting it to a [`MappedRows`], which implements `Iterator`.
            #[inline]
            pub fn mapped<F, B>(self, f: F) -> MappedRows<'stmt, F>
            where
                F: FnMut(&Row<'_>) -> Result<B>,
            {
                MappedRows { rows: self, map: f }
            }
            /// Map over this `Rows` with a fallible function, converting it to a
            /// [`AndThenRows`], which implements `Iterator` (instead of
            /// `FallibleStreamingIterator`).
            #[inline]
            pub fn and_then<F, T, E>(self, f: F) -> AndThenRows<'stmt, F>
            where
                F: FnMut(&Row<'_>) -> Result<T, E>,
            {
                AndThenRows { rows: self, map: f }
            }
            /// Give access to the underlying statement
            #[must_use]
            pub fn as_ref(&self) -> Option<&Statement<'stmt>> {
                self.stmt
            }
        }

        impl<'stmt> Rows<'stmt> {
            #[inline]
            pub fn new(stmt: &'stmt Statement<'stmt>) -> Rows<'stmt> {
                Rows {
                    stmt: Some(stmt),
                    row: None,
                }
            }

            #[inline]
            pub fn get_expected_row(&mut self) -> Result<&Row<'stmt>> {
                match self.next()? {
                    Some(row) => Ok(row),
                    None => Err(Error::QueryReturnedNoRows),
                }
            }
        }

        impl Drop for Rows<'_> {
            #[allow(unused_must_use)]
            #[inline]
            fn drop(&mut self) {
                self.reset();
            }
        }
        /// `F` is used to transform the _streaming_ iterator into a _fallible_iterator.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct Map<'stmt, F> {
            rows: Rows<'stmt>,
            f: F,
        }

        impl<F, B> FallibleIterator for Map<'_, F>
        where
            F: FnMut(&Row<'_>) -> Result<B>,
        {
            type Error = Error;
            type Item = B;

            #[inline]
            fn next(&mut self) -> Result<Option<B>> {
                match self.rows.next()? {
                    Some(v) => Ok(Some((self.f)(v)?)),
                    None => Ok(None),
                }
            }
        }
        /// An iterator over the mapped resulting rows of a query.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct MappedRows<'stmt, F> {
            rows: Rows<'stmt>,
            map: F,
        }

        impl<T, F> Iterator for MappedRows<'_, F>
        where
            F: FnMut(&Row<'_>) -> Result<T>,
        {
            type Item = Result<T>;

            #[inline]
            fn next(&mut self) -> Option<Result<T>> {
                let map = &mut self.map;
                self.rows
                    .next()
                    .transpose()
                    .map(|row_result| row_result.and_then(map))
            }
        }
        /// An iterator over the mapped resulting rows of a query, with an Error type unifying with Error.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct AndThenRows<'stmt, F> {
            rows: Rows<'stmt>,
            map: F,
        }

        impl<T, E, F> Iterator for AndThenRows<'_, F> where
        E: From<Error>,
        F: FnMut(&Row<'_>) -> Result<T, E>
        {
            type Item = Result<T, E>;

            #[inline]
            fn next(&mut self) -> Option<Self::Item> {
                let map = &mut self.map;
                self.rows
                    .next()
                    .transpose()
                    .map(|row_result| row_result.map_err(E::from).and_then(map))
            }
        }
        /// `FallibleStreamingIterator` differs from the standard library's `Iterator`
        /// in two ways:
        /// * each call to `next` (`sqlite3_step`) can fail.
        /// * returned `Row` is valid until `next` is called again or `Statement` is
        ///   reset or finalized.
        impl<'stmt> FallibleStreamingIterator for Rows<'stmt> {
            type Error = Error;
            type Item = Row<'stmt>;

            #[inline]
            fn advance(&mut self) -> Result<()> {
                if let Some(stmt) = self.stmt {
                    match stmt.step() {
                        Ok(true) => {
                            self.row = Some(Row { stmt });
                            Ok(())
                        }
                        Ok(false) => {
                            let r = self.reset();
                            self.row = None;
                            r
                        }
                        Err(e) => {
                            let _ = self.reset(); // prevents infinite loop on error
                            self.row = None;
                            Err(e)
                        }
                    }
                } else {
                    self.row = None;
                    Ok(())
                }
            }

            #[inline]
            fn get(&self) -> Option<&Row<'stmt>> {
                self.row.as_ref()
            }
        }
        /// A single result row of a query.
        pub struct Row<'stmt> {
            pub stmt: &'stmt Statement<'stmt>,
        }

        impl<'stmt> Row<'stmt> {
            /// Get the value of a particular column of the result row.
            ///
            /// # Panics
            ///
            /// Panics if calling [`row.get(idx)`](Row::get) would return an error,
            /// including:
            ///
            /// * If the underlying SQLite column type is not a valid type as a source
            ///   for `T`
            /// * If the underlying SQLite integral value is outside the range
            ///   representable by `T`
            /// * If `idx` is outside the range of columns in the returned query
            #[track_caller]
            pub fn get_unwrap<I: RowIndex, T: FromSql>(&self, idx: I) -> T {
                self.get(idx).unwrap()
            }
            /// Get the value of a particular column of the result row.
            ///
            /// ## Failure
            ///
            /// Returns an `Error::InvalidColumnType` if the underlying SQLite column
            /// type is not a valid type as a source for `T`.
            ///
            /// Returns an `Error::InvalidColumnIndex` if `idx` is outside the valid
            /// column range for this row.
            ///
            /// Returns an `Error::InvalidColumnName` if `idx` is not a valid column
            /// name for this row.
            ///
            /// If the result type is i128 (which requires the `i128_blob` feature to be
            /// enabled), and the underlying SQLite column is a blob whose size is not
            /// 16 bytes, `Error::InvalidColumnType` will also be returned.
            #[track_caller]
            pub fn get<I: RowIndex, T: FromSql>(&self, idx: I) -> Result<T> {
                let idx = idx.idx(self.stmt)?;
                let value = self.stmt.value_ref(idx);
                FromSql::column_result(value).map_err(|err| match err {
                    FromSqlError::InvalidType => Error::InvalidColumnType(
                        idx,
                        self.stmt.column_name_unwrap(idx).into(),
                        value.data_type(),
                    ),
                    FromSqlError::OutOfRange(i) => Error::IntegralValueOutOfRange(idx, i),
                    FromSqlError::Other(err) => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), err)
                    }
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), Box::new(err))
                    }
                })
            }
            /// Get the value of a particular column of the result row as a `ValueRef`,
            /// allowing data to be read out of a row without copying.
            ///
            /// This `ValueRef` is valid only as long as this Row, which is enforced by
            /// its lifetime. This means that while this method is completely safe,
            /// it can be somewhat difficult to use, and most callers will be better
            /// served by [`get`](Row::get) or [`get_unwrap`](Row::get_unwrap).
            ///
            /// ## Failure
            ///
            /// Returns an `Error::InvalidColumnIndex` if `idx` is outside the valid
            /// column range for this row.
            ///
            /// Returns an `Error::InvalidColumnName` if `idx` is not a valid column
            /// name for this row.
            pub fn get_ref<I: RowIndex>(&self, idx: I) -> Result<ValueRef<'_>> {
                let idx = idx.idx(self.stmt)?;
                // Narrowing from `ValueRef<'stmt>` (which `self.stmt.value_ref(idx)`
                // returns) to `ValueRef<'a>` is needed because it's only valid until
                // the next call to sqlite3_step.
                let val_ref = self.stmt.value_ref(idx);
                Ok(val_ref)
            }
            /// Get the value of a particular column of the result row as a `ValueRef`,
            /// allowing data to be read out of a row without copying.
            ///
            /// This `ValueRef` is valid only as long as this Row, which is enforced by
            /// its lifetime. This means that while this method is completely safe,
            /// it can be difficult to use, and most callers will be better served by
            /// [`get`](Row::get) or [`get_unwrap`](Row::get_unwrap).
            ///
            /// # Panics
            ///
            /// Panics if calling [`row.get_ref(idx)`](Row::get_ref) would return an
            /// error, including:
            ///
            /// * If `idx` is outside the range of columns in the returned query.
            /// * If `idx` is not a valid column name for this row.
            #[track_caller]
            pub fn get_ref_unwrap<I: RowIndex>(&self, idx: I) -> ValueRef<'_> {
                self.get_ref(idx).unwrap()
            }
        }

        impl<'stmt> AsRef<Statement<'stmt>> for Row<'stmt> {
            fn as_ref(&self) -> &Statement<'stmt> {
                self.stmt
            }
        }
        /// Debug `Row` like an ordered `Map<Result<&str>, Result<(Type, ValueRef)>>`
        /// with column name as key except that for `Type::Blob` only its size is
        /// printed (not its content).
        impl<'stmt> std::fmt::Debug for Row<'stmt> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut dm = f.debug_map();
                for c in 0..self.stmt.column_count() {
                    let name = self.stmt.column_name(c).expect("valid column index");
                    dm.key(&name);
                    let value = self.get_ref(c);
                    match value {
                        Ok(value) => {
                            let dt = value.data_type();
                            match value {
                                ValueRef::Null => {
                                    dm.value(&(dt, ()));
                                }
                                ValueRef::Integer(i) => {
                                    dm.value(&(dt, i));
                                }
                                ValueRef::Real(f) => {
                                    dm.value(&(dt, f));
                                }
                                ValueRef::Text(s) => {
                                    dm.value(&(dt, String::from_utf8_lossy(s)));
                                }
                                ValueRef::Blob(b) => {
                                    dm.value(&(dt, b.len()));
                                }
                            }
                        }
                        Err(ref _err) => {
                            dm.value(&value);
                        }
                    }
                }
                dm.finish()
            }
        }

        mod sealed {
            /// This trait exists just to ensure that the only impls of `trait Params`
            /// that are allowed are ones in this crate.
            pub trait Sealed {}
            impl Sealed for usize {}
            impl Sealed for &str {}
        }
        /// A trait implemented by types that can index into columns of a row.
        pub trait RowIndex: sealed::Sealed {
            /// Returns the index of the appropriate column, or `None` if no such
            /// column exists.
            fn idx(&self, stmt: &Statement<'_>) -> Result<usize>;
        }

        impl RowIndex for usize {
            #[inline]
            fn idx(&self, stmt: &Statement<'_>) -> Result<usize> {
                if *self >= stmt.column_count() {
                    Err(Error::InvalidColumnIndex(*self))
                } else {
                    Ok(*self)
                }
            }
        }

        impl RowIndex for &'_ str {
            #[inline]
            fn idx(&self, stmt: &Statement<'_>) -> Result<usize> {
                stmt.column_index(self)
            }
        }

        macro_rules! tuple_try_from_row {
            ($($field:ident),*) => {
                impl<'a, $($field,)*> convert::TryFrom<&'a Row<'a>> for ($($field,)*) where $($field: FromSql,)* {
                    type Error = crate::Error;

                    // we end with index += 1, which rustc warns about
                    // unused_variables and unused_mut are allowed for ()
                    #[allow(unused_assignments, unused_variables, unused_mut)]
                    fn try_from(row: &'a Row<'a>) -> Result<Self> {
                        let mut index = 0;
                        $(
                            #[allow(non_snake_case)]
                            let $field = row.get::<_, $field>(index)?;
                            index += 1;
                        )*
                        Ok(($($field,)*))
                    }
                }
            }
        }

        macro_rules! tuples_try_from_row {
            () => {
                // not very useful, but maybe some other macro users will find this helpful
                tuple_try_from_row!();
            };
            ($first:ident $(, $remaining:ident)*) => {
                tuple_try_from_row!($first $(, $remaining)*);
                tuples_try_from_row!($($remaining),*);
            };
        }

        tuples_try_from_row!(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P);
    }
    
    pub mod serialize
    {
        //! Serialize a database.
        use ::
        {
            *,
        };
        
        use std::marker::PhantomData;
        use std::ops::Deref;
        use std::ptr::NonNull;

        use crate::error::error_from_handle;
        use crate::ffi;
        use crate::{Connection, DatabaseName, Result};

        /// Shared (SQLITE_SERIALIZE_NOCOPY) serialized database
        pub struct SharedData<'conn> {
            phantom: PhantomData<&'conn Connection>,
            ptr: NonNull<u8>,
            sz: usize,
        }
        /// Owned serialized database
        pub struct OwnedData {
            ptr: NonNull<u8>,
            sz: usize,
        }

        impl OwnedData {
            /// # Safety
            ///
            /// Caller must be certain that `ptr` is allocated by `sqlite3_malloc`.
            pub unsafe fn from_raw_nonnull(ptr: NonNull<u8>, sz: usize) -> Self {
                Self { ptr, sz }
            }

            fn into_raw(self) -> (*mut u8, usize) {
                let raw = (self.ptr.as_ptr(), self.sz);
                std::mem::forget(self);
                raw
            }
        }

        impl Drop for OwnedData {
            fn drop(&mut self) {
                unsafe {
                    ffi::sqlite3_free(self.ptr.as_ptr().cast());
                }
            }
        }
        /// Serialized database
        pub enum Data<'conn> {
            /// Shared (SQLITE_SERIALIZE_NOCOPY) serialized database
            Shared(SharedData<'conn>),
            /// Owned serialized database
            Owned(OwnedData),
        }

        impl<'conn> Deref for Data<'conn> {
            type Target = [u8];

            fn deref(&self) -> &[u8] {
                let (ptr, sz) = match self {
                    Data::Owned(OwnedData { ptr, sz }) => (ptr.as_ptr(), *sz),
                    Data::Shared(SharedData { ptr, sz, .. }) => (ptr.as_ptr(), *sz),
                };
                unsafe { std::slice::from_raw_parts(ptr, sz) }
            }
        }

        impl Connection {
            /// Serialize a database.
            pub fn serialize(&self, schema: DatabaseName) -> Result<Data> {
                let schema = schema.as_cstring()?;
                let mut sz = 0;
                let mut ptr: *mut u8 = unsafe {
                    ffi::sqlite3_serialize(
                        self.handle(),
                        schema.as_ptr(),
                        &mut sz,
                        ffi::SQLITE_SERIALIZE_NOCOPY,
                    )
                };
                Ok(if ptr.is_null() {
                    ptr = unsafe { ffi::sqlite3_serialize(self.handle(), schema.as_ptr(), &mut sz, 0) };
                    if ptr.is_null() {
                        return Err(unsafe { error_from_handle(self.handle(), ffi::SQLITE_NOMEM) });
                    }
                    Data::Owned(OwnedData {
                        ptr: NonNull::new(ptr).unwrap(),
                        sz: sz.try_into().unwrap(),
                    })
                } else {
                    // shared buffer
                    Data::Shared(SharedData {
                        ptr: NonNull::new(ptr).unwrap(),
                        sz: sz.try_into().unwrap(),
                        phantom: PhantomData,
                    })
                })
            }
            /// Deserialize a database.
            pub fn deserialize(
                &mut self,
                schema: DatabaseName<'_>,
                data: OwnedData,
                read_only: bool,
            ) -> Result<()> {
                let schema = schema.as_cstring()?;
                let (data, sz) = data.into_raw();
                let sz = sz.try_into().unwrap();
                let flags = if read_only {
                    ffi::SQLITE_DESERIALIZE_FREEONCLOSE | ffi::SQLITE_DESERIALIZE_READONLY
                } else {
                    ffi::SQLITE_DESERIALIZE_FREEONCLOSE | ffi::SQLITE_DESERIALIZE_RESIZEABLE
                };
                let rc = unsafe {
                    ffi::sqlite3_deserialize(self.handle(), schema.as_ptr(), data, sz, sz, flags)
                };
                if rc != ffi::SQLITE_OK {
                    // TODO sqlite3_free(data) ?
                    return Err(unsafe { error_from_handle(self.handle(), rc) });
                }
                /* TODO
                if let Some(mxSize) = mxSize {
                    unsafe {
                        ffi::sqlite3_file_control(
                            self.handle(),
                            schema.as_ptr(),
                            ffi::SQLITE_FCNTL_SIZE_LIMIT,
                            &mut mxSize,
                        )
                    };
                }*/
                Ok(())
            }
        }
    }
    
    pub mod session
    {
        //! [Session Extension](https://sqlite.org/sessionintro.html)
        use ::
        {
            *,
        };
        
        /*
        use std::ffi::CStr;
        use std::io::{Read, Write};
        use std::marker::PhantomData;
        use std::os::raw::{c_char, c_int, c_uchar, c_void};
        use std::panic::catch_unwind;
        use std::ptr;
        use std::slice::{from_raw_parts, from_raw_parts_mut};

        use fallible_streaming_iterator::FallibleStreamingIterator;

        use crate::error::{check, error_from_sqlite_code, Error};
        use crate::ffi;
        use crate::hooks::Action;
        use crate::types::ValueRef;
        use crate::{errmsg_to_string, str_to_cstring, Connection, DatabaseName, Result}; */

        type Filter = Option<Box<dyn Fn(&str) -> bool>>;

        /// An instance of this object is a session that can be used to record changes to a database.
        pub struct Session<'conn> {
            phantom: PhantomData<&'conn Connection>,
            s: *mut ffi::sqlite3_session,
            filter: Filter,
        }

        impl Session<'_> {
            /// Create a new session object
            #[inline]
            pub fn new(db: &Connection) -> Result<Session<'_>> {
                Session::new_with_name(db, DatabaseName::Main)
            }
            /// Create a new session object
            #[inline]
            pub fn new_with_name<'conn>(
                db: &'conn Connection,
                name: DatabaseName<'_>,
            ) -> Result<Session<'conn>> {
                let name = name.as_cstring()?;

                let db = db.db.borrow_mut().db;

                let mut s: *mut ffi::sqlite3_session = ptr::null_mut();
                check(unsafe { ffi::sqlite3session_create(db, name.as_ptr(), &mut s) })?;

                Ok(Session {
                    phantom: PhantomData,
                    s,
                    filter: None,
                })
            }
            /// Set a table filter
            pub fn table_filter<F>(&mut self, filter: Option<F>)
            where
                F: Fn(&str) -> bool + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(
                    p_arg: *mut c_void,
                    tbl_str: *const c_char,
                ) -> c_int
                where
                    F: Fn(&str) -> bool,
                {
                    let tbl_name = CStr::from_ptr(tbl_str).to_str();
                    c_int::from(
                        catch_unwind(|| {
                            let boxed_filter: *mut F = p_arg.cast::<F>();
                            (*boxed_filter)(tbl_name.expect("non-utf8 table name"))
                        })
                        .unwrap_or_default(),
                    )
                }

                match filter {
                    Some(filter) => {
                        let boxed_filter = Box::new(filter);
                        unsafe {
                            ffi::sqlite3session_table_filter(
                                self.s,
                                Some(call_boxed_closure::<F>),
                                &*boxed_filter as *const F as *mut _,
                            );
                        }
                        self.filter = Some(boxed_filter);
                    }
                    _ => {
                        unsafe { ffi::sqlite3session_table_filter(self.s, None, ptr::null_mut()) }
                        self.filter = None;
                    }
                };
            }
            /// Attach a table. `None` means all tables.
            pub fn attach(&mut self, table: Option<&str>) -> Result<()> {
                let table = if let Some(table) = table {
                    Some(str_to_cstring(table)?)
                } else {
                    None
                };
                let table = table.as_ref().map(|s| s.as_ptr()).unwrap_or(ptr::null());
                check(unsafe { ffi::sqlite3session_attach(self.s, table) })
            }
            /// Generate a Changeset
            pub fn changeset(&mut self) -> Result<Changeset> {
                let mut n = 0;
                let mut cs: *mut c_void = ptr::null_mut();
                check(unsafe { ffi::sqlite3session_changeset(self.s, &mut n, &mut cs) })?;
                Ok(Changeset { cs, n })
            }
            /// Write the set of changes represented by this session to `output`.
            #[inline]
            pub fn changeset_strm(&mut self, output: &mut dyn Write) -> Result<()> {
                let output_ref = &output;
                check(unsafe {
                    ffi::sqlite3session_changeset_strm(
                        self.s,
                        Some(x_output),
                        output_ref as *const &mut dyn Write as *mut c_void,
                    )
                })
            }
            /// Generate a Patchset
            #[inline]
            pub fn patchset(&mut self) -> Result<Changeset> {
                let mut n = 0;
                let mut ps: *mut c_void = ptr::null_mut();
                check(unsafe { ffi::sqlite3session_patchset(self.s, &mut n, &mut ps) })?;
                // TODO Validate: same struct
                Ok(Changeset { cs: ps, n })
            }
            /// Write the set of patches represented by this session to `output`.
            #[inline]
            pub fn patchset_strm(&mut self, output: &mut dyn Write) -> Result<()> {
                let output_ref = &output;
                check(unsafe {
                    ffi::sqlite3session_patchset_strm(
                        self.s,
                        Some(x_output),
                        output_ref as *const &mut dyn Write as *mut c_void,
                    )
                })
            }
            /// Load the difference between tables.
            pub fn diff(&mut self, from: DatabaseName<'_>, table: &str) -> Result<()> {
                let from = from.as_cstring()?;
                let table = str_to_cstring(table)?;
                let table = table.as_ptr();
                unsafe {
                    let mut errmsg = ptr::null_mut();
                    let r =
                        ffi::sqlite3session_diff(self.s, from.as_ptr(), table, &mut errmsg as *mut *mut _);
                    if r != ffi::SQLITE_OK {
                        let errmsg: *mut c_char = errmsg;
                        let message = errmsg_to_string(&*errmsg);
                        ffi::sqlite3_free(errmsg as *mut c_void);
                        return Err(error_from_sqlite_code(r, Some(message)));
                    }
                }
                Ok(())
            }
            /// Test if a changeset has recorded any changes
            #[inline]
            pub fn is_empty(&self) -> bool {
                unsafe { ffi::sqlite3session_isempty(self.s) != 0 }
            }
            /// Query the current state of the session
            #[inline]
            pub fn is_enabled(&self) -> bool {
                unsafe { ffi::sqlite3session_enable(self.s, -1) != 0 }
            }
            /// Enable or disable the recording of changes
            #[inline]
            pub fn set_enabled(&mut self, enabled: bool) {
                unsafe {
                    ffi::sqlite3session_enable(self.s, c_int::from(enabled));
                }
            }
            /// Query the current state of the indirect flag
            #[inline]
            pub fn is_indirect(&self) -> bool {
                unsafe { ffi::sqlite3session_indirect(self.s, -1) != 0 }
            }
            /// Set or clear the indirect change flag
            #[inline]
            pub fn set_indirect(&mut self, indirect: bool) {
                unsafe {
                    ffi::sqlite3session_indirect(self.s, c_int::from(indirect));
                }
            }
        }

        impl Drop for Session<'_> {
            #[inline]
            fn drop(&mut self) {
                if self.filter.is_some() {
                    self.table_filter(None::<fn(&str) -> bool>);
                }
                unsafe { ffi::sqlite3session_delete(self.s) };
            }
        }
        /// Invert a changeset
        #[inline]
        pub fn invert_strm(input: &mut dyn Read, output: &mut dyn Write) -> Result<()> {
            let input_ref = &input;
            let output_ref = &output;
            check(unsafe {
                ffi::sqlite3changeset_invert_strm(
                    Some(x_input),
                    input_ref as *const &mut dyn Read as *mut c_void,
                    Some(x_output),
                    output_ref as *const &mut dyn Write as *mut c_void,
                )
            })
        }
        /// Combine two changesets
        #[inline]
        pub fn concat_strm(
            input_a: &mut dyn Read,
            input_b: &mut dyn Read,
            output: &mut dyn Write,
        ) -> Result<()> {
            let input_a_ref = &input_a;
            let input_b_ref = &input_b;
            let output_ref = &output;
            check(unsafe {
                ffi::sqlite3changeset_concat_strm(
                    Some(x_input),
                    input_a_ref as *const &mut dyn Read as *mut c_void,
                    Some(x_input),
                    input_b_ref as *const &mut dyn Read as *mut c_void,
                    Some(x_output),
                    output_ref as *const &mut dyn Write as *mut c_void,
                )
            })
        }
        /// Changeset or Patchset
        pub struct Changeset {
            cs: *mut c_void,
            n: c_int,
        }

        impl Changeset {
            /// Invert a changeset
            #[inline]
            pub fn invert(&self) -> Result<Changeset> {
                let mut n = 0;
                let mut cs = ptr::null_mut();
                check(unsafe {
                    ffi::sqlite3changeset_invert(self.n, self.cs, &mut n, &mut cs as *mut *mut _)
                })?;
                Ok(Changeset { cs, n })
            }
            /// Create an iterator to traverse a changeset
            #[inline]
            pub fn iter(&self) -> Result<ChangesetIter<'_>> {
                let mut it = ptr::null_mut();
                check(unsafe { ffi::sqlite3changeset_start(&mut it as *mut *mut _, self.n, self.cs) })?;
                Ok(ChangesetIter {
                    phantom: PhantomData,
                    it,
                    item: None,
                })
            }
            /// Concatenate two changeset objects
            #[inline]
            pub fn concat(a: &Changeset, b: &Changeset) -> Result<Changeset> {
                let mut n = 0;
                let mut cs = ptr::null_mut();
                check(unsafe {
                    ffi::sqlite3changeset_concat(a.n, a.cs, b.n, b.cs, &mut n, &mut cs as *mut *mut _)
                })?;
                Ok(Changeset { cs, n })
            }
        }

        impl Drop for Changeset {
            #[inline]
            fn drop(&mut self) {
                unsafe {
                    ffi::sqlite3_free(self.cs);
                }
            }
        }
        /// Cursor for iterating over the elements of a changeset
        /// or patchset.
        pub struct ChangesetIter<'changeset> {
            phantom: PhantomData<&'changeset Changeset>,
            it: *mut ffi::sqlite3_changeset_iter,
            item: Option<ChangesetItem>,
        }

        impl ChangesetIter<'_> {
            /// Create an iterator on `input`
            #[inline]
            pub fn start_strm<'input>(input: &&'input mut dyn Read) -> Result<ChangesetIter<'input>> {
                let mut it = ptr::null_mut();
                check(unsafe {
                    ffi::sqlite3changeset_start_strm(
                        &mut it as *mut *mut _,
                        Some(x_input),
                        input as *const &mut dyn Read as *mut c_void,
                    )
                })?;
                Ok(ChangesetIter {
                    phantom: PhantomData,
                    it,
                    item: None,
                })
            }
        }

        impl FallibleStreamingIterator for ChangesetIter<'_> {
            type Error = crate::error::Error;
            type Item = ChangesetItem;

            #[inline]
            fn advance(&mut self) -> Result<()> {
                let rc = unsafe { ffi::sqlite3changeset_next(self.it) };
                match rc {
                    ffi::SQLITE_ROW => {
                        self.item = Some(ChangesetItem { it: self.it });
                        Ok(())
                    }
                    ffi::SQLITE_DONE => {
                        self.item = None;
                        Ok(())
                    }
                    code => Err(error_from_sqlite_code(code, None)),
                }
            }

            #[inline]
            fn get(&self) -> Option<&ChangesetItem> {
                self.item.as_ref()
            }
        }
        /// Operation
        pub struct Operation<'item> {
            table_name: &'item str,
            number_of_columns: i32,
            code: Action,
            indirect: bool,
        }

        impl Operation<'_> {
            /// Returns the table name.
            #[inline]
            pub fn table_name(&self) -> &str {
                self.table_name
            }
            /// Returns the number of columns in table
            #[inline]
            pub fn number_of_columns(&self) -> i32 {
                self.number_of_columns
            }
            /// Returns the action code.
            #[inline]
            pub fn code(&self) -> Action {
                self.code
            }
            /// Returns `true` for an 'indirect' change.
            #[inline]
            pub fn indirect(&self) -> bool {
                self.indirect
            }
        }

        impl Drop for ChangesetIter<'_> {
            #[inline]
            fn drop(&mut self) {
                unsafe {
                    ffi::sqlite3changeset_finalize(self.it);
                }
            }
        }
        /// An item passed to a conflict-handler by
        /// [`Connection::apply`](Connection::apply), or an item generated by
        /// [`ChangesetIter::next`](ChangesetIter::next).
        // TODO enum ? Delete, Insert, Update, ...
        pub struct ChangesetItem {
            it: *mut ffi::sqlite3_changeset_iter,
        }

        impl ChangesetItem {
            /// Obtain conflicting row values
            ///
            /// May only be called with an `SQLITE_CHANGESET_DATA` or
            /// `SQLITE_CHANGESET_CONFLICT` conflict handler callback.
            #[inline]
            pub fn conflict(&self, col: usize) -> Result<ValueRef<'_>> {
                unsafe {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    check(ffi::sqlite3changeset_conflict(
                        self.it,
                        col as i32,
                        &mut p_value,
                    ))?;
                    if p_value.is_null() {
                        Err(Error::InvalidColumnIndex(col))
                    } else {
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }
            /// Determine the number of foreign key constraint violations
            ///
            /// May only be called with an `SQLITE_CHANGESET_FOREIGN_KEY` conflict
            /// handler callback.
            #[inline]
            pub fn fk_conflicts(&self) -> Result<i32> {
                unsafe {
                    let mut p_out = 0;
                    check(ffi::sqlite3changeset_fk_conflicts(self.it, &mut p_out))?;
                    Ok(p_out)
                }
            }
            /// Obtain new.* Values
            ///
            /// May only be called if the type of change is either `SQLITE_UPDATE` or
            /// `SQLITE_INSERT`.
            #[inline]
            pub fn new_value(&self, col: usize) -> Result<ValueRef<'_>> {
                unsafe {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    check(ffi::sqlite3changeset_new(self.it, col as i32, &mut p_value))?;
                    if p_value.is_null() {
                        Err(Error::InvalidColumnIndex(col))
                    } else {
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }
            /// Obtain old.* Values
            ///
            /// May only be called if the type of change is either `SQLITE_DELETE` or
            /// `SQLITE_UPDATE`.
            #[inline]
            pub fn old_value(&self, col: usize) -> Result<ValueRef<'_>> {
                unsafe {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    check(ffi::sqlite3changeset_old(self.it, col as i32, &mut p_value))?;
                    if p_value.is_null() {
                        Err(Error::InvalidColumnIndex(col))
                    } else {
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }
            /// Obtain the current operation
            #[inline]
            pub fn op(&self) -> Result<Operation<'_>> {
                let mut number_of_columns = 0;
                let mut code = 0;
                let mut indirect = 0;
                let tab = unsafe {
                    let mut pz_tab: *const c_char = ptr::null();
                    check(ffi::sqlite3changeset_op(
                        self.it,
                        &mut pz_tab,
                        &mut number_of_columns,
                        &mut code,
                        &mut indirect,
                    ))?;
                    CStr::from_ptr(pz_tab)
                };
                let table_name = tab.to_str()?;
                Ok(Operation {
                    table_name,
                    number_of_columns,
                    code: Action::from(code),
                    indirect: indirect != 0,
                })
            }
            /// Obtain the primary key definition of a table
            #[inline]
            pub fn pk(&self) -> Result<&[u8]> {
                let mut number_of_columns = 0;
                unsafe {
                    let mut pks: *mut c_uchar = ptr::null_mut();
                    check(ffi::sqlite3changeset_pk(
                        self.it,
                        &mut pks,
                        &mut number_of_columns,
                    ))?;
                    Ok(from_raw_parts(pks, number_of_columns as usize))
                }
            }
        }
        /// Used to combine two or more changesets or
        /// patchsets
        pub struct Changegroup {
            cg: *mut ffi::sqlite3_changegroup,
        }

        impl Changegroup {
            /// Create a new change group.
            #[inline]
            pub fn new() -> Result<Self> {
                let mut cg = ptr::null_mut();
                check(unsafe { ffi::sqlite3changegroup_new(&mut cg) })?;
                Ok(Changegroup { cg })
            }
            /// Add a changeset
            #[inline]
            pub fn add(&mut self, cs: &Changeset) -> Result<()> {
                check(unsafe { ffi::sqlite3changegroup_add(self.cg, cs.n, cs.cs) })
            }
            /// Add a changeset read from `input` to this change group.
            #[inline]
            pub fn add_stream(&mut self, input: &mut dyn Read) -> Result<()> {
                let input_ref = &input;
                check(unsafe {
                    ffi::sqlite3changegroup_add_strm(
                        self.cg,
                        Some(x_input),
                        input_ref as *const &mut dyn Read as *mut c_void,
                    )
                })
            }
            /// Obtain a composite Changeset
            #[inline]
            pub fn output(&mut self) -> Result<Changeset> {
                let mut n = 0;
                let mut output: *mut c_void = ptr::null_mut();
                check(unsafe { ffi::sqlite3changegroup_output(self.cg, &mut n, &mut output) })?;
                Ok(Changeset { cs: output, n })
            }
            /// Write the combined set of changes to `output`.
            #[inline]
            pub fn output_strm(&mut self, output: &mut dyn Write) -> Result<()> {
                let output_ref = &output;
                check(unsafe {
                    ffi::sqlite3changegroup_output_strm(
                        self.cg,
                        Some(x_output),
                        output_ref as *const &mut dyn Write as *mut c_void,
                    )
                })
            }
        }

        impl Drop for Changegroup {
            #[inline]
            fn drop(&mut self) {
                unsafe {
                    ffi::sqlite3changegroup_delete(self.cg);
                }
            }
        }

        impl Connection {
            /// Apply a changeset to a database
            pub fn apply<F, C>(&self, cs: &Changeset, filter: Option<F>, conflict: C) -> Result<()>
            where
                F: Fn(&str) -> bool + Send + 'static,
                C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
            {
                let db = self.db.borrow_mut().db;

                let filtered = filter.is_some();
                let tuple = &mut (filter, conflict);
                check(unsafe {
                    if filtered {
                        ffi::sqlite3changeset_apply(
                            db,
                            cs.n,
                            cs.cs,
                            Some(call_filter::<F, C>),
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    } else {
                        ffi::sqlite3changeset_apply(
                            db,
                            cs.n,
                            cs.cs,
                            None,
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    }
                })
            }
            /// Apply a changeset to a database
            pub fn apply_strm<F, C>(
                &self,
                input: &mut dyn Read,
                filter: Option<F>,
                conflict: C,
            ) -> Result<()>
            where
                F: Fn(&str) -> bool + Send + 'static,
                C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
            {
                let input_ref = &input;
                let db = self.db.borrow_mut().db;

                let filtered = filter.is_some();
                let tuple = &mut (filter, conflict);
                check(unsafe {
                    if filtered {
                        ffi::sqlite3changeset_apply_strm(
                            db,
                            Some(x_input),
                            input_ref as *const &mut dyn Read as *mut c_void,
                            Some(call_filter::<F, C>),
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    } else {
                        ffi::sqlite3changeset_apply_strm(
                            db,
                            Some(x_input),
                            input_ref as *const &mut dyn Read as *mut c_void,
                            None,
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    }
                })
            }
        }
        /// Constants passed to the conflict handler
        /// See [here](https://sqlite.org/session.html#SQLITE_CHANGESET_CONFLICT) for details.
        #[allow(missing_docs)]
        #[repr(i32)]
        #[derive(Debug, PartialEq, Eq)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms)]
        pub enum ConflictType {
            UNKNOWN = -1,
            SQLITE_CHANGESET_DATA = ffi::SQLITE_CHANGESET_DATA,
            SQLITE_CHANGESET_NOTFOUND = ffi::SQLITE_CHANGESET_NOTFOUND,
            SQLITE_CHANGESET_CONFLICT = ffi::SQLITE_CHANGESET_CONFLICT,
            SQLITE_CHANGESET_CONSTRAINT = ffi::SQLITE_CHANGESET_CONSTRAINT,
            SQLITE_CHANGESET_FOREIGN_KEY = ffi::SQLITE_CHANGESET_FOREIGN_KEY,
        }
        impl From<i32> for ConflictType {
            fn from(code: i32) -> ConflictType {
                match code {
                    ffi::SQLITE_CHANGESET_DATA => ConflictType::SQLITE_CHANGESET_DATA,
                    ffi::SQLITE_CHANGESET_NOTFOUND => ConflictType::SQLITE_CHANGESET_NOTFOUND,
                    ffi::SQLITE_CHANGESET_CONFLICT => ConflictType::SQLITE_CHANGESET_CONFLICT,
                    ffi::SQLITE_CHANGESET_CONSTRAINT => ConflictType::SQLITE_CHANGESET_CONSTRAINT,
                    ffi::SQLITE_CHANGESET_FOREIGN_KEY => ConflictType::SQLITE_CHANGESET_FOREIGN_KEY,
                    _ => ConflictType::UNKNOWN,
                }
            }
        }
        /// Constants returned by the conflict handler
        /// See [here](https://sqlite.org/session.html#SQLITE_CHANGESET_ABORT) for details.
        #[allow(missing_docs)]
        #[repr(i32)]
        #[derive(Debug, PartialEq, Eq)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms)]
        pub enum ConflictAction {
            SQLITE_CHANGESET_OMIT = ffi::SQLITE_CHANGESET_OMIT,
            SQLITE_CHANGESET_REPLACE = ffi::SQLITE_CHANGESET_REPLACE,
            SQLITE_CHANGESET_ABORT = ffi::SQLITE_CHANGESET_ABORT,
        }

        unsafe extern "C" fn call_filter<F, C>(p_ctx: *mut c_void, tbl_str: *const c_char) -> c_int
        where
            F: Fn(&str) -> bool + Send + 'static,
            C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
        {
            let tbl_name = CStr::from_ptr(tbl_str).to_str();
            c_int::from(
                catch_unwind(|| {
                    let tuple: *mut (Option<F>, C) = p_ctx.cast::<(Option<F>, C)>();
                    if let Some(ref filter) = (*tuple).0 {
                        filter(tbl_name.expect("illegal table name"))
                    } else {
                        true
                    }
                })
                .unwrap_or_default(),
            )
        }

        unsafe extern "C" fn call_conflict<F, C>(
            p_ctx: *mut c_void,
            e_conflict: c_int,
            p: *mut ffi::sqlite3_changeset_iter,
        ) -> c_int
        where
            F: Fn(&str) -> bool + Send + 'static,
            C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
        {
            let conflict_type = ConflictType::from(e_conflict);
            let item = ChangesetItem { it: p };
            if let Ok(action) = catch_unwind(|| {
                let tuple: *mut (Option<F>, C) = p_ctx.cast::<(Option<F>, C)>();
                (*tuple).1(conflict_type, item)
            }) {
                action as c_int
            } else {
                ffi::SQLITE_CHANGESET_ABORT
            }
        }

        unsafe extern "C" fn x_input(p_in: *mut c_void, data: *mut c_void, len: *mut c_int) -> c_int {
            if p_in.is_null() {
                return ffi::SQLITE_MISUSE;
            }
            let bytes: &mut [u8] = from_raw_parts_mut(data as *mut u8, *len as usize);
            let input = p_in as *mut &mut dyn Read;
            match (*input).read(bytes) {
                Ok(n) => {
                    *len = n as i32; // TODO Validate: n = 0 may not mean the reader will always no longer be able to
                                    // produce bytes.
                    ffi::SQLITE_OK
                }
                Err(_) => ffi::SQLITE_IOERR_READ, // TODO check if err is a (ru)sqlite Error => propagate
            }
        }

        unsafe extern "C" fn x_output(p_out: *mut c_void, data: *const c_void, len: c_int) -> c_int {
            if p_out.is_null() {
                return ffi::SQLITE_MISUSE;
            }
            // The sessions module never invokes an xOutput callback with the third
            // parameter set to a value less than or equal to zero.
            let bytes: &[u8] = from_raw_parts(data as *const u8, len as usize);
            let output = p_out as *mut &mut dyn Write;
            match (*output).write_all(bytes) {
                Ok(_) => ffi::SQLITE_OK,
                Err(_) => ffi::SQLITE_IOERR_WRITE, // TODO check if err is a (ru)sqlite Error => propagate
            }
        }
    }

    mod statement
    {
        use ::
        {
            *,
        };
        use std::os::raw::{c_int, c_void};
        #[cfg(feature = "array")]
        use std::rc::Rc;
        use std::slice::from_raw_parts;
        use std::{fmt, mem, ptr, str};

        use super::ffi;
        use super::{len_as_c_int, str_for_sqlite};
        use super::{
            AndThenRows, Connection, Error, MappedRows, Params, RawStatement, Result, Row, Rows, ValueRef,
        };
        use crate::types::{ToSql, ToSqlOutput};
        #[cfg(feature = "array")]
        use crate::vtab::array::{free_array, ARRAY_TYPE};

        /// A prepared statement.
        pub struct Statement<'conn> {
            conn: &'conn Connection,
            pub stmt: RawStatement,
        }

        impl Statement<'_> {
            /// Execute the prepared statement.
            #[inline]
            pub fn execute<P: Params>(&mut self, params: P) -> Result<usize> {
                params.__bind_in(self)?;
                self.execute_with_bound_parameters()
            }
            /// Execute an INSERT and return the ROWID.
            #[inline]
            pub fn insert<P: Params>(&mut self, params: P) -> Result<i64> {
                let changes = self.execute(params)?;
                match changes {
                    1 => Ok(self.conn.last_insert_rowid()),
                    _ => Err(Error::StatementChangedRows(changes)),
                }
            }
            /// Execute the prepared statement, returning a handle to the resulting rows.
            #[inline]
            pub fn query<P: Params>(&mut self, params: P) -> Result<Rows<'_>> {
                params.__bind_in(self)?;
                Ok(Rows::new(self))
            }
            /// Executes the prepared statement and maps a function over the resulting
            /// rows, returning an iterator over the mapped function results.
            pub fn query_map<T, P, F>(&mut self, params: P, f: F) -> Result<MappedRows<'_, F>>
            where
                P: Params,
                F: FnMut(&Row<'_>) -> Result<T>,
            {
                self.query(params).map(|rows| rows.mapped(f))
            }
            /// Executes the prepared statement and maps a function over the resulting
            /// rows, where the function returns a `Result` with `Error` type
            /// implementing `std::convert::From<Error>` (so errors can be unified).
            #[inline]
            pub fn query_and_then<T, E, P, F>(&mut self, params: P, f: F) -> Result<AndThenRows<'_, F>>
            where
                P: Params,
                E: From<Error>,
                F: FnMut(&Row<'_>) -> Result<T, E>,
            {
                self.query(params).map(|rows| rows.and_then(f))
            }
            /// Return `true` if a query in the SQL statement it executes returns one
            /// or more rows and `false` if the SQL returns an empty set.
            #[inline]
            pub fn exists<P: Params>(&mut self, params: P) -> Result<bool> {
                let mut rows = self.query(params)?;
                let exists = rows.next()?.is_some();
                Ok(exists)
            }
            /// Convenience method to execute a query that is expected to return a single row.
            pub fn query_row<T, P, F>(&mut self, params: P, f: F) -> Result<T>
            where
                P: Params,
                F: FnOnce(&Row<'_>) -> Result<T>,
            {
                let mut rows = self.query(params)?;

                rows.get_expected_row().and_then(f)
            }
            /// Consumes the statement.
            #[inline]
            pub fn finalize(mut self) -> Result<()> {
                self.finalize_()
            }
            /// Return the (one-based) index of an SQL parameter given its name.
            #[inline]
            pub fn parameter_index(&self, name: &str) -> Result<Option<usize>> {
                Ok(self.stmt.bind_parameter_index(name))
            }
            /// Return the SQL parameter name given its (one-based) index (the inverse
            /// of [`Statement::parameter_index`]).
            #[inline]
            pub fn parameter_name(&self, index: usize) -> Option<&'_ str> {
                self.stmt.bind_parameter_name(index as i32).map(|name| {
                    name.to_str()
                        .expect("Invalid UTF-8 sequence in parameter name")
                })
            }

            #[inline]
            pub fn bind_parameters<P>(&mut self, params: P) -> Result<()>
            where
                P: IntoIterator,
                P::Item: ToSql,
            {
                let expected = self.stmt.bind_parameter_count();
                let mut index = 0;
                for p in params {
                    index += 1; // The leftmost SQL parameter has an index of 1.
                    if index > expected {
                        break;
                    }
                    self.bind_parameter(&p, index)?;
                }
                if index != expected {
                    Err(Error::InvalidParameterCount(index, expected))
                } else {
                    Ok(())
                }
            }

            #[inline]
            pub fn ensure_parameter_count(&self, n: usize) -> Result<()> {
                let count = self.parameter_count();
                if count != n {
                    Err(Error::InvalidParameterCount(n, count))
                } else {
                    Ok(())
                }
            }

            #[inline]
            pub fn bind_parameters_named<T: ?Sized + ToSql>(
                &mut self,
                params: &[(&str, &T)],
            ) -> Result<()> {
                for &(name, value) in params {
                    if let Some(i) = self.parameter_index(name)? {
                        let ts: &dyn ToSql = &value;
                        self.bind_parameter(ts, i)?;
                    } else {
                        return Err(Error::InvalidParameterName(name.into()));
                    }
                }
                Ok(())
            }
            /// Return the number of parameters that can be bound to this statement.
            #[inline]
            pub fn parameter_count(&self) -> usize {
                self.stmt.bind_parameter_count()
            }
            /// Low level API to directly bind a parameter to a given index.
            #[inline]
            pub fn raw_bind_parameter<T: ToSql>(
                &mut self,
                one_based_col_index: usize,
                param: T,
            ) -> Result<()> {
                // This is the same as `bind_parameter` but slightly more ergonomic and
                // correctly takes `&mut self`.
                self.bind_parameter(&param, one_based_col_index)
            }
            /// Low level API to execute a statement given that all parameters were
            /// bound explicitly with the [`Statement::raw_bind_parameter`] API.
            #[inline]
            pub fn raw_execute(&mut self) -> Result<usize> {
                self.execute_with_bound_parameters()
            }
            /// Low level API to get `Rows` for this query given that all parameters
            /// were bound explicitly with the [`Statement::raw_bind_parameter`] API.
            #[inline]
            pub fn raw_query(&mut self) -> Rows<'_> {
                Rows::new(self)
            }

            // generic because many of these branches can constant fold away.
            fn bind_parameter<P: ?Sized + ToSql>(&self, param: &P, col: usize) -> Result<()>
            {
                let array_type:*const c_char = r#"rarray"#.to_string().to_ptr();
                let value = param.to_sql()?;

                let ptr = unsafe { self.stmt.ptr() };
                let value = match value {
                    ToSqlOutput::Borrowed(v) => v,
                    ToSqlOutput::Owned(ref v) => ValueRef::from(v),

                    #[cfg(feature = "blob")]
                    ToSqlOutput::ZeroBlob(len) => {
                        // TODO sqlite3_bind_zeroblob64 // 3.8.11
                        return self
                            .conn
                            .decode_result(unsafe { ffi::sqlite3_bind_zeroblob(ptr, col as c_int, len) });
                    }
                    #[cfg(feature = "functions")]
                    ToSqlOutput::Arg(_) => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                    #[cfg(feature = "array")]
                    ToSqlOutput::Array(a) => {
                        return self.conn.decode_result(unsafe {
                            ffi::sqlite3_bind_pointer(
                                ptr,
                                col as c_int,
                                Rc::into_raw(a) as *mut c_void,
                                ARRAY_TYPE,
                                Some(free_array),
                            )
                        });
                    }
                };
                self.conn.decode_result(match value {
                    ValueRef::Null => unsafe { ffi::sqlite3_bind_null(ptr, col as c_int) },
                    ValueRef::Integer(i) => unsafe { ffi::sqlite3_bind_int64(ptr, col as c_int, i) },
                    ValueRef::Real(r) => unsafe { ffi::sqlite3_bind_double(ptr, col as c_int, r) },
                    ValueRef::Text(s) => unsafe {
                        let (c_str, len, destructor) = str_for_sqlite(s)?;
                        // TODO sqlite3_bind_text64 // 3.8.7
                        ffi::sqlite3_bind_text(ptr, col as c_int, c_str, len, destructor)
                    },
                    ValueRef::Blob(b) => unsafe {
                        let length = len_as_c_int(b.len())?;
                        if length == 0 {
                            ffi::sqlite3_bind_zeroblob(ptr, col as c_int, 0)
                        } else {
                            // TODO sqlite3_bind_blob64 // 3.8.7
                            ffi::sqlite3_bind_blob(
                                ptr,
                                col as c_int,
                                b.as_ptr().cast::<c_void>(),
                                length,
                                ffi::SQLITE_TRANSIENT(),
                            )
                        }
                    },
                })
            }

            #[inline]
            fn execute_with_bound_parameters(&mut self) -> Result<usize> {
                self.check_update()?;
                let r = self.stmt.step();
                let rr = self.stmt.reset();
                match r {
                    ffi::SQLITE_DONE => match rr {
                        ffi::SQLITE_OK => Ok(self.conn.changes() as usize),
                        _ => Err(self.conn.decode_result(rr).unwrap_err()),
                    },
                    ffi::SQLITE_ROW => Err(Error::ExecuteReturnedResults),
                    _ => Err(self.conn.decode_result(r).unwrap_err()),
                }
            }

            #[inline]
            fn finalize_(&mut self) -> Result<()> {
                let mut stmt = unsafe { RawStatement::new(ptr::null_mut(), 0) };
                mem::swap(&mut stmt, &mut self.stmt);
                self.conn.decode_result(stmt.finalize())
            }

            #[cfg(feature = "extra_check")]
            #[inline]
            fn check_update(&self) -> Result<()> {
                // sqlite3_column_count works for DML but not for DDL (ie ALTER)
                if self.column_count() > 0 && self.stmt.readonly() {
                    return Err(Error::ExecuteReturnedResults);
                }
                Ok(())
            }

            #[cfg(not(feature = "extra_check"))]
            #[inline]
            #[allow(clippy::unnecessary_wraps)]
            fn check_update(&self) -> Result<()> {
                Ok(())
            }
            /// Returns a string containing the SQL text of prepared statement with
            /// bound parameters expanded.
            pub fn expanded_sql(&self) -> Option<String> {
                self.stmt
                    .expanded_sql()
                    .map(|s| s.to_string_lossy().to_string())
            }
            /// Get the value for one of the status counters for this statement.
            #[inline]
            pub fn get_status(&self, status: StatementStatus) -> i32 {
                self.stmt.get_status(status, false)
            }
            /// Reset the value of one of the status counters for this statement,
            #[inline]
            /// returning the value it had before resetting.
            pub fn reset_status(&self, status: StatementStatus) -> i32 {
                self.stmt.get_status(status, true)
            }
            /// Returns 1 if the prepared statement is an EXPLAIN statement,
            /// or 2 if the statement is an EXPLAIN QUERY PLAN,
            /// or 0 if it is an ordinary statement or a NULL pointer.
            #[inline]
            #[cfg(feature = "modern_sqlite")] // 3.28.0
            #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
            pub fn is_explain(&self) -> i32 {
                self.stmt.is_explain()
            }
            /// Returns true if the statement is read only.
            #[inline]
            pub fn readonly(&self) -> bool {
                self.stmt.readonly()
            }

            #[cfg(feature = "extra_check")]
            #[inline]
            pub fn check_no_tail(&self) -> Result<()> {
                if self.stmt.has_tail() {
                    Err(Error::MultipleStatement)
                } else {
                    Ok(())
                }
            }

            #[cfg(not(feature = "extra_check"))]
            #[inline]
            #[allow(clippy::unnecessary_wraps)]
            pub fn check_no_tail(&self) -> Result<()> {
                Ok(())
            }
            /// Safety: This is unsafe, because using `sqlite3_stmt` after the
            /// connection has closed is illegal, but `RawStatement` does not enforce
            /// this, as it loses our protective `'conn` lifetime bound.
            #[inline]
            pub unsafe fn into_raw(mut self) -> RawStatement {
                let mut stmt = RawStatement::new(ptr::null_mut(), 0);
                mem::swap(&mut stmt, &mut self.stmt);
                stmt
            }
            /// Reset all bindings
            pub fn clear_bindings(&mut self) {
                self.stmt.clear_bindings();
            }
        }

        impl fmt::Debug for Statement<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let sql = if self.stmt.is_null() {
                    Ok("")
                } else {
                    self.stmt.sql().unwrap().to_str()
                };
                f.debug_struct("Statement")
                    .field("conn", self.conn)
                    .field("stmt", &self.stmt)
                    .field("sql", &sql)
                    .finish()
            }
        }

        impl Drop for Statement<'_> {
            #[allow(unused_must_use)]
            #[inline]
            fn drop(&mut self) {
                self.finalize_();
            }
        }

        impl Statement<'_> {
            #[inline]
            pub(super) fn new(conn: &Connection, stmt: RawStatement) -> Statement<'_> {
                Statement { conn, stmt }
            }

            pub(super) fn value_ref(&self, col: usize) -> ValueRef<'_> {
                let raw = unsafe { self.stmt.ptr() };

                match self.stmt.column_type(col) {
                    ffi::SQLITE_NULL => ValueRef::Null,
                    ffi::SQLITE_INTEGER => {
                        ValueRef::Integer(unsafe { ffi::sqlite3_column_int64(raw, col as c_int) })
                    }
                    ffi::SQLITE_FLOAT => {
                        ValueRef::Real(unsafe { ffi::sqlite3_column_double(raw, col as c_int) })
                    }
                    ffi::SQLITE_TEXT => {
                        let s = unsafe {
                            // Quoting from "Using SQLite" book:
                            // To avoid problems, an application should first extract the desired type using
                            // a sqlite3_column_xxx() function, and then call the
                            // appropriate sqlite3_column_bytes() function.
                            let text = ffi::sqlite3_column_text(raw, col as c_int);
                            let len = ffi::sqlite3_column_bytes(raw, col as c_int);
                            assert!(
                                !text.is_null(),
                                "unexpected SQLITE_TEXT column type with NULL data"
                            );
                            from_raw_parts(text.cast::<u8>(), len as usize)
                        };

                        ValueRef::Text(s)
                    }
                    ffi::SQLITE_BLOB => {
                        let (blob, len) = unsafe {
                            (
                                ffi::sqlite3_column_blob(raw, col as c_int),
                                ffi::sqlite3_column_bytes(raw, col as c_int),
                            )
                        };

                        assert!(
                            len >= 0,
                            "unexpected negative return from sqlite3_column_bytes"
                        );
                        if len > 0 {
                            assert!(
                                !blob.is_null(),
                                "unexpected SQLITE_BLOB column type with NULL data"
                            );
                            ValueRef::Blob(unsafe { from_raw_parts(blob.cast::<u8>(), len as usize) })
                        } else {
                            // The return value from sqlite3_column_blob() for a zero-length BLOB
                            // is a NULL pointer.
                            ValueRef::Blob(&[])
                        }
                    }
                    _ => unreachable!("sqlite3_column_type returned invalid value"),
                }
            }

            #[inline]
            pub(super) fn step(&self) -> Result<bool> {
                match self.stmt.step() {
                    ffi::SQLITE_ROW => Ok(true),
                    ffi::SQLITE_DONE => Ok(false),
                    code => Err(self.conn.decode_result(code).unwrap_err()),
                }
            }

            #[inline]
            pub(super) fn reset(&self) -> Result<()> {
                match self.stmt.reset() {
                    ffi::SQLITE_OK => Ok(()),
                    code => Err(self.conn.decode_result(code).unwrap_err()),
                }
            }
        }
        /// Prepared statement status counters.
        ///
        /// See `https://www.sqlite.org/c3ref/c_stmtstatus_counter.html`
        /// for explanations of each.
        ///
        /// Note that depending on your version of SQLite, all of these
        /// may not be available.
        #[repr(i32)]
        #[derive(Clone, Copy, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum StatementStatus {
            /// Equivalent to SQLITE_STMTSTATUS_FULLSCAN_STEP
            FullscanStep = 1,
            /// Equivalent to SQLITE_STMTSTATUS_SORT
            Sort = 2,
            /// Equivalent to SQLITE_STMTSTATUS_AUTOINDEX
            AutoIndex = 3,
            /// Equivalent to SQLITE_STMTSTATUS_VM_STEP
            VmStep = 4,
            /// Equivalent to SQLITE_STMTSTATUS_REPREPARE (3.20.0)
            RePrepare = 5,
            /// Equivalent to SQLITE_STMTSTATUS_RUN (3.20.0)
            Run = 6,
            /// Equivalent to SQLITE_STMTSTATUS_FILTER_MISS
            FilterMiss = 7,
            /// Equivalent to SQLITE_STMTSTATUS_FILTER_HIT
            FilterHit = 8,
            /// Equivalent to SQLITE_STMTSTATUS_MEMUSED (3.20.0)
            MemUsed = 99,
        }
    }
    
    pub mod trace
    {
        //! Tracing and profiling functions. Error and warning log.
        use ::
        {
            *,
        };
        

        use std::ffi::{CStr, CString};
        use std::mem;
        use std::os::raw::{c_char, c_int, c_void};
        use std::panic::catch_unwind;
        use std::ptr;
        use std::time::Duration;

        use super::ffi;
        use crate::Connection;

        /// Set up the process-wide SQLite error logging callback.
        ///
        /// # Safety
        ///
        /// This function is marked unsafe for two reasons:
        ///
        /// * The function is not threadsafe. No other SQLite calls may be made while
        ///   `config_log` is running, and multiple threads may not call `config_log`
        ///   simultaneously.
        /// * The provided `callback` itself function has two requirements:
        ///     * It must not invoke any SQLite calls.
        ///     * It must be threadsafe if SQLite is used in a multithreaded way.
        ///
        /// cf [The Error And Warning Log](http://sqlite.org/errlog.html).
        #[cfg(not(feature = "loadable_extension"))]
        pub unsafe fn config_log(callback: Option<fn(c_int, &str)>) -> crate::Result<()> {
            extern "C" fn log_callback(p_arg: *mut c_void, err: c_int, msg: *const c_char) {
                let s = unsafe { CStr::from_ptr(msg).to_string_lossy() };
                let callback: fn(c_int, &str) = unsafe { mem::transmute(p_arg) };

                drop(catch_unwind(|| callback(err, &s)));
            }

            let rc = if let Some(f) = callback {
                ffi::sqlite3_config(
                    ffi::SQLITE_CONFIG_LOG,
                    log_callback as extern "C" fn(_, _, _),
                    f as *mut c_void,
                )
            } else {
                let nullptr: *mut c_void = ptr::null_mut();
                ffi::sqlite3_config(ffi::SQLITE_CONFIG_LOG, nullptr, nullptr)
            };

            if rc == ffi::SQLITE_OK {
                Ok(())
            } else {
                Err(crate::error::error_from_sqlite_code(rc, None))
            }
        }
        /// Write a message into the error log established by
        /// `config_log`.
        #[inline]
        pub fn log(err_code: c_int, msg: &str) {
            let msg = CString::new(msg).expect("SQLite log messages cannot contain embedded zeroes");
            unsafe {
                ffi::sqlite3_log(err_code, b"%s\0" as *const _ as *const c_char, msg.as_ptr());
            }
        }

        impl Connection {
            /// Register or clear a callback function that can be
            /// used for tracing the execution of SQL statements.
            ///
            /// Prepared statement placeholders are replaced/logged with their assigned
            /// values. There can only be a single tracer defined for each database
            /// connection. Setting a new tracer clears the old one.
            pub fn trace(&mut self, trace_fn: Option<fn(&str)>) {
                unsafe extern "C" fn trace_callback(p_arg: *mut c_void, z_sql: *const c_char) {
                    let trace_fn: fn(&str) = mem::transmute(p_arg);
                    let s = CStr::from_ptr(z_sql).to_string_lossy();
                    drop(catch_unwind(|| trace_fn(&s)));
                }

                let c = self.db.borrow_mut();
                match trace_fn {
                    Some(f) => unsafe {
                        ffi::sqlite3_trace(c.db(), Some(trace_callback), f as *mut c_void);
                    },
                    None => unsafe {
                        ffi::sqlite3_trace(c.db(), None, ptr::null_mut());
                    },
                }
            }
            /// Register or clear a callback function that can be
            /// used for profiling the execution of SQL statements.
            ///
            /// There can only be a single profiler defined for each database
            /// connection. Setting a new profiler clears the old one.
            pub fn profile(&mut self, profile_fn: Option<fn(&str, Duration)>) {
                unsafe extern "C" fn profile_callback(
                    p_arg: *mut c_void,
                    z_sql: *const c_char,
                    nanoseconds: u64,
                ) {
                    let profile_fn: fn(&str, Duration) = mem::transmute(p_arg);
                    let s = CStr::from_ptr(z_sql).to_string_lossy();
                    const NANOS_PER_SEC: u64 = 1_000_000_000;

                    let duration = Duration::new(
                        nanoseconds / NANOS_PER_SEC,
                        (nanoseconds % NANOS_PER_SEC) as u32,
                    );
                    drop(catch_unwind(|| profile_fn(&s, duration)));
                }

                let c = self.db.borrow_mut();
                match profile_fn {
                    Some(f) => unsafe {
                        ffi::sqlite3_profile(c.db(), Some(profile_callback), f as *mut c_void)
                    },
                    None => unsafe { ffi::sqlite3_profile(c.db(), None, ptr::null_mut()) },
                };
            }

            // TODO sqlite3_trace_v2 (https://sqlite.org/c3ref/trace_v2.html) // 3.14.0, #977
        }
    }

    pub mod transaction
    {
        use ::
        {
            *,
        };
        use crate::{Connection, Result};
        use std::ops::Deref;

        /// Options for transaction behavior. See [BEGIN
        /// TRANSACTION](http://www.sqlite.org/lang_transaction.html) for details.
        #[derive(Copy, Clone)]
        #[non_exhaustive]
        pub enum TransactionBehavior {
            /// DEFERRED means that the transaction does not actually start until the
            /// database is first accessed.
            Deferred,
            /// IMMEDIATE cause the database connection to start a new write
            /// immediately, without waiting for a writes statement.
            Immediate,
            /// EXCLUSIVE prevents other database connections from reading the database
            /// while the transaction is underway.
            Exclusive,
        }
        /// Options for how a Transaction or Savepoint should behave when it is dropped.
        #[derive(Copy, Clone, Debug, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum DropBehavior {
            /// Roll back the changes. This is the default.
            Rollback,

            /// Commit the changes.
            Commit,

            /// Do not commit or roll back changes - this will leave the transaction or
            /// savepoint open, so should be used with care.
            Ignore,

            /// Panic. Used to enforce intentional behavior during development.
            Panic,
        }
        /// Represents a transaction on a database connection.
        #[derive(Debug)]
        pub struct Transaction<'conn> {
            conn: &'conn Connection,
            drop_behavior: DropBehavior,
        }
        /// Represents a savepoint on a database connection.
        #[derive(Debug)]
        pub struct Savepoint<'conn> {
            conn: &'conn Connection,
            name: String,
            drop_behavior: DropBehavior,
            committed: bool,
        }

        impl Transaction<'_> {
            /// Begin a new transaction. Cannot be nested; see `savepoint` for nested
            /// transactions.
            ///
            /// Even though we don't mutate the connection, we take a `&mut Connection`
            /// to prevent nested transactions on the same connection. For cases
            /// where this is unacceptable, [`Transaction::new_unchecked`] is available.
            #[inline]
            pub fn new(conn: &mut Connection, behavior: TransactionBehavior) -> Result<Transaction<'_>> {
                Self::new_unchecked(conn, behavior)
            }
            /// Begin a new transaction, failing if a transaction is open.
            ///
            /// If a transaction is already open, this will return an error. Where
            /// possible, [`Transaction::new`] should be preferred, as it provides a
            /// compile-time guarantee that transactions are not nested.
            #[inline]
            pub fn new_unchecked(
                conn: &Connection,
                behavior: TransactionBehavior,
            ) -> Result<Transaction<'_>> {
                let query = match behavior {
                    TransactionBehavior::Deferred => "BEGIN DEFERRED",
                    TransactionBehavior::Immediate => "BEGIN IMMEDIATE",
                    TransactionBehavior::Exclusive => "BEGIN EXCLUSIVE",
                };
                conn.execute_batch(query).map(move |()| Transaction {
                    conn,
                    drop_behavior: DropBehavior::Rollback,
                })
            }
            /// Starts a new [savepoint](http://www.sqlite.org/lang_savepoint.html), allowing nested transactions.
            #[inline]
            pub fn savepoint(&mut self) -> Result<Savepoint<'_>> {
                Savepoint::new_(self.conn)
            }
            /// Create a new savepoint with a custom savepoint name. See `savepoint()`.
            #[inline]
            pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(self.conn, name)
            }
            /// Get the current setting for what happens to the transaction when it is
            /// dropped.
            #[inline]
            #[must_use]
            pub fn drop_behavior(&self) -> DropBehavior {
                self.drop_behavior
            }
            /// Configure the transaction to perform the specified action when it is
            /// dropped.
            #[inline]
            pub fn set_drop_behavior(&mut self, drop_behavior: DropBehavior) {
                self.drop_behavior = drop_behavior;
            }
            /// A convenience method which consumes and commits a transaction.
            #[inline]
            pub fn commit(mut self) -> Result<()> {
                self.commit_()
            }

            #[inline]
            fn commit_(&mut self) -> Result<()> {
                self.conn.execute_batch("COMMIT")?;
                Ok(())
            }
            /// A convenience method which consumes and rolls back a transaction.
            #[inline]
            pub fn rollback(mut self) -> Result<()> {
                self.rollback_()
            }

            #[inline]
            fn rollback_(&mut self) -> Result<()> {
                self.conn.execute_batch("ROLLBACK")?;
                Ok(())
            }
            /// Consumes the transaction, committing or rolling back according to the
            /// current setting (see `drop_behavior`).
            ///
            /// Functionally equivalent to the `Drop` implementation, but allows
            /// callers to see any errors that occur.
            #[inline]
            pub fn finish(mut self) -> Result<()> {
                self.finish_()
            }

            #[inline]
            fn finish_(&mut self) -> Result<()> {
                if self.conn.is_autocommit() {
                    return Ok(());
                }
                match self.drop_behavior() {
                    DropBehavior::Commit => self.commit_().or_else(|_| self.rollback_()),
                    DropBehavior::Rollback => self.rollback_(),
                    DropBehavior::Ignore => Ok(()),
                    DropBehavior::Panic => panic!("Transaction dropped unexpectedly."),
                }
            }
        }

        impl Deref for Transaction<'_> {
            type Target = Connection;

            #[inline]
            fn deref(&self) -> &Connection {
                self.conn
            }
        }

        #[allow(unused_must_use)]
        impl Drop for Transaction<'_> {
            #[inline]
            fn drop(&mut self) {
                self.finish_();
            }
        }

        impl Savepoint<'_> {
            #[inline]
            fn with_name_<T: Into<String>>(conn: &Connection, name: T) -> Result<Savepoint<'_>> {
                let name = name.into();
                conn.execute_batch(&format!("SAVEPOINT {name}"))
                    .map(|()| Savepoint {
                        conn,
                        name,
                        drop_behavior: DropBehavior::Rollback,
                        committed: false,
                    })
            }

            #[inline]
            fn new_(conn: &Connection) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(conn, "_rusqlite_sp")
            }
            /// Begin a new savepoint. Can be nested.
            #[inline]
            pub fn new(conn: &mut Connection) -> Result<Savepoint<'_>> {
                Savepoint::new_(conn)
            }
            /// Begin a new savepoint with a user-provided savepoint name.
            #[inline]
            pub fn with_name<T: Into<String>>(conn: &mut Connection, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(conn, name)
            }
            /// Begin a nested savepoint.
            #[inline]
            pub fn savepoint(&mut self) -> Result<Savepoint<'_>> {
                Savepoint::new_(self.conn)
            }
            /// Begin a nested savepoint with a user-provided savepoint name.
            #[inline]
            pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(self.conn, name)
            }
            /// Get the current setting for what happens to the savepoint when it is dropped.
            #[inline]
            #[must_use]
            pub fn drop_behavior(&self) -> DropBehavior {
                self.drop_behavior
            }
            /// Configure the savepoint to perform the specified action when it is dropped.
            #[inline]
            pub fn set_drop_behavior(&mut self, drop_behavior: DropBehavior) {
                self.drop_behavior = drop_behavior;
            }
            /// A convenience method which consumes and commits a savepoint.
            #[inline]
            pub fn commit(mut self) -> Result<()> {
                self.commit_()
            }

            #[inline]
            fn commit_(&mut self) -> Result<()> {
                self.conn.execute_batch(&format!("RELEASE {}", self.name))?;
                self.committed = true;
                Ok(())
            }
            /// A convenience method which rolls back a savepoint.
            #[inline]
            pub fn rollback(&mut self) -> Result<()> {
                self.conn
                    .execute_batch(&format!("ROLLBACK TO {}", self.name))
            }
            /// Consumes the savepoint, committing or rolling back according to the
            /// current setting (see `drop_behavior`).
            #[inline]
            pub fn finish(mut self) -> Result<()> {
                self.finish_()
            }

            #[inline]
            fn finish_(&mut self) -> Result<()> {
                if self.committed {
                    return Ok(());
                }
                match self.drop_behavior() {
                    DropBehavior::Commit => self
                        .commit_()
                        .or_else(|_| self.rollback().and_then(|()| self.commit_())),
                    DropBehavior::Rollback => self.rollback().and_then(|()| self.commit_()),
                    DropBehavior::Ignore => Ok(()),
                    DropBehavior::Panic => panic!("Savepoint dropped unexpectedly."),
                }
            }
        }

        impl Deref for Savepoint<'_> {
            type Target = Connection;

            #[inline]
            fn deref(&self) -> &Connection {
                self.conn
            }
        }

        #[allow(unused_must_use)]
        impl Drop for Savepoint<'_> {
            #[inline]
            fn drop(&mut self) {
                self.finish_();
            }
        }
        /// Transaction state of a database
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[non_exhaustive]
        #[cfg(feature = "modern_sqlite")] // 3.37.0
        #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
        pub enum TransactionState {
            /// Equivalent to SQLITE_TXN_NONE
            None,
            /// Equivalent to SQLITE_TXN_READ
            Read,
            /// Equivalent to SQLITE_TXN_WRITE
            Write,
        }

        impl Connection {
            /// Begin a new transaction with the default behavior (DEFERRED).
            #[inline]
            pub fn transaction(&mut self) -> Result<Transaction<'_>> {
                Transaction::new(self, self.transaction_behavior)
            }
            /// Begin a new transaction with a specified behavior.
            #[inline]
            pub fn transaction_with_behavior(
                &mut self,
                behavior: TransactionBehavior,
            ) -> Result<Transaction<'_>> {
                Transaction::new(self, behavior)
            }
            /// Begin a new transaction with the default behavior (DEFERRED).
            pub fn unchecked_transaction(&self) -> Result<Transaction<'_>> {
                Transaction::new_unchecked(self, self.transaction_behavior)
            }
            /// Begin a new savepoint with the default behavior (DEFERRED).
            #[inline]
            pub fn savepoint(&mut self) -> Result<Savepoint<'_>> {
                Savepoint::new(self)
            }
            /// Begin a new savepoint with a specified name.
            #[inline]
            pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name(self, name)
            }
            /// Determine the transaction state of a database
            #[cfg(feature = "modern_sqlite")] // 3.37.0
            #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
            pub fn transaction_state(
                &self,
                db_name: Option<crate::DatabaseName<'_>>,
            ) -> Result<TransactionState> {
                self.db.borrow().txn_state(db_name)
            }
            /// Set the default transaction behavior for the connection.
            pub fn set_transaction_behavior(&mut self, behavior: TransactionBehavior) {
                self.transaction_behavior = behavior;
            }
        }
    }

    pub mod types
    {
        //! Traits dealing with SQLite data types.
        use ::
        {
            *,
        };
        /*
        pub use self::from_sql::{FromSql, FromSqlError, FromSqlResult};
        pub use self::to_sql::{ToSql, ToSqlOutput};
        pub use self::value::Value;
        pub use self::value_ref::ValueRef;

        use std::fmt;
        */
        pub mod chrono
        {
            //! Convert most of the [Time Strings](http://sqlite.org/lang_datefunc.html) to chrono types.
            use ::
            {
                *,
            };
            /*
            use chrono::{DateTime, FixedOffset, Local, NaiveDate, NaiveDateTime, NaiveTime, TimeZone, Utc};

            use crate::types::{FromSql, FromSqlError, FromSqlResult, ToSql, ToSqlOutput, ValueRef};
            use crate::Result;
            */
            /// ISO 8601 calendar date without timezone => "YYYY-MM-DD"
            impl ToSql for NaiveDate 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%F").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// "YYYY-MM-DD" => ISO 8601 calendar date without timezone.
            impl FromSql for NaiveDate 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value
                        .as_str()
                        .and_then(|s| match NaiveDate::parse_from_str(s, "%F") {
                            Ok(dt) => Ok(dt),
                            Err(err) => Err(FromSqlError::Other(Box::new(err))),
                        })
                }
            }
            /// ISO 8601 time without timezone => "HH:MM:SS.SSS"
            impl ToSql for NaiveTime 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%T%.f").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// "HH:MM"/"HH:MM:SS"/"HH:MM:SS.SSS" => ISO 8601 time without timezone.
            impl FromSql for NaiveTime 
            {
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        let fmt = match s.len() {
                            5 => "%H:%M",
                            8 => "%T",
                            _ => "%T%.f",
                        };
                        match NaiveTime::parse_from_str(s, fmt) {
                            Ok(dt) => Ok(dt),
                            Err(err) => Err(FromSqlError::Other(Box::new(err))),
                        }
                    })
                }
            }
            /// ISO 8601 combined date and time without timezone =>
            /// "YYYY-MM-DD HH:MM:SS.SSS"
            impl ToSql for NaiveDateTime 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%F %T%.f").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// "YYYY-MM-DD HH:MM:SS"/"YYYY-MM-DD HH:MM:SS.SSS" => ISO 8601 combined date
            /// and time without timezone. ("YYYY-MM-DDTHH:MM:SS"/"YYYY-MM-DDTHH:MM:SS.SSS"
            /// also supported)
            impl FromSql for NaiveDateTime 
            {
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        let fmt = if s.len() >= 11 && s.as_bytes()[10] == b'T' {
                            "%FT%T%.f"
                        } else {
                            "%F %T%.f"
                        };

                        match NaiveDateTime::parse_from_str(s, fmt) {
                            Ok(dt) => Ok(dt),
                            Err(err) => Err(FromSqlError::Other(Box::new(err))),
                        }
                    })
                }
            }
            /// UTC time => UTC RFC3339 timestamp
            /// ("YYYY-MM-DD HH:MM:SS.SSS+00:00").
            impl ToSql for DateTime<Utc> 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%F %T%.f%:z").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// Local time => UTC RFC3339 timestamp
            /// ("YYYY-MM-DD HH:MM:SS.SSS+00:00").
            impl ToSql for DateTime<Local> 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.with_timezone(&Utc).format("%F %T%.f%:z").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// Date and time with time zone => RFC3339 timestamp
            /// ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM").
            impl ToSql for DateTime<FixedOffset> 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%F %T%.f%:z").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// RFC3339 ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM") into `DateTime<Utc>`.
            impl FromSql for DateTime<Utc> 
            {
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    {
                        // Try to parse value as rfc3339 first.
                        let s = value.as_str()?;

                        let fmt = if s.len() >= 11 && s.as_bytes()[10] == b'T' {
                            "%FT%T%.f%#z"
                        } else {
                            "%F %T%.f%#z"
                        };

                        if let Ok(dt) = DateTime::parse_from_str(s, fmt) {
                            return Ok(dt.with_timezone(&Utc));
                        }
                    }

                    // Couldn't parse as rfc3339 - fall back to NaiveDateTime.
                    NaiveDateTime::column_result(value).map(|dt| Utc.from_utc_datetime(&dt))
                }
            }
            /// RFC3339 ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM") into `DateTime<Local>`.
            impl FromSql for DateTime<Local> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let utc_dt = DateTime::<Utc>::column_result(value)?;
                    Ok(utc_dt.with_timezone(&Local))
                }
            }
            /// RFC3339 ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM") into `DateTime<FixedOffset>`.
            impl FromSql for DateTime<FixedOffset> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let s = String::column_result(value)?;
                    Self::parse_from_rfc3339(s.as_str())
                        .or_else(|_| Self::parse_from_str(s.as_str(), "%F %T%.f%:z"))
                        .map_err(|e| FromSqlError::Other(Box::new(e)))
                }
            }
        }

        pub mod from_sql
        {
            use ::
            {
                *,
            };
            /*
            use super::{Value, ValueRef};
            use std::error::Error;
            use std::fmt;
            */

            /// Enum listing possible errors from [`FromSql`] trait.
            #[derive(Debug)]
            #[non_exhaustive]
            pub enum FromSqlError 
            {
                /// Error when an SQLite value is requested, but the type of the result
                /// cannot be converted to the requested Rust type.
                InvalidType,

                /// Error when the i64 value returned by SQLite cannot be stored into the
                /// requested type.
                OutOfRange(i64),

                /// Error when the blob result returned by SQLite cannot be stored into the
                /// requested type due to a size mismatch.
                InvalidBlobSize {
                    /// The expected size of the blob.
                    expected_size: usize,
                    /// The actual size of the blob that was returned.
                    blob_size: usize,
                },

                /// An error case available for implementors of the [`FromSql`] trait.
                Other(Box<dyn Error + Send + Sync + 'static>),
            }

            impl PartialEq for FromSqlError 
            {
                fn eq(&self, other: &FromSqlError) -> bool {
                    match (self, other) {
                        (FromSqlError::InvalidType, FromSqlError::InvalidType) => true,
                        (FromSqlError::OutOfRange(n1), FromSqlError::OutOfRange(n2)) => n1 == n2,
                        (
                            FromSqlError::InvalidBlobSize {
                                expected_size: es1,
                                blob_size: bs1,
                            },
                            FromSqlError::InvalidBlobSize {
                                expected_size: es2,
                                blob_size: bs2,
                            },
                        ) => es1 == es2 && bs1 == bs2,
                        (..) => false,
                    }
                }
            }

            impl fmt::Display for FromSqlError 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    match *self {
                        FromSqlError::InvalidType => write!(f, "Invalid type"),
                        FromSqlError::OutOfRange(i) => write!(f, "Value {i} out of range"),
                        FromSqlError::InvalidBlobSize {
                            expected_size,
                            blob_size,
                        } => {
                            write!(
                                f,
                                "Cannot read {expected_size} byte value out of {blob_size} byte blob"
                            )
                        }
                        FromSqlError::Other(ref err) => err.fmt(f),
                    }
                }
            }

            impl Error for FromSqlError 
            {
                fn source(&self) -> Option<&(dyn Error + 'static)> {
                    if let FromSqlError::Other(ref err) = self {
                        Some(&**err)
                    } else {
                        None
                    }
                }
            }
            /// Result type for implementors of the [`FromSql`] trait.
            pub type FromSqlResult<T> = Result<T, FromSqlError>;

            /// A trait for types that can be created from a SQLite value.
            pub trait FromSql: Sized 
            {
                /// Converts SQLite value into Rust value.
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self>;
            }

            macro_rules! from_sql_integral(
                ($t:ident) => (
                    impl FromSql for $t {
                        #[inline]
                        fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                            let i = i64::column_result(value)?;
                            i.try_into().map_err(|_| FromSqlError::OutOfRange(i))
                        }
                    }
                );
                (non_zero $nz:ty, $z:ty) => (
                    impl FromSql for $nz {
                        #[inline]
                        fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                            let i = <$z>::column_result(value)?;
                            <$nz>::new(i).ok_or(FromSqlError::OutOfRange(0))
                        }
                    }
                )
            );

            from_sql_integral!(i8);
            from_sql_integral!(i16);
            from_sql_integral!(i32);
            
            from_sql_integral!(isize);
            from_sql_integral!(u8);
            from_sql_integral!(u16);
            from_sql_integral!(u32);
            from_sql_integral!(u64);
            from_sql_integral!(usize);

            from_sql_integral!(non_zero std::num::NonZeroIsize, isize);
            from_sql_integral!(non_zero std::num::NonZeroI8, i8);
            from_sql_integral!(non_zero std::num::NonZeroI16, i16);
            from_sql_integral!(non_zero std::num::NonZeroI32, i32);
            from_sql_integral!(non_zero std::num::NonZeroI64, i64);

            from_sql_integral!(non_zero std::num::NonZeroUsize, usize);
            from_sql_integral!(non_zero std::num::NonZeroU8, u8);
            from_sql_integral!(non_zero std::num::NonZeroU16, u16);
            from_sql_integral!(non_zero std::num::NonZeroU32, u32);
            from_sql_integral!(non_zero std::num::NonZeroU64, u64);

            impl FromSql for i64 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_i64()
                }
            }

            impl FromSql for f32 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Integer(i) => Ok(i as f32),
                        ValueRef::Real(f) => Ok(f as f32),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }

            impl FromSql for f64 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Integer(i) => Ok(i as f64),
                        ValueRef::Real(f) => Ok(f),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }

            impl FromSql for bool 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    i64::column_result(value).map(|i| i != 0)
                }
            }

            impl FromSql for String 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(ToString::to_string)
                }
            }

            impl FromSql for Box<str> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(Into::into)
                }
            }

            impl FromSql for std::rc::Rc<str> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(Into::into)
                }
            }

            impl FromSql for std::sync::Arc<str> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(Into::into)
                }
            }

            impl FromSql for Vec<u8> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_blob().map(<[u8]>::to_vec)
                }
            }

            impl<const N: usize> FromSql for [u8; N] 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let slice = value.as_blob()?;
                    slice.try_into().map_err(|_| FromSqlError::InvalidBlobSize {
                        expected_size: N,
                        blob_size: slice.len(),
                    })
                }
            }

            #[cfg(feature = "uuid")]
            impl FromSql for uuid::Uuid 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let bytes = <[u8; 16]>::column_result(value)?;
                    Ok(uuid::Uuid::from_u128(u128::from_be_bytes(bytes)))
                }
            }

            impl<T: FromSql> FromSql for Option<T> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Null => Ok(None),
                        _ => FromSql::column_result(value).map(Some),
                    }
                }
            }

            impl FromSql for Value 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    Ok(value.into())
                }
            }
        }
        
        pub mod time
        {
            //! Convert formats 1-10 in [Time Values](https://sqlite.org/lang_datefunc.html#time_values) to time types.
            use ::
            {
                *,
            };
            
            use crate::types::{FromSql, FromSqlError, FromSqlResult, ToSql, ToSqlOutput, ValueRef};
            use crate::{Error, Result};
            use time::format_description::FormatItem;
            use time::macros::format_description;
            use time::{Date, OffsetDateTime, PrimitiveDateTime, Time};

            const OFFSET_DATE_TIME_ENCODING: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day] [hour]:[minute]:[second].[subsecond][offset_hour sign:mandatory]:[offset_minute]"
            );
            const PRIMITIVE_DATE_TIME_ENCODING: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day] [hour]:[minute]:[second].[subsecond]"
            );
            const TIME_ENCODING: &[FormatItem<'_>] =
                format_description!(version = 2, "[hour]:[minute]:[second].[subsecond]");

            const DATE_FORMAT: &[FormatItem<'_>] = format_description!(version = 2, "[year]-[month]-[day]");
            const TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[hour]:[minute][optional [:[second][optional [.[subsecond]]]]]"
            );
            const PRIMITIVE_DATE_TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day][first [ ][T]][hour]:[minute][optional [:[second][optional [.[subsecond]]]]]"
            );
            const UTC_DATE_TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day][first [ ][T]][hour]:[minute][optional [:[second][optional [.[subsecond]]]]][optional [Z]]"
            );
            const OFFSET_DATE_TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day][first [ ][T]][hour]:[minute][optional [:[second][optional [.[subsecond]]]]][offset_hour sign:mandatory]:[offset_minute]"
            );
            const LEGACY_DATE_TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day] [hour]:[minute]:[second]:[subsecond] [offset_hour sign:mandatory]:[offset_minute]"
            );

            /// OffsetDatetime => RFC3339 format ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM")
            impl ToSql for OffsetDateTime {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let time_string = self
                        .format(&OFFSET_DATE_TIME_ENCODING)
                        .map_err(|err| Error::ToSqlConversionFailure(err.into()))?;
                    Ok(ToSqlOutput::from(time_string))
                }
            }

            // Supports parsing formats 2-7 from https://www.sqlite.org/lang_datefunc.html
            // Formats 2-7 without a timezone assumes UTC
            impl FromSql for OffsetDateTime {
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        if let Some(b' ') = s.as_bytes().get(23) {
                            // legacy
                            return OffsetDateTime::parse(s, &LEGACY_DATE_TIME_FORMAT)
                                .map_err(|err| FromSqlError::Other(Box::new(err)));
                        }
                        if s[8..].contains('+') || s[8..].contains('-') {
                            // Formats 2-7 with timezone
                            return OffsetDateTime::parse(s, &OFFSET_DATE_TIME_FORMAT)
                                .map_err(|err| FromSqlError::Other(Box::new(err)));
                        }
                        // Formats 2-7 without timezone
                        PrimitiveDateTime::parse(s, &UTC_DATE_TIME_FORMAT)
                            .map(|p| p.assume_utc())
                            .map_err(|err| FromSqlError::Other(Box::new(err)))
                    })
                }
            }
            /// ISO 8601 calendar date without timezone => "YYYY-MM-DD"
            impl ToSql for Date {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self
                        .format(&DATE_FORMAT)
                        .map_err(|err| Error::ToSqlConversionFailure(err.into()))?;
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// "YYYY-MM-DD" => ISO 8601 calendar date without timezone.
            impl FromSql for Date {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        Date::parse(s, &DATE_FORMAT).map_err(|err| FromSqlError::Other(err.into()))
                    })
                }
            }
            /// ISO 8601 time without timezone => "HH:MM:SS.SSS"
            impl ToSql for Time {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let time_str = self
                        .format(&TIME_ENCODING)
                        .map_err(|err| Error::ToSqlConversionFailure(err.into()))?;
                    Ok(ToSqlOutput::from(time_str))
                }
            }
            /// "HH:MM"/"HH:MM:SS"/"HH:MM:SS.SSS" => ISO 8601 time without timezone.
            impl FromSql for Time {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        Time::parse(s, &TIME_FORMAT).map_err(|err| FromSqlError::Other(err.into()))
                    })
                }
            }
            /// ISO 8601 combined date and time without timezone => "YYYY-MM-DD HH:MM:SS.SSS"
            impl ToSql for PrimitiveDateTime {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_time_str = self
                        .format(&PRIMITIVE_DATE_TIME_ENCODING)
                        .map_err(|err| Error::ToSqlConversionFailure(err.into()))?;
                    Ok(ToSqlOutput::from(date_time_str))
                }
            }
            /// YYYY-MM-DD HH:MM
            /// YYYY-MM-DDTHH:MM
            /// YYYY-MM-DD HH:MM:SS
            /// YYYY-MM-DDTHH:MM:SS
            /// YYYY-MM-DD HH:MM:SS.SSS
            /// YYYY-MM-DDTHH:MM:SS.SSS
            /// => ISO 8601 combined date and time with timezone
            impl FromSql for PrimitiveDateTime {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        PrimitiveDateTime::parse(s, &PRIMITIVE_DATE_TIME_FORMAT)
                            .map_err(|err| FromSqlError::Other(err.into()))
                    })
                }
            }
        }
        
        pub mod to_sql
        {
            use ::
            {
                *,
            };
            use super::{Null, Value, ValueRef};
            #[cfg(feature = "array")]
            use crate::vtab::array::Array;
            use crate::{Error, Result};
            use std::borrow::Cow;

            /// `ToSqlOutput` represents the possible output types for implementers of the
            /// [`ToSql`] trait.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ToSqlOutput<'a> {
                /// A borrowed SQLite-representable value.
                Borrowed(ValueRef<'a>),

                /// An owned SQLite-representable value.
                Owned(Value),

                /// A BLOB of the given length that is filled with
                /// zeroes.
                #[cfg(feature = "blob")]
                #[cfg_attr(docsrs, doc(cfg(feature = "blob")))]
                ZeroBlob(i32),

                /// n-th arg of an SQL scalar function
                #[cfg(feature = "functions")]
                #[cfg_attr(docsrs, doc(cfg(feature = "functions")))]
                Arg(usize),

                /// `feature = "array"`
                #[cfg(feature = "array")]
                #[cfg_attr(docsrs, doc(cfg(feature = "array")))]
                Array(Array),
            }

            // Generically allow any type that can be converted into a ValueRef
            // to be converted into a ToSqlOutput as well.
            impl<'a, T: ?Sized> From<&'a T> for ToSqlOutput<'a>
            where
                &'a T: Into<ValueRef<'a>>,
            {
                #[inline]
                fn from(t: &'a T) -> Self {
                    ToSqlOutput::Borrowed(t.into())
                }
            }

            // We cannot also generically allow any type that can be converted
            // into a Value to be converted into a ToSqlOutput because of
            // coherence rules (https://github.com/rust-lang/rust/pull/46192),
            // so we'll manually implement it for all the types we know can
            // be converted into Values.
            macro_rules! from_value(
                ($t:ty) => (
                    impl From<$t> for ToSqlOutput<'_> {
                        #[inline]
                        fn from(t: $t) -> Self { ToSqlOutput::Owned(t.into())}
                    }
                );
                (non_zero $t:ty) => (
                    impl From<$t> for ToSqlOutput<'_> {
                        #[inline]
                        fn from(t: $t) -> Self { ToSqlOutput::Owned(t.get().into())}
                    }
                )
            );
            from_value!(String);
            from_value!(Null);
            from_value!(bool);
            from_value!(i8);
            from_value!(i16);
            from_value!(i32);
            from_value!(i64);
            from_value!(isize);
            from_value!(u8);
            from_value!(u16);
            from_value!(u32);
            from_value!(f32);
            from_value!(f64);
            from_value!(Vec<u8>);

            from_value!(non_zero std::num::NonZeroI8);
            from_value!(non_zero std::num::NonZeroI16);
            from_value!(non_zero std::num::NonZeroI32);
            from_value!(non_zero std::num::NonZeroI64);
            from_value!(non_zero std::num::NonZeroIsize);
            from_value!(non_zero std::num::NonZeroU8);
            from_value!(non_zero std::num::NonZeroU16);
            from_value!(non_zero std::num::NonZeroU32);

            // It would be nice if we could avoid the heap allocation (of the `Vec`) that
            // `i128` needs in `Into<Value>`, but it's probably fine for the moment, and not
            // worth adding another case to Value.
            #[cfg(feature = "i128_blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "i128_blob")))]
            from_value!(i128);

            #[cfg(feature = "i128_blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "i128_blob")))]
            from_value!(non_zero std::num::NonZeroI128);

            #[cfg(feature = "uuid")]
            #[cfg_attr(docsrs, doc(cfg(feature = "uuid")))]
            from_value!(uuid::Uuid);

            impl ToSql for ToSqlOutput<'_> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(match *self {
                        ToSqlOutput::Borrowed(v) => ToSqlOutput::Borrowed(v),
                        ToSqlOutput::Owned(ref v) => ToSqlOutput::Borrowed(ValueRef::from(v)),

                        #[cfg(feature = "blob")]
                        ToSqlOutput::ZeroBlob(i) => ToSqlOutput::ZeroBlob(i),
                        #[cfg(feature = "functions")]
                        ToSqlOutput::Arg(i) => ToSqlOutput::Arg(i),
                        #[cfg(feature = "array")]
                        ToSqlOutput::Array(ref a) => ToSqlOutput::Array(a.clone()),
                    })
                }
            }
            /// A trait for types that can be converted into SQLite values. Returns
            /// [`Error::ToSqlConversionFailure`] if the conversion fails.
            pub trait ToSql {
                /// Converts Rust value to SQLite value
                fn to_sql(&self) -> Result<ToSqlOutput<'_>>;
            }

            impl<T: ToSql + ToOwned + ?Sized> ToSql for Cow<'_, T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            impl<T: ToSql + ?Sized> ToSql for Box<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            impl<T: ToSql + ?Sized> ToSql for std::rc::Rc<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            impl<T: ToSql + ?Sized> ToSql for std::sync::Arc<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }
            
            macro_rules! to_sql_self(
                ($t:ty) => (
                    impl ToSql for $t {
                        #[inline]
                        fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                            Ok(ToSqlOutput::from(*self))
                        }
                    }
                )
            );

            to_sql_self!(Null);
            to_sql_self!(bool);
            to_sql_self!(i8);
            to_sql_self!(i16);
            to_sql_self!(i32);
            to_sql_self!(i64);
            to_sql_self!(isize);
            to_sql_self!(u8);
            to_sql_self!(u16);
            to_sql_self!(u32);
            to_sql_self!(f32);
            to_sql_self!(f64);

            to_sql_self!(std::num::NonZeroI8);
            to_sql_self!(std::num::NonZeroI16);
            to_sql_self!(std::num::NonZeroI32);
            to_sql_self!(std::num::NonZeroI64);
            to_sql_self!(std::num::NonZeroIsize);
            to_sql_self!(std::num::NonZeroU8);
            to_sql_self!(std::num::NonZeroU16);
            to_sql_self!(std::num::NonZeroU32);

            #[cfg(feature = "i128_blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "i128_blob")))]
            to_sql_self!(i128);

            #[cfg(feature = "i128_blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "i128_blob")))]
            to_sql_self!(std::num::NonZeroI128);

            #[cfg(feature = "uuid")]
            #[cfg_attr(docsrs, doc(cfg(feature = "uuid")))]
            to_sql_self!(uuid::Uuid);

            macro_rules! to_sql_self_fallible(
                ($t:ty) => (
                    impl ToSql for $t {
                        #[inline]
                        fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                            Ok(ToSqlOutput::Owned(Value::Integer(
                                i64::try_from(*self).map_err(
                                    // TODO: Include the values in the error message.
                                    |err| Error::ToSqlConversionFailure(err.into())
                                )?
                            )))
                        }
                    }
                );
                (non_zero $t:ty) => (
                    impl ToSql for $t {
                        #[inline]
                        fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                            Ok(ToSqlOutput::Owned(Value::Integer(
                                i64::try_from(self.get()).map_err(
                                    // TODO: Include the values in the error message.
                                    |err| Error::ToSqlConversionFailure(err.into())
                                )?
                            )))
                        }
                    }
                )
            );

            // Special implementations for usize and u64 because these conversions can fail.
            to_sql_self_fallible!(u64);
            to_sql_self_fallible!(usize);
            to_sql_self_fallible!(non_zero std::num::NonZeroU64);
            to_sql_self_fallible!(non_zero std::num::NonZeroUsize);

            impl<T: ?Sized> ToSql for &'_ T
            where
                T: ToSql,
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    (*self).to_sql()
                }
            }

            impl ToSql for String {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self.as_str()))
                }
            }

            impl ToSql for str {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self))
                }
            }

            impl ToSql for Vec<u8> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self.as_slice()))
                }
            }

            impl<const N: usize> ToSql for [u8; N] {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(&self[..]))
                }
            }

            impl ToSql for [u8] {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self))
                }
            }

            impl ToSql for Value {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self))
                }
            }

            impl<T: ToSql> ToSql for Option<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    match *self {
                        None => Ok(ToSqlOutput::from(Null)),
                        Some(ref t) => t.to_sql(),
                    }
                }
            }
        }
        
        pub mod url
        {
            //! [`ToSql`] and [`FromSql`] implementation for [`url::Url`].
            use ::
            {
                *,
            };
            
            use crate::types::{FromSql, FromSqlError, FromSqlResult, ToSql, ToSqlOutput, ValueRef};
            use crate::Result;
            use url::Url;

            /// Serialize `Url` to text.
            impl ToSql for Url {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self.as_str()))
                }
            }
            /// Deserialize text to `Url`.
            impl FromSql for Url {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Text(s) => {
                            let s = std::str::from_utf8(s).map_err(|e| FromSqlError::Other(Box::new(e)))?;
                            Url::parse(s).map_err(|e| FromSqlError::Other(Box::new(e)))
                        }
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }
        }
        
        pub mod value
        {
            use ::
            {
                *,
            };
            use super::{Null, Type};

            /// Owning [dynamic type value](http://sqlite.org/datatype3.html). Value's type is typically
            /// dictated by SQLite (not by the caller).
            ///
            /// See [`ValueRef`](crate::types::ValueRef) for a non-owning dynamic type
            /// value.
            #[derive(Clone, Debug, PartialEq)]
            pub enum Value {
                /// The value is a `NULL` value.
                Null,
                /// The value is a signed integer.
                Integer(i64),
                /// The value is a floating point number.
                Real(f64),
                /// The value is a text string.
                Text(String),
                /// The value is a blob of data
                Blob(Vec<u8>),
            }

            impl From<Null> for Value {
                #[inline]
                fn from(_: Null) -> Value {
                    Value::Null
                }
            }

            impl From<bool> for Value {
                #[inline]
                fn from(i: bool) -> Value {
                    Value::Integer(i as i64)
                }
            }

            impl From<isize> for Value {
                #[inline]
                fn from(i: isize) -> Value {
                    Value::Integer(i as i64)
                }
            }
            
            impl From<uuid::Uuid> for Value {
                #[inline]
                fn from(id: uuid::Uuid) -> Value {
                    Value::Blob(id.as_bytes().to_vec())
                }
            }

            macro_rules! from_i64(
                ($t:ty) => (
                    impl From<$t> for Value {
                        #[inline]
                        fn from(i: $t) -> Value {
                            Value::Integer(i64::from(i))
                        }
                    }
                )
            );

            from_i64!(i8);
            from_i64!(i16);
            from_i64!(i32);
            from_i64!(u8);
            from_i64!(u16);
            from_i64!(u32);

            impl From<i64> for Value {
                #[inline]
                fn from(i: i64) -> Value {
                    Value::Integer(i)
                }
            }

            impl From<f32> for Value {
                #[inline]
                fn from(f: f32) -> Value {
                    Value::Real(f.into())
                }
            }

            impl From<f64> for Value {
                #[inline]
                fn from(f: f64) -> Value {
                    Value::Real(f)
                }
            }

            impl From<String> for Value {
                #[inline]
                fn from(s: String) -> Value {
                    Value::Text(s)
                }
            }

            impl From<Vec<u8>> for Value {
                #[inline]
                fn from(v: Vec<u8>) -> Value {
                    Value::Blob(v)
                }
            }

            impl<T> From<Option<T>> for Value
            where
                T: Into<Value>,
            {
                #[inline]
                fn from(v: Option<T>) -> Value {
                    match v {
                        Some(x) => x.into(),
                        None => Value::Null,
                    }
                }
            }

            impl Value {
                /// Returns SQLite fundamental datatype.
                #[inline]
                #[must_use]
                pub fn data_type(&self) -> Type {
                    match *self {
                        Value::Null => Type::Null,
                        Value::Integer(_) => Type::Integer,
                        Value::Real(_) => Type::Real,
                        Value::Text(_) => Type::Text,
                        Value::Blob(_) => Type::Blob,
                    }
                }
            }
        }
        
        pub mod value_ref
        {
            use ::
            {
                *,
            };
            use super::{Type, Value};
            use crate::types::{FromSqlError, FromSqlResult};

            /// A non-owning [dynamic type value](http://sqlite.org/datatype3.html). Typically, the
            /// memory backing this value is owned by SQLite.
            ///
            /// See [`Value`](Value) for an owning dynamic type value.
            #[derive(Copy, Clone, Debug, PartialEq)]
            pub enum ValueRef<'a> {
                /// The value is a `NULL` value.
                Null,
                /// The value is a signed integer.
                Integer(i64),
                /// The value is a floating point number.
                Real(f64),
                /// The value is a text string.
                Text(&'a [u8]),
                /// The value is a blob of data
                Blob(&'a [u8]),
            }

            impl ValueRef<'_> {
                /// Returns SQLite fundamental datatype.
                #[inline]
                #[must_use]
                pub fn data_type(&self) -> Type {
                    match *self {
                        ValueRef::Null => Type::Null,
                        ValueRef::Integer(_) => Type::Integer,
                        ValueRef::Real(_) => Type::Real,
                        ValueRef::Text(_) => Type::Text,
                        ValueRef::Blob(_) => Type::Blob,
                    }
                }
            }

            impl<'a> ValueRef<'a> {
                /// If `self` is case `Integer`, returns the integral value. Otherwise,
                /// returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_i64(&self) -> FromSqlResult<i64> {
                    match *self {
                        ValueRef::Integer(i) => Ok(i),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is case `Integer`, returns the integral value.
                /// Otherwise, returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_i64_or_null(&self) -> FromSqlResult<Option<i64>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Integer(i) => Ok(Some(i)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Real`, returns the floating point value. Otherwise,
                /// returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_f64(&self) -> FromSqlResult<f64> {
                    match *self {
                        ValueRef::Real(f) => Ok(f),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is case `Real`, returns the floating point value.
                /// Otherwise, returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_f64_or_null(&self) -> FromSqlResult<Option<f64>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Real(f) => Ok(Some(f)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Text`, returns the string value. Otherwise, returns
                /// [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_str(&self) -> FromSqlResult<&'a str> {
                    match *self {
                        ValueRef::Text(t) => {
                            std::str::from_utf8(t).map_err(|e| FromSqlError::Other(Box::new(e)))
                        }
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is case `Text`, returns the string value.
                /// Otherwise, returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_str_or_null(&self) -> FromSqlResult<Option<&'a str>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Text(t) => std::str::from_utf8(t)
                            .map_err(|e| FromSqlError::Other(Box::new(e)))
                            .map(Some),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Blob`, returns the byte slice. Otherwise, returns
                /// [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_blob(&self) -> FromSqlResult<&'a [u8]> {
                    match *self {
                        ValueRef::Blob(b) => Ok(b),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is case `Blob`, returns the byte slice.
                /// Otherwise, returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_blob_or_null(&self) -> FromSqlResult<Option<&'a [u8]>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Blob(b) => Ok(Some(b)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// Returns the byte slice that makes up this `ValueRef` if it's either
                /// [`ValueRef::Blob`] or [`ValueRef::Text`].
                #[inline]
                pub fn as_bytes(&self) -> FromSqlResult<&'a [u8]> {
                    match self {
                        ValueRef::Text(s) | ValueRef::Blob(s) => Ok(s),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is [`ValueRef::Blob`] or [`ValueRef::Text`] returns the byte
                /// slice that makes up this value
                #[inline]
                pub fn as_bytes_or_null(&self) -> FromSqlResult<Option<&'a [u8]>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Text(s) | ValueRef::Blob(s) => Ok(Some(s)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }

            impl From<ValueRef<'_>> for Value {
                #[inline]
                #[track_caller]
                fn from(borrowed: ValueRef<'_>) -> Value {
                    match borrowed {
                        ValueRef::Null => Value::Null,
                        ValueRef::Integer(i) => Value::Integer(i),
                        ValueRef::Real(r) => Value::Real(r),
                        ValueRef::Text(s) => {
                            let s = std::str::from_utf8(s).expect("invalid UTF-8");
                            Value::Text(s.to_string())
                        }
                        ValueRef::Blob(b) => Value::Blob(b.to_vec()),
                    }
                }
            }

            impl<'a> From<&'a str> for ValueRef<'a> {
                #[inline]
                fn from(s: &str) -> ValueRef<'_> {
                    ValueRef::Text(s.as_bytes())
                }
            }

            impl<'a> From<&'a [u8]> for ValueRef<'a> {
                #[inline]
                fn from(s: &[u8]) -> ValueRef<'_> {
                    ValueRef::Blob(s)
                }
            }

            impl<'a> From<&'a Value> for ValueRef<'a> {
                #[inline]
                fn from(value: &'a Value) -> ValueRef<'a> {
                    match *value {
                        Value::Null => ValueRef::Null,
                        Value::Integer(i) => ValueRef::Integer(i),
                        Value::Real(r) => ValueRef::Real(r),
                        Value::Text(ref s) => ValueRef::Text(s.as_bytes()),
                        Value::Blob(ref b) => ValueRef::Blob(b),
                    }
                }
            }

            impl<'a, T> From<Option<T>> for ValueRef<'a>
            where
                T: Into<ValueRef<'a>>,
            {
                #[inline]
                fn from(s: Option<T>) -> ValueRef<'a> {
                    match s {
                        Some(x) => x.into(),
                        None => ValueRef::Null,
                    }
                }
            }

            #[cfg(any(
                feature = "functions",
                feature = "session",
                feature = "vtab",
                feature = "preupdate_hook"
            ))]
            impl<'a> ValueRef<'a> {
                pub unsafe fn from_value(value: *mut crate::ffi::sqlite3_value) -> ValueRef<'a> {
                    use crate::ffi;
                    use std::slice::from_raw_parts;

                    match ffi::sqlite3_value_type(value) {
                        ffi::SQLITE_NULL => ValueRef::Null,
                        ffi::SQLITE_INTEGER => ValueRef::Integer(ffi::sqlite3_value_int64(value)),
                        ffi::SQLITE_FLOAT => ValueRef::Real(ffi::sqlite3_value_double(value)),
                        ffi::SQLITE_TEXT => {
                            let text = ffi::sqlite3_value_text(value);
                            let len = ffi::sqlite3_value_bytes(value);
                            assert!(
                                !text.is_null(),
                                "unexpected SQLITE_TEXT value type with NULL data"
                            );
                            let s = from_raw_parts(text.cast::<u8>(), len as usize);
                            ValueRef::Text(s)
                        }
                        ffi::SQLITE_BLOB => {
                            let (blob, len) = (
                                ffi::sqlite3_value_blob(value),
                                ffi::sqlite3_value_bytes(value),
                            );

                            assert!(
                                len >= 0,
                                "unexpected negative return from sqlite3_value_bytes"
                            );
                            if len > 0 {
                                assert!(
                                    !blob.is_null(),
                                    "unexpected SQLITE_BLOB value type with NULL data"
                                );
                                ValueRef::Blob(from_raw_parts(blob.cast::<u8>(), len as usize))
                            } else {
                                // The return value from sqlite3_value_blob() for a zero-length BLOB
                                // is a NULL pointer.
                                ValueRef::Blob(&[])
                            }
                        }
                        _ => unreachable!("sqlite3_value_type returned invalid value"),
                    }
                }

                // TODO sqlite3_value_nochange // 3.22.0 & VTab xUpdate
                // TODO sqlite3_value_frombind // 3.28.0
            }
        }
        /// Empty struct that can be used to fill in a query parameter as `NULL`.
        #[derive(Copy, Clone)]
        pub struct Null;
        /// SQLite data types.
        #[derive(Copy, Clone, Debug, PartialEq, Eq)]
        pub enum Type 
        {
            /// NULL
            Null,
            /// 64-bit signed integer
            Integer,
            /// 64-bit IEEE floating point number
            Real,
            /// String
            Text,
            /// BLOB
            Blob,
        }

        impl fmt::Display for Type 
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match *self {
                    Type::Null => f.pad("Null"),
                    Type::Integer => f.pad("Integer"),
                    Type::Real => f.pad("Real"),
                    Type::Text => f.pad("Text"),
                    Type::Blob => f.pad("Blob"),
                }
            }
        }
    }
    
    mod unlock_notify
    {
        //! [Unlock Notification](http://sqlite.org/unlock_notify.html)
        use ::
        {
            *,
        };
        
        /*
        use std::os::raw::c_int;
        use std::os::raw::c_void;
        use std::panic::catch_unwind;
        use std::sync::{Condvar, Mutex};

        use crate::ffi;
        */

        struct UnlockNotification {
            cond: Condvar,      // Condition variable to wait on
            mutex: Mutex<bool>, // Mutex to protect structure
        }

        #[allow(clippy::mutex_atomic)]
        impl UnlockNotification {
            fn new() -> UnlockNotification {
                UnlockNotification {
                    cond: Condvar::new(),
                    mutex: Mutex::new(false),
                }
            }

            fn fired(&self) {
                let mut flag = unpoison(self.mutex.lock());
                *flag = true;
                self.cond.notify_one();
            }

            fn wait(&self) {
                let mut fired = unpoison(self.mutex.lock());
                while !*fired {
                    fired = unpoison(self.cond.wait(fired));
                }
            }
        }

        #[inline]
        fn unpoison<T>(r: Result<T, std::sync::PoisonError<T>>) -> T {
            r.unwrap_or_else(std::sync::PoisonError::into_inner)
        }
        /// This function is an unlock-notify callback
        unsafe extern "C" fn unlock_notify_cb(ap_arg: *mut *mut c_void, n_arg: c_int) {
            use std::slice::from_raw_parts;
            let args = from_raw_parts(ap_arg as *const &UnlockNotification, n_arg as usize);
            for un in args {
                drop(catch_unwind(std::panic::AssertUnwindSafe(|| un.fired())));
            }
        }

        pub unsafe fn is_locked(db: *mut ffi::sqlite3, rc: c_int) -> bool {
            rc == ffi::SQLITE_LOCKED_SHAREDCACHE
                || (rc & 0xFF) == ffi::SQLITE_LOCKED
                    && ffi::sqlite3_extended_errcode(db) == ffi::SQLITE_LOCKED_SHAREDCACHE
        }
        /// This function assumes that an SQLite API call (either `sqlite3_prepare_v2()`
        /// or `sqlite3_step()`) has just returned `SQLITE_LOCKED`. The argument is the
        /// associated database connection.
        ///
        /// This function calls `sqlite3_unlock_notify()` to register for an
        /// unlock-notify callback, then blocks until that callback is delivered
        /// and returns `SQLITE_OK`. The caller should then retry the failed operation.
        ///
        /// Or, if `sqlite3_unlock_notify()` indicates that to block would deadlock
        /// the system, then this function returns `SQLITE_LOCKED` immediately. In
        /// this case the caller should not retry the operation and should roll
        /// back the current transaction (if any).
        #[cfg(feature = "unlock_notify")]
        pub unsafe fn wait_for_unlock_notify(db: *mut ffi::sqlite3) -> c_int {
            let un = UnlockNotification::new();
            /* Register for an unlock-notify callback. */
            let rc = ffi::sqlite3_unlock_notify(
                db,
                Some(unlock_notify_cb),
                &un as *const UnlockNotification as *mut c_void,
            );
            debug_assert!(
                rc == ffi::SQLITE_LOCKED || rc == ffi::SQLITE_LOCKED_SHAREDCACHE || rc == ffi::SQLITE_OK
            );
            if rc == ffi::SQLITE_OK {
                un.wait();
            }
            rc
        }
    }

    mod version
    {
        use ::
        {
            *,
        };
        use crate::ffi;
        use std::ffi::CStr;

        /// Returns the SQLite version as an integer; e.g., `3016002` for version
        /// 3.16.2.
        ///
        /// See [`sqlite3_libversion_number()`](https://www.sqlite.org/c3ref/libversion.html).
        #[inline]
        #[must_use]
        pub fn version_number() -> i32 {
            unsafe { ffi::sqlite3_libversion_number() }
        }
        /// Returns the SQLite version as a string; e.g., `"3.16.2"` for version 3.16.2.
        ///
        /// See [`sqlite3_libversion()`](https://www.sqlite.org/c3ref/libversion.html).
        ///
        /// # Panics
        ///
        /// Panics when version is not valid UTF-8.
        #[inline]
        #[must_use]
        pub fn version() -> &'static str {
            let cstr = unsafe { CStr::from_ptr(ffi::sqlite3_libversion()) };
            cstr.to_str()
                .expect("SQLite version string is not valid UTF8 ?!")
        }
    }
    
    pub mod vtab
    {
        //! Create virtual tables.
        use ::
        {
            borrow::{ Cow::{ self, Borrowed, Owned } },
            marker::{ PhantomData },
            rusqlite::{ Result },
            *,
        };
        /*
        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::marker::PhantomData;
        use std::os::raw::{c_char, c_int, c_void};
        use std::ptr;
        use std::slice;

        use crate::context::set_result;
        use crate::error::{error_from_sqlite_code, to_sqlite_error};
        use crate::ffi;
        pub use crate::ffi::{sqlite3_vtab, sqlite3_vtab_cursor};
        use crate::types::{FromSql, FromSqlError, ToSql, ValueRef};
        use crate::util::alloc;
        use crate::{str_to_cstring, Connection, Error, InnerConnection, Result};
        */
        /*
         let conn: Connection = ...;
         let mod: Module = ...; // VTab builder
         conn.create_module("module", mod);
        
         conn.execute("CREATE VIRTUAL TABLE foo USING module(...)");
         \-> Module::xcreate
          |-> let vtab: VTab = ...; // on the heap
          \-> conn.declare_vtab("CREATE TABLE foo (...)");
         conn = Connection::open(...);
         \-> Module::xconnect
          |-> let vtab: VTab = ...; // on the heap
          \-> conn.declare_vtab("CREATE TABLE foo (...)");
        
         conn.close();
         \-> vtab.xdisconnect
         conn.execute("DROP TABLE foo");
         \-> vtab.xDestroy
        
         let stmt = conn.prepare("SELECT ... FROM foo WHERE ...");
         \-> vtab.xbestindex
         stmt.query().next();
         \-> vtab.xopen
          |-> let cursor: VTabCursor = ...; // on the heap
          |-> cursor.xfilter or xnext
          |-> cursor.xeof
          \-> if not eof { cursor.column or xrowid } else { cursor.xclose }
        
         db: *mut ffi::sqlite3 => VTabConnection
         module: *const ffi::sqlite3_module => Module
         aux: *mut c_void => Module::Aux
         ffi::sqlite3_vtab => VTab
         ffi::sqlite3_vtab_cursor => VTabCursor
        */
        /// Virtual table kind
        pub enum VTabKind
        {
            /// Non-eponymous
            Default,
            /// [`create`](CreateVTab::create) == [`connect`](VTab::connect)
            Eponymous,
            /// No [`create`](CreateVTab::create) / [`destroy`](CreateVTab::destroy) or not used.
            EponymousOnly,
        }
        /// Virtual table module
        #[repr(transparent)]
        pub struct Module<'vtab, T: VTab<'vtab>> {
            base: ffi::sqlite3_module,
            phantom: PhantomData<&'vtab T>,
        }

        unsafe impl<'vtab, T: VTab<'vtab>> Send for Module<'vtab, T> {}
        unsafe impl<'vtab, T: VTab<'vtab>> Sync for Module<'vtab, T> {}

        union ModuleZeroHack {
            bytes: [u8; std::mem::size_of::<ffi::sqlite3_module>()],
            module: ffi::sqlite3_module,
        }
        
        const ZERO_MODULE: ffi::sqlite3_module = unsafe {
            ModuleZeroHack {
                bytes: [0_u8; std::mem::size_of::<ffi::sqlite3_module>()],
            }
            .module
        };

        macro_rules! module {
            ($lt:lifetime, $vt:ty, $ct:ty, $xc:expr, $xd:expr, $xu:expr) => {
            #[allow(clippy::needless_update)]
            &Module {
                base: ffi::sqlite3_module {
                    // We don't use V3
                    iVersion: 2,
                    xCreate: $xc,
                    xConnect: Some(rust_connect::<$vt>),
                    xBestIndex: Some(rust_best_index::<$vt>),
                    xDisconnect: Some(rust_disconnect::<$vt>),
                    xDestroy: $xd,
                    xOpen: Some(rust_open::<$vt>),
                    xClose: Some(rust_close::<$ct>),
                    xFilter: Some(rust_filter::<$ct>),
                    xNext: Some(rust_next::<$ct>),
                    xEof: Some(rust_eof::<$ct>),
                    xColumn: Some(rust_column::<$ct>),
                    xRowid: Some(rust_rowid::<$ct>), // FIXME optional
                    xUpdate: $xu,
                    xBegin: None,
                    xSync: None,
                    xCommit: None,
                    xRollback: None,
                    xFindFunction: None,
                    xRename: None,
                    xSavepoint: None,
                    xRelease: None,
                    xRollbackTo: None,
                    ..ZERO_MODULE
                },
                phantom: PhantomData::<&$lt $vt>,
            }
            };
        }
        /// Create a modifiable virtual table implementation.
        #[must_use]
        pub fn update_module<'vtab, T: UpdateVTab<'vtab>>() -> &'static Module<'vtab, T> {
            match T::KIND {
                VTabKind::EponymousOnly => {
                    module!('vtab, T, T::Cursor, None, None, Some(rust_update::<T>))
                }
                VTabKind::Eponymous => {
                    module!('vtab, T, T::Cursor, Some(rust_connect::<T>), Some(rust_disconnect::<T>), Some(rust_update::<T>))
                }
                _ => {
                    module!('vtab, T, T::Cursor, Some(rust_create::<T>), Some(rust_destroy::<T>), Some(rust_update::<T>))
                }
            }
        }
        /// Create a read-only virtual table implementation.
        #[must_use]
        pub fn read_only_module<'vtab, T: CreateVTab<'vtab>>() -> &'static Module<'vtab, T> {
            match T::KIND {
                VTabKind::EponymousOnly => eponymous_only_module(),
                VTabKind::Eponymous => {
                    // A virtual table is eponymous if its xCreate method is the exact same function
                    // as the xConnect method
                    module!('vtab, T, T::Cursor, Some(rust_connect::<T>), Some(rust_disconnect::<T>), None)
                }
                _ => {
                    // The xConnect and xCreate methods may do the same thing, but they must be
                    // different so that the virtual table is not an eponymous virtual table.
                    module!('vtab, T, T::Cursor, Some(rust_create::<T>), Some(rust_destroy::<T>), None)
                }
            }
        }
        /// Create an eponymous only virtual table implementation.
        #[must_use]
        pub fn eponymous_only_module<'vtab, T: VTab<'vtab>>() -> &'static Module<'vtab, T> {
            //  For eponymous-only virtual tables, the xCreate method is NULL
            module!('vtab, T, T::Cursor, None, None, None)
        }
        /// Virtual table configuration options
        #[repr(i32)]
        #[non_exhaustive]
        #[derive(Debug, Clone, Copy, Eq, PartialEq)]
        pub enum VTabConfig {
            /// Equivalent to SQLITE_VTAB_CONSTRAINT_SUPPORT
            ConstraintSupport = 1,
            /// Equivalent to SQLITE_VTAB_INNOCUOUS
            Innocuous = 2,
            /// Equivalent to SQLITE_VTAB_DIRECTONLY
            DirectOnly = 3,
            /// Equivalent to SQLITE_VTAB_USES_ALL_SCHEMAS
            UsesAllSchemas = 4,
        }
        /// `feature = "vtab"`
        pub struct VTabConnection(*mut ffi::sqlite3);

        impl VTabConnection {
            /// Configure various facets of the virtual table interface
            pub fn config(&mut self, config: VTabConfig) -> Result<()> {
                crate::error::check(unsafe { ffi::sqlite3_vtab_config(self.0, config as c_int) })
            }

            // TODO sqlite3_vtab_on_conflict (http://sqlite.org/c3ref/vtab_on_conflict.html) & xUpdate

            /// Get access to the underlying SQLite database connection handle.
            ///
            /// # Warning
            ///
            /// You should not need to use this function. If you do need to, please
            /// [open an issue on the rusqlite repository](https://github.com/rusqlite/rusqlite/issues) and describe
            /// your use case.
            ///
            /// # Safety
            ///
            /// This function is unsafe because it gives you raw access
            /// to the SQLite connection, and what you do with it could impact the
            /// safety of this `Connection`.
            pub unsafe fn handle(&mut self) -> *mut ffi::sqlite3 {
                self.0
            }
        }
        /// Eponymous-only virtual table instance trait.
        pub unsafe trait VTab<'vtab>: Sized {
            /// Client data passed to [`Connection::create_module`].
            type Aux;
            /// Specific cursor implementation
            type Cursor: VTabCursor;

            /// Establish a new connection to an existing virtual table.
            ///
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xconnect_method))
            fn connect(
                db: &mut VTabConnection,
                aux: Option<&Self::Aux>,
                args: &[&[u8]],
            ) -> Result<(String, Self)>;

            /// Determine the best way to access the virtual table.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xbestindex_method))
            fn best_index(&self, info: &mut IndexInfo) -> Result<()>;

            /// Create a new cursor used for accessing a virtual table.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xopen_method))
            fn open(&'vtab mut self) -> Result<Self::Cursor>;
        }
        /// Read-only virtual table instance trait.
        ///
        /// (See [SQLite doc](https://sqlite.org/c3ref/vtab.html))
        pub trait CreateVTab<'vtab>: VTab<'vtab> {
            /// For [`EponymousOnly`](VTabKind::EponymousOnly),
            /// [`create`](CreateVTab::create) and [`destroy`](CreateVTab::destroy) are
            /// not called
            const KIND: VTabKind;
            /// Create a new instance of a virtual table in response to a CREATE VIRTUAL
            /// TABLE statement. The `db` parameter is a pointer to the SQLite
            /// database connection that is executing the CREATE VIRTUAL TABLE
            /// statement.
            ///
            /// Call [`connect`](VTab::connect) by default.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xcreate_method))
            fn create(
                db: &mut VTabConnection,
                aux: Option<&Self::Aux>,
                args: &[&[u8]],
            ) -> Result<(String, Self)> {
                Self::connect(db, aux, args)
            }
            /// Destroy the underlying table implementation. This method undoes the work
            /// of [`create`](CreateVTab::create).
            ///
            /// Do nothing by default.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xdestroy_method))
            fn destroy(&self) -> Result<()> {
                Ok(())
            }
        }
        /// Writable virtual table instance trait.
        ///
        /// (See [SQLite doc](https://sqlite.org/vtab.html#xupdate))
        pub trait UpdateVTab<'vtab>: CreateVTab<'vtab> {
            /// Delete rowid or PK
            fn delete(&mut self, arg: ValueRef<'_>) -> Result<()>;
            /// Insert: `args[0] == NULL: old rowid or PK, args[1]: new rowid or PK,
            /// args[2]: ...`
            ///
            /// Return the new rowid.
            // TODO Make the distinction between argv[1] == NULL and argv[1] != NULL ?
            fn insert(&mut self, args: &Values<'_>) -> Result<i64>;
            /// Update: `args[0] != NULL: old rowid or PK, args[1]: new row id or PK,
            /// args[2]: ...`
            fn update(&mut self, args: &Values<'_>) -> Result<()>;
        }
        /// Index constraint operator.
        /// See [Virtual Table Constraint Operator Codes](https://sqlite.org/c3ref/c_index_constraint_eq.html) for details.
        #[derive(Debug, Eq, PartialEq)]
        #[allow(non_snake_case, non_camel_case_types, missing_docs)]
        #[allow(clippy::upper_case_acronyms)]
        pub enum IndexConstraintOp {
            SQLITE_INDEX_CONSTRAINT_EQ,
            SQLITE_INDEX_CONSTRAINT_GT,
            SQLITE_INDEX_CONSTRAINT_LE,
            SQLITE_INDEX_CONSTRAINT_LT,
            SQLITE_INDEX_CONSTRAINT_GE,
            SQLITE_INDEX_CONSTRAINT_MATCH,
            SQLITE_INDEX_CONSTRAINT_LIKE,         // 3.10.0
            SQLITE_INDEX_CONSTRAINT_GLOB,         // 3.10.0
            SQLITE_INDEX_CONSTRAINT_REGEXP,       // 3.10.0
            SQLITE_INDEX_CONSTRAINT_NE,           // 3.21.0
            SQLITE_INDEX_CONSTRAINT_ISNOT,        // 3.21.0
            SQLITE_INDEX_CONSTRAINT_ISNOTNULL,    // 3.21.0
            SQLITE_INDEX_CONSTRAINT_ISNULL,       // 3.21.0
            SQLITE_INDEX_CONSTRAINT_IS,           // 3.21.0
            SQLITE_INDEX_CONSTRAINT_LIMIT,        // 3.38.0
            SQLITE_INDEX_CONSTRAINT_OFFSET,       // 3.38.0
            SQLITE_INDEX_CONSTRAINT_FUNCTION(u8), // 3.25.0
        }

        impl From<u8> for IndexConstraintOp 
        {
            fn from(code: u8) -> IndexConstraintOp {
                match code {
                    2 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_EQ,
                    4 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_GT,
                    8 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_LE,
                    16 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_LT,
                    32 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_GE,
                    64 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_MATCH,
                    65 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_LIKE,
                    66 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_GLOB,
                    67 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_REGEXP,
                    68 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_NE,
                    69 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_ISNOT,
                    70 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_ISNOTNULL,
                    71 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_ISNULL,
                    72 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_IS,
                    73 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_LIMIT,
                    74 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_OFFSET,
                    v => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_FUNCTION(v),
                }
            }
        }

        bitflags::bitflags! 
        {
            /// Virtual table scan flags
            /// See [Function Flags](https://sqlite.org/c3ref/c_index_scan_unique.html) for details.
            #[repr(C)]
            #[derive(Copy, Clone, Debug)]
            pub struct IndexFlags: ::std::os::raw::c_int {
                /// Default
                const NONE     = 0;
                /// Scan visits at most 1 row.
                const SQLITE_INDEX_SCAN_UNIQUE  = ffi::SQLITE_INDEX_SCAN_UNIQUE;
            }
        }
        /// Pass information into and receive the reply from the
        /// [`VTab::best_index`] method.
        ///
        /// (See [SQLite doc](http://sqlite.org/c3ref/index_info.html))
        #[derive(Debug)]
        pub struct IndexInfo(*mut ffi::sqlite3_index_info);

        impl IndexInfo
        {
            /// Iterate on index constraint and its associated usage.
            #[inline]
            pub fn constraints_and_usages(&mut self) -> IndexConstraintAndUsageIter<'_> {
                let constraints =
                    unsafe { slice::from_raw_parts((*self.0).aConstraint, (*self.0).nConstraint as usize) };
                let constraint_usages = unsafe {
                    slice::from_raw_parts_mut((*self.0).aConstraintUsage, (*self.0).nConstraint as usize)
                };
                IndexConstraintAndUsageIter {
                    iter: constraints.iter().zip(constraint_usages.iter_mut()),
                }
            }
            /// Record WHERE clause constraints.
            #[inline]
            #[must_use]
            pub fn constraints(&self) -> IndexConstraintIter<'_> {
                let constraints =
                    unsafe { slice::from_raw_parts((*self.0).aConstraint, (*self.0).nConstraint as usize) };
                IndexConstraintIter {
                    iter: constraints.iter(),
                }
            }
            /// Information about the ORDER BY clause.
            #[inline]
            #[must_use]
            pub fn order_bys(&self) -> OrderByIter<'_> {
                let order_bys =
                    unsafe { slice::from_raw_parts((*self.0).aOrderBy, (*self.0).nOrderBy as usize) };
                OrderByIter {
                    iter: order_bys.iter(),
                }
            }
            /// Number of terms in the ORDER BY clause
            #[inline]
            #[must_use]
            pub fn num_of_order_by(&self) -> usize {
                unsafe { (*self.0).nOrderBy as usize }
            }
            /// Information about what parameters to pass to [`VTabCursor::filter`].
            #[inline]
            pub fn constraint_usage(&mut self, constraint_idx: usize) -> IndexConstraintUsage<'_> {
                let constraint_usages = unsafe {
                    slice::from_raw_parts_mut((*self.0).aConstraintUsage, (*self.0).nConstraint as usize)
                };
                IndexConstraintUsage(&mut constraint_usages[constraint_idx])
            }
            /// Number used to identify the index
            #[inline]
            pub fn set_idx_num(&mut self, idx_num: c_int) {
                unsafe {
                    (*self.0).idxNum = idx_num;
                }
            }
            /// String used to identify the index
            pub fn set_idx_str(&mut self, idx_str: &str) {
                unsafe {
                    (*self.0).idxStr = alloc(idx_str);
                    (*self.0).needToFreeIdxStr = 1;
                }
            }
            /// True if output is already ordered
            #[inline]
            pub fn set_order_by_consumed(&mut self, order_by_consumed: bool) {
                unsafe {
                    (*self.0).orderByConsumed = order_by_consumed as c_int;
                }
            }
            /// Estimated cost of using this index
            #[inline]
            pub fn set_estimated_cost(&mut self, estimated_ost: f64) {
                unsafe {
                    (*self.0).estimatedCost = estimated_ost;
                }
            }
            /// Estimated number of rows returned.
            #[inline]
            pub fn set_estimated_rows(&mut self, estimated_rows: i64) {
                unsafe {
                    (*self.0).estimatedRows = estimated_rows;
                }
            }
            /// Mask of SQLITE_INDEX_SCAN_* flags.
            #[inline]
            pub fn set_idx_flags(&mut self, flags: IndexFlags) {
                unsafe { (*self.0).idxFlags = flags.bits() };
            }
            /// Mask of columns used by statement
            #[inline]
            pub fn col_used(&self) -> u64 {
                unsafe { (*self.0).colUsed }
            }
            /// Determine the collation for a virtual table constraint
            pub fn collation(&self, constraint_idx: usize) -> Result<&str> {
                use std::ffi::CStr;
                let idx = constraint_idx as c_int;
                let collation = unsafe { ffi::sqlite3_vtab_collation(self.0, idx) };
                if collation.is_null() {
                    return Err(Error::SqliteFailure(
                        ffi::Error::new(ffi::SQLITE_MISUSE),
                        Some(format!("{constraint_idx} is out of range")),
                    ));
                }
                Ok(unsafe { CStr::from_ptr(collation) }.to_str()?)
            }
        }
        /// Iterate on index constraint and its associated usage.
        pub struct IndexConstraintAndUsageIter<'a> {
            iter: std::iter::Zip<
                slice::Iter<'a, ffi::sqlite3_index_constraint>,
                slice::IterMut<'a, ffi::sqlite3_index_constraint_usage>,
            >,
        }

        impl<'a> Iterator for IndexConstraintAndUsageIter<'a> {
            type Item = (IndexConstraint<'a>, IndexConstraintUsage<'a>);

            #[inline]
            fn next(&mut self) -> Option<(IndexConstraint<'a>, IndexConstraintUsage<'a>)> {
                self.iter
                    .next()
                    .map(|raw| (IndexConstraint(raw.0), IndexConstraintUsage(raw.1)))
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        }
        /// `feature = "vtab"`
        pub struct IndexConstraintIter<'a> {
            iter: slice::Iter<'a, ffi::sqlite3_index_constraint>,
        }

        impl<'a> Iterator for IndexConstraintIter<'a> {
            type Item = IndexConstraint<'a>;

            #[inline]
            fn next(&mut self) -> Option<IndexConstraint<'a>> {
                self.iter.next().map(IndexConstraint)
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        }
        /// WHERE clause constraint.
        pub struct IndexConstraint<'a>(&'a ffi::sqlite3_index_constraint);

        impl IndexConstraint<'_> {
            /// Column constrained.  -1 for ROWID
            #[inline]
            #[must_use]
            pub fn column(&self) -> c_int {
                self.0.iColumn
            }
            /// Constraint operator
            #[inline]
            #[must_use]
            pub fn operator(&self) -> IndexConstraintOp {
                IndexConstraintOp::from(self.0.op)
            }
            /// True if this constraint is usable
            #[inline]
            #[must_use]
            pub fn is_usable(&self) -> bool {
                self.0.usable != 0
            }
        }
        /// Information about what parameters to pass to
        /// [`VTabCursor::filter`].
        pub struct IndexConstraintUsage<'a>(&'a mut ffi::sqlite3_index_constraint_usage);

        impl IndexConstraintUsage<'_> {
            /// if `argv_index` > 0, constraint is part of argv to
            /// [`VTabCursor::filter`]
            #[inline]
            pub fn set_argv_index(&mut self, argv_index: c_int) {
                self.0.argvIndex = argv_index;
            }
            /// if `omit`, do not code a test for this constraint
            #[inline]
            pub fn set_omit(&mut self, omit: bool) {
                self.0.omit = omit as std::os::raw::c_uchar;
            }
        }
        /// `feature = "vtab"`
        pub struct OrderByIter<'a> {
            iter: slice::Iter<'a, ffi::sqlite3_index_orderby>,
        }

        impl<'a> Iterator for OrderByIter<'a> {
            type Item = OrderBy<'a>;

            #[inline]
            fn next(&mut self) -> Option<OrderBy<'a>> {
                self.iter.next().map(OrderBy)
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        }
        /// A column of the ORDER BY clause.
        pub struct OrderBy<'a>(&'a ffi::sqlite3_index_orderby);

        impl OrderBy<'_> {
            /// Column number
            #[inline]
            #[must_use]
            pub fn column(&self) -> c_int {
                self.0.iColumn
            }
            /// True for DESC.  False for ASC.
            #[inline]
            #[must_use]
            pub fn is_order_by_desc(&self) -> bool {
                self.0.desc != 0
            }
        }
        /// Virtual table cursor trait.
        pub unsafe trait VTabCursor: Sized {
            /// Begin a search of a virtual table.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xfilter_method))
            fn filter(&mut self, idx_num: c_int, idx_str: Option<&str>, args: &Values<'_>) -> Result<()>;
            /// Advance cursor to the next row of a result set initiated by
            /// [`filter`](VTabCursor::filter). (See [SQLite doc](https://sqlite.org/vtab.html#the_xnext_method))
            fn next(&mut self) -> Result<()>;
            /// Must return `false` if the cursor currently points to a valid row of
            /// data, or `true` otherwise.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xeof_method))
            fn eof(&self) -> bool;
            /// Find the value for the `i`-th column of the current row.
            /// `i` is zero-based so the first column is numbered 0.
            /// May return its result back to SQLite using one of the specified `ctx`.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xcolumn_method))
            fn column(&self, ctx: &mut Context, i: c_int) -> Result<()>;
            /// Return the rowid of row that the cursor is currently pointing at.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xrowid_method))
            fn rowid(&self) -> Result<i64>;
        }
        /// Context is used by [`VTabCursor::column`] to specify the
        /// cell value.
        pub struct Context(*mut ffi::sqlite3_context);

        impl Context {
            /// Set current cell value
            #[inline]
            pub fn set_result<T: ToSql>(&mut self, value: &T) -> Result<()> {
                let t = value.to_sql()?;
                unsafe { set_result(self.0, &[], &t) };
                Ok(())
            }

            // TODO sqlite3_vtab_nochange (http://sqlite.org/c3ref/vtab_nochange.html) // 3.22.0 & xColumn
        }
        /// Wrapper to [`VTabCursor::filter`] arguments, the values
        /// requested by [`VTab::best_index`].
        pub struct Values<'a> {
            args: &'a [*mut ffi::sqlite3_value],
        }

        impl Values<'_>
        {
            /// Returns the number of values.
            #[inline]
            #[must_use]
            pub fn len(&self) -> usize {
                self.args.len()
            }
            /// Returns `true` if there is no value.
            #[inline]
            #[must_use]
            pub fn is_empty(&self) -> bool {
                self.args.is_empty()
            }
            /// Returns value at `idx`
            pub fn get<T: FromSql>(&self, idx: usize) -> Result<T> {
                let arg = self.args[idx];
                let value = unsafe { ValueRef::from_value(arg) };
                FromSql::column_result(value).map_err(|err| match err {
                    FromSqlError::InvalidType => Error::InvalidFilterParameterType(idx, value.data_type()),
                    FromSqlError::Other(err) => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), err)
                    }
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), Box::new(err))
                    }
                    FromSqlError::OutOfRange(i) => Error::IntegralValueOutOfRange(idx, i),
                })
            }

            // `sqlite3_value_type` returns `SQLITE_NULL` for pointer.
            // So it seems not possible to enhance `ValueRef::from_value`.
            fn get_array(&self, idx: usize) -> Option<array::Array> {
                use crate::types::Value;
                let arg = self.args[idx];
                let ptr = unsafe { ffi::sqlite3_value_pointer(arg, array::ARRAY_TYPE) };
                if ptr.is_null() {
                    None
                } else {
                    Some(unsafe {
                        let ptr = ptr as *const Vec<Value>;
                        array::Array::increment_strong_count(ptr); // don't consume it
                        array::Array::from_raw(ptr)
                    })
                }
            }
            /// Turns `Values` into an iterator.
            #[inline]
            #[must_use]
            pub fn iter(&self) -> ValueIter<'_> {
                ValueIter {
                    iter: self.args.iter(),
                }
            }
            // TODO sqlite3_vtab_in_first / sqlite3_vtab_in_next https://sqlite.org/c3ref/vtab_in_first.html & 3.38.0
        }

        impl<'a> IntoIterator for &'a Values<'a> {
            type IntoIter = ValueIter<'a>;
            type Item = ValueRef<'a>;

            #[inline]
            fn into_iter(self) -> ValueIter<'a> {
                self.iter()
            }
        }
        /// [`Values`] iterator.
        pub struct ValueIter<'a> {
            iter: slice::Iter<'a, *mut ffi::sqlite3_value>,
        }

        impl<'a> Iterator for ValueIter<'a> {
            type Item = ValueRef<'a>;

            #[inline]
            fn next(&mut self) -> Option<ValueRef<'a>> {
                self.iter
                    .next()
                    .map(|&raw| unsafe { ValueRef::from_value(raw) })
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        }

        impl Connection {
            /// Register a virtual table implementation.
            ///
            /// Step 3 of [Creating New Virtual Table
            /// Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).
            #[inline]
            pub fn create_module<'vtab, T: VTab<'vtab>>(
                &self,
                module_name: &str,
                module: &'static Module<'vtab, T>,
                aux: Option<T::Aux>,
            ) -> Result<()> {
                self.db.borrow_mut().create_module(module_name, module, aux)
            }
        }

        impl InnerConnection {
            fn create_module<'vtab, T: VTab<'vtab>>(
                &mut self,
                module_name: &str,
                module: &'static Module<'vtab, T>,
                aux: Option<T::Aux>,
            ) -> Result<()> {
                use crate::version;
                if version::version_number() < 3_009_000 && module.base.xCreate.is_none() {
                    return Err(Error::ModuleError(format!(
                        "Eponymous-only virtual table not supported by SQLite version {}",
                        version::version()
                    )));
                }
                let c_name = str_to_cstring(module_name)?;
                let r = match aux {
                    Some(aux) => {
                        let boxed_aux: *mut T::Aux = Box::into_raw(Box::new(aux));
                        unsafe {
                            ffi::sqlite3_create_module_v2(
                                self.db(),
                                c_name.as_ptr(),
                                &module.base,
                                boxed_aux.cast::<c_void>(),
                                Some(free_boxed_value::<T::Aux>),
                            )
                        }
                    }
                    None => unsafe {
                        ffi::sqlite3_create_module_v2(
                            self.db(),
                            c_name.as_ptr(),
                            &module.base,
                            ptr::null_mut(),
                            None,
                        )
                    },
                };
                self.decode_result(r)
            }
        }
        /// Escape double-quote (`"`) character occurrences by
        /// doubling them (`""`).
        #[must_use]
        pub fn escape_double_quote(identifier: &str) -> Cow<'_, str> {
            if identifier.contains('"') {
                // escape quote by doubling them
                Owned(identifier.replace('"', "\"\""))
            } else {
                Borrowed(identifier)
            }
        }
        /// Dequote string
        #[must_use]
        pub fn dequote(s: &str) -> &str {
            if s.len() < 2 {
                return s;
            }
            match s.bytes().next() {
                Some(b) if b == b'"' || b == b'\'' => match s.bytes().next_back() {
                    Some(e) if e == b => &s[1..s.len() - 1], // FIXME handle inner escaped quote(s)
                    _ => s,
                },
                _ => s,
            }
        }
        
        #[must_use]
        pub fn parse_boolean(s: &str) -> Option<bool> {
            if s.eq_ignore_ascii_case("yes")
                || s.eq_ignore_ascii_case("on")
                || s.eq_ignore_ascii_case("true")
                || s.eq("1")
            {
                Some(true)
            } else if s.eq_ignore_ascii_case("no")
                || s.eq_ignore_ascii_case("off")
                || s.eq_ignore_ascii_case("false")
                || s.eq("0")
            {
                Some(false)
            } else {
                None
            }
        }
        /// `<param_name>=['"]?<param_value>['"]?` => `(<param_name>, <param_value>)`
        pub fn parameter(c_slice: &[u8]) -> Result<(&str, &str)> {
            let arg = std::str::from_utf8(c_slice)?.trim();
            let mut split = arg.split('=');
            if let Some(key) = split.next() {
                if let Some(value) = split.next() {
                    let param = key.trim();
                    let value = dequote(value.trim());
                    return Ok((param, value));
                }
            }
            Err(Error::ModuleError(format!("illegal argument: '{arg}'")))
        }

        // FIXME copy/paste from function.rs
        unsafe extern "C" fn free_boxed_value<T>(p: *mut c_void) {
            drop(Box::from_raw(p.cast::<T>()));
        }

        unsafe extern "C" fn rust_create<'vtab, T>(
            db: *mut ffi::sqlite3,
            aux: *mut c_void,
            argc: c_int,
            argv: *const *const c_char,
            pp_vtab: *mut *mut ffi::sqlite3_vtab,
            err_msg: *mut *mut c_char,
        ) -> c_int
        where
            T: CreateVTab<'vtab>,
        {
            use std::ffi::CStr;

            let mut conn = VTabConnection(db);
            let aux = aux.cast::<T::Aux>();
            let args = slice::from_raw_parts(argv, argc as usize);
            let vec = args
                .iter()
                .map(|&cs| CStr::from_ptr(cs).to_bytes()) // FIXME .to_str() -> Result<&str, Utf8Error>
                .collect::<Vec<_>>();
            match T::create(&mut conn, aux.as_ref(), &vec[..]) {
                Ok((sql, vtab)) => match std::ffi::CString::new(sql) {
                    Ok(c_sql) => {
                        let rc = ffi::sqlite3_declare_vtab(db, c_sql.as_ptr());
                        if rc == ffi::SQLITE_OK {
                            let boxed_vtab: *mut T = Box::into_raw(Box::new(vtab));
                            *pp_vtab = boxed_vtab.cast::<ffi::sqlite3_vtab>();
                            ffi::SQLITE_OK
                        } else {
                            let err = error_from_sqlite_code(rc, None);
                            to_sqlite_error(&err, err_msg)
                        }
                    }
                    Err(err) => {
                        *err_msg = alloc(&err.to_string());
                        ffi::SQLITE_ERROR
                    }
                },
                Err(err) => to_sqlite_error(&err, err_msg),
            }
        }

        unsafe extern "C" fn rust_connect<'vtab, T>(
            db: *mut ffi::sqlite3,
            aux: *mut c_void,
            argc: c_int,
            argv: *const *const c_char,
            pp_vtab: *mut *mut ffi::sqlite3_vtab,
            err_msg: *mut *mut c_char,
        ) -> c_int
        where
            T: VTab<'vtab>,
        {
            use std::ffi::CStr;

            let mut conn = VTabConnection(db);
            let aux = aux.cast::<T::Aux>();
            let args = slice::from_raw_parts(argv, argc as usize);
            let vec = args
                .iter()
                .map(|&cs| CStr::from_ptr(cs).to_bytes()) // FIXME .to_str() -> Result<&str, Utf8Error>
                .collect::<Vec<_>>();
            match T::connect(&mut conn, aux.as_ref(), &vec[..]) {
                Ok((sql, vtab)) => match std::ffi::CString::new(sql) {
                    Ok(c_sql) => {
                        let rc = ffi::sqlite3_declare_vtab(db, c_sql.as_ptr());
                        if rc == ffi::SQLITE_OK {
                            let boxed_vtab: *mut T = Box::into_raw(Box::new(vtab));
                            *pp_vtab = boxed_vtab.cast::<ffi::sqlite3_vtab>();
                            ffi::SQLITE_OK
                        } else {
                            let err = error_from_sqlite_code(rc, None);
                            to_sqlite_error(&err, err_msg)
                        }
                    }
                    Err(err) => {
                        *err_msg = alloc(&err.to_string());
                        ffi::SQLITE_ERROR
                    }
                },
                Err(err) => to_sqlite_error(&err, err_msg),
            }
        }

        unsafe extern "C" fn rust_best_index<'vtab, T>(
            vtab: *mut ffi::sqlite3_vtab,
            info: *mut ffi::sqlite3_index_info,
        ) -> c_int
        where
            T: VTab<'vtab>,
        {
            let vt = vtab.cast::<T>();
            let mut idx_info = IndexInfo(info);
            match (*vt).best_index(&mut idx_info) {
                Ok(_) => ffi::SQLITE_OK,
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg(vtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg(vtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }

        unsafe extern "C" fn rust_disconnect<'vtab, T>(vtab: *mut ffi::sqlite3_vtab) -> c_int
        where
            T: VTab<'vtab>,
        {
            if vtab.is_null() {
                return ffi::SQLITE_OK;
            }
            let vtab = vtab.cast::<T>();
            drop(Box::from_raw(vtab));
            ffi::SQLITE_OK
        }

        unsafe extern "C" fn rust_destroy<'vtab, T>(vtab: *mut ffi::sqlite3_vtab) -> c_int
        where
            T: CreateVTab<'vtab>,
        {
            if vtab.is_null() {
                return ffi::SQLITE_OK;
            }
            let vt = vtab.cast::<T>();
            match (*vt).destroy() {
                Ok(_) => {
                    drop(Box::from_raw(vt));
                    ffi::SQLITE_OK
                }
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg(vtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg(vtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }

        unsafe extern "C" fn rust_open<'vtab, T>(
            vtab: *mut ffi::sqlite3_vtab,
            pp_cursor: *mut *mut ffi::sqlite3_vtab_cursor,
        ) -> c_int
        where
            T: VTab<'vtab> + 'vtab,
        {
            let vt = vtab.cast::<T>();
            match (*vt).open() {
                Ok(cursor) => {
                    let boxed_cursor: *mut T::Cursor = Box::into_raw(Box::new(cursor));
                    *pp_cursor = boxed_cursor.cast::<ffi::sqlite3_vtab_cursor>();
                    ffi::SQLITE_OK
                }
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg(vtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg(vtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }

        unsafe extern "C" fn rust_close<C>(cursor: *mut ffi::sqlite3_vtab_cursor) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor.cast::<C>();
            drop(Box::from_raw(cr));
            ffi::SQLITE_OK
        }

        unsafe extern "C" fn rust_filter<C>(
            cursor: *mut ffi::sqlite3_vtab_cursor,
            idx_num: c_int,
            idx_str: *const c_char,
            argc: c_int,
            argv: *mut *mut ffi::sqlite3_value,
        ) -> c_int
        where
            C: VTabCursor,
        {
            use std::ffi::CStr;
            use std::str;
            let idx_name = if idx_str.is_null() {
                None
            } else {
                let c_slice = CStr::from_ptr(idx_str).to_bytes();
                Some(str::from_utf8_unchecked(c_slice))
            };
            let args = slice::from_raw_parts_mut(argv, argc as usize);
            let values = Values { args };
            let cr = cursor as *mut C;
            cursor_error(cursor, (*cr).filter(idx_num, idx_name, &values))
        }

        unsafe extern "C" fn rust_next<C>(cursor: *mut ffi::sqlite3_vtab_cursor) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor as *mut C;
            cursor_error(cursor, (*cr).next())
        }

        unsafe extern "C" fn rust_eof<C>(cursor: *mut ffi::sqlite3_vtab_cursor) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor.cast::<C>();
            (*cr).eof() as c_int
        }

        unsafe extern "C" fn rust_column<C>(
            cursor: *mut ffi::sqlite3_vtab_cursor,
            ctx: *mut ffi::sqlite3_context,
            i: c_int,
        ) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor.cast::<C>();
            let mut ctxt = Context(ctx);
            result_error(ctx, (*cr).column(&mut ctxt, i))
        }

        unsafe extern "C" fn rust_rowid<C>(
            cursor: *mut ffi::sqlite3_vtab_cursor,
            p_rowid: *mut ffi::sqlite3_int64,
        ) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor.cast::<C>();
            match (*cr).rowid() {
                Ok(rowid) => {
                    *p_rowid = rowid;
                    ffi::SQLITE_OK
                }
                err => cursor_error(cursor, err),
            }
        }

        unsafe extern "C" fn rust_update<'vtab, T>(
            vtab: *mut ffi::sqlite3_vtab,
            argc: c_int,
            argv: *mut *mut ffi::sqlite3_value,
            p_rowid: *mut ffi::sqlite3_int64,
        ) -> c_int
        where
            T: UpdateVTab<'vtab> + 'vtab,
        {
            assert!(argc >= 1);
            let args = slice::from_raw_parts_mut(argv, argc as usize);
            let vt = vtab.cast::<T>();
            let r = if args.len() == 1 {
                (*vt).delete(ValueRef::from_value(args[0]))
            } else if ffi::sqlite3_value_type(args[0]) == ffi::SQLITE_NULL {
                // TODO Make the distinction between argv[1] == NULL and argv[1] != NULL ?
                let values = Values { args };
                match (*vt).insert(&values) {
                    Ok(rowid) => {
                        *p_rowid = rowid;
                        Ok(())
                    }
                    Err(e) => Err(e),
                }
            } else {
                let values = Values { args };
                (*vt).update(&values)
            };
            match r {
                Ok(_) => ffi::SQLITE_OK,
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg(vtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg(vtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }
        /// Virtual table cursors can set an error message by assigning a string to `zErrMsg`.
        #[cold] unsafe fn cursor_error<T>(cursor: *mut ffi::sqlite3_vtab_cursor, result: Result<T>) -> c_int {
            match result {
                Ok(_) => ffi::SQLITE_OK,
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg((*cursor).pVtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg((*cursor).pVtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }
        /// Virtual tables methods can set an error message by assigning a string to `zErrMsg`.
        #[cold] unsafe fn set_err_msg(vtab: *mut ffi::sqlite3_vtab, err_msg: &str) {
            if !(*vtab).zErrMsg.is_null() {
                ffi::sqlite3_free((*vtab).zErrMsg.cast::<c_void>());
            }
            (*vtab).zErrMsg = alloc(err_msg);
        }
        /// To raise an error, the `column` method should use this method to set the
        /// error message and return the error code.
        #[cold] unsafe fn result_error<T>(ctx: *mut ffi::sqlite3_context, result: Result<T>) -> c_int {
            match result {
                Ok(_) => ffi::SQLITE_OK,
                Err(Error::SqliteFailure(err, s)) => {
                    match err.extended_code {
                        ffi::SQLITE_TOOBIG => {
                            ffi::sqlite3_result_error_toobig(ctx);
                        }
                        ffi::SQLITE_NOMEM => {
                            ffi::sqlite3_result_error_nomem(ctx);
                        }
                        code => {
                            ffi::sqlite3_result_error_code(ctx, code);
                            if let Some(Ok(cstr)) = s.map(|s| str_to_cstring(&s)) {
                                ffi::sqlite3_result_error(ctx, cstr.as_ptr(), -1);
                            }
                        }
                    };
                    err.extended_code
                }
                Err(err) => {
                    ffi::sqlite3_result_error_code(ctx, ffi::SQLITE_ERROR);
                    if let Ok(cstr) = str_to_cstring(&err.to_string()) {
                        ffi::sqlite3_result_error(ctx, cstr.as_ptr(), -1);
                    }
                    ffi::SQLITE_ERROR
                }
            }
        }
        
        pub mod array
        {
            //! Array Virtual Table.
            use ::
            {
                *,
            };
            
            use std::marker::PhantomData;
            use std::os::raw::{c_char, c_int, c_void};
            use std::rc::Rc;

            use crate::ffi;
            use crate::types::{ToSql, ToSqlOutput, Value};
            use crate::vtab::{
                eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,
                Values,
            };
            use crate::{Connection, Result};
            //pub const ARRAY_TYPE: *const c_char = format!( r#"rarray"# ).as_ptr;

            pub unsafe extern "C" fn free_array(p: *mut c_void) 
            {
                drop(Rc::from_raw(p as *const Vec<Value>));
            }
            /// Array parameter / pointer
            pub type Array = Rc<Vec<Value>>;

            impl ToSql for Array {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::Array(self.clone()))
                }
            }
            /// Register the "rarray" module.
            pub fn load_module(conn: &Connection) -> Result<()>
            {
                let aux: Option<()> = None;
                conn.create_module("rarray", eponymous_only_module::<ArrayTab>(), aux)
            }

            // Column numbers
            // const CARRAY_COLUMN_VALUE : c_int = 0;
            const CARRAY_COLUMN_POINTER: c_int = 1;

            /// An instance of the Array virtual table
            #[repr(C)]
            struct ArrayTab {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab,
            }

            unsafe impl<'vtab> VTab<'vtab> for ArrayTab {
                type Aux = ();
                type Cursor = ArrayTabCursor<'vtab>;

                fn connect(
                    _: &mut VTabConnection,
                    _aux: Option<&()>,
                    _args: &[&[u8]],
                ) -> Result<(String, ArrayTab)> {
                    let vtab = ArrayTab {
                        base: ffi::sqlite3_vtab::default(),
                    };
                    Ok(("CREATE TABLE x(value,pointer hidden)".to_owned(), vtab))
                }

                fn best_index(&self, info: &mut IndexInfo) -> Result<()> {
                    // Index of the pointer= constraint
                    let mut ptr_idx = false;
                    for (constraint, mut constraint_usage) in info.constraints_and_usages() {
                        if !constraint.is_usable() {
                            continue;
                        }
                        if constraint.operator() != IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_EQ {
                            continue;
                        }
                        if let CARRAY_COLUMN_POINTER = constraint.column() {
                            ptr_idx = true;
                            constraint_usage.set_argv_index(1);
                            constraint_usage.set_omit(true);
                        }
                    }
                    if ptr_idx {
                        info.set_estimated_cost(1_f64);
                        info.set_estimated_rows(100);
                        info.set_idx_num(1);
                    } else {
                        info.set_estimated_cost(2_147_483_647_f64);
                        info.set_estimated_rows(2_147_483_647);
                        info.set_idx_num(0);
                    }
                    Ok(())
                }

                fn open(&mut self) -> Result<ArrayTabCursor<'_>> {
                    Ok(ArrayTabCursor::new())
                }
            }
            /// A cursor for the Array virtual table
            #[repr(C)]
            struct ArrayTabCursor<'vtab> {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab_cursor,
                /// The rowid
                row_id: i64,
                /// Pointer to the array of values ("pointer")
                ptr: Option<Array>,
                phantom: PhantomData<&'vtab ArrayTab>,
            }

            impl ArrayTabCursor<'_> {
                fn new<'vtab>() -> ArrayTabCursor<'vtab> {
                    ArrayTabCursor {
                        base: ffi::sqlite3_vtab_cursor::default(),
                        row_id: 0,
                        ptr: None,
                        phantom: PhantomData,
                    }
                }

                fn len(&self) -> i64 {
                    match self.ptr {
                        Some(ref a) => a.len() as i64,
                        _ => 0,
                    }
                }
            }
            unsafe impl VTabCursor for ArrayTabCursor<'_> {
                fn filter(&mut self, idx_num: c_int, _idx_str: Option<&str>, args: &Values<'_>) -> Result<()> {
                    if idx_num > 0 {
                        self.ptr = args.get_array(0);
                    } else {
                        self.ptr = None;
                    }
                    self.row_id = 1;
                    Ok(())
                }

                fn next(&mut self) -> Result<()> {
                    self.row_id += 1;
                    Ok(())
                }

                fn eof(&self) -> bool {
                    self.row_id > self.len()
                }

                fn column(&self, ctx: &mut Context, i: c_int) -> Result<()> {
                    match i {
                        CARRAY_COLUMN_POINTER => Ok(()),
                        _ => {
                            if let Some(ref array) = self.ptr {
                                let value = &array[(self.row_id - 1) as usize];
                                ctx.set_result(&value)
                            } else {
                                Ok(())
                            }
                        }
                    }
                }

                fn rowid(&self) -> Result<i64> {
                    Ok(self.row_id)
                }
            }
        }
        pub mod csvtab
        {
            //! CSV Virtual Table.
            use ::
            {
                *,
            };
            
            use std::fs::File;
            use std::marker::PhantomData;
            use std::os::raw::c_int;
            use std::path::Path;
            use std::str;

            use crate::ffi;
            use crate::types::Null;
            use crate::vtab::{
                escape_double_quote, parse_boolean, read_only_module, Context, CreateVTab, IndexInfo, VTab,
                VTabConfig, VTabConnection, VTabCursor, VTabKind, Values,
            };
            use crate::{Connection, Error, Result};

            /// Register the "csv" module.
            pub fn load_module(conn: &Connection) -> Result<()> {
                let aux: Option<()> = None;
                conn.create_module("csv", read_only_module::<CsvTab>(), aux)
            }
            /// An instance of the CSV virtual table
            #[repr(C)]
            struct CsvTab {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab,
                /// Name of the CSV file
                filename: String,
                has_headers: bool,
                delimiter: u8,
                quote: u8,
                /// Offset to start of data
                offset_first_row: csv::Position,
            }

            impl CsvTab {
                fn reader(&self) -> Result<csv::Reader<File>, csv::Error> {
                    csv::ReaderBuilder::new()
                        .has_headers(self.has_headers)
                        .delimiter(self.delimiter)
                        .quote(self.quote)
                        .from_path(&self.filename)
                }

                fn parse_byte(arg: &str) -> Option<u8> {
                    if arg.len() == 1 {
                        arg.bytes().next()
                    } else {
                        None
                    }
                }
            }

            unsafe impl<'vtab> VTab<'vtab> for CsvTab {
                type Aux = ();
                type Cursor = CsvTabCursor<'vtab>;

                fn connect(
                    db: &mut VTabConnection,
                    _aux: Option<&()>,
                    args: &[&[u8]],
                ) -> Result<(String, CsvTab)> {
                    if args.len() < 4 {
                        return Err(Error::ModuleError("no CSV file specified".to_owned()));
                    }

                    let mut vtab = CsvTab {
                        base: ffi::sqlite3_vtab::default(),
                        filename: "".to_owned(),
                        has_headers: false,
                        delimiter: b',',
                        quote: b'"',
                        offset_first_row: csv::Position::new(),
                    };
                    let mut schema = None;
                    let mut n_col = None;

                    let args = &args[3..];
                    for c_slice in args {
                        let (param, value) = super::parameter(c_slice)?;
                        match param {
                            "filename" => {
                                if !Path::new(value).exists() {
                                    return Err(Error::ModuleError(format!("file '{value}' does not exist")));
                                }
                                value.clone_into(&mut vtab.filename);
                            }
                            "schema" => {
                                schema = Some(value.to_owned());
                            }
                            "columns" => {
                                if let Ok(n) = value.parse::<u16>() {
                                    if n_col.is_some() {
                                        return Err(Error::ModuleError(
                                            "more than one 'columns' parameter".to_owned(),
                                        ));
                                    } else if n == 0 {
                                        return Err(Error::ModuleError(
                                            "must have at least one column".to_owned(),
                                        ));
                                    }
                                    n_col = Some(n);
                                } else {
                                    return Err(Error::ModuleError(format!(
                                        "unrecognized argument to 'columns': {value}"
                                    )));
                                }
                            }
                            "header" => {
                                if let Some(b) = parse_boolean(value) {
                                    vtab.has_headers = b;
                                } else {
                                    return Err(Error::ModuleError(format!(
                                        "unrecognized argument to 'header': {value}"
                                    )));
                                }
                            }
                            "delimiter" => {
                                if let Some(b) = CsvTab::parse_byte(value) {
                                    vtab.delimiter = b;
                                } else {
                                    return Err(Error::ModuleError(format!(
                                        "unrecognized argument to 'delimiter': {value}"
                                    )));
                                }
                            }
                            "quote" => {
                                if let Some(b) = CsvTab::parse_byte(value) {
                                    if b == b'0' {
                                        vtab.quote = 0;
                                    } else {
                                        vtab.quote = b;
                                    }
                                } else {
                                    return Err(Error::ModuleError(format!(
                                        "unrecognized argument to 'quote': {value}"
                                    )));
                                }
                            }
                            _ => {
                                return Err(Error::ModuleError(format!(
                                    "unrecognized parameter '{param}'"
                                )));
                            }
                        }
                    }

                    if vtab.filename.is_empty() {
                        return Err(Error::ModuleError("no CSV file specified".to_owned()));
                    }

                    let mut cols: Vec<String> = Vec::new();
                    if vtab.has_headers || (n_col.is_none() && schema.is_none()) {
                        let mut reader = vtab.reader()?;
                        if vtab.has_headers {
                            {
                                let headers = reader.headers()?;
                                // headers ignored if cols is not empty
                                if n_col.is_none() && schema.is_none() {
                                    cols = headers
                                        .into_iter()
                                        .map(|header| escape_double_quote(header).into_owned())
                                        .collect();
                                }
                            }
                            vtab.offset_first_row = reader.position().clone();
                        } else {
                            let mut record = csv::ByteRecord::new();
                            if reader.read_byte_record(&mut record)? {
                                for (i, _) in record.iter().enumerate() {
                                    cols.push(format!("c{i}"));
                                }
                            }
                        }
                    } else if let Some(n_col) = n_col {
                        for i in 0..n_col {
                            cols.push(format!("c{i}"));
                        }
                    }

                    if cols.is_empty() && schema.is_none() {
                        return Err(Error::ModuleError("no column specified".to_owned()));
                    }

                    if schema.is_none() {
                        let mut sql = String::from("CREATE TABLE x(");
                        for (i, col) in cols.iter().enumerate() {
                            sql.push('"');
                            sql.push_str(col);
                            sql.push_str("\" TEXT");
                            if i == cols.len() - 1 {
                                sql.push_str(");");
                            } else {
                                sql.push_str(", ");
                            }
                        }
                        schema = Some(sql);
                    }
                    db.config(VTabConfig::DirectOnly)?;
                    Ok((schema.unwrap(), vtab))
                }

                // Only a forward full table scan is supported.
                fn best_index(&self, info: &mut IndexInfo) -> Result<()> {
                    info.set_estimated_cost(1_000_000.);
                    Ok(())
                }

                fn open(&mut self) -> Result<CsvTabCursor<'_>> {
                    Ok(CsvTabCursor::new(self.reader()?))
                }
            }

            impl CreateVTab<'_> for CsvTab {
                const KIND: VTabKind = VTabKind::Default;
            }
            /// A cursor for the CSV virtual table
            #[repr(C)]
            struct CsvTabCursor<'vtab> {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab_cursor,
                /// The CSV reader object
                reader: csv::Reader<File>,
                /// Current cursor position used as rowid
                row_number: usize,
                /// Values of the current row
                cols: csv::StringRecord,
                eof: bool,
                phantom: PhantomData<&'vtab CsvTab>,
            }

            impl CsvTabCursor<'_> {
                fn new<'vtab>(reader: csv::Reader<File>) -> CsvTabCursor<'vtab> {
                    CsvTabCursor {
                        base: ffi::sqlite3_vtab_cursor::default(),
                        reader,
                        row_number: 0,
                        cols: csv::StringRecord::new(),
                        eof: false,
                        phantom: PhantomData,
                    }
                }
                /// Accessor to the associated virtual table.
                fn vtab(&self) -> &CsvTab {
                    unsafe { &*(self.base.pVtab as *const CsvTab) }
                }
            }

            unsafe impl VTabCursor for CsvTabCursor<'_> {
                // Only a full table scan is supported.  So `filter` simply rewinds to
                // the beginning.
                fn filter(
                    &mut self,
                    _idx_num: c_int,
                    _idx_str: Option<&str>,
                    _args: &Values<'_>,
                ) -> Result<()> {
                    {
                        let offset_first_row = self.vtab().offset_first_row.clone();
                        self.reader.seek(offset_first_row)?;
                    }
                    self.row_number = 0;
                    self.next()
                }

                fn next(&mut self) -> Result<()> {
                    {
                        self.eof = self.reader.is_done();
                        if self.eof {
                            return Ok(());
                        }

                        self.eof = !self.reader.read_record(&mut self.cols)?;
                    }

                    self.row_number += 1;
                    Ok(())
                }

                fn eof(&self) -> bool {
                    self.eof
                }

                fn column(&self, ctx: &mut Context, col: c_int) -> Result<()> {
                    if col < 0 || col as usize >= self.cols.len() {
                        return Err(Error::ModuleError(format!(
                            "column index out of bounds: {col}"
                        )));
                    }
                    if self.cols.is_empty() {
                        return ctx.set_result(&Null);
                    }
                    // TODO Affinity
                    ctx.set_result(&self.cols[col as usize].to_owned())
                }

                fn rowid(&self) -> Result<i64> {
                    Ok(self.row_number as i64)
                }
            }

            impl From<csv::Error> for Error {
                #[cold]
                fn from(err: csv::Error) -> Error {
                    Error::ModuleError(err.to_string())
                }
            }
        }
        pub mod series
        {
            //! Generate series virtual table.
            use ::
            {
                *,
            };
            
            use std::marker::PhantomData;
            use std::os::raw::c_int;

            use crate::ffi;
            use crate::types::Type;
            use crate::vtab::{
                eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConfig, VTabConnection,
                VTabCursor, Values,
            };
            use crate::{Connection, Error, Result};

            /// Register the "generate_series" module.
            pub fn load_module(conn: &Connection) -> Result<()> {
                let aux: Option<()> = None;
                conn.create_module("generate_series", eponymous_only_module::<SeriesTab>(), aux)
            }

            // Column numbers
            // const SERIES_COLUMN_VALUE : c_int = 0;
            const SERIES_COLUMN_START: c_int = 1;
            const SERIES_COLUMN_STOP: c_int = 2;
            const SERIES_COLUMN_STEP: c_int = 3;

            bitflags::bitflags! {
                #[derive(Clone, Copy)]
                #[repr(C)]
                struct QueryPlanFlags: ::std::os::raw::c_int {
                    // start = $value  -- constraint exists
                    const START = 1;
                    // stop = $value   -- constraint exists
                    const STOP  = 2;
                    // step = $value   -- constraint exists
                    const STEP  = 4;
                    // output in descending order
                    const DESC  = 8;
                    // output in ascending order
                    const ASC  = 16;
                    // Both start and stop
                    const BOTH  = QueryPlanFlags::START.bits() | QueryPlanFlags::STOP.bits();
                }
            }
            /// An instance of the Series virtual table
            #[repr(C)]
            struct SeriesTab {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab,
            }

            unsafe impl<'vtab> VTab<'vtab> for SeriesTab {
                type Aux = ();
                type Cursor = SeriesTabCursor<'vtab>;

                fn connect(
                    db: &mut VTabConnection,
                    _aux: Option<&()>,
                    _args: &[&[u8]],
                ) -> Result<(String, SeriesTab)> {
                    let vtab = SeriesTab {
                        base: ffi::sqlite3_vtab::default(),
                    };
                    db.config(VTabConfig::Innocuous)?;
                    Ok((
                        "CREATE TABLE x(value,start hidden,stop hidden,step hidden)".to_owned(),
                        vtab,
                    ))
                }

                fn best_index(&self, info: &mut IndexInfo) -> Result<()> {
                    // The query plan bitmask
                    let mut idx_num: QueryPlanFlags = QueryPlanFlags::empty();
                    // Mask of unusable constraints
                    let mut unusable_mask: QueryPlanFlags = QueryPlanFlags::empty();
                    // Constraints on start, stop, and step
                    let mut a_idx: [Option<usize>; 3] = [None, None, None];
                    for (i, constraint) in info.constraints().enumerate() {
                        if constraint.column() < SERIES_COLUMN_START {
                            continue;
                        }
                        let (i_col, i_mask) = match constraint.column() {
                            SERIES_COLUMN_START => (0, QueryPlanFlags::START),
                            SERIES_COLUMN_STOP => (1, QueryPlanFlags::STOP),
                            SERIES_COLUMN_STEP => (2, QueryPlanFlags::STEP),
                            _ => {
                                unreachable!()
                            }
                        };
                        if !constraint.is_usable() {
                            unusable_mask |= i_mask;
                        } else if constraint.operator() == IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_EQ {
                            idx_num |= i_mask;
                            a_idx[i_col] = Some(i);
                        }
                    }
                    // Number of arguments that SeriesTabCursor::filter expects
                    let mut n_arg = 0;
                    for j in a_idx.iter().flatten() {
                        n_arg += 1;
                        let mut constraint_usage = info.constraint_usage(*j);
                        constraint_usage.set_argv_index(n_arg);
                        constraint_usage.set_omit(true);
                        #[cfg(all(test, feature = "modern_sqlite"))]
                        debug_assert_eq!(Ok("BINARY"), info.collation(*j));
                    }
                    if !(unusable_mask & !idx_num).is_empty() {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_CONSTRAINT),
                            None,
                        ));
                    }
                    if idx_num.contains(QueryPlanFlags::BOTH) {
                        // Both start= and stop= boundaries are available.
                        #[allow(clippy::bool_to_int_with_if)]
                        info.set_estimated_cost(f64::from(
                            2 - if idx_num.contains(QueryPlanFlags::STEP) {
                                1
                            } else {
                                0
                            },
                        ));
                        info.set_estimated_rows(1000);
                        let order_by_consumed = {
                            let mut order_bys = info.order_bys();
                            if let Some(order_by) = order_bys.next() {
                                if order_by.column() == 0 {
                                    if order_by.is_order_by_desc() {
                                        idx_num |= QueryPlanFlags::DESC;
                                    } else {
                                        idx_num |= QueryPlanFlags::ASC;
                                    }
                                    true
                                } else {
                                    false
                                }
                            } else {
                                false
                            }
                        };
                        if order_by_consumed {
                            info.set_order_by_consumed(true);
                        }
                    } else {
                        // If either boundary is missing, we have to generate a huge span
                        // of numbers.  Make this case very expensive so that the query
                        // planner will work hard to avoid it.
                        info.set_estimated_rows(2_147_483_647);
                    }
                    info.set_idx_num(idx_num.bits());
                    Ok(())
                }

                fn open(&mut self) -> Result<SeriesTabCursor<'_>> {
                    Ok(SeriesTabCursor::new())
                }
            }
            /// A cursor for the Series virtual table
            #[repr(C)]
            struct SeriesTabCursor<'vtab> {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab_cursor,
                /// True to count down rather than up
                is_desc: bool,
                /// The rowid
                row_id: i64,
                /// Current value ("value")
                value: i64,
                /// Minimum value ("start")
                min_value: i64,
                /// Maximum value ("stop")
                max_value: i64,
                /// Increment ("step")
                step: i64,
                phantom: PhantomData<&'vtab SeriesTab>,
            }

            impl SeriesTabCursor<'_> {
                fn new<'vtab>() -> SeriesTabCursor<'vtab> {
                    SeriesTabCursor {
                        base: ffi::sqlite3_vtab_cursor::default(),
                        is_desc: false,
                        row_id: 0,
                        value: 0,
                        min_value: 0,
                        max_value: 0,
                        step: 0,
                        phantom: PhantomData,
                    }
                }
            }
            #[allow(clippy::comparison_chain)]
            unsafe impl VTabCursor for SeriesTabCursor<'_> {
                fn filter(&mut self, idx_num: c_int, _idx_str: Option<&str>, args: &Values<'_>) -> Result<()> {
                    let mut idx_num = QueryPlanFlags::from_bits_truncate(idx_num);
                    let mut i = 0;
                    if idx_num.contains(QueryPlanFlags::START) {
                        self.min_value = args.get::<Option<_>>(i)?.unwrap_or_default();
                        i += 1;
                    } else {
                        self.min_value = 0;
                    }
                    if idx_num.contains(QueryPlanFlags::STOP) {
                        self.max_value = args.get::<Option<_>>(i)?.unwrap_or_default();
                        i += 1;
                    } else {
                        self.max_value = 0xffff_ffff;
                    }
                    if idx_num.contains(QueryPlanFlags::STEP) {
                        self.step = args.get::<Option<_>>(i)?.unwrap_or_default();
                        if self.step == 0 {
                            self.step = 1;
                        } else if self.step < 0 {
                            self.step = -self.step;
                            if !idx_num.contains(QueryPlanFlags::ASC) {
                                idx_num |= QueryPlanFlags::DESC;
                            }
                        }
                    } else {
                        self.step = 1;
                    };
                    for arg in args.iter() {
                        if arg.data_type() == Type::Null {
                            // If any of the constraints have a NULL value, then return no rows.
                            self.min_value = 1;
                            self.max_value = 0;
                            break;
                        }
                    }
                    self.is_desc = idx_num.contains(QueryPlanFlags::DESC);
                    if self.is_desc {
                        self.value = self.max_value;
                        if self.step > 0 {
                            self.value -= (self.max_value - self.min_value) % self.step;
                        }
                    } else {
                        self.value = self.min_value;
                    }
                    self.row_id = 1;
                    Ok(())
                }

                fn next(&mut self) -> Result<()> {
                    if self.is_desc {
                        self.value -= self.step;
                    } else {
                        self.value += self.step;
                    }
                    self.row_id += 1;
                    Ok(())
                }

                fn eof(&self) -> bool {
                    if self.is_desc {
                        self.value < self.min_value
                    } else {
                        self.value > self.max_value
                    }
                }

                fn column(&self, ctx: &mut Context, i: c_int) -> Result<()> {
                    let x = match i {
                        SERIES_COLUMN_START => self.min_value,
                        SERIES_COLUMN_STOP => self.max_value,
                        SERIES_COLUMN_STEP => self.step,
                        _ => self.value,
                    };
                    ctx.set_result(&x)
                }

                fn rowid(&self) -> Result<i64> {
                    Ok(self.row_id)
                }
            }
        }
        
        mod vtablog
        {
            //! Port of C [vtablog](http://www.sqlite.org/cgi/src/finfo?name=ext/misc/vtablog.c)
            use ::
            {
                *,
            };
            
            use std::marker::PhantomData;
            use std::os::raw::c_int;
            use std::str::FromStr;
            use std::sync::atomic::{AtomicUsize, Ordering};

            use crate::vtab::{
                update_module, Context, CreateVTab, IndexInfo, UpdateVTab, VTab, VTabConnection, VTabCursor,
                VTabKind, Values,
            };
            use crate::{ffi, ValueRef};
            use crate::{Connection, Error, Result};

            /// Register the "vtablog" module.
            pub fn load_module(conn: &Connection) -> Result<()> {
                let aux: Option<()> = None;
                conn.create_module("vtablog", update_module::<VTabLog>(), aux)
            }
            /// An instance of the vtablog virtual table
            #[repr(C)]
            struct VTabLog {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab,
                /// Number of rows in the table
                n_row: i64,
                /// Instance number for this vtablog table
                i_inst: usize,
                /// Number of cursors created
                n_cursor: usize,
            }

            impl VTabLog {
                fn connect_create(
                    _: &mut VTabConnection,
                    _: Option<&()>,
                    args: &[&[u8]],
                    is_create: bool,
                ) -> Result<(String, VTabLog)> {
                    static N_INST: AtomicUsize = AtomicUsize::new(1);
                    let i_inst = N_INST.fetch_add(1, Ordering::SeqCst);
                    println!(
                        "VTabLog::{}(tab={}, args={:?}):",
                        if is_create { "create" } else { "connect" },
                        i_inst,
                        args,
                    );
                    let mut schema = None;
                    let mut n_row = None;

                    let args = &args[3..];
                    for c_slice in args {
                        let (param, value) = super::parameter(c_slice)?;
                        match param {
                            "schema" => {
                                if schema.is_some() {
                                    return Err(Error::ModuleError(format!(
                                        "more than one '{param}' parameter"
                                    )));
                                }
                                schema = Some(value.to_owned())
                            }
                            "rows" => {
                                if n_row.is_some() {
                                    return Err(Error::ModuleError(format!(
                                        "more than one '{param}' parameter"
                                    )));
                                }
                                if let Ok(n) = i64::from_str(value) {
                                    n_row = Some(n)
                                }
                            }
                            _ => {
                                return Err(Error::ModuleError(format!(
                                    "unrecognized parameter '{param}'"
                                )));
                            }
                        }
                    }
                    if schema.is_none() {
                        return Err(Error::ModuleError("no schema defined".to_owned()));
                    }
                    let vtab = VTabLog {
                        base: ffi::sqlite3_vtab::default(),
                        n_row: n_row.unwrap_or(10),
                        i_inst,
                        n_cursor: 0,
                    };
                    Ok((schema.unwrap(), vtab))
                }
            }

            impl Drop for VTabLog {
                fn drop(&mut self) {
                    println!("VTabLog::drop({})", self.i_inst);
                }
            }

            unsafe impl<'vtab> VTab<'vtab> for VTabLog {
                type Aux = ();
                type Cursor = VTabLogCursor<'vtab>;

                fn connect(
                    db: &mut VTabConnection,
                    aux: Option<&Self::Aux>,
                    args: &[&[u8]],
                ) -> Result<(String, Self)> {
                    VTabLog::connect_create(db, aux, args, false)
                }

                fn best_index(&self, info: &mut IndexInfo) -> Result<()> {
                    println!("VTabLog::best_index({})", self.i_inst);
                    info.set_estimated_cost(500.);
                    info.set_estimated_rows(500);
                    Ok(())
                }

                fn open(&'vtab mut self) -> Result<Self::Cursor> {
                    self.n_cursor += 1;
                    println!(
                        "VTabLog::open(tab={}, cursor={})",
                        self.i_inst, self.n_cursor
                    );
                    Ok(VTabLogCursor {
                        base: ffi::sqlite3_vtab_cursor::default(),
                        i_cursor: self.n_cursor,
                        row_id: 0,
                        phantom: PhantomData,
                    })
                }
            }

            impl<'vtab> CreateVTab<'vtab> for VTabLog {
                const KIND: VTabKind = VTabKind::Default;

                fn create(
                    db: &mut VTabConnection,
                    aux: Option<&Self::Aux>,
                    args: &[&[u8]],
                ) -> Result<(String, Self)> {
                    VTabLog::connect_create(db, aux, args, true)
                }

                fn destroy(&self) -> Result<()> {
                    println!("VTabLog::destroy({})", self.i_inst);
                    Ok(())
                }
            }

            impl<'vtab> UpdateVTab<'vtab> for VTabLog {
                fn delete(&mut self, arg: ValueRef<'_>) -> Result<()> {
                    println!("VTabLog::delete({}, {arg:?})", self.i_inst);
                    Ok(())
                }

                fn insert(&mut self, args: &Values<'_>) -> Result<i64> {
                    println!(
                        "VTabLog::insert({}, {:?})",
                        self.i_inst,
                        args.iter().collect::<Vec<ValueRef<'_>>>()
                    );
                    Ok(self.n_row)
                }

                fn update(&mut self, args: &Values<'_>) -> Result<()> {
                    println!(
                        "VTabLog::update({}, {:?})",
                        self.i_inst,
                        args.iter().collect::<Vec<ValueRef<'_>>>()
                    );
                    Ok(())
                }
            }
            /// A cursor for the Series virtual table
            #[repr(C)]
            struct VTabLogCursor<'vtab> {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab_cursor,
                /// Cursor number
                i_cursor: usize,
                /// The rowid
                row_id: i64,
                phantom: PhantomData<&'vtab VTabLog>,
            }

            impl VTabLogCursor<'_> {
                fn vtab(&self) -> &VTabLog {
                    unsafe { &*(self.base.pVtab as *const VTabLog) }
                }
            }

            impl Drop for VTabLogCursor<'_> {
                fn drop(&mut self) {
                    println!(
                        "VTabLogCursor::drop(tab={}, cursor={})",
                        self.vtab().i_inst,
                        self.i_cursor
                    );
                }
            }

            unsafe impl VTabCursor for VTabLogCursor<'_> {
                fn filter(&mut self, _: c_int, _: Option<&str>, _: &Values<'_>) -> Result<()> {
                    println!(
                        "VTabLogCursor::filter(tab={}, cursor={})",
                        self.vtab().i_inst,
                        self.i_cursor
                    );
                    self.row_id = 0;
                    Ok(())
                }

                fn next(&mut self) -> Result<()> {
                    println!(
                        "VTabLogCursor::next(tab={}, cursor={}): rowid {} -> {}",
                        self.vtab().i_inst,
                        self.i_cursor,
                        self.row_id,
                        self.row_id + 1
                    );
                    self.row_id += 1;
                    Ok(())
                }

                fn eof(&self) -> bool {
                    let eof = self.row_id >= self.vtab().n_row;
                    println!(
                        "VTabLogCursor::eof(tab={}, cursor={}): {}",
                        self.vtab().i_inst,
                        self.i_cursor,
                        eof,
                    );
                    eof
                }

                fn column(&self, ctx: &mut Context, i: c_int) -> Result<()> {
                    let value = if i < 26 {
                        format!(
                            "{}{}",
                            "abcdefghijklmnopqrstuvwyz".chars().nth(i as usize).unwrap(),
                            self.row_id
                        )
                    } else {
                        format!("{i}{}", self.row_id)
                    };
                    println!(
                        "VTabLogCursor::column(tab={}, cursor={}, i={}): {}",
                        self.vtab().i_inst,
                        self.i_cursor,
                        i,
                        value,
                    );
                    ctx.set_result(&value)
                }

                fn rowid(&self) -> Result<i64> {
                    println!(
                        "VTabLogCursor::rowid(tab={}, cursor={}): {}",
                        self.vtab().i_inst,
                        self.i_cursor,
                        self.row_id,
                    );
                    Ok(self.row_id)
                }
            }
        }
    }

    pub mod util
    {
        use ::
        {
            *,
        };
        // Internal utilities
        pub mod param_cache
        {
            use ::
            {
                *,
            };
            use super::SmallCString;
            use std::cell::RefCell;
            use std::collections::BTreeMap;

            /// Maps parameter names to parameter indices.
            #[derive(Default, Clone, Debug)]
            // BTreeMap seems to do better here unless we want to pull in a custom hash
            // function.
            pub struct ParamIndexCache(RefCell<BTreeMap<SmallCString, usize>>);

            impl ParamIndexCache {
                pub fn get_or_insert_with<F>(&self, s: &str, func: F) -> Option<usize> where
                    F: FnOnce(&std::ffi::CStr) -> Option<usize>,
                {
                    let mut cache = self.0.borrow_mut();
                    // Avoid entry API, needs allocation to test membership.
                    if let Some(v) = cache.get(s) {
                        return Some(*v);
                    }
                    // If there's an internal nul in the name it couldn't have been a
                    // parameter, so early return here is ok.
                    let name = SmallCString::new(s).ok()?;
                    let val = func(&name)?;
                    cache.insert(name, val);
                    Some(val)
                }
            }
        } pub use param_cache::ParamIndexCache;

        pub mod small_cstr
        {
            use ::
            {
                *,
            };
            use smallvec::{smallvec, SmallVec};
            use std::ffi::{CStr, CString, NulError};

            /// Similar to `std::ffi::CString`, but avoids heap allocating if the string is
            /// small enough. Also guarantees it's input is UTF-8 -- used for cases where we
            /// need to pass a NUL-terminated string to SQLite, and we have a `&str`.
            #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
            pub struct SmallCString(SmallVec<[u8; 16]>);

            impl SmallCString {
                #[inline]
                pub fn new(s: &str) -> Result<Self, NulError> {
                    if s.as_bytes().contains(&0_u8) {
                        return Err(Self::fabricate_nul_error(s));
                    }
                    let mut buf = SmallVec::with_capacity(s.len() + 1);
                    buf.extend_from_slice(s.as_bytes());
                    buf.push(0);
                    let res = Self(buf);
                    res.debug_checks();
                    Ok(res)
                }

                #[inline]
                pub fn as_str(&self) -> &str {
                    self.debug_checks();
                    // Constructor takes a &str so this is safe.
                    unsafe { std::str::from_utf8_unchecked(self.as_bytes_without_nul()) }
                }
                /// Get the bytes not including the NUL terminator. E.g. the bytes which
                /// make up our `str`:
                /// - `SmallCString::new("foo").as_bytes_without_nul() == b"foo"`
                /// - `SmallCString::new("foo").as_bytes_with_nul() == b"foo\0"`
                #[inline]
                pub fn as_bytes_without_nul(&self) -> &[u8] {
                    self.debug_checks();
                    &self.0[..self.len()]
                }
                /// Get the bytes behind this str *including* the NUL terminator. This
                /// should never return an empty slice.
                #[inline]
                pub fn as_bytes_with_nul(&self) -> &[u8] {
                    self.debug_checks();
                    &self.0
                }

                #[inline]
                #[cfg(debug_assertions)]
                fn debug_checks(&self) {
                    debug_assert_ne!(self.0.len(), 0);
                    debug_assert_eq!(self.0[self.0.len() - 1], 0);
                    let strbytes = &self.0[..(self.0.len() - 1)];
                    debug_assert!(!strbytes.contains(&0));
                    debug_assert!(std::str::from_utf8(strbytes).is_ok());
                }

                #[inline]
                #[cfg(not(debug_assertions))]
                fn debug_checks(&self) {}

                #[inline]
                pub fn len(&self) -> usize {
                    debug_assert_ne!(self.0.len(), 0);
                    self.0.len() - 1
                }

                #[inline]
                #[allow(unused)] // clippy wants this function.
                pub fn is_empty(&self) -> bool {
                    self.len() == 0
                }

                #[inline]
                pub fn as_cstr(&self) -> &CStr {
                    let bytes = self.as_bytes_with_nul();
                    debug_assert!(CStr::from_bytes_with_nul(bytes).is_ok());
                    unsafe { CStr::from_bytes_with_nul_unchecked(bytes) }
                }

                #[cold]
                fn fabricate_nul_error(b: &str) -> NulError {
                    CString::new(b).unwrap_err()
                }
            }

            impl Default for SmallCString {
                #[inline]
                fn default() -> Self {
                    Self(smallvec![0])
                }
            }

            impl std::fmt::Debug for SmallCString {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.debug_tuple("SmallCString").field(&self.as_str()).finish()
                }
            }

            impl std::ops::Deref for SmallCString {
                type Target = CStr;

                #[inline]
                fn deref(&self) -> &CStr {
                    self.as_cstr()
                }
            }

            impl PartialEq<SmallCString> for str {
                #[inline]
                fn eq(&self, s: &SmallCString) -> bool {
                    s.as_bytes_without_nul() == self.as_bytes()
                }
            }

            impl PartialEq<str> for SmallCString {
                #[inline]
                fn eq(&self, s: &str) -> bool {
                    self.as_bytes_without_nul() == s.as_bytes()
                }
            }

            impl std::borrow::Borrow<str> for SmallCString {
                #[inline]
                fn borrow(&self) -> &str {
                    self.as_str()
                }
            }
        } pub use small_cstr::SmallCString;
        
        // Doesn't use any modern features or vtab stuff, but is only used by them.
        mod sqlite_string
        {
            use ::
            {
                *,
            };
            
            use crate::ffi;
            use std::marker::PhantomData;
            use std::os::raw::{c_char, c_int};
            use std::ptr::NonNull;

            // Space to hold this string must be obtained
            // from an SQLite memory allocation function
            pub fn alloc(s: &str) -> *mut c_char {
                SqliteMallocString::from_str(s).into_raw()
            }
            /// A string we own that's allocated on the SQLite heap. Automatically calls
            /// `sqlite3_free` when dropped, unless `into_raw` (or `into_inner`) is called
            /// on it. If constructed from a rust string, `sqlite3_malloc` is used.
            ///
            /// It has identical representation to a nonnull `*mut c_char`, so you can use
            /// it transparently as one. It's nonnull, so Option<SqliteMallocString> can be
            /// used for nullable ones (it's still just one pointer).
            ///
            /// Most strings shouldn't use this! Only places where the string needs to be
            /// freed with `sqlite3_free`. This includes `sqlite3_extended_sql` results,
            /// some error message pointers... Note that misuse is extremely dangerous!
            ///
            /// Note that this is *not* a lossless interface. Incoming strings with internal
            /// NULs are modified, and outgoing strings which are non-UTF8 are modified.
            /// This seems unavoidable -- it tries very hard to not panic.
            #[repr(transparent)]
            pub struct SqliteMallocString {
                ptr: NonNull<c_char>,
                _boo: PhantomData<Box<[c_char]>>,
            }
            // This is owned data for a primitive type, and thus it's safe to implement
            // these. That said, nothing needs them, and they make things easier to misuse.

            // unsafe impl Send for SqliteMallocString {}
            // unsafe impl Sync for SqliteMallocString {}

            impl SqliteMallocString {
                /// SAFETY: Caller must be certain that `m` a nul-terminated c string
                /// allocated by `sqlite3_malloc`, and that SQLite expects us to free it!
                #[inline]
                pub unsafe fn from_raw_nonnull(ptr: NonNull<c_char>) -> Self {
                    Self {
                        ptr,
                        _boo: PhantomData,
                    }
                }
                /// SAFETY: Caller must be certain that `m` a nul-terminated c string
                /// allocated by `sqlite3_malloc`, and that SQLite expects us to free it!
                #[inline]
                pub unsafe fn from_raw(ptr: *mut c_char) -> Option<Self> {
                    NonNull::new(ptr).map(|p| Self::from_raw_nonnull(p))
                }
                /// Get the pointer behind `self`. After this is called, we no longer manage
                /// it.
                #[inline]
                pub fn into_inner(self) -> NonNull<c_char> {
                    let p = self.ptr;
                    std::mem::forget(self);
                    p
                }
                /// Get the pointer behind `self`. After this is called, we no longer manage
                /// it.
                #[inline]
                pub fn into_raw(self) -> *mut c_char {
                    self.into_inner().as_ptr()
                }
                /// Borrow the pointer behind `self`. We still manage it when this function
                /// returns. If you want to relinquish ownership, use `into_raw`.
                #[inline]
                pub fn as_ptr(&self) -> *const c_char {
                    self.ptr.as_ptr()
                }

                #[inline]
                pub fn as_cstr(&self) -> &std::ffi::CStr {
                    unsafe { std::ffi::CStr::from_ptr(self.as_ptr()) }
                }

                #[inline]
                pub fn to_string_lossy(&self) -> std::borrow::Cow<'_, str> {
                    self.as_cstr().to_string_lossy()
                }
                /// Convert `s` into a SQLite string.
                ///
                /// This should almost never be done except for cases like error messages or
                /// other strings that SQLite frees.
                ///
                /// If `s` contains internal NULs, we'll replace them with
                /// `NUL_REPLACE_CHAR`.
                ///
                /// Except for `debug_assert`s which may trigger during testing, this
                /// function never panics. If we hit integer overflow or the allocation
                /// fails, we call `handle_alloc_error` which aborts the program after
                /// calling a global hook.
                ///
                /// This means it's safe to use in extern "C" functions even outside
                /// `catch_unwind`.
                pub fn from_str(s: &str) -> Self {
                    let s = if s.as_bytes().contains(&0) {
                        std::borrow::Cow::Owned(make_nonnull(s))
                    } else {
                        std::borrow::Cow::Borrowed(s)
                    };
                    debug_assert!(!s.as_bytes().contains(&0));
                    let bytes: &[u8] = s.as_ref().as_bytes();
                    let src_ptr: *const c_char = bytes.as_ptr().cast();
                    let src_len = bytes.len();
                    let maybe_len_plus_1 = s.len().checked_add(1).and_then(|v| c_int::try_from(v).ok());
                    unsafe {
                        let res_ptr = maybe_len_plus_1
                            .and_then(|len_to_alloc| {
                                // `>` because we added 1.
                                debug_assert!(len_to_alloc > 0);
                                debug_assert_eq!((len_to_alloc - 1) as usize, src_len);
                                NonNull::new(ffi::sqlite3_malloc(len_to_alloc).cast::<c_char>())
                            })
                            .unwrap_or_else(|| {
                                use std::alloc::{handle_alloc_error, Layout};
                                // Report via handle_alloc_error so that it can be handled with any
                                // other allocation errors and properly diagnosed.
                                //
                                // This is safe:
                                // - `align` is never 0
                                // - `align` is always a power of 2.
                                // - `size` needs no realignment because it's guaranteed to be aligned
                                //   (everything is aligned to 1)
                                // - `size` is also never zero, although this function doesn't actually require
                                //   it now.
                                let len = s.len().saturating_add(1).min(isize::MAX as usize);
                                let layout = Layout::from_size_align_unchecked(len, 1);
                                // Note: This call does not return.
                                handle_alloc_error(layout);
                            });
                        let buf: *mut c_char = res_ptr.as_ptr().cast::<c_char>();
                        src_ptr.copy_to_nonoverlapping(buf, src_len);
                        buf.add(src_len).write(0);
                        debug_assert_eq!(std::ffi::CStr::from_ptr(res_ptr.as_ptr()).to_bytes(), bytes);
                        Self::from_raw_nonnull(res_ptr)
                    }
                }
            }

            const NUL_REPLACE: &str = "␀";

            #[cold]
            fn make_nonnull(v: &str) -> String {
                v.replace('\0', NUL_REPLACE)
            }

            impl Drop for SqliteMallocString {
                #[inline]
                fn drop(&mut self) {
                    unsafe { ffi::sqlite3_free(self.ptr.as_ptr().cast()) };
                }
            }

            impl std::fmt::Debug for SqliteMallocString {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    self.to_string_lossy().fmt(f)
                }
            }

            impl std::fmt::Display for SqliteMallocString {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    self.to_string_lossy().fmt(f)
                }
            }
        } pub use sqlite_string::{alloc, SqliteMallocString};
    }
    pub use self::util::SmallCString;
    /// Number of cached prepared statements we'll hold on to.
    pub const STATEMENT_CACHE_DEFAULT_CAPACITY: usize = 16;
    /// A macro making it more convenient to longer lists of parameters as a `&[&dyn ToSql]`.
    #[macro_export] macro_rules! params 
    {
        () => {
            &[] as &[&dyn $crate::ToSql]
        };
        ($($param:expr),+ $(,)?) => {
            &[$(&$param as &dyn $crate::ToSql),+] as &[&dyn $crate::ToSql]
        };
    }
    /// A macro making it more convenient to pass lists of named parameters as a `&[(&str, &dyn ToSql)]`.
    #[macro_export] macro_rules! named_params 
    {
        () => {
            &[] as &[(&str, &dyn $crate::ToSql)]
        };
        // Note: It's a lot more work to support this as part of the same macro as
        // `params!`, unfortunately.
        ($($param_name:literal: $param_val:expr),+ $(,)?) => {
            &[$(($param_name, &$param_val as &dyn $crate::ToSql)),+] as &[(&str, &dyn $crate::ToSql)]
        };
    }
    /// Captured identifiers in SQL.
    #[macro_export] macro_rules! prepare_and_bind 
    {
        ($conn:expr, $sql:literal) => {{
            let mut stmt = $conn.prepare($sql)?;
            $crate::__bind!(stmt $sql);
            stmt
        }};
    }
    /// Captured identifiers in SQL
    #[macro_export] macro_rules! prepare_cached_and_bind 
    {
        ($conn:expr, $sql:literal) => {{
            let mut stmt = $conn.prepare_cached($sql)?;
            $crate::__bind!(stmt $sql);
            stmt
        }};
    }
    /// A typedef of the result returned by many methods.
    pub type Result<T, E = Error> = result::Result<T, E>;
    /// See the [method documentation](#tymethod.optional).
    pub trait OptionalExtension<T> 
    {
        /// Converts a `Result<T>` into a `Result<Option<T>>`.
        ///
        /// By default, Rusqlite treats 0 rows being returned from a query that is
        /// expected to return 1 row as an error. This method will
        /// handle that error, and give you back an `Option<T>` instead.
        fn optional(self) -> Result<Option<T>>;
    }

    impl<T> OptionalExtension<T> for Result<T> 
    {
        fn optional(self) -> Result<Option<T>> {
            match self {
                Ok(value) => Ok(Some(value)),
                Err(Error::QueryReturnedNoRows) => Ok(None),
                Err(e) => Err(e),
            }
        }
    }

    unsafe fn errmsg_to_string(errmsg: *const c_char) -> String 
    {
        CStr::from_ptr(errmsg).to_string_lossy().into_owned()
    }

    fn str_to_cstring(s: &str) -> Result<SmallCString> 
    {
        Ok(SmallCString::new(s)?)
    }
    /// Returns `Ok((string ptr, len as c_int, SQLITE_STATIC | SQLITE_TRANSIENT))` normally.
    fn str_for_sqlite(s: &[u8]) -> Result<(*const c_char, c_int, ffi::sqlite3_destructor_type)> 
    {
        let len = len_as_c_int(s.len())?;
        let (ptr, dtor_info) = if len != 0 {
            (s.as_ptr().cast::<c_char>(), ffi::SQLITE_TRANSIENT())
        } else {
            // Return a pointer guaranteed to live forever
            ("".as_ptr().cast::<c_char>(), ffi::SQLITE_STATIC())
        };
        Ok((ptr, len, dtor_info))
    }
    
    fn len_as_c_int(len: usize) -> Result<c_int> 
    {
        if len >= (c_int::MAX as usize) {
            Err(Error::SqliteFailure(
                ffi::Error::new(ffi::SQLITE_TOOBIG),
                None,
            ))
        } else {
            Ok(len as c_int)
        }
    }

    #[cfg(unix)]
    fn path_to_cstring(p: &Path) -> Result<CString> 
    {
        use std::os::unix::ffi::OsStrExt;
        Ok(CString::new(p.as_os_str().as_bytes())?)
    }

    #[cfg(not(unix))]
    fn path_to_cstring(p: &Path) -> Result<CString> 
    {
        let s = p.to_str().ok_or_else(|| Error::InvalidPath(p.to_owned()))?;
        Ok(CString::new(s)?)
    }
    /// Name for a database within a SQLite connection.
    #[derive(Copy, Clone, Debug)]
    pub enum DatabaseName<'a> 
    {
        /// The main database.
        Main,

        /// The temporary database (e.g., any "CREATE TEMPORARY TABLE" tables).
        Temp,

        /// A database that has been attached via "ATTACH DATABASE ...".
        Attached(&'a str),
    }
    /// Shorthand for [`DatabaseName::Main`].
    pub const MAIN_DB: DatabaseName<'static> = DatabaseName::Main;
    /// Shorthand for [`DatabaseName::Temp`].
    pub const TEMP_DB: DatabaseName<'static> = DatabaseName::Temp;
    
    impl DatabaseName<'_> 
    {
        #[inline]
        fn as_cstring(&self) -> Result<SmallCString> {
            use self::DatabaseName::{Attached, Main, Temp};
            match *self {
                Main => str_to_cstring("main"), // TODO C-string literals
                Temp => str_to_cstring("temp"),
                Attached(s) => str_to_cstring(s),
            }
        }
    }
    /// A connection to a SQLite database.
    pub struct Connection
    {
        db: RefCell<InnerConnection>,
        cache: StatementCache,
        transaction_behavior: TransactionBehavior,
    }

    unsafe impl Send for Connection {}

    impl Drop for Connection 
    {
        #[inline]
        fn drop(&mut self) {
            self.flush_prepared_statement_cache();
        }
    }

    impl Connection 
    {
        /// Open a new connection to a SQLite database.
        #[inline]
        pub fn open<P: AsRef<Path>>(path: P) -> Result<Connection> {
            let flags = OpenFlags::default();
            Connection::open_with_flags(path, flags)
        }
        /// Open a new connection to an in-memory SQLite database.
        #[inline]
        pub fn open_in_memory() -> Result<Connection> {
            let flags = OpenFlags::default();
            Connection::open_in_memory_with_flags(flags)
        }
        /// Open a new connection to a SQLite database.
        #[inline]
        pub fn open_with_flags<P: AsRef<Path>>(path: P, flags: OpenFlags) -> Result<Connection> {
            let c_path = path_to_cstring(path.as_ref())?;
            InnerConnection::open_with_flags(&c_path, flags, None).map(|db| Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
        /// Open a new connection to a SQLite database using the specific flags and vfs name.
        #[inline]
        pub fn open_with_flags_and_vfs<P: AsRef<Path>>(
            path: P,
            flags: OpenFlags,
            vfs: &str,
        ) -> Result<Connection> {
            let c_path = path_to_cstring(path.as_ref())?;
            let c_vfs = str_to_cstring(vfs)?;
            InnerConnection::open_with_flags(&c_path, flags, Some(&c_vfs)).map(|db| Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
        /// Open a new connection to an in-memory SQLite database.
        #[inline]
        pub fn open_in_memory_with_flags(flags: OpenFlags) -> Result<Connection> {
            Connection::open_with_flags(":memory:", flags)
        }
        /// Open a new connection to an in-memory SQLite database using the specific flags and vfs name.
        #[inline]
        pub fn open_in_memory_with_flags_and_vfs(flags: OpenFlags, vfs: &str) -> Result<Connection> {
            Connection::open_with_flags_and_vfs(":memory:", flags, vfs)
        }
        /// Convenience method to run multiple SQL statements (that cannot take any parameters).
        pub fn execute_batch(&self, sql: &str) -> Result<()> {
            let mut sql = sql;
            while !sql.is_empty() {
                let stmt = self.prepare(sql)?;
                if !stmt.stmt.is_null() && stmt.step()? && cfg!(feature = "extra_check") {
                    // Some PRAGMA may return rows
                    return Err(Error::ExecuteReturnedResults);
                }
                let tail = stmt.stmt.tail();
                if tail == 0 || tail >= sql.len() {
                    break;
                }
                sql = &sql[tail..];
            }
            Ok(())
        }
        /// Convenience method to prepare and execute a single SQL statement.
        #[inline]
        pub fn execute<P: Params>(&self, sql: &str, params: P) -> Result<usize> {
            self.prepare(sql)
                .and_then(|mut stmt| stmt.check_no_tail().and_then(|()| stmt.execute(params)))
        }
        /// Returns the path to the database file, if one exists and is known.
        #[inline]
        pub fn path(&self) -> Option<&str> {
            unsafe {
                let db = self.handle();
                let db_name = DatabaseName::Main.as_cstring().unwrap();
                let db_filename = ffi::sqlite3_db_filename(db, db_name.as_ptr());
                if db_filename.is_null() {
                    None
                } else {
                    CStr::from_ptr(db_filename).to_str().ok()
                }
            }
        }
        /// Attempts to free as much heap memory as possible from the database connection.
        #[inline]
        #[cfg(feature = "release_memory")]
        pub fn release_memory(&self) -> Result<()> {
            self.db.borrow_mut().release_memory()
        }
        /// Get the SQLite rowid of the most recent successful INSERT.
        #[inline]
        pub fn last_insert_rowid(&self) -> i64 {
            self.db.borrow_mut().last_insert_rowid()
        }
        /// Convenience method to execute a query that is expected to return a single row.
        #[inline]
        pub fn query_row<T, P, F>(&self, sql: &str, params: P, f: F) -> Result<T>
        where
            P: Params,
            F: FnOnce(&Row<'_>) -> Result<T>,
        {
            let mut stmt = self.prepare(sql)?;
            stmt.check_no_tail()?;
            stmt.query_row(params, f)
        }

        // https://sqlite.org/tclsqlite.html#onecolumn
        #[cfg(test)]
        pub fn one_column<T: types::FromSql>(&self, sql: &str) -> Result<T> {
            self.query_row(sql, [], |r| r.get(0))
        }
        /// Convenience method to execute a query that is expected to return a
        /// single row, and execute a mapping via `f` on that returned row with
        /// the possibility of failure.
        #[inline]
        pub fn query_row_and_then<T, E, P, F>(&self, sql: &str, params: P, f: F) -> Result<T, E>
        where
            P: Params,
            F: FnOnce(&Row<'_>) -> Result<T, E>,
            E: From<Error>,
        {
            let mut stmt = self.prepare(sql)?;
            stmt.check_no_tail()?;
            let mut rows = stmt.query(params)?;

            rows.get_expected_row().map_err(E::from).and_then(f)
        }
        /// Prepare a SQL statement for execution.
        #[inline]
        pub fn prepare(&self, sql: &str) -> Result<Statement<'_>> {
            self.prepare_with_flags(sql, PrepFlags::default())
        }
        /// Prepare a SQL statement for execution.
        #[inline]
        pub fn prepare_with_flags(&self, sql: &str, flags: PrepFlags) -> Result<Statement<'_>> {
            self.db.borrow_mut().prepare(self, sql, flags)
        }
        /// Close the SQLite connection.
        #[inline]
        pub fn close(self) -> Result<(), (Connection, Error)> {
            self.flush_prepared_statement_cache();
            let r = self.db.borrow_mut().close();
            r.map_err(move |err| (self, err))
        }
        /// Enable loading of SQLite extensions from both SQL queries and Rust.
        #[cfg(feature = "load_extension")]
        #[cfg_attr(docsrs, doc(cfg(feature = "load_extension")))]
        #[inline]
        pub unsafe fn load_extension_enable(&self) -> Result<()> {
            self.db.borrow_mut().enable_load_extension(1)
        }
        /// Disable loading of SQLite extensions.
        #[cfg(feature = "load_extension")]
        #[cfg_attr(docsrs, doc(cfg(feature = "load_extension")))]
        #[inline]
        pub fn load_extension_disable(&self) -> Result<()> {
            // It's always safe to turn off extension loading.
            unsafe { self.db.borrow_mut().enable_load_extension(0) }
        }
        /// Load the SQLite extension at `dylib_path`. `dylib_path` is passed
        /// through to `sqlite3_load_extension`, which may attempt OS-specific
        /// modifications if the file cannot be loaded directly.
        #[cfg(feature = "load_extension")]
        #[cfg_attr(docsrs, doc(cfg(feature = "load_extension")))]
        #[inline]
        pub unsafe fn load_extension<P: AsRef<Path>>(
            &self,
            dylib_path: P,
            entry_point: Option<&str>,
        ) -> Result<()> {
            self.db
                .borrow_mut()
                .load_extension(dylib_path.as_ref(), entry_point)
        }
        /// Get access to the underlying SQLite database connection handle.
        ///
        /// # Warning
        ///
        /// You should not need to use this function. If you do need to, please
        /// [open an issue on the rusqlite repository](https://github.com/rusqlite/rusqlite/issues) and describe
        /// your use case.
        ///
        /// # Safety
        ///
        /// This function is unsafe because it gives you raw access
        /// to the SQLite connection, and what you do with it could impact the
        /// safety of this `Connection`.
        #[inline]
        pub unsafe fn handle(&self) -> *mut ffi::sqlite3 {
            self.db.borrow().db()
        }
        /// Create a `Connection` from a raw handle.
        ///
        /// The underlying SQLite database connection handle will not be closed when
        /// the returned connection is dropped/closed.
        ///
        /// # Safety
        ///
        /// This function is unsafe because improper use may impact the Connection.
        #[inline]
        pub unsafe fn from_handle(db: *mut ffi::sqlite3) -> Result<Connection> {
            let db = InnerConnection::new(db, false);
            Ok(Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
        /// Helper to register an SQLite extension written in Rust.
        /// For [persistent](https://sqlite.org/loadext.html#persistent_loadable_extensions) extension,
        /// `init` should return `Ok(true)`.
        /// # Safety
        /// * Results are undefined if `init` does not just register features.
        #[cfg(feature = "loadable_extension")]
        #[cfg_attr(docsrs, doc(cfg(feature = "loadable_extension")))]
        pub unsafe fn extension_init2(
            db: *mut ffi::sqlite3,
            pz_err_msg: *mut *mut c_char,
            p_api: *mut ffi::sqlite3_api_routines,
            init: fn(Connection) -> Result<bool>,
        ) -> c_int {
            if p_api.is_null() {
                return ffi::SQLITE_ERROR;
            }
            match ffi::rusqlite_extension_init2(p_api)
                .map_err(Error::from)
                .and(Connection::from_handle(db))
                .and_then(init)
            {
                Err(err) => to_sqlite_error(&err, pz_err_msg),
                Ok(true) => ffi::SQLITE_OK_LOAD_PERMANENTLY,
                _ => ffi::SQLITE_OK,
            }
        }
        /// Create a `Connection` from a raw owned handle.
        ///
        /// The returned connection will attempt to close the inner connection
        /// when dropped/closed. This function should only be called on connections
        /// owned by the caller.
        ///
        /// # Safety
        ///
        /// This function is unsafe because improper use may impact the Connection.
        /// In particular, it should only be called on connections created
        /// and owned by the caller, e.g. as a result of calling
        /// `ffi::sqlite3_open`().
        #[inline]
        pub unsafe fn from_handle_owned(db: *mut ffi::sqlite3) -> Result<Connection> {
            let db = InnerConnection::new(db, true);
            Ok(Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
        /// Get access to a handle that can be used to interrupt long-running
        /// queries from another thread.
        #[inline]
        pub fn get_interrupt_handle(&self) -> InterruptHandle {
            self.db.borrow().get_interrupt_handle()
        }

        #[inline]
        fn decode_result(&self, code: c_int) -> Result<()> {
            self.db.borrow().decode_result(code)
        }
        /// Return the number of rows modified, inserted or deleted by the most
        /// recently completed INSERT, UPDATE or DELETE statement on the database
        /// connection.
        ///
        /// See <https://www.sqlite.org/c3ref/changes.html>
        #[inline]
        pub fn changes(&self) -> u64 {
            self.db.borrow().changes()
        }
        /// Return the total number of rows modified, inserted or deleted by all
        /// completed INSERT, UPDATE or DELETE statements since the database
        /// connection was opened, including those executed as part of trigger programs.
        ///
        /// See <https://www.sqlite.org/c3ref/total_changes.html>
        #[inline]
        pub fn total_changes(&self) -> u64 {
            self.db.borrow().total_changes()
        }
        /// Test for auto-commit mode.
        /// Autocommit mode is on by default.
        #[inline]
        pub fn is_autocommit(&self) -> bool {
            self.db.borrow().is_autocommit()
        }
        /// Determine if all associated prepared statements have been reset.
        #[inline]
        pub fn is_busy(&self) -> bool {
            self.db.borrow().is_busy()
        }
        /// Flush caches to disk mid-transaction
        pub fn cache_flush(&self) -> Result<()> {
            self.db.borrow_mut().cache_flush()
        }
        /// Determine if a database is read-only
        pub fn is_readonly(&self, db_name: DatabaseName<'_>) -> Result<bool> {
            self.db.borrow().db_readonly(db_name)
        }
        /// Return the schema name for a database connection
        ///
        /// ## Failure
        ///
        /// Return an `Error::InvalidDatabaseIndex` if `index` is out of range.
        #[cfg(feature = "modern_sqlite")] // 3.39.0
        #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
        pub fn db_name(&self, index: usize) -> Result<String> {
            unsafe {
                let db = self.handle();
                let name = ffi::sqlite3_db_name(db, index as c_int);
                if name.is_null() {
                    Err(Error::InvalidDatabaseIndex(index))
                } else {
                    Ok(CStr::from_ptr(name).to_str()?.to_owned())
                }
            }
        }
        /// Determine whether an interrupt is currently in effect
        #[cfg(feature = "modern_sqlite")] // 3.41.0
        #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
        pub fn is_interrupted(&self) -> bool {
            self.db.borrow().is_interrupted()
        }
    }

    impl fmt::Debug for Connection 
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Connection")
                .field("path", &self.path())
                .finish()
        }
    }
    /// Batch iterator
    #[derive(Debug)]
    pub struct Batch<'conn, 'sql> 
    {
        conn: &'conn Connection,
        sql: &'sql str,
        tail: usize,
    }

    impl<'conn, 'sql> Batch<'conn, 'sql> 
    {
        /// Constructor
        pub fn new(conn: &'conn Connection, sql: &'sql str) -> Batch<'conn, 'sql> {
            Batch { conn, sql, tail: 0 }
        }
        /// Iterates on each batch statements.
        ///
        /// Returns `Ok(None)` when batch is completed.
         // fallible iterator
        pub fn next(&mut self) -> Result<Option<Statement<'conn>>> {
            while self.tail < self.sql.len() {
                let sql = &self.sql[self.tail..];
                let next = self.conn.prepare(sql)?;
                let tail = next.stmt.tail();
                if tail == 0 {
                    self.tail = self.sql.len();
                } else {
                    self.tail += tail;
                }
                if next.stmt.is_null() {
                    continue;
                }
                return Ok(Some(next));
            }
            Ok(None)
        }
    }

    impl<'conn> Iterator for Batch<'conn, '_> 
    {
        type Item = Result<Statement<'conn>>;

        fn next(&mut self) -> Option<Result<Statement<'conn>>> {
            self.next().transpose()
        }
    }

    bitflags::bitflags! 
    {
        /// Flags for opening SQLite database connections. See
        /// [sqlite3_open_v2](https://www.sqlite.org/c3ref/open.html) for details.
        ///
        /// The default open flags are `SQLITE_OPEN_READ_WRITE | SQLITE_OPEN_CREATE
        /// | SQLITE_OPEN_URI | SQLITE_OPEN_NO_MUTEX`. See [`Connection::open`] for
        /// some discussion about these flags.
        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
        #[repr(C)]
        pub struct OpenFlags: ::std::os::raw::c_int {
            /// The database is opened in read-only mode.
            /// If the database does not already exist, an error is returned.
            const SQLITE_OPEN_READ_ONLY = ffi::SQLITE_OPEN_READONLY;
            /// The database is opened for reading and writing if possible,
            /// or reading only if the file is write-protected by the operating system.
            /// In either case the database must already exist, otherwise an error is returned.
            const SQLITE_OPEN_READ_WRITE = ffi::SQLITE_OPEN_READWRITE;
            /// The database is created if it does not already exist
            const SQLITE_OPEN_CREATE = ffi::SQLITE_OPEN_CREATE;
            /// The filename can be interpreted as a URI if this flag is set.
            const SQLITE_OPEN_URI = ffi::SQLITE_OPEN_URI;
            /// The database will be opened as an in-memory database.
            const SQLITE_OPEN_MEMORY = ffi::SQLITE_OPEN_MEMORY;
            /// The new database connection will not use a per-connection mutex (the
            /// connection will use the "multi-thread" threading mode, in SQLite
            /// parlance).
            ///
            /// This is used by default, as proper `Send`/`Sync` usage (in
            /// particular, the fact that [`Connection`] does not implement `Sync`)
            /// ensures thread-safety without the need to perform locking around all
            /// calls.
            const SQLITE_OPEN_NO_MUTEX = ffi::SQLITE_OPEN_NOMUTEX;
            /// The new database connection will use a per-connection mutex -- the
            /// "serialized" threading mode, in SQLite parlance.
            ///
            /// # Caveats
            ///
            /// This flag should probably never be used with `rusqlite`, as we
            /// ensure thread-safety statically (we implement [`Send`] and not
            /// [`Sync`]). That said
            ///
            /// Critically, even if this flag is used, the [`Connection`] is not
            /// safe to use across multiple threads simultaneously. To access a
            /// database from multiple threads, you should either create multiple
            /// connections, one for each thread (if you have very many threads,
            /// wrapping the `rusqlite::Connection` in a mutex is also reasonable).
            ///
            /// This is both because of the additional per-connection state stored
            /// by `rusqlite` (for example, the prepared statement cache), and
            /// because not all of SQLites functions are fully thread safe, even in
            /// serialized/`SQLITE_OPEN_FULLMUTEX` mode.
            ///
            /// All that said, it's fairly harmless to enable this flag with
            /// `rusqlite`, it will just slow things down while providing no
            /// benefit.
            const SQLITE_OPEN_FULL_MUTEX = ffi::SQLITE_OPEN_FULLMUTEX;
            /// The database is opened with shared cache enabled.
            ///
            /// This is frequently useful for in-memory connections, but note that
            /// broadly speaking it's discouraged by SQLite itself, which states
            /// "Any use of shared cache is discouraged" in the official
            /// [documentation](https://www.sqlite.org/c3ref/enable_shared_cache.html).
            const SQLITE_OPEN_SHARED_CACHE = 0x0002_0000;
            /// The database is opened shared cache disabled.
            const SQLITE_OPEN_PRIVATE_CACHE = 0x0004_0000;
            /// The database filename is not allowed to be a symbolic link. (3.31.0)
            const SQLITE_OPEN_NOFOLLOW = 0x0100_0000;
            /// Extended result codes. (3.37.0)
            const SQLITE_OPEN_EXRESCODE = 0x0200_0000;
        }
    }

    impl Default for OpenFlags 
    {
        #[inline]
        fn default() -> OpenFlags {
            // Note: update the `Connection::open` and top-level `OpenFlags` docs if
            // you change these.
            OpenFlags::SQLITE_OPEN_READ_WRITE
                | OpenFlags::SQLITE_OPEN_CREATE
                | OpenFlags::SQLITE_OPEN_NO_MUTEX
                | OpenFlags::SQLITE_OPEN_URI
        }
    }

    bitflags::bitflags! 
    {
        /// Prepare flags. See
        /// [sqlite3_prepare_v3](https://sqlite.org/c3ref/c_prepare_normalize.html) for details.
        #[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]
        #[repr(C)]
        pub struct PrepFlags: ::std::os::raw::c_uint {
            /// A hint to the query planner that the prepared statement will be retained for a long time and probably reused many times.
            const SQLITE_PREPARE_PERSISTENT = 0x01;
            /// Causes the SQL compiler to return an error (error code SQLITE_ERROR) if the statement uses any virtual tables.
            const SQLITE_PREPARE_NO_VTAB = 0x04;
        }
    }
    /// Allows interrupting a long-running computation.
    pub struct InterruptHandle 
    {
        db_lock: Arc<Mutex<*mut ffi::sqlite3>>,
    }

    unsafe impl Send for InterruptHandle {}
    unsafe impl Sync for InterruptHandle {}

    impl InterruptHandle 
    {
        /// Interrupt the query currently executing on another thread. This will
        /// cause that query to fail with a `SQLITE3_INTERRUPT` error.
        pub fn interrupt(&self) {
            let db_handle = self.db_lock.lock().unwrap();
            if !db_handle.is_null() {
                unsafe { ffi::sqlite3_interrupt(*db_handle) }
            }
        }
    }
}

pub mod scripting
{
    use ::
    {
        *,
    };
    use std::fs::File;
    use std::io::{Read, Write, ErrorKind};
    use std::path::Path;

    use pest::iterators::Pair;
    use regex::{Regex, RegexBuilder};

    use crate::execute;
    use crate::libs;
    use crate::parsers;
    use crate::shell;
    use crate::types;
    use crate::types::CommandResult;

    pub fn run_script(sh: &mut shell::Shell, args: &Vec<String>) -> i32 {
        let src_file = &args[1];
        let full_src_file: String;
        if src_file.contains('/') {
            full_src_file = src_file.clone();
        } else {
            let full_path = libs::path::find_file_in_path(src_file, false);
            if full_path.is_empty() {
                // not in PATH and not in current work directory
                if !Path::new(src_file).exists() {
                    println_stderr!(":: {}: no such file", src_file);
                    return 1;
                }
                full_src_file = format!("./{}", src_file);
            } else {
                full_src_file = full_path.clone();
            }
        }

        if !Path::new(&full_src_file).exists() {
            println_stderr!(":: {}: no such file", src_file);
            return 1;
        }
        if Path::new(&full_src_file).is_dir() {
            println_stderr!(":: {}: is a directory", src_file);
            return 1;
        }

        let mut file;
        match File::open(&full_src_file) {
            Ok(x) => file = x,
            Err(e) => {
                println_stderr!(":: {}: failed to open file - {:?}", &full_src_file, e.kind());
                return 1;
            }
        }
        let mut text = String::new();
        match file.read_to_string(&mut text) {
            Ok(_) => {}
            Err(e) => {
                match e.kind() {
                    ErrorKind::InvalidData => {
                        println_stderr!(":: {}: not a valid script file", &full_src_file);
                    }
                    _ => {
                        println_stderr!(":: {}: error: {:?}", &full_src_file, e);
                    }
                }
                return 1;
            }
        }

        if text.contains("\\\n") {
            let re = RegexBuilder::new(r#"([ \t]*\\\n[ \t]+)|([ \t]+\\\n[ \t]*)"#)
                .multi_line(true).build().unwrap();
            text = re.replace_all(&text, " ").to_string();

            let re = RegexBuilder::new(r#"\\\n"#).multi_line(true).build().unwrap();
            text = re.replace_all(&text, "").to_string();
        }

        let re_func_head = Regex::new(r"^function ([a-zA-Z_-][a-zA-Z0-9_-]*) *(?:\(\))? *\{$").unwrap();
        let re_func_tail = Regex::new(r"^\}$").unwrap();
        let mut text_new = String::new();
        let mut enter_func = false;
        let mut func_name = String::new();
        let mut func_body = String::new();
        for line in text.clone().lines() {
            if re_func_head.is_match(line.trim()) {
                enter_func = true;
                let cap = re_func_head.captures(line.trim()).unwrap();
                func_name = cap[1].to_string();
                func_body = String::new();
                continue;
            }
            if re_func_tail.is_match(line.trim()) {
                sh.set_func(&func_name, &func_body);
                enter_func = false;
                continue;
            }
            if enter_func {
                func_body.push_str(line);
                func_body.push('\n');
            } else {
                text_new.push_str(line);
                text_new.push('\n');
            }
        }

        let mut status = 0;
        let cr_list = run_lines(sh, &text_new, args, false);
        if let Some(last) = cr_list.last() {
            status = last.status;
        }

        // FIXME: We probably need to fix the issue in the `set` builtin,
        // which currently set `exit_on_error` at the shell session level,
        // we should instead set in a script-level.
        // Here is a work-around ugly fix.
        sh.exit_on_error = false;

        status
    }

    pub fn run_lines(sh: &mut shell::Shell,
                    lines: &str,
                    args: &Vec<String>,
                    capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        match parsers::locust::parse_lines(lines) {
            Ok(pairs_exp) => {
                for pair in pairs_exp {
                    let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, false, capture);
                    cr_list.append(&mut _cr_list);
                }
            }
            Err(e) => {
                println_stderr!("syntax error: {:?}", e);
                return cr_list;
            }
        }
        cr_list
    }

    fn expand_args(line: &str, args: &[String]) -> String {
        let linfo = parsers::parser_line::parse_line(line);
        let mut tokens = linfo.tokens;
        expand_args_in_tokens(&mut tokens, args);
        parsers::parser_line::tokens_to_line(&tokens)
    }

    fn expand_line_to_toknes(line: &str,
                            args: &[String],
                            sh: &mut shell::Shell) -> types::Tokens {
        let linfo = parsers::parser_line::parse_line(line);
        let mut tokens = linfo.tokens;
        expand_args_in_tokens(&mut tokens, args);
        shell::do_expansion(sh, &mut tokens);
        tokens
    }

    fn is_args_in_token(token: &str) -> bool {
        libs::re::re_contains(token, r"\$\{?[0-9@]+\}?")
    }

    fn expand_args_for_single_token(token: &str, args: &[String]) -> String {
        let re = Regex::new(r"^(.*?)\$\{?([0-9]+|@)\}?(.*)$").unwrap();
        if !re.is_match(token) {
            return token.to_string();
        }

        let mut result = String::new();
        let mut _token = token.to_string();
        let mut _head = String::new();
        let mut _output = String::new();
        let mut _tail = String::new();
        loop {
            if !re.is_match(&_token) {
                if !_token.is_empty() {
                    result.push_str(&_token);
                }
                break;
            }
            for cap in re.captures_iter(&_token) {
                _head = cap[1].to_string();
                _tail = cap[3].to_string();
                let _key = cap[2].to_string();
                if _key == "@" {
                    result.push_str(format!("{}{}", _head, args[1..].join(" ")).as_str());
                } else if let Ok(arg_idx) = _key.parse::<usize>() {
                    if arg_idx < args.len() {
                        result.push_str(format!("{}{}", _head, args[arg_idx]).as_str());
                    } else {
                        result.push_str(&_head);
                    }
                } else {
                    result.push_str(&_head);
                }
            }

            if _tail.is_empty() {
                break;
            }
            _token = _tail.clone();
        }
        result
    }

    fn expand_args_in_tokens(tokens: &mut types::Tokens, args: &[String]) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for (sep, token) in tokens.iter() {
            if sep == "`" || sep == "'" || !is_args_in_token(token) {
                idx += 1;
                continue;
            }

            let _token = expand_args_for_single_token(token, args);
            buff.push((idx, _token));
            idx += 1;
        }

        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn run_exp_test_br(sh: &mut shell::Shell,
                    pair_br: Pair<parsers::locust::Rule>,
                    args: &Vec<String>,
                    in_loop: bool,
                    capture: bool) -> (Vec<CommandResult>, bool, bool, bool) {
        let mut cr_list = Vec::new();
        let pairs = pair_br.into_inner();
        let mut test_pass = false;
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::IF_HEAD ||
                    rule == parsers::locust::Rule::IF_ELSEIF_HEAD ||
                    rule == parsers::locust::Rule::WHILE_HEAD {
                let pairs_test: Vec<Pair<parsers::locust::Rule>> =
                    pair.into_inner().collect();
                let pair_test = &pairs_test[0];
                let line = pair_test.as_str().trim();
                let line_new = expand_args(line, &args[1..]);
                let mut _cr_list = execute::run_command_line(sh, &line_new, true, capture);
                if let Some(last) = _cr_list.last() {
                    if last.status == 0 {
                        test_pass = true;
                    }
                }
                continue;
            }

            if rule == parsers::locust::Rule::KW_ELSE {
                test_pass = true;
                continue;
            }

            if rule == parsers::locust::Rule::EXP_BODY {
                if !test_pass {
                    return (cr_list, false, false, false);
                }
                let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, in_loop, capture);
                cr_list.append(&mut _cr_list);
                // branch executed successfully
                return (cr_list, true, _cont, _brk);
            }

            unreachable!();
        }
        (cr_list, test_pass, false, false)
    }

    fn run_exp_if(sh: &mut shell::Shell,
                pair_if: Pair<parsers::locust::Rule>,
                args: &Vec<String>,
                in_loop: bool,
                capture: bool) -> (Vec<CommandResult>, bool, bool) {
        let mut cr_list = Vec::new();
        let pairs = pair_if.into_inner();
        let mut met_continue = false;
        let mut met_break = false;
        for pair in pairs {
            let (mut _cr_list, passed, _cont, _brk) = run_exp_test_br(sh, pair, args, in_loop, capture);
            met_continue = _cont;
            met_break = _brk;
            cr_list.append(&mut _cr_list);
            // break at first successful branch
            if passed {
                break;
            }
        }
        (cr_list, met_continue, met_break)
    }

    fn get_for_result_from_init(sh: &mut shell::Shell,
                                pair_init: Pair<parsers::locust::Rule>,
                                args: &[String]) -> Vec<String> {
        let mut result: Vec<String> = Vec::new();
        let pairs = pair_init.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::TEST {
                let line = pair.as_str().trim();
                let tokens = expand_line_to_toknes(line, &args[1..], sh);
                for (sep, token) in tokens {
                    if sep.is_empty() {
                        for x in token.split_whitespace() {
                            result.push(x.to_string());
                        }
                    } else {
                        result.push(token.clone());
                    }
                }
            }
        }
        result
    }

    fn get_for_result_list(sh: &mut shell::Shell,
                        pair_head: Pair<parsers::locust::Rule>,
                        args: &[String]) -> Vec<String> {
        let pairs = pair_head.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_INIT {
                return get_for_result_from_init(sh, pair, args);
            }
        }
        Vec::new()
    }

    fn get_for_var_name(pair_head: Pair<parsers::locust::Rule>) -> String {
        let pairs = pair_head.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_INIT {
                let pairs_init = pair.into_inner();
                for pair_init in pairs_init {
                    let rule_init = pair_init.as_rule();
                    if rule_init == parsers::locust::Rule::FOR_VAR {
                        let line = pair_init.as_str().trim();
                        return line.to_string();
                    }
                }
            }
        }
        String::new()
    }

    fn run_exp_for(sh: &mut shell::Shell,
                pair_for: Pair<parsers::locust::Rule>,
                args: &Vec<String>,
                capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        let pairs = pair_for.into_inner();
        let mut result_list: Vec<String> = Vec::new();
        let mut var_name: String = String::new();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_HEAD {
                var_name = get_for_var_name(pair.clone());
                result_list = get_for_result_list(sh, pair.clone(), args);
                continue;
            }
            if rule == parsers::locust::Rule::EXP_BODY {
                for value in &result_list {
                    sh.set_env(&var_name, value);
                    let (mut _cr_list, _cont, _brk) = run_exp(
                        sh, pair.clone(), args, true, capture);
                    cr_list.append(&mut _cr_list);
                    if _brk {
                        break;
                    }
                }
            }
        }
        cr_list
    }

    fn run_exp_while(sh: &mut shell::Shell,
                    pair_while: Pair<parsers::locust::Rule>,
                    args: &Vec<String>,
                    capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        loop {
            let (mut _cr_list, passed, _cont, _brk) = run_exp_test_br(sh, pair_while.clone(), args, true, capture);
            cr_list.append(&mut _cr_list);
            if !passed || _brk {
                break;
            }
        }
        cr_list
    }

    fn run_exp(sh: &mut shell::Shell,
            pair_in: Pair<parsers::locust::Rule>,
            args: &Vec<String>,
            in_loop: bool,
            capture: bool) -> (Vec<CommandResult>, bool, bool) {
        let mut cr_list = Vec::new();
        let pairs = pair_in.into_inner();
        for pair in pairs {
            let line = pair.as_str().trim();
            if line.is_empty() {
                continue;
            }

            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::CMD {
                if line == "continue" {
                    if in_loop {
                        return (cr_list, true, false);
                    } else {
                        println_stderr!(":: continue: only meaningful in loops");
                        continue;
                    }
                }
                if line == "break" {
                    if in_loop {
                        return (cr_list, false, true);
                    } else {
                        println_stderr!(":: break: only meaningful in loops");
                        continue;
                    }
                }

                let line_new = expand_args(line, &args[1..]);
                let mut _cr_list = execute::run_command_line(sh, &line_new, true, capture);
                cr_list.append(&mut _cr_list);
                if let Some(last) = cr_list.last() {
                    let status = last.status;
                    if status != 0 && sh.exit_on_error {
                        return (cr_list, false, false);
                    }
                }
            } else if rule == parsers::locust::Rule::EXP_IF {
                let (mut _cr_list, _cont, _brk) = run_exp_if(sh, pair, args, in_loop, capture);
                cr_list.append(&mut _cr_list);
                if _cont {
                    return (cr_list, true, false);
                }
                if _brk {
                    return (cr_list, false, true);
                }
            } else if rule == parsers::locust::Rule::EXP_FOR {
                let mut _cr_list = run_exp_for(sh, pair, args, capture);
                cr_list.append(&mut _cr_list);
            } else if rule == parsers::locust::Rule::EXP_WHILE {
                let mut _cr_list = run_exp_while(sh, pair, args, capture);
                cr_list.append(&mut _cr_list);
            }
        }
        (cr_list, false, false)
    }
}

pub mod shell
{
    use ::
    {
        *,
    };

    use errno::errno;
    use std::collections::{HashMap, HashSet};
    use std::env;
    use std::io::Write;
    use std::mem;

    use regex::Regex;
    use uuid::Uuid;

    use crate::core;
    use crate::libs;
    use crate::parsers;
    use crate::tools;
    use crate::types::{self, CommandLine};

    #[derive(Debug, Clone)]
    pub struct Shell {
        pub jobs: HashMap<i32, types::Job>,
        pub aliases: HashMap<String, String>,
        pub envs: HashMap<String, String>,
        pub funcs: HashMap<String, String>,
        pub cmd: String,
        pub current_dir: String,
        pub previous_dir: String,
        pub previous_cmd: String,
        pub previous_status: i32,
        pub is_login: bool,
        pub exit_on_error: bool,
        pub has_terminal: bool,
        pub session_id: String,
    }

    impl Shell {
        pub fn new() -> Shell {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = tools::get_current_dir();
            // TODO: the shell proc may have terminal later
            // e.g. $ cicada foo.sh &
            // then with a $ fg
            let has_terminal = proc_has_terminal();
            let (session_id, _) = uuid.split_at(13);
            Shell {
                jobs: HashMap::new(),
                aliases: HashMap::new(),
                envs: HashMap::new(),
                funcs: HashMap::new(),
                cmd: String::new(),
                current_dir: current_dir.clone(),
                previous_dir: String::new(),
                previous_cmd: String::new(),
                previous_status: 0,
                is_login: false,
                exit_on_error: false,
                has_terminal,
                session_id: session_id.to_string(),
            }
        }

        pub fn insert_job(&mut self, gid: i32, pid: i32, cmd: &str, status: &str, bg: bool) {
            let mut i = 1;
            loop {
                let mut indexed_job_missing = false;
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        x.pids.push(pid);
                        x.cmd = format!("{} | {}", x.cmd, cmd);
                        return;
                    }
                } else {
                    indexed_job_missing = true;
                }

                if indexed_job_missing {
                    self.jobs.insert(
                        i,
                        types::Job {
                            cmd: cmd.to_string(),
                            id: i,
                            gid,
                            pids: vec![pid],
                            pids_stopped: HashSet::new(),
                            status: status.to_string(),
                            is_bg: bg,
                        },
                    );
                    return;
                }
                i += 1;
            }
        }

        pub fn get_job_by_id(&self, job_id: i32) -> Option<&types::Job> {
            self.jobs.get(&job_id)
        }

        pub fn mark_job_member_continued(&mut self, pid: i32,
                                        gid: i32) -> Option<&types::Job> {
            if self.jobs.is_empty() {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.pids_stopped.remove(&pid);
                        idx_found = i;
                        break;
                    }
                }


                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            self.jobs.get(&idx_found)
        }

        pub fn mark_job_member_stopped(&mut self, pid: i32,
                                    gid: i32) -> Option<&types::Job> {
            if self.jobs.is_empty() {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.pids_stopped.insert(pid);
                        idx_found = i;
                        break;
                    }
                }


                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            self.jobs.get(&idx_found)
        }

        pub fn get_job_by_gid(&self, gid: i32) -> Option<&types::Job> {
            if self.jobs.is_empty() {
                return None;
            }

            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get(&i) {
                    if x.gid == gid {
                        return Some(x);
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
            None
        }

        pub fn mark_job_as_running(&mut self, gid: i32, bg: bool) {
            if self.jobs.is_empty() {
                return;
            }

            let mut i = 1;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.status = "Running".to_string();
                        job.pids_stopped.clear();
                        job.is_bg = bg;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }

        pub fn mark_job_as_stopped(&mut self, gid: i32) {
            if self.jobs.is_empty() {
                return;
            }

            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        x.status = "Stopped".to_string();
                        x.is_bg = true;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }

        pub fn remove_pid_from_job(&mut self, gid: i32, pid: i32) -> Option<types::Job> {
            if self.jobs.is_empty() {
                return None;
            }

            let mut empty_pids = false;
            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        if let Ok(i_pid) = x.pids.binary_search(&pid) {
                            x.pids.remove(i_pid);
                        }
                        empty_pids = x.pids.is_empty();
                        break;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            if empty_pids {
                return self.jobs.remove(&i);
            }
            None
        }
        /// Update existing *ENV Variable* if such name exists in ENVs,
        /// otherwise, we define a local *Shell Variable*, which would not
        /// be exported into child processes.
        pub fn set_env(&mut self, name: &str, value: &str) {
            if env::var(name).is_ok() {
                env::set_var(name, value);
            } else {
                self.envs.insert(name.to_string(), value.to_string());
            }
        }
        /// get *Shell Variable*, or *ENV Variable*.
        pub fn get_env(&self, name: &str) -> Option<String> {
            match self.envs.get(name) {
                Some(x) => Some(x.to_string()),
                None => {
                    match env::var(name) {
                        Ok(x) => Some(x),
                        Err(_) => None,
                    }
                }
            }
        }
        /// Remove environment variable, function from the environment of
        /// the currently running process
        pub fn remove_env(&mut self, name: &str) -> bool {
            // function names can contain the `-` char.
            let ptn_env = Regex::new(r"^[a-zA-Z_][a-zA-Z0-9_-]*$").unwrap();
            if !ptn_env.is_match(name) {
                return false;
            }

            env::remove_var(name);
            self.envs.remove(name);
            self.remove_func(name);
            true
        }

        pub fn remove_path(&mut self, path: &str) {
            if let Ok(paths) = env::var("PATH") {
                let mut paths_new: Vec<&str> = paths.split(":").collect();
                paths_new.retain(|&x| x != path);
                env::set_var("PATH", paths_new.join(":").as_str());
            }
        }

        fn remove_func(&mut self, name: &str) {
            self.funcs.remove(name);
        }

        pub fn set_func(&mut self, name: &str, value: &str) {
            self.funcs.insert(name.to_string(), value.to_string());
        }

        pub fn get_func(&self, name: &str) -> Option<String> {
            self.funcs.get(name).map(|x| x.to_string())
        }

        pub fn get_alias_list(&self) -> Vec<(String, String)> {
            let mut result = Vec::new();
            for (name, value) in &self.aliases {
                result.push((name.clone(), value.clone()));
            }
            result
        }

        pub fn add_alias(&mut self, name: &str, value: &str) {
            self.aliases.insert(name.to_string(), value.to_string());
        }

        pub fn is_alias(&self, name: &str) -> bool {
            self.aliases.contains_key(name)
        }

        pub fn remove_alias(&mut self, name: &str) -> bool {
            let opt = self.aliases.remove(name);
            opt.is_some()
        }

        pub fn get_alias_content(&self, name: &str) -> Option<String> {
            let result = match self.aliases.get(name) {
                Some(x) => x.to_string(),
                None => String::new(),
            };
            if result.is_empty() {
                None
            } else {
                Some(result)
            }
        }
    }

    pub unsafe fn give_terminal_to(gid: i32) -> bool {
        let mut mask: libc::sigset_t = mem::zeroed();
        let mut old_mask: libc::sigset_t = mem::zeroed();

        libc::sigemptyset(&mut mask);
        libc::sigaddset(&mut mask, libc::SIGTSTP);
        libc::sigaddset(&mut mask, libc::SIGTTIN);
        libc::sigaddset(&mut mask, libc::SIGTTOU);
        libc::sigaddset(&mut mask, libc::SIGCHLD);

        let rcode = libc::pthread_sigmask(libc::SIG_BLOCK, &mask, &mut old_mask);
        if rcode != 0 {
            log!("failed to call pthread_sigmask");
        }
        let rcode = libc::tcsetpgrp(1, gid);
        let given;
        if rcode == -1 {
            given = false;
            let e = errno();
            let code = e.0;
            log!("error in give_terminal_to() {}: {}", code, e);
        } else {
            given = true;
        }
        let rcode = libc::pthread_sigmask(libc::SIG_SETMASK, &old_mask, &mut mask);
        if rcode != 0 {
            log!("failed to call pthread_sigmask");
        }
        given
    }

    fn needs_globbing(line: &str) -> bool {
        let re = Regex::new(r"\*+").expect("Invalid regex ptn");
        re.is_match(line)
    }

    pub fn expand_glob(tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !needs_globbing(text) {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let item = text.as_str();

            if !item.contains('*') || item.trim().starts_with('\'') || item.trim().starts_with('"') {
                result.push(item.to_string());
            } else {
                let _basename = libs::path::basename(item);
                let show_hidden = _basename.starts_with(".*");

                match glob::glob(item) {
                    Ok(paths) => {
                        let mut is_empty = true;
                        for entry in paths {
                            match entry {
                                Ok(path) => {
                                    let file_path = path.to_string_lossy();
                                    let _basename = libs::path::basename(&file_path);
                                    if _basename == ".." || _basename == "." {
                                        continue;
                                    }
                                    if _basename.starts_with('.') && !show_hidden {
                                        // skip hidden files, you may need to
                                        // type `ls .*rc` instead of `ls *rc`
                                        continue;
                                    }
                                    result.push(file_path.to_string());
                                    is_empty = false;
                                }
                                Err(e) => {
                                    log!("glob error: {:?}", e);
                                }
                            }
                        }
                        if is_empty {
                            result.push(item.to_string());
                        }
                    }
                    Err(e) => {
                        println!("glob error: {:?}", e);
                        result.push(item.to_string());
                        return;
                    }
                }
            }

            buff.push((idx, result));
            idx += 1;
        }

        for (i, result) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in result.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }

    fn expand_one_env(sh: &Shell, token: &str) -> String {
        // do not combine these two into one: `\{?..\}?`,
        // otherwize `}` in `{print $NF}` would gone.
        let re1 = Regex::new(r"^(.*?)\$([A-Za-z0-9_]+|\$|\?)(.*)$").unwrap();
        let re2 = Regex::new(r"(.*?)\$\{([A-Za-z0-9_]+|\$|\?)\}(.*)$").unwrap();
        if !re1.is_match(token) && !re2.is_match(token) {
            return token.to_string();
        }

        let mut result = String::new();
        let match_re1 = re1.is_match(token);
        let match_re2 = re2.is_match(token);
        if !match_re1 && !match_re2 {
            return token.to_string();
        }

        let cap_results = if match_re1 {
            re1.captures_iter(token)
        } else {
            re2.captures_iter(token)
        };

        for cap in cap_results {
            let head = cap[1].to_string();
            let tail = cap[3].to_string();
            let key = cap[2].to_string();
            if key == "?" {
                result.push_str(format!("{}{}", head, sh.previous_status).as_str());
            } else if key == "$" {
                unsafe {
                    let val = libc::getpid();
                    result.push_str(format!("{}{}", head, val).as_str());
                }
            } else if let Ok(val) = env::var(&key) {
                result.push_str(format!("{}{}", head, val).as_str());
            } else if let Some(val) = sh.get_env(&key) {
                result.push_str(format!("{}{}", head, val).as_str());
            } else {
                result.push_str(&head);
            }
            result.push_str(&tail);
        }

        result
    }

    fn need_expand_brace(line: &str) -> bool {
        libs::re::re_contains(line, r#"\{[^ "']*,[^ "']*,?[^ "']*\}"#)
    }

    fn brace_getitem(s: &str, depth: i32) -> (Vec<String>, String) {
        let mut out: Vec<String> = vec![String::new()];
        let mut ss = s.to_string();
        let mut tmp;
        while !ss.is_empty() {
            let c = match ss.chars().next() {
                Some(x) => x,
                None => {
                    return (out, ss);
                }
            };
            if depth > 0 && (c == ',' || c == '}') {
                return (out, ss);
            }
            if c == '{' {
                let mut sss = ss.clone();
                sss.remove(0);
                let result_groups = brace_getgroup(&sss, depth + 1);
                if let Some((out_group, s_group)) = result_groups {
                    let mut tmp_out = Vec::new();
                    for x in out.iter() {
                        for y in out_group.iter() {
                            let item = format!("{}{}", x, y);
                            tmp_out.push(item);
                        }
                    }
                    out = tmp_out;
                    ss = s_group.clone();
                    continue;
                }
            }
            // FIXME: here we mean more than one char.
            if c == '\\' && ss.len() > 1 {
                ss.remove(0);
                let c;
                match ss.chars().next() {
                    Some(x) => c = x,
                    None => {
                        return (out, ss)
                    }
                }

                tmp = format!("\\{}", c);
            } else {
                tmp = c.to_string();
            }
            let mut result = Vec::new();
            for x in out.iter() {
                let item = format!("{}{}", x, tmp);
                result.push(item);
            }
            out = result;
            ss.remove(0);
        }
        (out, ss)
    }

    fn brace_getgroup(s: &str, depth: i32) -> Option<(Vec<String>, String)> {
        let mut out: Vec<String> = Vec::new();
        let mut comma = false;
        let mut ss = s.to_string();
        while !ss.is_empty() {
            let (g, sss) = brace_getitem(ss.as_str(), depth);
            ss = sss.clone();
            if ss.is_empty() {
                break;
            }
            for x in g.iter() {
                out.push(x.clone());
            }

            let c = match ss.chars().next() {
                Some(x) => x,
                None => {
                    break;
                }
            };
            if c == '}' {
                let mut sss = ss.clone();
                sss.remove(0);
                if comma {
                    return Some((out, sss));
                }
                let mut result = Vec::new();
                for x in out.iter() {
                    let item = format!("{{{}}}", x);
                    result.push(item);
                }
                return Some((result, ss));
            }
            if c == ',' {
                comma = true;
                ss.remove(0);
            }
        }

        None
    }

    fn expand_brace(tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, token) in tokens.iter() {
            if !sep.is_empty() || !need_expand_brace(token) {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let items = brace_getitem(token, 0);
            for x in items.0 {
                result.push(x.clone());
            }
            buff.push((idx, result));
            idx += 1;
        }

        for (i, items) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in items.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }

    fn expand_brace_range(tokens: &mut types::Tokens) {
        let re;
        if let Ok(x) = Regex::new(r#"\{(-?[0-9]+)\.\.(-?[0-9]+)(\.\.)?([0-9]+)?\}"#) {
            re = x;
        } else {
            println_stderr!(":: re new error");
            return;
        }

        let mut idx: usize = 0;
        let mut buff: Vec<(usize, Vec<String>)> = Vec::new();
        for (sep, token) in tokens.iter() {
            if !sep.is_empty() || !re.is_match(token) {
                idx += 1;
                continue;
            }

            // safe to unwrap here, since the `is_match` above already validated
            let caps = re.captures(token).unwrap();

            let start = match caps[1].to_string().parse::<i32>() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!(":: {}", e);
                    return;
                }
            };

            let end = match caps[2].to_string().parse::<i32>() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!(":: {}", e);
                    return;
                }
            };

            // incr is always positive
            let mut incr = if caps.get(4).is_none() {
                1
            } else {
                match caps[4].to_string().parse::<i32>() {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!(":: {}", e);
                        return;
                    }
                }
            };
            if incr <= 1 {
                incr = 1;
            }

            let mut result: Vec<String> = Vec::new();
            let mut n = start;
            if start > end {
                while n >= end {
                    result.push(format!("{}", n));
                    n -= incr;
                }
            } else {
                while n <= end {
                    result.push(format!("{}", n));
                    n += incr;
                }
            }

            buff.push((idx, result));
            idx += 1;
        }

        for (i, items) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in items.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }

    fn expand_alias(sh: &Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        let mut is_head = true;
        for (sep, text) in tokens.iter() {
            if sep.is_empty() && text == "|" {
                is_head = true;
                idx += 1;
                continue;
            }
            if is_head && text == "xargs" {
                idx += 1;
                continue;
            }

            if !is_head || !sh.is_alias(text) {
                idx += 1;
                is_head = false;
                continue;
            }

            if let Some(value) = sh.get_alias_content(text) {
                buff.push((idx, value.clone()));
            }

            idx += 1;
            is_head = false;
        }

        for (i, text) in buff.iter().rev() {
            let linfo = parsers::parser_line::parse_line(text);
            let tokens_ = linfo.tokens;
            tokens.remove(*i);
            for item in tokens_.iter().rev() {
                tokens.insert(*i, item.clone());
            }
        }
    }

    fn expand_home(tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !text.starts_with("~") {
                idx += 1;
                continue;
            }

            let mut s: String = text.clone();
            let ptn = r"^~(?P<tail>.*)";
            let re = Regex::new(ptn).expect("invalid re ptn");
            let home = tools::get_user_home();
            let ss = s.clone();
            let to = format!("{}$tail", home);
            let result = re.replace_all(ss.as_str(), to.as_str());
            s = result.to_string();

            buff.push((idx, s.clone()));
            idx += 1;
        }

        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn env_in_token(token: &str) -> bool {
        if libs::re::re_contains(token, r"\$\{?[\$\?]\}?") {
            return true;
        }

        let ptn_env_name = r"[a-zA-Z_][a-zA-Z0-9_]*";
        let ptn_env = format!(r"\$\{{?{}\}}?", ptn_env_name);
        if !libs::re::re_contains(token, &ptn_env) {
            return false;
        }

        // do not expand env in a command substitution, e.g.:
        // - echo $(echo '$HOME')
        // - VERSION=$(foobar -h | grep 'version: v' | awk '{print $NF}')
        let ptn_cmd_sub1 = format!(r"^{}=`.*`$", ptn_env_name);
        let ptn_cmd_sub2 = format!(r"^{}=\$\(.*\)$", ptn_env_name);
        if libs::re::re_contains(token, &ptn_cmd_sub1)
            || libs::re::re_contains(token, &ptn_cmd_sub2)
            || libs::re::re_contains(token, r"^\$\(.+\)$")
        {
            return false;
        }

        // for cmd-line like `alias foo='echo $PWD'`
        let ptn_env = format!(r"='.*\$\{{?{}\}}?.*'$", ptn_env_name);
        !libs::re::re_contains(token, &ptn_env)
    }

    pub fn expand_env(sh: &Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for (sep, token) in tokens.iter() {
            if sep == "`" || sep == "'" {
                idx += 1;
                continue;
            }

            if !env_in_token(token) {
                idx += 1;
                continue;
            }

            let mut _token = token.clone();
            while env_in_token(&_token) {
                _token = expand_one_env(sh, &_token);
            }
            buff.push((idx, _token));
            idx += 1;
        }

        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn should_do_dollar_command_extension(line: &str) -> bool {
        libs::re::re_contains(line, r"\$\([^\)]+\)") &&
        !libs::re::re_contains(line, r"='.*\$\([^\)]+\).*'$")
    }

    fn do_command_substitution_for_dollar(sh: &mut Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();

        for (sep, token) in tokens.iter() {
            if sep == "'" || sep == "\\" || !should_do_dollar_command_extension(token) {
                idx += 1;
                continue;
            }

            let mut line = token.to_string();
            loop {
                if !should_do_dollar_command_extension(&line) {
                    break;
                }

                let ptn_cmd = r"\$\((.+)\)";
                let cmd = match libs::re::find_first_group(ptn_cmd, &line) {
                    Some(x) => x,
                    None => {
                        println_stderr!(":: calculator: no first group");
                        return;
                    }
                };

                let cmd_result = match CommandLine::from_line(&cmd, sh) {
                    Ok(c) => {
                        log!("run subcmd dollar: {:?}", &cmd);
                        let (term_given, cr) = core::run_pipeline(sh, &c, true, true, false);
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid(0);
                                give_terminal_to(gid);
                            }
                        }

                        cr
                    }
                    Err(e) => {
                        println_stderr!(":: {}", e);
                        continue;
                    }
                };

                let output_txt = cmd_result.stdout.trim();

                let ptn = r"(?P<head>[^\$]*)\$\(.+\)(?P<tail>.*)";
                let re;
                if let Ok(x) = Regex::new(ptn) {
                    re = x;
                } else {
                    return;
                }

                let to = format!("${{head}}{}${{tail}}", output_txt);
                let line_ = line.clone();
                let result = re.replace(&line_, to.as_str());
                line = result.to_string();
            }

            buff.insert(idx, line.clone());
            idx += 1;
        }

        for (i, text) in buff.iter() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn do_command_substitution_for_dot(sh: &mut Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();
        for (sep, token) in tokens.iter() {
            let new_token: String;
            if sep == "`" {
                log!("run subcmd dot1: {:?}", token);
                let cr = match CommandLine::from_line(token, sh) {
                    Ok(c) => {
                        let (term_given, _cr) = core::run_pipeline(sh, &c, true, true, false);
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid(0);
                                give_terminal_to(gid);
                            }
                        }

                        _cr
                    }
                    Err(e) => {
                        println_stderr!(":: {}", e);
                        continue;
                    }
                };

                new_token = cr.stdout.trim().to_string();
            } else if sep == "\"" || sep.is_empty() {
                let re;
                if let Ok(x) = Regex::new(r"^([^`]*)`([^`]+)`(.*)$") {
                    re = x;
                } else {
                    println_stderr!(":: re new error");
                    return;
                }
                if !re.is_match(token) {
                    idx += 1;
                    continue;
                }
                let mut _token = token.clone();
                let mut _item = String::new();
                let mut _head = String::new();
                let mut _output = String::new();
                let mut _tail = String::new();
                loop {
                    if !re.is_match(&_token) {
                        if !_token.is_empty() {
                            _item = format!("{}{}", _item, _token);
                        }
                        break;
                    }
                    for cap in re.captures_iter(&_token) {
                        _head = cap[1].to_string();
                        _tail = cap[3].to_string();
                        log!("run subcmd dot2: {:?}", &cap[2]);

                        let cr = match CommandLine::from_line(&cap[2], sh) {
                            Ok(c) => {
                                let (term_given, _cr) = core::run_pipeline(sh, &c, true, true, false);
                                if term_given {
                                    unsafe {
                                        let gid = libc::getpgid(0);
                                        give_terminal_to(gid);
                                    }
                                }

                                _cr
                            }
                            Err(e) => {
                                println_stderr!(":: {}", e);
                                continue;
                            }
                        };

                        _output = cr.stdout.trim().to_string();
                    }
                    _item = format!("{}{}{}", _item, _head, _output);
                    if _tail.is_empty() {
                        break;
                    }
                    _token = _tail.clone();
                }
                new_token = _item;
            } else {
                idx += 1;
                continue;
            }

            buff.insert(idx, new_token.clone());
            idx += 1;
        }

        for (i, text) in buff.iter() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn do_command_substitution(sh: &mut Shell, tokens: &mut types::Tokens) {
        do_command_substitution_for_dot(sh, tokens);
        do_command_substitution_for_dollar(sh, tokens);
    }

    pub fn do_expansion(sh: &mut Shell, tokens: &mut types::Tokens) {
        let line = parsers::parser_line::tokens_to_line(tokens);
        if tools::is_arithmetic(&line) {
            return;
        }

        if tokens.len() >= 2 && tokens[0].1 == "export" && tokens[1].1.starts_with("PROMPT=") {
            return;
        }

        expand_alias(sh, tokens);
        expand_home(tokens);
        expand_env(sh, tokens);
        expand_brace(tokens);
        expand_glob(tokens);
        do_command_substitution(sh, tokens);
        expand_brace_range(tokens);
    }

    pub fn trim_multiline_prompts(line: &str) -> String {
        // remove sub-prompts from multiple line mode
        // 1. assuming '\n' char cannot be typed manually?
        // 2. `>>` is defined as `src/prompt/multilines.rs`
        let line_new = libs::re::replace_all(line, r"\\\n>> ", "");
        let line_new = libs::re::replace_all(&line_new, r"\| *\n>> ", "| ");
        libs::re::replace_all(&line_new, r"(?P<NEWLINE>\n)>> ", "$NEWLINE")
    }

    fn proc_has_terminal() -> bool {
        unsafe {
            let tgid = libc::tcgetpgrp(0);
            let pgid = libc::getpgid(0);
            tgid == pgid
        }
    }
}

pub mod signals
{
    use ::
    {
        *,
    };

    use errno::{errno, set_errno};
    use nix::sys::signal;
    use nix::sys::wait::{WaitPidFlag as WF, WaitStatus as WS, waitpid};
    use nix::unistd::Pid;
    use std::sync::Mutex;
    use std::collections::{HashMap, HashSet};

    lazy_static! {
        static ref REAP_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
        static ref STOP_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
        static ref CONT_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
        static ref KILL_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
    }

    pub fn killed_map_insert(pid: i32, sig: i32) {
        if let Ok(mut m) = KILL_MAP.try_lock() {
            m.insert(pid, sig);
        }
    }

    pub fn killed_map_pop(pid: i32) -> Option<i32> {
        if let Ok(mut m) = KILL_MAP.try_lock() {
            m.remove(&pid)
        } else {
            None
        }
    }

    pub fn insert_cont_map(pid: i32) {
        if let Ok(mut m) = CONT_MAP.try_lock() {
            m.insert(pid);
        }
    }

    pub fn pop_cont_map(pid: i32) -> bool {
        match CONT_MAP.try_lock() {
            Ok(mut m) => m.remove(&pid),
            Err(_) => false,
        }
    }

    pub fn insert_stopped_map(pid: i32) {
        if let Ok(mut m) = STOP_MAP.try_lock() {
            m.insert(pid);
        }
    }

    pub fn pop_stopped_map(pid: i32) -> bool {
        match STOP_MAP.try_lock() {
            Ok(mut m) => m.remove(&pid),
            Err(_) => false,
        }
    }

    pub fn insert_reap_map(pid: i32, status: i32) {
        if let Ok(mut m) = REAP_MAP.try_lock() {
            m.insert(pid, status);
        }
    }

    pub fn pop_reap_map(pid: i32) -> Option<i32> {
        match REAP_MAP.try_lock() {
            Ok(mut m) => m.remove(&pid),
            Err(_) => None,
        }
    }

    pub fn block_signals() {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        match signal::sigprocmask(signal::SigmaskHow::SIG_BLOCK, Some(&sigset), None) {
            Ok(_) => {},
            Err(e) => {
                log!("sigprocmask block error: {:?}", e);
            }
        }
    }

    pub fn unblock_signals() {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        match signal::sigprocmask(signal::SigmaskHow::SIG_UNBLOCK, Some(&sigset), None) {
            Ok(_) => {},
            Err(e) => {
                log!("sigprocmask unblock error: {:?}", e);
            }
        }
    }

    #[allow(unreachable_patterns)]
    pub extern "C" fn handle_sigchld(_sig: i32) {
        let saved_errno = errno();
        let options = Some(WF::WUNTRACED | WF::WNOHANG | WF::WCONTINUED);
        loop {
            match waitpid(Pid::from_raw(-1), options) {
                Ok(WS::Exited(pid, status)) => {
                    insert_reap_map(i32::from(pid), status);
                }
                Ok(WS::Stopped(pid, _sig)) => {
                    insert_stopped_map(i32::from(pid));
                }
                Ok(WS::Continued(pid)) => {
                    // NOTE: SIGCHLD generated by SIGCONT is not reliable
                    // on Mac (both for signal handler or sync waitpid).
                    insert_cont_map(i32::from(pid));
                }
                Ok(WS::Signaled(pid, sig, _core_dumped)) => {
                    killed_map_insert(i32::from(pid), sig as i32);
                }
                Ok(WS::StillAlive) => {
                    break;
                }
                Ok(_others) => {
                    // log!("sigchld others: {:?}", _others);
                }
                Err(e) => {
                    if e == nix::Error::ECHILD {
                        break;
                    }

                    log!("chld waitpid error: {:?}", e);
                    break;
                }
            }
        }

        set_errno(saved_errno);
    }

    pub fn setup_sigchld_handler() {
        let sigset = signal::SigSet::empty();
        let handler = signal::SigHandler::Handler(handle_sigchld);
        // automatically restart system calls interrupted by this signal handler
        let flags = signal::SaFlags::SA_RESTART;
        let sa = signal::SigAction::new(handler, flags, sigset);
        unsafe {
            match signal::sigaction(signal::SIGCHLD, &sa) {
                Ok(_) => {},
                Err(e) => {
                    log!("sigaction error: {:?}", e);
                }
            }
        }
    }
}

pub mod str
{
    pub use std::str::{ * };
}

pub mod sync
{
    pub mod atomic
    {
        pub use std::sync::atomic::{ * };
        /// A memory location which can be safely modified from multiple threads.
        pub type Atomic<T> = <T as AtomicPrimitive>::AtomicInner;
        /// A boolean type which can be safely shared between threads.
        pub struct AtomicBool
        {
            v: UnsafeCell<u8>,
        }

    }

    pub use std::sync::{ atomic as lib, * };
} use std::sync::Arc;

pub mod system
{
    use ::
    {
        *
    };

    pub mod common
    {
        use ::
        {
            *
        };

        pub mod api
        {

        }
    }

    pub use self::common::{ * };
}

pub mod tools
{
    use ::
    {
        *,
    };
    
    pub fn is_signal_handler_enabled() -> bool
    {
        env::var("CICADA_ENABLE_SIG_HANDLER").map_or(false, |x| x == "1")
    }

    pub fn get_user_name() -> String
    {
        match env::var("USER")
        {
            Ok(x) => { return x; }
            Err(e) => { log!(":: env USER error: {}", e); }
        }

        let cmd_result = execute::run("whoami");
        return cmd_result.stdout.trim().to_string();
    }

    pub fn get_user_home() -> String
    {
        match env::var("HOME")
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!(":: env HOME error: {}", e);
                String::new()
            }
        }
    }

    pub fn get_config_dir() -> String
    {
        if let Ok(x) = env::var("XDG_CONFIG_HOME")
        {
            format!("{}/cicada", x)
        }
        else
        {
            let home = get_user_home();
            format!("{}/.config/cicada", home)
        }
    }

    pub fn get_user_completer_dir() -> String
    {
        let dir_config = get_config_dir();
        format!("{}/completers", dir_config)
    }

    pub fn unquote(s: &str) -> String
    {
        let args = parsers::parser_line::line_to_plain_tokens(s);
        if args.is_empty() { return String::new(); }

        args[0].clone()
    }

    pub fn is_env(line: &str) -> bool
    {
        re_contains(line, r"^[a-zA-Z_][a-zA-Z0-9_]*=.*$")
    }
    
    pub fn extend_bangbang(sh: &shell::Shell, line: &mut String)
    {
        if !re_contains(line, r"!!") { return; }
        if sh.previous_cmd.is_empty() { return; }

        let re = Regex::new(r"!!").unwrap();
        let mut replaced = false;
        let mut new_line = String::new();
        let linfo = parsers::parser_line::parse_line(line);
        for (sep, token) in linfo.tokens
        {
            if !sep.is_empty() { new_line.push_str(&sep); }

            if re_contains(&token, r"!!") && sep != "'"
            {
                let line2 = token.clone();
                let result = re.replace_all(&line2, sh.previous_cmd.as_str());
                new_line.push_str(&result);
                replaced = true;
            }
            else {
                new_line.push_str(&token);
            }

            if !sep.is_empty() {
                new_line.push_str(&sep);
            }
            new_line.push(' ');
        }

        *line = new_line.trim_end().to_string();
        // print full line after extending
        if replaced {
            println!("{}", line);
        }
    }

    pub fn wrap_sep_string(sep: &str, s: &str) -> String {
        let mut _token = String::new();
        let mut met_subsep = false;
        // let set previous_subsep to any char except '`' or '"'
        let mut previous_subsep = 'N';
        for c in s.chars() {
            // handle cmds like: export DIR=`brew --prefix openssl`/include
            // or like: export foo="hello world"
            if sep.is_empty() && (c == '`' || c == '"') {
                if !met_subsep {
                    met_subsep = true;
                    previous_subsep = c;
                } else if c == previous_subsep {
                    met_subsep = false;
                    previous_subsep = 'N';
                }
            }
            if c.to_string() == sep {
                _token.push('\\');
            }
            if c == ' ' && sep.is_empty() && !met_subsep {
                _token.push('\\');
            }
            _token.push(c);
        }
        format!("{}{}{}", sep, _token, sep)
    }

    pub fn env_args_to_command_line() -> String {
        let mut result = String::new();
        let env_args = env::args();
        if env_args.len() <= 1 {
            return result;
        }
        for (i, arg) in env_args.enumerate() {
            if i == 0 || arg == "-c" {
                continue;
            }
            result.push_str(arg.as_str());
        }
        result
    }

    extern "C" {
        fn gethostname(name: *mut libc::c_char, size: libc::size_t) -> libc::c_int;
    }

    /// via: https://gist.github.com/conradkleinespel/6c8174aee28fa22bfe26
    pub fn get_hostname() -> String {
        let len = 255;
        let mut buf = Vec::<u8>::with_capacity(len);

        let ptr = buf.as_mut_slice().as_mut_ptr();

        let err = unsafe { gethostname(ptr as *mut libc::c_char, len as libc::size_t) } as i32;

        match err {
            0 => {
                let real_len;
                let mut i = 0;
                loop {
                    let byte = unsafe { *(((ptr as u64) + (i as u64)) as *const u8) };
                    if byte == 0 {
                        real_len = i;
                        break;
                    }

                    i += 1;
                }
                unsafe { buf.set_len(real_len) }
                String::from_utf8_lossy(buf.as_slice()).into_owned()
            }
            _ => String::from("unknown"),
        }
    }

    pub fn is_arithmetic(line: &str) -> bool {
        if !re_contains(line, r"[0-9]+") {
            return false;
        }
        if !re_contains(line, r"\+|\-|\*|/|\^") {
            return false;
        }
        re_contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$")
    }

    pub fn create_raw_fd_from_file(file_name: &str, append: bool) -> Result<i32, String> {
        let mut oos = OpenOptions::new();
        if append {
            oos.append(true);
        } else {
            oos.write(true);
            oos.truncate(true);
        }
        match oos.create(true).open(file_name) {
            Ok(x) => {
                let fd = x.into_raw_fd();
                Ok(fd)
            }
            Err(e) => Err(format!("{}", e)),
        }
    }

    pub fn get_fd_from_file(file_name: &str) -> i32 {
        let path = Path::new(file_name);
        let display = path.display();
        let file = match File::open(path) {
            Err(why) => {
                println_stderr!(":: {}: {}", display, why);
                return -1;
            }
            Ok(file) => file,
        };
        file.into_raw_fd()
    }

    pub fn escape_path(path: &str) -> String {
        let re = Regex::new(r##"(?P<c>[!\(\)<>,\?\]\[\{\} \\'"`*\^#|$&;])"##).unwrap();
        return re.replace_all(path, "\\$c").to_string();
    }

    pub fn get_current_dir() -> String {
        let mut current_dir = PathBuf::new();
        match env::current_dir() {
            Ok(x) => current_dir = x,
            Err(e) => {
                println_stderr!("env current_dir() failed: {}", e);
            }
        }
        let mut str_current_dir = "";
        match current_dir.to_str() {
            Some(x) => str_current_dir = x,
            None => {
                println_stderr!("current_dir to str failed.");
            }
        }
        str_current_dir.to_string()
    }

    pub fn split_into_fields(
        sh: &shell::Shell,
        line: &str,
        envs: &HashMap<String, String>,
    ) -> Vec<String> {
        let ifs_chars;
        if envs.contains_key("IFS") {
            ifs_chars = envs[&"IFS".to_string()].chars().collect();
        } else if let Some(x) = sh.get_env("IFS") {
            ifs_chars = x.chars().collect();
        } else if let Ok(x) = env::var("IFS") {
            ifs_chars = x.chars().collect();
        } else {
            ifs_chars = vec![];
        }

        if ifs_chars.is_empty() {
            return line
                .split(&[' ', '\t', '\n'][..])
                .map(|x| x.to_string())
                .collect();
        } else {
            return line.split(&ifs_chars[..]).map(|x| x.to_string()).collect();
        }
    }

    pub fn is_builtin(s: &str) -> bool {
        let builtins = [
            "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg",
            "history", "jobs", "read", "source", "ulimit", "unalias", "vox",
            "minfd", "set", "unset", "unpath",
        ];
        builtins.contains(&s)
    }

    pub fn init_path_env() {
        // order matters. took from `runc spec`
        let mut paths: Vec<String> = vec![];
        for x in [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ] {
            if Path::new(x).exists() {
                paths.push(x.to_string());
            }
        }

        if let Ok(env_path) = env::var("PATH") {
            for x in env_path.split(":") {
                if !paths.contains(&x.to_string()) {
                    paths.push(x.to_string());
                }
            }
        }
        let paths = paths.join(":");
        env::set_var("PATH", paths);
    }

    pub fn is_shell_altering_command(line: &str) -> bool {
        let line = line.trim();
        if re_contains(line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$") {
            return true;
        }
        line.starts_with("alias ")
            || line.starts_with("export ")
            || line.starts_with("unalias ")
            || line.starts_with("unset ")
            || line.starts_with("source ")
    }
}

pub mod types
{
    use ::
    {
        *,
    };
    use regex::Regex;
    use std::collections::{HashMap, HashSet};
    use std::fmt;

    use crate::parsers;
    use crate::parsers::parser_line::tokens_to_redirections;
    use crate::shell;
    use crate::libs;
    use crate::tools;

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct WaitStatus(i32, i32, i32);

    impl WaitStatus {
        pub fn from_exited(pid: i32, status: i32) -> Self {
            WaitStatus(pid, 0, status)
        }

        pub fn from_signaled(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 1, sig)
        }

        pub fn from_stopped(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 2, sig)
        }

        pub fn from_continuted(pid: i32) -> Self {
            WaitStatus(pid, 3, 0)
        }

        pub fn from_others() -> Self {
            WaitStatus(0, 9, 9)
        }

        pub fn from_error(errno: i32) -> Self {
            WaitStatus(0, 255, errno)
        }

        pub fn empty() -> Self {
            WaitStatus(0, 0, 0)
        }

        pub fn is_error(&self) -> bool {
            self.1 == 255
        }

        pub fn is_others(&self) -> bool {
            self.1 == 9
        }

        pub fn is_signaled(&self) -> bool {
            self.1 == 1
        }

        pub fn get_errno(&self) -> nix::Error {
            nix::Error::from_raw(self.2)
        }

        pub fn is_exited(&self) -> bool {
            self.0 != 0 && self.1 == 0
        }

        pub fn is_stopped(&self) -> bool {
            self.1 == 2
        }

        pub fn is_continued(&self) -> bool {
            self.1 == 3
        }

        pub fn get_pid(&self) -> i32 {
            self.0
        }

        fn _get_signaled_status(&self) -> i32 {
            self.2 + 128
        }

        pub fn get_signal(&self) -> i32 {
            self.2
        }

        pub fn get_name(&self) -> String {
            if self.is_exited() {
                "Exited".to_string()
            } else if self.is_stopped() {
                "Stopped".to_string()
            } else if self.is_continued() {
                "Continued".to_string()
            } else if self.is_signaled() {
                "Signaled".to_string()
            } else if self.is_others() {
                "Others".to_string()
            } else if self.is_error() {
                "Error".to_string()
            } else {
                format!("unknown: {}", self.2)
            }
        }

        pub fn get_status(&self) -> i32 {
            if self.is_exited() {
                self.2
            } else {
                self._get_signaled_status()
            }
        }
    }

    impl fmt::Debug for WaitStatus {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let mut formatter = f.debug_struct("WaitStatus");
            formatter.field("pid", &self.0);
            let name = self.get_name();
            formatter.field("name", &name);
            formatter.field("ext", &self.2);
            formatter.finish()
        }
    }

    pub type Token = (String, String);
    pub type Tokens = Vec<Token>;
    pub type Redirection = (String, String, String);

    #[derive(Debug)]
    pub struct LineInfo {
        // e.g. echo 'foo
        // is not a completed line, need to turn to multiple-line mode.
        pub tokens: Tokens,
        pub is_complete: bool,
    }

    impl LineInfo {
        pub fn new(tokens: Tokens) -> Self {
            LineInfo { tokens, is_complete: true }
        }
    }

    ///
    /// command line: `ls 'foo bar' 2>&1 > /dev/null < one-file` would be:
    /// Command {
    ///     tokens: [("", "ls"), ("", "-G"), ("\'", "foo bar")],
    ///     redirects_to: [
    ///         ("2", ">", "&1"),
    ///         ("1", ">", "/dev/null"),
    ///     ],
    ///     redirect_from: Some(("<", "one-file")),
    /// }
    ///
    #[derive(Debug)]
    pub struct Command {
        pub tokens: Tokens,
        pub redirects_to: Vec<Redirection>,
        pub redirect_from: Option<Token>,
    }

    #[derive(Debug)]
    pub struct CommandLine {
        pub line: String,
        pub commands: Vec<Command>,
        pub envs: HashMap<String, String>,
        pub background: bool,
    }

    impl Command {
        pub fn from_tokens(tokens: Tokens) -> Result<Command, String> {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");

            let mut len = tokens_new.len();
            while has_redirect_from {
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<") {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<<<") {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }

                has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");
            }

            let tokens_final;
            let redirects_to;
            match tokens_to_redirections(&tokens_new) {
                Ok((_tokens, _redirects_to)) => {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }
                Err(e) => {
                    return Err(e);
                }
            }

            let redirect_from = if redirects_from_type.is_empty() {
                None
            } else {
                Some((redirects_from_type, redirects_from_value))
            };

            Ok(Command{
                tokens: tokens_final,
                redirects_to,
                redirect_from,
            })
        }

        pub fn has_redirect_from(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<"
        }

        pub fn has_here_string(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<<<"
        }

        pub fn is_builtin(&self) -> bool {
            tools::is_builtin(&self.tokens[0].1)
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Job {
        pub cmd: String,
        pub id: i32,
        pub gid: i32,
        pub pids: Vec<i32>,
        pub pids_stopped: HashSet<i32>,
        pub status: String,
        pub is_bg: bool,
    }

    impl Job {
        pub fn all_members_stopped(&self) -> bool {
            for pid in &self.pids {
                if !self.pids_stopped.contains(pid) {
                    return false;
                }
            }
            true
        }

        pub fn all_members_running(&self) -> bool {
            self.pids_stopped.is_empty()
        }
    }

    
    #[derive(Clone, Debug, Default)]
    pub struct CommandResult {
        pub gid: i32,
        pub status: i32,
        pub stdout: String,
        pub stderr: String,
    }

    impl CommandResult {
        pub fn new() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 0,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn from_status(gid: i32, status: i32) -> CommandResult {
            CommandResult {
                gid,
                status,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn error() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 1,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    }

    
    #[derive(Clone, Debug, Default)]
    pub struct CommandOptions {
        pub background: bool,
        pub isatty: bool,
        pub capture_output: bool,
        pub envs: HashMap<String, String>,
    }

    fn split_tokens_by_pipes(tokens: &[Token]) -> Vec<Tokens> {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();
        for token in tokens {
            let sep = &token.0;
            let value = &token.1;
            if sep.is_empty() && value == "|" {
                if cmd.is_empty() {
                    return Vec::new();
                }
                cmds.push(cmd.clone());
                cmd = Vec::new();
            } else {
                cmd.push(token.clone());
            }
        }
        if cmd.is_empty() {
            return Vec::new();
        }
        cmds.push(cmd.clone());
        cmds
    }

    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String> {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new(r"^([a-zA-Z0-9_]+)=(.*)$").unwrap();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !libs::re::re_contains(text, r"^([a-zA-Z0-9_]+)=(.*)$") {
                break;
            }

            for cap in re.captures_iter(text) {
                let name = cap[1].to_string();
                let value = parsers::parser_line::unquote(&cap[2]);
                envs.insert(name, value);
            }

            n += 1;
        }
        if n > 0 {
            tokens.drain(0..n);
        }
        envs
    }

    impl CommandLine {
        pub fn from_line(line: &str, sh: &mut shell::Shell) -> Result<CommandLine, String> {
            let linfo = parsers::parser_line::parse_line(line);
            let mut tokens = linfo.tokens;
            shell::do_expansion(sh, &mut tokens);
            let envs = drain_env_tokens(&mut tokens);

            let mut background = false;
            let len = tokens.len();
            if len > 1 && tokens[len - 1].1 == "&" {
                background = true;
                tokens.pop();
            }

            let mut commands = Vec::new();
            for sub_tokens in split_tokens_by_pipes(&tokens) {
                match Command::from_tokens(sub_tokens) {
                    Ok(c) => {
                        commands.push(c);
                    }
                    Err(e) => {
                        return Err(e);
                    }
                }
            }

            Ok(CommandLine{
                line: line.to_string(),
                commands,
                envs,
                background,
            })
        }

        pub fn is_empty(&self) -> bool {
            self.commands.is_empty()
        }

        pub fn with_pipeline(&self) -> bool {
            self.commands.len() > 1
        }

        pub fn is_single_and_builtin(&self) -> bool {
            self.commands.len() == 1 && self.commands[0].is_builtin()
        }
    }
}

pub mod yaml_rust
{
    //! YAML 1.2 implementation in pure Rust.
    use ::
    {
        *,
    };

    pub mod emitter
    {
        use ::
        {
            convert::{ From },
            error::{ Error },
            fmt::{ self, Display },
            *,
        }; use super::yaml::{ Hash, Yaml };

        pub type EmitResult = Result<(), EmitError>;

        #[derive(Copy, Clone, Debug)]
        pub enum EmitError 
        {
            FmtError(fmt::Error),
            BadHashmapKey,
        }

        impl Error for EmitError 
        {
            fn cause(&self) -> Option<&dyn Error> {
                None
            }
        }

        impl Display for EmitError 
        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                match *self {
                    EmitError::FmtError(ref err) => Display::fmt(err, formatter),
                    EmitError::BadHashmapKey => formatter.write_str("bad hashmap key"),
                }
            }
        }

        impl From<fmt::Error> for EmitError 
        {
            fn from(f: fmt::Error) -> Self {
                EmitError::FmtError(f)
            }
        }

        pub struct YamlEmitter<'a> 
        {
            writer: &'a mut dyn fmt::Write,
            best_indent: usize,
            compact: bool,

            level: isize,
        }
        
        pub fn escape_str(wr: &mut dyn fmt::Write, v: &str) -> Result<(), fmt::Error> 
        {
            wr.write_str("\"")?;

            let mut start = 0;

            for (i, byte) in v.bytes().enumerate() {
                let escaped = match byte {
                    b'"' => "\\\"",
                    b'\\' => "\\\\",
                    b'\x00' => "\\u0000",
                    b'\x01' => "\\u0001",
                    b'\x02' => "\\u0002",
                    b'\x03' => "\\u0003",
                    b'\x04' => "\\u0004",
                    b'\x05' => "\\u0005",
                    b'\x06' => "\\u0006",
                    b'\x07' => "\\u0007",
                    b'\x08' => "\\b",
                    b'\t' => "\\t",
                    b'\n' => "\\n",
                    b'\x0b' => "\\u000b",
                    b'\x0c' => "\\f",
                    b'\r' => "\\r",
                    b'\x0e' => "\\u000e",
                    b'\x0f' => "\\u000f",
                    b'\x10' => "\\u0010",
                    b'\x11' => "\\u0011",
                    b'\x12' => "\\u0012",
                    b'\x13' => "\\u0013",
                    b'\x14' => "\\u0014",
                    b'\x15' => "\\u0015",
                    b'\x16' => "\\u0016",
                    b'\x17' => "\\u0017",
                    b'\x18' => "\\u0018",
                    b'\x19' => "\\u0019",
                    b'\x1a' => "\\u001a",
                    b'\x1b' => "\\u001b",
                    b'\x1c' => "\\u001c",
                    b'\x1d' => "\\u001d",
                    b'\x1e' => "\\u001e",
                    b'\x1f' => "\\u001f",
                    b'\x7f' => "\\u007f",
                    _ => continue,
                };

                if start < i {
                    wr.write_str(&v[start..i])?;
                }

                wr.write_str(escaped)?;

                start = i + 1;
            }

            if start != v.len() {
                wr.write_str(&v[start..])?;
            }

            wr.write_str("\"")?;
            Ok(())
        }

        impl<'a> YamlEmitter<'a> 
        {
            pub fn new(writer: &'a mut dyn fmt::Write) -> YamlEmitter {
                YamlEmitter {
                    writer,
                    best_indent: 2,
                    compact: true,
                    level: -1,
                }
            }
            /// Set 'compact inline notation' on or off, as described for block
            /// [sequences](http://www.yaml.org/spec/1.2/spec.html#id2797382)
            /// and
            /// [mappings](http://www.yaml.org/spec/1.2/spec.html#id2798057).
            ///
            /// In this form, blocks cannot have any properties (such as anchors
            /// or tags), which should be OK, because this emitter doesn't
            /// (currently) emit those anyways.
            pub fn compact(&mut self, compact: bool) {
                self.compact = compact;
            }
            /// Determine if this emitter is using 'compact inline notation'.
            pub fn is_compact(&self) -> bool {
                self.compact
            }

            pub fn dump(&mut self, doc: &Yaml) -> EmitResult {
                // write DocumentStart
                writeln!(self.writer, "---")?;
                self.level = -1;
                self.emit_node(doc)
            }

            fn write_indent(&mut self) -> EmitResult {
                if self.level <= 0 {
                    return Ok(());
                }
                for _ in 0..self.level {
                    for _ in 0..self.best_indent {
                        write!(self.writer, " ")?;
                    }
                }
                Ok(())
            }

            fn emit_node(&mut self, node: &Yaml) -> EmitResult {
                match *node {
                    Yaml::Array(ref v) => self.emit_array(v),
                    Yaml::Hash(ref h) => self.emit_hash(h),
                    Yaml::String(ref v) => {
                        if need_quotes(v) {
                            escape_str(self.writer, v)?;
                        } else {
                            write!(self.writer, "{}", v)?;
                        }
                        Ok(())
                    }
                    Yaml::Boolean(v) => {
                        if v {
                            self.writer.write_str("true")?;
                        } else {
                            self.writer.write_str("false")?;
                        }
                        Ok(())
                    }
                    Yaml::Integer(v) => {
                        write!(self.writer, "{}", v)?;
                        Ok(())
                    }
                    Yaml::Real(ref v) => {
                        write!(self.writer, "{}", v)?;
                        Ok(())
                    }
                    Yaml::Null | Yaml::BadValue => {
                        write!(self.writer, "~")?;
                        Ok(())
                    }
                    // XXX(chenyh) Alias
                    _ => Ok(()),
                }
            }

            fn emit_array(&mut self, v: &[Yaml]) -> EmitResult {
                if v.is_empty() {
                    write!(self.writer, "[]")?;
                } else {
                    self.level += 1;
                    for (cnt, x) in v.iter().enumerate() {
                        if cnt > 0 {
                            writeln!(self.writer)?;
                            self.write_indent()?;
                        }
                        write!(self.writer, "-")?;
                        self.emit_val(true, x)?;
                    }
                    self.level -= 1;
                }
                Ok(())
            }

            fn emit_hash(&mut self, h: &Hash) -> EmitResult {
                if h.is_empty() {
                    self.writer.write_str("{}")?;
                } else {
                    self.level += 1;
                    for (cnt, (k, v)) in h.iter().enumerate() {
                        let complex_key = match *k {
                            Yaml::Hash(_) | Yaml::Array(_) => true,
                            _ => false,
                        };
                        if cnt > 0 {
                            writeln!(self.writer)?;
                            self.write_indent()?;
                        }
                        if complex_key {
                            write!(self.writer, "?")?;
                            self.emit_val(true, k)?;
                            writeln!(self.writer)?;
                            self.write_indent()?;
                            write!(self.writer, ":")?;
                            self.emit_val(true, v)?;
                        } else {
                            self.emit_node(k)?;
                            write!(self.writer, ":")?;
                            self.emit_val(false, v)?;
                        }
                    }
                    self.level -= 1;
                }
                Ok(())
            }
            /// Emit a yaml as a hash or array value: i.e., which should appear
            /// following a ":" or "-", either after a space, or on a new line.
            /// If `inline` is true, then the preceding characters are distinct
            /// and short enough to respect the compact flag.
            fn emit_val(&mut self, inline: bool, val: &Yaml) -> EmitResult {
                match *val {
                    Yaml::Array(ref v) => {
                        if (inline && self.compact) || v.is_empty() {
                            write!(self.writer, " ")?;
                        } else {
                            writeln!(self.writer)?;
                            self.level += 1;
                            self.write_indent()?;
                            self.level -= 1;
                        }
                        self.emit_array(v)
                    }
                    Yaml::Hash(ref h) => {
                        if (inline && self.compact) || h.is_empty() {
                            write!(self.writer, " ")?;
                        } else {
                            writeln!(self.writer)?;
                            self.level += 1;
                            self.write_indent()?;
                            self.level -= 1;
                        }
                        self.emit_hash(h)
                    }
                    _ => {
                        write!(self.writer, " ")?;
                        self.emit_node(val)
                    }
                }
            }
        }
        /// Check if the string requires quoting.
        pub fn need_quotes(string: &str) -> bool
        {
            fn need_quotes_spaces(string: &str) -> bool {
                string.starts_with(' ') || string.ends_with(' ')
            }

            string == ""
                || need_quotes_spaces(string)
                || string.starts_with(|character: char| match character {
                    '&' | '*' | '?' | '|' | '-' | '<' | '>' | '=' | '!' | '%' | '@' => true,
                    _ => false,
                })
                || string.contains(|character: char| match character {
                    ':'
                    | '{'
                    | '}'
                    | '['
                    | ']'
                    | ','
                    | '#'
                    | '`'
                    | '\"'
                    | '\''
                    | '\\'
                    | '\0'..='\x06'
                    | '\t'
                    | '\n'
                    | '\r'
                    | '\x0e'..='\x1a'
                    | '\x1c'..='\x1f' => true,
                    _ => false,
                })
                || [
                    // http://yaml.org/type/bool.html
                    // Note: 'y', 'Y', 'n', 'N', is not quoted deliberately, as in libyaml. PyYAML also parse
                    // them as string, not booleans, although it is violating the YAML 1.1 specification.
                    // See https://github.com/dtolnay/serde-yaml/pull/83#discussion_r152628088.
                    "yes", "Yes", "YES", "no", "No", "NO", "True", "TRUE", "true", "False", "FALSE",
                    "false", "on", "On", "ON", "off", "Off", "OFF",
                    // http://yaml.org/type/null.html
                    "null", "Null", "NULL", "~",
                ]
                .contains(&string)
                || string.starts_with('.')
                || string.starts_with("0x")
                || string.parse::<i64>().is_ok()
                || string.parse::<f64>().is_ok()
        }
    } pub use self::emitter::{ EmitError, YamlEmitter };

    pub mod parser
    {
        use ::
        {
            collections::{ HashMap },
            *,
        };

        use super::scanner::*;

        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        enum State {
            StreamStart,
            ImplicitDocumentStart,
            DocumentStart,
            DocumentContent,
            DocumentEnd,
            BlockNode,
            // BlockNodeOrIndentlessSequence,
            // FlowNode,
            BlockSequenceFirstEntry,
            BlockSequenceEntry,
            IndentlessSequenceEntry,
            BlockMappingFirstKey,
            BlockMappingKey,
            BlockMappingValue,
            FlowSequenceFirstEntry,
            FlowSequenceEntry,
            FlowSequenceEntryMappingKey,
            FlowSequenceEntryMappingValue,
            FlowSequenceEntryMappingEnd,
            FlowMappingFirstKey,
            FlowMappingKey,
            FlowMappingValue,
            FlowMappingEmptyValue,
            End,
        }
        /// `Event` is used with the low-level event base parsing API,
        /// see `EventReceiver` trait.
        #[derive(Clone, PartialEq, Debug, Eq)]
        pub enum Event {
            /// Reserved for internal use
            Nothing,
            StreamStart,
            StreamEnd,
            DocumentStart,
            DocumentEnd,
            /// Refer to an anchor ID
            Alias(usize),
            /// Value, style, anchor_id, tag
            Scalar(String, TScalarStyle, usize, Option<TokenType>),
            /// Anchor ID
            SequenceStart(usize),
            SequenceEnd,
            /// Anchor ID
            MappingStart(usize),
            MappingEnd,
        }

        impl Event {
            fn empty_scalar() -> Event {
                // a null scalar
                Event::Scalar("~".to_owned(), TScalarStyle::Plain, 0, None)
            }

            fn empty_scalar_with_anchor(anchor: usize, tag: Option<TokenType>) -> Event {
                Event::Scalar("".to_owned(), TScalarStyle::Plain, anchor, tag)
            }
        }

        #[derive(Debug)]
        pub struct Parser<T> {
            scanner: Scanner<T>,
            states: Vec<State>,
            state: State,
            marks: Vec<Marker>,
            token: Option<Token>,
            current: Option<(Event, Marker)>,
            anchors: HashMap<String, usize>,
            anchor_id: usize,
        }

        pub trait EventReceiver {
            fn on_event(&mut self, ev: Event);
        }

        pub trait MarkedEventReceiver {
            fn on_event(&mut self, ev: Event, _mark: Marker);
        }

        impl<R: EventReceiver> MarkedEventReceiver for R {
            fn on_event(&mut self, ev: Event, _mark: Marker) {
                self.on_event(ev)
            }
        }

        pub type ParseResult = Result<(Event, Marker), ScanError>;

        impl<T: Iterator<Item = char>> Parser<T> {
            pub fn new(src: T) -> Parser<T> {
                Parser {
                    scanner: Scanner::new(src),
                    states: Vec::new(),
                    state: State::StreamStart,
                    marks: Vec::new(),
                    token: None,
                    current: None,

                    anchors: HashMap::new(),
                    // valid anchor_id starts from 1
                    anchor_id: 1,
                }
            }

            pub fn peek(&mut self) -> Result<&(Event, Marker), ScanError> {
                match self.current {
                    Some(ref x) => Ok(x),
                    None => {
                        self.current = Some(self.next()?);
                        self.peek()
                    }
                }
            }

            pub fn next(&mut self) -> ParseResult {
                match self.current {
                    None => self.parse(),
                    Some(_) => Ok(self.current.take().unwrap()),
                }
            }

            fn peek_token(&mut self) -> Result<&Token, ScanError> {
                match self.token {
                    None => {
                        self.token = Some(self.scan_next_token()?);
                        Ok(self.token.as_ref().unwrap())
                    }
                    Some(ref tok) => Ok(tok),
                }
            }

            fn scan_next_token(&mut self) -> Result<Token, ScanError> {
                let token = self.scanner.next();
                match token {
                    None => match self.scanner.get_error() {
                        None => Err(ScanError::new(self.scanner.mark(), "unexpected eof")),
                        Some(e) => Err(e),
                    },
                    Some(tok) => Ok(tok),
                }
            }

            fn fetch_token(&mut self) -> Token {
                self.token
                    .take()
                    .expect("fetch_token needs to be preceded by peek_token")
            }

            fn skip(&mut self) {
                self.token = None;
                //self.peek_token();
            }
            fn pop_state(&mut self) {
                self.state = self.states.pop().unwrap()
            }
            fn push_state(&mut self, state: State) {
                self.states.push(state);
            }

            fn parse(&mut self) -> ParseResult {
                if self.state == State::End {
                    return Ok((Event::StreamEnd, self.scanner.mark()));
                }
                let (ev, mark) = self.state_machine()?;
                // println!("EV {:?}", ev);
                Ok((ev, mark))
            }

            pub fn load<R: MarkedEventReceiver>(
                &mut self,
                recv: &mut R,
                multi: bool,
            ) -> Result<(), ScanError> {
                if !self.scanner.stream_started() {
                    let (ev, mark) = self.next()?;
                    assert_eq!(ev, Event::StreamStart);
                    recv.on_event(ev, mark);
                }

                if self.scanner.stream_ended() {
                    // XXX has parsed?
                    recv.on_event(Event::StreamEnd, self.scanner.mark());
                    return Ok(());
                }
                loop {
                    let (ev, mark) = self.next()?;
                    if ev == Event::StreamEnd {
                        recv.on_event(ev, mark);
                        return Ok(());
                    }
                    // clear anchors before a new document
                    self.anchors.clear();
                    self.load_document(ev, mark, recv)?;
                    if !multi {
                        break;
                    }
                }
                Ok(())
            }

            fn load_document<R: MarkedEventReceiver>(
                &mut self,
                first_ev: Event,
                mark: Marker,
                recv: &mut R,
            ) -> Result<(), ScanError> {
                assert_eq!(first_ev, Event::DocumentStart);
                recv.on_event(first_ev, mark);

                let (ev, mark) = self.next()?;
                self.load_node(ev, mark, recv)?;

                // DOCUMENT-END is expected.
                let (ev, mark) = self.next()?;
                assert_eq!(ev, Event::DocumentEnd);
                recv.on_event(ev, mark);

                Ok(())
            }

            fn load_node<R: MarkedEventReceiver>(
                &mut self,
                first_ev: Event,
                mark: Marker,
                recv: &mut R,
            ) -> Result<(), ScanError> {
                match first_ev {
                    Event::Alias(..) | Event::Scalar(..) => {
                        recv.on_event(first_ev, mark);
                        Ok(())
                    }
                    Event::SequenceStart(_) => {
                        recv.on_event(first_ev, mark);
                        self.load_sequence(recv)
                    }
                    Event::MappingStart(_) => {
                        recv.on_event(first_ev, mark);
                        self.load_mapping(recv)
                    }
                    _ => {
                        println!("UNREACHABLE EVENT: {:?}", first_ev);
                        unreachable!();
                    }
                }
            }

            fn load_mapping<R: MarkedEventReceiver>(&mut self, recv: &mut R) -> Result<(), ScanError> {
                let (mut key_ev, mut key_mark) = self.next()?;
                while key_ev != Event::MappingEnd {
                    // key
                    self.load_node(key_ev, key_mark, recv)?;

                    // value
                    let (ev, mark) = self.next()?;
                    self.load_node(ev, mark, recv)?;

                    // next event
                    let (ev, mark) = self.next()?;
                    key_ev = ev;
                    key_mark = mark;
                }
                recv.on_event(key_ev, key_mark);
                Ok(())
            }

            fn load_sequence<R: MarkedEventReceiver>(&mut self, recv: &mut R) -> Result<(), ScanError> {
                let (mut ev, mut mark) = self.next()?;
                while ev != Event::SequenceEnd {
                    self.load_node(ev, mark, recv)?;

                    // next event
                    let (next_ev, next_mark) = self.next()?;
                    ev = next_ev;
                    mark = next_mark;
                }
                recv.on_event(ev, mark);
                Ok(())
            }

            fn state_machine(&mut self) -> ParseResult {
                // let next_tok = self.peek_token()?;
                // println!("cur_state {:?}, next tok: {:?}", self.state, next_tok);
                match self.state {
                    State::StreamStart => self.stream_start(),

                    State::ImplicitDocumentStart => self.document_start(true),
                    State::DocumentStart => self.document_start(false),
                    State::DocumentContent => self.document_content(),
                    State::DocumentEnd => self.document_end(),

                    State::BlockNode => self.parse_node(true, false),
                    // State::BlockNodeOrIndentlessSequence => self.parse_node(true, true),
                    // State::FlowNode => self.parse_node(false, false),
                    State::BlockMappingFirstKey => self.block_mapping_key(true),
                    State::BlockMappingKey => self.block_mapping_key(false),
                    State::BlockMappingValue => self.block_mapping_value(),

                    State::BlockSequenceFirstEntry => self.block_sequence_entry(true),
                    State::BlockSequenceEntry => self.block_sequence_entry(false),

                    State::FlowSequenceFirstEntry => self.flow_sequence_entry(true),
                    State::FlowSequenceEntry => self.flow_sequence_entry(false),

                    State::FlowMappingFirstKey => self.flow_mapping_key(true),
                    State::FlowMappingKey => self.flow_mapping_key(false),
                    State::FlowMappingValue => self.flow_mapping_value(false),

                    State::IndentlessSequenceEntry => self.indentless_sequence_entry(),

                    State::FlowSequenceEntryMappingKey => self.flow_sequence_entry_mapping_key(),
                    State::FlowSequenceEntryMappingValue => self.flow_sequence_entry_mapping_value(),
                    State::FlowSequenceEntryMappingEnd => self.flow_sequence_entry_mapping_end(),
                    State::FlowMappingEmptyValue => self.flow_mapping_value(true),

                    /* impossible */
                    State::End => unreachable!(),
                }
            }

            fn stream_start(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(mark, TokenType::StreamStart(_)) => {
                        self.state = State::ImplicitDocumentStart;
                        self.skip();
                        Ok((Event::StreamStart, mark))
                    }
                    Token(mark, _) => Err(ScanError::new(mark, "did not find expected <stream-start>")),
                }
            }

            fn document_start(&mut self, implicit: bool) -> ParseResult {
                if !implicit {
                    while let TokenType::DocumentEnd = self.peek_token()?.1 {
                        self.skip();
                    }
                }

                match *self.peek_token()? {
                    Token(mark, TokenType::StreamEnd) => {
                        self.state = State::End;
                        self.skip();
                        Ok((Event::StreamEnd, mark))
                    }
                    Token(_, TokenType::VersionDirective(..))
                    | Token(_, TokenType::TagDirective(..))
                    | Token(_, TokenType::DocumentStart) => {
                        // explicit document
                        self._explicit_document_start()
                    }
                    Token(mark, _) if implicit => {
                        self.parser_process_directives()?;
                        self.push_state(State::DocumentEnd);
                        self.state = State::BlockNode;
                        Ok((Event::DocumentStart, mark))
                    }
                    _ => {
                        // explicit document
                        self._explicit_document_start()
                    }
                }
            }

            fn parser_process_directives(&mut self) -> Result<(), ScanError> {
                loop {
                    match self.peek_token()?.1 {
                        TokenType::VersionDirective(_, _) => {
                            // XXX parsing with warning according to spec
                            //if major != 1 || minor > 2 {
                            //    return Err(ScanError::new(tok.0,
                            //        "found incompatible YAML document"));
                            //}
                        }
                        TokenType::TagDirective(..) => {
                            // TODO add tag directive
                        }
                        _ => break,
                    }
                    self.skip();
                }
                // TODO tag directive
                Ok(())
            }

            fn _explicit_document_start(&mut self) -> ParseResult {
                self.parser_process_directives()?;
                match *self.peek_token()? {
                    Token(mark, TokenType::DocumentStart) => {
                        self.push_state(State::DocumentEnd);
                        self.state = State::DocumentContent;
                        self.skip();
                        Ok((Event::DocumentStart, mark))
                    }
                    Token(mark, _) => Err(ScanError::new(
                        mark,
                        "did not find expected <document start>",
                    )),
                }
            }

            fn document_content(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(mark, TokenType::VersionDirective(..))
                    | Token(mark, TokenType::TagDirective(..))
                    | Token(mark, TokenType::DocumentStart)
                    | Token(mark, TokenType::DocumentEnd)
                    | Token(mark, TokenType::StreamEnd) => {
                        self.pop_state();
                        // empty scalar
                        Ok((Event::empty_scalar(), mark))
                    }
                    _ => self.parse_node(true, false),
                }
            }

            fn document_end(&mut self) -> ParseResult {
                let mut _implicit = true;
                let marker: Marker = match *self.peek_token()? {
                    Token(mark, TokenType::DocumentEnd) => {
                        self.skip();
                        _implicit = false;
                        mark
                    }
                    Token(mark, _) => mark,
                };

                // TODO tag handling
                self.state = State::DocumentStart;
                Ok((Event::DocumentEnd, marker))
            }

            fn register_anchor(&mut self, name: String, _: &Marker) -> Result<usize, ScanError> {
                // anchors can be overridden/reused
                // if self.anchors.contains_key(name) {
                //     return Err(ScanError::new(*mark,
                //         "while parsing anchor, found duplicated anchor"));
                // }
                let new_id = self.anchor_id;
                self.anchor_id += 1;
                self.anchors.insert(name, new_id);
                Ok(new_id)
            }

            fn parse_node(&mut self, block: bool, indentless_sequence: bool) -> ParseResult {
                let mut anchor_id = 0;
                let mut tag = None;
                match *self.peek_token()? {
                    Token(_, TokenType::Alias(_)) => {
                        self.pop_state();
                        if let Token(mark, TokenType::Alias(name)) = self.fetch_token() {
                            match self.anchors.get(&name) {
                                None => {
                                    return Err(ScanError::new(
                                        mark,
                                        "while parsing node, found unknown anchor",
                                    ))
                                }
                                Some(id) => return Ok((Event::Alias(*id), mark)),
                            }
                        } else {
                            unreachable!()
                        }
                    }
                    Token(_, TokenType::Anchor(_)) => {
                        if let Token(mark, TokenType::Anchor(name)) = self.fetch_token() {
                            anchor_id = self.register_anchor(name, &mark)?;
                            if let TokenType::Tag(..) = self.peek_token()?.1 {
                                if let tg @ TokenType::Tag(..) = self.fetch_token().1 {
                                    tag = Some(tg);
                                } else {
                                    unreachable!()
                                }
                            }
                        } else {
                            unreachable!()
                        }
                    }
                    Token(_, TokenType::Tag(..)) => {
                        if let tg @ TokenType::Tag(..) = self.fetch_token().1 {
                            tag = Some(tg);
                            if let TokenType::Anchor(_) = self.peek_token()?.1 {
                                if let Token(mark, TokenType::Anchor(name)) = self.fetch_token() {
                                    anchor_id = self.register_anchor(name, &mark)?;
                                } else {
                                    unreachable!()
                                }
                            }
                        } else {
                            unreachable!()
                        }
                    }
                    _ => {}
                }
                match *self.peek_token()? {
                    Token(mark, TokenType::BlockEntry) if indentless_sequence => {
                        self.state = State::IndentlessSequenceEntry;
                        Ok((Event::SequenceStart(anchor_id), mark))
                    }
                    Token(_, TokenType::Scalar(..)) => {
                        self.pop_state();
                        if let Token(mark, TokenType::Scalar(style, v)) = self.fetch_token() {
                            Ok((Event::Scalar(v, style, anchor_id, tag), mark))
                        } else {
                            unreachable!()
                        }
                    }
                    Token(mark, TokenType::FlowSequenceStart) => {
                        self.state = State::FlowSequenceFirstEntry;
                        Ok((Event::SequenceStart(anchor_id), mark))
                    }
                    Token(mark, TokenType::FlowMappingStart) => {
                        self.state = State::FlowMappingFirstKey;
                        Ok((Event::MappingStart(anchor_id), mark))
                    }
                    Token(mark, TokenType::BlockSequenceStart) if block => {
                        self.state = State::BlockSequenceFirstEntry;
                        Ok((Event::SequenceStart(anchor_id), mark))
                    }
                    Token(mark, TokenType::BlockMappingStart) if block => {
                        self.state = State::BlockMappingFirstKey;
                        Ok((Event::MappingStart(anchor_id), mark))
                    }
                    // ex 7.2, an empty scalar can follow a secondary tag
                    Token(mark, _) if tag.is_some() || anchor_id > 0 => {
                        self.pop_state();
                        Ok((Event::empty_scalar_with_anchor(anchor_id, tag), mark))
                    }
                    Token(mark, _) => Err(ScanError::new(
                        mark,
                        "while parsing a node, did not find expected node content",
                    )),
                }
            }

            fn block_mapping_key(&mut self, first: bool) -> ParseResult {
                // skip BlockMappingStart
                if first {
                    let _ = self.peek_token()?;
                    //self.marks.push(tok.0);
                    self.skip();
                }
                match *self.peek_token()? {
                    Token(_, TokenType::Key) => {
                        self.skip();
                        match *self.peek_token()? {
                            Token(mark, TokenType::Key)
                            | Token(mark, TokenType::Value)
                            | Token(mark, TokenType::BlockEnd) => {
                                self.state = State::BlockMappingValue;
                                // empty scalar
                                Ok((Event::empty_scalar(), mark))
                            }
                            _ => {
                                self.push_state(State::BlockMappingValue);
                                self.parse_node(true, true)
                            }
                        }
                    }
                    // XXX(chenyh): libyaml failed to parse spec 1.2, ex8.18
                    Token(mark, TokenType::Value) => {
                        self.state = State::BlockMappingValue;
                        Ok((Event::empty_scalar(), mark))
                    }
                    Token(mark, TokenType::BlockEnd) => {
                        self.pop_state();
                        self.skip();
                        Ok((Event::MappingEnd, mark))
                    }
                    Token(mark, _) => Err(ScanError::new(
                        mark,
                        "while parsing a block mapping, did not find expected key",
                    )),
                }
            }

            fn block_mapping_value(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(_, TokenType::Value) => {
                        self.skip();
                        match *self.peek_token()? {
                            Token(mark, TokenType::Key)
                            | Token(mark, TokenType::Value)
                            | Token(mark, TokenType::BlockEnd) => {
                                self.state = State::BlockMappingKey;
                                // empty scalar
                                Ok((Event::empty_scalar(), mark))
                            }
                            _ => {
                                self.push_state(State::BlockMappingKey);
                                self.parse_node(true, true)
                            }
                        }
                    }
                    Token(mark, _) => {
                        self.state = State::BlockMappingKey;
                        // empty scalar
                        Ok((Event::empty_scalar(), mark))
                    }
                }
            }

            fn flow_mapping_key(&mut self, first: bool) -> ParseResult {
                if first {
                    let _ = self.peek_token()?;
                    self.skip();
                }
                let marker: Marker =
                    {
                        match *self.peek_token()? {
                            Token(mark, TokenType::FlowMappingEnd) => mark,
                            Token(mark, _) => {
                                if !first {
                                    match *self.peek_token()? {
                                    Token(_, TokenType::FlowEntry) => self.skip(),
                                    Token(mark, _) => return Err(ScanError::new(mark,
                                        "while parsing a flow mapping, did not find expected ',' or '}'"))
                                }
                                }

                                match *self.peek_token()? {
                                    Token(_, TokenType::Key) => {
                                        self.skip();
                                        match *self.peek_token()? {
                                            Token(mark, TokenType::Value)
                                            | Token(mark, TokenType::FlowEntry)
                                            | Token(mark, TokenType::FlowMappingEnd) => {
                                                self.state = State::FlowMappingValue;
                                                return Ok((Event::empty_scalar(), mark));
                                            }
                                            _ => {
                                                self.push_state(State::FlowMappingValue);
                                                return self.parse_node(false, false);
                                            }
                                        }
                                    }
                                    Token(marker, TokenType::Value) => {
                                        self.state = State::FlowMappingValue;
                                        return Ok((Event::empty_scalar(), marker));
                                    }
                                    Token(_, TokenType::FlowMappingEnd) => (),
                                    _ => {
                                        self.push_state(State::FlowMappingEmptyValue);
                                        return self.parse_node(false, false);
                                    }
                                }

                                mark
                            }
                        }
                    };

                self.pop_state();
                self.skip();
                Ok((Event::MappingEnd, marker))
            }

            fn flow_mapping_value(&mut self, empty: bool) -> ParseResult {
                let mark: Marker = {
                    if empty {
                        let Token(mark, _) = *self.peek_token()?;
                        self.state = State::FlowMappingKey;
                        return Ok((Event::empty_scalar(), mark));
                    } else {
                        match *self.peek_token()? {
                            Token(marker, TokenType::Value) => {
                                self.skip();
                                match self.peek_token()?.1 {
                                    TokenType::FlowEntry | TokenType::FlowMappingEnd => {}
                                    _ => {
                                        self.push_state(State::FlowMappingKey);
                                        return self.parse_node(false, false);
                                    }
                                }
                                marker
                            }
                            Token(marker, _) => marker,
                        }
                    }
                };

                self.state = State::FlowMappingKey;
                Ok((Event::empty_scalar(), mark))
            }

            fn flow_sequence_entry(&mut self, first: bool) -> ParseResult {
                // skip FlowMappingStart
                if first {
                    let _ = self.peek_token()?;
                    //self.marks.push(tok.0);
                    self.skip();
                }
                match *self.peek_token()? {
                    Token(mark, TokenType::FlowSequenceEnd) => {
                        self.pop_state();
                        self.skip();
                        return Ok((Event::SequenceEnd, mark));
                    }
                    Token(_, TokenType::FlowEntry) if !first => {
                        self.skip();
                    }
                    Token(mark, _) if !first => {
                        return Err(ScanError::new(
                            mark,
                            "while parsing a flow sequence, expected ',' or ']'",
                        ));
                    }
                    _ => { /* next */ }
                }
                match *self.peek_token()? {
                    Token(mark, TokenType::FlowSequenceEnd) => {
                        self.pop_state();
                        self.skip();
                        Ok((Event::SequenceEnd, mark))
                    }
                    Token(mark, TokenType::Key) => {
                        self.state = State::FlowSequenceEntryMappingKey;
                        self.skip();
                        Ok((Event::MappingStart(0), mark))
                    }
                    _ => {
                        self.push_state(State::FlowSequenceEntry);
                        self.parse_node(false, false)
                    }
                }
            }

            fn indentless_sequence_entry(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(_, TokenType::BlockEntry) => (),
                    Token(mark, _) => {
                        self.pop_state();
                        return Ok((Event::SequenceEnd, mark));
                    }
                }
                self.skip();
                match *self.peek_token()? {
                    Token(mark, TokenType::BlockEntry)
                    | Token(mark, TokenType::Key)
                    | Token(mark, TokenType::Value)
                    | Token(mark, TokenType::BlockEnd) => {
                        self.state = State::IndentlessSequenceEntry;
                        Ok((Event::empty_scalar(), mark))
                    }
                    _ => {
                        self.push_state(State::IndentlessSequenceEntry);
                        self.parse_node(true, false)
                    }
                }
            }

            fn block_sequence_entry(&mut self, first: bool) -> ParseResult {
                // BLOCK-SEQUENCE-START
                if first {
                    let _ = self.peek_token()?;
                    //self.marks.push(tok.0);
                    self.skip();
                }
                match *self.peek_token()? {
                    Token(mark, TokenType::BlockEnd) => {
                        self.pop_state();
                        self.skip();
                        Ok((Event::SequenceEnd, mark))
                    }
                    Token(_, TokenType::BlockEntry) => {
                        self.skip();
                        match *self.peek_token()? {
                            Token(mark, TokenType::BlockEntry) | Token(mark, TokenType::BlockEnd) => {
                                self.state = State::BlockSequenceEntry;
                                Ok((Event::empty_scalar(), mark))
                            }
                            _ => {
                                self.push_state(State::BlockSequenceEntry);
                                self.parse_node(true, false)
                            }
                        }
                    }
                    Token(mark, _) => Err(ScanError::new(
                        mark,
                        "while parsing a block collection, did not find expected '-' indicator",
                    )),
                }
            }

            fn flow_sequence_entry_mapping_key(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(mark, TokenType::Value)
                    | Token(mark, TokenType::FlowEntry)
                    | Token(mark, TokenType::FlowSequenceEnd) => {
                        self.skip();
                        self.state = State::FlowSequenceEntryMappingValue;
                        Ok((Event::empty_scalar(), mark))
                    }
                    _ => {
                        self.push_state(State::FlowSequenceEntryMappingValue);
                        self.parse_node(false, false)
                    }
                }
            }

            fn flow_sequence_entry_mapping_value(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(_, TokenType::Value) => {
                        self.skip();
                        self.state = State::FlowSequenceEntryMappingValue;
                        match *self.peek_token()? {
                            Token(mark, TokenType::FlowEntry) | Token(mark, TokenType::FlowSequenceEnd) => {
                                self.state = State::FlowSequenceEntryMappingEnd;
                                Ok((Event::empty_scalar(), mark))
                            }
                            _ => {
                                self.push_state(State::FlowSequenceEntryMappingEnd);
                                self.parse_node(false, false)
                            }
                        }
                    }
                    Token(mark, _) => {
                        self.state = State::FlowSequenceEntryMappingEnd;
                        Ok((Event::empty_scalar(), mark))
                    }
                }
            }

            fn flow_sequence_entry_mapping_end(&mut self) -> ParseResult {
                self.state = State::FlowSequenceEntry;
                Ok((Event::MappingEnd, self.scanner.mark()))
            }
        }
    } pub use self::parser::{ Event };

    pub mod scanner
    {
        use ::
        {
            collections::{ VecDeque },
            error::{ Error },
            *,
        };

        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        pub enum TEncoding {
            Utf8,
        }

        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        pub enum TScalarStyle {
            Any,
            Plain,
            SingleQuoted,
            DoubleQuoted,

            Literal,
            Foled,
        }

        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        pub struct Marker {
            index: usize,
            line: usize,
            col: usize,
        }

        impl Marker {
            fn new(index: usize, line: usize, col: usize) -> Marker {
                Marker { index, line, col }
            }

            pub fn index(&self) -> usize {
                self.index
            }

            pub fn line(&self) -> usize {
                self.line
            }

            pub fn col(&self) -> usize {
                self.col
            }
        }

        #[derive(Clone, PartialEq, Debug, Eq)]
        pub struct ScanError {
            mark: Marker,
            info: String,
        }

        impl ScanError {
            pub fn new(loc: Marker, info: &str) -> ScanError {
                ScanError {
                    mark: loc,
                    info: info.to_owned(),
                }
            }

            pub fn marker(&self) -> &Marker {
                &self.mark
            }
        }

        impl Error for ScanError {
            fn description(&self) -> &str {
                self.info.as_ref()
            }

            fn cause(&self) -> Option<&dyn Error> {
                None
            }
        }

        impl fmt::Display for ScanError {
            // col starts from 0
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                write!(
                    formatter,
                    "{} at line {} column {}",
                    self.info,
                    self.mark.line,
                    self.mark.col + 1
                )
            }
        }

        #[derive(Clone, PartialEq, Debug, Eq)]
        pub enum TokenType {
            NoToken,
            StreamStart(TEncoding),
            StreamEnd,
            /// major, minor
            VersionDirective(u32, u32),
            /// handle, prefix
            TagDirective(String, String),
            DocumentStart,
            DocumentEnd,
            BlockSequenceStart,
            BlockMappingStart,
            BlockEnd,
            FlowSequenceStart,
            FlowSequenceEnd,
            FlowMappingStart,
            FlowMappingEnd,
            BlockEntry,
            FlowEntry,
            Key,
            Value,
            Alias(String),
            Anchor(String),
            /// handle, suffix
            Tag(String, String),
            Scalar(TScalarStyle, String),
        }

        #[derive(Clone, PartialEq, Debug, Eq)]
        pub struct Token(pub Marker, pub TokenType);

        #[derive(Clone, PartialEq, Debug, Eq)]
        struct SimpleKey {
            possible: bool,
            required: bool,
            token_number: usize,
            mark: Marker,
        }

        impl SimpleKey {
            fn new(mark: Marker) -> SimpleKey {
                SimpleKey {
                    possible: false,
                    required: false,
                    token_number: 0,
                    mark,
                }
            }
        }

        #[derive(Debug)]
        pub struct Scanner<T> {
            rdr: T,
            mark: Marker,
            tokens: VecDeque<Token>,
            buffer: VecDeque<char>,
            error: Option<ScanError>,

            stream_start_produced: bool,
            stream_end_produced: bool,
            adjacent_value_allowed_at: usize,
            simple_key_allowed: bool,
            simple_keys: Vec<SimpleKey>,
            indent: isize,
            indents: Vec<isize>,
            flow_level: u8,
            tokens_parsed: usize,
            token_available: bool,
        }

        impl<T: Iterator<Item = char>> Iterator for Scanner<T> {
            type Item = Token;
            fn next(&mut self) -> Option<Token> {
                if self.error.is_some() {
                    return None;
                }
                match self.next_token() {
                    Ok(tok) => tok,
                    Err(e) => {
                        self.error = Some(e);
                        None
                    }
                }
            }
        }

        #[inline]
        fn is_z(c: char) -> bool {
            c == '\0'
        }
        #[inline]
        fn is_break(c: char) -> bool {
            c == '\n' || c == '\r'
        }
        #[inline]
        fn is_breakz(c: char) -> bool {
            is_break(c) || is_z(c)
        }
        #[inline]
        fn is_blank(c: char) -> bool {
            c == ' ' || c == '\t'
        }
        #[inline]
        fn is_blankz(c: char) -> bool {
            is_blank(c) || is_breakz(c)
        }
        #[inline]
        fn is_digit(c: char) -> bool {
            c >= '0' && c <= '9'
        }
        #[inline]
        fn is_alpha(c: char) -> bool {
            match c {
                '0'..='9' | 'a'..='z' | 'A'..='Z' => true,
                '_' | '-' => true,
                _ => false,
            }
        }
        #[inline]
        fn is_hex(c: char) -> bool {
            (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')
        }
        #[inline]
        fn as_hex(c: char) -> u32 {
            match c {
                '0'..='9' => (c as u32) - ('0' as u32),
                'a'..='f' => (c as u32) - ('a' as u32) + 10,
                'A'..='F' => (c as u32) - ('A' as u32) + 10,
                _ => unreachable!(),
            }
        }
        #[inline]
        fn is_flow(c: char) -> bool {
            match c {
                ',' | '[' | ']' | '{' | '}' => true,
                _ => false,
            }
        }

        pub type ScanResult = Result<(), ScanError>;

        impl<T: Iterator<Item = char>> Scanner<T> {
            /// Creates the YAML tokenizer.
            pub fn new(rdr: T) -> Scanner<T> {
                Scanner {
                    rdr,
                    buffer: VecDeque::new(),
                    mark: Marker::new(0, 1, 0),
                    tokens: VecDeque::new(),
                    error: None,

                    stream_start_produced: false,
                    stream_end_produced: false,
                    adjacent_value_allowed_at: 0,
                    simple_key_allowed: true,
                    simple_keys: Vec::new(),
                    indent: -1,
                    indents: Vec::new(),
                    flow_level: 0,
                    tokens_parsed: 0,
                    token_available: false,
                }
            }
            #[inline]
            pub fn get_error(&self) -> Option<ScanError> {
                match self.error {
                    None => None,
                    Some(ref e) => Some(e.clone()),
                }
            }

            #[inline]
            fn lookahead(&mut self, count: usize) {
                if self.buffer.len() >= count {
                    return;
                }
                for _ in 0..(count - self.buffer.len()) {
                    self.buffer.push_back(self.rdr.next().unwrap_or('\0'));
                }
            }
            #[inline]
            fn skip(&mut self) {
                let c = self.buffer.pop_front().unwrap();

                self.mark.index += 1;
                if c == '\n' {
                    self.mark.line += 1;
                    self.mark.col = 0;
                } else {
                    self.mark.col += 1;
                }
            }
            #[inline]
            fn skip_line(&mut self) {
                if self.buffer[0] == '\r' && self.buffer[1] == '\n' {
                    self.skip();
                    self.skip();
                } else if is_break(self.buffer[0]) {
                    self.skip();
                }
            }
            #[inline]
            fn ch(&self) -> char {
                self.buffer[0]
            }
            #[inline]
            fn ch_is(&self, c: char) -> bool {
                self.buffer[0] == c
            }
            
            #[inline]
            fn eof(&self) -> bool {
                self.ch_is('\0')
            }
            #[inline]
            pub fn stream_started(&self) -> bool {
                self.stream_start_produced
            }
            #[inline]
            pub fn stream_ended(&self) -> bool {
                self.stream_end_produced
            }
            #[inline]
            pub fn mark(&self) -> Marker {
                self.mark
            }
            #[inline]
            fn read_break(&mut self, s: &mut String) {
                if self.buffer[0] == '\r' && self.buffer[1] == '\n' {
                    s.push('\n');
                    self.skip();
                    self.skip();
                } else if self.buffer[0] == '\r' || self.buffer[0] == '\n' {
                    s.push('\n');
                    self.skip();
                } else {
                    unreachable!();
                }
            }
            fn insert_token(&mut self, pos: usize, tok: Token) {
                let old_len = self.tokens.len();
                assert!(pos <= old_len);
                self.tokens.push_back(tok);
                for i in 0..old_len - pos {
                    self.tokens.swap(old_len - i, old_len - i - 1);
                }
            }
            fn allow_simple_key(&mut self) {
                self.simple_key_allowed = true;
            }
            fn disallow_simple_key(&mut self) {
                self.simple_key_allowed = false;
            }

            pub fn fetch_next_token(&mut self) -> ScanResult {
                self.lookahead(1);
                // println!("--> fetch_next_token Cur {:?} {:?}", self.mark, self.ch());

                if !self.stream_start_produced {
                    self.fetch_stream_start();
                    return Ok(());
                }
                self.skip_to_next_token();

                self.stale_simple_keys()?;

                let mark = self.mark;
                self.unroll_indent(mark.col as isize);

                self.lookahead(4);

                if is_z(self.ch()) {
                    self.fetch_stream_end()?;
                    return Ok(());
                }

                // Is it a directive?
                if self.mark.col == 0 && self.ch_is('%') {
                    return self.fetch_directive();
                }

                if self.mark.col == 0
                    && self.buffer[0] == '-'
                    && self.buffer[1] == '-'
                    && self.buffer[2] == '-'
                    && is_blankz(self.buffer[3])
                {
                    self.fetch_document_indicator(TokenType::DocumentStart)?;
                    return Ok(());
                }

                if self.mark.col == 0
                    && self.buffer[0] == '.'
                    && self.buffer[1] == '.'
                    && self.buffer[2] == '.'
                    && is_blankz(self.buffer[3])
                {
                    self.fetch_document_indicator(TokenType::DocumentEnd)?;
                    return Ok(());
                }

                let c = self.buffer[0];
                let nc = self.buffer[1];
                match c {
                    '[' => self.fetch_flow_collection_start(TokenType::FlowSequenceStart),
                    '{' => self.fetch_flow_collection_start(TokenType::FlowMappingStart),
                    ']' => self.fetch_flow_collection_end(TokenType::FlowSequenceEnd),
                    '}' => self.fetch_flow_collection_end(TokenType::FlowMappingEnd),
                    ',' => self.fetch_flow_entry(),
                    '-' if is_blankz(nc) => self.fetch_block_entry(),
                    '?' if is_blankz(nc) => self.fetch_key(),
                    ':' if is_blankz(nc)
                        || (self.flow_level > 0
                            && (is_flow(nc) || self.mark.index == self.adjacent_value_allowed_at)) =>
                    {
                        self.fetch_value()
                    }
                    // Is it an alias?
                    '*' => self.fetch_anchor(true),
                    // Is it an anchor?
                    '&' => self.fetch_anchor(false),
                    '!' => self.fetch_tag(),
                    // Is it a literal scalar?
                    '|' if self.flow_level == 0 => self.fetch_block_scalar(true),
                    // Is it a folded scalar?
                    '>' if self.flow_level == 0 => self.fetch_block_scalar(false),
                    '\'' => self.fetch_flow_scalar(true),
                    '"' => self.fetch_flow_scalar(false),
                    // plain scalar
                    '-' if !is_blankz(nc) => self.fetch_plain_scalar(),
                    ':' | '?' if !is_blankz(nc) && self.flow_level == 0 => self.fetch_plain_scalar(),
                    '%' | '@' | '`' => Err(ScanError::new(
                        self.mark,
                        &format!("unexpected character: `{}'", c),
                    )),
                    _ => self.fetch_plain_scalar(),
                }
            }

            pub fn next_token(&mut self) -> Result<Option<Token>, ScanError> {
                if self.stream_end_produced {
                    return Ok(None);
                }

                if !self.token_available {
                    self.fetch_more_tokens()?;
                }
                let t = self.tokens.pop_front().unwrap();
                self.token_available = false;
                self.tokens_parsed += 1;

                if let TokenType::StreamEnd = t.1 {
                    self.stream_end_produced = true;
                }
                Ok(Some(t))
            }

            pub fn fetch_more_tokens(&mut self) -> ScanResult {
                let mut need_more;
                loop {
                    need_more = false;
                    if self.tokens.is_empty() {
                        need_more = true;
                    } else {
                        self.stale_simple_keys()?;
                        for sk in &self.simple_keys {
                            if sk.possible && sk.token_number == self.tokens_parsed {
                                need_more = true;
                                break;
                            }
                        }
                    }

                    if !need_more {
                        break;
                    }
                    self.fetch_next_token()?;
                }
                self.token_available = true;

                Ok(())
            }

            fn stale_simple_keys(&mut self) -> ScanResult {
                for sk in &mut self.simple_keys {
                    if sk.possible
                        && (sk.mark.line < self.mark.line || sk.mark.index + 1024 < self.mark.index)
                    {
                        if sk.required {
                            return Err(ScanError::new(self.mark, "simple key expect ':'"));
                        }
                        sk.possible = false;
                    }
                }
                Ok(())
            }

            fn skip_to_next_token(&mut self) {
                loop {
                    self.lookahead(1);
                    // TODO(chenyh) BOM
                    match self.ch() {
                        ' ' => self.skip(),
                        '\t' if self.flow_level > 0 || !self.simple_key_allowed => self.skip(),
                        '\n' | '\r' => {
                            self.lookahead(2);
                            self.skip_line();
                            if self.flow_level == 0 {
                                self.allow_simple_key();
                            }
                        }
                        '#' => {
                            while !is_breakz(self.ch()) {
                                self.skip();
                                self.lookahead(1);
                            }
                        }
                        _ => break,
                    }
                }
            }

            fn fetch_stream_start(&mut self) {
                let mark = self.mark;
                self.indent = -1;
                self.stream_start_produced = true;
                self.allow_simple_key();
                self.tokens
                    .push_back(Token(mark, TokenType::StreamStart(TEncoding::Utf8)));
                self.simple_keys.push(SimpleKey::new(Marker::new(0, 0, 0)));
            }

            fn fetch_stream_end(&mut self) -> ScanResult {
                // force new line
                if self.mark.col != 0 {
                    self.mark.col = 0;
                    self.mark.line += 1;
                }

                self.unroll_indent(-1);
                self.remove_simple_key()?;
                self.disallow_simple_key();

                self.tokens
                    .push_back(Token(self.mark, TokenType::StreamEnd));
                Ok(())
            }

            fn fetch_directive(&mut self) -> ScanResult {
                self.unroll_indent(-1);
                self.remove_simple_key()?;

                self.disallow_simple_key();

                let tok = self.scan_directive()?;

                self.tokens.push_back(tok);

                Ok(())
            }

            fn scan_directive(&mut self) -> Result<Token, ScanError> {
                let start_mark = self.mark;
                self.skip();

                let name = self.scan_directive_name()?;
                let tok = match name.as_ref() {
                    "YAML" => self.scan_version_directive_value(&start_mark)?,
                    "TAG" => self.scan_tag_directive_value(&start_mark)?,
                    // XXX This should be a warning instead of an error
                    _ => {
                        // skip current line
                        self.lookahead(1);
                        while !is_breakz(self.ch()) {
                            self.skip();
                            self.lookahead(1);
                        }
                        // XXX return an empty TagDirective token
                        Token(
                            start_mark,
                            TokenType::TagDirective(String::new(), String::new()),
                        )
                        // return Err(ScanError::new(start_mark,
                        //     "while scanning a directive, found unknown directive name"))
                    }
                };
                self.lookahead(1);

                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }

                if self.ch() == '#' {
                    while !is_breakz(self.ch()) {
                        self.skip();
                        self.lookahead(1);
                    }
                }

                if !is_breakz(self.ch()) {
                    return Err(ScanError::new(
                        start_mark,
                        "while scanning a directive, did not find expected comment or line break",
                    ));
                }

                // Eat a line break
                if is_break(self.ch()) {
                    self.lookahead(2);
                    self.skip_line();
                }

                Ok(tok)
            }

            fn scan_version_directive_value(&mut self, mark: &Marker) -> Result<Token, ScanError> {
                self.lookahead(1);

                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }

                let major = self.scan_version_directive_number(mark)?;

                if self.ch() != '.' {
                    return Err(ScanError::new(
                        *mark,
                        "while scanning a YAML directive, did not find expected digit or '.' character",
                    ));
                }

                self.skip();

                let minor = self.scan_version_directive_number(mark)?;

                Ok(Token(*mark, TokenType::VersionDirective(major, minor)))
            }

            fn scan_directive_name(&mut self) -> Result<String, ScanError> {
                let start_mark = self.mark;
                let mut string = String::new();
                self.lookahead(1);
                while is_alpha(self.ch()) {
                    string.push(self.ch());
                    self.skip();
                    self.lookahead(1);
                }

                if string.is_empty() {
                    return Err(ScanError::new(
                        start_mark,
                        "while scanning a directive, could not find expected directive name",
                    ));
                }

                if !is_blankz(self.ch()) {
                    return Err(ScanError::new(
                        start_mark,
                        "while scanning a directive, found unexpected non-alphabetical character",
                    ));
                }

                Ok(string)
            }

            fn scan_version_directive_number(&mut self, mark: &Marker) -> Result<u32, ScanError> {
                let mut val = 0u32;
                let mut length = 0usize;
                self.lookahead(1);
                while is_digit(self.ch()) {
                    if length + 1 > 9 {
                        return Err(ScanError::new(
                            *mark,
                            "while scanning a YAML directive, found extremely long version number",
                        ));
                    }
                    length += 1;
                    val = val * 10 + ((self.ch() as u32) - ('0' as u32));
                    self.skip();
                    self.lookahead(1);
                }

                if length == 0 {
                    return Err(ScanError::new(
                        *mark,
                        "while scanning a YAML directive, did not find expected version number",
                    ));
                }

                Ok(val)
            }

            fn scan_tag_directive_value(&mut self, mark: &Marker) -> Result<Token, ScanError> {
                self.lookahead(1);
                /* Eat whitespaces. */
                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }
                let handle = self.scan_tag_handle(true, mark)?;

                self.lookahead(1);
                /* Eat whitespaces. */
                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }

                let is_secondary = handle == "!!";
                let prefix = self.scan_tag_uri(true, is_secondary, &String::new(), mark)?;

                self.lookahead(1);

                if is_blankz(self.ch()) {
                    Ok(Token(*mark, TokenType::TagDirective(handle, prefix)))
                } else {
                    Err(ScanError::new(
                        *mark,
                        "while scanning TAG, did not find expected whitespace or line break",
                    ))
                }
            }

            fn fetch_tag(&mut self) -> ScanResult {
                self.save_simple_key()?;
                self.disallow_simple_key();

                let tok = self.scan_tag()?;
                self.tokens.push_back(tok);
                Ok(())
            }

            fn scan_tag(&mut self) -> Result<Token, ScanError> {
                let start_mark = self.mark;
                let mut handle = String::new();
                let mut suffix;
                let mut secondary = false;

                // Check if the tag is in the canonical form (verbatim).
                self.lookahead(2);

                if self.buffer[1] == '<' {
                    // Eat '!<'
                    self.skip();
                    self.skip();
                    suffix = self.scan_tag_uri(false, false, &String::new(), &start_mark)?;

                    if self.ch() != '>' {
                        return Err(ScanError::new(
                            start_mark,
                            "while scanning a tag, did not find the expected '>'",
                        ));
                    }

                    self.skip();
                } else {
                    // The tag has either the '!suffix' or the '!handle!suffix'
                    handle = self.scan_tag_handle(false, &start_mark)?;
                    // Check if it is, indeed, handle.
                    if handle.len() >= 2 && handle.starts_with('!') && handle.ends_with('!') {
                        if handle == "!!" {
                            secondary = true;
                        }
                        suffix = self.scan_tag_uri(false, secondary, &String::new(), &start_mark)?;
                    } else {
                        suffix = self.scan_tag_uri(false, false, &handle, &start_mark)?;
                        handle = "!".to_owned();
                        // A special case: the '!' tag.  Set the handle to '' and the
                        // suffix to '!'.
                        if suffix.is_empty() {
                            handle.clear();
                            suffix = "!".to_owned();
                        }
                    }
                }

                self.lookahead(1);
                if is_blankz(self.ch()) {
                    // XXX: ex 7.2, an empty scalar can follow a secondary tag
                    Ok(Token(start_mark, TokenType::Tag(handle, suffix)))
                } else {
                    Err(ScanError::new(
                        start_mark,
                        "while scanning a tag, did not find expected whitespace or line break",
                    ))
                }
            }

            fn scan_tag_handle(&mut self, directive: bool, mark: &Marker) -> Result<String, ScanError> {
                let mut string = String::new();
                self.lookahead(1);
                if self.ch() != '!' {
                    return Err(ScanError::new(
                        *mark,
                        "while scanning a tag, did not find expected '!'",
                    ));
                }

                string.push(self.ch());
                self.skip();

                self.lookahead(1);
                while is_alpha(self.ch()) {
                    string.push(self.ch());
                    self.skip();
                    self.lookahead(1);
                }

                // Check if the trailing character is '!' and copy it.
                if self.ch() == '!' {
                    string.push(self.ch());
                    self.skip();
                } else if directive && string != "!" {
                    // It's either the '!' tag or not really a tag handle.  If it's a %TAG
                    // directive, it's an error.  If it's a tag token, it must be a part of
                    // URI.
                    return Err(ScanError::new(
                        *mark,
                        "while parsing a tag directive, did not find expected '!'",
                    ));
                }
                Ok(string)
            }

            fn scan_tag_uri(
                &mut self,
                directive: bool,
                _is_secondary: bool,
                head: &str,
                mark: &Marker,
            ) -> Result<String, ScanError> {
                let mut length = head.len();
                let mut string = String::new();

                // Copy the head if needed.
                // Note that we don't copy the leading '!' character.
                if length > 1 {
                    string.extend(head.chars().skip(1));
                }

                self.lookahead(1);
                /*
                * The set of characters that may appear in URI is as follows:
                *
                *      '0'-'9', 'A'-'Z', 'a'-'z', '_', '-', ';', '/', '?', ':', '@', '&',
                *      '=', '+', '$', ',', '.', '!', '~', '*', '\'', '(', ')', '[', ']',
                *      '%'.
                */
                while match self.ch() {
                    ';' | '/' | '?' | ':' | '@' | '&' => true,
                    '=' | '+' | '$' | ',' | '.' | '!' | '~' | '*' | '\'' | '(' | ')' | '[' | ']' => true,
                    '%' => true,
                    c if is_alpha(c) => true,
                    _ => false,
                } {
                    // Check if it is a URI-escape sequence.
                    if self.ch() == '%' {
                        string.push(self.scan_uri_escapes(directive, mark)?);
                    } else {
                        string.push(self.ch());
                        self.skip();
                    }

                    length += 1;
                    self.lookahead(1);
                }

                if length == 0 {
                    return Err(ScanError::new(
                        *mark,
                        "while parsing a tag, did not find expected tag URI",
                    ));
                }

                Ok(string)
            }

            fn scan_uri_escapes(&mut self, _directive: bool, mark: &Marker) -> Result<char, ScanError> {
                let mut width = 0usize;
                let mut code = 0u32;
                loop {
                    self.lookahead(3);

                    if !(self.ch() == '%' && is_hex(self.buffer[1]) && is_hex(self.buffer[2])) {
                        return Err(ScanError::new(
                            *mark,
                            "while parsing a tag, did not find URI escaped octet",
                        ));
                    }

                    let octet = (as_hex(self.buffer[1]) << 4) + as_hex(self.buffer[2]);
                    if width == 0 {
                        width = match octet {
                            _ if octet & 0x80 == 0x00 => 1,
                            _ if octet & 0xE0 == 0xC0 => 2,
                            _ if octet & 0xF0 == 0xE0 => 3,
                            _ if octet & 0xF8 == 0xF0 => 4,
                            _ => {
                                return Err(ScanError::new(
                                    *mark,
                                    "while parsing a tag, found an incorrect leading UTF-8 octet",
                                ));
                            }
                        };
                        code = octet;
                    } else {
                        if octet & 0xc0 != 0x80 {
                            return Err(ScanError::new(
                                *mark,
                                "while parsing a tag, found an incorrect trailing UTF-8 octet",
                            ));
                        }
                        code = (code << 8) + octet;
                    }

                    self.skip();
                    self.skip();
                    self.skip();

                    width -= 1;
                    if width == 0 {
                        break;
                    }
                }

                match char::from_u32(code) {
                    Some(ch) => Ok(ch),
                    None => Err(ScanError::new(
                        *mark,
                        "while parsing a tag, found an invalid UTF-8 codepoint",
                    )),
                }
            }

            fn fetch_anchor(&mut self, alias: bool) -> ScanResult {
                self.save_simple_key()?;
                self.disallow_simple_key();

                let tok = self.scan_anchor(alias)?;

                self.tokens.push_back(tok);

                Ok(())
            }

            fn scan_anchor(&mut self, alias: bool) -> Result<Token, ScanError> {
                let mut string = String::new();
                let start_mark = self.mark;

                self.skip();
                self.lookahead(1);
                while is_alpha(self.ch()) {
                    string.push(self.ch());
                    self.skip();
                    self.lookahead(1);
                }

                if string.is_empty()
                    || match self.ch() {
                        c if is_blankz(c) => false,
                        '?' | ':' | ',' | ']' | '}' | '%' | '@' | '`' => false,
                        _ => true,
                    }
                {
                    return Err(ScanError::new(start_mark, "while scanning an anchor or alias, did not find expected alphabetic or numeric character"));
                }

                if alias {
                    Ok(Token(start_mark, TokenType::Alias(string)))
                } else {
                    Ok(Token(start_mark, TokenType::Anchor(string)))
                }
            }

            fn fetch_flow_collection_start(&mut self, tok: TokenType) -> ScanResult {
                // The indicators '[' and '{' may start a simple key.
                self.save_simple_key()?;

                self.increase_flow_level()?;

                self.allow_simple_key();

                let start_mark = self.mark;
                self.skip();

                self.tokens.push_back(Token(start_mark, tok));
                Ok(())
            }

            fn fetch_flow_collection_end(&mut self, tok: TokenType) -> ScanResult {
                self.remove_simple_key()?;
                self.decrease_flow_level();

                self.disallow_simple_key();

                let start_mark = self.mark;
                self.skip();

                self.tokens.push_back(Token(start_mark, tok));
                Ok(())
            }

            fn fetch_flow_entry(&mut self) -> ScanResult {
                self.remove_simple_key()?;
                self.allow_simple_key();

                let start_mark = self.mark;
                self.skip();

                self.tokens
                    .push_back(Token(start_mark, TokenType::FlowEntry));
                Ok(())
            }

            fn increase_flow_level(&mut self) -> ScanResult {
                self.simple_keys.push(SimpleKey::new(Marker::new(0, 0, 0)));
                self.flow_level = self
                    .flow_level
                    .checked_add(1)
                    .ok_or_else(|| ScanError::new(self.mark, "recursion limit exceeded"))?;
                Ok(())
            }
            fn decrease_flow_level(&mut self) {
                if self.flow_level > 0 {
                    self.flow_level -= 1;
                    self.simple_keys.pop().unwrap();
                }
            }

            fn fetch_block_entry(&mut self) -> ScanResult {
                if self.flow_level == 0 {
                    // Check if we are allowed to start a new entry.
                    if !self.simple_key_allowed {
                        return Err(ScanError::new(
                            self.mark,
                            "block sequence entries are not allowed in this context",
                        ));
                    }

                    let mark = self.mark;
                    // generate BLOCK-SEQUENCE-START if indented
                    self.roll_indent(mark.col, None, TokenType::BlockSequenceStart, mark);
                } else {
                    // - * only allowed in block
                    return Err(ScanError::new(
                        self.mark,
                        r#""-" is only valid inside a block"#,
                    ));
                }
                self.remove_simple_key()?;
                self.allow_simple_key();

                let start_mark = self.mark;
                self.skip();

                self.tokens
                    .push_back(Token(start_mark, TokenType::BlockEntry));
                Ok(())
            }

            fn fetch_document_indicator(&mut self, t: TokenType) -> ScanResult {
                self.unroll_indent(-1);
                self.remove_simple_key()?;
                self.disallow_simple_key();

                let mark = self.mark;

                self.skip();
                self.skip();
                self.skip();

                self.tokens.push_back(Token(mark, t));
                Ok(())
            }

            fn fetch_block_scalar(&mut self, literal: bool) -> ScanResult {
                self.save_simple_key()?;
                self.allow_simple_key();
                let tok = self.scan_block_scalar(literal)?;

                self.tokens.push_back(tok);
                Ok(())
            }

            fn scan_block_scalar(&mut self, literal: bool) -> Result<Token, ScanError> {
                let start_mark = self.mark;
                let mut chomping: i32 = 0;
                let mut increment: usize = 0;
                let mut indent: usize = 0;
                let mut trailing_blank: bool;
                let mut leading_blank: bool = false;

                let mut string = String::new();
                let mut leading_break = String::new();
                let mut trailing_breaks = String::new();

                // skip '|' or '>'
                self.skip();
                self.lookahead(1);

                if self.ch() == '+' || self.ch() == '-' {
                    if self.ch() == '+' {
                        chomping = 1;
                    } else {
                        chomping = -1;
                    }
                    self.skip();
                    self.lookahead(1);
                    if is_digit(self.ch()) {
                        if self.ch() == '0' {
                            return Err(ScanError::new(
                                start_mark,
                                "while scanning a block scalar, found an indentation indicator equal to 0",
                            ));
                        }
                        increment = (self.ch() as usize) - ('0' as usize);
                        self.skip();
                    }
                } else if is_digit(self.ch()) {
                    if self.ch() == '0' {
                        return Err(ScanError::new(
                            start_mark,
                            "while scanning a block scalar, found an indentation indicator equal to 0",
                        ));
                    }

                    increment = (self.ch() as usize) - ('0' as usize);
                    self.skip();
                    self.lookahead(1);
                    if self.ch() == '+' || self.ch() == '-' {
                        if self.ch() == '+' {
                            chomping = 1;
                        } else {
                            chomping = -1;
                        }
                        self.skip();
                    }
                }

                // Eat whitespaces and comments to the end of the line.
                self.lookahead(1);

                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }

                if self.ch() == '#' {
                    while !is_breakz(self.ch()) {
                        self.skip();
                        self.lookahead(1);
                    }
                }

                // Check if we are at the end of the line.
                if !is_breakz(self.ch()) {
                    return Err(ScanError::new(
                        start_mark,
                        "while scanning a block scalar, did not find expected comment or line break",
                    ));
                }

                if is_break(self.ch()) {
                    self.lookahead(2);
                    self.skip_line();
                }

                if increment > 0 {
                    indent = if self.indent >= 0 {
                        (self.indent + increment as isize) as usize
                    } else {
                        increment
                    }
                }
                // Scan the leading line breaks and determine the indentation level if needed.
                self.block_scalar_breaks(&mut indent, &mut trailing_breaks)?;

                self.lookahead(1);

                let start_mark = self.mark;

                while self.mark.col == indent && !is_z(self.ch()) {
                    // We are at the beginning of a non-empty line.
                    trailing_blank = is_blank(self.ch());
                    if !literal && !leading_break.is_empty() && !leading_blank && !trailing_blank {
                        if trailing_breaks.is_empty() {
                            string.push(' ');
                        }
                        leading_break.clear();
                    } else {
                        string.push_str(&leading_break);
                        leading_break.clear();
                    }

                    string.push_str(&trailing_breaks);
                    trailing_breaks.clear();

                    leading_blank = is_blank(self.ch());

                    while !is_breakz(self.ch()) {
                        string.push(self.ch());
                        self.skip();
                        self.lookahead(1);
                    }
                    // break on EOF
                    if is_z(self.ch()) {
                        break;
                    }

                    self.lookahead(2);
                    self.read_break(&mut leading_break);

                    // Eat the following indentation spaces and line breaks.
                    self.block_scalar_breaks(&mut indent, &mut trailing_breaks)?;
                }

                // Chomp the tail.
                if chomping != -1 {
                    string.push_str(&leading_break);
                }

                if chomping == 1 {
                    string.push_str(&trailing_breaks);
                }

                if literal {
                    Ok(Token(
                        start_mark,
                        TokenType::Scalar(TScalarStyle::Literal, string),
                    ))
                } else {
                    Ok(Token(
                        start_mark,
                        TokenType::Scalar(TScalarStyle::Foled, string),
                    ))
                }
            }

            fn block_scalar_breaks(&mut self, indent: &mut usize, breaks: &mut String) -> ScanResult {
                let mut max_indent = 0;
                loop {
                    self.lookahead(1);
                    while (*indent == 0 || self.mark.col < *indent) && self.buffer[0] == ' ' {
                        self.skip();
                        self.lookahead(1);
                    }

                    if self.mark.col > max_indent {
                        max_indent = self.mark.col;
                    }

                    // Check for a tab character messing the indentation.
                    if (*indent == 0 || self.mark.col < *indent) && self.buffer[0] == '\t' {
                        return Err(ScanError::new(self.mark,
                                "while scanning a block scalar, found a tab character where an indentation space is expected"));
                    }

                    if !is_break(self.ch()) {
                        break;
                    }

                    self.lookahead(2);
                    // Consume the line break.
                    self.read_break(breaks);
                }

                if *indent == 0 {
                    *indent = max_indent;
                    if *indent < (self.indent + 1) as usize {
                        *indent = (self.indent + 1) as usize;
                    }
                    if *indent < 1 {
                        *indent = 1;
                    }
                }
                Ok(())
            }

            fn fetch_flow_scalar(&mut self, single: bool) -> ScanResult {
                self.save_simple_key()?;
                self.disallow_simple_key();

                let tok = self.scan_flow_scalar(single)?;

                // From spec: To ensure JSON compatibility, if a key inside a flow mapping is JSON-like,
                // YAML allows the following value to be specified adjacent to the “:”.
                self.adjacent_value_allowed_at = self.mark.index;

                self.tokens.push_back(tok);
                Ok(())
            }

            fn scan_flow_scalar(&mut self, single: bool) -> Result<Token, ScanError> {
                let start_mark = self.mark;

                let mut string = String::new();
                let mut leading_break = String::new();
                let mut trailing_breaks = String::new();
                let mut whitespaces = String::new();
                let mut leading_blanks;

                /* Eat the left quote. */
                self.skip();

                loop {
                    /* Check for a document indicator. */
                    self.lookahead(4);

                    if self.mark.col == 0
                        && (((self.buffer[0] == '-') && (self.buffer[1] == '-') && (self.buffer[2] == '-'))
                            || ((self.buffer[0] == '.')
                                && (self.buffer[1] == '.')
                                && (self.buffer[2] == '.')))
                        && is_blankz(self.buffer[3])
                    {
                        return Err(ScanError::new(
                            start_mark,
                            "while scanning a quoted scalar, found unexpected document indicator",
                        ));
                    }

                    if is_z(self.ch()) {
                        return Err(ScanError::new(
                            start_mark,
                            "while scanning a quoted scalar, found unexpected end of stream",
                        ));
                    }

                    self.lookahead(2);

                    leading_blanks = false;
                    // Consume non-blank characters.

                    while !is_blankz(self.ch()) {
                        match self.ch() {
                            // Check for an escaped single quote.
                            '\'' if self.buffer[1] == '\'' && single => {
                                string.push('\'');
                                self.skip();
                                self.skip();
                            }
                            // Check for the right quote.
                            '\'' if single => break,
                            '"' if !single => break,
                            // Check for an escaped line break.
                            '\\' if !single && is_break(self.buffer[1]) => {
                                self.lookahead(3);
                                self.skip();
                                self.skip_line();
                                leading_blanks = true;
                                break;
                            }
                            // Check for an escape sequence.
                            '\\' if !single => {
                                let mut code_length = 0usize;
                                match self.buffer[1] {
                                    '0' => string.push('\0'),
                                    'a' => string.push('\x07'),
                                    'b' => string.push('\x08'),
                                    't' | '\t' => string.push('\t'),
                                    'n' => string.push('\n'),
                                    'v' => string.push('\x0b'),
                                    'f' => string.push('\x0c'),
                                    'r' => string.push('\x0d'),
                                    'e' => string.push('\x1b'),
                                    ' ' => string.push('\x20'),
                                    '"' => string.push('"'),
                                    '\'' => string.push('\''),
                                    '\\' => string.push('\\'),
                                    // NEL (#x85)
                                    'N' => string.push(char::from_u32(0x85).unwrap()),
                                    // #xA0
                                    '_' => string.push(char::from_u32(0xA0).unwrap()),
                                    // LS (#x2028)
                                    'L' => string.push(char::from_u32(0x2028).unwrap()),
                                    // PS (#x2029)
                                    'P' => string.push(char::from_u32(0x2029).unwrap()),
                                    'x' => code_length = 2,
                                    'u' => code_length = 4,
                                    'U' => code_length = 8,
                                    _ => {
                                        return Err(ScanError::new(
                                            start_mark,
                                            "while parsing a quoted scalar, found unknown escape character",
                                        ))
                                    }
                                }
                                self.skip();
                                self.skip();
                                // Consume an arbitrary escape code.
                                if code_length > 0 {
                                    self.lookahead(code_length);
                                    let mut value = 0u32;
                                    for i in 0..code_length {
                                        if !is_hex(self.buffer[i]) {
                                            return Err(ScanError::new(start_mark,
                                                "while parsing a quoted scalar, did not find expected hexadecimal number"));
                                        }
                                        value = (value << 4) + as_hex(self.buffer[i]);
                                    }

                                    let ch = match char::from_u32(value) {
                                        Some(v) => v,
                                        None => {
                                            return Err(ScanError::new(start_mark,
                                                "while parsing a quoted scalar, found invalid Unicode character escape code"));
                                        }
                                    };
                                    string.push(ch);

                                    for _ in 0..code_length {
                                        self.skip();
                                    }
                                }
                            }
                            c => {
                                string.push(c);
                                self.skip();
                            }
                        }
                        self.lookahead(2);
                    }
                    self.lookahead(1);
                    match self.ch() {
                        '\'' if single => break,
                        '"' if !single => break,
                        _ => {}
                    }

                    // Consume blank characters.
                    while is_blank(self.ch()) || is_break(self.ch()) {
                        if is_blank(self.ch()) {
                            // Consume a space or a tab character.
                            if leading_blanks {
                                self.skip();
                            } else {
                                whitespaces.push(self.ch());
                                self.skip();
                            }
                        } else {
                            self.lookahead(2);
                            // Check if it is a first line break.
                            if leading_blanks {
                                self.read_break(&mut trailing_breaks);
                            } else {
                                whitespaces.clear();
                                self.read_break(&mut leading_break);
                                leading_blanks = true;
                            }
                        }
                        self.lookahead(1);
                    }
                    // Join the whitespaces or fold line breaks.
                    if leading_blanks {
                        if leading_break.is_empty() {
                            string.push_str(&leading_break);
                            string.push_str(&trailing_breaks);
                            trailing_breaks.clear();
                            leading_break.clear();
                        } else {
                            if trailing_breaks.is_empty() {
                                string.push(' ');
                            } else {
                                string.push_str(&trailing_breaks);
                                trailing_breaks.clear();
                            }
                            leading_break.clear();
                        }
                    } else {
                        string.push_str(&whitespaces);
                        whitespaces.clear();
                    }
                } // loop

                // Eat the right quote.
                self.skip();

                if single {
                    Ok(Token(
                        start_mark,
                        TokenType::Scalar(TScalarStyle::SingleQuoted, string),
                    ))
                } else {
                    Ok(Token(
                        start_mark,
                        TokenType::Scalar(TScalarStyle::DoubleQuoted, string),
                    ))
                }
            }

            fn fetch_plain_scalar(&mut self) -> ScanResult {
                self.save_simple_key()?;
                self.disallow_simple_key();

                let tok = self.scan_plain_scalar()?;

                self.tokens.push_back(tok);
                Ok(())
            }

            fn scan_plain_scalar(&mut self) -> Result<Token, ScanError> {
                let indent = self.indent + 1;
                let start_mark = self.mark;

                let mut string = String::new();
                let mut leading_break = String::new();
                let mut trailing_breaks = String::new();
                let mut whitespaces = String::new();
                let mut leading_blanks = false;

                loop {
                    /* Check for a document indicator. */
                    self.lookahead(4);

                    if self.mark.col == 0
                        && (((self.buffer[0] == '-') && (self.buffer[1] == '-') && (self.buffer[2] == '-'))
                            || ((self.buffer[0] == '.')
                                && (self.buffer[1] == '.')
                                && (self.buffer[2] == '.')))
                        && is_blankz(self.buffer[3])
                    {
                        break;
                    }

                    if self.ch() == '#' {
                        break;
                    }
                    while !is_blankz(self.ch()) {
                        // indicators can end a plain scalar, see 7.3.3. Plain Style
                        match self.ch() {
                            ':' if is_blankz(self.buffer[1])
                                || (self.flow_level > 0 && is_flow(self.buffer[1])) =>
                            {
                                break;
                            }
                            ',' | '[' | ']' | '{' | '}' if self.flow_level > 0 => break,
                            _ => {}
                        }

                        if leading_blanks || !whitespaces.is_empty() {
                            if leading_blanks {
                                if leading_break.is_empty() {
                                    string.push_str(&leading_break);
                                    string.push_str(&trailing_breaks);
                                    trailing_breaks.clear();
                                    leading_break.clear();
                                } else {
                                    if trailing_breaks.is_empty() {
                                        string.push(' ');
                                    } else {
                                        string.push_str(&trailing_breaks);
                                        trailing_breaks.clear();
                                    }
                                    leading_break.clear();
                                }
                                leading_blanks = false;
                            } else {
                                string.push_str(&whitespaces);
                                whitespaces.clear();
                            }
                        }

                        string.push(self.ch());
                        self.skip();
                        self.lookahead(2);
                    }
                    // is the end?
                    if !(is_blank(self.ch()) || is_break(self.ch())) {
                        break;
                    }
                    self.lookahead(1);

                    while is_blank(self.ch()) || is_break(self.ch()) {
                        if is_blank(self.ch()) {
                            if leading_blanks && (self.mark.col as isize) < indent && self.ch() == '\t' {
                                return Err(ScanError::new(
                                    start_mark,
                                    "while scanning a plain scalar, found a tab",
                                ));
                            }

                            if leading_blanks {
                                self.skip();
                            } else {
                                whitespaces.push(self.ch());
                                self.skip();
                            }
                        } else {
                            self.lookahead(2);
                            // Check if it is a first line break
                            if leading_blanks {
                                self.read_break(&mut trailing_breaks);
                            } else {
                                whitespaces.clear();
                                self.read_break(&mut leading_break);
                                leading_blanks = true;
                            }
                        }
                        self.lookahead(1);
                    }

                    // check indentation level
                    if self.flow_level == 0 && (self.mark.col as isize) < indent {
                        break;
                    }
                }

                if leading_blanks {
                    self.allow_simple_key();
                }

                Ok(Token(
                    start_mark,
                    TokenType::Scalar(TScalarStyle::Plain, string),
                ))
            }

            fn fetch_key(&mut self) -> ScanResult {
                let start_mark = self.mark;
                if self.flow_level == 0 {
                    // Check if we are allowed to start a new key (not necessarily simple).
                    if !self.simple_key_allowed {
                        return Err(ScanError::new(
                            self.mark,
                            "mapping keys are not allowed in this context",
                        ));
                    }
                    self.roll_indent(
                        start_mark.col,
                        None,
                        TokenType::BlockMappingStart,
                        start_mark,
                    );
                }

                self.remove_simple_key()?;

                if self.flow_level == 0 {
                    self.allow_simple_key();
                } else {
                    self.disallow_simple_key();
                }

                self.skip();
                self.tokens.push_back(Token(start_mark, TokenType::Key));
                Ok(())
            }

            fn fetch_value(&mut self) -> ScanResult {
                let sk = self.simple_keys.last().unwrap().clone();
                let start_mark = self.mark;
                if sk.possible {
                    // insert simple key
                    let tok = Token(sk.mark, TokenType::Key);
                    let tokens_parsed = self.tokens_parsed;
                    self.insert_token(sk.token_number - tokens_parsed, tok);

                    // Add the BLOCK-MAPPING-START token if needed.
                    self.roll_indent(
                        sk.mark.col,
                        Some(sk.token_number),
                        TokenType::BlockMappingStart,
                        start_mark,
                    );

                    self.simple_keys.last_mut().unwrap().possible = false;
                    self.disallow_simple_key();
                } else {
                    // The ':' indicator follows a complex key.
                    if self.flow_level == 0 {
                        if !self.simple_key_allowed {
                            return Err(ScanError::new(
                                start_mark,
                                "mapping values are not allowed in this context",
                            ));
                        }

                        self.roll_indent(
                            start_mark.col,
                            None,
                            TokenType::BlockMappingStart,
                            start_mark,
                        );
                    }

                    if self.flow_level == 0 {
                        self.allow_simple_key();
                    } else {
                        self.disallow_simple_key();
                    }
                }
                self.skip();
                self.tokens.push_back(Token(start_mark, TokenType::Value));

                Ok(())
            }

            fn roll_indent(&mut self, col: usize, number: Option<usize>, tok: TokenType, mark: Marker) {
                if self.flow_level > 0 {
                    return;
                }

                if self.indent < col as isize {
                    self.indents.push(self.indent);
                    self.indent = col as isize;
                    let tokens_parsed = self.tokens_parsed;
                    match number {
                        Some(n) => self.insert_token(n - tokens_parsed, Token(mark, tok)),
                        None => self.tokens.push_back(Token(mark, tok)),
                    }
                }
            }

            fn unroll_indent(&mut self, col: isize) {
                if self.flow_level > 0 {
                    return;
                }
                while self.indent > col {
                    self.tokens.push_back(Token(self.mark, TokenType::BlockEnd));
                    self.indent = self.indents.pop().unwrap();
                }
            }

            fn save_simple_key(&mut self) -> Result<(), ScanError> {
                let required = self.flow_level > 0 && self.indent == (self.mark.col as isize);
                if self.simple_key_allowed {
                    let mut sk = SimpleKey::new(self.mark);
                    sk.possible = true;
                    sk.required = required;
                    sk.token_number = self.tokens_parsed + self.tokens.len();

                    self.remove_simple_key()?;

                    self.simple_keys.pop();
                    self.simple_keys.push(sk);
                }
                Ok(())
            }

            fn remove_simple_key(&mut self) -> ScanResult {
                let last = self.simple_keys.last_mut().unwrap();
                if last.possible && last.required {
                    return Err(ScanError::new(self.mark, "simple key expected"));
                }

                last.possible = false;
                Ok(())
            }
        }
    } pub use self::scanner::{ ScanError };

    pub mod yaml
    {
        use ::
        {
            collections::{ BTreeMap },
            linked_hash_map::{ LinkedHashMap },
            ops::{ Index },
            yaml_rust::
            {
                parser::{ * },
                scanner::{ Marker, ScanError, TScalarStyle, TokenType },
            },
            *,
        };

        macro_rules! define_as (
            ($name:ident, $t:ident, $yt:ident) => (
        pub fn $name(&self) -> Option<$t> {
            match *self {
                Yaml::$yt(v) => Some(v),
                _ => None
            }
        }
            );
        );

        macro_rules! define_as_ref (
            ($name:ident, $t:ty, $yt:ident) => (
        pub fn $name(&self) -> Option<$t> {
            match *self {
                Yaml::$yt(ref v) => Some(v),
                _ => None
            }
        }
            );
        );

        macro_rules! define_into 
        (
            ($name:ident, $t:ty, $yt:ident) => (
        pub fn $name(self) -> Option<$t> {
            match self {
                Yaml::$yt(v) => Some(v),
                _ => None
            }
        }
            );
        );

        static BAD_VALUE: Yaml = Yaml::BadValue;
        pub type Array = Vec<Yaml>;
        pub type Hash = LinkedHashMap<Yaml, Yaml>;
        /// A YAML node is stored as this `Yaml` enumeration, providing an easy way to access your YAML document.
        #[derive(Clone, PartialEq, PartialOrd, Debug, Eq, Ord, Hash)]
        pub enum Yaml 
        {
            /// Float types are stored as String and parsed on demand.
            Real(string::String),
            /// YAML int is stored as i64.
            Integer(i64),
            /// YAML scalar.
            String(string::String),
            /// YAML bool, e.g. `true` or `false`.
            Boolean(bool),
            /// YAML array, can be accessed as a `Vec`.
            Array(self::Array),
            /// YAML hash, can be accessed as a `LinkedHashMap`.
            Hash(self::Hash),
            /// Alias, not fully supported yet.
            Alias(usize),
            /// YAML null, e.g. `null` or `~`.
            Null,
            /// Accessing a nonexistent node via the Index trait returns `BadValue`.
            BadValue,
        }

        fn parse_f64(v: &str) -> Option<f64> 
        {
            match v {
                ".inf" | ".Inf" | ".INF" | "+.inf" | "+.Inf" | "+.INF" => Some(f64::INFINITY),
                "-.inf" | "-.Inf" | "-.INF" => Some(f64::NEG_INFINITY),
                ".nan" | "NaN" | ".NAN" => Some(f64::NAN),
                _ => v.parse::<f64>().ok(),
            }
        }

        pub struct YamlLoader 
        {
            docs: Vec<Yaml>,
            // states
            // (current node, anchor_id) tuple
            doc_stack: Vec<(Yaml, usize)>,
            key_stack: Vec<Yaml>,
            anchor_map: BTreeMap<usize, Yaml>,
        }

        impl MarkedEventReceiver for YamlLoader 
        {
            fn on_event(&mut self, ev: Event, _: Marker) {
                // println!("EV {:?}", ev);
                match ev {
                    Event::DocumentStart => {
                        // do nothing
                    }
                    Event::DocumentEnd => {
                        match self.doc_stack.len() {
                            // empty document
                            0 => self.docs.push(Yaml::BadValue),
                            1 => self.docs.push(self.doc_stack.pop().unwrap().0),
                            _ => unreachable!(),
                        }
                    }
                    Event::SequenceStart(aid) => {
                        self.doc_stack.push((Yaml::Array(Vec::new()), aid));
                    }
                    Event::SequenceEnd => {
                        let node = self.doc_stack.pop().unwrap();
                        self.insert_new_node(node);
                    }
                    Event::MappingStart(aid) => {
                        self.doc_stack.push((Yaml::Hash(Hash::new()), aid));
                        self.key_stack.push(Yaml::BadValue);
                    }
                    Event::MappingEnd => {
                        self.key_stack.pop().unwrap();
                        let node = self.doc_stack.pop().unwrap();
                        self.insert_new_node(node);
                    }
                    Event::Scalar(v, style, aid, tag) => {
                        let node = if style != TScalarStyle::Plain {
                            Yaml::String(v)
                        } else if let Some(TokenType::Tag(ref handle, ref suffix)) = tag {
                            // XXX tag:yaml.org,2002:
                            if handle == "!!" {
                                match suffix.as_ref() {
                                    "bool" => {
                                        // "true" or "false"
                                        match v.parse::<bool>() {
                                            Err(_) => Yaml::BadValue,
                                            Ok(v) => Yaml::Boolean(v),
                                        }
                                    }
                                    "int" => match v.parse::<i64>() {
                                        Err(_) => Yaml::BadValue,
                                        Ok(v) => Yaml::Integer(v),
                                    },
                                    "float" => match parse_f64(&v) {
                                        Some(_) => Yaml::Real(v),
                                        None => Yaml::BadValue,
                                    },
                                    "null" => match v.as_ref() {
                                        "~" | "null" => Yaml::Null,
                                        _ => Yaml::BadValue,
                                    },
                                    _ => Yaml::String(v),
                                }
                            } else {
                                Yaml::String(v)
                            }
                        } else {
                            // Datatype is not specified, or unrecognized
                            Yaml::from_str(&v)
                        };

                        self.insert_new_node((node, aid));
                    }
                    Event::Alias(id) => {
                        let n = match self.anchor_map.get(&id) {
                            Some(v) => v.clone(),
                            None => Yaml::BadValue,
                        };
                        self.insert_new_node((n, 0));
                    }
                    _ => { /* ignore */ }
                }
                // println!("DOC {:?}", self.doc_stack);
            }
        }

        impl YamlLoader 
        {
            fn insert_new_node(&mut self, node: (Yaml, usize)) {
                // valid anchor id starts from 1
                if node.1 > 0 {
                    self.anchor_map.insert(node.1, node.0.clone());
                }
                if self.doc_stack.is_empty() {
                    self.doc_stack.push(node);
                } else {
                    let parent = self.doc_stack.last_mut().unwrap();
                    match *parent {
                        (Yaml::Array(ref mut v), _) => v.push(node.0),
                        (Yaml::Hash(ref mut h), _) => {
                            let cur_key = self.key_stack.last_mut().unwrap();
                            // current node is a key
                            if cur_key.is_badvalue() {
                                *cur_key = node.0;
                            // current node is a value
                            } else {
                                let mut newkey = Yaml::BadValue;
                                mem::swap(&mut newkey, cur_key);
                                h.insert(newkey, node.0);
                            }
                        }
                        _ => unreachable!(),
                    }
                }
            }

            pub fn load_from_str(source: &str) -> Result<Vec<Yaml>, ScanError> {
                let mut loader = YamlLoader {
                    docs: Vec::new(),
                    doc_stack: Vec::new(),
                    key_stack: Vec::new(),
                    anchor_map: BTreeMap::new(),
                };
                let mut parser = Parser::new(source.chars());
                parser.load(&mut loader, true)?;
                Ok(loader.docs)
            }
        }

        impl Yaml 
        {
            define_as!(as_bool, bool, Boolean);
            define_as!(as_i64, i64, Integer);

            define_as_ref!(as_str, &str, String);
            define_as_ref!(as_hash, &Hash, Hash);
            define_as_ref!(as_vec, &Array, Array);

            define_into!(into_bool, bool, Boolean);
            define_into!(into_i64, i64, Integer);
            define_into!(into_string, String, String);
            define_into!(into_hash, Hash, Hash);
            define_into!(into_vec, Array, Array);

            pub fn is_null(&self) -> bool {
                match *self {
                    Yaml::Null => true,
                    _ => false,
                }
            }

            pub fn is_badvalue(&self) -> bool {
                match *self {
                    Yaml::BadValue => true,
                    _ => false,
                }
            }

            pub fn is_array(&self) -> bool {
                match *self {
                    Yaml::Array(_) => true,
                    _ => false,
                }
            }

            pub fn as_f64(&self) -> Option<f64> {
                match *self {
                    Yaml::Real(ref v) => parse_f64(v),
                    _ => None,
                }
            }

            pub fn into_f64(self) -> Option<f64> {
                match self {
                    Yaml::Real(ref v) => parse_f64(v),
                    _ => None,
                }
            }
        }
        
        impl Yaml 
        {
            // Not implementing FromStr because there is no possibility of Error.
            // This function falls back to Yaml::String if nothing else matches.
            pub fn from_str(v: &str) -> Yaml {
                if v.starts_with("0x") {
                    if let Ok(i) = i64::from_str_radix(&v[2..], 16) {
                        return Yaml::Integer(i);
                    }
                }
                if v.starts_with("0o") {
                    if let Ok(i) = i64::from_str_radix(&v[2..], 8) {
                        return Yaml::Integer(i);
                    }
                }
                if v.starts_with('+') {
                    if let Ok(i) = v[1..].parse::<i64>() {
                        return Yaml::Integer(i);
                    }
                }
                match v {
                    "~" | "null" => Yaml::Null,
                    "true" => Yaml::Boolean(true),
                    "false" => Yaml::Boolean(false),
                    _ if v.parse::<i64>().is_ok() => Yaml::Integer(v.parse::<i64>().unwrap()),
                    // try parsing as f64
                    _ if parse_f64(v).is_some() => Yaml::Real(v.to_owned()),
                    _ => Yaml::String(v.to_owned()),
                }
            }
        }

        impl<'a> Index<&'a str> for Yaml 
        {
            type Output = Yaml;

            fn index(&self, idx: &'a str) -> &Yaml {
                let key = Yaml::String(idx.to_owned());
                match self.as_hash() {
                    Some(h) => h.get(&key).unwrap_or(&BAD_VALUE),
                    None => &BAD_VALUE,
                }
            }
        }

        impl Index<usize> for Yaml 
        {
            type Output = Yaml;

            fn index(&self, idx: usize) -> &Yaml {
                if let Some(v) = self.as_vec() {
                    v.get(idx).unwrap_or(&BAD_VALUE)
                } else if let Some(v) = self.as_hash() {
                    let key = Yaml::Integer(idx as i64);
                    v.get(&key).unwrap_or(&BAD_VALUE)
                } else {
                    &BAD_VALUE
                }
            }
        }

        impl IntoIterator for Yaml 
        {
            type Item = Yaml;
            type IntoIter = YamlIter;

            fn into_iter(self) -> Self::IntoIter {
                YamlIter {
                    yaml: self.into_vec().unwrap_or_else(Vec::new).into_iter(),
                }
            }
        }

        pub struct YamlIter 
        {
            yaml: vec::IntoIter<Yaml>,
        }

        impl Iterator for YamlIter 
        {
            type Item = Yaml;

            fn next(&mut self) -> Option<Yaml> {
                self.yaml.next()
            }
        }
    } pub use self::yaml::{ Yaml, YamlLoader };
}

fn main()
{
    unsafe
    {
        libc::signal(libc::SIGPIPE, libc::SIG_DFL);

        // ignore SIGTSTP (ctrl-Z) for the shell itself
        libc::signal(libc::SIGTSTP, libc::SIG_IGN);
        libc::signal(libc::SIGQUIT, libc::SIG_IGN);
    }

    tools::init_path_env();

    let mut sh = shell::Shell::new();
    let args: Vec<String> = env::args().collect();

    if libs::progopts::is_login(&args) {
        rcfile::load_rc_files(&mut sh);
        sh.is_login = true;
    }
    
    highlight::init_command_cache();
    highlight::update_aliases(&sh);

    if libs::progopts::is_script(&args) {
        log!("run script: {:?} ", &args);
        let status = scripting::run_script(&mut sh, &args);
        std::process::exit(status);
    }

    if libs::progopts::is_command_string(&args) {
        // handles `cicada -c 'echo hi && echo yoo'`,
        // e.g. it could be triggered from Vim (`:!ls` etc).
        let line = tools::env_args_to_command_line();
        log!("run with -c args: {}", &line);
        execute::run_command_line(&mut sh, &line, false, false);
        std::process::exit(sh.previous_status);
    }

    if libs::progopts::is_non_tty() {
        // cases like open a new MacVim window,
        // (i.e. CMD+N) on an existing one
        execute::run_procs_for_non_tty(&mut sh);
        return;
    }

    let mut rl;
    match Interface::new("cicada") {
        Ok(x) => rl = x,
        Err(e) => {
            // non-tty will raise errors here
            println!(":: lineread error: {}", e);
            return;
        }
    }

    rl.define_function("enter-function", Arc::new(prompt::EnterFunction));
    rl.bind_sequence("\r", Command::from_str("enter-function"));

    let highlighter = highlight::create_highlighter();
    rl.set_highlighter(highlighter);

    history::init(&mut rl);
    rl.set_completer(Arc::new(completers::CicadaCompleter {
        sh: Arc::new(sh.clone()),
    }));

    let sig_handler_enabled = tools::is_signal_handler_enabled();
    if sig_handler_enabled {
        signals::setup_sigchld_handler();
        // block the signals at most of time, since Rust is not "async-signal-safe"
        // yet. see https://github.com/rust-lang/rfcs/issues/1368
        // we'll unblock them when necessary only.
        signals::block_signals();
    }

    loop {
        let prompt = prompt::get_prompt(&sh);
        match rl.set_prompt(&prompt) {
            Ok(_) => {}
            Err(e) => {
                println_stderr!(":: prompt error: {}", e);
            }
        }

        if sig_handler_enabled {
            // FIXME: in `rl.read_line()` below, there is lots of Rust code,
            // which may not be async-signal-safe. see follow links for details:
            // - https://ldpreload.com/blog/signalfd-is-useless
            // - https://man7.org/linux/man-pages/man7/signal-safety.7.html
            signals::unblock_signals();
        }
        match rl.read_line() {
            Ok(ReadResult::Input(line)) => {
                if sig_handler_enabled {
                    signals::block_signals();
                }

                let line = shell::trim_multiline_prompts(&line);
                if line.trim() == "" {
                    jobc::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                    continue;
                }
                sh.cmd = line.clone();

                let tsb = ctime::DateTime::now().unix_timestamp();
                let mut line = line.clone();

                // since `!!` expansion is only meaningful in an interactive
                // shell we extend it here, instead of in `run_command_line()`.
                tools::extend_bangbang(&sh, &mut line);

                let mut status = 0;
                let cr_list = execute::run_command_line(&mut sh, &line, true, false);
                if let Some(last) = cr_list.last() {
                    status = last.status;
                }
                let tse = ctime::DateTime::now().unix_timestamp();

                if !sh.cmd.starts_with(' ') && line != sh.previous_cmd {
                    history::add(&sh, &mut rl, &line, status, tsb, tse);
                    sh.previous_cmd = line.clone();
                }

                if tools::is_shell_altering_command(&line) {
                    // since our shell object need to be passed into
                    // `lineread::Completer` with an Arc.
                    // I currently do not know how to share the same sh
                    // instance at hand with it.

                    // update the Arc clone when alias/function/env changes
                    rl.set_completer(Arc::new(completers::CicadaCompleter {
                        sh: Arc::new(sh.clone()),
                    }));

                    // Update aliases in the highlighter when they might have changed
                    highlight::update_aliases(&sh);
                }

                jobc::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                continue;
            }
            Ok(ReadResult::Eof) => {
                if let Ok(x) = env::var("NO_EXIT_ON_CTRL_D") {
                    if x == "1" {
                        println!();
                    }
                } else {
                    println!("exit");
                    break;
                }
            }
            Ok(ReadResult::Signal(s)) => {
                println_stderr!("readline signal: {:?}", s);
            }
            Err(e) => {
                println_stderr!("readline error: {}", e);
                // There maybe other reason of this Err, but possibly it occurs
                // in cases we give term to a child, and it stops, and we
                // didn't have term back to shell in waitpid places. Here
                // it's a last resort.
                // FIXME: we only need this trick when job-control has issues
                unsafe {
                    let gid = libc::getpgid(0);
                    shell::give_terminal_to(gid);
                }
            }
        }
        if sig_handler_enabled {
            signals::block_signals();
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 57167
