#![allow
(
    dead_code,
    elided_named_lifetimes,
    non_camel_case_types,
    stable_features,
    unknown_lints,
    unused_assignments,
    unused_imports,
    unused_macros,
    unused_mut,
    unused_unsafe,
    unused_variables,
)]
/**/
#[macro_use] extern crate bitflags;
#[macro_use] extern crate lazy_static;
/**/
extern crate rand;
extern crate fnv;
extern crate memchr;
extern crate nix;
extern crate regex as re;
extern crate smallvec;
extern crate time as timed;
extern crate unicode_normalization;
extern crate unicode_width;
//extern crate libc;
#[macro_use] pub mod macros
{
    use ::
    {
        *,
    };    
    /// OVER::map    
    #[macro_export] macro_rules! map
    {
        { } => { ::collections::HashMap::new() };
        
        { $( $key:expr => $value:expr ),+ , } => { map!{ $( $key => $value),+ } };
        
        { $( $key:expr => $value:expr ),* } =>
        {
            {
                let mut _map = ::collections::HashMap::new();
                $( let _ = _map.insert($key, $value); )*
                _map
            }
        }
    }
    /// Given an int, creates and returns a `BigInt`.
    #[macro_export] macro_rules! int
    {
        ($int:expr) => 
        {{
            use num::big::BigInt;

            let _b: BigInt = $int.into();
            _b
        }};
    }
    /// Given two ints, creates and returns a `BigRational`.
    #[macro_export] macro_rules! frac
    {
        ($int1:expr, $int2:expr) => 
        {{
            ::num::rational::BigRational::new($int1.into(), $int2.into())
        }};
    }
    /// Given a list of elements, converts each element to a `Value` and returns an `Arr` containing a
    /// vector of the values.
    #[macro_export] macro_rules! arr
    {
        [] =>
        {
            ::database::arrays::Arr::from_vec(vec![]).unwrap()
        };

        [ $( $elem:expr ),+ , ] => { try_arr![ $( $elem ),+ ].unwrap() };

        [ $( $elem:expr ),+ ] => { try_arr![ $( $elem ),+ ].unwrap() };
    }
    /// Given a list of elements, converts each to a `Value` and returns an `Arr` containing a vector of the values.
    #[macro_export] macro_rules! try_arr
    {
        [ $( $elem:expr ),+ , ] => { try_arr![ $( $elem ),+ ] };

        [ $( $elem:expr ),+ ] =>
        {
            {
                ::database::arrays::Arr::from_vec(vec![ $( $elem.into() ),+ ])
            }
        };
    }
    /// Given a list of elements, converts each element to `Value`s and returns a `Tup` containing a
    /// vector of the values.
    #[macro_export] macro_rules! tup
    {
        ( $( $elem:expr ),* , ) => { tup!( $( $elem ),* ) };

        ( $( $elem:expr ),* ) =>
        {
            {
                ::database::tuples::Tup::from_vec(vec![ $( $elem.into() ),+ ])            
            }
        };
    }
    /// Given a list of field/value pairs, returns an `Obj` containing each pair.
    #[macro_export] macro_rules! obj
    {
        {} => { ::database::objects::Obj::from_map_unchecked( ::collections::HashMap::new() ) };
        { $( $field:expr => $inner:expr ),+ , } => { try_obj!{ $( $field => $inner ),+ }.unwrap() };
        { $( $field:expr => $inner:expr ),+ } => { try_obj!{ $( $field => $inner ),+ }.unwrap() };
    }
    /// Given a list of field to `Value` pairs, returns an `Obj` with the fields and values.
    #[macro_export] macro_rules! try_obj 
    {
        { $( $field:expr => $inner:expr ),+ , } =>
        {
            try_obj!{ $( $field => $inner ),* };
        };

        { $( $field:expr => $inner:expr ),+ } =>
        {
            {
                use ::database::objects::Obj;
                let mut _map = ::collections::HashMap::new();
                let mut _parent: Option<::database::values::Value> = None;
                $(
                    if $field == "^" { _parent = Some($inner.into()); }
                    else { _map.insert($field.into(), $inner.into()); }
                )*

                match _parent
                {
                    Some(parent) => match parent.get_obj()
                    {
                        Ok(parent) => Obj::from_map_with_parent(_map, parent),
                        e @ Err(_) => e,
                    }

                    None => Obj::from_map(_map),
                }
            }
        };
    }
}

pub mod alloc
{
    pub use std::alloc::{ * };
}

pub mod arch
{
    pub use std::arch::{ x86_64::{ * }, * };
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod boxed
{
    pub use std::boxed::{ * };
}

pub mod cell
{
   pub use std::cell::{ * };
}

pub mod char
{
    //! Character stream used for parsing.
    pub use std::char::{ * };
    use ::
    {
        cell::{ RefCell },
        fs::{ File },
        io::{ self, Read },
        iter::{ Peekable },
        rc::{ Rc },
        str::{ Chars },
        *,
    };
    
    const CTRL_MASK: u8 = 0x1f;
    const UNCTRL_BIT: u8 = 0x40;

    #[derive(Clone, Debug)]
    struct Inner
    {
        file: Option<String>,
        contents: String,
        stream: Peekable<Chars<'static>>,
        line: usize,
        col: usize,
    }

    #[derive(Clone, Debug)]
    pub struct CharStream
    {
        inner: Rc<RefCell<Inner>>,
    }

    impl CharStream
    {
        pub fn from_file(path: &str) -> io::Result<CharStream>
        {
            let mut file = File::open(path)?;

            let len = file.metadata()?.len();
            let mut contents = String::with_capacity(len as usize);

            file.read_to_string(&mut contents)?;

            Self::from_string_impl(Some(String::from(path)), contents)
        }

        pub fn from_string(contents: String) -> io::Result<CharStream>
        {
            Self::from_string_impl(None, contents)
        }

        pub fn from_string_impl(file: Option<String>, contents: String) -> io::Result<CharStream>
        {
            let chars: Chars = unsafe { mem::transmute(contents.chars()) };
            let stream = chars.peekable();

            Ok(CharStream
            {
                inner: Rc::new(RefCell::new(Inner
                {
                    file,
                    contents,
                    stream,
                    line: 1,
                    col: 1,
                })),
            })
        }

        pub fn peek(&self) -> Option<char>
        {
            let mut inner = self.inner.borrow_mut();
            let opt = inner.stream.peek();
            match opt
            {
                Some(ch) => Some(*ch),
                None => None,
            }
        }

        pub fn file(&self) -> Option<String>
        {
            let inner = self.inner.borrow();
            inner.file.clone()
        }

        pub fn line(&self) -> usize
        {
            let inner = self.inner.borrow();
            inner.line
        }

        pub fn col(&self) -> usize
        {
            let inner = self.inner.borrow();
            inner.col
        }

        fn set_line(&mut self, value: usize)
        {
            let mut inner = self.inner.borrow_mut();
            inner.line = value;
        }

        fn set_col(&mut self, value: usize)
        {
            let mut inner = self.inner.borrow_mut();
            inner.col = value;
        }
    }

    impl Iterator for CharStream
    {
        type Item = char;

        fn next(&mut self) -> Option<Self::Item>
        {
            let opt =
            {
                let mut inner = self.inner.borrow_mut();
                inner.stream.next()
            };

            match opt
            {
                Some(ch) =>
                {
                    if ch == '\n' {
                        let line = self.line();
                        self.set_line(line + 1);
                        self.set_col(1);
                    } else {
                        let col = self.col();
                        self.set_col(col + 1);
                    }
                    Some(ch)
                }
                None => None,
            }
        }
    }
    /*
    pub fn format_char(...) -> String */
    pub fn format( ch:char ) -> String
    {
        match ch
        {
            '\n' => String::from("\\n"),
            ch => format!("{}", ch),
        }
    }
    /*
    pub fn get_escape_char(...) -> Option<char> */
    /// If `ch` preceded by a backslash together form an escape character, then return this char.
    pub fn get_escape(ch: char) -> Option<char>
    {
        match ch 
        {
            '\\' => Some('\\'),
            '"' => Some('"'),
            '\'' => Some('\''),
            '$' => Some('$'),
            'n' => Some('\n'),
            'r' => Some('\r'),
            't' => Some('\t'),
            _ => None,
        }
    }
    /*
    pub fn char_width(ch: char) -> Option<usize> */
    /// Returns the width of a character in the terminal.
    #[inline] pub fn width(ch: char) -> Option<usize>
    {
        use unicode_width::UnicodeWidthChar;
        ch.width()
    }
    /// Returns the control character corresponding to the given character.
    #[inline] pub fn ctrl(ch: char) -> char { ((ch as u8) & CTRL_MASK) as char }
    /// Returns the ASCII character corresponding to the given control character.
    #[inline] pub fn unctrl_upper(ch: char) -> char { ((ch as u8) | UNCTRL_BIT) as char }
    /// Returns the lowercase ASCII character corresponding to the given control character.
    #[inline] pub fn unctrl_lower(ch: char) -> char { unctrl_upper(ch).to_ascii_lowercase() }
}

pub mod cmp
{
    pub use std::cmp::{ * };
}

pub mod collections
{
    pub use std::collections::{ * };
}

pub mod convert
{
    pub use std::convert::{ * };
}
/*
mortal*/
pub mod common
{
    //! Platform-independent terminal interface
    use ::
    {
        sync::{ LockResult, PoisonError, TryLockError, TryLockResult },
        *,
    };
    /*
    #[macro_use] extern crate bitflags;
    extern crate smallstr;
    extern crate unicode_normalization;
    extern crate unicode_width;

    #[cfg(unix)] extern crate libc;
    #[cfg(unix)] extern crate nix;
    #[cfg(unix)] extern crate terminfo;

    #[cfg(windows)] extern crate winapi; */
    #[macro_use] pub mod buffer
    {
        use ::
        { 
            common::
            {
                terminal::{Color, Cursor, Size, Style, Theme},
            },
            is::{ visible },
            mem::{ swap },
            ops::{ Range },
            str::{ SmallString },
            *,
        };
        const TAB_STOP: usize = 8;

        pub struct ScreenBuffer
        {
            buffer: Vec<Cell>,
            back_buffer: Vec<Cell>,
            size: Size,
            cursor: Cursor,
            fg: Option<Color>,
            bg: Option<Color>,
            style: Option<Style>,
        }

        impl ScreenBuffer 
        {
            pub fn new(size: Size) -> ScreenBuffer 
            {
                let area = size.area();

                ScreenBuffer
                {
                    buffer: vec![Cell::default(); area],
                    back_buffer: vec![Cell::default(); area],
                    size: size,
                    cursor: Cursor::default(),
                    fg: None,
                    bg: None,
                    style:None,
                }
            }

            pub fn cursor(&self) -> Cursor { self.cursor }

            pub fn size(&self) -> Size { self.size }

            pub fn resize(&mut self, new_size: Size)
            {
                resize_buffer(&mut self.buffer, self.size, new_size);
                new_buffer(&mut self.back_buffer, new_size);
                self.size = new_size;
            }

            pub fn set_cursor(&mut self, pos: Cursor) { self.cursor = pos; }

            pub fn next_line(&mut self, column: usize)
            {
                self.cursor.line += 1;
                self.cursor.column = column;
            }

            pub fn clear_attributes(&mut self)
            {
                self.fg = None;
                self.bg = None;
                /*
                self.style = Style::empty(); */
            }
            /*
            pub fn add_style(&mut self, style: Style) { self.style |= style; }
            pub fn remove_style(&mut self, style: Style) { self.style -= style; }
            pub fn set_style(&mut self, style: Style)  { self.style = style; }
            pub fn set_fg(&mut self, fg: Option<Color>) { self.fg = fg; }
            pub fn set_bg(&mut self, bg: Option<Color>) { self.bg = bg; }
            */

            pub fn set_theme(&mut self, theme: Theme)
            {
                /*
                self.set_fg(theme.fg);
                self.set_bg(theme.bg);
                self.set_style(theme.style);*/
            }

            pub fn clear_screen(&mut self)
            {
                for cell in &mut self.buffer
                {
                    *cell = Cell::default();
                }
            }

            pub fn indices(&self) -> Range<usize> {  0..self.size.area() }
            
            pub fn next_cell(&mut self, indices: &mut Range<usize>) -> Option<(Cursor, Cell)>
            {
                while let Some(idx) = indices.next()
                {
                    let first = self.buffer[idx].first_char();
                    let width = char::width(first).unwrap_or(0);

                    if width == 2 { let _ = indices.next(); }

                    if self.buffer[idx] != self.back_buffer[idx]
                    {
                        let cell = self.buffer[idx].clone();
                        let line = idx / self.size.columns;
                        let column = idx % self.size.columns;
                        self.back_buffer[idx] = cell.clone();
                        return Some((Cursor{line, column}, cell));
                    }
                }

                None
            }

            fn cell_mut(&mut self, pos: Cursor) -> &mut Cell
            {
                let size = self.size;
                &mut self.buffer[pos.as_index(size)]
            }

            fn set_cell(&mut self, pos: Cursor, ch: char)
            {
                let fg = self.fg;
                let bg = self.bg;
                let style = self.style;
                let cell = self.cell_mut(pos);
                cell.fg = fg;
                cell.bg = bg;
                cell.style = style;
                cell.text = ch.into();
            }

            pub fn write_char(&mut self, ch: char) -> Result<(), OutOfBounds>
            {
                if ch == '\t'
                {
                    self.try_cursor()?;
                    let rem = self.size.columns - self.cursor.column;
                    let n = rem.min(TAB_STOP - (self.cursor.column % TAB_STOP));

                    for _ in 0..n
                    {
                        self.write_char(' ')?;
                    }
                }
                
                else if ch == '\r' { self.cursor.column = 0; }
                
                else if ch == '\n'
                {
                    self.cursor.line += 1;
                    self.cursor.column = 0;
                }
                
                else if is::combining_mark(ch)
                {
                    if let Some(prev) = self.cursor.previous(self.size)
                    {
                        self.try_cursor_at(prev)?;
                        self.cell_mut(prev).text.push(ch);
                    }
                }
                
                else if is::visible(ch)
                {
                    self.try_cursor()?;

                    if let Some(prev) = self.cursor.previous(self.size)
                    {
                        let cell = self.cell_mut(prev);
                        if cell.is_wide() { *cell = Cell::default(); }
                    }

                    let rem = self.size.columns - self.cursor.column;
                    let width = char::width(ch).unwrap_or(0);
                    
                    if rem < width
                    {
                        self.try_cursor()?;
                        let mut pos = self.cursor;

                        for _ in 0..rem
                        {
                            self.set_cell(pos, ch);
                            pos.column += 1;
                        }

                        self.cursor.column = 0;
                        self.cursor.line += 1;
                    }

                    self.try_cursor()?;
                    let mut pos = self.cursor;
                    self.set_cell(pos, ch);

                    for _ in 1..width
                    {
                        pos.column += 1;
                        self.set_cell(pos, ' ');
                    }

                    self.cursor.column += width;

                    if self.cursor.column >= self.size.columns
                    {
                        self.cursor.line += 1;
                        self.cursor.column = 0;
                    }
                }

                Ok(())
            }

            pub fn write_str(&mut self, s: &str) -> Result<(), OutOfBounds>
            {
                for ch in s.chars()
                {
                    self.write_char(ch)?;
                }

                Ok(())
            }

            pub fn write_at(&mut self, pos: Cursor, text: &str) -> Result<(), OutOfBounds>
            {
                self.try_cursor_at(pos)?;
                self.cursor = pos;
                self.write_str(text)
            }

            pub fn write_styled(&mut self, fg: Option<Color>, bg: Option<Color>, style: Style, text: &str) 
            -> Result<(), OutOfBounds>
            {
                self.fg = fg;
                self.bg = bg;
                self.style = Some( style );
                self.write_str(text)?;
                self.clear_attributes();
                Ok(())
            }

            pub fn write_styled_at
            (&mut self, pos: Cursor, fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
            -> Result<(), OutOfBounds>
            {
                self.try_cursor_at(pos)?;
                self.cursor = pos;
                self.write_styled(fg, bg, style, text)
            }

            fn try_cursor(&self) -> Result<(), OutOfBounds> { self.try_cursor_at(self.cursor) }

            fn try_cursor_at(&self, pos: Cursor) -> Result<(), OutOfBounds>
            {
                if pos.line >= self.size.lines || pos.column >= self.size.columns { Err(OutOfBounds(())) }
                else { Ok(()) }
            }
        }
        
        macro_rules! forward_screen_buffer_methods
        {
            ( |$slf:ident| $field:expr ) =>
            {
                pub fn size(&self) -> ::common::terminal::Size {
                    let $slf = self;
                    $field.size()
                }

                pub fn cursor(&self) -> ::common::terminal::Cursor {
                    let $slf = self;
                    $field.cursor()
                }

                pub fn set_cursor(&self, pos: ::common::terminal::Cursor) {
                    let $slf = self;
                    $field.set_cursor(pos);
                }

                pub fn next_line(&self, column: usize) {
                    let $slf = self;
                    $field.next_line(column);
                }

                pub fn clear_screen(&self) {
                    let $slf = self;
                    $field.clear_screen();
                }

                pub fn clear_attributes(&self) {
                    let $slf = self;
                    $field.clear_attributes();
                }

                pub fn add_style(&self, style: ::common::terminal::Style) {
                    let $slf = self;
                    //$field.add_style(style);
                }

                pub fn remove_style(&self, style: ::common::terminal::Style) {
                    let $slf = self;
                    //$field.remove_style(style);
                }

                pub fn set_style(&self, style: ::common::terminal::Style) {
                    let $slf = self;
                   // $field.set_style(style);
                }

                pub fn set_fg(&self, fg: Option<::common::terminal::Color>) {
                    let $slf = self;
                    //$field.set_fg(fg);
                }

                pub fn set_bg(&self, bg: Option<::common::terminal::Color>) {
                    let $slf = self;
                   // $field.set_bg(bg);
                }

                pub fn set_theme(&self, theme: ::common::terminal::Theme) {
                    let $slf = self;
                    $field.set_theme(theme)
                }

                pub fn write_char(&self, ch: char) {
                    let $slf = self;
                    let _ = $field.write_char(ch);
                }

                pub fn write_str(&self, s: &str) {
                    let $slf = self;
                    let _ = $field.write_str(s);
                }

                pub fn write_at(&self, pos: ::common::terminal::Cursor, text: &str) {
                    let $slf = self;
                    let _ = $field.write_at(pos, text);
                }

                pub fn write_styled(&self,
                        fg: Option<::common::terminal::Color>, bg: Option<::common::terminal::Color>,
                        style: ::common::terminal::Style, text: &str) {
                    let $slf = self;
                    let _ = $field.write_styled(fg, bg, style, text);
                }

                pub fn write_styled_at(&self, pos: ::common::terminal::Cursor,
                        fg: Option<::common::terminal::Color>, bg: Option<::common::terminal::Color>,
                        style: ::common::terminal::Style, text: &str) {
                    let $slf = self;
                    let _ = $field.write_styled_at(pos, fg, bg, style, text);
                }
            }
        }
        
        macro_rules! forward_screen_buffer_mut_methods
        {
            ( |$slf:ident| $field:expr ) =>
            {
                pub fn size(&self) -> ::common::terminal::Size {
                    let $slf = self;
                    $field.size()
                }

                pub fn cursor(&self) -> ::common::terminal::Cursor {
                    let $slf = self;
                    $field.cursor()
                }

                pub fn set_cursor(&mut self, pos: ::common::terminal::Cursor) {
                    let $slf = self;
                    $field.set_cursor(pos);
                }

                pub fn next_line(&mut self, column: usize) {
                    let $slf = self;
                    $field.next_line(column);
                }

                pub fn clear_screen(&mut self) {
                    let $slf = self;
                    $field.clear_screen();
                }

                pub fn clear_attributes(&mut self) {
                    let $slf = self;
                    $field.clear_attributes();
                }

                pub fn add_style(&mut self, style: ::common::terminal::Style) {
                    let $slf = self;
                    //$field.add_style(style);
                }

                pub fn remove_style(&mut self, style: ::common::terminal::Style) {
                    let $slf = self;
                    //$field.remove_style(style);
                }

                pub fn set_style(&mut self, style: ::common::terminal::Style) {
                    let $slf = self;
                    //$field.set_style(style);
                }

                pub fn set_fg(&mut self, fg: Option<::common::terminal::Color>) {
                    let $slf = self;
                    //$field.set_fg(fg);
                }

                pub fn set_bg(&mut self, bg: Option<::common::terminal::Color>) {
                    let $slf = self;
                    //$field.set_bg(bg);
                }

                pub fn set_theme(&mut self, theme: ::common::terminal::Theme) {
                    let $slf = self;
                    $field.set_theme(theme);
                }

                pub fn write_char(&mut self, ch: char) {
                    let $slf = self;
                    let _ = $field.write_char(ch);
                }

                pub fn write_str(&mut self, s: &str) {
                    let $slf = self;
                    let _ = $field.write_str(s);
                }

                pub fn write_at(&mut self, pos: ::common::terminal::Cursor, text: &str) {
                    let $slf = self;
                    let _ = $field.write_at(pos, text);
                }

                pub fn write_styled(&mut self,
                        fg: Option<::common::terminal::Color>, bg: Option<::common::terminal::Color>,
                        style: ::common::terminal::Style, text: &str) {
                    let $slf = self;
                    let _ = $field.write_styled(fg, bg, style, text);
                }

                pub fn write_styled_at(&mut self, pos: ::common::terminal::Cursor,
                        fg: Option<::common::terminal::Color>, bg: Option<::common::terminal::Color>,
                        style: ::common::terminal::Style, text: &str) {
                    let $slf = self;
                    let _ = $field.write_styled_at(pos, fg, bg, style, text);
                }
            }
        }

        #[derive(Debug)]
        pub struct OutOfBounds(());

        #[derive(Clone, Debug, Eq, PartialEq)]
        pub struct Cell
        {
            fg: Option<Color>,
            bg: Option<Color>,
            style: Option<Style>,
            text: SmallString<[u8; 8]>,
        }

        impl Cell
        {
            fn new(fg: Option<Color>, bg: Option<Color>, style: Option<Style>, chr: char) -> Cell
            {
                Cell
                {
                    fg,
                    bg,
                    style,
                    text: chr.into(),
                }
            }

            fn invalid() -> Cell
            {
                Cell
                {
                    fg: None,
                    bg: None,
                    style: None,
                    text: SmallString::new(),
                }
            }

            pub fn attrs(&self) -> (Option<Color>, Option<Color>, Option<Style>) { (self.fg, self.bg, self.style ) }

            pub fn text(&self) -> &str { &self.text }

            fn first_char(&self) -> char { self.text.chars().next().expect("empty cell text") }

            fn is_wide(&self) -> bool { self.text.chars().next().and_then(char::width).unwrap_or(0) == 2 }
        }

        impl Default for Cell        
        {
            fn default() -> Cell { Cell::new(None, None, None, ' ') }
        }

        fn resize_buffer(buf: &mut Vec<Cell>, old: Size, new: Size)
        {
            if old != new
            {
                let mut new_buf = vec![Cell::default(); new.area()];

                if !buf.is_empty()
                {
                    let n_cols = old.columns.min(new.columns);

                    for (old, new) in buf.chunks_mut(old.columns).zip(new_buf.chunks_mut(new.columns))
                    {
                        for i in 0..n_cols
                        {
                            swap(&mut new[i], &mut old[i]);
                        }
                    }
                }

                *buf = new_buf;
            }
        }

        fn new_buffer(buf: &mut Vec<Cell>, new_size: Size) { *buf = vec![Cell::invalid(); new_size.area()]; }
    }

    #[macro_use] pub mod macros
    {
        //! Provides macros easier printing with colors and styles.
        use ::
        {
            *,
        };
        /// Writes attributes and formatted text to a `Terminal` or `Screen`.
        #[macro_export] macro_rules! term_write
        {
            // Entry rule
            ( $term:expr , $first:tt $($rest:tt)* ) => {
                match $term.borrow_term_write_guard() {
                    mut term => {
                        let init = $crate::macros::Chain::init();
                        term_write!(@_INTERNAL main: term ; init ; $first $($rest)*)
                    }
                }
            };

            // Final rule
            ( @_INTERNAL main: $term:expr ; $result:expr ; ) => {
                $result
            };

            // Color/style rules
            ( @_INTERNAL main: $term:expr ; $result:expr ; [ $($tt:tt)* ] $($rest:tt)* ) => {
                term_write!(
                    @_INTERNAL main: $term;
                    term_write!(@_INTERNAL style: $term; $result; $($tt)*);
                    $($rest)*
                )
            };

            // Formatting rules
            ( @_INTERNAL main: $term:expr ; $result:expr ; ( $($tt:tt)* ) $($rest:tt)* ) => {
                term_write!(
                    @_INTERNAL main: $term;
                    term_write!(@_INTERNAL format: $term; $result; $($tt)*);
                    $($rest)*
                )
            };
            ( @_INTERNAL main: $term:expr ; $result:expr ; $tt:tt $($rest:tt)* ) => {
                term_write!(
                    @_INTERNAL main: $term;
                    term_write!(@_INTERNAL literal: $term; $result; $tt);
                    $($rest)*
                )
            };

            // Set foreground color
            ( @_INTERNAL style: $term:expr ; $result:expr ; black ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Black))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; blue ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Blue))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; cyan ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Cyan))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; green ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Green))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; magenta ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Magenta))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; red ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Red))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; white ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::White))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; yellow ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Yellow))
            };

            // Set background color
            ( @_INTERNAL style: $term:expr ; $result:expr ; # black ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Black))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # blue ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Blue))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # cyan ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Cyan))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # green ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Green))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # magenta ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Magenta))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # red ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Red))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # white ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::White))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # yellow ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Yellow))
            };

            // Add style
            ( @_INTERNAL style: $term:expr ; $result:expr ; bold ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($crate::Style::BOLD))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; italic ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($crate::Style::ITALIC))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; reverse ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($crate::Style::REVERSE))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; underline ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($crate::Style::UNDERLINE))
            };

            // Remove style
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! bold ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($crate::Style::BOLD))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! italic ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($crate::Style::ITALIC))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! reverse ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($crate::Style::REVERSE))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! underline ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($crate::Style::UNDERLINE))
            };

            // Clear attributes
            ( @_INTERNAL style: $term:expr ; $result:expr ; reset ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.clear_attributes())
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! fg ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg(None))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! bg ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg(None))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! style ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_style(None))
            };

            // Color/style expressions
            ( @_INTERNAL style: $term:expr ; $result:expr ; fg = $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($e))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; bg = $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($e))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; style = $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_style($e))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; style += $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($e))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; style -= $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($e))
            };
            ( @_INTERNAL style: $term:expr ; $result:expr ; theme = $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_theme($e))
            };

            // std::fmt formatting
            ( @_INTERNAL format: $term:expr ; $result:expr ; : $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || write!($term, "{}", $e))
            };
            ( @_INTERNAL format: $term:expr ; $result:expr ; ? $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || write!($term, "{:?}", $e))
            };
            ( @_INTERNAL format: $term:expr ; $result:expr ; $($tt:tt)* ) => {
                $crate::macros::Chain::chain(
                    $result, || write!($term, $($tt)*))
            };

            // Literal formatting
            ( @_INTERNAL literal: $term:expr ; $result:expr ; $lit:tt ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.write_str(concat!($lit)))
            };
        }
        /// Writes attributes and formatted text to a `Terminal` or `Screen`.
        #[macro_export] macro_rules! term_writeln
        {
            ( $term:expr ) => {
                term_write!($term, "\n")
            };
            ( $term:expr , $($tt:tt)* ) => {
                term_write!($term, $($tt)* "\n")
            };
        }
        // Facilitates chaining calls from either a `Terminal` or `Screen` lock.
        pub trait Chain: Sized
        
        {
            fn chain<F: FnOnce() -> Self>(self, f: F) -> Self;
            fn init() -> Self;
        }

        impl Chain for ()
        {
            fn chain<F: FnOnce() -> Self>(self, f: F) -> Self { f() }
            fn init() -> Self {}
        }

        impl Chain for io::Result<()>
        {
            fn chain<F: FnOnce() -> Self>(self, f: F) -> Self { self.and_then(|_| f()) }
            fn init() -> Self { Ok(()) }
        }
    }    

    pub mod screen
    {
        //! Provides a drawable buffer on terminal devices
        use ::
        {
            common::
            {
                terminal::{ Color, Cursor, CursorMode, Event, PrepareConfig, Size, Style, Theme, Terminal, },
            },
            sync::{ LockResult, TryLockResult, map_lock_result, map_try_lock_result },
            time::{ Duration },            
            *,
        }; use super::sys;
        /// Provides operations on an underlying terminal device in screen mode.
        pub struct Screen(sys::Screen);
        /// Holds an exclusive lock for read operations on a `Screen`
        pub struct ScreenReadGuard<'a>(sys::ScreenReadGuard<'a>);
        /// Holds an exclusive lock for write operations on a `Screen`
        pub struct ScreenWriteGuard<'a>(sys::ScreenWriteGuard<'a>);

        impl Screen 
        {
            /// Opens a new screen interface on `stdout`.
            pub fn new(config: PrepareConfig) -> io::Result<Screen> { sys::Screen::stdout(config).map(Screen) }
            /// Opens a new screen interface on `stderr`.
            pub fn stderr(config: PrepareConfig) -> io::Result<Screen> { sys::Screen::stderr(config).map(Screen) }
            /// Begins a new screen session using the given `Terminal` instance.
            pub fn with_terminal(term: Terminal, config: PrepareConfig) -> io::Result<Screen> 
            { sys::Screen::new(term.0, config).map(Screen) }
            /// Returns the name of the terminal.
            #[inline] pub fn name(&self) -> &str { self.0.name() }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn lock_read(&self) -> LockResult<ScreenReadGuard> 
            { map_lock_result(self.0.lock_read(), ScreenReadGuard) }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> 
            { map_lock_result(self.0.lock_write(), ScreenWriteGuard) }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> 
            { map_try_lock_result(self.0.try_lock_read(), ScreenReadGuard) }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard> 
            { map_try_lock_result(self.0.try_lock_write(), ScreenWriteGuard) }
        }
        /// # Locking
        /// The following methods internally acquire the read lock.
        impl Screen 
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> { self.0.wait_event(timeout) }
            /// Reads an event from the terminal.
            pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_event(timeout) }
        }
        /// # Locking
        ///
        /// The following methods internally acquire the write lock.
        impl Screen
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size { self.0.size() }
            /// Returns the current cursor position.
            #[inline] pub fn cursor(&self) -> Cursor { self.0.cursor() }
            /// Sets the cursor position.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&self, pos: C) { self.0.set_cursor(pos.into()); }
            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn next_line(&self, column: usize) { self.0.next_line(column); }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Clears the internal screen buffer.
            pub fn clear_screen(&self) { self.0.clear_screen(); }
            /// Adds a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&self, style: Style) { self.0.add_style(style); }
            /// Removes a set of `Style` flags to the current style setting.
            #[inline] pub fn remove_style(&self, style: Style) { self.0.remove_style(style); }
            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&self, style: S) 
            { 
                //self.0.set_style(style.into().unwrap_or_default()); 
            }
            /// Sets or removes foreground text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&self, fg: C) { self.0.set_fg(fg.into()); }
            /// Sets or removes background text color.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&self, bg: C) { self.0.set_bg(bg.into()); }
            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&self, theme: Theme) { self.0.set_theme(theme) }
            /// Removes color and style attributes.
            #[inline] pub fn clear_attributes(&self) { self.0.clear_attributes(); }
            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&self) { self.add_style(Style::BOLD); }
            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&self) { self.add_style(Style::ITALIC); }
            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&self) { self.add_style(Style::UNDERLINE); }
            /// Adds reverse to the current style setting.
            #[inline] pub fn reverse(&self) { self.add_style(Style::REVERSE); }
            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&self) -> io::Result<()> { self.0.refresh() }
            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&self, position: C, text: &str) where 
            C: Into<Cursor> { self.0.write_at(position.into(), text); }
            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { 
                //self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text); 
            }
            /// Writes text with the given attributes at the given position within the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&self, position: C,
            fg: F, bg: B, style: S, text: &str) where
            C: Into<Cursor>,
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { 
                //self.0.write_styled_at(position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text); 
            }
            /// Writes a single character at the cursor position using the current style and color settings.
            pub fn write_char(&self, ch: char) { self.0.write_char(ch); }
            /// Writes a string at the cursor position using the current style and color settings.
            pub fn write_str(&self, s: &str) { self.0.write_str(s); }
            /// Writes formatted text at the cursor position using the current style and color settings.
            pub fn write_fmt(&self, args: fmt::Arguments)
            {
                let s = args.to_string();
                self.write_str(&s)
            }
            
            pub fn borrow_term_write_guard(&self) -> ScreenWriteGuard { self.lock_write().unwrap() }
        }

        impl<'a> ScreenReadGuard<'a>
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> { self.0.wait_event(timeout) }
            /// Reads an event from the terminal.
            pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
            { self.0.read_event(timeout) }
        }

        impl<'a> ScreenWriteGuard<'a>
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size { self.0.size() }
            /// Sets the cursor position.
            #[inline] pub fn cursor(&self) -> Cursor { self.0.cursor() }
            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&mut self, pos: C) { self.0.set_cursor(pos.into()); }
            /// Set the current cursor mode.
            #[inline] pub fn next_line(&mut self, column: usize) { self.0.next_line(column); }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn clear_screen(&mut self) { self.0.clear_screen(); }
            /// Removes a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&mut self, style: Style) { self.0.add_style(style) }
            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn remove_style(&mut self, style: Style) { self.0.remove_style(style) }
            /// Sets or removes foreground text color.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&mut self, style: S) 
            { 
                // self.0.set_style(style.into().unwrap_or_default()) 
            }
            /// Sets or removes background text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&mut self, fg: C) { self.0.set_fg(fg.into()) }
            /// Removes color and style attributes.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&mut self, bg: C) { self.0.set_bg(bg.into()) }
            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&mut self, theme: Theme) { self.0.set_theme(theme) }
            /// Adds bold to the current style setting.
            #[inline] pub fn clear_attributes(&mut self) { self.0.clear_attributes() }
            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&mut self) { self.add_style(Style::BOLD) }
            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&mut self) { self.add_style(Style::ITALIC); }
            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&mut self) { self.add_style(Style::UNDERLINE) }
            /// Adds reverse to the current style setting.
            #[inline] pub fn reverse(&mut self) { self.add_style(Style::REVERSE) }
            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&mut self) -> io::Result<()> { self.0.refresh() }
            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&mut self, position: C, text: &str) where
            C: Into<Cursor> { self.0.write_at(position.into(), text) }
            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&mut self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { 
                //self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text) 
            }
            /// Writes text with the given attributes at the given position within the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&mut self, position: C,
            fg: F, bg: B, style: S, text: &str) where
            C: Into<Cursor>,
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { 
                // self.0.write_styled_at(position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text) 
            }
            /// Writes a single character at the cursor position using the current style and color settings.
            pub fn write_char(&mut self, ch: char) { self.0.write_char(ch) }
            /// Writes a string at the cursor position using the current style and color settings.
            pub fn write_str(&mut self, s: &str) { self.0.write_str(s) }
            /// Writes formatted text at the cursor position using the current style and color settings.
            pub fn write_fmt(&mut self, args: fmt::Arguments)
            {
                let s = args.to_string();
                self.write_str(&s)
            }
            
            pub fn borrow_term_write_guard(&mut self) -> &mut Self { self }
        }
    } pub use self::screen::{ Screen, ScreenReadGuard, ScreenWriteGuard };

    pub mod sequence
    {
        //! Utilities for manipulating raw input sequences
        use ::
        {
            iter::{ FromIterator },
            mem::{ replace },
            *,
        };
        /// Contains a set of string sequences, mapped to a value.
        #[derive(Clone, Debug, Default)]
        pub struct SequenceMap<K, V>
        {
            sequences: Vec<(K, V)>,
        }
        /// Represents the result of a `SequenceMap::find` operation.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum FindResult<V>
        {
            /// No contained sequences begin with the provided input sequence.
            NotFound,
            /// One or more sequences begin with the provided input sequence,
            /// but the sequence does not represent a complete sequence.
            Incomplete,
            /// A sequence was found exactly matching the input sequence;
            Undecided(V),
            /// A sequence was found exactly matching the input sequence;
            Found(V),
        }

        impl<'a, V: Clone> FindResult<&'a V>
        {
            /// Maps `FindResult<&V>` to `FindResult<V>` by cloning the contents of the result value.
            pub fn cloned(self) -> FindResult<V>
            {
                match self
                {
                    FindResult::NotFound => FindResult::NotFound,
                    FindResult::Incomplete => FindResult::Incomplete,
                    FindResult::Undecided(v) => FindResult::Undecided(v.clone()),
                    FindResult::Found(v) => FindResult::Found(v.clone()),
                }
            }
        }

        impl<K: AsRef<str>, V> SequenceMap<K, V>
        {
            /// Creates an empty `SequenceMap`.
            pub fn new() -> SequenceMap<K, V> { SequenceMap::with_capacity(0) }
            /// Creates an empty `SequenceMap` with allocated capacity for `n` elements.
            pub fn with_capacity(n: usize) -> SequenceMap<K, V>
            {
                SequenceMap
                {
                    sequences: Vec::with_capacity(n),
                }
            }
            /// Returns a slice of all contained sequences, sorted by key.
            pub fn sequences(&self) -> &[(K, V)] { &self.sequences }
            /// Returns a mutable slice of all contained sequences, sorted by key.
            pub fn sequences_mut(&mut self) -> &mut [(K, V)] { &mut self.sequences }
            /// Returns an `Entry` for the given key.
            pub fn entry(&mut self, key: K) -> Entry<K, V>
            {
                match self.search(key.as_ref())
                {
                    Ok(n) => Entry::Occupied(OccupiedEntry
                    {
                        map: self,
                        index: n,
                    }),
                    
                    Err(n) => Entry::Vacant(VacantEntry
                    {
                        map: self,
                        key,
                        index: n,
                    })
                }
            }
            /// Performs a search for a partial or complete sequence match.
            pub fn find(&self, key: &str) -> FindResult<&V>
            {
                let (n, found) = match self.search(key)
                {
                    Ok(n) => (n, true),
                    Err(n) => (n, false)
                };

                let incomplete = self.sequences
                .get(n + (found as usize))
                .map_or(false, |&(ref next, _)| next.as_ref().starts_with(key));

                match (found, incomplete)
                {
                    (false, false) => FindResult::NotFound,
                    (false, true) => FindResult::Incomplete,
                    (true, false) => FindResult::Found(&self.sequences[n].1),
                    (true, true) => FindResult::Undecided(&self.sequences[n].1),
                }
            }
            /// Returns the corresponding value for the given sequence.
            pub fn get(&self, key: &str) -> Option<&V>
            {
                match self.search(key)
                {
                    Ok(n) => Some(&self.sequences[n].1),
                    Err(_) => None
                }
            }
            /// Returns a mutable reference to the corresponding value for the given sequence.
            pub fn get_mut(&mut self, key: &str) -> Option<&mut V>
            {
                match self.search(key)
                {
                    Ok(n) => Some(&mut self.sequences[n].1),
                    Err(_) => None
                }
            }
            /// Inserts a key-value pair into the map.
            pub fn insert(&mut self, key: K, value: V) -> Option<V>
            {
                match self.search(key.as_ref())
                {
                    Ok(n) => Some(replace(&mut self.sequences[n], (key, value)).1),
                    Err(n) =>
                    {
                        self.sequences.insert(n, (key, value));
                        None
                    }
                }
            }
            /// Removes a key-value pair from the map.
            pub fn remove(&mut self, key: &str) -> Option<(K, V)>
            {
                match self.search(key)
                {
                    Ok(n) => Some(self.sequences.remove(n)),
                    Err(_) => None
                }
            }

            fn search(&self, key: &str) -> Result<usize, usize>
            { self.sequences.binary_search_by_key(&key, |&(ref k, _)| &k.as_ref()) }
        }

        impl<K: AsRef<str>, V> From<Vec<(K, V)>> for SequenceMap<K, V>
        {
            /// Creates a `SequenceMap` from a `Vec` of key-value pairs.
            fn from(mut sequences: Vec<(K, V)>) -> SequenceMap<K, V>
            {
                sequences.sort_by(|a, b| a.0.as_ref().cmp(b.0.as_ref()));
                sequences.dedup_by(|a, b| a.0.as_ref() == b.0.as_ref());
                SequenceMap{sequences}
            }
        }

        impl<K: AsRef<str>, V> FromIterator<(K, V)> for SequenceMap<K, V>
        {
            /// Creates a `SequenceMap` from an iterator of key-value pairs.
            fn from_iter<I: IntoIterator<Item=(K, V)>>(iter: I) -> Self
            {
                let iter = iter.into_iter();
                let mut map = SequenceMap::with_capacity(iter.size_hint().0);

                for (k, v) in iter
                {
                    map.insert(k, v);
                }

                map
            }
        }
        /// A view into a single entry of a `SequenceMap`, which may be either occupied or vacant.
        pub enum Entry<'a, K: 'a, V: 'a>
        {
            /// An occupied entry
            Occupied(OccupiedEntry<'a, K, V>),
            /// A vacant entry
            Vacant(VacantEntry<'a, K, V>),
        }
        /// A view into an occupied entry in a `SequenceMap`.
        pub struct OccupiedEntry<'a, K: 'a, V: 'a>
        {
            map: &'a mut SequenceMap<K, V>,
            index: usize,
        }
        /// A view into a vacant entry in a `SequenceMap`.
        pub struct VacantEntry<'a, K: 'a, V: 'a>
        {
            map: &'a mut SequenceMap<K, V>,
            key: K,
            index: usize,
        }

        impl<'a, K, V> Entry<'a, K, V>
        {
            /// Provides in-place mutable access to an occupied entry before any potential inserts into the map.
            pub fn and_modify<F: FnOnce(&mut V)>(self, f: F) -> Self
            {
                match self
                {
                    Entry::Occupied(mut ent) =>
                    {
                        f(ent.get_mut());
                        Entry::Occupied(ent)
                    }
                    
                    Entry::Vacant(ent) => Entry::Vacant(ent)
                }
            }
            /// Returns a mutable reference to the entry value, inserting the provided default if the entry is vacant.
            pub fn or_insert(self, default: V) -> &'a mut V
            {
                match self
                {
                    Entry::Occupied(ent) => ent.into_mut(),
                    Entry::Vacant(ent) => ent.insert(default)
                }
            }
            /// Returns a mutable reference to the entry value, 
            /// inserting a value with the closure if the entry is vacant.
            pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V
            {
                match self
                {
                    Entry::Occupied(ent) => ent.into_mut(),
                    Entry::Vacant(ent) => ent.insert(default())
                }
            }
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K
            {
                match *self
                {
                    Entry::Occupied(ref ent) => ent.key(),
                    Entry::Vacant(ref ent) => ent.key(),
                }
            }
        }

        impl<'a, K, V> OccupiedEntry<'a, K, V>
        {
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K { &self.map.sequences[self.index].0 }
            /// Returns a borrowed reference to the entry value.
            pub fn get(&self) -> &V { &self.map.sequences[self.index].1 }
            /// Returns a mutable reference to the entry value.
            pub fn get_mut(&mut self) -> &mut V { &mut self.map.sequences[self.index].1 }
            /// Converts the `OccupiedEntry` into a mutable reference whose lifetime is bound to the `SequenceMap`.
            pub fn into_mut(self) -> &'a mut V { &mut self.map.sequences[self.index].1 }
            /// Replaces the entry value with the given value, returning the previous value.
            pub fn insert(&mut self, value: V) -> V { replace(self.get_mut(), value) }
            /// Removes the entry and returns the value.
            pub fn remove(self) -> V { self.map.sequences.remove(self.index).1 }
            /// Removes the entry and returns the key-value pair.
            pub fn remove_entry(self) -> (K, V) { self.map.sequences.remove(self.index) }
        }

        impl<'a, K, V> VacantEntry<'a, K, V>
        {
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K { &self.key }
            /// Consumes the `VacantEntry` and returns ownership of the key.
            pub fn into_key(self) -> K { self.key }
            /// Consumes the `VacantEntry` and inserts a value, 
            /// returning a mutable reference to its place in the `SequenceMap`.
            pub fn insert(self, value: V) -> &'a mut V
            {
                self.map.sequences.insert(self.index, (self.key, value));
                &mut self.map.sequences[self.index].1
            }
        }

        impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for Entry<'a, K, V>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                match *self
                {
                    Entry::Occupied(ref ent) => f.debug_tuple("Entry").field(ent).finish(),
                    Entry::Vacant(ref ent) => f.debug_tuple("Entry").field(ent).finish()
                }
            }
        }

        impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for OccupiedEntry<'a, K, V>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                f.debug_struct("OccupiedEntry")
                .field("key", self.key())
                .field("value", self.get())
                .finish()
            }
        }

        impl<'a, K: fmt::Debug, V> fmt::Debug for VacantEntry<'a, K, V>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                f.debug_tuple("VacantEntry")
                .field(self.key())
                .finish()
            }
        }
    } pub use self::sequence::{ FindResult, SequenceMap };
    
    pub mod signal
    {
        //! Contains types relating to operating system signals
        use ::
        {
            iter::{ FromIterator },
            *,
        };

        macro_rules! impl_op 
        {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    type Output = SignalSet;

                    fn $tr_meth(self, rhs: SignalSet) -> SignalSet {
                        self.$method(rhs)
                    }
                }
            }
        }

        macro_rules! impl_mut_op 
        {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    fn $tr_meth(&mut self, rhs: SignalSet) {
                        *self = self.$method(rhs);
                    }
                }
            }
        }

        macro_rules! impl_unary_op 
        {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    type Output = SignalSet;

                    fn $tr_meth(self) -> SignalSet {
                        self.$method()
                    }
                }
            }
        }
        /// Signal received through a terminal device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Signal
        {
            /// Break signal (`CTRL_BREAK_EVENT`); Windows only
            Break,
            /// Continue signal (`SIGCONT`); Unix only
            Continue,
            /// Interrupt signal (`SIGINT` on Unix, `CTRL_C_EVENT` on Windows)
            Interrupt,
            /// Terminal window resize (`SIGWINCH` on Unix, `WINDOW_BUFFER_SIZE_EVENT` on Windows)
            Resize,
            /// Suspend signal (`SIGTSTP`); Unix only
            Suspend,
            /// Quit signal (`SIGQUIT`); Unix only
            Quit,
        }

        const NUM_SIGNALS: u8 = 6;

        impl Signal 
        {
            fn as_bit(&self) -> u8 { 1 << (*self as u8) }
            fn all_bits() -> u8 { (1 << NUM_SIGNALS) - 1 }
        }

        impl ops::BitOr for Signal 
        {
            type Output = SignalSet;

            fn bitor(self, rhs: Signal) -> SignalSet 
            {
                let mut set = SignalSet::new();

                set.insert(self);
                set.insert(rhs);
                set
            }
        }

        impl ops::Not for Signal 
        {
            type Output = SignalSet;
            fn not(self) -> SignalSet { !SignalSet::from(self) }
        }
        /// Represents a set of `Signal` values
        #[derive(Copy, Clone, Default, Eq, PartialEq)]
        pub struct SignalSet(u8);

        impl SignalSet
        {
            /// Returns an empty `SignalSet`.
            pub fn new() -> SignalSet { SignalSet(0) }
            /// Returns a `SignalSet` containing all available signals.
            pub fn all() -> SignalSet { SignalSet(Signal::all_bits()) }
            /// Returns whether this set contains the given `Signal`.
            pub fn contains(&self, sig: Signal) -> bool { self.0 & sig.as_bit() != 0 }
            /// Returns whether this set contains all signals present in another set.
            pub fn contains_all(&self, other: SignalSet) -> bool { self.0 & other.0 == other.0 }
            /// Returns whether this set contains any signals present in another set.
            pub fn intersects(&self, other: SignalSet) -> bool { self.0 & other.0 != 0 }
            /// Returns whether this set contains any signals.
            pub fn is_empty(&self) -> bool { self.0 == 0 }
            /// Inserts a `Signal` into this set.
            pub fn insert(&mut self, sig: Signal) { self.0 |= sig.as_bit(); }
            /// Removes a `Signal` from this set.
            pub fn remove(&mut self, sig: Signal) { self.0 &= !sig.as_bit(); }
            /// Sets whether this set contains the given `Signal`.
            pub fn set(&mut self, sig: Signal, set: bool) { if set { self.insert(sig); } else { self.remove(sig); } }
            /// Returns the difference of two sets.
            pub fn difference(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 & !other.0) }
            /// Returns the symmetric difference of two sets.
            pub fn symmetric_difference(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 ^ other.0) }
            /// Returns the intersection of two sets.
            pub fn intersection(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 & other.0) }
            /// Returns the union of two sets.
            pub fn union(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 | other.0) }
            /// Returns the inverse of the set.
            pub fn inverse(&self) -> SignalSet { SignalSet(!self.0 & Signal::all_bits()) }
        }

        impl fmt::Debug for SignalSet
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
            {
                const SIGNALS: &[Signal] = &[
                    Signal::Break,
                    Signal::Continue,
                    Signal::Interrupt,
                    Signal::Resize,
                    Signal::Suspend,
                    Signal::Quit,
                ];

                let mut first = true;

                f.write_str("SignalSet(")?;

                for &sig in SIGNALS {
                    if self.contains(sig) {
                        if !first {
                            f.write_str(" | ")?;
                        }

                        write!(f, "{:?}", sig)?;
                        first = false;
                    }
                }

                f.write_str(")")
            }
        }

        impl From<Signal> for SignalSet 
        {
            fn from(sig: Signal) -> SignalSet 
            {
                let mut set = SignalSet::new();
                set.insert(sig);
                set
            }
        }

        impl Extend<Signal> for SignalSet 
        {
            fn extend<I: IntoIterator<Item=Signal>>(&mut self, iter: I)
            {
                for sig in iter {
                    self.insert(sig);
                }
            }
        }

        impl FromIterator<Signal> for SignalSet 
        {
            fn from_iter<I: IntoIterator<Item=Signal>>(iter: I) -> SignalSet
            {
                let mut set = SignalSet::new();
                set.extend(iter);
                set
            }
        }

        impl_op!{ BitAnd, bitand, intersection }
        impl_op!{ BitOr, bitor, union }
        impl_op!{ BitXor, bitxor, symmetric_difference }
        impl_op!{ Sub, sub, difference }

        impl_unary_op!{ Not, not, inverse }

        impl_mut_op!{ BitAndAssign, bitand_assign, intersection }
        impl_mut_op!{ BitOrAssign, bitor_assign, union }
        impl_mut_op!{ BitXorAssign, bitxor_assign, symmetric_difference }
        impl_mut_op!{ SubAssign, sub_assign, difference }
    } pub use self::signal::{Signal, SignalSet};
    
    pub mod terminal
    {
        //! Provides an interface to terminal devices
        use ::
        {
            common::signal::{Signal, SignalSet},
            sync::{LockResult, TryLockResult, map_lock_result, map_try_lock_result },
            time::{ Duration },
            *,
        };
        /// Represents a color attribute applied to text foreground or background.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Color 
        {
            /// Black
            Black,
            /// Blue
            Blue,
            /// Cyan
            Cyan,
            /// Green
            Green,
            /// Magenta
            Magenta,
            /// Red
            Red,
            /// White
            White,
            /// Yellow
            Yellow,
        }

        #[repr( u8 )] #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
        pub enum Style
        {
            BOLD = 0,
            ITALIC = 1,
            REVERSE = 2,
            UNDERLINE = 3,
            NORMAL = 4,
            EMPTY = 5,
        }

        impl Style
        {
            pub fn empty() -> Self
            {
                Self::EMPTY
            }
        }
        /*
        bitflags!
        {
            /// Represents a set of style attributes applied to text.
            #[derive( Copy, Clone, Debug, Default, Eq, PartialEq, Hash )]
            pub struct Style: u8 
            {
                /// Bold
                const BOLD      = 1 << 0;
                /// Italic
                const ITALIC    = 1 << 1;
                /// Reverse; foreground and background color swapped
                const REVERSE   = 1 << 2;
                /// Underline
                const UNDERLINE = 1 << 3;
            }
        } */
        /// Represents a terminal output theme.
        #[derive( Copy, Clone, Debug, Default )]
        pub struct Theme 
        {
            /// Foreground color
            pub fg: Option<Color>,
            /// Background color
            pub bg: Option<Color>,
            /// Style
            pub style: Option<Style>,
        }

        impl Theme 
        {
            /// Creates a new theme with given values.
            pub fn new<F,B,S>(fg: F, bg: B, style: S) -> Theme where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>
            {
                Theme
                {
                    fg: fg.into(),
                    bg: bg.into(),
                    style: style.into(),
                }
            }
            /// Sets the foreground color on the given Theme and returns the new.
            pub fn fg<F>(mut self, fg: F) -> Theme where 
            F:Into<Option<Color>>
            {
                self.fg = fg.into();
                self
            }
            /// Sets the background color on the given Theme and returns the new.
            pub fn bg<B>(mut self, bg: B) -> Theme where B: Into<Option<Color>>
            {
                self.bg = bg.into();
                self
            }
            /// Sets the style on the given Theme and returns the new.
            pub fn style<S>(mut self, style: S) -> Theme where S: Into<Option<Style>>
            {
                self.style = style.into();
                self
            }
        }
        /// Represents the cursor position in a terminal device
        #[derive( Copy, Clone, Debug, Default, Eq, PartialEq )]
        pub struct Cursor
        {
            /// Index of line in terminal, beginning at `0`.
            pub line: usize,
            /// Index of column in terminal, beginning at `0`.
            pub column: usize,
        }

        impl Cursor
        {
            /// Returns the position of the next cell within a terminal of the given size.
            #[inline] pub fn next(&self, size: Size) -> Option<Cursor>
            {
                let mut line = self.line;
                let mut column = self.column + 1;

                if column >= size.columns
                {
                    column = 0;
                    line += 1;
                }

                if line >= size.lines { None } else { Some(Cursor{line, column}) }
            }
            /// Returns the position of the previous cell within a terminal of the given size.
            ///
            /// Returns `None` if this cursor position represents the first cell.
            #[inline] pub fn previous(&self, size: Size) -> Option<Cursor>
            {
                if self.column == 0
                {
                    if self.line == 0 { None } else { Some(Cursor{line: self.line - 1, column: size.columns - 1}) }
                }
                else { Some(Cursor{line: self.line, column: self.column - 1}) }
            }
            /// Returns a `Cursor` pointing to the first cell, i.e. `(0, 0)`.
            #[inline] pub fn first() -> Cursor
            {
                Cursor
                {
                    line: 0,
                    column: 0,
                }
            }
            /// Returns a `Cursor` pointing to the last cell of a screen of the given size.
            #[inline] pub fn last(size: Size) -> Cursor
            {
                Cursor
                {
                    line: size.lines - 1,
                    column: size.columns - 1,
                }
            }
            /// Returns whether the cursor is out of bounds of the given size.
            #[inline] pub fn is_out_of_bounds(&self, size: Size) -> bool
            { self.line >= size.lines || self.column >= size.columns }
            /// Returns the index of the cursor position within a one-dimensional array of the given size.
            pub fn as_index(&self, size: Size) -> usize { self.line * size.columns + self.column }
        }

        impl From<(usize, usize)> for Cursor
        {
            /// Returns a `Cursor` value from a `(line, column)` or `(y, x)` tuple.
            fn from((line, column): (usize, usize)) -> Cursor { Cursor{line, column} }
        }
        /// Represents the visual appearance of the cursor in the terminal
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum CursorMode
        {
            /// Normal mode
            Normal,
            /// Invisible mode
            Invisible,
            /// Overwrite mode
            Overwrite,
        }
        /// Represents an event generated from a terminal interface
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Event
        {
            /// Keyboard event
            Key(Key),
            /// Mouse event
            Mouse(Mouse),
            /// Raw data read
            Raw(usize),
            /// Terminal window size changed; contained value is the new size.
            Resize(Size),
            /// Terminal signal received
            Signal(Signal),
            /// No event
            NoEvent,
        }
        /// Represents a keyboard key press event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Key
        {
            /// Backspace
            Backspace,
            /// Enter
            Enter,
            /// Escape
            Escape,
            /// Tab
            Tab,
            /// Up arrow
            Up,
            /// Down arrow
            Down,
            /// Left arrow
            Left,
            /// Right arrow
            Right,
            /// Delete
            Delete,
            /// Insert
            Insert,
            /// Home
            Home,
            /// End
            End,
            /// PageUp
            PageUp,
            /// PageDown
            PageDown,
            /// Character key
            Char(char),
            /// Control character
            Ctrl(char),
            /// Function `n` key; e.g. F1, F2, ...
            F(u32),
        }

        impl From<char> for Key
        {
            fn from(ch: char) -> Key
            {
                match ch
                {
                    '\x1b' => Key::Escape,
                    '\x7f' => Key::Backspace,
                    '\r' | '\n' => Key::Enter,
                    '\t' => Key::Tab,
                    _ if is::ctrl(ch) => Key::Ctrl( char::unctrl_lower(ch)),
                    _ => Key::Char(ch),
                }
            }
        }
        /// Represents a mouse event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct Mouse
        {
            /// The position of the mouse within the terminal when the event occurred
            pub position: Cursor,
            /// The input event that occurred
            pub input: MouseInput,
            /// Modifier keys held when the input event occurred.
            pub modifiers: ModifierState,
        }
        /// Represents the type of mouse input event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseInput
        {
            /// The mouse cursor was moved
            Motion,
            /// A mouse button was pressed
            ButtonPressed(MouseButton),
            /// A mouse button was released
            ButtonReleased(MouseButton),
            /// The mouse wheel was scrolled up
            WheelUp,
            /// The mouse wheel was scrolled down
            WheelDown,
        }
        /// Represents a button on a mouse device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseButton
        {
            /// Left mouse button
            Left,
            /// Right mouse button
            Right,
            /// Middle mouse button
            Middle,
            /// Other mouse button
            Other(u32),
        }
        /// Represents a set of modifier keys
        #[repr( u8 )] #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
        pub enum ModifierState
        {
            /// Alt key
            ALT = 0,//const ALT   = 1 << 0;
            /// Ctrl key
            CTRL = 1,//const CTRL  = 1 << 1;
            /// Shift key
            SHIFT = 2,//const SHIFT = 1 << 2;
        }
        /*
        bitflags!
        {
            /// Represents a set of modifier keys
            #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
            pub struct ModifierState: u8 
            {
                /// Alt key
                const ALT   = 1 << 0;
                /// Ctrl key
                const CTRL  = 1 << 1;
                /// Shift key
                const SHIFT = 1 << 2;
            }
        } */
        /// Configures a [`Terminal`] or [`Screen`] instance to read special input.
        #[derive(Copy, Clone, Debug)]
        pub struct PrepareConfig
        {
            /// Whether to block signals that result from user input.
            pub block_signals: bool,
            /// Whether to enable control flow characters.
            pub enable_control_flow: bool,
            /// If `true`, the terminal will be configured to generate events from function keys.
            pub enable_keypad: bool,
            /// If `true`, the terminal will be configured to generate events for
            /// mouse input, if supported, and `read_event` may return `Event::Mouse(_)`.
            pub enable_mouse: bool,
            /// If `true`, mouse motion events will always be reported.
            pub always_track_motion: bool,
            /// For each signal in the set, a signal handler will intercept the signal
            /// and report it by returning an `Event::Signal(_)` value.
            pub report_signals: SignalSet,
        }

        impl Default for PrepareConfig
        {
            fn default() -> PrepareConfig
            {
                PrepareConfig
                {
                    block_signals: true,
                    enable_control_flow: false,
                    enable_keypad: true,
                    enable_mouse: false,
                    always_track_motion: false,
                    report_signals: SignalSet::new(),
                }
            }
        }
        /// Represents a previous device state of a [`Terminal`].
        #[must_use = "the result of `terminal.prepare()` should be passed to \
            `terminal.restore()` to restore terminal to its original state"]
        pub struct PrepareState(::common::sys::PrepareState);
        /// Represents the size of a terminal window
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct Size
        {
            /// Number of lines in the terminal
            pub lines: usize,
            /// Number of columns in the terminal
            pub columns: usize,
        }

        impl Size
        {
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn area(&self) -> usize 
            { self.checked_area().unwrap_or_else( || panic!("overflow in Size::area {:?}", self)) }
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn checked_area(&self) -> Option<usize> { self.lines.checked_mul(self.columns) }
        }
        /// Provides concurrent read and write access to a terminal device.
        pub struct Terminal(pub ::common::sys::Terminal );
        /// Holds an exclusive lock for read operations on a `Terminal`
        pub struct TerminalReadGuard<'a>( ::common::sys::TerminalReadGuard<'a> );
        /// Holds an exclusive lock for write operations on a `Terminal`.
        pub struct TerminalWriteGuard<'a>( ::common::sys::TerminalWriteGuard<'a> );

        impl Terminal
        {
            /// Opens a new interface to the terminal on `stdout`.
            pub fn new() -> io::Result<Terminal> { Ok(Terminal( super::sys::Terminal::stdout()? )) }
            /// Opens a new interface to the terminal on `stderr`.
            pub fn stderr() -> io::Result<Terminal> { Ok(Terminal( super::sys::Terminal::stderr()? )) }
            /// Returns the name of the terminal.
            #[inline] pub fn name(&self) -> &str { self.0.name() }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn lock_read(&self) -> LockResult<TerminalReadGuard>
            { map_lock_result(self.0.lock_read(), TerminalReadGuard) }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn lock_write(&self) -> LockResult<TerminalWriteGuard>
            { map_lock_result(self.0.lock_write(), TerminalWriteGuard) }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard>
            { map_try_lock_result(self.0.try_lock_read(), TerminalReadGuard) }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard>
            { map_try_lock_result(self.0.try_lock_write(), TerminalWriteGuard) }
        }
        /// # Locking
        /// The following methods internally acquire both the read and write locks.
        impl Terminal
        {
            /*
            /// Prepares the terminal to read input.
            pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState>
            { self.0.prepare(config).map(PrepareState)  } */
            /// Restores the terminal to its previous state.
            pub fn restore(&self, state: PrepareState) -> io::Result<()> { self.0.restore(state.0) }
        }
        /// # Locking
        /// The following methods internally acquire the read lock.
        impl Terminal
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> { self.0.wait_event(timeout) }
            /// Waits for input and reads an event from the terminal.
            pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_event(timeout) }
        }
        /// # Locking
        /// The following methods internally acquire the write lock.
        impl Terminal
        {
            /// Returns the size of the terminal.
            #[inline] pub fn size(&self) -> io::Result<Size> { self.0.size() }
            /// Clears the terminal screen, placing the cursor at the first line and column.
            pub fn clear_screen(&self) -> io::Result<()> { self.0.clear_screen() }
            /// Clears the current line, starting at cursor position.
            pub fn clear_to_line_end(&self) -> io::Result<()> { self.0.clear_to_line_end() }
            /// Clears the screen, starting at cursor position.
            pub fn clear_to_screen_end(&self) -> io::Result<()> { self.0.clear_to_screen_end() }
            /// Moves the cursor up `n` lines.
            pub fn move_up(&self, n: usize) -> io::Result<()> { self.0.move_up(n) }
            /// Moves the cursor down `n` lines.
            pub fn move_down(&self, n: usize) -> io::Result<()> { self.0.move_down(n) }
            /// Moves the cursor left `n` columns.
            pub fn move_left(&self, n: usize) -> io::Result<()> { self.0.move_left(n) }
            /// Moves the cursor right `n` columns.
            pub fn move_right(&self, n: usize) -> io::Result<()> { self.0.move_right(n) }
            /// Moves the cursor to the first column of the current line
            pub fn move_to_first_column(&self) -> io::Result<()> { self.0.move_to_first_column() }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn add_style(&self, style: Style) -> io::Result<()> { self.0.add_style(style) }
            /// Removes a set of `Style` flags from the current style setting.
            pub fn remove_style(&self, style: Style) -> io::Result<()> { self.0.remove_style(style) }
            /// Sets the current style to the given set of flags.
            pub fn set_style<S>(&self, style: S) -> ::io::Result<()> where 
            S: Into<Option<Style>> 
            { 
                //self.0.set_style(style.into().unwrap_or_default()) 
                Ok(())
            }
            /// Sets all attributes for the terminal.
            pub fn set_theme(&self, theme: Theme) -> io::Result<()> { self.0.set_theme(theme) }
            /// Sets the foreground text color.
            pub fn set_fg<C: Into<Option<Color>>>(&self, fg: C) -> io::Result<()> { self.0.set_fg(fg.into()) }
            /// Sets the background text color.
            pub fn set_bg<C: Into<Option<Color>>>(&self, bg: C) -> io::Result<()> { self.0.set_bg(bg.into()) }
            /// Removes color and style attributes.
            pub fn clear_attributes(&self) -> io::Result<()> { self.0.clear_attributes() }
            /// Adds bold to the current style setting.
            pub fn bold(&self) -> io::Result<()> { self.add_style(Style::BOLD) }
            /// Adds italic to the current style setting.
            pub fn italic(&self) -> io::Result<()> { self.add_style(Style::ITALIC) }
            /// Adds underline to the current style setting.
            pub fn underline(&self) -> io::Result<()> { self.add_style(Style::UNDERLINE) }
            /// Adds reverse to the current style setting.
            pub fn reverse(&self) -> io::Result<()> { self.add_style(Style::REVERSE) }
            /// Writes output to the terminal with the given color and style.
            pub fn write_styled<F, B, S>(&self, fg: F, bg: B, style: S, s: &str) -> io::Result<()> where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>
            { 
                // self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), s) 
                Ok(())
            }
            /// Writes a single character to the terminal using the current style and color settings.
            pub fn write_char(&self, ch: char) -> io::Result<()> { self.0.write_char(ch) }
            /// Writes a string to the terminal using the current style and color settings.
            pub fn write_str(&self, s: &str) -> io::Result<()> { self.0.write_str(s) }
            /// Writes formatted text to the terminal using the current style and color settings.
            pub fn write_fmt(&self, args: fmt::Arguments) -> io::Result<()>
            {
                let s = args.to_string();
                self.write_str(&s)
            }
            
            pub fn borrow_term_write_guard(&self) -> TerminalWriteGuard { self.lock_write().unwrap() }
        }

        impl<'a> TerminalReadGuard<'a>
        {
            /*
            /// Prepares the terminal to read input.
            pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState>
            { self.0.prepare(config).map(PrepareState) }
            /// Performs terminal preparation using both [`Terminal`] locks.
            pub fn prepare_with_lock(&mut self, writer: &mut TerminalWriteGuard, config: PrepareConfig) -> 
            io::Result<PrepareState>
            { self.0.prepare_with_lock(&mut writer.0, config).map(PrepareState) } */
            /// Restores the terminal to its previous state.
            pub fn restore(&mut self, state: PrepareState) -> io::Result<()> { self.0.restore(state.0) }
            /// Performs terminal state restoration using both [`Terminal`] locks.
            pub fn restore_with_lock(&mut self, writer: &mut TerminalWriteGuard, state: PrepareState) 
            -> io::Result<()>
            { self.0.restore_with_lock(&mut writer.0, state.0) }
            /// Waits for an event from the terminal.
            pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> { self.0.wait_event(timeout) }
            /// Waits for input and reads an event from the terminal.
            pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> { self.0.read_event(timeout) }
        }

        impl<'a> TerminalWriteGuard<'a> 
        {
            /// Flush all output to the terminal device.
            pub fn flush(&mut self) -> io::Result<()> { self.0.flush() }
            /// Returns the size of the terminal.
            #[inline] pub fn size(&self) -> io::Result<Size> { self.0.size() }
            /// Clears the terminal screen, placing the cursor at the first line and column.
            pub fn clear_screen(&mut self) -> io::Result<()> { self.0.clear_screen() }
            /// Clears the current line, starting at cursor position.
            pub fn clear_to_line_end(&mut self) -> io::Result<()> { self.0.clear_to_line_end() }
            /// Clears the screen, starting at cursor position.
            pub fn clear_to_screen_end(&mut self) -> io::Result<()> { self.0.clear_to_screen_end() }
            /// Moves the cursor up `n` lines.
            pub fn move_up(&mut self, n: usize) -> io::Result<()> { self.0.move_up(n) }
            /// Moves the cursor down `n` lines.
            pub fn move_down(&mut self, n: usize) -> io::Result<()> { self.0.move_down(n) }
            /// Moves the cursor left `n` columns.
            pub fn move_left(&mut self, n: usize) -> io::Result<()> { self.0.move_left(n) }
            /// Moves the cursor right `n` columns.
            pub fn move_right(&mut self, n: usize) -> io::Result<()> { self.0.move_right(n) }
            /// Moves the cursor to the first column of the current line
            pub fn move_to_first_column(&mut self) -> io::Result<()> { self.0.move_to_first_column() }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn add_style(&mut self, style: Style) -> io::Result<()> { self.0.add_style(style) }
            /// Removes a set of `Style` flags from the current style setting.
            pub fn remove_style(&mut self, style: Style) -> io::Result<()> { self.0.remove_style(style) }
            /// Sets the current style to the given set of flags.
            pub fn set_style<S>(&mut self, style: S) -> ::io::Result<()> where
            S: Into<Option<Style>> 
            { 
                //self.0.set_style(style.into().unwrap_or_default())
                Ok(())
            }
            /// Sets all attributes for the terminal.
            pub fn set_theme(&mut self, theme: Theme) -> io::Result<()> { self.0.set_theme(theme) }
            /// Sets the background text color.
            pub fn set_fg<C: Into<Option<Color>>>(&mut self, fg: C) -> io::Result<()> { self.0.set_fg(fg.into()) }
            /// Removes color and style attributes.
            pub fn set_bg<C: Into<Option<Color>>>(&mut self, bg: C) -> io::Result<()> { self.0.set_bg(bg.into()) }
            /// Adds bold to the current style setting.
            pub fn clear_attributes(&mut self) -> io::Result<()> { self.0.clear_attributes() }
            /// Adds bold to the current style setting.
            pub fn bold(&mut self) -> io::Result<()> { self.add_style(Style::BOLD) }
            /// Adds italic to the current style setting.
            pub fn italic(&mut self) -> io::Result<()> { self.add_style(Style::ITALIC) }
            /// Adds underline to the current style setting.
            pub fn underline(&mut self) -> io::Result<()> { self.add_style(Style::UNDERLINE) }
            /// Adds reverse to the current style setting.
            pub fn reverse(&mut self) -> io::Result<()> { self.add_style(Style::REVERSE) }
            /// Writes output to the terminal with the given color and style added.
            pub fn write_styled<F, B, S>(&mut self, fg: F, bg: B, style: S, s: &str) -> io::Result<()> where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>
            {
                //self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), s)
                Ok(())
            }
            /// Writes a single character to the terminal using the current style and color settings.
            pub fn write_char(&mut self, ch: char) -> io::Result<()> { self.0.write_char(ch) }
            /// Writes a string to the terminal using the current style and color settings.
            pub fn write_str(&mut self, s: &str) -> io::Result<()> { self.0.write_str(s) }
            /// Writes formatted text to the terminal using the current style and color settings.
            pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()>
            {
                let s = args.to_string();
                self.write_str(&s)
            }
            
            pub fn borrow_term_write_guard(&mut self) -> &mut Self { self }
        }
    } pub use self::terminal::
    {
        Color, Cursor, CursorMode, Size, Style, Theme, Event, Key, Mouse, MouseInput, MouseButton, ModifierState,
        PrepareConfig, PrepareState, Terminal, TerminalReadGuard, TerminalWriteGuard,
    };

    pub mod system
    {
        pub mod unix
        {
            use ::
            {
                path::{ Path },
                time::{ Duration },
                *,
            };
            
            pub mod ext
            {
                //! Unix extension trait
                use ::
                {
                    common::{ Event },
                    path::{ Path },
                    time::{ Duration },
                    *,
                };
                /// Implements Unix-only extensions for terminal interfaces.
                pub trait OpenTerminalExt: Sized
                {
                    /// Opens a terminal interface on the device at the given path.
                    fn from_path<P: AsRef<Path>>(path: P) -> io::Result<Self>;
                }
                /// Implements Unix-only extensions for terminal interfaces.
                pub trait TerminalExt
                {
                    /// Reads raw data from the terminal.
                    fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> ::io::Result<Option<Event>>;
                }
            } pub use self::ext::{ * };

            pub mod io
            {   
                /*
                use std::os::fd::BorrowedFd;
                use std::os::fd::raw::{AsRawFd, FromRawFd, IntoRawFd, RawFd};
                use ::
                {
                    ffi::c_int,
                    num::traits::{ NotAllOnes },
                    *,
                };
                /// Raw file descriptors.
                pub type RawFd = c_int;                
                type ValidRawFd = NotAllOnes<RawFd>;
                /// An owned file descriptor.
                #[repr(transparent)]
                pub struct OwnedFd
                {
                    fd: ValidRawFd,
                }
                impl OwnedFd
                {
                     #[inline] fn as_fd(&self) -> BorrowedFd<'_>
                    {
                        unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) }
                    }
                    /// Creates a new `OwnedFd` instance that shares 
                    /// the same underlying file description as the existing `OwnedFd` instance.
                    pub fn try_clone(&self) -> ::io::Result<Self> 
                    { 
                        self.as_fd().try_clone_to_owned()
                    }
                }
                /// A trait to express the ability to construct an object from a raw file descriptor.
                pub trait FromRawFd
                {
                    /// Constructs a new instance of `Self` from the given raw file descriptor.
                    unsafe fn from_raw_fd(fd: RawFd) -> Self;
                }

                impl FromRawFd for RawFd
                {
                    #[inline] unsafe fn from_raw_fd(fd: RawFd) -> RawFd 
                    {
                        fd
                    }
                }

                impl FromRawFd for fs::File 
                {
                    #[inline] unsafe fn from_raw_fd(fd: RawFd) -> fs::File
                    {
                        unsafe { fs::File::from(OwnedFd::from_raw_fd(fd)) }
                    }
                }

                impl FromRawFd for io::PipeReader
                {
                    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self
                    {
                        Self::from_inner(unsafe { FromRawFd::from_raw_fd(raw_fd) })
                    }
                }

                impl FromRawFd for io::PipeWriter
                {
                    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {
                        Self::from_inner(unsafe { FromRawFd::from_raw_fd(raw_fd) })
                    }
                }
                /// A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.
                pub trait IntoRawFd
                {
                    /// Consumes this object, returning the raw underlying file descriptor.
                    #[must_use = "losing the raw file descriptor may leak resources"]
                    fn into_raw_fd(self) -> RawFd;
                }

                impl IntoRawFd for RawFd
                {
                    #[inline] fn into_raw_fd(self) -> RawFd { self }
                }

                impl IntoRawFd for fs::File
                {
                    #[inline] fn into_raw_fd(self) -> RawFd { self.into_inner().into_inner().into_raw_fd() }
                }
                impl IntoRawFd for io::PipeReader
                {
                    fn into_raw_fd(self) -> RawFd { self.0.into_raw_fd() }
                }

                impl IntoRawFd for io::PipeWriter
                {
                    fn into_raw_fd(self) -> RawFd { self.0.into_raw_fd() }
                } */
            } pub use self::io::{ * };

            pub mod screen
            {
                use ::
                {
                    sync::
                    {
                        LockResult, map_lock_result, map_try_lock_result, map2_lock_result, map2_try_lock_result, Mutex, MutexGuard, 
                        TryLockResult
                    },
                    time::{ Duration },
                    common::
                    {
                      buffer::{ ScreenBuffer },   
                      sys::{ Terminal, TerminalReadGuard, TerminalWriteGuard, PrepareState },
                      terminal::{ Color, Cursor, CursorMode, Event, Size, Style, PrepareConfig },
                    },
                    *,
                };
                
                pub struct Screen 
                {
                    term: Terminal,
                    state: Option<PrepareState>,
                    writer: Mutex<Writer>,
                }

                impl Screen 
                {
                    pub fn new(term: Terminal, config: PrepareConfig) -> io::Result<Screen> 
                    {
                        let size = term.size()?;
                        // let state = term.prepare(config)?;
                        let screen = Screen
                        {
                            term: term,
                            //state: Some(state),
                            state: None,

                            writer: Mutex::new(Writer
                            {
                                buffer: ScreenBuffer::new(size),
                                clear_screen: false,
                                real_cursor: Cursor::default(),
                            }),
                        };
                        screen.term.enter_screen()?;
                        Ok(screen)
                    }

                    pub fn stdout(config: PrepareConfig) -> io::Result<Screen> 
                    { Screen::new(Terminal::stdout()?, config) }

                    pub fn stderr(config: PrepareConfig) -> io::Result<Screen>
                    { Screen::new(Terminal::stderr()?, config) }

                    forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                    pub fn lock_read(&self) -> LockResult<ScreenReadGuard> 
                    {
                        map_lock_result
                        (
                            self.term.lock_read(),
                            |r| ScreenReadGuard::new(self, r)
                        )
                    }

                    pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> 
                    {
                        map_try_lock_result
                        (
                            self.term.try_lock_read(),
                            | r | ScreenReadGuard::new(self, r)
                        )
                    }

                    pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> 
                    {
                        map2_lock_result
                        (
                            self.term.lock_write(), 
                            self.writer.lock(),
                            | a, b | ScreenWriteGuard::new(a, b)
                        )
                    }

                    pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard> 
                    {
                        map2_try_lock_result
                        (
                            self.term.try_lock_write(), 
                            self.writer.try_lock(),
                            | a, b | ScreenWriteGuard::new(a, b)
                        )
                    }

                    fn lock_reader(&self) -> ScreenReadGuard  { self.lock_read().expect("Screen::lock_reader") }
                    fn lock_writer(&self) -> ScreenWriteGuard  { self.lock_write().expect("Screen::lock_writer") }

                    fn lock_write_data(&self) -> MutexGuard<Writer>  
                    { self.writer.lock().expect("Screen::lock_write_data") }

                    pub fn name(&self) -> &str  { self.term.name() }

                    pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> 
                    { self.term.set_cursor_mode(mode) }

                    pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> 
                    { self.lock_reader().wait_event(timeout) }

                    pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    { self.lock_reader().read_event(timeout) }

                    pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    { self.lock_reader().read_raw(buf, timeout) }

                    pub fn refresh(&self) -> io::Result<()> { self.lock_writer().refresh() }
                }

                impl Drop for Screen 
                {
                    fn drop(&mut self) 
                    {
                        let res = if let Some(state) = self.state.take() { self.term.restore(state) }
                        else { Ok(()) };

                        if let Err(e) = res.and_then(|_| self.term.exit_screen()) 
                        { eprintln!("failed to restore terminal: {}", e); }
                    }
                }

                pub struct ScreenReadGuard<'a> 
                {
                    screen: &'a Screen,
                    reader: TerminalReadGuard<'a>,
                }

                pub struct ScreenWriteGuard<'a> 
                {
                    writer: TerminalWriteGuard<'a>,
                    data: MutexGuard<'a, Writer>,
                }

                struct Writer 
                {
                    buffer: ScreenBuffer,
                    clear_screen: bool,
                    real_cursor: Cursor,
                }

                impl<'a> ScreenReadGuard<'a> 
                {
                    fn new(screen: &'a Screen, reader: TerminalReadGuard<'a>) -> ScreenReadGuard<'a> 
                    { ScreenReadGuard{screen, reader} }

                    pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> 
                    { self.reader.wait_event(timeout) }

                    pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        let r = self.reader.read_event(timeout)?;

                        if let Some(Event::Resize(size)) = r 
                        {
                            self.screen.lock_write_data().update_size(size);
                        }

                        Ok(r)
                    }

                    pub fn read_raw(&mut self, buf:&mut [u8], timeout:Option<Duration>) -> io::Result<Option<Event>>
                    {
                        let r = self.reader.read_raw(buf, timeout)?;

                        if let Some(Event::Resize(size)) = r 
                        {
                            self.screen.lock_write_data().update_size(size);
                        }

                        Ok(r)
                    }
                }

                impl<'a> ScreenWriteGuard<'a> 
                {
                    fn new(writer: TerminalWriteGuard<'a>, data: MutexGuard<'a, Writer>) -> ScreenWriteGuard<'a> 
                    { ScreenWriteGuard{writer, data} }

                    forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                    pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> 
                    { self.writer.set_cursor_mode(mode) }

                    pub fn refresh(&mut self) -> io::Result<()> 
                    {
                        if self.data.clear_screen 
                        {
                            self.writer.clear_screen()?;
                            self.data.clear_screen = false;
                        }

                        self.writer.clear_attributes()?;
                        let mut indices = self.data.buffer.indices();

                        while let Some((pos, cell)) = self.data.buffer.next_cell(&mut indices) 
                        {
                            self.move_cursor(pos)?;

                            //self.apply_attrs(cell.attrs())?;
                            self.writer.write_str(cell.text())?;
                            self.data.real_cursor.column += 1;
                        }

                        self.writer.clear_attributes()?;
                        let size = self.data.buffer.size();
                        let pos = self.data.buffer.cursor();

                        if pos.is_out_of_bounds(size) { self.move_cursor(Cursor::last(size))?; }                        
                        else  { self.move_cursor(pos)?; }

                        self.writer.flush()
                    }

                    fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> 
                    {
                        if self.data.real_cursor != pos 
                        {
                            self.writer.move_cursor(pos)?;
                            self.data.real_cursor = pos;
                        }

                        Ok(())
                    }

                    fn apply_attrs(&mut self, (fg, bg, style): (Option<Color>, Option<Color>, Style)) -> io::Result<()> 
                    { self.writer.set_attrs(fg, bg, style) }
                }

                impl<'a> Drop for ScreenWriteGuard<'a> 
                {
                    fn drop(&mut self) { if let Err(e) = self.refresh() { eprintln!("screen refresh failed: {}", e); } }
                }

                impl Writer 
                {
                    fn update_size(&mut self, new_size: Size) 
                    {
                        if self.real_cursor.is_out_of_bounds(new_size) { self.real_cursor = (!0, !0).into(); }

                        self.buffer.resize(new_size);
                        self.clear_screen = true;
                    }
                }
            } pub use self::screen::{ Screen, ScreenReadGuard, ScreenWriteGuard };

            pub mod terminal
            {
                use ffi::c_int;
                use ffi::c_ushort;
                use std::os::fd::{ * };
                use ::
                {
                    common::
                    {
                        sequence::{ FindResult, SequenceMap },
                        signal::{ Signal, SignalSet },
                        //sys::io::{ FromRawFd, IntoRawFd, RawFd },
                        terminal::
                        { 
                            Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme, MouseButton, 
                            Mouse, MouseInput, ModifierState,
                        },
                    },
                    convert::TryFrom,
                    fs::File,
                    libc::unix::{ * },
                    mem::{replace, zeroed},
                    nix::
                    {
                        errno::{ Errno },
                        sys::
                        {
                            select::{ select, FdSet },
                            signal::{ sigaction, SaFlags, SigAction, SigHandler, Signal as NixSignal, SigSet },
                            termios::{ tcgetattr, tcsetattr, SetArg, InputFlags, LocalFlags },
                            time::{ TimeVal, TimeValLike },
                            
                        },
                        unistd::{ read, write },
                    },
                    path::Path,
                    str::{ from_utf8, SmallString, prefixes },
                    sync::atomic::{AtomicUsize, Ordering},
                    sync::{LockResult, map_lock_result, map_try_lock_result, Mutex, MutexGuard, TryLockResult},
                    time::Duration,
                    *,
                };
                /*
                use terminfo::{self, capability as cap, Database};
                use terminfo::capability::Expansion;
                use terminfo::expand::Context;
                */
                const OUT_BUFFER_SIZE: usize = 8192;
                const XTERM_ENABLE_MOUSE: &str = "\x1b[?1006h\x1b[?1002h";
                const XTERM_DISABLE_MOUSE: &str = "\x1b[?1006l\x1b[?1002l";
                const XTERM_ENABLE_MOUSE_MOTION: &str = "\x1b[?1003h";
                const XTERM_DISABLE_MOUSE_MOTION: &str = "\x1b[?1003l";
                const XTERM_MOUSE_INTRO: &str = "\x1b[<";
                const XTERM_SHIFT_MASK: u32 = 0x04;
                const XTERM_META_MASK: u32  = 0x08;
                const XTERM_CTRL_MASK: u32  = 0x10;
                const XTERM_MODIFIER_MASK: u32 = XTERM_SHIFT_MASK | XTERM_META_MASK | XTERM_CTRL_MASK;

                type SeqMap = SequenceMap<SmallString<[u8; 8]>, SeqData>;

                #[derive(Copy, Clone)]
                enum SeqData 
                {
                    XTermMouse,
                    Key(Key),
                }

                pub struct Terminal 
                {
                    //info: Database,
                    out_fd: RawFd,
                    in_fd: RawFd,
                    owned_fd: bool,
                    //sequences: SeqMap,
                    reader: Mutex<Reader>,
                    writer: Mutex<Writer>,
                }

                pub struct TerminalReadGuard<'a> 
                {
                    term: &'a Terminal,
                    reader: MutexGuard<'a, Reader>,
                }

                pub struct TerminalWriteGuard<'a> 
                {
                    term: &'a Terminal,
                    writer: MutexGuard<'a, Writer>,
                }

                struct Reader 
                {
                    in_buffer: Vec<u8>,
                    resume: Option<Resume>,
                    report_signals: SignalSet,
                }

                struct Writer 
                {
                    //context: Context,
                    out_buffer: Vec<u8>,
                    fg: Option<Color>,
                    bg: Option<Color>,
                    cur_style: Style,
                }

                impl Terminal 
                {
                    fn new(in_fd: RawFd, out_fd: RawFd, owned_fd: bool) -> io::Result<Terminal>
                    {
                        //let info = Database::from_env().map_err(ti_to_io)?;
                        //let sequences = sequences(&info);

                        Ok
                        (
                            Terminal
                            {
                                //info,
                                in_fd,
                                out_fd,
                                owned_fd,
                                //sequences,
                                reader: Mutex::new(Reader{
                                    in_buffer: Vec::new(),
                                    resume: None,
                                    report_signals: SignalSet::new(),
                                }),
                                writer: Mutex::new(Writer::new()),
                            }
                        )
                    }

                    pub fn open<P: AsRef<Path>>(path: P) -> io::Result<Terminal> 
                    {
                        let fd = open_rw(path)?;

                        let r = Terminal::new(fd, fd, true);

                        if r.is_err() {
                            unsafe { close_fd(fd); }
                        }

                        r
                    }

                    pub fn stdout() -> io::Result<Terminal> 
                    {
                        Terminal::new(STDIN_FILENO, STDOUT_FILENO, false)
                    }

                    pub fn stderr() -> io::Result<Terminal> 
                    {
                        Terminal::new(STDIN_FILENO, STDERR_FILENO, false)
                    }

                    pub fn name(&self) -> &str 
                    {
                        //self.info.name()
                        ""
                    }

                    fn is_xterm(&self) -> bool 
                    {
                        is_xterm(self.name())
                    }

                    pub fn size(&self) -> io::Result<Size> 
                    {
                        self.lock_writer().size()
                    }

                    pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> 
                    {
                        self.lock_reader().wait_event(timeout)
                    }

                    pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        self.lock_reader().read_event(timeout)
                    }

                    pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        self.lock_reader().read_raw(buf, timeout)
                    }

                    pub fn enter_screen(&self) -> io::Result<()> 
                    {
                        self.lock_writer().enter_screen()
                    }

                    pub fn exit_screen(&self) -> io::Result<()> 
                    {
                        self.lock_writer().exit_screen()
                    }
                    /*
                    pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> 
                    {
                        self.lock_reader().prepare(config)
                    } 
                    */
                    pub fn restore(&self, state: PrepareState) -> io::Result<()> 
                    {
                        self.lock_reader().restore(state)
                    }

                    pub fn clear_screen(&self) -> io::Result<()> 
                    {
                        self.lock_writer().clear_screen()
                    }

                    pub fn clear_to_line_end(&self) -> io::Result<()> 
                    {
                        self.lock_writer().clear_to_line_end()
                    }

                    pub fn clear_to_screen_end(&self) -> io::Result<()> 
                    {
                        self.lock_writer().clear_to_screen_end()
                    }

                    pub fn move_up(&self, n: usize) -> io::Result<()> 
                    {
                        if n != 0 {
                            self.lock_writer().move_up(n)?;
                        }
                        Ok(())
                    }

                    pub fn move_down(&self, n: usize) -> io::Result<()> 
                    {
                        if n != 0 {
                            self.lock_writer().move_down(n)?;
                        }
                        Ok(())
                    }

                    pub fn move_left(&self, n: usize) -> io::Result<()> 
                    {
                        if n != 0 {
                            self.lock_writer().move_left(n)?;
                        }
                        Ok(())
                    }

                    pub fn move_right(&self, n: usize) -> io::Result<()> 
                    {
                        if n != 0 {
                            self.lock_writer().move_right(n)?;
                        }
                        Ok(())
                    }

                    pub fn move_to_first_column(&self) -> io::Result<()> 
                    {
                        self.lock_writer().move_to_first_column()
                    }

                    pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> 
                    {
                        self.lock_writer().set_cursor_mode(mode)
                    }

                    pub fn write_char(&self, ch: char) -> io::Result<()> 
                    {
                        self.write_str(ch.encode_utf8(&mut [0; 4]))
                    }

                    pub fn write_str(&self, s: &str) -> io::Result<()> 
                    {
                        self.lock_writer().write_str(s)
                    }

                    pub fn write_styled(&self,
                            fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                            -> io::Result<()> {
                        self.lock_writer().write_styled(fg, bg, style, text)
                    }

                    pub fn clear_attributes(&self) -> io::Result<()> 
                    {
                        self.lock_writer().clear_attributes()
                    }

                    pub fn set_fg(&self, fg: Option<Color>) -> io::Result<()> 
                    {
                        self.lock_writer().set_fg(fg)
                    }

                    pub fn set_bg(&self, bg: Option<Color>) -> io::Result<()> 
                    {
                        self.lock_writer().set_bg(bg)
                    }

                    pub fn add_style(&self, style: Style) -> io::Result<()> 
                    {
                        self.lock_writer().add_style(style)
                    }

                    pub fn remove_style(&self, style: Style) -> io::Result<()> 
                    {
                        self.lock_writer().remove_style(style)
                    }

                    pub fn set_style(&self, style: Style) -> io::Result<()> 
                    {
                        self.lock_writer().set_style(style)
                    }

                    pub fn set_theme(&self, theme: Theme) -> io::Result<()> 
                    {
                        self.lock_writer().set_theme(theme)
                    }

                    pub fn lock_read(&self) -> LockResult<TerminalReadGuard> 
                    {
                        map_lock_result(self.reader.lock(),
                            |r| TerminalReadGuard::new(self, r))
                    }

                    pub fn lock_write(&self) -> LockResult<TerminalWriteGuard> 
                    {
                        map_lock_result(self.writer.lock(),
                            |w| TerminalWriteGuard::new(self, w))
                    }

                    pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard> 
                    {
                        map_try_lock_result(self.reader.try_lock(),
                            |r| TerminalReadGuard::new(self, r))
                    }

                    pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard> 
                    {
                        map_try_lock_result(self.writer.try_lock(),
                            |w| TerminalWriteGuard::new(self, w))
                    }

                    fn lock_reader(&self) -> TerminalReadGuard 
                    {
                        self.lock_read().expect("Terminal::lock_reader")
                    }

                    fn lock_writer(&self) -> TerminalWriteGuard 
                    {
                        self.lock_write().expect("Terminal::lock_writer")
                    }
                }

                impl Drop for Terminal 
                {
                    fn drop(&mut self) {
                        if let Err(e) = self.set_cursor_mode(CursorMode::Normal) {
                            eprintln!("failed to restore terminal: {}", e);
                        }

                        if self.owned_fd {
                            unsafe { close_fd(self.out_fd); }
                        }
                    }
                }

                impl<'a> TerminalReadGuard<'a> 
                {
                    fn new(term: &'a Terminal, reader: MutexGuard<'a, Reader>) -> TerminalReadGuard<'a> 
                    {
                        TerminalReadGuard{term, reader}
                    }
                    /*
                    pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState> 
                    {
                        let mut writer = self.term.lock_writer();
                        self.prepare_with_lock(&mut writer, config)
                    }
                    pub fn prepare_with_lock(&mut self, writer: &mut TerminalWriteGuard, config: PrepareConfig) -> 
                    io::Result<PrepareState>
                    {
                        use nix::sys::termios::SpecialCharacterIndices::*;

                        let old_tio = tcgetattr(self.term.in_fd).map_err(nix_to_io)?;
                        let mut tio = old_tio.clone();

                        let mut state = PrepareState
                        {
                            old_tio: old_tio.into(),
                            old_sigcont: None,
                            old_sigint: None,
                            old_sigtstp: None,
                            old_sigquit: None,
                            old_sigwinch: None,
                            restore_keypad: false,
                            restore_mouse: false,
                            prev_resume: self.reader.resume,
                        };

                        tio.input_flags.remove(
                            InputFlags::INLCR | InputFlags::ICRNL
                        );

                        tio.local_flags.remove(
                            LocalFlags::ICANON | LocalFlags::ECHO
                        );
                        
                        if config.block_signals {
                            tio.local_flags.remove(LocalFlags::ISIG);
                        } else {
                            tio.local_flags.insert(LocalFlags::ISIG);
                        }
                        
                        if config.enable_control_flow {
                            tio.input_flags.insert(InputFlags::IXON);
                        } else {
                            tio.input_flags.remove(InputFlags::IXON);
                        }
                        
                        tio.control_chars[VMIN as usize] = 0;
                        tio.control_chars[VTIME as usize] = 0;

                        tcsetattr(self.term.in_fd, SetArg::TCSANOW, &tio).map_err(nix_to_io)?;

                        if config.enable_mouse {
                            if writer.enable_mouse(config.always_track_motion)? {
                                state.restore_mouse = true;
                            }
                        }

                        if config.enable_keypad {
                            if writer.enable_keypad()? {
                                state.restore_keypad = true;
                            }
                        }

                        writer.flush()?;

                        let action = SigAction::new(SigHandler::Handler(handle_signal),
                            SaFlags::empty(), SigSet::all());
                            
                        state.old_sigcont = Some(unsafe { sigaction(NixSignal::SIGCONT, &action).map_err(nix_to_io)? });
                        state.old_sigwinch = Some(unsafe { sigaction(NixSignal::SIGWINCH, &action).map_err(nix_to_io)? });

                        if config.report_signals.contains(Signal::Interrupt) {
                            state.old_sigint = Some(unsafe { sigaction(NixSignal::SIGINT, &action).map_err(nix_to_io)? });
                        }
                        if config.report_signals.contains(Signal::Suspend) {
                            state.old_sigtstp = Some(unsafe { sigaction(NixSignal::SIGTSTP, &action).map_err(nix_to_io)? });
                        }
                        if config.report_signals.contains(Signal::Quit) {
                            state.old_sigquit = Some(unsafe { sigaction(NixSignal::SIGQUIT, &action).map_err(nix_to_io)? });
                        }

                        self.reader.report_signals = config.report_signals;
                        self.reader.resume = Some(Resume{config});

                        Ok(state)
                    }
                    */
                    pub fn restore(&mut self, state: PrepareState) -> io::Result<()> 
                    {
                        let mut writer = self.term.lock_writer();
                        self.restore_with_lock(&mut writer, state)
                    }

                    pub fn restore_with_lock(&mut self, writer: &mut TerminalWriteGuard, state: PrepareState) -> 
                    io::Result<()>
                    {
                        /*
                        self.reader.resume = state.prev_resume;

                        if state.restore_mouse {
                            writer.disable_mouse()?;
                        }

                        if state.restore_keypad {
                            writer.disable_keypad()?;
                        }

                        writer.flush()?;

                        tcsetattr(self.term.in_fd, SetArg::TCSANOW, &state.old_tio.into()).map_err(nix_to_io)?;

                        unsafe {
                            if let Some(ref old) = state.old_sigcont {
                                sigaction(NixSignal::SIGCONT, old).map_err(nix_to_io)?;
                            }
                            if let Some(ref old) = state.old_sigint {
                                sigaction(NixSignal::SIGINT, old).map_err(nix_to_io)?;
                            }
                            if let Some(ref old) = state.old_sigtstp {
                                sigaction(NixSignal::SIGTSTP, old).map_err(nix_to_io)?;
                            }
                            if let Some(ref old) = state.old_sigquit {
                                sigaction(NixSignal::SIGQUIT, old).map_err(nix_to_io)?;
                            }
                            if let Some(ref old) = state.old_sigwinch {
                                sigaction(NixSignal::SIGWINCH, old).map_err(nix_to_io)?;
                            }
                        } */

                        Ok(())
                    }

                    pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> 
                    {
                        /*
                        if get_signal().is_some() {
                            return Ok(true);
                        }

                        if peek_event(&self.reader.in_buffer, &self.term.sequences)?.is_some() {
                            return Ok(true);
                        }

                        let mut timeout = timeout.map(to_timeval);

                        let n = loop {
                            let in_fd = self.term.in_fd;

                            let mut r_fds = FdSet::new();
                            r_fds.insert(in_fd);

                            // FIXME: FdSet does not implement Copy or Clone
                            let mut e_fds = FdSet::new();
                            e_fds.insert(in_fd);

                            match select(in_fd + 1,
                                    Some(&mut r_fds), None, Some(&mut e_fds), timeout.as_mut()) {
                                Ok(n) => break n,
                                Err(Errno::EINTR) =>
                                    if get_signal().is_some() {
                                        return Ok(true);
                                    }
                                
                                Err(e) => return Err(nix_to_io(e))
                            }
                        };

                        Ok(n != 0) */
                        Ok( true )
                    }

                    pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        if let Some(ev) = self.try_read()? {
                            return Ok(Some(ev));
                        }

                        match self.read_into_buffer(timeout)? {
                            Some(Event::Raw(_)) => self.try_read(),
                            Some(Event::Signal(sig)) => {
                                if let Some(ev) = self.handle_signal(sig)? {
                                    Ok(Some(ev))
                                } else {
                                    Ok(None)
                                }
                            }
                            r => Ok(r)
                        }
                    }

                    pub fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        if !self.reader.in_buffer.is_empty() {
                            let n = buf.len().min(self.reader.in_buffer.len());
                            buf[..n].copy_from_slice(&self.reader.in_buffer[..n]);

                            let _ = self.reader.in_buffer.drain(..n);

                            return Ok(Some(Event::Raw(n)));
                        }

                        match self.read_input(buf, timeout)? {
                            Some(Event::Signal(sig)) => {
                                if let Some(event) = self.handle_signal(sig)? {
                                    Ok(Some(event))
                                } else {
                                    Ok(None)
                                }
                            }
                            r => Ok(r)
                        }
                    }

                    fn read_into_buffer(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        let mut buf = replace(&mut self.reader.in_buffer, Vec::new());

                        buf.reserve(128);

                        let len = buf.len();
                        let cap = buf.capacity();
                        let r;

                        unsafe {
                            buf.set_len(cap);

                            r = self.read_input(&mut buf[len..], timeout);

                            match r {
                                Ok(Some(Event::Raw(n))) => buf.set_len(len + n),
                                _ => buf.set_len(len)
                            }
                        }
                        
                        self.reader.in_buffer = buf;

                        r
                    }

                    fn read_input(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        // Check for a signal that may have already arrived.
                        if let Some(sig) = take_signal() {
                            return Ok(Some(Event::Signal(sig)));
                        }

                        if !self.wait_event(timeout)? {
                            return Ok(None);
                        }

                        // Check for a signal again after waiting
                        if let Some(sig) = take_signal() {
                            return Ok(Some(Event::Signal(sig)));
                        }

                        loop {
                            match read(self.term.in_fd, buf) {
                                Ok(n) => break Ok(Some(Event::Raw(n))),
                                Err(Errno::EINTR) => {
                                    if let Some(sig) = take_signal() {
                                        return Ok(Some(Event::Signal(sig)));
                                    }
                                }
                                Err(e) => return Err(nix_to_io(e))
                            }
                        }
                    }

                    fn try_read(&mut self) -> io::Result<Option<Event>> 
                    {
                        /*
                        let in_buffer = &mut self.reader.in_buffer;

                        if in_buffer.is_empty() {
                            Ok(None)
                        } else {
                            match peek_event(&in_buffer, &self.term.sequences) {
                                Ok(Some((ev, n))) => {
                                    let _ = in_buffer.drain(..n);
                                    Ok(Some(ev))
                                }
                                Ok(None) => Ok(None),
                                Err(e) => Err(e)
                            }
                        } */
                        Ok( None )
                    }

                    fn handle_signal(&mut self, sig: Signal) -> io::Result<Option<Event>> 
                    {
                        /*
                        match sig {
                            Signal::Continue => {
                                self.resume()?;
                            }
                            Signal::Resize => {
                                let size = self.term.size()?;
                                return Ok(Some(Event::Resize(size)));
                            }
                            _ => ()
                        }

                        if self.reader.report_signals.contains(sig) {
                            Ok(Some(Event::Signal(sig)))
                        } else {
                            Ok(None)
                        } */
                        Ok( None )
                    }

                    fn resume(&mut self) -> io::Result<()> 
                    {
                        /*
                        if let Some(resume) = self.reader.resume {
                            let _ = self.prepare(resume.config)?;
                        } */
                        Ok(())
                    }
                }

                macro_rules! expand_opt 
                {
                    ( $slf:expr , $cap:path ) => { {
                        if let Some(cap) = $slf.term.info.get::<$cap>() {
                            $slf.expand(cap.expand())
                        } else {
                            Ok(())
                        }
                    } };
                    ( $slf:expr , $cap:path , |$ex:ident| $expansion:expr ) => { {
                        if let Some(cap) = $slf.term.info.get::<$cap>() {
                            let $ex = cap.expand();
                            $slf.expand($expansion)
                        } else {
                            Ok(())
                        }
                    } }
                }

                macro_rules! expand_req 
                {
                    ( $slf:expr , $cap:path , $name:expr ) => { {
                        $slf.term.info.get::<$cap>()
                            .ok_or_else(|| not_supported($name))
                            .and_then(|cap| $slf.expand(cap.expand()))
                    } };
                    ( $slf:expr , $cap:path , $name:expr , |$ex:ident| $expansion:expr ) => { {
                        $slf.term.info.get::<$cap>()
                            .ok_or_else(|| not_supported($name))
                            .and_then(|cap| {
                                let $ex = cap.expand();
                                $slf.expand($expansion)
                            })
                    } }
                }

                impl<'a> TerminalWriteGuard<'a> 
                {
                    fn new(term: &'a Terminal, writer: MutexGuard<'a, Writer>) -> TerminalWriteGuard<'a> {
                        TerminalWriteGuard{term, writer}
                    }

                    pub fn size(&self) -> io::Result<Size> {
                        get_winsize(self.term.out_fd)
                    }

                    fn disable_keypad(&mut self) -> io::Result<()>
                    {
                        /*
                        if let Some(local) = self.term.info.get::<cap::KeypadLocal>() {
                            self.expand(local.expand())?;
                        }
                        */
                        Ok(())
                    }

                    fn enable_keypad(&mut self) -> io::Result<bool>
                    {
                        /*
                        if let Some(xmit) = self.term.info.get::<cap::KeypadXmit>() {
                            self.expand(xmit.expand())?;
                            Ok(true)
                        } else {
                            Ok(false)
                        } */

                        Ok( true )
                    }

                    fn disable_mouse(&mut self) -> io::Result<()> {
                        self.write_bytes(XTERM_DISABLE_MOUSE.as_bytes())?;
                        self.write_bytes(XTERM_DISABLE_MOUSE_MOTION.as_bytes())
                    }

                    fn enable_mouse(&mut self, track_motion: bool) -> io::Result<bool> {
                        if self.term.is_xterm() {
                            self.write_bytes(XTERM_ENABLE_MOUSE.as_bytes())?;
                            if track_motion {
                                self.write_bytes(XTERM_ENABLE_MOUSE_MOTION.as_bytes())?;
                            }
                            Ok(true)
                        } else {
                            Ok(false)
                        }
                    }

                    fn enter_screen(&mut self) -> io::Result<()> 
                    {
                        /*
                        match (self.term.info.get::<cap::EnterCaMode>(),
                                self.term.info.get::<cap::ChangeScrollRegion>(),
                                self.term.info.get::<cap::CursorHome>()) {
                            (enter, Some(scroll), Some(home)) => {
                                let size = self.size()?;

                                if let Some(enter) = enter {
                                    self.expand(enter.expand())?;
                                }

                                self.expand(scroll.expand()
                                    .parameters(0, to_u32(size.lines - 1)))?;
                                self.expand(home.expand())?;
                            }
                            (_, None, _) => return Err(not_supported("change_scroll_region")),
                            (_, _, None) => return Err(not_supported("cursor_home")),
                        }

                        self.clear_attributes()?;
                        self.clear_screen()?;
                        */

                        Ok(())
                    }

                    fn exit_screen(&mut self) -> io::Result<()> {
                        /*
                        if let Some(exit) = self.term.info.get::<cap::ExitCaMode>() {
                            self.expand(exit.expand())?;
                            self.flush()?;
                        } */

                        Ok(())
                    }

                    pub fn clear_attributes(&mut self) -> io::Result<()> { /*
                        if self.writer.fg.is_some() || self.writer.bg.is_some() ||
                                !self.writer.cur_style.is_empty() {
                            self.writer.fg = None;
                            self.writer.bg = None;
                            self.writer.cur_style = Style::empty();
                            expand_opt!(self, cap::ExitAttributeMode)?;
                        } */

                        Ok(())
                    }

                    pub fn set_fg(&mut self, fg: Option<Color>) -> io::Result<()> {
                        if self.writer.fg == fg {
                            Ok(())
                        } else {
                            if let Some(fg) = fg {
                                self.set_fg_color(fg)?;
                            } else {
                                self.clear_fg()?;
                            }

                            self.writer.fg = fg;
                            Ok(())
                        }
                    }

                    pub fn set_bg(&mut self, bg: Option<Color>) -> io::Result<()> {
                        if self.writer.bg == bg {
                            Ok(())
                        } else {
                            if let Some(bg) = bg {
                                self.set_bg_color(bg)?;
                            } else {
                                self.clear_bg()?;
                            }

                            self.writer.bg = bg;
                            Ok(())
                        }
                    }

                    pub fn add_style(&mut self, style: Style) -> io::Result<()> { /*
                        let add = style - self.writer.cur_style;

                        if add.contains(Style::BOLD) {
                            expand_opt!(self, cap::EnterBoldMode)?;
                        }
                        if add.contains(Style::ITALIC) {
                            expand_opt!(self, cap::EnterItalicsMode)?;
                        }
                        if add.contains(Style::REVERSE) {
                            expand_opt!(self, cap::EnterReverseMode)?;
                        }
                        if add.contains(Style::UNDERLINE) {
                            expand_opt!(self, cap::EnterUnderlineMode)?;
                        }

                        self.writer.cur_style |= add; */

                        Ok(())
                    }

                    pub fn remove_style(&mut self, style: Style) -> io::Result<()> { /*
                        let remove = style & self.writer.cur_style;

                        if remove.intersects(Style::BOLD | Style::REVERSE) {
                            // terminfo does not contain entries to remove bold or reverse.
                            // Instead, we must reset all attributes.
                            let new_style = self.writer.cur_style - remove;
                            let fg = self.writer.fg;
                            let bg = self.writer.bg;
                            self.clear_attributes()?;
                            self.add_style(new_style)?;
                            self.set_fg(fg)?;
                            self.set_bg(bg)?;
                        } else {
                            if remove.contains(Style::ITALIC) {
                                expand_opt!(self, cap::ExitItalicsMode)?;
                            }
                            if remove.contains(Style::UNDERLINE) {
                                expand_opt!(self, cap::ExitUnderlineMode)?;
                            }

                            self.writer.cur_style -= remove;
                        } */

                        Ok(())
                    }

                    pub fn set_style(&mut self, style: Style) -> io::Result<()>
                    {
                        /*
                        let add = style - self.writer.cur_style;
                        let remove = self.writer.cur_style - style;

                        if remove.intersects(Style::BOLD | Style::REVERSE) {
                            // terminfo does not contain entries to remove bold or reverse.
                            // Instead, we must reset all attributes.
                            let fg = self.writer.fg;
                            let bg = self.writer.bg;
                            self.clear_attributes()?;
                            self.set_fg(fg)?;
                            self.set_bg(bg)?;
                            self.add_style(style)?;
                        } else {
                            self.add_style(add)?;
                            self.remove_style(remove)?;
                        } */

                        Ok(())
                    }

                    pub fn set_theme(&mut self, theme: Theme) -> io::Result<()>
                    {
                        //self.set_attrs(theme.fg, theme.bg, theme.style)
                        Ok(())
                    }

                    pub fn set_attrs(&mut self, fg: Option<Color>, bg: Option<Color>, style: Style) -> io::Result<()> {
                        if (self.writer.fg.is_some() && fg.is_none()) ||
                                (self.writer.bg.is_some() && bg.is_none()) {
                            self.clear_attributes()?;
                        }

                        self.set_style(style)?;
                        self.set_fg(fg)?;
                        self.set_bg(bg)?;

                        Ok(())
                    }

                    fn clear_fg(&mut self) -> io::Result<()> {
                        let bg = self.writer.bg;
                        let style = self.writer.cur_style;

                        self.clear_attributes()?;
                        self.set_bg(bg)?;
                        self.set_style(style)
                    }

                    fn clear_bg(&mut self) -> io::Result<()> {
                        let fg = self.writer.fg;
                        let style = self.writer.cur_style;

                        self.clear_attributes()?;
                        self.set_fg(fg)?;
                        self.set_style(style)
                    }

                    fn set_fg_color(&mut self, fg: Color) -> io::Result<()> { /*
                        expand_opt!(self, cap::SetAForeground,
                            |ex| ex.parameters(color_code(fg))) */
                            Ok(())
                    }

                    fn set_bg_color(&mut self, bg: Color) -> io::Result<()> { /*
                        expand_opt!(self, cap::SetABackground,
                            |ex| ex.parameters(color_code(bg))) */
                            Ok(())
                    }

                    pub fn clear_screen(&mut self) -> io::Result<()> { /*
                        expand_req!(self, cap::ClearScreen, "clear_screen") */ 
                        Ok(())
                    }

                    pub fn clear_to_line_end(&mut self) -> io::Result<()> { /*
                        expand_req!(self, cap::ClrEol, "clr_eol") */
                        Ok(())
                    }

                    pub fn clear_to_screen_end(&mut self) -> io::Result<()> { /*
                        expand_req!(self, cap::ClrEos, "clr_eos") */
                        Ok(())
                    }

                    pub fn move_up(&mut self, n: usize) -> io::Result<()> { /*
                        if n == 1 {
                            expand_req!(self, cap::CursorUp, "cursor_up")?;
                        } else if n != 0 {
                            expand_req!(self, cap::ParmUpCursor, "parm_cursor_up",
                                |ex| ex.parameters(to_u32(n)))?;
                        } */
                        Ok(())
                    }

                    pub fn move_down(&mut self, n: usize) -> io::Result<()> { /*
                        if n != 0 {
                            expand_req!(self, cap::ParmDownCursor, "parm_cursor_down",
                                |ex| ex.parameters(to_u32(n)))?;
                        } */
                        Ok(())
                    }

                    pub fn move_left(&mut self, n: usize) -> io::Result<()> { /*
                        if n == 1 {
                            expand_req!(self, cap::CursorLeft, "cursor_left")?;
                        } else if n != 0 {
                            expand_req!(self, cap::ParmLeftCursor, "parm_cursor_left",
                                |ex| ex.parameters(to_u32(n)))?;
                        } */
                        Ok(())
                    }

                    pub fn move_right(&mut self, n: usize) -> io::Result<()> { /*
                        if n == 1 {
                            expand_req!(self, cap::CursorRight, "cursor_right")?;
                        } else if n != 0 {
                            expand_req!(self, cap::ParmRightCursor, "parm_cursor_right",
                                |ex| ex.parameters(to_u32(n)))?;
                        } */
                        Ok(())
                    }

                    pub fn move_to_first_column(&mut self) -> io::Result<()> {
                        self.write_bytes(b"\r")
                    }

                    pub fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> { /*
                        match (self.term.info.get::<cap::CursorAddress>(),
                                self.term.info.get::<cap::CursorHome>()) {
                            (_, Some(ref home)) if pos == Cursor::default() => {
                                self.expand(home.expand())?;
                            }
                            (Some(addr), _) => {
                                self.expand(addr.expand()
                                    .parameters(to_u32(pos.line), to_u32(pos.column)))?;
                            }
                            (None, _) => return Err(not_supported("cursor_address"))
                        } */

                        Ok(())
                    }

                    pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> { /*
                        match mode {
                            CursorMode::Normal | CursorMode::Overwrite => {
                                expand_opt!(self, cap::CursorNormal)?;
                            }
                            CursorMode::Invisible => {
                                expand_opt!(self, cap::CursorInvisible)?;
                            }
                        } */

                        Ok(())
                    }

                    pub fn write_char(&mut self, ch: char) -> io::Result<()> {
                        self.write_str(ch.encode_utf8(&mut [0; 4]))
                    }

                    pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                        self.write_bytes(s.as_bytes())
                    }

                    pub fn write_styled(&mut self,
                            fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                            -> io::Result<()> {
                        self.set_attrs(fg, bg, style)?;

                        self.write_str(text)?;
                        self.clear_attributes()
                    }

                    fn write_bytes(&mut self, buf: &[u8]) -> io::Result<()> {
                        if buf.len() + self.writer.out_buffer.len() > self.writer.out_buffer.capacity() {
                            self.flush()?;
                        }

                        if buf.len() > self.writer.out_buffer.capacity() {
                            self.write_data(buf).1
                        } else {
                            self.writer.out_buffer.extend(buf);
                            Ok(())
                        }
                    }

                    pub fn flush(&mut self) -> io::Result<()> {
                        let (n, res) = self.write_data(&self.writer.out_buffer);
                        self.writer.out_buffer.drain(..n);
                        res
                    }

                    fn write_data(&self, buf: &[u8]) -> (usize, io::Result<()>) 
                    {
                        /*
                        let mut offset = 0;

                        let r = loop {
                            if offset == buf.len() {
                                break Ok(());
                            }

                            match write(self.term.out_fd, buf) {
                                Ok(0) => break Err(io::Error::from(io::ErrorKind::WriteZero)),
                                Ok(n) => offset += n,
                                Err(Errno::EINTR) => continue,
                                Err(e) => break Err(nix_to_io(e))
                            }
                        };

                        (offset, r) */
                        ( 0, Ok(()) )
                    }
                    /*
                    fn expand<T: AsRef<[u8]>>(&mut self, exp: Expansion<T>) -> io::Result<()> {
                        let writer = &mut *self.writer;
                        exp
                            .with(&mut writer.context)
                            .to(&mut writer.out_buffer)
                            .map_err(ti_to_io)
                    } */
                }

                impl<'a> Drop for TerminalWriteGuard<'a> 
                {
                    fn drop(&mut self) {
                        if let Err(e) = self.flush() {
                            eprintln!("failed to flush terminal: {}", e);
                        }
                    }
                }

                impl Writer 
                {
                    fn new() -> Writer {
                        Writer{
                            //context: Context::default(),
                            out_buffer: Vec::with_capacity(OUT_BUFFER_SIZE),
                            fg: None,
                            bg: None,
                            cur_style: Style::empty(),
                        }
                    }
                }

                fn is_xterm(name: &str) -> bool 
                {
                    // Includes such terminal names as "xterm-256color"
                    name == "xterm" || name.starts_with("xterm-")
                }
                /*
                fn sequences(info: &Database) -> SeqMap 
                {
                    let mut sequences = SequenceMap::new();

                    macro_rules! add {
                        ( $seq:ty , $key:expr ) => { {
                            if let Some(seq) = info.get::<$seq>() {
                                if let Some(s) = ascii_str(seq.as_ref()) {
                                    sequences.insert(s.into(), SeqData::Key($key));
                                }
                            }
                        } }
                    }

                    add!(cap::KeyUp,        Key::Up);
                    add!(cap::KeyDown,      Key::Down);
                    add!(cap::KeyLeft,      Key::Left);
                    add!(cap::KeyRight,     Key::Right);
                    add!(cap::KeyHome,      Key::Home);
                    add!(cap::KeyEnd,       Key::End);
                    add!(cap::KeyNPage,     Key::PageDown);
                    add!(cap::KeyPPage,     Key::PageUp);
                    add!(cap::KeyDc,        Key::Delete);
                    add!(cap::KeyIc,        Key::Insert);
                    add!(cap::KeyF1,        Key::F(1));
                    add!(cap::KeyF2,        Key::F(2));
                    add!(cap::KeyF3,        Key::F(3));
                    add!(cap::KeyF4,        Key::F(4));
                    add!(cap::KeyF5,        Key::F(5));
                    add!(cap::KeyF6,        Key::F(6));
                    add!(cap::KeyF7,        Key::F(7));
                    add!(cap::KeyF8,        Key::F(8));
                    add!(cap::KeyF9,        Key::F(9));
                    add!(cap::KeyF10,       Key::F(10));
                    add!(cap::KeyF11,       Key::F(11));
                    add!(cap::KeyF12,       Key::F(12));

                    if is_xterm(info.name()) {
                        sequences.insert(XTERM_MOUSE_INTRO.into(), SeqData::XTermMouse);
                    }

                    sequences
                }
                */

                pub struct PrepareState 
                {
                    old_tio: termios,
                    old_sigcont: Option<SigAction>,
                    old_sigint: Option<SigAction>,
                    old_sigtstp: Option<SigAction>,
                    old_sigquit: Option<SigAction>,
                    old_sigwinch: Option<SigAction>,
                    restore_keypad: bool,
                    restore_mouse: bool,
                    prev_resume: Option<Resume>,
                }

                #[derive(Copy, Clone, Debug)]
                struct Resume 
                {
                    config: PrepareConfig,
                }

                unsafe fn close_fd(fd: RawFd) 
                {
                    drop(File::from_raw_fd(fd));
                }

                fn open_rw<P: AsRef<Path>>(path: P) -> io::Result<RawFd> 
                {
                    use std::fs::OpenOptions;

                    let file = OpenOptions::new()
                        .read(true)
                        .write(true)
                        .open(path)?;

                    Ok(file.into_raw_fd())
                }

                #[repr(C)]
                struct Winsize 
                {
                    ws_row: c_ushort,
                    ws_col: c_ushort,
                    ws_xpixel: c_ushort,
                    ws_ypixel: c_ushort,
                }

                fn get_winsize(fd: c_int) -> io::Result<Size> 
                {
                    let mut winsz: Winsize = unsafe { zeroed() };
                    
                    let res = unsafe { ioctl(fd, TIOCGWINSZ.into(), &mut winsz) };

                    if res == -1 {
                        Err(io::Error::last_os_error())
                    } else {
                        let size = Size{
                            lines: winsz.ws_row as usize,
                            columns: winsz.ws_col as usize,
                        };

                        Ok(size)
                    }
                }

                fn nix_to_io(e: nix::Error) -> io::Error 
                {
                    io::Error::from_raw_os_error(e as i32)
                }
                /*
                fn ti_to_io(e: terminfo::Error) -> io::Error 
                {
                    match e {
                        terminfo::Error::Io(e) => e,
                        terminfo::Error::NotFound => io::Error::new(
                            io::ErrorKind::NotFound, "terminfo entry not found"),
                        terminfo::Error::Parse => io::Error::new(
                            io::ErrorKind::Other, "failed to parse terminfo entry"),
                        terminfo::Error::Expand(_) => io::Error::new(
                            io::ErrorKind::Other, "failed to expand terminfo entry"),
                    }
                } */

                fn to_timeval(d: Duration) -> TimeVal 
                {
                    /*
                    const MAX_SECS: i64 = i64::max_value() / 1_000;

                    let secs = match d.as_secs() {
                        n if n > MAX_SECS as u64 => MAX_SECS,
                        n => n as i64,
                    };

                    let millis = d.subsec_millis() as i64; */

                    //TimeVal::milliseconds(secs * 1_000 + millis)
                    TimeVal::milliseconds( 0 )
                }

                fn peek_event(buf: &[u8], sequences: &SeqMap) -> io::Result<Option<(Event, usize)>>
                {
                    let (res, n) = {
                        let s = utf8_prefix(buf)?;

                        if s.is_empty() {
                            return Ok(None);
                        }

                        let mut last_match = None;

                        for pfx in prefixes(s) {
                            match sequences.find(pfx) {
                                FindResult::NotFound => break,
                                FindResult::Found(value) => {
                                    last_match = Some((pfx, *value));
                                    break;
                                }
                                FindResult::Incomplete => (),
                                FindResult::Undecided(value) => {
                                    last_match = Some((pfx, *value));
                                }
                            }
                        }

                        let res = last_match.and_then(|(seq, value)| {
                            match value {
                                SeqData::Key(key) => Some((Event::Key(key), seq.len())),
                                SeqData::XTermMouse => {
                                    if let Some((data, len)) = parse_mouse_data(&buf[seq.len()..]) {
                                        Some((Event::Mouse(data), seq.len() + len))
                                    } else {
                                        // Input sequence was incomplete
                                        None
                                    }
                                }
                            }
                        });

                        if let Some(res) = res {
                            res
                        } else {
                            let ch = s.chars().next().unwrap();
                            (Event::Key(ch.into()), ch.len_utf8())
                        }
                    };

                    Ok(Some((res, n)))
                }

                fn parse_mouse_data(mut buf: &[u8]) -> Option<(Mouse, usize)> 
                {
                    /*
                    let orig_len = buf.len();

                    let (mut input, end) = parse_integer(&mut buf)?;

                    if end != b';' {
                        return None;
                    }

                    let (column, end) = parse_integer(&mut buf)?;

                    if end != b';' {
                        return None;
                    }

                    let (line, end) = parse_integer(&mut buf)?;

                    let is_pressed = match end {
                        b'M' => true,
                        b'm' => false,
                        _ => return None
                    };

                    let mut mods = ModifierState::empty();

                    if (input & XTERM_SHIFT_MASK) != 0 {
                        mods |= ModifierState::SHIFT;
                    }
                    if (input & XTERM_META_MASK) != 0 {
                        mods |= ModifierState::ALT;
                    }
                    if (input & XTERM_CTRL_MASK) != 0 {
                        mods |= ModifierState::CTRL;
                    }

                    input &= !XTERM_MODIFIER_MASK;

                    let input = match input {
                        0 ..= 3 => mouse_button_event(input, is_pressed),
                        64 => MouseInput::WheelUp,
                        65 => MouseInput::WheelDown,
                        _ => MouseInput::Motion,
                    };

                    let position = Cursor{
                        // Parsed line and column begin at 1; we begin at 0
                        line: (line - 1) as usize,
                        column: (column - 1) as usize,
                    };

                    Some((Mouse{
                        position,
                        input,
                        modifiers: mods,
                    }, orig_len - buf.len())) */
                    None
                }

                fn parse_integer(buf: &mut &[u8]) -> Option<(u32, u8)> 
                {
                    let mut n = 0u32;
                    let mut iter = buf.iter();

                    while let Some(&b) = iter.next() {
                        match b {
                            b'0' ..= b'9' => {
                                n = n.checked_mul(10)?
                                    .checked_add((b - b'0') as u32)?;
                            }
                            _ => {
                                *buf = iter.as_slice();
                                return Some((n, b));
                            }
                        }
                    }

                    None
                }

                fn mouse_button_event(input: u32, is_pressed: bool) -> MouseInput 
                {
                    let button = match input {
                        0 => MouseButton::Left,
                        1 => MouseButton::Middle,
                        2 => MouseButton::Right,
                        _ => MouseButton::Other(input)
                    };

                    if is_pressed {
                        MouseInput::ButtonPressed(button)
                    } else {
                        MouseInput::ButtonReleased(button)
                    }
                }

                fn utf8_prefix(buf: &[u8]) -> io::Result<&str> 
                {
                    match from_utf8(buf) {
                        Ok(s) => Ok(s),
                        Err(e) => {
                            if e.valid_up_to() != 0 {
                                from_utf8(&buf[..e.valid_up_to()])
                                    .map_err(|_| unreachable!())
                            } else if e.error_len().is_some() {
                                Err(io::Error::new(io::ErrorKind::Other,
                                    "read invalid utf-8 data from terminal"))
                            } else {
                                Ok("")
                            }
                        }
                    }
                }

                static LAST_SIGNAL: AtomicUsize = AtomicUsize::new(0);

                extern "C" fn handle_signal(signum: c_int) 
                {
                    LAST_SIGNAL.store(signum as usize, Ordering::Relaxed);
                }

                fn conv_signal(sig: c_int) -> Option<Signal> 
                {
                    match NixSignal::try_from(sig).ok() {
                        Some(NixSignal::SIGCONT)  => Some(Signal::Continue),
                        Some(NixSignal::SIGINT)   => Some(Signal::Interrupt),
                        Some(NixSignal::SIGQUIT)  => Some(Signal::Quit),
                        Some(NixSignal::SIGTSTP)  => Some(Signal::Suspend),
                        Some(NixSignal::SIGWINCH) => Some(Signal::Resize),
                        _ => None
                    }
                }

                fn get_signal() -> Option<Signal> 
                {
                    conv_signal(LAST_SIGNAL.load(Ordering::Relaxed) as c_int)
                }

                fn take_signal() -> Option<Signal> 
                {
                    conv_signal(LAST_SIGNAL.swap(0, Ordering::Relaxed) as c_int)
                }

                fn ascii_str(s: &[u8]) -> Option<&str> 
                {
                    use std::str::from_utf8_unchecked;

                    if s.is_ascii() {
                        Some(unsafe { from_utf8_unchecked(s) })
                    } else {
                        None
                    }
                }

                fn color_code(color: Color) -> u8 
                {
                    match color {
                        Color::Black =>     0,
                        Color::Red =>       1,
                        Color::Green =>     2,
                        Color::Yellow =>    3,
                        Color::Blue =>      4,
                        Color::Magenta =>   5,
                        Color::Cyan =>      6,
                        Color::White =>     7,
                    }
                }

                fn not_supported(op: &str) -> io::Error 
                {
                    io::Error::new(io::ErrorKind::Other,
                        format!("operation not supported: {}", op))
                }

                #[cfg(target_pointer_width = "64")]
                fn to_u32(u: usize) -> u32 {
                    if u > u32::max_value() as usize {
                        u32::max_value()
                    } else {
                        u as u32
                    }
                }

                #[cfg(any(target_pointer_width = "16", target_pointer_width = "32"))]
                fn to_u32(u: usize) -> u32 {
                    u as u32
                }
            } pub use self::terminal::{ PrepareState, Terminal, TerminalReadGuard, TerminalWriteGuard };
        }

        pub mod windows
        {
            use ::
            {
                common::{ Event },
                time::{ Duration },
                libc::windows::INPUT_RECORD,
                *,
            };
            
            pub mod ext
            {
                //! Windows console extension trait
                use ::
                {
                    common::{ Event },
                    libc::windows::{ * },
                    time::{ Duration },
                    *,
                }; 
                /// Implements Windows-only extensions for terminal interfaces.
                pub trait TerminalExt
                {
                    /// Reads raw data from the console.
                    fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> ::io::Result<Option<Event>>;
                    /// Reads raw event data from the console.
                    fn read_raw_event(&mut self, events: &mut [INPUT_RECORD], timeout: Option<Duration>) -> ::io::Result<Option<Event>>;
                }
            } pub use self::ext::{ * };

            pub mod terminal
            {
                use ::
                {
                    char::{ self, unctrl_lower },
                    common::
                    {
                        terminal::
                        {
                            Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme, MouseButton, 
                            Mouse, MouseInput, ModifierState,
                        }, Signal, SignalSet,
                    },
                    ffi::OsStr,
                    libc::windows::{ * },
                    mem::{replace, zeroed},
                    //os::windows::ffi::OsStrExt,
                    sync::
                    { 
                        atomic::{ AtomicUsize, Ordering }, 
                        LockResult, Mutex, MutexGuard, TryLockResult, map_lock_result, map_try_lock_result,
                    },
                    time::Duration,
                    *,
                };
                /// A Unicode code point: from U+0000 to U+10FFFF.
                #[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]
                pub struct CodePoint
                {
                    value: u32,
                }
                /// Iterator for the code points of a WTF-8 string.
                #[derive(Clone)]
                pub struct Wtf8CodePoints<'a>
                {
                    pub bytes: Option<slice::Iter<'a, u8>>,
                }

                impl<'a> Wtf8CodePoints<'a>
                {
                    pub const fn new() ->Self
                    {
                        Self
                        {
                            bytes: None,
                        }
                    }

                    pub fn create() ->Self
                    {
                        Self
                        {
                            bytes: None,
                        }
                    }

                    pub fn build( &mut self, from:slice::Iter<'a, u8> ) -> Self
                    {
                        self.bytes = Some( from );
                        return self.clone();
                    }
                }

                impl Iterator for Wtf8CodePoints<'_>
                {
                    type Item = CodePoint;

                    #[inline] fn next(&mut self) -> Option<CodePoint> {
                        //unsafe { str::next_code_point(&mut self.bytes.unwrap_or([].iter())).map(|c| CodePoint { value: c }) }
                        None
                    }

                    #[inline] fn size_hint(&self) -> (usize, Option<usize>)
                    {
                        /* let len = self.bytes.len();
                        (len.saturating_add(3) / 4, Some(len)) */
                        (0, None)
                    }
                }
                /// Generates a wide character sequence for potentially ill-formed UTF-16.
                #[derive(Clone)]
                pub struct EncodeWide<'a> 
                {
                    code_points: Wtf8CodePoints<'a>,
                    extra: u16,
                }

                impl <'a> EncodeWide<'a> 
                {
                    pub fn create() -> Self
                    {
                        Self
                        {
                            code_points: Wtf8CodePoints::create(),
                            extra: 0,
                        }
                    }
                }
                /// Windows-specific extensions to [`OsStr`].
                pub trait OsStrExt
                {
                    /// Re-encodes an `OsStr` as a wide character sequence, i.e., potentially ill-formed UTF-16.
                    fn encode_wide(&self) -> EncodeWide<'_>;
                }
                
                impl OsStrExt for OsStr
                {
                    #[inline] fn encode_wide(&self) -> EncodeWide<'_> 
                    { 
                        //self.as_inner().inner.encode_wide()
                        EncodeWide::create()
                    }
                }

                pub struct Terminal
                {
                    in_handle: HANDLE,
                    default_attrs: WORD,
                    old_out_mode: DWORD,
                    reader: Mutex<Reader>,
                    writer: Mutex<Writer>,
                }

                pub struct TerminalReadGuard<'a>
                {
                    term: &'a Terminal,
                    reader: MutexGuard<'a, Reader>,
                }

                pub struct TerminalWriteGuard<'a>
                {
                    term: &'a Terminal,
                    writer: MutexGuard<'a, Writer>,
                }

                unsafe impl Send for Terminal {}
                unsafe impl Sync for Terminal {}

                struct Reader
                {
                    always_track_motion: bool,
                    prev_buttons: DWORD,
                }

                struct Writer
                {
                    out_handle: HANDLE,
                    fg: Option<Color>,
                    bg: Option<Color>,
                    style: Style,
                }

                pub struct PrepareState
                {
                    old_in_mode: DWORD,
                    clear_handler: bool,
                }

                impl Terminal
                {
                    fn new(out: DWORD) -> io::Result<Terminal> {
                        let in_handle = result_handle(
                            unsafe { GetStdHandle(STD_INPUT_HANDLE) })?;
                        let out_handle = result_handle(
                            unsafe { GetStdHandle(out) })?;

                        let default_attrs = unsafe { console_info(out_handle)?.wAttributes };

                        let old_out_mode = unsafe { prepare_output(out_handle)? };

                        Ok(Terminal{
                            in_handle,
                            default_attrs,
                            old_out_mode,
                            reader: Mutex::new(Reader{
                                always_track_motion: false,
                                prev_buttons: 0,
                            }),
                            writer: Mutex::new(Writer{
                                out_handle,
                                fg: None,
                                bg: None,
                                style: Style::empty(),
                            }),
                        })
                    }

                    pub fn stdout() -> io::Result<Terminal> {
                        Terminal::new(STD_OUTPUT_HANDLE)
                    }

                    pub fn stderr() -> io::Result<Terminal> {
                        Terminal::new(STD_ERROR_HANDLE)
                    }

                    pub fn name(&self) -> &str {
                        "windows-console"
                    }

                    pub fn size(&self) -> io::Result<Size> {
                        self.lock_writer().size()
                    }

                    pub fn clear_screen(&self) -> io::Result<()> {
                        self.lock_writer().clear_screen()
                    }

                    pub fn clear_to_line_end(&self) -> io::Result<()> {
                        self.lock_writer().clear_to_line_end()
                    }

                    pub fn clear_to_screen_end(&self) -> io::Result<()> {
                        self.lock_writer().clear_to_screen_end()
                    }

                    pub fn move_to_first_column(&self) -> io::Result<()> {
                        self.lock_writer().move_to_first_column()
                    }

                    pub fn move_up(&self, n: usize) -> io::Result<()> {
                        if n != 0 {
                            self.lock_writer().move_up(n)?;
                        }
                        Ok(())
                    }

                    pub fn move_down(&self, n: usize) -> io::Result<()> {
                        if n != 0 {
                            self.lock_writer().move_down(n)?;
                        }
                        Ok(())
                    }

                    pub fn move_left(&self, n: usize) -> io::Result<()> {
                        if n != 0 {
                            self.lock_writer().move_left(n)?;
                        }
                        Ok(())
                    }

                    pub fn move_right(&self, n: usize) -> io::Result<()> {
                        if n != 0 {
                            self.lock_writer().move_right(n)?;
                        }
                        Ok(())
                    }

                    pub fn enter_screen(&self) -> io::Result<HANDLE> {
                        self.lock_writer().enter_screen()
                    }

                    // This method is unsafe because the validity of `old_handle` cannot be
                    // verified. The caller must guarantee that it is the same `HANDLE`
                    // previously returned by `enter_screen`.
                    pub unsafe fn exit_screen(&self, old_handle: HANDLE) -> io::Result<()> {
                        self.lock_writer().exit_screen(old_handle)
                    }

                    pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> {
                        self.lock_reader().prepare(config)
                    }

                    pub fn restore(&self, state: PrepareState) -> io::Result<()> {
                        self.lock_reader().restore(state)
                    }

                    pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> {
                        self.lock_reader().wait_event(timeout)
                    }

                    pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                        self.lock_reader().read_event(timeout)
                    }

                    pub fn read_raw(&self, buf: &mut [u16],
                            timeout: Option<Duration>) -> io::Result<Option<Event>> {
                        self.lock_reader().read_raw(buf, timeout)
                    }

                    pub fn read_raw_event(&self, events: &mut [INPUT_RECORD],
                            timeout: Option<Duration>) -> io::Result<Option<Event>> {
                        self.lock_reader().read_raw_event(events, timeout)
                    }

                    pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> {
                        self.lock_writer().set_cursor_mode(mode)
                    }

                    pub fn clear_attributes(&self) -> io::Result<()> {
                        self.lock_writer().clear_attributes()
                    }

                    pub fn add_style(&self, style: Style) -> io::Result<()> {
                        self.lock_writer().add_style(style)
                    }

                    pub fn remove_style(&self, style: Style) -> io::Result<()> {
                        self.lock_writer().remove_style(style)
                    }

                    pub fn set_style(&self, style: Style) -> io::Result<()> {
                        self.lock_writer().set_style(style)
                    }

                    pub fn set_fg(&self, fg: Option<Color>) -> io::Result<()> {
                        self.lock_writer().set_fg(fg)
                    }

                    pub fn set_bg(&self, bg: Option<Color>) -> io::Result<()> {
                        self.lock_writer().set_bg(bg)
                    }

                    pub fn set_theme(&self, theme: Theme) -> io::Result<()> {
                        self.lock_writer().set_theme(theme)
                    }

                    pub fn write_char(&self, ch: char) -> io::Result<()> {
                        self.lock_writer().write_str(ch.encode_utf8(&mut [0; 4]))
                    }

                    pub fn write_str(&self, s: &str) -> io::Result<()> {
                        self.lock_writer().write_str(s)
                    }

                    pub fn write_styled(&self,
                            fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                            -> io::Result<()> {
                        self.lock_writer().write_styled(fg, bg, style, text)
                    }

                    pub fn lock_read(&self) -> LockResult<TerminalReadGuard> {
                        map_lock_result(self.reader.lock(),
                            |r| TerminalReadGuard::new(self, r))
                    }

                    pub fn lock_write(&self) -> LockResult<TerminalWriteGuard> {
                        map_lock_result(self.writer.lock(),
                            |w| TerminalWriteGuard::new(self, w))
                    }

                    pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard> {
                        map_try_lock_result(self.reader.try_lock(),
                            |r| TerminalReadGuard::new(self, r))
                    }

                    pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard> {
                        map_try_lock_result(self.writer.try_lock(),
                            |w| TerminalWriteGuard::new(self, w))
                    }

                    fn lock_reader(&self) -> TerminalReadGuard {
                        self.lock_read().expect("Terminal::lock_reader")
                    }

                    fn lock_writer(&self) -> TerminalWriteGuard {
                        self.lock_write().expect("Terminal::lock_writer")
                    }
                }

                impl Drop for Terminal
                {
                    fn drop(&mut self) 
                    {
                        let r = self.set_cursor_mode(CursorMode::Normal);
                        let r2 = r.and_then(|_| {
                            let lock = self.lock_writer();
                            unsafe { set_console_mode(lock.writer.out_handle, self.old_out_mode)?; }
                            Ok(())
                        });

                        if let Err(e) = r2 {
                            eprintln!("failed to restore terminal: {}", e);
                        }
                    }
                }

                impl<'a> TerminalReadGuard<'a>
                {
                    fn new(term: &'a Terminal, reader: MutexGuard<'a, Reader>) -> TerminalReadGuard<'a> {
                        TerminalReadGuard{term, reader}
                    }

                    pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState> {
                        // The write lock is acquired here for consistency, though it is not used
                        // in the Windows implementation. This is done to ensure that a user will
                        // not write and test Windows code that then causes a deadlock on Unix.
                        let mut writer = self.term.lock_writer();
                        self.prepare_with_lock(&mut writer, config)
                    }

                    pub fn prepare_with_lock(&mut self, _writer: &mut TerminalWriteGuard,
                            config: PrepareConfig) -> io::Result<PrepareState> {
                        let old_in_mode = unsafe { console_mode(self.term.in_handle)? };

                        let mut state = PrepareState{
                            old_in_mode,
                            clear_handler: false,
                        };

                        let mut in_mode = old_in_mode;

                        // Necessary to modify certain flags
                        in_mode |= ENABLE_EXTENDED_FLAGS;

                        // Disable echoing input to console
                        in_mode &= !ENABLE_ECHO_INPUT;
                        // Disable waiting for newline before input can be read
                        in_mode &= !ENABLE_LINE_INPUT;

                        // Enable or disable processing Ctrl-C as interrupt
                        if config.block_signals {
                            in_mode &= !ENABLE_PROCESSED_INPUT;
                        } else {
                            in_mode |= ENABLE_PROCESSED_INPUT;
                        }

                        // Enable or disable mouse events
                        if config.enable_mouse {
                            self.reader.always_track_motion = config.always_track_motion;
                            in_mode |= ENABLE_MOUSE_INPUT;
                        } else {
                            in_mode &= !ENABLE_MOUSE_INPUT;
                        }

                        // Disable text editing using mouse
                        in_mode &= !ENABLE_QUICK_EDIT_MODE;

                        // Enable window size events
                        in_mode |= ENABLE_WINDOW_INPUT;

                        // Disable escape sequences in input
                        in_mode &= !ENABLE_VIRTUAL_TERMINAL_INPUT;

                        unsafe {
                            set_console_mode(self.term.in_handle, in_mode)?;

                            if config.report_signals.intersects(Signal::Break | Signal::Interrupt) {
                                catch_signals(config.report_signals);
                                result_bool(SetConsoleCtrlHandler(Some(ctrl_handler), TRUE))?;
                                state.clear_handler = true;
                            }
                        }

                        Ok(state)
                    }

                    pub fn restore(&mut self, state: PrepareState) -> io::Result<()> {
                        let mut writer = self.term.lock_writer();
                        self.restore_with_lock(&mut writer, state)
                    }

                    pub fn restore_with_lock(&mut self, _writer: &mut TerminalWriteGuard,
                            state: PrepareState) -> io::Result<()> {
                        unsafe {
                            if state.clear_handler {
                                result_bool(SetConsoleCtrlHandler(Some(ctrl_handler), FALSE))?;
                            }

                            set_console_mode(self.term.in_handle,
                                state.old_in_mode | ENABLE_EXTENDED_FLAGS)?;
                        }

                        Ok(())
                    }

                    pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool>
                    {
                        /*
                        if get_signal().is_some() {
                            return Ok(true);
                        }

                        let res = unsafe { WaitForSingleObject(
                            self.term.in_handle, as_millis(timeout)) };

                        match res {
                            WAIT_OBJECT_0 => Ok(true),
                            WAIT_TIMEOUT => Ok(false),
                            WAIT_FAILED | _ => Err(io::Error::last_os_error())
                                                    }
                                                                        }
                                                                         | _ => Err(io::Error::last_os_error())
                        }
                        */
                        Ok( true )
                    }

                    pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                        let mut event: [INPUT_RECORD; 1] = unsafe { zeroed() };

                        let n = match self.read_raw_event(&mut event, timeout)? {
                            Some(Event::Raw(n)) => n,
                            r => return Ok(r)
                        };

                        if n == 0 {
                            Ok(None)
                        } else {
                            let event = event[0];

                            if let Some(key) = key_press_event(&event) {
                                Ok(Some(Event::Key(key)))
                            } else if let Some(mouse) = self.mouse_event(&event) {
                                Ok(Some(Event::Mouse(mouse)))
                            } else if let Some(size) = size_event(&event) {
                                Ok(Some(Event::Resize(size)))
                            } else {
                                Ok(Some(Event::NoEvent))
                            }
                        }
                    }

                    pub fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>)
                            -> io::Result<Option<Event>> {
                        if !self.wait_event(timeout)? {
                            return Ok(None);
                        }

                        if let Some(sig) = take_signal() {
                            return Ok(Some(Event::Signal(sig)));
                        }

                        unsafe {
                            let len = to_dword(buf.len());
                            let mut n_read = 0;

                            result_bool(ReadConsoleW(
                                self.term.in_handle,
                                buf.as_ptr() as *mut VOID,
                                len,
                                &mut n_read,
                                ptr::null_mut()))?;

                            if n_read == 0 {
                                Ok(None)
                            } else {
                                Ok(Some(Event::Raw(n_read as usize)))
                            }
                        }
                    }

                    pub fn read_raw_event(&mut self, events: &mut [INPUT_RECORD], timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        /*
                        if !self.wait_event(timeout)? {
                            return Ok(None);
                        }

                        if let Some(sig) = take_signal() {
                            return Ok(Some(Event::Signal(sig)));
                        }

                        let len = to_dword(events.len());
                        let mut n = 0;

                        result_bool(unsafe { ReadConsoleInputW(
                            self.term.in_handle,
                            events.as_mut_ptr(),
                            len,
                            &mut n) })?;

                        Ok(Some(Event::Raw(n as usize)))
                        */
                        Ok( None )
                    }

                    fn mouse_event(&mut self, event: &INPUT_RECORD) -> Option<Mouse>
                    {
                        /*
                        if event.EventType == MOUSE_EVENT {
                            let mouse = unsafe { event.Event.MouseEvent() };

                            let input = if mouse.dwEventFlags & MOUSE_WHEELED != 0 {
                                let direction = (mouse.dwButtonState >> 16) as i16;

                                if direction > 0 {
                                    MouseInput::WheelUp
                                } else {
                                    MouseInput::WheelDown
                                }
                            } else {
                                let prev_buttons = self.reader.prev_buttons;
                                let now_buttons = mouse.dwButtonState;

                                self.reader.prev_buttons = mouse.dwButtonState;

                                if prev_buttons == now_buttons {
                                    if now_buttons == 0 && !self.reader.always_track_motion {
                                        return None;
                                    }

                                    MouseInput::Motion
                                } else {
                                    button_changed(prev_buttons, now_buttons)?
                                }
                            };

                            let position = coord_to_cursor(mouse.dwMousePosition);

                            let mut mods = ModifierState::empty();

                            if has_alt(mouse.dwControlKeyState) {
                                mods |= ModifierState::ALT;
                            }
                            if has_ctrl(mouse.dwControlKeyState) {
                                mods |= ModifierState::CTRL;
                            }
                            if has_shift(mouse.dwControlKeyState) {
                                mods |= ModifierState::SHIFT;
                            }

                            Some(Mouse{
                                position,
                                input,
                                modifiers: mods,
                            })
                        } else {
                            None
                        } */
                        None
                    }
                }

                impl<'a> TerminalWriteGuard<'a>
                {
                    fn new(term: &'a Terminal, writer: MutexGuard<'a, Writer>) -> TerminalWriteGuard<'a> {
                        TerminalWriteGuard{term, writer: writer}
                    }

                    fn enter_screen(&mut self) -> io::Result<HANDLE>
                    {
                        let size = self.size()?;

                        let handle = result_handle(unsafe { CreateConsoleScreenBuffer
                        (
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            ptr::null(),
                            CONSOLE_TEXTMODE_BUFFER,
                            ptr::null_mut()) })?;

                        if let Err(e) = unsafe { setup_screen(handle, size) }
                        {
                            let _ = unsafe { close_handle(handle) };
                            return Err(e);
                        }

                        let old_handle = self.swap_out_handle(handle);

                        let mut out_mode = unsafe { console_mode(handle)? };
                        
                        out_mode &= !(ENABLE_WRAP_AT_EOL_OUTPUT | DISABLE_NEWLINE_AUTO_RETURN);

                        unsafe { set_console_mode(handle, out_mode)?; }

                        Ok(old_handle)
                    }

                    unsafe fn exit_screen(&mut self, old_handle: HANDLE) -> io::Result<()> {
                        result_bool(SetConsoleActiveScreenBuffer(old_handle))?;

                        let handle = self.swap_out_handle(old_handle);

                        close_handle(handle)
                    }

                    pub fn size(&self) -> io::Result<Size> {
                        unsafe { console_size(self.writer.out_handle) }
                    }

                    pub fn flush(&mut self) -> io::Result<()> {
                        Ok(())
                    }

                    pub fn clear_screen(&mut self) -> io::Result<()> {
                        let mut info = self.get_info()?;

                        let win_height = (info.srWindow.Bottom - info.srWindow.Top) + 1;

                        if win_height == info.dwSize.Y {
                            // Window and screen buffer are the same size. Just erase everything.
                            self.clear_area(
                                COORD{X: 0, Y: 0},
                                info.dwSize.X as DWORD * info.dwSize.Y as DWORD)?;
                        } else {
                            // Distance we can move down
                            let max = info.dwSize.Y - (info.srWindow.Bottom + 1);
                            // Distance we want to move down
                            let dist = (info.dwCursorPosition.Y + 1) - info.srWindow.Top;

                            let down = dist.min(max);

                            // If there's room to move the window down, do it
                            if down > 0 {
                                info.srWindow.Top += down as SHORT;
                                info.srWindow.Bottom += down as SHORT;

                                result_bool(unsafe { SetConsoleWindowInfo(
                                    self.writer.out_handle,
                                    TRUE,
                                    &info.srWindow) })?;
                            }

                            let clear = info.srWindow.Bottom - info.dwCursorPosition.Y;

                            // If we need to move some text, do that, too
                            if clear < win_height {
                                let dist = (win_height - clear) as SHORT;

                                let src = SMALL_RECT{
                                    Top: dist,
                                    Bottom: info.dwCursorPosition.Y,
                                    Left: 0,
                                    Right: info.dwSize.X,
                                };

                                let dest = COORD{
                                    X: 0,
                                    Y: 0,
                                };

                                let fill = CHAR_INFO{
                                    Char: unicode_char(b' ' as WCHAR),
                                    Attributes: 0,
                                };

                                result_bool(unsafe { ScrollConsoleScreenBufferW(
                                    self.writer.out_handle,
                                    &src,
                                    ptr::null(),
                                    dest,
                                    &fill) })?;
                            }
                        }

                        // Finally, move the cursor to the window origin
                        self.move_abs(COORD{
                            X: info.srWindow.Left,
                            Y: info.srWindow.Top,
                        })
                    }

                    pub fn clear_to_line_end(&mut self) -> io::Result<()> {
                        let info = self.get_info()?;

                        let start = info.dwCursorPosition;
                        let size = info.dwSize;

                        self.clear_area(start, (size.X - start.X) as DWORD)
                    }

                    pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
                        let info = self.get_info()?;

                        let start = info.dwCursorPosition;
                        let size = info.dwSize;

                        let lines = (size.Y - start.Y) as DWORD;
                        let columns = (size.X - start.X) as DWORD;

                        let n = lines * size.X as DWORD + columns;

                        self.clear_area(start, n)
                    }

                    pub fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> {
                        self.move_abs(cursor_to_coord(pos))
                    }

                    pub fn move_to_first_column(&mut self) -> io::Result<()> {
                        let info = self.get_info()?;
                        self.move_abs(COORD{X: 0, Y: info.dwCursorPosition.Y})
                    }

                    pub fn move_up(&mut self, n: usize) -> io::Result<()> {
                        self.move_rel(COORD{X: 0, Y: to_short_neg(n)})
                    }

                    pub fn move_down(&mut self, n: usize) -> io::Result<()> {
                        self.move_rel(COORD{X: 0, Y: to_short(n)})
                    }

                    pub fn move_left(&mut self, n: usize) -> io::Result<()> {
                        self.move_rel(COORD{X: to_short_neg(n), Y: 0})
                    }

                    pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                        self.move_rel(COORD{X: to_short(n), Y: 0})
                    }

                    pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                        let (size, vis) = match mode {
                            CursorMode::Normal => (25, TRUE),
                            CursorMode::Invisible => (1, FALSE),
                            CursorMode::Overwrite => (100, TRUE),
                        };

                        let info = CONSOLE_CURSOR_INFO {
                            dwSize: size,
                            bVisible: vis,
                        };

                        result_bool(unsafe { SetConsoleCursorInfo(self.writer.out_handle, &info) })
                    }

                    pub fn clear_attributes(&mut self) -> io::Result<()> {
                        self.set_attributes(None, None, Style::empty())
                    }

                    pub fn add_style(&mut self, style: Style) -> io::Result<()> {
                        /*let add = style - self.writer.style;

                        if !add.is_empty() {
                            self.writer.style |= add;
                            self.update_attrs()?;
                        } */

                        Ok(())
                    }

                    pub fn remove_style(&mut self, style: Style) -> io::Result<()> {
                        /* let remove = style & self.writer.style;

                        if !remove.is_empty() {
                            self.writer.style -= remove;
                            self.update_attrs()?;
                        } */

                        Ok(())
                    }

                    pub fn set_style(&mut self, style: Style) -> io::Result<()> {
                        if self.writer.style != style {
                            self.writer.style = style;
                            self.update_attrs()?;
                        }
                        Ok(())
                    }

                    pub fn set_fg(&mut self, fg: Option<Color>) -> io::Result<()> {
                        if self.writer.fg != fg {
                            self.writer.fg = fg;
                            self.update_attrs()?;
                        }

                        Ok(())
                    }

                    pub fn set_bg(&mut self, bg: Option<Color>) -> io::Result<()> {
                        if self.writer.bg != bg {
                            self.writer.bg = bg;
                            self.update_attrs()?;
                        }
                        Ok(())
                    }

                    pub fn set_theme(&mut self, theme: Theme) -> io::Result<()> 
                    {
                        /*self.set_attributes(theme.fg, theme.bg, theme.style)*/
                        Ok(())
                    }

                    // Clears any previous attributes
                    pub fn set_attributes(&mut self,
                            fg: Option<Color>, bg: Option<Color>, style: Style) -> io::Result<()> {
                        if self.writer.fg != fg || self.writer.bg != bg || self.writer.style != style {
                            self.writer.fg = fg;
                            self.writer.bg = bg;
                            self.writer.style = style;
                            self.update_attrs()?;
                        }

                        Ok(())
                    }

                    fn update_attrs(&mut self) -> io::Result<()>
                    {
                        /*
                        let mut attrs = self.term.default_attrs;

                        if let Some(fg) = self.writer.fg {
                            attrs &= !fg_code(Color::White);
                            attrs |= fg_code(fg);
                        }

                        if let Some(bg) = self.writer.bg {
                            attrs &= !bg_code(Color::White);
                            attrs |= bg_code(bg);
                        }

                        attrs |= style_code(self.writer.style);

                        if self.writer.style.contains(Style::REVERSE) {
                            attrs = swap_colors(attrs);
                        }

                        self.set_attrs(attrs) */
                        Ok(())
                    }

                    pub fn write_char(&mut self, ch: char) -> io::Result<()> 
                    {
                        let mut buf = [0; 4];
                        self.write_str(ch.encode_utf8(&mut buf))
                    }

                    pub fn write_str(&mut self, s: &str) -> io::Result<()>
                    {
                        /*
                        let buf = OsStr::new(s).encode_wide().collect::<Vec<_>>();
                        let mut n = 0;

                        while buf.len() > n {
                            let mut n_dw = 0;
                            let len = to_dword(buf.len() - n);

                            result_bool(unsafe { WriteConsoleW(
                                self.writer.out_handle,
                                buf[n..].as_ptr() as *const VOID,
                                len,
                                &mut n_dw,
                                ptr::null_mut()) })?;

                            n += n_dw as usize;
                        } */
                        Ok(())
                    }

                    pub fn write_styled(&mut self,
                            fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                            -> io::Result<()> {
                        self.set_attributes(fg, bg, style)?;
                        self.write_str(text)?;
                        self.clear_attributes()
                    }

                    fn clear_area(&mut self, start: COORD, n: DWORD) -> io::Result<()> {
                        let mut n_chars = 0;

                        result_bool(unsafe { FillConsoleOutputAttribute(
                            self.writer.out_handle,
                            self.term.default_attrs,
                            n,
                            start,
                            &mut n_chars) })?;

                        result_bool(unsafe { FillConsoleOutputCharacterA(
                            self.writer.out_handle,
                            b' ' as CHAR,
                            n,
                            start,
                            &mut n_chars) })?;

                        Ok(())
                    }

                    fn move_abs(&mut self, pos: COORD) -> io::Result<()> {
                        result_bool(unsafe { SetConsoleCursorPosition(
                            self.writer.out_handle, pos) })
                    }

                    fn move_rel(&mut self, off: COORD) -> io::Result<()> {
                        let info = self.get_info()?;

                        let size = info.dwSize;
                        let cursor = info.dwCursorPosition;

                        let dest = COORD{
                            X: cursor.X.saturating_add(off.X).min(size.X - 1),
                            Y: cursor.Y.saturating_add(off.Y).min(size.Y - 1),
                        };

                        self.move_abs(dest)
                    }

                    fn set_attrs(&mut self, attrs: WORD) -> io::Result<()> {
                        result_bool(unsafe { SetConsoleTextAttribute(
                            self.writer.out_handle, attrs) })
                    }

                    fn get_info(&self) -> io::Result<CONSOLE_SCREEN_BUFFER_INFO> {
                        unsafe { console_info(self.writer.out_handle) }
                    }

                    fn swap_out_handle(&mut self, handle: HANDLE) -> HANDLE {
                        replace(&mut self.writer.out_handle, handle)
                    }
                }
                
                fn as_millis(timeout: Option<Duration>) -> DWORD 
                {
                    /*match timeout {
                        Some(t) => {
                            let s = (t.as_secs() * 1_000) as DWORD;
                            let ms = (t.subsec_nanos() / 1_000_000) as DWORD;

                            s + ms
                        }
                        None => INFINITE,
                    } */
                    0
                }

                fn fg_code(color: Color) -> WORD 
                {
                    (match color 
                    {
                        Color::Black => 0,
                        Color::Blue => FOREGROUND_BLUE,
                        Color::Cyan => FOREGROUND_BLUE | FOREGROUND_GREEN,
                        Color::Green => FOREGROUND_GREEN,
                        Color::Magenta => FOREGROUND_BLUE | FOREGROUND_RED,
                        Color::Red => FOREGROUND_RED,
                        Color::White => FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
                        Color::Yellow => FOREGROUND_RED | FOREGROUND_GREEN,
                    }) as WORD
                }

                fn bg_code(color: Color) -> WORD 
                {
                    (match color {
                        Color::Black => 0,
                        Color::Blue => BACKGROUND_BLUE,
                        Color::Cyan => BACKGROUND_BLUE | BACKGROUND_GREEN,
                        Color::Green => BACKGROUND_GREEN,
                        Color::Magenta => BACKGROUND_BLUE | BACKGROUND_RED,
                        Color::Red => BACKGROUND_RED,
                        Color::White => BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE,
                        Color::Yellow => BACKGROUND_RED | BACKGROUND_GREEN,
                    }) as WORD
                }

                fn style_code(style: Style) -> WORD 
                {
                    let mut code = 0;

                    /* if style.contains(Style::BOLD) {
                        // Closest available approximation for bold text
                        code |= FOREGROUND_INTENSITY as WORD;
                    } */

                    code
                }

                fn swap_colors(code: WORD) -> WORD 
                {
                    let fg_mask = fg_code(Color::White);
                    let bg_mask = bg_code(Color::White);

                    let fg_shift = fg_mask.trailing_zeros();
                    let bg_shift = bg_mask.trailing_zeros();
                    let shift = bg_shift - fg_shift;

                    let fg = code & fg_mask;
                    let bg = code & bg_mask;

                    let swapped_fg = fg << shift;
                    let swapped_bg = bg >> shift;

                    (code & !(fg_mask | bg_mask)) | swapped_fg | swapped_bg
                }

                unsafe fn close_handle(handle: HANDLE) -> io::Result<()> 
                {
                    result_bool(CloseHandle(handle))
                }

                unsafe fn console_info(handle: HANDLE) -> io::Result<CONSOLE_SCREEN_BUFFER_INFO>
                {
                    let mut info = zeroed();
                    result_bool(GetConsoleScreenBufferInfo(handle, &mut info))?;
                    Ok(info)
                }

                unsafe fn console_mode(handle: HANDLE) -> io::Result<DWORD> 
                {
                    let mut mode = 0;

                    result_bool(GetConsoleMode(handle, &mut mode))?;

                    Ok(mode)
                }

                unsafe fn console_size(handle: HANDLE) -> io::Result<Size> 
                {
                    let info = console_info(handle)?;

                    Ok(coord_to_size(info.dwSize))
                }

                unsafe fn set_console_mode(handle: HANDLE, mode: DWORD) -> io::Result<()> 
                {
                    result_bool(SetConsoleMode(handle, mode))
                }
                
                unsafe fn setup_screen(handle: HANDLE, size: Size) -> io::Result<()> 
                {
                    result_bool(SetConsoleScreenBufferSize(handle, size_to_coord(size)))?;
                    result_bool(SetConsoleActiveScreenBuffer(handle))
                }

                unsafe fn prepare_output(handle: HANDLE) -> io::Result<DWORD> 
                {
                    let old_out_mode = console_mode(handle)?;

                    let mut out_mode = old_out_mode;
                    
                    out_mode |= ENABLE_PROCESSED_OUTPUT;
                    
                    out_mode |= ENABLE_WRAP_AT_EOL_OUTPUT;

                    set_console_mode(handle, out_mode)?;

                    Ok(old_out_mode)
                }

                fn button_changed(prev_buttons: DWORD, now_buttons: DWORD) -> Option<MouseInput> 
                {
                    use std::mem::size_of;

                    let n_bits = size_of::<DWORD>() * 8;

                    for i in 0..n_bits {
                        let bit = 1 << i;

                        let changed = (prev_buttons ^ now_buttons) & bit != 0;

                        if changed {
                            let button = bit_to_button(bit);

                            let input = if prev_buttons & bit == 0 {
                                MouseInput::ButtonPressed(button)
                            } else {
                                MouseInput::ButtonReleased(button)
                            };

                            return Some(input);
                        }
                    }

                    None
                }

                fn bit_to_button(mut bit: DWORD) -> MouseButton
                {
                    assert!(bit != 0);

                    match bit
                    {
                        FROM_LEFT_1ST_BUTTON_PRESSED => MouseButton::Left,
                        RIGHTMOST_BUTTON_PRESSED => MouseButton::Right,
                        FROM_LEFT_2ND_BUTTON_PRESSED => MouseButton::Middle,
                        _ =>
                        {
                            bit >>= 3;
                            let mut n = 3;

                            while bit != 1
                            {
                                bit >>= 1;
                                n += 1;
                            }

                            MouseButton::Other(n)
                        }
                    }
                }

                fn coord_to_cursor(pos: COORD) -> Cursor 
                {
                    Cursor{
                        line: pos.Y as usize,
                        column: pos.X as usize,
                    }
                }

                fn coord_to_size(size: COORD) -> Size 
                {
                    Size{
                        lines: size.Y as usize,
                        columns: size.X as usize,
                    }
                }

                fn cursor_to_coord(pos: Cursor) -> COORD 
                {
                    COORD
                    {
                        Y: to_short(pos.line),
                        X: to_short(pos.column),
                    }
                }

                fn size_to_coord(size: Size) -> COORD 
                {
                    COORD{
                        Y: to_short(size.lines),
                        X: to_short(size.columns),
                    }
                }

                fn has_alt(state: DWORD) -> bool 
                {
                    state & ( LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED) != 0
                }

                fn has_ctrl(state: DWORD) -> bool 
                {
                    state & ( LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED) != 0
                }

                fn has_shift(state: DWORD) -> bool 
                {
                    state & SHIFT_PRESSED != 0
                }

                fn to_dword(n: usize) -> DWORD 
                {
                    if n > DWORD::max_value() as usize {
                        DWORD::max_value()
                    } else {
                        n as DWORD
                    }
                }

                fn to_short(n: usize) -> SHORT 
                {
                    if n > SHORT::max_value() as usize {
                        SHORT::max_value()
                    } else {
                        n as SHORT
                    }
                }

                fn to_short_neg(n: usize) -> SHORT 
                {
                    let n = if n > isize::max_value() as usize {
                        isize::min_value()
                    } else {
                        -(n as isize)
                    };

                    if n < SHORT::min_value() as isize {
                        SHORT::min_value()
                    } else {
                        n as SHORT
                    }
                }

                fn key_press_event(event: &INPUT_RECORD) -> Option<Key>
                {
                    if event.EventType == KEY_EVENT
                    {
                        let key = unsafe { event.Event.KeyEvent() };

                        if key.bKeyDown == FALSE { return None; }

                        let key = match key.wVirtualKeyCode as c_int
                        {
                            VK_BACK => Key::Backspace,
                            VK_RETURN => Key::Enter,
                            VK_ESCAPE => Key::Escape,
                            VK_TAB => Key::Tab,
                            VK_UP => Key::Up,
                            VK_DOWN => Key::Down,
                            VK_LEFT => Key::Left,
                            VK_RIGHT => Key::Right,
                            VK_DELETE => Key::Delete,
                            VK_INSERT => Key::Insert,
                            VK_HOME => Key::Home,
                            VK_END => Key::End,
                            VK_PRIOR => Key::PageUp,
                            VK_NEXT => Key::PageDown,
                            VK_F1 => Key::F(1),
                            VK_F2 => Key::F(2),
                            VK_F3 => Key::F(3),
                            VK_F4 => Key::F(4),
                            VK_F5 => Key::F(5),
                            VK_F6 => Key::F(6),
                            VK_F7 => Key::F(7),
                            VK_F8 => Key::F(8),
                            VK_F9 => Key::F(9),
                            VK_F10 => Key::F(10),
                            VK_F11 => Key::F(11),
                            VK_F12 => Key::F(12),
                            _ =>
                            {
                                /*
                                if has_alt(key.dwControlKeyState) { return None; }

                                let is_ctrl = has_ctrl(key.dwControlKeyState);

                                let u_char = unsafe { *key.uChar.UnicodeChar() };

                                if u_char != 0
                                {
                                    match char::from_u32(u_char as u32)
                                    {
                                        Some(ch) if is::ctrl( u_char as char  ) => Key::Ctrl(char::unctrl_lower( ch as char)),
                                        Some(ch) => ch.into(),
                                        None => return None
                                    }
                                }

                                else { return None; } */
                                return None;
                            }
                        };

                        Some(key)
                    }
                    else { None }
                }

                pub fn size_event(event: &INPUT_RECORD) -> Option<Size> 
                {
                    if event.EventType == WINDOW_BUFFER_SIZE_EVENT {
                        let size = unsafe { event.Event.WindowBufferSizeEvent() };

                        Some(Size{
                            lines: size.dwSize.Y as usize,
                            columns: size.dwSize.X as usize,
                        })
                    } else {
                        None
                    }
                }

                fn unicode_char(wch: WCHAR) -> CHAR_INFO_Char 
                {
                    let mut ch: CHAR_INFO_Char = unsafe { zeroed() };

                    unsafe { *ch.UnicodeChar_mut() = wch; }

                    ch
                }

                fn result_bool(b: BOOL) -> io::Result<()> 
                {
                    if b == FALSE {
                        Err(io::Error::last_os_error())
                    } else {
                        Ok(())
                    }
                }

                fn result_handle(ptr: HANDLE) -> io::Result<HANDLE> 
                {
                    if ptr.is_null() {
                        Err(io::Error::last_os_error())
                    } else {
                        Ok(ptr)
                    }
                }

                static CATCH_SIGNALS: AtomicUsize = AtomicUsize::new(0);
                
                static LAST_SIGNAL: AtomicUsize = AtomicUsize::new(!0);

                fn catch_signals(set: SignalSet) 
                {
                    let mut sigs = 0;

                    if set.contains(Signal::Break) {
                        sigs |= (1 << CTRL_BREAK_EVENT) as usize;
                    }
                    if set.contains(Signal::Interrupt) {
                        sigs |= (1 << CTRL_C_EVENT) as usize;
                    }

                    CATCH_SIGNALS.store(sigs, Ordering::Relaxed);
                }

                unsafe extern "system" fn ctrl_handler(ctrl_type: DWORD) -> BOOL
                {
                    match ctrl_type
                    {
                        CTRL_BREAK_EVENT | CTRL_C_EVENT => {
                            let catch = CATCH_SIGNALS.load(Ordering::Relaxed);

                            if catch & (1 << ctrl_type) as usize == 0 {
                                return FALSE;
                            }

                            LAST_SIGNAL.store(ctrl_type as usize, Ordering::Relaxed);

                            if let Ok(handle) = result_handle(
                                    GetStdHandle(STD_INPUT_HANDLE)) {
                                let input = INPUT_RECORD{
                                    EventType: KEY_EVENT,
                                    Event: zeroed(),
                                };

                                let mut n = 0;
                                let _ = WriteConsoleInputW(
                                    handle,
                                    &input,
                                    1,
                                    &mut n);
                            }

                            TRUE
                        }
                        _ => FALSE
                    }
                }

                fn conv_signal(sig: DWORD) -> Option<Signal> 
                {
                    match sig {
                        CTRL_BREAK_EVENT => Some(Signal::Break),
                        CTRL_C_EVENT => Some(Signal::Interrupt),
                        _ => None
                    }
                }

                fn get_signal() -> Option<Signal> 
                {
                    conv_signal(LAST_SIGNAL.load(Ordering::Relaxed) as DWORD)
                }

                fn take_signal() -> Option<Signal> 
                {
                    conv_signal(LAST_SIGNAL.swap(!0, Ordering::Relaxed) as DWORD)
                }
            } pub use self::terminal::{ * };

            pub mod screen
            {
                use ::
                {
                    common::
                    {
                        buffer::ScreenBuffer,
                        sys::terminal::{ PrepareState, Terminal, TerminalReadGuard, TerminalWriteGuard },
                        terminal::{Color, Cursor, CursorMode, Event, PrepareConfig, Size, Style},
                    },
                    libc::windows::{ * },
                    sync::{LockResult, Mutex, MutexGuard, TryLockResult, map_lock_result, map_try_lock_result, map2_lock_result, map2_try_lock_result, },
                    time::Duration,
                    *,
                };
                
                pub struct Screen 
                {
                    term: Terminal,
                    state: Option<PrepareState>,
                    old_handle: HANDLE,
                    writer: Mutex<Writer>,
                }

                pub struct ScreenReadGuard<'a> 
                {
                    screen: &'a Screen,
                    reader: TerminalReadGuard<'a>,
                }

                pub struct ScreenWriteGuard<'a> 
                {
                    writer: TerminalWriteGuard<'a>,
                    data: MutexGuard<'a, Writer>,
                }

                struct Writer 
                {
                    buffer: ScreenBuffer,
                    clear_screen: bool,
                    real_cursor: Cursor,
                }

                impl Screen 
                {
                    /*
                    pub fn new(term: Terminal, config: PrepareConfig) -> io::Result<Screen> 
                    {
                        let size = term.size()?;

                        let old_handle = term.enter_screen()?;
                        let state = term.prepare(config)?;

                        Ok(Screen{
                            term,
                            state: Some(state),
                            writer: Mutex::new(Writer{
                                buffer: ScreenBuffer::new(size),
                                clear_screen: false,
                                real_cursor: Cursor::default(),
                            }),
                            old_handle,
                        })
                    }

                    pub fn stdout(config: PrepareConfig) -> io::Result<Screen> 
                    {
                        Screen::new(Terminal::stdout()?, config)
                    }

                    pub fn stderr(config: PrepareConfig) -> io::Result<Screen> 
                    {
                        Screen::new(Terminal::stderr()?, config)
                    }  */

                    forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                    pub fn lock_read(&self) -> LockResult<ScreenReadGuard> 
                    {
                        map_lock_result(self.term.lock_read(),
                            |r| ScreenReadGuard::new(self, r))
                    }

                    pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> 
                    {
                        map_try_lock_result(self.term.try_lock_read(),
                            |r| ScreenReadGuard::new(self, r))
                    }

                    pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> 
                    {
                        map2_lock_result(self.term.lock_write(), self.writer.lock(),
                            |a, b| ScreenWriteGuard::new(a, b))
                    }

                    pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard> 
                    {
                        map2_try_lock_result(self.term.try_lock_write(), self.writer.try_lock(),
                            |a, b| ScreenWriteGuard::new(a, b))
                    }

                    fn lock_reader(&self) -> ScreenReadGuard 
                    {
                        self.lock_read().expect("Screen::lock_reader")
                    }

                    fn lock_writer(&self) -> ScreenWriteGuard 
                    {
                        self.lock_write().expect("Screen::lock_writer")
                    }

                    fn lock_write_data(&self) -> MutexGuard<Writer> 
                    {
                        self.writer.lock().expect("Screen::lock_writer")
                    }

                    pub fn name(&self) -> &str 
                    {
                        self.term.name()
                    }

                    pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> 
                    {
                        self.term.set_cursor_mode(mode)
                    }

                    pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> 
                    {
                        self.lock_reader().wait_event(timeout)
                    }

                    pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        self.lock_reader().read_event(timeout)
                    }

                    pub fn read_raw(&self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                        self.lock_reader().read_raw(buf, timeout)
                    }

                    pub fn read_raw_event(&self, events: &mut [INPUT_RECORD], timeout: Option<Duration>) -> 
                    io::Result<Option<Event>>
                    { self.lock_reader().read_raw_event( events, timeout ) }

                    pub fn refresh(&self) -> io::Result<()> 
                    {
                        self.lock_writer().refresh()
                    }
                }

                impl Drop for Screen 
                {
                    fn drop(&mut self)
                    {
                        /*
                        let res = if let Some(state) = self.state.take() {
                            self.term.restore(state)
                        } else {
                            Ok(())
                        };

                        if let Err(e) = res.and_then(
                                |_| unsafe { self.term.exit_screen(self.old_handle) }) {
                            eprintln!("failed to restore terminal: {}", e);
                        } */
                    }
                }

                unsafe impl Send for Screen {}
                unsafe impl Sync for Screen {}

                impl<'a> ScreenReadGuard<'a> 
                {
                    fn new(screen: &'a Screen, reader: TerminalReadGuard<'a>) -> ScreenReadGuard<'a> 
                    {
                        ScreenReadGuard{screen, reader}
                    }

                    pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> 
                    {
                        self.reader.wait_event(timeout)
                    }

                    pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
                    {
                        /*
                        let r = self.reader.read_event(timeout)?;

                        if let Some(Event::Resize(size)) = r {
                            self.screen.lock_write_data().update_size(size);
                        }

                        Ok(r)
                        */
                        Ok( None )
                    }

                    pub fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>>
                    {
                        /*
                        let r = self.reader.read_raw(buf, timeout)?;

                        if let Some(Event::Resize(size)) = r {
                            self.screen.lock_write_data().update_size(size);
                        }

                        Ok(r)
                        */
                        Ok( None )
                    }

                    pub fn read_raw_event(&mut self, events: &mut [INPUT_RECORD], timeout: Option<Duration>) ->
                    io::Result<Option<Event>>
                    {
                        /*
                        let r = self.reader.read_raw_event(events, timeout)?;

                        if let Some(Event::Raw(n)) = r
                        {
                            for ev in events[..n].iter().rev() {
                                if let Some(size) = size_event(ev) {
                                    self.screen.lock_write_data().update_size(size);
                                    break;
                                }
                            }
                        }

                        Ok(r)
                        */
                        Ok( None )
                    }
                }

                impl<'a> ScreenWriteGuard<'a>
                {
                    fn new(writer: TerminalWriteGuard<'a>, data: MutexGuard<'a, Writer>) -> ScreenWriteGuard<'a>
                    { ScreenWriteGuard{writer, data} }

                    forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                    pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
                    { self.writer.set_cursor_mode(mode) }

                    pub fn refresh(&mut self) -> io::Result<()>
                    {
                        /*
                        if self.data.clear_screen
                        {
                            self.writer.clear_screen()?;
                            self.data.clear_screen = false;
                        }

                        let mut real_attrs = (None, None, Style::empty());
                        self.writer.clear_attributes()?;
                        let mut indices = self.data.buffer.indices();

                        while let Some((pos, cell)) = self.data.buffer.next_cell(&mut indices)
                        {
                            self.move_cursor(pos)?;
                            self.apply_attrs(real_attrs, cell.attrs())?;
                            self.writer.write_str(cell.text())?;
                            self.data.real_cursor.column += 1;
                            real_attrs = cell.attrs();
                        }

                        self.writer.clear_attributes()?;
                        let size = self.data.buffer.size();
                        let pos = self.data.buffer.cursor();

                        if pos.is_out_of_bounds(size) { self.move_cursor(Cursor::last(size))?; }
                        else { self.move_cursor(pos)?; }
                        */

                        Ok(())
                    }

                    fn apply_attrs(&mut self, src: (Option<Color>, Option<Color>, Style), dest: (Option<Color>, Option<Color>, Style)) ->
                    io::Result<()>
                    {
                        //if src != dest { self.writer.set_attributes(dest.0, dest.1, dest.2)?; }
                        Ok(())
                    }

                    fn move_cursor(&mut self, pos: Cursor) -> io::Result<()>
                    {
                        if self.data.real_cursor != pos
                        {
                            self.writer.move_cursor(pos)?;
                            self.data.real_cursor = pos;
                        }

                        Ok(())
                    }
                }

                impl<'a> Drop for ScreenWriteGuard<'a>
                {
                    fn drop(&mut self)
                    {
                        if let Err(e) = self.refresh() { eprintln!("failed to refresh screen: {}", e); }
                    }
                }

                impl Writer
                {
                    fn update_size(&mut self, new_size: Size)
                    {
                        if self.real_cursor.is_out_of_bounds(new_size) { self.real_cursor = (!0, !0).into(); }
                        self.buffer.resize(new_size);
                        self.clear_screen = true;
                    }
                }

            } pub use self::screen::{ * };
        }
    }
    
    #[cfg(unix)] pub use self::system::unix as sys;
    #[cfg(unix)] pub use self::sys::ext as unix;

    #[cfg(windows)] pub use self::system::windows as sys;
    #[cfg(windows)] pub use self::sys::ext as windows;
}
/*
over | the best data format. */
pub mod database
{
    use ::
    {
        collections::
        {
            hash_map::{Iter, Keys, Values},
            HashMap,
        },
        *,
    };
    /// Result type for this crate.
    pub type OverResult<T> = Result<T, OverError>;
    /// Indent step in .over files.
    const INDENT_STEP: usize = 4; 

    pub mod arrays
    {
        //! `Arr` module | An array container which can hold an arbitrary number of elements of a single type.
        use ::
        {
            database::
            {
                parses::format::Format,
                types::Type,
                values::Value,
                OverError, OverResult, INDENT_STEP,
            },
            slice::Iter,
            sync::Arc,
            *,
        };
        
        #[derive(Clone, Debug)]
        struct ArrInner 
        {
            vec: Vec<Value>,
            inner_t: Type,
        }
        /// `Arr` struct.
        #[derive(Clone, Debug)]
        pub struct Arr 
        {
            inner: Arc<ArrInner>,
        }

        impl Arr 
        {
            /// Returns a new `Arr` from the given vector of `Value`s.
            pub fn from_vec(vec: Vec<Value>) -> OverResult<Arr> 
            {
                let mut tcur = Type::Any;
                let mut has_any = true;

                for value in &vec {
                    let tnew = value.get_type();

                    if has_any {
                        match Type::most_specific(&tcur, &tnew) {
                            Some((t, any)) => {
                                tcur = t;
                                has_any = any;
                            }
                            None => return Err(OverError::ArrTypeMismatch(tcur, tnew)),
                        }
                    } else if tcur != tnew {
                        return Err(OverError::ArrTypeMismatch(tcur, tnew));
                    }
                }

                Ok(Arr {
                    inner: Arc::new(ArrInner { vec, inner_t: tcur }),
                })
            }
            /// Returns a new `Arr` from the given vector of `Value`s without checks.
            pub fn from_vec_unchecked(vec: Vec<Value>, inner_t: Type) -> Arr 
            {
                Arr {
                    inner: Arc::new(ArrInner { vec, inner_t }),
                }
            }
            /// Returns a reference to the inner vec of this `Arr`.
            pub fn vec_ref(&self) -> &Vec<Value> 
            {
                &self.inner.vec
            }
            /// Iterates over each `Value` in `self`, applying `Fn` `f`.
            pub fn with_each<F>(&self, mut f: F) where
                F: FnMut(&Value),
            {
                for value in &self.inner.vec {
                    f(value)
                }
            }
            /// Gets the value at `index`.
            /// Returns an error if `index` is out of bounds.
            pub fn get(&self, index: usize) -> OverResult<Value> 
            {
                if index >= self.inner.vec.len() {
                    Err(OverError::ArrOutOfBounds(index))
                } else {
                    Ok(self.inner.vec[index].clone())
                }
            }
            /// Returns the type of all elements in this `Arr`.
            pub fn inner_type(&self) -> Type 
            {
                self.inner.inner_t.clone()
            }
            /// Returns the length of this `Arr`.
            pub fn len(&self) -> usize 
            {
                self.inner.vec.len()
            }
            /// Returns whether this `Arr` is empty.
            pub fn is_empty(&self) -> bool
            {
                self.inner.vec.is_empty()
            }
            /// Returns whether `self` and `other` point to the same data.
            pub fn ptr_eq(&self, other: &Self) -> bool 
            {
                Arc::ptr_eq(&self.inner, &other.inner)
            }
            /// Returns an iterator over the Arr.
            pub fn iter(&self) -> Iter<Value> 
            {
                self.vec_ref().iter()
            }
        }

        impl Default for Arr 
        
        {
            fn default() -> Self  { Self::from_vec_unchecked(vec![], Type::Any) }
        }

        impl fmt::Display for Arr 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            { write!(f, "{}", self.format(true, INDENT_STEP)) }
        }

        impl PartialEq for Arr 
        
        {
            fn eq(&self, other: &Self) -> bool 
            {
                // Quickly return false if the types don't match.
                if self.inner.inner_t != other.inner.inner_t {
                    return false;
                }

                self.inner.vec == other.inner.vec
            }
        }
    } pub use self::arrays::Arr;

    pub mod error
    {
        //! Error module.
        use ::
        {
            database::
            {
                parses::error::ParseError,
                types::Type,
            },
            error::{ Error },
            *,
        };
        /// The fabulous OVER error type.
        #[derive(Debug, PartialEq, Eq)]
        pub enum OverError
        {
            ArrOutOfBounds(usize),
            ArrTypeMismatch(Type, Type),
            DatabaseNotFound,
            EnvironmentFileNotFound,            
            FieldNotFound(String),
            InvalidFieldName(String),
            NoParentFound,
            ParseError(String),
            TupOutOfBounds(usize),
            TupTypeMismatch(Type, Type, usize),
            TypeMismatch(Type, Type),
            IoError(String),
        }

        impl fmt::Display for OverError 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                use self::OverError::*;
                match *self 
                {
                    ArrOutOfBounds(ref index) => write!(f, "Arr index {} out of bounds", index),
                    ArrTypeMismatch(ref expected, ref found) => write!(
                        f,
                        "Arr inner types do not match: expected {}, found {}",
                        expected, found
                    ),
                    DatabaseNotFound  => write!(f, "Database not found."),
                    EnvironmentFileNotFound  => write!(f, "Environment File not found."),
                    FieldNotFound(ref field) => write!(f, "Field not found: \"{}\"", field),
                    InvalidFieldName(ref field) => write!(f, "Invalid field name: \"{}\"", field),
                    NoParentFound => write!(f, "No parent found for this obj"),
                    TupOutOfBounds(ref index) => write!(f, "Tup index {} out of bounds", index),
                    TupTypeMismatch(ref expected, ref found, ref index) => write!(
                        f,
                        "Tup inner types do not match at index {}: expected {}, found {}",
                        index, expected, found
                    ),
                    TypeMismatch(ref expected, ref found) => {
                        write!(f, "Type mismatch: expected {}, found {}", expected, found)
                    }

                    ParseError(ref error) | IoError(ref error) => write!(f, "{}", error),
                }
            }
        }

        impl Error for OverError 
        
        {
            fn description(&self) -> &str
            {
                use self::OverError::*;
                match *self
                {
                    ArrOutOfBounds(_) => "Arr index out of bounds",
                    ArrTypeMismatch(_, _) => "Arr inner types do not match",
                    DatabaseNotFound => "Database not found",
                    EnvironmentFileNotFound => "Environment File not found",
                    FieldNotFound(_) => "Field not found",
                    InvalidFieldName(_) => "Invalid field name",
                    NoParentFound => "No parent found for this obj",
                    TupOutOfBounds(_) => "Tup index out of bounds",
                    TupTypeMismatch(_, _, _) => "Tup inner types do not match",
                    TypeMismatch(_, _) => "Type mismatch",
                    ParseError(ref error) | IoError(ref error) => error,
                }
            }
        }

        impl From<io::Error> for OverError 
        
        {
            fn from(e: io::Error) -> Self
            {
                OverError::IoError(format!("{}", e))
            }
        }

        impl From<ParseError> for OverError 
        
        {
            fn from(e: ParseError) -> Self
            {
                OverError::ParseError(format!("{}", e))
            }
        }

    } pub use self::error::OverError;

    pub mod objects
    {
        //! `Obj` module | A hashmap of keys to values, where values can be any type, including other objects.
        use ::
        {
            collections::
            {
                hash_map::{Iter, Keys, Values},
                HashMap,
            },
            database::
            {
                arrays::Arr,
                error::OverError,
                parses::{ self, format::Format },
                tuples::Tup,
                types::Type,
                values::Value,
                OverResult, INDENT_STEP,
            },
            num::
            {
                big::{ BigInt },
                rational::{ BigRational },
                traits::{ Zero },
            },
            str::{ FromStr },
            sync::
            {
                atomic::{AtomicUsize, Ordering}, Arc,
            },
            *,
        };

        lazy_static! 
        {
            static ref CUR_ID: AtomicUsize = AtomicUsize::new(0);
        }

        fn get_id() -> usize 
        {
            CUR_ID.fetch_add(1, Ordering::Relaxed)
        }

        #[derive(Clone, Debug)]
        struct ObjInner 
        {
            map: HashMap<String, Value>,
            parent: Option<Obj>,
            id: usize,
        }
        /// `Obj` struct.
        #[derive(Clone, Debug)]
        pub struct Obj 
        {
            inner: Arc<ObjInner>,
        }

        macro_rules! get_fn 
        {
            ( $doc:expr, $name:tt, $type:ty ) => {
                #[doc=$doc]
                pub fn $name(&self, field: &str) -> OverResult<$type> {
                    match self.get(field) {
                        Some(value) => {
                            match value.$name() {
                                Ok(result) => Ok(result),
                                e @ Err(_) => e,
                            }
                        }
                        None => Err(OverError::FieldNotFound(field.into())),
                    }
                }
            }
        }

        impl Obj 
        {
            /// Returns a new `Obj` created from the given `HashMap`.
            pub fn from_map(obj_map: HashMap<String, Value>) -> OverResult<Obj> {
                for field in obj_map.keys() {
                    if !Self::is_valid_field(field) {
                        return Err(OverError::InvalidFieldName((*field).clone()));
                    }
                }
                let id = get_id();

                Ok(Obj {
                    inner: Arc::new(ObjInner {
                        map: obj_map,
                        parent: None,
                        id,
                    }),
                })
            }
            /// Returns a new `Obj` created from the given `HashMap` with given `parent`.
            pub fn from_map_with_parent(obj_map: HashMap<String, Value>, parent: Obj) -> OverResult<Obj> {
                for field in obj_map.keys() {
                    if !Self::is_valid_field(field) {
                        return Err(OverError::InvalidFieldName(field.clone()));
                    }
                }
                let id = get_id();

                Ok(Obj {
                    inner: Arc::new(ObjInner {
                        map: obj_map,
                        parent: Some(parent),
                        id,
                    }),
                })
            }
            /// Returns a new `Obj` created from the given `HashMap`.
            pub fn from_map_unchecked(obj_map: HashMap<String, Value>) -> Obj {
                let id = get_id();

                Obj {
                    inner: Arc::new(ObjInner {
                        map: obj_map,
                        parent: None,
                        id,
                    }),
                }
            }
            /// Returns a new `Obj` created from the given `HashMap` with given `parent`.
            pub fn from_map_with_parent_unchecked(obj_map: HashMap<String, Value>, parent: Obj) -> Obj {
                let id = get_id();

                Obj {
                    inner: Arc::new(ObjInner {
                        map: obj_map,
                        parent: Some(parent),
                        id,
                    }),
                }
            }
            /// Returns the ID of this `Obj`.
            pub fn id(&self) -> usize {
                self.inner.id
            }
            /// Returns a reference to the inner map of this `Obj`.
            pub fn map_ref(&self) -> &HashMap<String, Value> 
            {
                &self.inner.map
            }
            /// Returns a new `Obj` loaded from a file.
            pub fn from_file(path: &str) -> OverResult<Obj> {
                Ok(parses::load_from_file(path)?)
            }
            /// Writes this `Obj` to given file in `.over` representation.
            pub fn write_to_file(&self, path: &str) -> OverResult<()> {
                str::write_file(path, &self.write_str())?;
                Ok(())
            }
            /// Writes this `Obj` to a `String`.
            pub fn write_str(&self) -> String {
                self.format(false, 0)
            }
            /// Iterates over each `(String, Value)` pair in `self`, applying `f`.
            pub fn with_each<F>(&self, mut f: F) where
                F: FnMut(&String, &Value),
            {
                for (field, value) in &self.inner.map {
                    f(field, value)
                }
            }
            /// Returns the number of fields for this `Obj` (parent fields not included).
            pub fn len(&self) -> usize {
                self.inner.map.len()
            }
            /// Returns whether this `Obj` is empty.
            pub fn is_empty(&self) -> bool
            {
                self.inner.map.is_empty()
            }
            /// Returns whether `self` and `other` point to the same data.
            pub fn ptr_eq(&self, other: &Self) -> bool {
                Arc::ptr_eq(&self.inner, &other.inner)
            }
            /// Returns true if this `Obj` contains `field`.
            pub fn contains(&self, field: &str) -> bool
            {
                self.inner.map.contains_key(field)
            }
            /// Gets the `Value` associated with `field`.
            pub fn get(&self, field: &str) -> Option<Value> {
                match self.inner.map.get(field) {
                    Some(value) => Some(value.clone()),
                    None => match self.inner.parent {
                        Some(ref parent) => parent.get(field),
                        None => None,
                    },
                }
            }
            /// Gets the `Value` associated with `field` and the `Obj` where it was found.
            pub fn get_with_source(&self, field: &str) -> Option<(Value, Obj)> {
                match self.inner.map.get(field) {
                    Some(value) => Some((value.clone(), self.clone())),
                    None => match self.inner.parent {
                        Some(ref parent) => parent.get_with_source(field),
                        None => None,
                    },
                }
            }

            get_fn!(
                "Returns the `bool` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Bool`.",
                get_bool,
                bool
            );
            get_fn!(
                "Returns the `BigInt` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Int`.",
                get_int,
                BigInt
            );
            get_fn!(
                "Returns the `BigRational` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Frac`.",
                get_frac,
                BigRational
            );
            get_fn!(
                "Returns the `char` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Char`.",
                get_char,
                char
            );
            get_fn!(
                "Returns the `String` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Str`.",
                get_str,
                String
            );
            get_fn!(
                "Returns the `Arr` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Arr`.",
                get_arr,
                Arr
            );
            get_fn!(
                "Returns the `Tup` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Tup`.",
                get_tup,
                Tup
            );
            get_fn!(
                "Returns the `Obj` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Obj`.",
                get_obj,
                Obj
            );
            /// Returns whether this `Obj` has a parent.
            pub fn has_parent(&self) -> bool
            {
                self.inner.parent.is_some()
            }
            /// Returns the parent for this `Obj`.
            pub fn get_parent(&self) -> Option<Obj> {
                match self.inner.parent {
                    Some(ref parent) => Some(parent.clone()),
                    None => None,
                }
            }
            /// Returns true if `field` is a valid field name for an `Obj`.
            pub fn is_valid_field(field: &str) -> bool {
                let mut first = true;

                for ch in field.chars() {
                    if first {
                        if !Self::is_valid_field_char(ch, true) {
                            return false;
                        }
                        first = false;
                    } else if !Self::is_valid_field_char(ch, false) {
                        return false;
                    }
                }

                true
            }
            /// Returns true if the given char is valid for a field, depending on whether it is the first char or not.
            pub fn is_valid_field_char(ch: char, first: bool) -> bool
            {
                match ch {
                    ch if ch.is_alphabetic() => true,
                    ch if is::char_digit(ch) => !first,
                    '_' => true,
                    '^' => first,
                    _ => false,
                }
            }
            /// An iterator visiting all fields (keys) in arbitrary order.
            pub fn keys(&self) -> Keys<String, Value> {
                self.map_ref().keys()
            }
            /// An iterator visiting all values in arbitrary order.
            pub fn values(&self) -> Values<String, Value> {
                self.map_ref().values()
            }
            /// An iterator visiting all field-value pairs in arbitrary order.
            pub fn iter(&self) -> Iter<String, Value> {
                self.map_ref().iter()
            }
        }

        impl Default for Obj 
        
        {
            fn default() -> Self {
                Self::from_map_unchecked(map! {})
            }
        }

        impl fmt::Display for Obj 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {write!(f, "{}", self.format(true, INDENT_STEP))
            }
        }

        impl FromStr for Obj
        {
            type Err = OverError;

            fn from_str(s: &str) -> Result<Self, Self::Err> 
            {
                Ok(parses::load_from_str(s)?)
            }
        }
        /// For two Objs to be equal, the following two checks must pass:
        /// 1. If either Obj has a parent, then both must have parents and the parents must be equal.
        /// 2. The two Objs must have all the same fields pointing to the same values.
        impl PartialEq for Obj 
        
        {
            fn eq(&self, other: &Self) -> bool 
            {
                let inner = &self.inner;
                let other_inner = &other.inner;

                // Check parent equality.
                if inner.parent.is_some() && other_inner.parent.is_some() {
                    let parent = self.get_parent().unwrap();
                    let other_parent = other.get_parent().unwrap();
                    if parent != other_parent {
                        return false;
                    }
                } else if !(inner.parent.is_none() && other_inner.parent.is_none()) {
                    return false;
                }

                // Check HashMap equality.
                inner.map == other_inner.map
            }
        }
        
        impl Eq for Obj {}
    } pub use self::objects::Obj;

    pub mod tuples
    {
        use ::
        {
            database::
            {
                parses::format::Format,
                types::Type,
                values::Value,
                OverError, OverResult, INDENT_STEP,
            },
            slice::Iter,
            sync::Arc,
            *,
        };
        
        #[derive(Clone, Debug)]
        struct TupInner 
        {
            vec: Vec<Value>,
            inner_tvec: Vec<Type>,
        }
        /// `Tup` struct.
        #[derive(Clone, Debug)]
        pub struct Tup 
        {
            inner: Arc<TupInner>,
        }

        impl Tup 
        {
            /// Returns a new `Tup` from the given vector of `Value`s.
            pub fn from_vec(values: Vec<Value>) -> Tup {
                let tvec: Vec<Type> = values.iter().map(|val| val.get_type()).collect();

                Tup {
                    inner: Arc::new(TupInner {
                        vec: values,
                        inner_tvec: tvec,
                    }),
                }
            }
            /// Returns a reference to the inner vec of this `Tup`.
            pub fn vec_ref(&self) -> &Vec<Value> 
            {
                &self.inner.vec
            }
            /// Iterates over each `Value` in `self`, applying `Fn` `f`.
            pub fn with_each<F>(&self, mut f: F) where
                F: FnMut(&Value),
            {
                for value in &self.inner.vec {
                    f(value)
                }
            }
            /// Gets the value at `index`.
            /// Returns an error if `index` is out of bounds.
            pub fn get(&self, index: usize) -> OverResult<Value> {
                if index >= self.inner.vec.len() {
                    Err(OverError::TupOutOfBounds(index))
                } else {
                    Ok(self.inner.vec[index].clone())
                }
            }
            /// Returns the type vector of this `Tup`.
            pub fn inner_type_vec(&self) -> Vec<Type> {
                self.inner.inner_tvec.clone()
            }
            /// Returns the length of this `Tup`.
            pub fn len(&self) -> usize {
                self.inner.vec.len()
            }
            /// Returns whether this `Tup` is empty.
            pub fn is_empty(&self) -> bool
            {
                self.inner.vec.is_empty()
            }
            /// Returns whether `self` and `other` point to the same data.
            pub fn ptr_eq(&self, other: &Self) -> bool {
                Arc::ptr_eq(&self.inner, &other.inner)
            }
            /// Returns an iterator over the Tup.
            pub fn iter(&self) -> Iter<Value> {
                self.vec_ref().iter()
            }
        }

        impl Default for Tup 
        
        {
            fn default() -> Self {
                Self::from_vec(vec![])
            }
        }

        impl fmt::Display for Tup 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {write!(f, "{}", self.format(true, INDENT_STEP))
            }
        }

        impl From<Vec<Value>> for Tup 
        
        {
            fn from(vec: Vec<Value>) -> Self {
                Self::from_vec(vec)
            }
        }

        impl PartialEq for Tup 
        
        {
            fn eq(&self, other: &Self) -> bool {
                // Quickly return false if the types don't match.
                if self.inner.inner_tvec != other.inner.inner_tvec {
                    return false;
                }

                self.inner.vec == other.inner.vec
            }
        }
    } pub use self::tuples::Tup;

    pub mod types
    {
        //! Module for types.
        use ::
        {
            *,
        };
        /// Enum of possible types for `Value`s.
        #[derive(Clone, Debug)]
        pub enum Type 
        {
            /// A type used to indicate an empty Arr.
            Any,
            /// Null value.
            Null,

            /// A boolean type.
            Bool,
            /// A signed integer type.
            Int,
            /// A fractional type.
            Frac,
            /// A character type.
            Char,
            /// A string type.
            Str,

            /// An array type, containing the type of its sub-elements.
            Arr(Box<Type>),
            /// A tuple type, containing the types of its sub-elements.
            Tup(Vec<Type>),
            /// An object type.
            Obj,
        }

        impl Type 
        {
            /// Returns true if this type is strictly the same as `other`.
            pub fn is(&self, other: &Type) -> bool {
                use self::Type::*;

                match *self {
                    Any => {
                        if let Any = *other {
                            true
                        } else {
                            false
                        }
                    }

                    Null => {
                        if let Null = *other {
                            true
                        } else {
                            false
                        }
                    }
                    Bool => {
                        if let Bool = *other {
                            true
                        } else {
                            false
                        }
                    }
                    Int => {
                        if let Int = *other {
                            true
                        } else {
                            false
                        }
                    }
                    Frac => {
                        if let Frac = *other {
                            true
                        } else {
                            false
                        }
                    }
                    Char => {
                        if let Char = *other {
                            true
                        } else {
                            false
                        }
                    }
                    Str => {
                        if let Str = *other {
                            true
                        } else {
                            false
                        }
                    }
                    Obj => {
                        if let Obj = *other {
                            true
                        } else {
                            false
                        }
                    }

                    Arr(ref t1) => {
                        if let Arr(ref t2) = *other {
                            t1.is(t2)
                        } else {
                            false
                        }
                    }

                    Tup(ref tvec1) => {
                        if let Tup(ref tvec2) = *other {
                            if tvec1.len() != tvec2.len() {
                                return false;
                            }
                            tvec1.iter().zip(tvec2.iter()).all(|(t1, t2)| t1.is(t2))
                        } else {
                            false
                        }
                    }
                }
            }
            /// Returns true if this `Type` contains `Any`.
            pub fn has_any(&self) -> bool {
                match *self {
                    Type::Any => true,
                    Type::Arr(ref t) => Self::has_any(t),
                    Type::Tup(ref tvec) => tvec.iter().any(|t| Self::has_any(t)),
                    _ => false,
                }
            }
            /// Returns a type with the most specificity that can be applied to the two input types as well
            /// as `true` if the returned type is not maximally specific, that is, it contains `Any`.
            pub fn most_specific(type1: &Type, type2: &Type) -> Option<(Type, bool)> {
                use self::Type::*;

                if let Any = *type2 {
                    return Some((type1.clone(), type1.has_any()));
                }

                match *type1 {
                    Any => Some((type2.clone(), type2.has_any())),

                    Arr(ref t1) => {
                        if let Arr(ref t2) = *type2 {
                            Self::most_specific(t1, t2).map(|(t, any)| (Arr(Box::new(t)), any))
                        } else {
                            None
                        }
                    }

                    Tup(ref tvec1) => {
                        if let Tup(ref tvec2) = *type2 {
                            if tvec1.len() == tvec2.len() {
                                let mut has_any = false;

                                let tvec: Option<Vec<Type>> = tvec1
                                    .iter()
                                    .zip(tvec2.iter())
                                    .map(|(t1, t2)| {
                                        Self::most_specific(t1, t2).map(|(t, any)| {
                                            if !has_any && any {
                                                has_any = any;
                                            }
                                            t
                                        })
                                    })
                                    .collect();

                                tvec.map(|tvec| (Tup(tvec), has_any))
                            } else {
                                None
                            }
                        } else {
                            None
                        }
                    }

                    ref t => {
                        if t == type2 {
                            Some((t.clone(), false))
                        } else {
                            None
                        }
                    }
                }
            }
        }
        /// Two types are considered equal if one of them is Any or they have the same variant.
        impl PartialEq for Type 
        
        {
            fn eq(&self, other: &Self) -> bool {
                use self::Type::*;

                // If either is Any, always return `true`.
                if let Any = *other {
                    return true;
                }

                match *self {
                    Any => true,
                    Arr(ref box1) => {
                        if let Arr(ref box2) = *other {
                            box1 == box2
                        } else {
                            false
                        }
                    }
                    Tup(ref tvec1) => {
                        if let Tup(ref tvec2) = *other {
                            tvec1 == tvec2
                        } else {
                            false
                        }
                    }
                    _ => self.is(other),
                }
            }
        }

        impl Eq for Type {}

        impl fmt::Display for Type 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {use self::Type::*;

                match *self {
                    Any => write!(f, "Any"),
                    Null => write!(f, "Null"),
                    Bool => write!(f, "Bool"),
                    Int => write!(f, "Int"),
                    Frac => write!(f, "Frac"),
                    Char => write!(f, "Char"),
                    Str => write!(f, "Str"),
                    Arr(ref boxxy) => write!(f, "Arr({})", boxxy),
                    Tup(ref tvec) => write!(
                        f,
                        "Tup({})",
                        match tvec.get(0) {
                            Some(t1) => tvec
                                .iter()
                                .skip(1)
                                .fold(format!("{}", t1), |s, t| format!("{}, {}", s, t)),
                            None => String::from(""),
                        }
                    ),
                    Obj => write!(f, "Obj"),
                }
            }
        }
    }

    pub mod values
    {
        //! Module for values.
        use ::
        {
            database::
            {
                arrays,
                error::OverError,
                objects,
                parses::{ format::Format },
                tuples,
                types::Type,
                OverResult, INDENT_STEP,
            },
            num::
            {
                big::{ BigInt },
                rational::{ BigRational },
                traits::{ ToPrimitive },
            },
            *,
        };

        macro_rules! get_fn 
        {
            ( $doc:expr, $name:tt, $type:ty, $variant:ident ) => {
                #[doc=$doc]
                pub fn $name(&self) -> OverResult<$type> {
                    if let Value::$variant(ref inner) = *self {
                        Ok(inner.clone())
                    } else {
                        Err(OverError::TypeMismatch(Type::$variant, self.get_type()))
                    }
                }
            }
        }

        macro_rules! impl_from 
        {
            ($type:ty, $fn:tt) => {
                impl From<$type> for Value {
                    fn from(inner: $type) -> Self {
                        Value::$fn(inner.into())
                    }
                }
            };
        }

        macro_rules! impl_eq 
        {
            ($valtype:ident, $type:ty) => {
                impl PartialEq<$type> for Value {
                    fn eq(&self, other: &$type) -> bool {
                        match *self {
                            Value::$valtype(ref value) => value == other,
                            _ => false,
                        }
                    }
                }

                impl PartialEq<Value> for $type {
                    fn eq(&self, other: &Value) -> bool {
                        match *other {
                            Value::$valtype(ref value) => value == self,
                            _ => false,
                        }
                    }
                }
            };
        }

        macro_rules! impl_eq_int 
        {
            ($type:ty, $fn:tt) => {
                impl PartialEq<$type> for Value {
                    fn eq(&self, other: &$type) -> bool {
                        match *self {
                            Value::Int(ref value) => match value.$fn() {
                                Some(value) => value == *other,
                                None => false,
                            },
                            _ => false,
                        }
                    }
                }

                impl PartialEq<Value> for $type {
                    fn eq(&self, other: &Value) -> bool {
                        match *other {
                            Value::Int(ref value) => match value.$fn() {
                                Some(value) => value == *self,
                                None => false,
                            },
                            _ => false,
                        }
                    }
                }
            };
        }
        /// Enum of possible values and their inner types.
        #[derive(Clone, Debug, PartialEq)]
        pub enum Value
        {
            /// A null value.
            Null,

            // Copy values.
            /// A boolean value.
            Bool(bool),
            /// A signed integer value.
            Int(BigInt),
            /// A fractional value.
            Frac(BigRational),
            /// A character value.
            Char(char),
            /// A string value.
            Str(String),

            // Reference values.
            /// An array value.
            Arr(arrays::Arr),
            /// A tuple value.
            Tup(tuples::Tup),
            /// An object value.
            Obj(objects::Obj),
        }

        impl Value 
        {
            /// Returns true if this `Value` is null.
            pub fn is_null(&self) -> bool {
                if let Value::Null = *self {
                    true
                } else {
                    false
                }
            }
            /// Returns the `Type` of this `Value`.
            pub fn get_type(&self) -> Type {
                use self::Value::*;

                match *self {
                    Null => Type::Null,
                    Bool(_) => Type::Bool,
                    Int(_) => Type::Int,
                    Frac(_) => Type::Frac,
                    Char(_) => Type::Char,
                    Str(_) => Type::Str,
                    Arr(ref arr) => Type::Arr(Box::new(arr.inner_type())),
                    Tup(ref tup) => Type::Tup(tup.inner_type_vec()),
                    Obj(_) => Type::Obj,
                }
            }

            get_fn!(
                "Returns the `bool` contained in this `Value`. \
                Returns an error if this `Value` is not `Bool`.",
                get_bool,
                bool,
                Bool
            );
            get_fn!(
                "Returns the `BigInt` contained in this `Value`. \
                Returns an error if this `Value` is not `Int`.",
                get_int,
                BigInt,
                Int
            );
            /// Returns the `BigRational` contained in this `Value`.
            /// Returns an error if this `Value` is not `Frac`.
            pub fn get_frac(&self) -> OverResult<BigRational> {
                match *self {
                    Value::Frac(ref inner) => Ok(inner.clone()),
                    Value::Int(ref inner) => Ok(frac!(inner.clone(), 1)),
                    _ => Err(OverError::TypeMismatch(Type::Frac, self.get_type())),
                }
            }
            get_fn!(
                "Returns the `char` contained in this `Value`. \
                Returns an error if this `Value` is not `Char`.",
                get_char,
                char,
                Char
            );
            get_fn!(
                "Returns the `String` contained in this `Value`. \
                Returns an error if this `Value` is not `Str`.",
                get_str,
                String,
                Str
            );
            get_fn!(
                "Returns the `Obj` contained in this `Value`. \
                Returns an error if this `Value` is not `Obj`.",
                get_obj,
                objects::Obj,
                Obj
            );
            /// Returns the `Arr` contained in this `Value`.
            /// Returns an error if this `Value` is not `Arr`.
            pub fn get_arr(&self) -> OverResult<arrays::Arr> {
                if let Value::Arr(ref inner) = *self {
                    Ok(inner.clone())
                } else {
                    Err(OverError::TypeMismatch(
                        Type::Arr(Box::new(Type::Any)),
                        self.get_type(),
                    ))
                }
            }
            /// Returns the `Tup` contained in this `Value`.
            /// Returns an error if this `Value` is not `Tup`.
            pub fn get_tup(&self) -> OverResult<tuples::Tup> {
                if let Value::Tup(ref inner) = *self {
                    Ok(inner.clone())
                } else {
                    Err(OverError::TypeMismatch(Type::Tup(vec![]), self.get_type()))
                }
            }
        }

        impl fmt::Display for Value 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {write!(f, "{}", self.format(true, INDENT_STEP))
            }
        }
        
        impl_eq!(Bool, bool);
        impl_eq!(Int, BigInt);
        impl_eq!(Frac, BigRational);
        impl_eq!(Char, char);
        impl_eq!(Arr, arrays::Arr);
        impl_eq!(Tup, tuples::Tup);
        impl_eq!(Obj, objects::Obj);

        impl<'a> PartialEq<&'a str> for Value 
        
        {
            fn eq(&self, other: &&str) -> bool {
                match *self {
                    Value::Str(ref value) => value == &other.replace("\r\n", "\n"),
                    _ => false,
                }
            }
        }

        impl<'a> PartialEq<Value> for &'a str 
        
        {
            fn eq(&self, other: &Value) -> bool {
                match *other {
                    Value::Str(ref value) => value == &self.replace("\r\n", "\n"),
                    _ => false,
                }
            }
        }

        impl PartialEq<String> for Value 
        
        {
            fn eq(&self, other: &String) -> bool {
                &other.as_str() == self
            }
        }

        impl PartialEq<Value> for String 
        
        {
            fn eq(&self, other: &Value) -> bool
            {
                &self.as_str() == other
            }
        }
        
        impl_eq_int!(usize, to_usize);
        impl_eq_int!(u8, to_u8);
        impl_eq_int!(u16, to_u16);
        impl_eq_int!(u32, to_u32);
        impl_eq_int!(u64, to_u64);
        impl_eq_int!(i8, to_i8);
        impl_eq_int!(i16, to_i16);
        impl_eq_int!(i32, to_i32);
        impl_eq_int!(i64, to_i64);

        impl_from!(bool, Bool);

        impl_from!(usize, Int);
        impl_from!(u8, Int);
        impl_from!(u16, Int);
        impl_from!(u32, Int);
        impl_from!(u64, Int);
        impl_from!(i8, Int);
        impl_from!(i16, Int);
        impl_from!(i32, Int);
        impl_from!(i64, Int);
        impl_from!(BigInt, Int);
    
        impl_from!(BigRational, Frac);
        impl_from!(char, Char);
        impl_from!(String, Str);

        impl<'a> From<&'a str> for Value 
        
        {
            fn from(inner: &str) -> Self {
                Value::Str(inner.into())
            }
        }

        impl_from!(arrays::Arr, Arr);
        impl_from!(tuples::Tup, Tup);
        impl_from!(objects::Obj, Obj);
    }

    pub mod parses
    {
        //! Functions for loading/writing Objs.
        use ::
        {
            *,
        };

        pub mod error
        {
            //! Module for parse errors.
            use ::
            {
                database::
                {
                    types::{ Type },
                    OverError,
                },
                error::{ Error },
                num::
                {
                    big::{ BigInt, ParseBigIntError },
                    ParseIntError,
                },
                *,
            };
            
            use super::
            {
                ParseResult,
                MAX_DEPTH,
            };

            pub fn parse_err<T>(file: Option<String>, kind: ParseErrorKind) -> ParseResult<T>
            { Err(ParseError { file, kind }) }
            /// Error kind.
            #[derive( Debug )]
            pub enum ParseErrorKind
            {
                BinaryOperatorError(Type, Type, char, usize, usize),
                CyclicInclude(String, usize, usize),
                DuplicateField(String, usize, usize),
                DuplicateGlobal(String, usize, usize),
                ExpectedType(Type, Type, usize, usize),
                GlobalNotFound(String, usize, usize),
                InvalidIndex(BigInt, usize, usize),
                InvalidClosingBracket(Option<char>, char, usize, usize),
                InvalidDot(Type, usize, usize),
                InvalidEscapeChar(char, usize, usize),
                InvalidFieldChar(char, usize, usize),
                InvalidFieldName(String, usize, usize),
                InvalidIncludeChar(char, usize, usize),
                InvalidIncludePath(String, usize, usize),
                InvalidIncludeToken(Type, usize, usize),
                InvalidNumeric(usize, usize),
                InvalidValue(String, usize, usize),
                InvalidValueChar(char, usize, usize),
                MaxDepth(usize, usize),
                UnaryOperatorError(Type, char, usize, usize),
                UnexpectedEnd(usize),
                VariableNotFound(String, usize, usize),

                IoError(String),
                OverError(String),
                ParseIntError(String),
            }
            /// Parse error.
            #[derive( Debug )]
            pub struct ParseError
            {
                /// The file this error occurred in.
                pub file: Option<String>,
                /// Error kind.
                pub kind: ParseErrorKind,
            }

            impl fmt::Display for ParseError
            {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    use self::ParseErrorKind::*;

                    if let Some(ref file) = (*self).file {
                        write!(f, "{}: ", file)?;
                    }

                    match (*self).kind {
                        BinaryOperatorError(ref expected, ref found, ref op, ref line, ref col) => write!(
                            f,
                            "Could not apply operator {} on types {} and {} at line {}, column {}",
                            op, expected, found, line, col,
                        ),
                        CyclicInclude(ref file, ref line, ref col) => write!(
                            f,
                            "Tried to cyclically include file \"{}\" at line {}, column {}",
                            file, line, col
                        ),
                        DuplicateField(ref field, ref line, ref col) => write!(
                            f,
                            "Duplicate field \"{}\" at line {}, column {}",
                            field, line, col
                        ),
                        DuplicateGlobal(ref field, ref line, ref col) => write!(
                            f,
                            "Duplicate global \"{}\" at line {}, column {}",
                            field, line, col
                        ),
                        ExpectedType(ref expected, ref found, ref line, ref col) => write!(
                            f,
                            "Expected {} at line {}, column {}; found {}",
                            expected, line, col, found
                        ),
                        GlobalNotFound(ref var, ref line, ref col) => write!(
                            f,
                            "Global \"{}\" at line {}, column {} could not be found",
                            var, line, col
                        ),
                        InvalidClosingBracket(ref expected, ref found, ref line, ref col) => write!(
                            f,
                            "Invalid closing bracket '{}' at line {}, column {}; expected {}",
                            found,
                            line,
                            col,
                            match *expected {
                                Some(ch) => format!("'{}'", ch),
                                None => String::from("none"),
                            }
                        ),
                        InvalidDot(ref t, ref line, ref col) => write!(
                            f,
                            "Invalid use of dot notation on value of type {} at line {}, column {}; \
                            value must be an Obj, Arr, or Tup.",
                            t, line, col
                        ),
                        InvalidEscapeChar(ref ch, ref line, ref col) => write!(
                            f,
                            "Invalid escape character '\\{}' at line {}, column {}. \
                            If you meant to write a backslash, use '\\\\'",
                            ::char::format(*ch),
                            line,
                            col
                        ),
                        InvalidFieldChar(ref ch, ref line, ref col) => write!(
                            f,
                            "Invalid character '{}' for field at line {}, column {}",
                            ::char::format(*ch),
                            line,
                            col
                        ),
                        InvalidFieldName(ref field, ref line, ref col) => write!(
                            f,
                            "Invalid field name \"{}\" at line {}, column {}",
                            field, line, col
                        ),
                        InvalidIncludeChar(ref found, ref line, ref col) => write!(
                            f,
                            "Invalid include token character \'{}\' at line {}, column {}",
                            found, line, col
                        ),
                        InvalidIncludePath(ref path, ref line, ref col) => write!(
                            f,
                            "Invalid include path \"{}\" at line {}, column {}",
                            path, line, col
                        ),
                        InvalidIncludeToken(ref t, ref line, ref col) => write!(
                            f,
                            "Invalid value of type \"{}\" at line {}, column {}; \
                            must be either a Str value or one of the tokens \
                            \"Obj\", \"Arr\", \"Tup\", or \"Str\"",
                            t, line, col
                        ),
                        InvalidIndex(ref index, ref line, ref col) => write!(
                            f,
                            "Invalid index {} at line {}, column {}",
                            index, line, col
                        ),
                        InvalidNumeric(ref line, ref col) => {
                            write!(f, "Invalid numeric value at line {}, column {}", line, col)
                        }
                        InvalidValue(ref value, ref line, ref col) => write!(
                            f,
                            "Invalid value \"{}\" at line {}, column {}",
                            value, line, col
                        ),
                        InvalidValueChar(ref ch, ref line, ref col) => write!(
                            f,
                            "Invalid character '{}' for value at line {}, column {}",
                            ::char::format(*ch),
                            line,
                            col
                        ),
                        MaxDepth(ref line, ref col) => write!(
                            f,
                            "Exceeded maximum recursion depth ({}) at line {}, column {}",
                            MAX_DEPTH, line, col
                        ),
                        UnaryOperatorError(ref found, ref op, ref line, ref col) => write!(
                            f,
                            "Could not apply operator {} on type {} at line {}, column {}",
                            op, found, line, col,
                        ),
                        UnexpectedEnd(ref line) => write!(f, "Unexpected end at line {}", line,),
                        VariableNotFound(ref var, ref line, ref col) => write!(
                            f,
                            "Variable \"{}\" at line {}, column {} could not be found",
                            var, line, col
                        ),

                        IoError(ref error) | OverError(ref error) | ParseIntError(ref error) => {
                            write!(f, "{}", error)
                        }
                    }
                }
            }

            impl Error for ParseError
            {
                fn description(&self) -> &str
                {
                    use self::ParseErrorKind::*;

                    match (*self).kind
                    {
                        BinaryOperatorError(_, _, _, _, _) | UnaryOperatorError(_, _, _, _) =>
                        {
                            "Could not apply operator"
                        }

                        CyclicInclude(_, _, _) => "Tried to cyclically include file",
                        DuplicateField(_, _, _) => "Duplicate field",
                        DuplicateGlobal(_, _, _) => "Duplicate global",
                        ExpectedType(_, _, _, _) => "Expected different type",
                        GlobalNotFound(_, _, _) => "Global could not be found",
                        InvalidClosingBracket(_, _, _, _) => "Invalid closing bracket",
                        InvalidDot(_, _, _) => "Invalid use of dot notation",
                        InvalidEscapeChar(_, _, _) => "Invalid escape character",
                        InvalidFieldChar(_, _, _) => "Invalid character for field",
                        InvalidFieldName(_, _, _) => "Invalid field name",
                        InvalidIncludeChar(_, _, _) => "Invalid include character",
                        InvalidIncludePath(_, _, _) => "Invalid include path",
                        InvalidIncludeToken(_, _, _) => "Invalid include token",
                        InvalidIndex(_, _, _) => "Invalid index",
                        InvalidNumeric(_, _) => "Invalid numeric value",
                        InvalidValue(_, _, _) => "Invalid value",
                        InvalidValueChar(_, _, _) => "Invalid character for value",
                        MaxDepth(_, _) => "Exceeded maximum depth for a container",
                        UnexpectedEnd(_) => "Unexpected end when reading value",
                        VariableNotFound(_, _, _) => "Variable could not be found",

                        IoError(ref error) | OverError(ref error) | ParseIntError(ref error) => error,
                    }
                }
            }

            impl ParseError
            {
                /// Convert an `OverError` to a `ParseError` given line and column numbers.
                pub fn from_over(e: &OverError, file: Option<String>, line: usize, col: usize) -> Self
                {
                    ParseError
                    {
                        file,
                        kind: ParseErrorKind::OverError(format!("{} at line {}, col {}", e, line, col)),
                    }
                }
            }

            impl From<io::Error> for ParseError
            {
                fn from(e: io::Error) -> Self
                {
                    ParseError {
                        file: None,
                        kind: ParseErrorKind::IoError(format!("{}", e)),
                    }
                }
            }

            impl From<ParseIntError> for ParseError
            {
                fn from(e: ParseIntError) -> Self
                {
                    ParseError {
                        file: None,
                        kind: ParseErrorKind::ParseIntError(format!("{}", e)),
                    }
                }
            }

            impl From<ParseBigIntError> for ParseError
            {
                fn from(e: ParseBigIntError) -> Self
                {
                    ParseError {
                        file: None,
                        kind: ParseErrorKind::ParseIntError(format!("{}", e)),
                    }
                }
            }
        } use self::error::ParseError;

        pub mod format
        {
            //! Module containing functions for formatting output of objects.
            use ::
            {
                database::{ arrays::Arr, objects::Obj, tuples::Tup, values::Value, INDENT_STEP },
                num::
                {
                    big::BigInt,
                    rational::BigRational,
                    traits::One,
                },
                *,
            };
            
            fn indent(amount: usize) -> String { " ".repeat(amount) }

            fn get_char_map(ch: char) -> Option<&'static str>
            {
                match ch
                {
                    '\\' => Some("\\\\"),
                    '\"' => Some("\\\""),
                    '\'' => Some("\\\'"),
                    '$' => Some("\\$"),
                    '\n' => Some("\\n"),
                    '\r' => Some("\\r"),
                    '\t' => Some("\\t"),
                    _ => None,
                }
            }

            fn replace_all(s: &str) -> String
            {
                let mut string = String::with_capacity(s.len());

                for ch in s.chars()
                {
                    if let Some(s) = get_char_map(ch) {
                        string.push_str(s);
                    } else {
                        string.push(ch);
                    }
                }

                string
            }
            /// Trait for formatting a .over representation of an object.
            pub trait Format
            {
                fn format(&self, full: bool, indent_amt: usize) -> String;
            }

            impl Format for BigRational
            {
                fn format(&self, _full: bool, _indent_amt: usize) -> String
                {
                    let frac_fmt = format!("{}", *self);

                    if *self.denom() == BigInt::one() { format!("{}.0", frac_fmt) } else { frac_fmt }
                }
            }

            impl Format for char
            {
                fn format(&self, _full: bool, _indent_amt: usize) -> String
                {
                    if let Some(s) = get_char_map(*self) {
                        format!("\'{}\'", s)
                    } else {
                        format!("\'{}\'", *self)
                    }
                }
            }

            impl Format for String
            {
                fn format(&self, _full: bool, _indent_amt: usize) -> String { format!("\"{}\"", replace_all(self)) }
            }

            impl Format for Value
            {
                fn format(&self, _full: bool, indent_amt: usize) -> String
                {
                    match *self
                    {
                        Value::Null => String::from("null"),

                        Value::Bool(ref inner) => {
                            if *inner {
                                String::from("true")
                            } else {
                                String::from("false")
                            }
                        }

                        Value::Int(ref inner) => format!("{}", inner),

                        Value::Frac(ref inner) => inner.format(true, indent_amt),
                        Value::Char(ref inner) => inner.format(true, indent_amt),
                        Value::Str(ref inner) => inner.format(true, indent_amt),
                        Value::Arr(ref inner) => inner.format(true, indent_amt),
                        Value::Tup(ref inner) => inner.format(true, indent_amt),
                        Value::Obj(ref inner) => inner.format(true, indent_amt),
                    }
                }
            }

            impl Format for Arr
            {
                fn format(&self, full: bool, indent_amt: usize) -> String
                {
                    match self.len()
                    {
                        0 =>
                        {
                            if full {
                                String::from("[]")
                            } else {
                                String::new()
                            }
                        }

                        1 =>
                        {
                            let f = self.get(0).unwrap().format(true, indent_amt);
                            if full {
                                format!("[{}]", f)
                            } else {
                                f
                            }
                        }

                        _ =>
                        {
                            let mut s = if full {
                                String::from("[\n")
                            } else {
                                String::new()
                            };

                            self.with_each(|value| {
                                s.push_str(&format!(
                                    "{}{}\n",
                                    indent(indent_amt),
                                    value.format(true, indent_amt + INDENT_STEP)
                                ))
                            });

                            if full {
                                let actual_indent_amt = if indent_amt == 0 {
                                    0
                                } else {
                                    indent_amt - INDENT_STEP
                                };
                                s.push_str(&format!("{}]", indent(actual_indent_amt)));
                            }
                            s
                        }
                    }
                }
            }

            impl Format for Tup
            {
                fn format(&self, full: bool, indent_amt: usize) -> String
                {
                    match self.len()
                    {
                        0 =>
                        {
                            if full {
                                String::from("()")
                            } else {
                                String::new()
                            }
                        }

                        1 =>
                        {
                            let f = self.get(0).unwrap().format(true, indent_amt);
                            if full {
                                format!("({})", f)
                            } else {
                                f
                            }
                        }

                        _ =>
                        {
                            let mut s = if full {
                                String::from("(\n")
                            } else {
                                String::new()
                            };

                            self.with_each(|value| {
                                s.push_str(&format!(
                                    "{}{}\n",
                                    indent(indent_amt),
                                    value.format(true, indent_amt + INDENT_STEP)
                                ))
                            });

                            if full {
                                s.push_str(&format!("{})", indent(indent_amt - INDENT_STEP)));
                            }
                            s
                        }
                    }
                }
            }

            impl Format for Obj
            {
                fn format(&self, full: bool, indent_amt: usize) -> String
                {
                    if self.is_empty() && !self.has_parent()
                    {
                        if full { String::from("{}") } else { String::new() }
                    }
                    
                    else
                    {
                        let mut s = if full { String::from("{\n") }

                        else { String::new() };

                        if let Some(parent) = self.get_parent()
                        {
                            s.push_str(&format!
                            (
                                "{}^: {}\n",
                                indent(indent_amt),
                                parent.format(true, indent_amt + INDENT_STEP)
                            ));
                        }

                        self.with_each(|field, value|
                        {
                            s.push_str(&format!
                            (
                                "{}{}: {}\n",
                                indent(indent_amt),
                                field,
                                value.format(true, indent_amt + INDENT_STEP)
                            ));
                        });

                        if full { s.push_str(&format!("{}}}", indent(indent_amt - INDENT_STEP))); }
                        s
                    }
                }
            }
        }

        pub mod parser
        {
            //! Module containing parsing functions.
            use ::
            {
                char::{ CharStream },
                collections::{ HashMap, HashSet, VecDeque },
                database::
                {
                    arrays::{self, Arr},
                    objects::Obj,
                    tuples::Tup,
                    types::Type,
                    values::Value,
                },
                num::
                {
                    big::{ BigInt },
                    rational::{ BigRational },
                    fractional::{ frac_from_whole_and_dec },
                    traits::{ ToPrimitive, Zero },
                },
                ops::{ Deref },
                path::{ Path },
                *,
            };

            use super::
            {
                error::ParseErrorKind::*,
                error::{parse_err, ParseError},
                ParseResult, MAX_DEPTH,
            };
            
            type ObjMap = HashMap<String, Value>;
            type GlobalMap = HashMap<String, Value>;
            type IncludedMap = (HashMap<String, Value>, HashSet<String>);

            lazy_static!
            {
                static ref OBJ_SENTINEL: Obj = Obj::from_map_unchecked(HashMap::new());
                static ref STR_SENTINEL: Obj = Obj::from_map_unchecked(HashMap::new());
                static ref ARR_SENTINEL: Obj = Obj::from_map_unchecked(HashMap::new());
                static ref TUP_SENTINEL: Obj = Obj::from_map_unchecked(HashMap::new());
            }
            /// Parses given file as an `Obj`.
            pub fn parse_obj_file(path: &str) -> ParseResult<Obj> 
            {
                let stream = CharStream::from_file(path)?;
                parse_obj_stream(stream, &mut (HashMap::new(), HashSet::new()))
            }
            /// Parses given file as an `Obj`, keeping track of already encountered includes.
            pub fn parse_obj_file_includes(path: &str, included: &mut IncludedMap) -> ParseResult<Obj> 
            {
                let stream = CharStream::from_file(path)?;
                parse_obj_stream(stream, included)
            }
            /// Parses given &str as an `Obj`.
            pub fn parse_obj_str(contents: &str) -> ParseResult<Obj> 
            {
                let contents = String::from(contents);
                let stream = CharStream::from_string(contents)?;
                parse_obj_stream(stream, &mut (HashMap::new(), HashSet::new()))
            }
            /// Parses an Obj given a character stream.
            #[inline] fn parse_obj_stream(mut stream: CharStream, mut included: &mut IncludedMap) -> ParseResult<Obj> 
            {
                let mut obj: ObjMap = HashMap::new();

                // Go to the first non-whitespace character, or return if there is none.
                if !find_char(stream.clone()) 
                {
                    return Ok(Obj::from_map_unchecked(obj));
                }

                let mut globals: GlobalMap = HashMap::new();
                let mut parent = None;

                // Parse all field/value pairs for this Obj.
                while parse_field_value_pair
                (
                    &mut stream,
                    &mut obj,
                    &mut globals,
                    &mut included,
                    &mut parent,
                    1,
                    None,
                )? {}

                Ok(match parent 
                {
                    Some(parent) => Obj::from_map_with_parent_unchecked(obj, parent),
                    None => Obj::from_map_unchecked(obj),
                })
            }
            /// Parses a sub-Obj in a file. It *must* start with { and end with }.
            pub fn parse_obj
            (
                mut stream: &mut CharStream,
                globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
            ) -> ParseResult<Value> 
            {
                // Check depth.
                if depth > MAX_DEPTH 
                {
                    return parse_err(stream.file(), MaxDepth(stream.line(), stream.col()));
                }

                // We must already be at a '{'.
                let ch = stream.next().unwrap();
                assert_eq!(ch, '{');

                // Go to the first non-whitespace character, or error if there is none.
                if !find_char(stream.clone()) 
                {
                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                }

                let mut obj: ObjMap = HashMap::new();
                let mut parent = None;

                // Parse field/value pairs.
                while parse_field_value_pair
                (
                    &mut stream,
                    &mut obj,
                    globals,
                    &mut included,
                    &mut parent,
                    depth,
                    Some('}'),
                )? {}

                let obj = match parent 
                {
                    Some(parent) => Obj::from_map_with_parent_unchecked(obj, parent),
                    None => Obj::from_map_unchecked(obj),
                };
                Ok(obj.into())
            }
            /// Parses a field/value pair.
            #[inline] pub fn parse_field_value_pair
            (
                mut stream: &mut CharStream,
                obj: &mut ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                parent: &mut Option<Obj>,
                depth: usize,
                cur_brace: Option<char>,
            ) -> ParseResult<bool>
            {
                // Check if we're at an end delimiter instead of a field.
                let peek = stream.peek().unwrap();
                if peek == '}' && cur_brace.is_some() 
                {
                    let _ = stream.next();
                    return Ok(false);
                } else if is::end_delimiter(peek) 
                {
                    return parse_err
                    (
                        stream.file(),
                        InvalidClosingBracket(cur_brace, peek, stream.line(), stream.col()),
                    );
                }

                // Get the field line/col.
                let (field_line, field_col) = (stream.line(), stream.col());

                // Parse field.
                let (field, is_global, is_parent) = parse_field(stream.clone(), field_line, field_col)?;

                if !is_global && !is_parent && obj.contains_key(&field) 
                {
                    return parse_err(stream.file(), DuplicateField(field, field_line, field_col));
                } else if is_parent && parent.is_some() 
                {
                    return parse_err(
                        stream.file(),
                        DuplicateField("^".into(), field_line, field_col),
                    );
                }

                // Deal with extra whitespace between field and value.
                if !find_char(stream.clone()) 
                {
                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                }

                // At a non-whitespace character, parse value.
                let (value_line, value_col) = (stream.line(), stream.col());
                let value = parse_value
                (
                    &mut stream,
                    obj,
                    &mut globals,
                    &mut included,
                    value_line,
                    value_col,
                    depth,
                    cur_brace,
                    true,
                )?;

                // Add value either to the globals map or to the current Obj.
                if is_global 
                {
                    if globals.contains_key(&field) 
                    {
                        return parse_err(stream.file(), DuplicateGlobal(field, field_line, field_col));
                    }
                    globals.insert(field, value);
                } else if is_parent 
                {
                    let par = value
                        .get_obj()
                        .map_err(|e| ParseError::from_over(&e, stream.file(), value_line, value_col))?;
                    *parent = Some(par);
                } else 
                {
                    obj.insert(field, value);
                }

                // Go to the next non-whitespace character.
                if !find_char(stream.clone()) 
                {
                    match cur_brace 
                    {
                        Some(_) => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                        None => return Ok(false),
                    }
                }

                Ok(true)
            }
            /// Parses an Arr given a file.
            fn parse_arr_file(path: &str, mut included: &mut IncludedMap) -> ParseResult<Arr> 
            {
                let mut stream = CharStream::from_file(path)?;

                let obj: ObjMap = HashMap::new();
                let mut globals: GlobalMap = HashMap::new();

                let mut vec = Vec::new();
                let mut tcur = Type::Any;
                let mut has_any = true;

                loop 
                {
                    // Go to the first non-whitespace character, or error if there is none.
                    if !find_char(stream.clone()) 
                    {
                        break;
                    }

                    // At a non-whitespace character, parse value.
                    let (value_line, value_col) = (stream.line(), stream.col());
                    let value = parse_value
                    (
                        &mut stream,
                        &obj,
                        &mut globals,
                        &mut included,
                        value_line,
                        value_col,
                        1,
                        None,
                        true,
                    )?;

                    let tnew = value.get_type();

                    if has_any 
                    {
                        match Type::most_specific(&tcur, &tnew) 
                        {
                            Some((t, any)) => 
                            {
                                tcur = t;
                                has_any = any;
                            }
                            None => 
                            {
                                return parse_err
                                (
                                    stream.file(),
                                    ExpectedType(tcur, tnew, value_line, value_col),
                                );
                            }
                        }
                    } else if tcur != tnew 
                    {
                        return parse_err
                        (
                            stream.file(),
                            ExpectedType(tcur, tnew, value_line, value_col),
                        );
                    }

                    vec.push(value);
                }

                let arr = Arr::from_vec_unchecked(vec, tcur);

                Ok(arr)
            }
            /// Parses a sub-Arr in a file. It *must* start with [ and end with ].
            pub fn parse_arr
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
            ) -> ParseResult<Value>
            {
                // Check depth.
                if depth > MAX_DEPTH {
                    return parse_err(stream.file(), MaxDepth(stream.line(), stream.col()));
                }

                // We must already be at a '['.
                let ch = stream.next().unwrap();
                assert_eq!(ch, '[');

                let mut vec = Vec::new();
                let mut tcur = Type::Any;
                let mut has_any = true;

                loop {
                    // Go to the first non-whitespace character, or error if there is none.
                    if !find_char(stream.clone()) {
                        return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                    }

                    let peek = stream.peek().unwrap();
                    if peek == ']' {
                        let _ = stream.next();
                        break;
                    } else if is::end_delimiter(peek) {
                        return parse_err(
                            stream.file(),
                            InvalidClosingBracket(Some(']'), peek, stream.line(), stream.col()),
                        );
                    }

                    // At a non-whitespace character, parse value.
                    let (value_line, value_col) = (stream.line(), stream.col());
                    let value = parse_value(
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        value_line,
                        value_col,
                        depth,
                        Some(']'),
                        true,
                    )?;

                    let tnew = value.get_type();

                    if has_any {
                        match Type::most_specific(&tcur, &tnew) {
                            Some((t, any)) => {
                                tcur = t;
                                has_any = any;
                            }
                            None => {
                                return parse_err(
                                    stream.file(),
                                    ExpectedType(tcur, tnew, value_line, value_col),
                                );
                            }
                        }
                    } else if tcur != tnew {
                        return parse_err(
                            stream.file(),
                            ExpectedType(tcur, tnew, value_line, value_col),
                        );
                    }

                    vec.push(value);
                }

                let arr = Arr::from_vec_unchecked(vec, tcur);

                Ok(arr.into())
            }
            /// Parses a Tup given a file.
            pub fn parse_tup_file(path: &str, mut included: &mut IncludedMap) -> ParseResult<Tup>
            {
                let mut stream = CharStream::from_file(path)?;

                let mut vec: Vec<Value> = Vec::new();
                let obj: ObjMap = HashMap::new();
                let mut globals: GlobalMap = HashMap::new();

                loop {
                    // Go to the first non-whitespace character, or error if there is none.
                    if !find_char(stream.clone()) {
                        break;
                    }

                    // At a non-whitespace character, parse value.
                    let (value_line, value_col) = (stream.line(), stream.col());
                    let value = parse_value(
                        &mut stream,
                        &obj,
                        &mut globals,
                        &mut included,
                        value_line,
                        value_col,
                        1,
                        None,
                        true,
                    )?;

                    vec.push(value);
                }

                Ok(vec.into())
            }
            /// Parses a sub-Tup in a file. It *must* start with ( and end with ).
            pub fn parse_tup
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
            ) -> ParseResult<Value>
            {
                if depth > MAX_DEPTH { return parse_err(stream.file(), MaxDepth(stream.line(), stream.col())); }
                let mut vec = Vec::new();
                let ch = stream.next().unwrap();
                assert_eq!(ch, '(');
                
                loop 
                {
                    if !find_char(stream.clone()) { return parse_err(stream.file(), UnexpectedEnd(stream.line())); }

                    let peek = stream.peek().unwrap();

                    if peek == ')' 
                    {
                        let _ = stream.next();
                        break;
                    } 
                    else if is::end_delimiter(peek) 
                    {
                        return parse_err
                        (
                            stream.file(),
                            InvalidClosingBracket(Some(')'), peek, stream.line(), stream.col()),
                        );
                    }
                    
                    let (value_line, value_col) = (stream.line(), stream.col());
                    let value = parse_value
                    (
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        value_line,
                        value_col,
                        depth,
                        Some(')'),
                        true,
                    )?;

                    vec.push(value);
                }

                let tup = Tup::from_vec(vec);

                Ok(tup.into())
            }
            /// Gets the next field in the char stream.
            pub fn parse_field
            (
                mut stream: CharStream,
                line: usize,
                col: usize,
            ) -> ParseResult<(String, bool, bool)>
            {
                let mut field = String::new();
                let mut first = true;
                let mut is_global = false;

                let ch = stream.peek().unwrap();
                if ch == '@' {
                    let ch = stream.next().unwrap();
                    is_global = true;
                    field.push(ch);
                }

                while let Some(ch) = stream.next() {
                    match ch {
                        ':' if !first => {
                            break;
                        }
                        ch if Obj::is_valid_field_char(ch, first) => field.push(ch),
                        ch => {
                            return parse_err(
                                stream.file(),
                                InvalidFieldChar(ch, stream.line(), stream.col() - 1),
                            );
                        }
                    }

                    first = false;
                }

                // Check for invalid field names.
                match field.as_str() {
                    _field_str if is::reserved(_field_str) => {
                        parse_err(stream.file(), InvalidFieldName(field.clone(), line, col))
                    }
                    "^" => Ok((field.clone(), false, true)),
                    bad if bad.starts_with('^') => {
                        parse_err(stream.file(), InvalidFieldName(field.clone(), line, col))
                    }
                    _ => Ok((field.clone(), is_global, false)),
                }
            }
            /// Gets the next value in the char stream.
            pub fn parse_value
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                line: usize,
                col: usize,
                depth: usize,
                cur_brace: Option<char>,
                is_first: bool,
            ) -> ParseResult<Value>
            {
                // Peek to determine what kind of value we'll be parsing.
                let res = match stream.peek().unwrap() {
                    '"' => parse_str(&mut stream)?,
                    '\'' => parse_char(&mut stream)?,
                    '{' => parse_obj(&mut stream, &mut globals, included, depth + 1)?,
                    '[' => parse_arr(&mut stream, obj, &mut globals, included, depth + 1)?,
                    '(' => parse_tup(&mut stream, obj, &mut globals, included, depth + 1)?,
                    '@' => parse_variable(
                        &mut stream,
                        obj,
                        globals,
                        included,
                        line,
                        col,
                        depth,
                        cur_brace,
                    )?,
                    '<' => parse_include(&mut stream, obj, &mut globals, &mut included, depth + 1)?,
                    ch @ '+' | ch @ '-' => {
                        parse_unary_op(&mut stream, obj, globals, included, depth, cur_brace, ch)?
                    }
                    ch if is::numeric_char(ch) => parse_numeric(&mut stream, line, col)?,
                    ch if Obj::is_valid_field_char(ch, true) => parse_variable(
                        &mut stream,
                        obj,
                        globals,
                        included,
                        line,
                        col,
                        depth,
                        cur_brace,
                    )?,
                    ch => {
                        return parse_err(stream.file(), InvalidValueChar(ch, line, col));
                    }
                };

                // Process operations if this is the first value.
                if is_first {
                    let mut val_deque: VecDeque<(Value, usize, usize)> = VecDeque::new();
                    let mut op_deque: VecDeque<char> = VecDeque::new();
                    val_deque.push_back((res, line, col));

                    loop {
                        match stream.peek() {
                            Some(ch) if is::operator(ch) => {
                                let _ = stream.next();
                                if stream.peek().is_none() {
                                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                                }

                                let (line2, col2) = (stream.line(), stream.col());

                                // Parse another value.
                                let val2 = parse_value(
                                    &mut stream,
                                    obj,
                                    &mut globals,
                                    &mut included,
                                    line2,
                                    col2,
                                    depth,
                                    cur_brace,
                                    false,
                                )?;

                                if is::priority_operator(ch) {
                                    let (val1, line1, col1) = val_deque.pop_back().unwrap();
                                    let res = binary_op_on_values(stream, val1, val2, ch, line2, col2)?;
                                    val_deque.push_back((res, line1, col1));
                                } else {
                                    val_deque.push_back((val2, line2, col2));
                                    op_deque.push_back(ch);
                                }
                            }
                            _ => break,
                        }
                    }

                    // Check for valid characters after the value.
                    check_value_end(stream, cur_brace)?;

                    let (mut val1, _, _) = val_deque.pop_front().unwrap();
                    while !op_deque.is_empty() 
                    {
                        let (val2, line2, col2) = val_deque.pop_front().unwrap();
                        val1 = binary_op_on_values(
                            stream,
                            val1,
                            val2,
                            op_deque.pop_front().unwrap(),
                            line2,
                            col2,
                        )?;
                    }
                    Ok(val1)
                } else {
                    Ok(res)
                }
            }

            fn parse_unary_op
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
                cur_brace: Option<char>,
                ch: char,
            ) -> ParseResult<Value>
            {
                let _ = stream.next();
                let line = stream.line();
                let col = stream.col();

                let res = match stream.peek() {
                    Some(_) => parse_value(
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        line,
                        col,
                        depth + 1,
                        cur_brace,
                        false,
                    )?,
                    None => return parse_err(stream.file(), UnexpectedEnd(line)),
                };
                unary_op_on_value(stream, res, ch, line, col)
            }
            /// Gets the next numeric (either Int or Frac) in the character stream.
            fn parse_numeric(stream: &mut CharStream, line: usize, col: usize) -> ParseResult<Value>
            {
                let mut s1 = String::new();
                let mut s2 = String::new();
                let mut dec = false;
                let mut under = false;

                while let Some(ch) = stream.peek() {
                    match ch {
                        ch if is::value_end_char(ch) => break,
                        ch if is::char_digit(ch) => {
                            if !dec {
                                s1.push(ch);
                            } else {
                                s2.push(ch);
                            }
                        }
                        '.' | ',' => {
                            if !dec {
                                dec = true;
                            } else {
                                return parse_err(
                                    stream.file(),
                                    InvalidValueChar(ch, stream.line(), stream.col()),
                                );
                            }
                        }
                        '_' => {
                            if !under {
                                under = true;
                            } else {
                                return parse_err(
                                    stream.file(),
                                    InvalidValueChar(ch, stream.line(), stream.col()),
                                );
                            }
                        }
                        _ => {
                            return parse_err(
                                stream.file(),
                                InvalidValueChar(ch, stream.line(), stream.col()),
                            );
                        }
                    }

                    if ch != '_' {
                        under = false;
                    }

                    let _ = stream.next();
                }

                if dec {
                    // Parse a Frac from a number with a decimal.
                    if s1.is_empty() && s2.is_empty() {
                        return parse_err(stream.file(), InvalidNumeric(line, col));
                    }

                    let whole: BigInt = if s1.is_empty() {
                        0u8.into()
                    } else {
                        s1.parse()?
                    };

                    // Remove trailing zeros.
                    let s2 = s2.trim_end_matches('0');

                    let (decimal, dec_len): (BigInt, usize) = if s2.is_empty() {
                        (0u8.into(), 1)
                    } else {
                        (s2.parse()?, s2.len())
                    };

                    let f = frac_from_whole_and_dec(whole, decimal, dec_len);
                    Ok(f.into())
                } else {
                    // Parse an Int.
                    if s1.is_empty() {
                        return parse_err(stream.file(), InvalidNumeric(line, col));
                    }

                    let i: BigInt = s1.parse()?;
                    Ok(i.into())
                }
            }
            /// Parses a variable name and gets a value from the corresponding variable.
            fn parse_variable
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                line: usize,
                col: usize,
                depth: usize,
                cur_brace: Option<char>,
            ) -> ParseResult<Value>
            {
                let mut var = String::new();
                let mut is_global = false;
                let mut dot = false;
                let mut dot_global = false;

                let ch = stream.peek().unwrap();
                if ch == '@' {
                    let ch = stream.next().unwrap();
                    is_global = true;
                    var.push(ch);
                }

                while let Some(ch) = stream.peek() {
                    match ch {
                        '.' => {
                            let _ = stream.next();
                            match stream.peek() {
                                Some('@') => dot_global = true,
                                Some(ch) if Obj::is_valid_field_char(ch, true) || is::numeric_char(ch) => (),
                                Some(ch) => {
                                    return parse_err(
                                        stream.file(),
                                        InvalidValueChar(ch, stream.line(), stream.col()),
                                    );
                                }
                                None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                            }

                            dot = true;
                            break;
                        }
                        ch if is::value_end_char(ch) => break,
                        ch if Obj::is_valid_field_char(ch, false) => {
                            let _ = stream.next();
                            var.push(ch);
                        }
                        ch => {
                            return parse_err(
                                stream.file(),
                                InvalidValueChar(ch, stream.line(), stream.col()),
                            );
                        }
                    }
                }

                let mut value = match var.as_str() {
                    "null" => Value::Null,
                    "true" => Value::Bool(true),
                    "false" => Value::Bool(false),

                    "Obj" => Value::Obj(OBJ_SENTINEL.clone()),
                    "Str" => Value::Obj(STR_SENTINEL.clone()),
                    "Arr" => Value::Obj(ARR_SENTINEL.clone()),
                    "Tup" => Value::Obj(TUP_SENTINEL.clone()),

                    var @ "@" => return parse_err(stream.file(), InvalidValue(var.into(), line, col)),
                    var if is_global => {
                        // Global variable, get value from globals map.
                        match globals.get(var) {
                            Some(value) => value.clone(),
                            None => {
                                let var = String::from(var);
                                return parse_err(stream.file(), GlobalNotFound(var, line, col));
                            }
                        }
                    }
                    var => {
                        // Regular variable, get value from the current Obj.
                        match obj.get(var) {
                            Some(value) => value.clone(),
                            None => {
                                let var = String::from(var);
                                return parse_err(stream.file(), VariableNotFound(var, line, col));
                            }
                        }
                    }
                };

                if dot {
                    value = match value {
                        Value::Arr(arr) => {
                            let (line, col) = (stream.line(), stream.col());
                            let value = parse_value(
                                &mut stream,
                                obj,
                                &mut globals,
                                &mut included,
                                line,
                                col,
                                depth + 1,
                                cur_brace,
                                false,
                            )?;

                            match value {
                                Value::Int(int) => match int.to_usize() {
                                    Some(index) => arr
                                        .get(index)
                                        .map_err(|e| ParseError::from_over(&e, stream.file(), line, col))?,
                                    None => return parse_err(stream.file(), InvalidIndex(int, line, col)),
                                },
                                _ => {
                                    return parse_err(
                                        stream.file(),
                                        ExpectedType(Type::Int, value.get_type(), line, col),
                                    );
                                }
                            }
                        }
                        Value::Tup(tup) => {
                            let (line, col) = (stream.line(), stream.col());
                            let value = parse_value(
                                &mut stream,
                                obj,
                                &mut globals,
                                &mut included,
                                line,
                                col,
                                depth + 1,
                                cur_brace,
                                false,
                            )?;

                            match value {
                                Value::Int(int) => match int.to_usize() {
                                    Some(index) => tup
                                        .get(index)
                                        .map_err(|e| ParseError::from_over(&e, stream.file(), line, col))?,
                                    None => return parse_err(stream.file(), InvalidIndex(int, line, col)),
                                },
                                _ => {
                                    return parse_err(
                                        stream.file(),
                                        ExpectedType(Type::Int, value.get_type(), line, col),
                                    );
                                }
                            }
                        }
                        Value::Obj(obj) => {
                            let (line, col) = (stream.line(), stream.col());

                            if dot_global {
                                return parse_err(stream.file(), InvalidValueChar('@', line, col));
                            }

                            parse_variable(
                                &mut stream,
                                obj.map_ref(),
                                globals,
                                included,
                                line,
                                col,
                                depth + 1,
                                cur_brace,
                            )?
                        }
                        _ => return parse_err(stream.file(), InvalidDot(value.get_type(), line, col)),
                    }
                }

                Ok(value)
            }
            /// Gets the next Char in the character stream.
            pub fn parse_char(stream: &mut CharStream) -> ParseResult<Value>
            {
                let ch = stream.next().unwrap();
                assert_eq!(ch, '\'');

                let (escape, mut ch) = match stream.next() {
                    Some('\\') => (true, '\0'),
                    Some(ch) if ch == '\n' || ch == '\r' || ch == '\t' => {
                        return parse_err(
                            stream.file(),
                            InvalidValueChar(ch, stream.line(), stream.col() - 1),
                        );
                    }
                    Some(ch) => (false, ch),
                    None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                };

                if escape {
                    ch = match stream.next() {
                        Some(ch) => match char::get_escape(ch) {
                            Some(ch) => ch,
                            None => {
                                return parse_err(
                                    stream.file(),
                                    InvalidEscapeChar(ch, stream.line(), stream.col() - 1),
                                );
                            }
                        },
                        None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                    }
                }

                match stream.next() {
                    Some('\'') => (),
                    Some(ch) => {
                        return parse_err(
                            stream.file(),
                            InvalidValueChar(ch, stream.line(), stream.col() - 1),
                        );
                    }
                    None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                }

                Ok(ch.into())
            }

            fn parse_str_file(path: &str) -> ParseResult<String>
            {
                let s = str::read_file(path)?.replace("\r\n", "\n");
                Ok(s)
            }
            /// Gets the next Str in the character stream.
            pub fn parse_str(stream: &mut CharStream) -> ParseResult<Value>
            {
                let ch = stream.next().unwrap();
                assert_eq!(ch, '"');

                let mut s = String::new();
                let mut escape = false;

                loop {
                    match stream.next() {
                        Some(ch) => {
                            if escape {
                                match char::get_escape(ch) {
                                    Some(ch) => s.push(ch),
                                    None => {
                                        return parse_err(
                                            stream.file(),
                                            InvalidEscapeChar(ch, stream.line(), stream.col() - 1),
                                        );
                                    }
                                }
                                escape = false;
                            } else {
                                match ch {
                                    '"' => break,
                                    '\\' => escape = true,
                                    _ => s.push(ch),
                                }
                            }
                        }
                        None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                    }
                }

                // Replace \r\n line endings with \n for consistency in internal handling.
                let s = s.replace("\r\n", "\n");

                Ok(s.into())
            }

            pub fn parse_include
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
            ) -> ParseResult<Value>
            {
                enum IncludeType {
                    Obj,
                    Str,
                    Arr,
                    Tup,
                }

                // Check depth.
                if depth > MAX_DEPTH {
                    return parse_err(stream.file(), MaxDepth(stream.line(), stream.col()));
                }

                let ch = stream.next().unwrap();
                assert_eq!(ch, '<');

                // Go to the next non-whitespace character, or error if there is none.
                if !find_char(stream.clone()) {
                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                }

                let (mut line, mut col) = (stream.line(), stream.col());
                let mut value = parse_value(
                    &mut stream,
                    obj,
                    &mut globals,
                    &mut included,
                    line,
                    col,
                    depth,
                    Some('>'),
                    true,
                )?;

                let mut include_type = IncludeType::Obj; // Default include type if no token is present.
                let mut parse_again = true; // True if an include token was found.
                match value {
                    Value::Obj(ref obj) if obj.ptr_eq(&OBJ_SENTINEL) => include_type = IncludeType::Obj,
                    Value::Obj(ref obj) if obj.ptr_eq(&STR_SENTINEL) => include_type = IncludeType::Str,
                    Value::Obj(ref obj) if obj.ptr_eq(&ARR_SENTINEL) => include_type = IncludeType::Arr,
                    Value::Obj(ref obj) if obj.ptr_eq(&TUP_SENTINEL) => include_type = IncludeType::Tup,
                    Value::Str(_) => parse_again = false,
                    _ => {
                        return parse_err(
                            stream.file(),
                            InvalidIncludeToken(value.get_type(), line, col),
                        );
                    }
                }

                if parse_again {
                    // Go to the next non-whitespace character, or error if there is none.
                    if !find_char(stream.clone()) {
                        return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                    }

                    line = stream.line();
                    col = stream.col();
                    value = parse_value(
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        line,
                        col,
                        depth,
                        Some('>'),
                        true,
                    )?;
                }

                // Go to the next non-whitespace character, or error if there is none.
                if !find_char(stream.clone()) {
                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                }

                match stream.next().unwrap() {
                    '>' => (),
                    ch => {
                        return parse_err(
                            stream.file(),
                            InvalidClosingBracket(Some('>'), ch, stream.line(), stream.col() - 1),
                        );
                    }
                }

                // Get the full path of the include file.
                let include_file = match value {
                    Value::Str(s) => s,
                    _ => {
                        return parse_err(
                            stream.file(),
                            ExpectedType(Type::Str, value.get_type(), line, col),
                        );
                    }
                };

                let pathbuf = match stream.file().as_ref() {
                    Some(file) => Path::new(file)
                        .parent()
                        .unwrap()
                        .join(Path::new(&include_file)),
                    None => Path::new(&include_file).to_path_buf(),
                };
                let path = pathbuf.as_path();
                if !path.is_file() {
                    return parse_err(stream.file(), InvalidIncludePath(include_file, line, col));
                }

                // Get the include file as a path relative to the current working directory.
                let path_str = match path.to_str() {
                    Some(path) => path,
                    None => return parse_err(stream.file(), InvalidIncludePath(include_file, line, col)),
                };

                // Get the include file as an absolute path.
                let path = match path.canonicalize() {
                    Ok(path) => path,
                    Err(_) => return parse_err(stream.file(), InvalidIncludePath(include_file, line, col)),
                };
                let full_path_str = match path.to_str() {
                    Some(path) => path,
                    None => return parse_err(stream.file(), InvalidIncludePath(include_file, line, col)),
                };

                // Prevent cyclic includes by temporarily storing the current file path.
                let storing = if let Some(file) = stream.file() {
                    let full_file = String::from(Path::new(&file).canonicalize().unwrap().to_str().unwrap());
                    included.1.insert(full_file.clone());
                    Some(full_file)
                } else {
                    None
                };
                if included.1.contains(full_path_str) {
                    return parse_err(stream.file(), CyclicInclude(include_file, line, col));
                }

                // Get either the tracked value or parse it if it's our first time seeing the include.
                let value = if included.0.contains_key(full_path_str) {
                    let value = &included.0[full_path_str];
                    value.clone()
                } else {
                    let value: Value = match include_type {
                        IncludeType::Obj => parse_obj_file_includes(path_str, included)?.into(),
                        IncludeType::Str => parse_str_file(path_str)?.into(),
                        IncludeType::Arr => parse_arr_file(path_str, included)?.into(),
                        IncludeType::Tup => parse_tup_file(path_str, included)?.into(),
                    };
                    // Use full path as included key.
                    included.0.insert(full_path_str.into(), value.clone());
                    value
                };

                // Remove the stored file path.
                if let Some(file) = storing {
                    included.1.remove(&file);
                }

                Ok(value)
            }
            /// Tries to perform a unary operation on a single value.
            pub fn unary_op_on_value
            (
                stream: &CharStream,
                val: Value,
                op: char,
                line: usize,
                col: usize,
            ) -> ParseResult<Value>
            {
                use ::database::types::Type::*;

                let t = val.get_type();

                Ok(match op {
                    '+' => match t {
                        Int | Frac => val,
                        _ => return parse_err(stream.file(), UnaryOperatorError(t, op, line, col)),
                    },
                    '-' => match t {
                        Int => (-val.get_int().unwrap()).into(),
                        Frac => (-val.get_frac().unwrap()).into(),
                        _ => return parse_err(stream.file(), UnaryOperatorError(t, op, line, col)),
                    },
                    _ => return parse_err(stream.file(), UnaryOperatorError(t, op, line, col)),
                })
            }
            /// Tries to perform an operation on two values.
            pub fn binary_op_on_values
            (
                stream: &CharStream,
                mut val1: Value,
                mut val2: Value,
                op: char,
                line: usize,
                col: usize,
            ) -> ParseResult<Value>
            {
                use ::database::types::Type::*;

                let (mut type1, mut type2) = (val1.get_type(), val2.get_type());
                
                if type1 == Int && type2 == Frac 
                {
                    val1 = Value::Frac(BigRational::new(val1.get_int().unwrap(), 1.into()));
                    type1 = Frac;
                }
                
                else if type1 == Frac && type2 == Int 
                {
                    val2 = Value::Frac(BigRational::new(val2.get_int().unwrap(), 1.into()));
                    type2 = Frac;
                }

                Ok(match op 
                {
                    '+' => 
                    {
                        match type1 
                        {
                            Int if type2 == Int => (val1.get_int().unwrap() + val2.get_int().unwrap()).into(),
                            Frac if type2 == Frac => 
                            {
                                (val1.get_frac().unwrap() + val2.get_frac().unwrap()).into()
                            }
                            Char if type2 == Char => 
                            {
                                let mut s = String::with_capacity(2);
                                s.push(val1.get_char().unwrap());
                                s.push(val2.get_char().unwrap());
                                s.into()
                            }
                            Char if type2 == Str => 
                            {
                                let str2 = val2.get_str().unwrap();
                                let mut s = String::with_capacity(1 + str2.len());
                                s.push(val1.get_char().unwrap());
                                s.push_str(&str2);
                                s.into()
                            }
                            Str if type2 == Char => 
                            {
                                let str1 = val1.get_str().unwrap();
                                let mut s = String::with_capacity(str1.len() + 1);
                                s.push_str(&str1);
                                s.push(val2.get_char().unwrap());
                                s.into()
                            }
                            Str if type2 == Str => 
                            {
                                let str1 = val1.get_str().unwrap();
                                let str2 = val2.get_str().unwrap();
                                let mut s = String::with_capacity(str1.len() + str2.len());
                                s.push_str(&str1);
                                s.push_str(&str2);
                                s.into()
                            }
                            Arr(_) => 
                            {
                                match Type::most_specific(&type1, &type2) 
                                {
                                    Some((t, _)) => 
                                    {
                                        let (arr1, arr2) = (val1.get_arr().unwrap(), val2.get_arr().unwrap());
                                        let (mut vec1, mut vec2) =
                                            (arr1.vec_ref().clone(), arr2.vec_ref().clone());

                                        let mut vec = Vec::with_capacity(vec1.len() + vec2.len());
                                        vec.append(&mut vec1);
                                        vec.append(&mut vec2);

                                        // Get the inner type.
                                        let arr = if let Arr(ref t) = t 
                                        {
                                            // Because we know the type already, we can safely use `_unchecked`.
                                            arrays::Arr::from_vec_unchecked(vec, t.deref().clone())
                                        } else 
                                        {
                                            panic!("Logic error")
                                        };

                                        arr.into()
                                    }
                                    None => {
                                        return parse_err
                                        (
                                            stream.file(),
                                            BinaryOperatorError(type1, type2, op, line, col),
                                        );
                                    }
                                }
                            }
                            _ => {
                                return parse_err
                                (
                                    stream.file(),
                                    BinaryOperatorError(type1, type2, op, line, col),
                                );
                            }
                        }
                    }
                    '-' => match type1 
                    {
                        Int if type2 == Int => (val1.get_int().unwrap() - val2.get_int().unwrap()).into(),
                        Frac if type2 == Frac => (val1.get_frac().unwrap() - val2.get_frac().unwrap()).into(),
                        _ => {
                            return parse_err(
                                stream.file(),
                                BinaryOperatorError(type1, type2, op, line, col),
                            );
                        }
                    }
                    ,
                    '*' => match type1 
                    {
                        Int if type2 == Int => (val1.get_int().unwrap() * val2.get_int().unwrap()).into(),
                        Frac if type2 == Frac => (val1.get_frac().unwrap() * val2.get_frac().unwrap()).into(),
                        _ => {
                            return parse_err(
                                stream.file(),
                                BinaryOperatorError(type1, type2, op, line, col),
                            );
                        }
                    }
                    ,
                    '/' => match type1 
                    {
                        Int if type2 == Int => {
                            let (int1, int2) = (val1.get_int().unwrap(), val2.get_int().unwrap());
                            if int2.is_zero() {
                                return parse_err(stream.file(), InvalidNumeric(line, col));
                            }
                            BigRational::new(int1, int2).into()
                        }
                        Frac if type2 == Frac => {
                            let (frac1, frac2) = (val1.get_frac().unwrap(), val2.get_frac().unwrap());
                            if frac2.is_zero() {
                                return parse_err(stream.file(), InvalidNumeric(line, col));
                            }
                            (frac1 / frac2).into()
                        }
                        _ => {
                            return parse_err(
                                stream.file(),
                                BinaryOperatorError(type1, type2, op, line, col),
                            );
                        }
                    }
                    ,
                    '%' => match type1 
                    {
                        Int if type2 == Int => {
                            let int2 = val2.get_int().unwrap();
                            if int2.is_zero() {
                                return parse_err(stream.file(), InvalidNumeric(line, col));
                            }
                            (val1.get_int().unwrap() % int2).into()
                        }
                        _ => {
                            return parse_err(
                                stream.file(),
                                BinaryOperatorError(type1, type2, op, line, col),
                            );
                        }
                    },
                    _ => 
                    {
                        return parse_err(
                            stream.file(),
                            BinaryOperatorError(type1, type2, op, line, col),
                        );
                    }
                })
            }
            /// Finds the next non-whitespace character, ignoring comments, and update stream position.
            pub fn find_char(mut stream: CharStream) -> bool
            {
                while let Some(ch) = stream.peek() 
                {
                    match ch 
                    {
                        '#' => 
                        {
                            // Comment found; eat the rest of the line.
                            loop {
                                let ch = stream.next();
                                if ch.is_none() 
                                {
                                    return false;
                                }
                                if ch.unwrap() == '\n' 
                                {
                                    break;
                                }
                            }
                        }

                        ch if ch.is_whitespace() => 
                        {
                            let _ = stream.next();
                        }

                        _ => return true,
                    }
                }

                false
            }
            /// Helper function to make sure values are followed by a correct end delimiter.
            pub fn check_value_end(stream: &CharStream, cur_brace: Option<char>) -> ParseResult<()>
            {
                match stream.peek() 
                {
                    Some(ch) => match ch 
                    {
                        ch if is::value_end_char(ch) => 
                        {
                            if is::end_delimiter(ch) && Some(ch) != cur_brace 
                            {
                                parse_err(
                                    stream.file(),
                                    InvalidClosingBracket(cur_brace, ch, stream.line(), stream.col()),
                                )
                            } else 
                            {
                                Ok(())
                            }
                        }

                        ch => parse_err
                        (
                            stream.file(),
                            InvalidValueChar(ch, stream.line(), stream.col()),
                        ),
                    },
                    None => Ok(()),
                }
            }
        }
        
        use super::Obj;

        pub type ParseResult<T> = Result<T, ParseError>;
        pub const MAX_DEPTH: usize = 64;
        /// Load an `Obj` from a file.
        pub fn load_from_file(path: &str) -> ParseResult<Obj> { parser::parse_obj_file(path) }
        /// Load an `Obj` from a &str.
        pub fn load_from_str(contents: &str) -> ParseResult<Obj> { parser::parse_obj_str(contents) }
    }
    /// pls custom database.
    #[derive(Eq, PartialEq, Clone, Debug)]
    pub struct Database
    {
        pub name:String,
        pub description:String,
        pub alias:Vec<String>,
        pub object:Option<Obj>,
    }
    
    impl Database 
    {
        /// Create a new database with constant support.
        pub const fn new() -> Self
        {
            Self
            {
                name:String::new(),
                description:String::new(),
                alias: Vec::new(),
                object: None,
            }
        }
        /// Create a new database with a backing name, description, and Obj
        pub fn create( name:String, description:String, object:Obj ) -> Self
        {
            Self
            {
                name,
                description,
                alias: Vec::new(),
                object:Some( object ),
            }
        }
        /// Create a new database with a backing name, description, and HashMap
        pub fn create_from_map( name:String, description:String, map:HashMap<String, values::Value> ) -> OverResult<Self>
        {
            match Obj::from_map( map )
            {
                Ok( object ) => Ok( Self::create( name, description, object ) ),
                Err( e ) => Err( e )
            }
        }
        /// Create a new database with a backing name, description, and HashMap, and given parent.
        pub fn create_from_map_with_parent( name:String, description:String, map:HashMap<String, values::Value>, parent: Obj ) -> OverResult<Self>
        {
            match Obj::from_map_with_parent( map, parent )
            {
                Ok( object ) => Ok( Self::create( name, description, object ) ),
                Err( e ) => Err( e )
            }
        }
        /// Build the object data of the database once it has been established.
        pub fn build( &mut self ) -> Self
        {
            match &self.object
            {
                None =>
                {
                    self.object = Some( Obj::default() );
                    return self.clone();
                }
                Some( db ) => self.clone()
            }
        }
        /// Load a database from the current environment.
        pub fn from_env() -> OverResult<Self> 
        {
            if let Ok( filepath ) = env::var("PLS") { Self::from_file( &filepath ) }
            else  { Err( OverError::EnvironmentFileNotFound ) }
        }
        /// Returns a new `Obj` loaded from a file.
        pub fn from_file( filepath:&str ) -> OverResult<Self>
        {
            Ok( Self::create( "pls".to_string(), "...".to_string(), Obj::from_file( filepath )? ) )
        }
        /// Gets the `Value` associated with `field`.
        pub fn get(&self, field: &str) -> OverResult<values::Value>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    match db.get( field )
                    {
                        None => Err( OverError::FieldNotFound( field.to_string() ) ),
                        Some( found ) =>
                        {
                            Ok( found )
                        }
                    }
                }
            }
        }
        /// Returns the ID of this `Obj`.
        pub fn identify( &self ) -> usize
        {
            match &self.object
            {
                None => 0,
                Some( db ) => 
                {
                    return db.id();
                }
            }
        }
        /// Returns a reference to the inner map of this `Obj`.
        pub fn refer( &self ) -> Option<&HashMap<String, values::Value>>
        {
            match &self.object
            {
                None => None,
                Some( db ) => 
                {
                    return Some( db.map_ref() );
                }
            }
        }
        /// Writes this `Obj` to given file in `.over` representation.
        pub fn write_to_file( &self, path:&str ) -> OverResult<()> 
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    db.write_to_file( path )
                }
            }
        }
        /// Writes this `Obj` to a `String`.
        pub fn write_str(&self) -> String
        {
            match &self.object
            {
                None => String::new(),
                Some( db ) =>
                {
                    return db.write_str();
                }
            }
        }
        /// Iterates over each `(String, Value)` pair in `self`, applying `f`.
        pub fn with_each<F>(&self, mut f: F) where
        F: FnMut(&String, &values::Value),
        {
            match &self.object
            {
                None => { return },
                Some( db ) =>
                {
                    db.with_each( f )
                }
            }
        }
        /// Returns the number of fields for this `Obj` (parent fields not included).
        pub fn len(&self) -> usize
        {
            match &self.object
            {
                None => 0,
                Some( db ) =>
                {
                    return db.len();
                }
            }
        }
        /// Returns whether this `Obj` is empty.
        pub fn is_empty(&self) -> bool
        {
            match &self.object
            {
                None => true,
                Some( db ) =>
                {
                    return db.is_empty();
                }
            }
        }
        /// Returns whether `self` and `other` point to the same data.
        pub fn ptr_eq(&self, other: &Self) -> bool
        {
            match &self.object
            {
                None => false,
                Some( this ) =>
                {
                    match &other.object
                    {
                        None => false,
                        Some( that ) =>
                        {
                            this.ptr_eq( &that )
                        }
                    }
                }
            }
        }
        /// Returns whether this `Obj` is empty.
        pub fn contains(&self, field: &str) -> bool
        {
            match &self.object
            {
                None => false,
                Some( db ) =>
                {
                    return db.contains( field );
                }
            }
        }
        /// Gets the `Value` associated with `field` and the `Obj` where it was found.
        pub fn get_with_source(&self, field: &str) -> Option<(values::Value, Obj)>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return db.get_with_source( field );
                }
            }
        }
        /// Returns the `bool` found at `field`.
        pub fn get_bool(&self, field: &str) -> OverResult<bool>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_bool( field );
                }
            }
        }
        /// Returns the `BigInt` found at `field`.
        pub fn get_int(&self, field: &str) -> OverResult<num::big::BigInt>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_int( field );
                }
            }
        }
        /// Returns the `BigRational` found at `field`.
        pub fn get_frac(&self, field: &str) -> OverResult<num::rational::BigRational>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_frac( field );
                }
            }
        }
        /// Returns the `char` found at `field`.
        pub fn get_char(&self, field: &str) -> OverResult<char>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_char( field );
                }
            }
        }
        /// Returns the `String` found at `field`.
        pub fn get_str(&self, field: &str) -> OverResult<String>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_str( field );
                }
            }
        }
        /// Returns the `Arr` found at `field`.
        pub fn get_arr(&self, field: &str) -> OverResult<Arr>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_arr( field );
                }
            }
        }
        /// Returns the `Tup` found at `field`.
        pub fn get_tup(&self, field: &str) -> OverResult<Tup>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_tup( field );
                }
            }
        }
        /// Returns the `Obj` found at `field`.
        pub fn get_obj(&self, field: &str) -> OverResult<Obj>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_obj( field );
                }
            }
        }
        /// Returns whether this `Obj` has a parent.
        pub fn has_parent(&self) -> bool
        {
            match &self.object
            {
                None => false,
                Some( db ) =>
                {
                    return db.has_parent();
                }
            }
        }
        /// Returns the parent for this `Obj`.
        pub fn get_parent(&self) -> Option<Obj>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return db.get_parent();
                }
            }
        }
        /// Returns true if `field` is a valid field name for an `Obj`.
        pub fn valid( &self, field: &str ) -> bool
        {
            Obj::is_valid_field( field )
        }
        /// An iterator visiting all fields (keys) in arbitrary order.
        pub fn keys(&self) -> Option<Keys<String, values::Value>>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return Some( db.keys() );
                }
            }
        }
        /// An iterator visiting all fields (keys) in arbitrary order.
        pub fn values(&self) -> Option<Values<String, values::Value>>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return Some( db.values() );
                }
            }
        }
        /// An iterator visiting all fields (keys) in arbitrary order.
        pub fn iter(&self) -> Option<Iter<String, values::Value>>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return Some( db.iter() );
                }
            }
        }
    }
}

pub mod default
{
    pub use std::default::{ * };
}

pub mod env
{
    pub use std::env::{ * };
}

pub mod error
{
    pub use std::error::{ * };

    pub mod no
    {
        use ::
        {
            *,
        };
    }
}

pub mod ffi
{
    pub use std::ffi::{ * };
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod fs
{
    pub use std::fs::{ * };
}

pub mod hash
{
    pub use std::hash::{ * };
}

pub mod io
{
    pub use std::io::{ * };
}

pub mod iter
{
    pub use std::iter::{ * };
}

pub mod is
{
    use ::
    {
        *,
    };
    /*
    pub fn is_alphabetic(...) -> bool */
    /// Tests if byte is ASCII alphabetic: A-Z, a-z
    #[inline] pub fn alphabetic(chr: u8) -> bool { (chr >= 0x41 && chr <= 0x5A) || (chr >= 0x61 && chr <= 0x7A) }
    /*
    pub fn is_digit(...) -> bool */
    /// Tests if byte is ASCII digit: 0-9
    #[inline] pub fn digit(chr: u8) -> bool { chr >= 0x30 && chr <= 0x39 }
    /*
    pub fn is_hex_digit(...) -> bool */
    /// Tests if byte is ASCII hex digit: 0-9, A-F, a-f
    #[inline] pub fn hex_digit(chr: u8) -> bool 
    { (chr >= 0x30 && chr <= 0x39) || (chr >= 0x41 && chr <= 0x46) || (chr >= 0x61 && chr <= 0x66) }
    /*
    pub fn is_oct_digit(...) -> bool */
    /// Tests if byte is ASCII octal digit: 0-7
    #[inline] pub fn oct_digit(chr: u8) -> bool { chr >= 0x30 && chr <= 0x37 }
    /*
    pub fn is_alphanumeric(...) -> bool */
    /// Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9
    #[inline] pub fn alphanumeric(chr: u8) -> bool { alphabetic(chr) || digit(chr) }
    /*
    pub fn is_space(...) -> bool */
    /// Tests if byte is ASCII space or tab
    #[inline] pub fn space(chr: u8) -> bool { chr == b' ' || chr == b'\t' }
    /*
    pub fn is_newline(...) -> bool */
    /// Tests if byte is ASCII newline: \n
    #[inline] pub fn newline(chr: u8) -> bool { chr == b'\n' }
    /*
    pub fn is_value_end_char(...) -> bool */
    /// Returns true if this character signifies the legal end of a value.
    pub fn value_end_char(ch: char) -> bool {
        whitespace(ch) || end_delimiter(ch) || operator(ch)
    }
    /*
    pub fn is_whitespace(...) -> bool */
    /// Returns true if the character is either whitespace or '#' (start of a comment).
    pub fn whitespace(ch: char) -> bool {
        ch.is_whitespace() || ch == '#'
    }
    /*
    pub fn is_end_delimiter(...) -> bool */
    pub fn end_delimiter(ch: char) -> bool {
        match ch {
            ')' | ']' | '}' | '>' => true,
            _ => false,
        }
    }
    /*
    pub fn is_numeric_char(...) -> bool */
    pub fn numeric_char(ch: char) -> bool {
        match ch {
            _ch if is::char_digit(_ch) => true,
            '.' | ',' => true,
            _ => false,
        }
    }
    /*
    pub fn is_priority_operator(...) -> bool */
    pub fn priority_operator(ch: char) -> bool {
        match ch {
            '*' | '/' | '%' => true,
            _ => false,
        }
    }
    /*
    pub fn is_operator(...) -> bool */
    pub fn operator(ch: char) -> bool
    {
        match ch {
            '+' | '-' | '*' | '/' | '%' => true,
            _ => false,
        }
    }
    /*
    pub fn is_reserved(...) -> bool */
    pub fn reserved(field: &str) -> bool {
        match field {
            "@" | "null" | "true" | "false" | "Obj" | "Str" | "Arr" | "Tup" => true,
            _ => false,
        }
    }
    /*
    pub fn is_digit(...) -> bool */
    /// Returns true if `ch` is an ASCII decimal digit.
    pub fn char_digit(ch: char) -> bool
    {
        match ch
        {
            '0'..='9' => true,
            _ => false,
        }
    }
    /*
    pub fn is_combining_mark(ch: char) -> bool */
    /// Returns whether the given character is a combining mark.
    #[inline] pub fn combining_mark(ch: char) -> bool
    {
        use unicode_normalization::char::is_combining_mark;
        is_combining_mark(ch)
    }
    /*
    pub fn is_visible(ch: char) -> bool */
    pub fn visible(ch: char) -> bool
    {
        match ch
        {
            '\t' | '\r' | '\n' => true,
            _ => char::width(ch).unwrap_or(0) != 0
        }
    }
    /*
    pub fn is_ctrl(...) -> bool */
    /// Returns whether the given character is a control character.
    #[inline] pub fn ctrl(ch: char) -> bool
    {
        let ch = ch as u32;
        ch & ( 0x1f as u32 ) == ch
    }
}
/*
libc */
pub mod libc
{
    //! libc - Raw FFI bindings to platforms' system libraries
    pub mod primitives
    {
        //! This module contains type aliases for C's platform-specific types and fixed-width integer types.
        use ::
        {
            *,
        };

        pub type c_schar = i8;
        pub type c_uchar = u8;
        pub type c_short = i16;
        pub type c_ushort = u16;

        pub type c_longlong = i64;
        pub type c_ulonglong = u64;

        pub type c_float = f32;
        pub type c_double = f64;
        
        pub type c_char = i8;
        
        pub type c_int = i32;
        pub type c_uint = u32;

        pub type c_long = i32;
        pub type c_ulong = u32;

    }  pub use self::primitives::{ * };
    
    pub mod unix
    {
        use ::
        {
            ffi::{ * },
            *,
        };
        
        pub type intmax_t = i64;
        pub type uintmax_t = u64;

        pub type size_t = usize;
        pub type ptrdiff_t = isize;
        pub type intptr_t = isize;
        pub type uintptr_t = usize;
        pub type ssize_t = isize;

        pub type pid_t = i32;
        pub type in_addr_t = u32;
        pub type in_port_t = u16;
        pub type sighandler_t = size_t;
        pub type cc_t = c_uchar;
        pub type tcflag_t = c_uint;

        pub const NCCS: usize = 32;

        
        pub const STDIN_FILENO: c_int = 0;
        pub const STDOUT_FILENO: c_int = 1;
        pub const STDERR_FILENO: c_int = 2;
        
        pub const TIOCGWINSZ: c_int = 0x5401;
        pub const TIOCSWINSZ: c_int = 0x5402;
        pub const TIOCLINUX: c_int = 0x5403;
        pub const TIOCGPGRP: c_int = 0x540f;
        pub const TIOCSPGRP: c_int = 0x5410;                

        extern "C"
        {
            pub fn ioctl(fd: c_int, request: c_int, ...) -> c_int;
        }

        pub struct termios
        {
            pub c_iflag: tcflag_t,
            pub c_oflag: tcflag_t,
            pub c_cflag: tcflag_t,
            pub c_lflag: tcflag_t,
            pub c_line: cc_t,
            pub c_cc: [cc_t; NCCS],
        }

    } #[cfg(unix)] pub use self::unix::*;

    pub mod windows
    {
        use ::
        {
            *,
        };
        
        pub use std::os::raw::c_void;
        pub type c_char = i8;
        pub type c_schar = i8;
        pub type c_uchar = u8;
        pub type c_short = i16;
        pub type c_ushort = u16;
        pub type c_int = i32;
        pub type c_uint = u32;
        pub type c_long = i32;
        pub type c_ulong = u32;
        pub type c_longlong = i64;
        pub type c_ulonglong = u64;
        pub type c_float = f32;
        pub type c_double = f64;
        pub type __int8 = i8;
        pub type __uint8 = u8;
        pub type __int16 = i16;
        pub type __uint16 = u16;
        pub type __int32 = i32;
        pub type __uint32 = u32;
        pub type __int64 = i64;
        pub type __uint64 = u64;
        pub type wchar_t = u16;

        pub type ULONG = c_ulong;
        pub type PULONG = *mut ULONG;
        pub type USHORT = c_ushort;
        pub type PUSHORT = *mut USHORT;
        pub type UCHAR = c_uchar;
        pub type PUCHAR = *mut UCHAR;
        pub type PSZ = *mut c_char;
        pub const MAX_PATH: usize = 260;
        pub const FALSE: BOOL = 0;
        pub const TRUE: BOOL = 1;
        pub type DWORD = c_ulong;
        pub type BOOL = c_int;
        pub type BYTE = c_uchar;
        pub type WORD = c_ushort;
        pub type FLOAT = c_float;
        pub type PFLOAT = *mut FLOAT;
        pub type PBOOL = *mut BOOL;
        pub type LPBOOL = *mut BOOL;
        pub type PBYTE = *mut BYTE;
        pub type LPBYTE = *mut BYTE;
        pub type PINT = *mut c_int;
        pub type LPINT = *mut c_int;
        pub type PWORD = *mut WORD;
        pub type LPWORD = *mut WORD;
        pub type LPLONG = *mut c_long;
        pub type PDWORD = *mut DWORD;
        pub type LPDWORD = *mut DWORD;
        pub type LPVOID = *mut c_void;
        pub type LPCVOID = *const c_void;
        pub type INT = c_int;
        pub type UINT = c_uint;
        pub type PUINT = *mut c_uint;
        pub type POINTER_64_INT = usize;
        pub type INT8 = c_schar;
        pub type PINT8 = *mut c_schar;
        pub type INT16 = c_short;
        pub type PINT16 = *mut c_short;
        pub type INT32 = c_int;
        pub type PINT32 = *mut c_int;
        pub type INT64 = __int64;
        pub type PINT64 = *mut __int64;
        pub type UINT8 = c_uchar;
        pub type PUINT8 = *mut c_uchar;
        pub type UINT16 = c_ushort;
        pub type PUINT16 = *mut c_ushort;
        pub type UINT32 = c_uint;
        pub type PUINT32 = *mut c_uint;
        pub type UINT64 = __uint64;
        pub type PUINT64 = *mut __uint64;
        pub type LONG32 = c_int;
        pub type PLONG32 = *mut c_int;
        pub type ULONG32 = c_uint;
        pub type PULONG32 = *mut c_uint;
        pub type DWORD32 = c_uint;
        pub type PDWORD32 = *mut c_uint;
        pub type INT_PTR = isize;
        pub type PINT_PTR = *mut isize;
        pub type UINT_PTR = usize;
        pub type PUINT_PTR = *mut usize;
        pub type LONG_PTR = isize;
        pub type PLONG_PTR = *mut isize;
        pub type ULONG_PTR = usize;
        pub type PULONG_PTR = *mut usize;
        pub type SHANDLE_PTR = isize;
        pub type HANDLE_PTR = usize;
        pub type WPARAM = UINT_PTR;
        pub type LPARAM = LONG_PTR;
        pub type LRESULT = LONG_PTR;

        
        #[cfg(target_pointer_width = "32")]
        pub type PHALF_PTR = *mut c_short;
        #[cfg(target_pointer_width = "64")]
        pub type PHALF_PTR = *mut c_int;
        pub type SIZE_T = ULONG_PTR;
        pub type PSIZE_T = *mut ULONG_PTR;
        pub type SSIZE_T = LONG_PTR;
        pub type PSSIZE_T = *mut LONG_PTR;
        pub type DWORD_PTR = ULONG_PTR;
        pub type PDWORD_PTR = *mut ULONG_PTR;
        pub type LONG64 = __int64;
        pub type PLONG64 = *mut __int64;
        pub type ULONG64 = __uint64;
        pub type PULONG64 = *mut __uint64;
        pub type DWORD64 = __uint64;
        pub type PDWORD64 = *mut __uint64;
        pub type KAFFINITY = ULONG_PTR;
        pub type PKAFFINITY = *mut KAFFINITY;

        pub type PKEY_EVENT_RECORD = *mut KEY_EVENT_RECORD;
        pub const RIGHT_ALT_PRESSED: DWORD = 0x0001;
        pub const LEFT_ALT_PRESSED: DWORD = 0x0002;
        pub const RIGHT_CTRL_PRESSED: DWORD = 0x0004;
        pub const LEFT_CTRL_PRESSED: DWORD = 0x0008;
        pub const SHIFT_PRESSED: DWORD = 0x0010;
        pub const NUMLOCK_ON: DWORD = 0x0020;
        pub const SCROLLLOCK_ON: DWORD = 0x0040;
        pub const CAPSLOCK_ON: DWORD = 0x0080;
        pub const ENHANCED_KEY: DWORD = 0x0100;
        pub const NLS_DBCSCHAR: DWORD = 0x00010000;
        pub const NLS_ALPHANUMERIC: DWORD = 0x00000000;
        pub const NLS_KATAKANA: DWORD = 0x00020000;
        pub const NLS_HIRAGANA: DWORD = 0x00040000;
        pub const NLS_ROMAN: DWORD = 0x00400000;
        pub const NLS_IME_CONVERSION: DWORD = 0x00800000;
        pub const NLS_IME_DISABLE: DWORD = 0x20000000;

        #[repr( C )] struct GROUP_AFFINITY 
        {
            Mask: KAFFINITY,
            Group: USHORT,
            Reserved: [USHORT; 3],
        }
        
        pub const CTRL_C_EVENT: DWORD = 0;
        pub const CTRL_BREAK_EVENT: DWORD = 1;
        pub const CTRL_CLOSE_EVENT: DWORD = 2;
        pub const CTRL_LOGOFF_EVENT: DWORD = 5;
        pub const CTRL_SHUTDOWN_EVENT: DWORD = 6;
        pub const ENABLE_PROCESSED_INPUT: DWORD = 0x0001;
        pub const ENABLE_LINE_INPUT: DWORD = 0x0002;
        pub const ENABLE_ECHO_INPUT: DWORD = 0x0004;
        pub const ENABLE_WINDOW_INPUT: DWORD = 0x0008;
        pub const ENABLE_MOUSE_INPUT: DWORD = 0x0010;
        pub const ENABLE_INSERT_MODE: DWORD = 0x0020;
        pub const ENABLE_QUICK_EDIT_MODE: DWORD = 0x0040;
        pub const ENABLE_EXTENDED_FLAGS: DWORD = 0x0080;
        pub const ENABLE_AUTO_POSITION: DWORD = 0x0100;
        pub const ENABLE_VIRTUAL_TERMINAL_INPUT: DWORD = 0x0200;
        pub const ENABLE_PROCESSED_OUTPUT: DWORD = 0x0001;
        pub const ENABLE_WRAP_AT_EOL_OUTPUT: DWORD = 0x0002;
        pub const ENABLE_VIRTUAL_TERMINAL_PROCESSING: DWORD = 0x0004;
        pub const DISABLE_NEWLINE_AUTO_RETURN: DWORD = 0x0008;
        pub const ENABLE_LVB_GRID_WORLDWIDE: DWORD = 0x0010;

        pub type PGROUP_AFFINITY = *mut GROUP_AFFINITY;
        pub const MAXIMUM_PROC_PER_GROUP: UCHAR = 64;
        pub const MAXIMUM_PROCESSORS: UCHAR = MAXIMUM_PROC_PER_GROUP;
        pub type HANDLE = *mut c_void;
        pub type PHANDLE = *mut HANDLE;
        pub type FCHAR = UCHAR;
        pub type FSHORT = USHORT;
        pub type FLONG = ULONG;
        pub type HRESULT = c_long;
        pub const OBJ_HANDLE_TAGBITS: usize = 0x00000003;
        pub type CCHAR = c_char;
        pub type CSHORT = c_short;
        pub type CLONG = ULONG;
        pub type PCCHAR = *mut CCHAR;
        pub type PCSHORT = *mut CSHORT;
        pub type PCLONG = *mut CLONG;
        pub type LCID = ULONG;
        pub type PLCID = PULONG;
        pub type LANGID = USHORT;

        pub const SYSTEM_CACHE_ALIGNMENT_SIZE: usize = 128;
        pub type PVOID = *mut c_void;
        pub type PVOID64 = u64; // This is a 64-bit pointer, even when in 32-bit
        pub type VOID = c_void;
        pub type CHAR = c_char;
        pub type SHORT = c_short;
        pub type LONG = c_long;
        pub type WCHAR = wchar_t;
        pub type PWCHAR = *mut WCHAR;
        pub type LPWCH = *mut WCHAR;
        pub type PWCH = *mut WCHAR;
        pub type LPCWCH = *const WCHAR;
        pub type PCWCH = *const WCHAR;
        pub type NWPSTR = *mut WCHAR;
        pub type LPWSTR = *mut WCHAR;
        pub type LPTSTR = LPSTR;
        pub type PWSTR = *mut WCHAR;
        pub type PZPWSTR = *mut PWSTR;
        pub type PCZPWSTR = *const PWSTR;
        pub type LPUWSTR = *mut WCHAR; // Unaligned pointer
        pub type PUWSTR = *mut WCHAR; // Unaligned pointer
        pub type LPCWSTR = *const WCHAR;
        pub type PCWSTR = *const WCHAR;
        pub type PZPCWSTR = *mut PCWSTR;
        pub type PCZPCWSTR = *const PCWSTR;
        pub type LPCUWSTR = *const WCHAR; // Unaligned pointer
        pub type PCUWSTR = *const WCHAR; // Unaligned pointer
        pub type PZZWSTR = *mut WCHAR;
        pub type PCZZWSTR = *const WCHAR;
        pub type PUZZWSTR = *mut WCHAR; // Unaligned pointer
        pub type PCUZZWSTR = *const WCHAR; // Unaligned pointer
        pub type PNZWCH = *mut WCHAR;
        pub type PCNZWCH = *const WCHAR;
        pub type PUNZWCH = *mut WCHAR; // Unaligned pointer
        pub type PCUNZWCH = *const WCHAR; // Unaligned pointer
        pub type LPCWCHAR = *const WCHAR;
        pub type PCWCHAR = *const WCHAR;
        pub type LPCUWCHAR = *const WCHAR; // Unaligned pointer
        pub type PCUWCHAR = *const WCHAR; // Unaligned pointer
        pub type UCSCHAR = c_ulong;
        pub const UCSCHAR_INVALID_CHARACTER: UCSCHAR = 0xffffffff;
        pub const MIN_UCSCHAR: UCSCHAR = 0;
        pub const MAX_UCSCHAR: UCSCHAR = 0x0010FFFF;
        pub type PUCSCHAR = *mut UCSCHAR;
        pub type PCUCSCHAR = *const UCSCHAR;
        pub type PUCSSTR = *mut UCSCHAR;
        pub type PUUCSSTR = *mut UCSCHAR; // Unaligned pointer
        pub type PCUCSSTR = *const UCSCHAR;
        pub type PCUUCSSTR = *const UCSCHAR; // Unaligned pointer
        pub type PUUCSCHAR = *mut UCSCHAR; // Unaligned pointer
        pub type PCUUCSCHAR = *const UCSCHAR; // Unaligned pointer
        pub type PCHAR = *mut CHAR;
        pub type LPCH = *mut CHAR;
        pub type PCH = *mut CHAR;
        pub type LPCCH = *const CHAR;
        pub type PCCH = *const CHAR;
        pub type NPSTR = *mut CHAR;
        pub type LPSTR = *mut CHAR;
        pub type PSTR = *mut CHAR;
        pub type PZPSTR = *mut PSTR;
        pub type PCZPSTR = *const PSTR;
        pub type LPCSTR = *const CHAR;
        pub type PCSTR = *const CHAR;
        pub type PZPCSTR = *mut PCSTR;
        pub type PCZPCSTR = *const PCSTR;
        pub type PZZSTR = *mut CHAR;
        pub type PCZZSTR = *const CHAR;
        pub type PNZCH = *mut CHAR;
        pub type PCNZCH = *const CHAR;

        pub const FILE_SHARE_READ: DWORD = 0x00000001;
        pub const FILE_SHARE_WRITE: DWORD = 0x00000002;
        pub const FILE_SHARE_DELETE: DWORD = 0x00000004;
        // Skipping TCHAR things
        pub type DOUBLE = c_double;

        pub const WAIT_TIMEOUT: DWORD = 258;

        pub type PCONSOLE_READCONSOLE_CONTROL = *mut CONSOLE_READCONSOLE_CONTROL;
        pub const CONSOLE_TEXTMODE_BUFFER: DWORD = 1;
        pub type PEXCEPTION_POINTERS = *mut EXCEPTION_POINTERS;
        pub type PACCESS_TOKEN = PVOID;
        pub type PSECURITY_DESCRIPTOR = PVOID;
        pub type PSID = PVOID;
        pub type PCLAIMS_BLOB = PVOID;
        pub type ACCESS_MASK = DWORD;
        pub type PACCESS_MASK = *mut ACCESS_MASK;
        pub const DELETE: DWORD = 0x00010000;
        pub const READ_CONTROL: DWORD = 0x00020000;
        pub const WRITE_DAC: DWORD = 0x00040000;
        pub const WRITE_OWNER: DWORD = 0x00080000;
        pub const SYNCHRONIZE: DWORD = 0x00100000;
        pub const STANDARD_RIGHTS_REQUIRED: DWORD = 0x000F0000;
        pub const STANDARD_RIGHTS_READ: DWORD = READ_CONTROL;
        pub const STANDARD_RIGHTS_WRITE: DWORD = READ_CONTROL;
        pub const STANDARD_RIGHTS_EXECUTE: DWORD = READ_CONTROL;
        pub const STANDARD_RIGHTS_ALL: DWORD = 0x001F0000;
        pub const SPECIFIC_RIGHTS_ALL: DWORD = 0x0000FFFF;
        pub const ACCESS_SYSTEM_SECURITY: DWORD = 0x01000000;
        pub const MAXIMUM_ALLOWED: DWORD = 0x02000000;
        pub const GENERIC_READ: DWORD = 0x80000000;
        pub const GENERIC_WRITE: DWORD = 0x40000000;
        pub const GENERIC_EXECUTE: DWORD = 0x20000000;
        pub const GENERIC_ALL: DWORD = 0x10000000;
        
        pub const STD_INPUT_HANDLE: DWORD = -10i32 as u32;
        pub const STD_OUTPUT_HANDLE: DWORD = -11i32 as u32;
        pub const STD_ERROR_HANDLE: DWORD = -12i32 as u32;
        
        pub type PMOUSE_EVENT_RECORD = *mut MOUSE_EVENT_RECORD;
        pub const FROM_LEFT_1ST_BUTTON_PRESSED: DWORD = 0x0001;
        pub const RIGHTMOST_BUTTON_PRESSED: DWORD = 0x0002;
        pub const FROM_LEFT_2ND_BUTTON_PRESSED: DWORD = 0x0004;
        pub const FROM_LEFT_3RD_BUTTON_PRESSED: DWORD = 0x0008;
        pub const FROM_LEFT_4TH_BUTTON_PRESSED: DWORD = 0x0010;
        pub const MOUSE_MOVED: DWORD = 0x0001;
        pub const DOUBLE_CLICK: DWORD = 0x0002;
        pub const MOUSE_WHEELED: DWORD = 0x0004;
        pub const MOUSE_HWHEELED: DWORD = 0x0008;

        pub const VK_LBUTTON: c_int = 0x01;
        pub const VK_RBUTTON: c_int = 0x02;
        pub const VK_CANCEL: c_int = 0x03;
        pub const VK_MBUTTON: c_int = 0x04;
        pub const VK_XBUTTON1: c_int = 0x05;
        pub const VK_XBUTTON2: c_int = 0x06;
        pub const VK_BACK: c_int = 0x08;
        pub const VK_TAB: c_int = 0x09;
        pub const VK_CLEAR: c_int = 0x0C;
        pub const VK_RETURN: c_int = 0x0D;
        pub const VK_SHIFT: c_int = 0x10;
        pub const VK_CONTROL: c_int = 0x11;
        pub const VK_MENU: c_int = 0x12;
        pub const VK_PAUSE: c_int = 0x13;
        pub const VK_CAPITAL: c_int = 0x14;
        pub const VK_KANA: c_int = 0x15;
        pub const VK_HANGEUL: c_int = 0x15;
        pub const VK_HANGUL: c_int = 0x15;
        pub const VK_JUNJA: c_int = 0x17;
        pub const VK_FINAL: c_int = 0x18;
        pub const VK_HANJA: c_int = 0x19;
        pub const VK_KANJI: c_int = 0x19;
        pub const VK_ESCAPE: c_int = 0x1B;
        pub const VK_CONVERT: c_int = 0x1C;
        pub const VK_NONCONVERT: c_int = 0x1D;
        pub const VK_ACCEPT: c_int = 0x1E;
        pub const VK_MODECHANGE: c_int = 0x1F;
        pub const VK_SPACE: c_int = 0x20;
        pub const VK_PRIOR: c_int = 0x21;
        pub const VK_NEXT: c_int = 0x22;
        pub const VK_END: c_int = 0x23;
        pub const VK_HOME: c_int = 0x24;
        pub const VK_LEFT: c_int = 0x25;
        pub const VK_UP: c_int = 0x26;
        pub const VK_RIGHT: c_int = 0x27;
        pub const VK_DOWN: c_int = 0x28;
        pub const VK_SELECT: c_int = 0x29;
        pub const VK_PRINT: c_int = 0x2A;
        pub const VK_EXECUTE: c_int = 0x2B;
        pub const VK_SNAPSHOT: c_int = 0x2C;
        pub const VK_INSERT: c_int = 0x2D;
        pub const VK_DELETE: c_int = 0x2E;
        pub const VK_HELP: c_int = 0x2F;
        pub const VK_LWIN: c_int = 0x5B;
        pub const VK_RWIN: c_int = 0x5C;
        pub const VK_APPS: c_int = 0x5D;
        pub const VK_SLEEP: c_int = 0x5F;

        pub const FOREGROUND_BLUE: WORD = 0x0001;
        pub const FOREGROUND_GREEN: WORD = 0x0002;
        pub const FOREGROUND_RED: WORD = 0x0004;
        pub const FOREGROUND_INTENSITY: WORD = 0x0008;
        pub const BACKGROUND_BLUE: WORD = 0x0010;
        pub const BACKGROUND_GREEN: WORD = 0x0020;
        pub const BACKGROUND_RED: WORD = 0x0040;
        pub const BACKGROUND_INTENSITY: WORD = 0x0080;
        pub const COMMON_LVB_LEADING_BYTE: WORD = 0x0100;
        pub const COMMON_LVB_TRAILING_BYTE: WORD = 0x0200;
        pub const COMMON_LVB_GRID_HORIZONTAL: WORD = 0x0400;
        pub const COMMON_LVB_GRID_LVERTICAL: WORD = 0x0800;
        pub const COMMON_LVB_GRID_RVERTICAL: WORD = 0x1000;
        pub const COMMON_LVB_REVERSE_VIDEO: WORD = 0x4000;
        pub const COMMON_LVB_UNDERSCORE: WORD = 0x8000;
        pub const COMMON_LVB_SBCSDBCS: WORD = 0x0300;

        extern "system"
        {
            pub fn GetEnvironmentStrings() -> LPCH;
            pub fn GetEnvironmentStringsW() -> LPWCH;
            pub fn SetEnvironmentStringsW( NewEnvironment: LPWCH ) -> BOOL;
            pub fn FreeEnvironmentStringsA( penv: LPCH ) -> BOOL;
            pub fn FreeEnvironmentStringsW( penv: LPWCH ) -> BOOL;
            pub fn GetStdHandle( nStdHandle: DWORD ) -> HANDLE;
            pub fn SetStdHandle( nStdHandle: DWORD, hHandle: HANDLE ) -> BOOL;
            pub fn SetStdHandleEx( nStdHandle: DWORD, hHandle: HANDLE, phPrevValue: PHANDLE ) -> BOOL;
        
            pub fn GetConsoleScreenBufferInfo(
                hConsoleOutput: HANDLE,
                lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO,
            ) -> BOOL;
            pub fn GetConsoleScreenBufferInfoEx(
                hConsoleOutput: HANDLE,
                lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX,
            ) -> BOOL;
            pub fn SetConsoleScreenBufferInfoEx(
                hConsoleOutput: HANDLE,
                lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX,
            ) -> BOOL;
            pub fn GetLargestConsoleWindowSize(
                hConsoleOutput: HANDLE,
            ) -> COORD;
            pub fn GetConsoleCursorInfo(
                hConsoleOutput: HANDLE,
                lpConsoleCursorInfo: PCONSOLE_CURSOR_INFO,
            ) -> BOOL;
            pub fn GetCurrentConsoleFont(
                hConsoleOutput: HANDLE,
                bMaximumWindow: BOOL,
                lpConsoleCurrentFont: PCONSOLE_FONT_INFO,
            ) -> BOOL;
            pub fn GetCurrentConsoleFontEx(
                hConsoleOutput: HANDLE,
                bMaximumWindow: BOOL,
                lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX,
            ) -> BOOL;
            pub fn SetCurrentConsoleFontEx(
                hConsoleOutput: HANDLE,
                bMaximumWindow: BOOL,
                lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX,
            ) -> BOOL;
            pub fn GetConsoleHistoryInfo(
                lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO,
            ) -> BOOL;
            pub fn SetConsoleHistoryInfo(
                lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO,
            ) -> BOOL;
            pub fn GetConsoleFontSize(
                hConsoleOutput: HANDLE,
                nFont: DWORD,
            ) -> COORD;
            pub fn GetConsoleSelectionInfo(
                lpConsoleSelectionInfo: PCONSOLE_SELECTION_INFO,
            ) -> BOOL;
            pub fn GetNumberOfConsoleMouseButtons(
                lpNumberOfMouseButtons: LPDWORD,
            ) -> BOOL;
            pub fn SetConsoleActiveScreenBuffer(
                hConsoleOutput: HANDLE,
            ) -> BOOL;
            pub fn FlushConsoleInputBuffer(
                hConsoleInput: HANDLE,
            ) -> BOOL;
            pub fn SetConsoleScreenBufferSize(
                hConsoleOutput: HANDLE,
                dwSize: COORD,
            ) -> BOOL;
            pub fn SetConsoleCursorPosition(
                hConsoleOutput: HANDLE,
                dwCursorPosition: COORD,
            ) -> BOOL;
            pub fn SetConsoleCursorInfo(
                hConsoleOutput: HANDLE,
                lpConsoleCursorInfo: *const CONSOLE_CURSOR_INFO,
            ) -> BOOL;
            pub fn ScrollConsoleScreenBufferA(
                hConsoleOutput: HANDLE,
                lpScrollRectangle: *const SMALL_RECT,
                lpClipRectangle: *const SMALL_RECT,
                dwDestinationOrigin: COORD,
                lpFill: *const CHAR_INFO,
            ) -> BOOL;
            pub fn ScrollConsoleScreenBufferW(
                hConsoleOutput: HANDLE,
                lpScrollRectangle: *const SMALL_RECT,
                lpClipRectangle: *const SMALL_RECT,
                dwDestinationOrigin: COORD,
                lpFill: *const CHAR_INFO,
            ) -> BOOL;
            pub fn SetConsoleWindowInfo(
                hConsoleOutput: HANDLE,
                bAbsolute: BOOL,
                lpConsoleWindow: *const SMALL_RECT,
            ) -> BOOL;
            pub fn SetConsoleTextAttribute(
                hConsoleOutput: HANDLE,
                wAttributes: WORD,
            ) -> BOOL;
            pub fn GenerateConsoleCtrlEvent(
                dwCtrlEvent: DWORD,
                dwProcessGroupId: DWORD,
            ) -> BOOL;
            pub fn FreeConsole() -> BOOL;
            pub fn AttachConsole(
                dwProcessId: DWORD,
            ) -> BOOL;
            
            pub fn GetConsoleTitleA(
                lpConsoleTitle: LPSTR,
                nSize: DWORD,
            ) -> DWORD;
            pub fn GetConsoleTitleW(
                lpConsoleTitle: LPWSTR,
                nSize: DWORD,
            ) -> DWORD;
            pub fn GetConsoleOriginalTitleA(
                lpConsoleTitle: LPSTR,
                nSize: DWORD,
            ) -> DWORD;
            pub fn GetConsoleOriginalTitleW(
                lpConsoleTitle: LPWSTR,
                nSize: DWORD,
            ) -> DWORD;
            pub fn SetConsoleTitleA(
                lpConsoleTitle: LPCSTR,
            ) -> BOOL;

            pub fn WriteConsoleInputW
            (
                hConsoleInput: HANDLE,
                lpBuffer: *const INPUT_RECORD,
                nLength: DWORD,
                lpNumberOfEventsWritten: LPDWORD,
            ) -> BOOL;

            pub fn CloseHandle(
                hObject: HANDLE,
            ) -> BOOL;

            pub fn CreateConsoleScreenBuffer(
                dwDesiredAccess: DWORD,
                dwShareMode: DWORD,
                lpSecurityAttributes: *const SECURITY_ATTRIBUTES,
                dwFlags: DWORD,
                lpScreenBufferData: LPVOID,
            ) -> HANDLE;

            pub fn SetConsoleMode
            (
                hConsoleHandle: HANDLE,
                dwMode: DWORD,
            ) -> BOOL;

            pub fn AllocConsole() -> BOOL;
            pub fn GetConsoleCP() -> UINT;
            pub fn GetConsoleMode(
                hConsoleHandle: HANDLE,
                lpMode: LPDWORD,
            ) -> BOOL;

            
            pub fn FillConsoleOutputCharacterA
            (
                hConsoleOutput: HANDLE,
                cCharacter: CHAR,
                nLength: DWORD,
                dwWriteCoord: COORD,
                lpNumberOfCharsWritten: LPDWORD,
            ) -> BOOL;

            pub fn FillConsoleOutputCharacterW
            (
                hConsoleOutput: HANDLE,
                cCharacter: WCHAR,
                nLength: DWORD,
                dwWriteCoord: COORD,
                lpNumberOfCharsWritten: LPDWORD,
            ) -> BOOL;

            pub fn FillConsoleOutputAttribute
            (
                hConsoleOutput: HANDLE,
                wAttribute: WORD,
                nLength: DWORD,
                dwWriteCoord: COORD,
                lpNumberOfAttrsWritten: LPDWORD,
            ) -> BOOL;

            pub fn ReadConsoleInputW
            (
                hConsoleInput: HANDLE,
                lpBuffer: PINPUT_RECORD,
                nLength: DWORD,
                lpNumberOfEventsRead: LPDWORD,
            ) -> BOOL;

            pub fn ReadConsoleW
            (
                hConsoleInput: HANDLE,
                lpBuffer: LPVOID,
                nNumberOfCharsToRead: DWORD,
                lpNumberOfCharsRead: LPDWORD,
                pInputControl: PCONSOLE_READCONSOLE_CONTROL,
            ) -> BOOL;

            pub fn WaitForSingleObject(
                hHandle: HANDLE,
                dwMilliseconds: DWORD,
            ) -> DWORD;

            pub fn SetConsoleCtrlHandler(
                HandlerRoutine: PHANDLER_ROUTINE,
                Add: BOOL,
            ) -> BOOL;
        }

        pub type PHANDLER_ROUTINE = Option<unsafe extern "system" fn(CtrlType: DWORD) -> BOOL>;

        pub type NTSTATUS = LONG;
        
        pub const STATUS_USER_APC: NTSTATUS = 0x000000C0;
        pub const STATUS_WAIT_0: NTSTATUS = 0x00000000;
        pub const STATUS_ABANDONED_WAIT_0: NTSTATUS = 0x00000080;
        pub const WAIT_FAILED: DWORD = 0xFFFFFFFF;
        pub const WAIT_OBJECT_0: DWORD = STATUS_WAIT_0 as u32;
        pub const WAIT_ABANDONED: DWORD = STATUS_ABANDONED_WAIT_0 as u32;
        pub const WAIT_ABANDONED_0: DWORD = STATUS_ABANDONED_WAIT_0 as u32;
        pub const WAIT_IO_COMPLETION: DWORD = STATUS_USER_APC as u32;

        pub type PCONSOLE_FONT_INFO = *mut CONSOLE_FONT_INFO;
        pub type PCONSOLE_FONT_INFOEX = *mut CONSOLE_FONT_INFOEX;
        pub type PCONSOLE_CURSOR_INFO = *mut CONSOLE_CURSOR_INFO;
        pub type PCONSOLE_SELECTION_INFO = *mut CONSOLE_SELECTION_INFO;
        pub type PCONSOLE_HISTORY_INFO = *mut CONSOLE_HISTORY_INFO;
        pub type PCONSOLE_SCREEN_BUFFER_INFO = *mut CONSOLE_SCREEN_BUFFER_INFO;
        pub type PCONSOLE_SCREEN_BUFFER_INFOEX = *mut CONSOLE_SCREEN_BUFFER_INFOEX;
        pub type COLORREF = DWORD;

        pub type PINPUT_RECORD = *mut INPUT_RECORD;
        pub const KEY_EVENT: WORD = 0x0001;
        pub const MOUSE_EVENT: WORD = 0x0002;
        pub const WINDOW_BUFFER_SIZE_EVENT: WORD = 0x0004;
        pub const MENU_EVENT: WORD = 0x0008;
        pub const FOCUS_EVENT: WORD = 0x0010;
        pub const ATTACH_PARENT_PROCESS: DWORD = 0xFFFFFFFF;

        pub type PFLOAT128 = *mut FLOAT128;
        pub type LONGLONG = __int64;
        pub type ULONGLONG = __uint64;
        pub const MAXLONGLONG: LONGLONG = 0x7fffffffffffffff;
        pub type PLONGLONG = *mut LONGLONG;
        pub type PULONGLONG = *mut ULONGLONG;
        pub type USN = LONGLONG;

        #[repr( C )] #[derive( Clone, Copy )]
        pub struct FLOAT128
        {
            pub LowPart: __int64,
            pub HighPart: __int64,
        }
        
        #[repr( C )] #[derive( Clone, Copy )]
        pub struct CONTEXT_u( () );

        #[repr( C )] #[derive( Clone, Copy )]
        pub struct M128A {
            pub Low: ULONGLONG,
            pub High: LONGLONG,
        }

        #[repr( C )] #[derive( Clone, Copy )]
        pub struct CONTEXT {

            pub P1Home: DWORD64,
            pub P2Home: DWORD64,
            pub P3Home: DWORD64,
            pub P4Home: DWORD64,
            pub P5Home: DWORD64,
            pub P6Home: DWORD64,
            pub ContextFlags: DWORD,
            pub MxCsr: DWORD,
            pub SegCs: WORD,
            pub SegDs: WORD,
            pub SegEs: WORD,
            pub SegFs: WORD,
            pub SegGs: WORD,
            pub SegSs: WORD,
            pub EFlags: DWORD,
            pub Dr0: DWORD64,
            pub Dr1: DWORD64,
            pub Dr2: DWORD64,
            pub Dr3: DWORD64,
            pub Dr6: DWORD64,
            pub Dr7: DWORD64,
            pub Rax: DWORD64,
            pub Rcx: DWORD64,
            pub Rdx: DWORD64,
            pub Rbx: DWORD64,
            pub Rsp: DWORD64,
            pub Rbp: DWORD64,
            pub Rsi: DWORD64,
            pub Rdi: DWORD64,
            pub R8: DWORD64,
            pub R9: DWORD64,
            pub R10: DWORD64,
            pub R11: DWORD64,
            pub R12: DWORD64,
            pub R13: DWORD64,
            pub R14: DWORD64,
            pub R15: DWORD64,
            pub Rip: DWORD64,
            pub u: CONTEXT_u,
            pub VectorRegister: [M128A; 26],
            pub VectorControl: DWORD64,
            pub DebugControl: DWORD64,
            pub LastBranchToRip: DWORD64,
            pub LastBranchFromRip: DWORD64,
            pub LastExceptionToRip: DWORD64,
            pub LastExceptionFromRip: DWORD64,
        }
        pub type PCONTEXT = *mut CONTEXT;

        #[repr( C )] #[derive( Clone, Copy )]
        pub struct EXCEPTION_RECORD {
            pub ExceptionCode: DWORD,
            pub ExceptionFlags: DWORD,
            pub ExceptionRecord: *mut EXCEPTION_RECORD,
            pub ExceptionAddress: PVOID,
            pub NumberParameters: DWORD,
            pub ExceptionInformation: [ULONG_PTR; 15],
        }

        pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;

        #[repr( C )] #[derive( Clone, Copy )]
        pub struct EXCEPTION_POINTERS {
            pub ExceptionRecord: PEXCEPTION_RECORD,
            pub ContextRecord: PCONTEXT,
        }

        #[repr( C )] #[derive( Clone, Copy )]
        pub struct CONSOLE_READCONSOLE_CONTROL
        {
            pub nLength: ULONG,
            pub nInitialChars: ULONG,
            pub dwCtrlWakeupMask: ULONG,
            pub dwControlKeyState: ULONG,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct WINDOW_BUFFER_SIZE_RECORD
        {
            pub dwSize: COORD,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct SECURITY_ATTRIBUTES
        {
            pub nLength: DWORD,
            pub lpSecurityDescriptor: LPVOID,
            pub bInheritHandle: BOOL,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct CHAR_INFO_Char(()); 

        impl CHAR_INFO_Char
        {
            pub unsafe fn UnicodeChar_mut(&mut self) -> &mut WCHAR
            {
                unsafe
                {
                    mem::transmute( ptr::null_mut::<&mut WCHAR>() )
                }
            }
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct CONSOLE_FONT_INFO
        {
            pub nFont: DWORD,
            pub dwFontSize: COORD,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct CONSOLE_FONT_INFOEX
        {
            pub cbSize: ULONG,
            pub nFont: DWORD,
            pub dwFontSize: COORD,
            pub FontFamily: UINT,
            pub FontWeight: UINT,
            pub FaceName: [WCHAR; 32],
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct CONSOLE_SCREEN_BUFFER_INFOEX
        {
            pub cbSize: ULONG,
            pub dwSize: COORD,
            pub dwCursorPosition: COORD,
            pub wAttributes: WORD,
            pub srWindow: SMALL_RECT,
            pub dwMaximumWindowSize: COORD,
            pub wPopupAttributes: WORD,
            pub bFullscreenSupported: BOOL,
            pub ColorTable: [COLORREF; 16],
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct MOUSE_EVENT_RECORD
        {
            pub dwMousePosition: COORD,
            pub dwButtonState: DWORD,
            pub dwControlKeyState: DWORD,
            pub dwEventFlags: DWORD,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct CONSOLE_HISTORY_INFO 
        {
            pub cbSize: UINT,
            pub HistoryBufferSize: UINT,
            pub NumberOfHistoryBuffers: UINT,
            pub dwFlags: DWORD,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct CONSOLE_SELECTION_INFO
        {
            pub dwFlags: DWORD,
            pub dwSelectionAnchor: COORD,
            pub srSelection: SMALL_RECT,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct CONSOLE_CURSOR_INFO
        {
            pub dwSize: DWORD,
            pub bVisible: BOOL,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct INPUT_RECORD_Event( () );

        impl INPUT_RECORD_Event
        {
            pub unsafe fn WindowBufferSizeEvent(&self) -> &WINDOW_BUFFER_SIZE_RECORD
            {
                unsafe
                {
                    mem::transmute( ptr::null::<&WINDOW_BUFFER_SIZE_RECORD>() )
                }
            }
            
            pub unsafe fn KeyEvent(&self) -> &KEY_EVENT_RECORD
            {
                unsafe
                {
                    mem::transmute( ptr::null::<&KEY_EVENT_RECORD>() )
                }
            }
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct INPUT_RECORD 
        {
            pub EventType: WORD,
            pub Event: INPUT_RECORD_Event,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct CHAR_INFO 
        {
            pub Char: CHAR_INFO_Char,
            pub Attributes: WORD,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct COORD
        {
            pub X: SHORT,
            pub Y: SHORT,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct SMALL_RECT
        {
            pub Left: SHORT,
            pub Top: SHORT,
            pub Right: SHORT,
            pub Bottom: SHORT,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct CONSOLE_SCREEN_BUFFER_INFO 
        {
            pub dwSize: COORD,
            pub dwCursorPosition: COORD,
            pub wAttributes: WORD,
            pub srWindow: SMALL_RECT,
            pub dwMaximumWindowSize: COORD,
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct KEY_EVENT_RECORD_uChar( () );

        impl KEY_EVENT_RECORD_uChar
        {
            pub unsafe fn UnicodeChar(&self) -> &WCHAR
            {
                unsafe
                {
                    mem::transmute( ptr::null::<&WCHAR>() )
                }
            }
        }

        #[repr(C)] #[derive( Clone, Copy )]
        pub struct KEY_EVENT_RECORD
        {
            pub bKeyDown: BOOL,
            pub wRepeatCount: WORD,
            pub wVirtualKeyCode: WORD,
            pub wVirtualScanCode: WORD,
            pub uChar: KEY_EVENT_RECORD_uChar,
            pub dwControlKeyState: DWORD,
        }

        impl KEY_EVENT_RECORD
        {
            pub unsafe fn UnicodeChar(&self) -> &WCHAR
            {
                unsafe
                {
                    mem::transmute( ptr::null::<&WCHAR>() )
                }
            }
        }
    } #[cfg(windows)] pub use self::windows::*;

}

pub mod marker
{
    pub use std::marker::{ * };
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod num
{
    pub use std::num::{ * };
    
    pub mod big
    {
        //! Big Integer Types for Rust
        use ::
        {
            *,
        };

        #[macro_use]
        pub mod macros
        {
            use ::
            {
                *,
            };

            macro_rules! cfg_32 
            {
                ($($any:tt)+) => 
                {
                    #[cfg(not(target_pointer_width = "64"))] $($any)+
                }
            }

            macro_rules! cfg_32_or_test 
            {
                ($($any:tt)+) => 
                {
                    #[cfg(any(not(target_pointer_width = "64"), test))] $($any)+
                }
            }

            macro_rules! cfg_64 
            {
                ($($any:tt)+) => 
                {
                    #[cfg(target_pointer_width = "64")] $($any)+
                }
            }

            macro_rules! cfg_digit 
            {
                ($item32:item $item64:item) => 
                {
                    cfg_32!($item32);
                    cfg_64!($item64);
                };
            }

            macro_rules! cfg_digit_expr 
            {
                ($expr32:expr, $expr64:expr) => 
                {
                    cfg_32!($expr32);
                    cfg_64!($expr64);
                };
            }

            macro_rules! forward_val_val_binop 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for $res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            // forward to val-ref
                            $imp::$method(self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_val_val_binop_commutative 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for $res {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            // forward to val-ref, with the larger capacity as val
                            if self.capacity() >= other.capacity() 
                            {
                                $imp::$method(self, &other)
                            } else 
                            {
                                $imp::$method(other, &self)
                            }
                        }
                    }
                };
            }

            macro_rules! forward_ref_val_binop 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            // forward to ref-ref
                            $imp::$method(self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_ref_val_binop_commutative 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for &$res {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            // reverse, forward to val-ref
                            $imp::$method(other, self)
                        }
                    }
                };
            }

            macro_rules! forward_val_ref_binop 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<&$res> for $res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                            // forward to ref-ref
                            $imp::$method(&self, other)
                        }
                    }
                };
            }

            macro_rules! forward_ref_ref_binop 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<&$res> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                            // forward to val-ref
                            $imp::$method(self.clone(), other)
                        }
                    }
                };
            }

            macro_rules! forward_ref_ref_binop_commutative 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<&$res> for &$res {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                            // forward to val-ref, choosing the larger to clone
                            if self.len() >= other.len() 
                            {
                                $imp::$method(self.clone(), other)
                            } else 
                            {
                                $imp::$method(other.clone(), self)
                            }
                        }
                    }
                };
            }

            macro_rules! forward_val_assign 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for $res 
                    {
                        #[inline] fn $method(&mut self, other: $res) 
                        {
                            self.$method(&other);
                        }
                    }
                };
            }

            macro_rules! forward_val_assign_scalar 
            {
                (impl $imp:ident for $res:ty, $scalar:ty, $method:ident) => 
                {
                    impl $imp<$res> for $scalar 
                    {
                        #[inline] fn $method(&mut self, other: $res) 
                        {
                            self.$method(&other);
                        }
                    }
                };
            }
            /// use this if val_val_binop is already implemented and the reversed order is required
            macro_rules! forward_scalar_val_val_binop_commutative 
            {
                (impl $imp:ident < $scalar:ty > for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for $scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(other, self)
                        }
                    }
                };
            }

            // Forward scalar to ref-val, when reusing storage is not helpful
            macro_rules! forward_scalar_val_val_binop_to_ref_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<$scalar> for $res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $scalar) -> $res 
                        {
                            $imp::$method(&self, other)
                        }
                    }

                    impl $imp<$res> for $scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_ref_ref_binop_to_ref_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<&$scalar> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$scalar) -> $res 
                        {
                            $imp::$method(self, *other)
                        }
                    }

                    impl $imp<&$res> for &$scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                            $imp::$method(*self, other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_val_ref_binop_to_ref_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<&$scalar> for $res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$scalar) -> $res 
                        {
                            $imp::$method(&self, *other)
                        }
                    }

                    impl $imp<$res> for &$scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(*self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_val_ref_binop_to_val_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<&$scalar> for $res {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$scalar) -> $res 
                        {
                            $imp::$method(self, *other)
                        }
                    }

                    impl $imp<$res> for &$scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(*self, other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_ref_val_binop_to_val_val 
            {
                (impl $imp:ident < $scalar:ty > for $res:ty, $method:ident) => 
                {
                    impl $imp<$scalar> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $scalar) -> $res 
                        {
                            $imp::$method(self.clone(), other)
                        }
                    }

                    impl $imp<&$res> for $scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                            $imp::$method(self, other.clone())
                        }
                    }
                };
            }

            macro_rules! forward_scalar_ref_ref_binop_to_val_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<&$scalar> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$scalar) -> $res 
                        {
                            $imp::$method(self.clone(), *other)
                        }
                    }

                    impl $imp<&$res> for &$scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                            $imp::$method(*self, other.clone())
                        }
                    }
                };
            }

            macro_rules! promote_scalars 
            {
                (impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),*) => 
                {
                    $(
                        forward_all_scalar_binop_to_val_val!(impl $imp<$scalar> for $res, $method);

                        impl $imp<$scalar> for $res 
                        {
                            type Output = $res;

                            #[allow(clippy::cast_lossless)]
                            #[inline]
                            fn $method(self, other: $scalar) -> $res 
                            {
                                $imp::$method(self, other as $promo)
                            }
                        }

                        impl $imp<$res> for $scalar 
                        {
                            type Output = $res;

                            #[allow(clippy::cast_lossless)]
                            #[inline]
                            fn $method(self, other: $res) -> $res 
                            {
                                $imp::$method(self as $promo, other)
                            }
                        }
                    )*
                }
            }
            macro_rules! promote_scalars_assign 
            {
                (impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),*) => 
                {
                    $(
                        impl $imp<$scalar> for $res 
                        {
                            #[allow(clippy::cast_lossless)]
                            #[inline]
                            fn $method(&mut self, other: $scalar) 
                            {
                                self.$method(other as $promo);
                            }
                        }
                    )*
                }
            }

            macro_rules! promote_unsigned_scalars 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_scalars!(impl $imp<u32> for $res, $method, u8, u16);
                    promote_scalars!(impl $imp<UsizePromotion> for $res, $method, usize);
                }
            }

            macro_rules! promote_unsigned_scalars_assign 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_scalars_assign!(impl $imp<u32> for $res, $method, u8, u16);
                    promote_scalars_assign!(impl $imp<UsizePromotion> for $res, $method, usize);
                }
            }

            macro_rules! promote_signed_scalars 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_scalars!(impl $imp<i32> for $res, $method, i8, i16);
                    promote_scalars!(impl $imp<IsizePromotion> for $res, $method, isize);
                }
            }

            macro_rules! promote_signed_scalars_assign 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_scalars_assign!(impl $imp<i32> for $res, $method, i8, i16);
                    promote_scalars_assign!(impl $imp<IsizePromotion> for $res, $method, isize);
                }
            }

            // Forward everything to ref-ref, when reusing storage is not helpful
            macro_rules! forward_all_binop_to_ref_ref 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    forward_val_val_binop!(impl $imp for $res, $method);
                    forward_val_ref_binop!(impl $imp for $res, $method);
                    forward_ref_val_binop!(impl $imp for $res, $method);
                };
            }

            // Forward everything to val-ref, so LHS storage can be reused
            macro_rules! forward_all_binop_to_val_ref 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    forward_val_val_binop!(impl $imp for $res, $method);
                    forward_ref_val_binop!(impl $imp for $res, $method);
                    forward_ref_ref_binop!(impl $imp for $res, $method);
                };
            }

            // Forward everything to val-ref, commutatively, so either LHS or RHS storage can be reused
            macro_rules! forward_all_binop_to_val_ref_commutative 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    forward_val_val_binop_commutative!(impl $imp for $res, $method);
                    forward_ref_val_binop_commutative!(impl $imp for $res, $method);
                    forward_ref_ref_binop_commutative!(impl $imp for $res, $method);
                };
            }

            macro_rules! forward_all_scalar_binop_to_ref_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    forward_scalar_val_val_binop_to_ref_val!(impl $imp<$scalar> for $res, $method);
                    forward_scalar_val_ref_binop_to_ref_val!(impl $imp<$scalar> for $res, $method);
                    forward_scalar_ref_ref_binop_to_ref_val!(impl $imp<$scalar> for $res, $method);
                }
            }

            macro_rules! forward_all_scalar_binop_to_val_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    forward_scalar_val_ref_binop_to_val_val!(impl $imp<$scalar> for $res, $method);
                    forward_scalar_ref_val_binop_to_val_val!(impl $imp<$scalar> for $res, $method);
                    forward_scalar_ref_ref_binop_to_val_val!(impl $imp<$scalar> for $res, $method);
                }
            }

            macro_rules! forward_all_scalar_binop_to_val_val_commutative 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    forward_scalar_val_val_binop_commutative!(impl $imp<$scalar> for $res, $method);
                    forward_all_scalar_binop_to_val_val!(impl $imp<$scalar> for $res, $method);
                }
            }

            macro_rules! promote_all_scalars 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_unsigned_scalars!(impl $imp for $res, $method);
                    promote_signed_scalars!(impl $imp for $res, $method);
                }
            }

            macro_rules! promote_all_scalars_assign 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_unsigned_scalars_assign!(impl $imp for $res, $method);
                    promote_signed_scalars_assign!(impl $imp for $res, $method);
                }
            }

            macro_rules! impl_sum_iter_type 
            {
                ($res:ty) => 
                {
                    impl<T> Sum<T> for $res
                    where
                        $res: Add<T, Output = $res>,
                    {
                        fn sum<I>(iter: I) -> Self
                        where
                            I: Iterator<Item = T>,
                        {
                            iter.fold(Self::ZERO, <$res>::add)
                        }
                    }
                };
            }

            macro_rules! impl_product_iter_type 
            {
                ($res:ty) => 
                {
                    impl<T> Product<T> for $res
                    where
                        $res: Mul<T, Output = $res>,
                    {
                        fn product<I>(iter: I) -> Self
                        where
                            I: Iterator<Item = T>,
                        {
                            iter.fold(One::one(), <$res>::mul)
                        }
                    }
                };
            }
        }
        
        pub mod bigint
        {
            use ::
            {
                cmp::Ordering::{self, Equal},
                default::{ Default },
                num::
                {
                    big::
                    {
                        big_digit::{ self, BigDigit },
                        Sign::{Minus, NoSign, Plus},
                        biguint::{to_str_radix_reversed, BigUint, IntDigits, U32Digits, U64Digits}
                    },
                    integers::{ Integer, Roots },
                    traits::{ConstZero, Num, One, Pow, Signed, Zero},
                },
                ops::{ Neg, Not },
                string::{ String },
                vec::{ Vec },
                *,
            };

            pub mod addition
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    iter::{ Sum },
                    num::
                    {
                        big::
                        {
                            bigint::{ UnsignedAbs, CheckedUnsignedAbs::{ self, Negative, Positive } },
                            BigInt, Sign::{Minus, NoSign, Plus}, IsizePromotion, UsizePromotion,
                        },
                        traits::{ CheckedAdd },
                    },
                    ops::{ Add, AddAssign },
                    *,
                };
                
                macro_rules! bigint_add
                {
                    ($a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr) => {
                        match ($a.sign, $b.sign) {
                            (_, NoSign) => $a_owned,
                            (NoSign, _) => $b_owned,
                            // same sign => keep the sign with the sum of magnitudes
                            (Plus, Plus) | (Minus, Minus) => BigInt::from_biguint($a.sign, $a_data + $b_data),
                            // opposite signs => keep the sign of the larger with the difference of magnitudes
                            (Plus, Minus) | (Minus, Plus) => match $a.data.cmp(&$b.data) {
                                Less => BigInt::from_biguint($b.sign, $b_data - $a_data),
                                Greater => BigInt::from_biguint($a.sign, $a_data - $b_data),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }

                impl Add<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: &BigInt) -> BigInt
                    {
                        bigint_add!(
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }

                impl Add<BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: BigInt) -> BigInt {
                        bigint_add!(self, self.clone(), &self.data, other, other, other.data)
                    }
                }

                impl Add<&BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: &BigInt) -> BigInt {
                        bigint_add!(self, self, self.data, other, other.clone(), &other.data)
                    }
                }

                impl Add<BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: BigInt) -> BigInt {
                        bigint_add!(self, self, self.data, other, other, other.data)
                    }
                }

                impl AddAssign<&BigInt> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: &BigInt) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }
                forward_val_assign!(impl AddAssign for BigInt, add_assign);

                promote_all_scalars!(impl Add for BigInt, add);
                promote_all_scalars_assign!(impl AddAssign for BigInt, add_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u32> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u64> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u128> for BigInt, add);

                impl Add<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: u32) -> BigInt {
                        match self.sign {
                            NoSign => From::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }

                impl AddAssign<u32> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: u32) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                impl Add<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: u64) -> BigInt {
                        match self.sign {
                            NoSign => From::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }

                impl AddAssign<u64> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: u64) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                impl Add<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: u128) -> BigInt {
                        match self.sign {
                            NoSign => BigInt::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }
                impl AddAssign<u128> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: u128) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i32> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i64> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i128> for BigInt, add);

                impl Add<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i32> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl Add<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i64> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl Add<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i128> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl CheckedAdd for BigInt 
                {
                    #[inline] fn checked_add(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.add(v))
                    }
                }

                impl_sum_iter_type!(BigInt);

            } pub use self::addition::{ * };

            pub mod division
            
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                CheckedUnsignedAbs::{ Negative, Positive },
                                Sign::{ self, * },
                                BigInt, UnsignedAbs,
                            },
                            IsizePromotion, UsizePromotion,
                        },
                        integers::{ Integer },
                        traits::{ CheckedDiv, CheckedEuclid, Euclid, Signed, ToPrimitive, Zero },
                    },
                    ops::{ Div, DivAssign, Rem, RemAssign },
                    *,
                };
                
                forward_all_binop_to_ref_ref!(impl Div for BigInt, div);

                impl Div<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: &BigInt) -> BigInt {
                        let (q, _) = self.div_rem(other);
                        q
                    }
                }

                impl DivAssign<&BigInt> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: &BigInt) {
                        *self = &*self / other;
                    }
                }
                forward_val_assign!(impl DivAssign for BigInt, div_assign);

                promote_all_scalars!(impl Div for BigInt, div);
                promote_all_scalars_assign!(impl DivAssign for BigInt, div_assign);
                forward_all_scalar_binop_to_val_val!(impl Div<u32> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u64> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u128> for BigInt, div);

                impl Div<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u32> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: u32) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u32 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                impl Div<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u64> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: u64) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u64 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                impl Div<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u128> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: u128) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u128 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Div<i32> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<i64> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<i128> for BigInt, div);

                impl Div<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i32> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i32 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                impl Div<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i64> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i64 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                impl Div<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i128> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i128 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                forward_all_binop_to_ref_ref!(impl Rem for BigInt, rem);

                impl Rem<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: &BigInt) -> BigInt {
                        if let Some(other) = other.to_u32() {
                            self % other
                        } else if let Some(other) = other.to_i32() {
                            self % other
                        } else {
                            let (_, r) = self.div_rem(other);
                            r
                        }
                    }
                }

                impl RemAssign<&BigInt> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: &BigInt) {
                        *self = &*self % other;
                    }
                }
                forward_val_assign!(impl RemAssign for BigInt, rem_assign);

                promote_all_scalars!(impl Rem for BigInt, rem);
                promote_all_scalars_assign!(impl RemAssign for BigInt, rem_assign);
                forward_all_scalar_binop_to_val_val!(impl Rem<u32> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u64> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u128> for BigInt, rem);

                impl Rem<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u32> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: u32) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u32 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                impl Rem<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u64> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: u64) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u64 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                impl Rem<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u128> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: u128) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u128 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Rem<i32> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<i64> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<i128> for BigInt, rem);

                impl Rem<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: i32) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i32> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: i32) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i32 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl Rem<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: i64) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i64> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: i64) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i64 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl Rem<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: i128) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i128> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: i128) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i128 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl CheckedDiv for BigInt 
                {
                    #[inline] fn checked_div(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div(v))
                    }
                }

                impl CheckedEuclid for BigInt 
                {
                    #[inline] fn checked_div_euclid(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div_euclid(v))
                    }

                    #[inline] fn checked_rem_euclid(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.rem_euclid(v))
                    }

                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some(self.div_rem_euclid(v))
                    }
                }

                impl Euclid for BigInt 
                {
                    #[inline] fn div_euclid(&self, v: &BigInt) -> BigInt {
                        let (q, r) = self.div_rem(v);
                        if r.is_negative() {
                            if v.is_positive() {
                                q - 1
                            } else {
                                q + 1
                            }
                        } else {
                            q
                        }
                    }

                    #[inline] fn rem_euclid(&self, v: &BigInt) -> BigInt {
                        let r = self % v;
                        if r.is_negative() {
                            if v.is_positive() {
                                r + v
                            } else {
                                r - v
                            }
                        } else {
                            r
                        }
                    }

                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) 
                    {
                        let (q, r) = self.div_rem(v);
                        if r.is_negative() {
                            if v.is_positive() {
                                (q - 1, r + v)
                            } else {
                                (q + 1, r - v)
                            }
                        } else {
                            (q, r)
                        }
                    }
                }

            } pub use self::division::{ * };

            pub mod multiplication
            {
                use ::
                {
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                CheckedUnsignedAbs::{ Negative, Positive },
                                Sign::{ self,* },
                                BigInt, UnsignedAbs
                            },
                            IsizePromotion, UsizePromotion,
                        },
                        traits::{CheckedMul, One, Zero},
                    },
                    ops::{ Mul, MulAssign },
                    *,
                };
                
                impl Mul<Sign> for Sign
                {
                    type Output = Sign;

                    #[inline] fn mul(self, other: Sign) -> Sign {
                        match (self, other) {
                            (NoSign, _) | (_, NoSign) => NoSign,
                            (Plus, Plus) | (Minus, Minus) => Plus,
                            (Plus, Minus) | (Minus, Plus) => Minus,
                        }
                    }
                }

                macro_rules! impl_mul 
                {
                    ($(impl Mul<$Other:ty> for $Self:ty;)*) => {$(
                        impl Mul<$Other> for $Self {
                            type Output = BigInt;

                            #[inline]
                            fn mul(self, other: $Other) -> BigInt {
                                // automatically match value/ref
                                let BigInt { data: x, .. } = self;
                                let BigInt { data: y, .. } = other;
                                BigInt::from_biguint(self.sign * other.sign, x * y)
                            }
                        }
                    )*}
                }
                impl_mul! 
                {
                    impl Mul<BigInt> for BigInt;
                    impl Mul<BigInt> for &BigInt;
                    impl Mul<&BigInt> for BigInt;
                    impl Mul<&BigInt> for &BigInt;
                }

                macro_rules! impl_mul_assign 
                {
                    ($(impl MulAssign<$Other:ty> for BigInt;)*) => {$(
                        impl MulAssign<$Other> for BigInt {
                            #[inline]
                            fn mul_assign(&mut self, other: $Other) {
                                // automatically match value/ref
                                let BigInt { data: y, .. } = other;
                                self.data *= y;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                } else {
                                    self.sign = self.sign * other.sign;
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! 
                {
                    impl MulAssign<BigInt> for BigInt;
                    impl MulAssign<&BigInt> for BigInt;
                }

                promote_all_scalars!(impl Mul for BigInt, mul);
                promote_all_scalars_assign!(impl MulAssign for BigInt, mul_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u32> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u64> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u128> for BigInt, mul);

                impl Mul<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u32> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: u32) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Mul<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u64> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: u64) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Mul<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u128> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: u128) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i32> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i64> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i128> for BigInt, mul);

                impl Mul<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i32> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl Mul<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i64> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl Mul<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i128> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl CheckedMul for BigInt 
                {
                    #[inline] fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.mul(v))
                    }
                }

                impl_product_iter_type!(BigInt);

            } pub use self::multiplication::{ * };

            pub mod subtraction
            {
                
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                CheckedUnsignedAbs::{ Negative, Positive },
                                Sign::{ self,* },
                                BigInt, UnsignedAbs
                            },
                            IsizePromotion, UsizePromotion,
                        },
                        traits::{ CheckedSub },
                    },
                    ops::{ Sub, SubAssign },
                    *,
                };
                
                macro_rules! bigint_sub 
                {
                    ($a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr) => {
                        match ($a.sign, $b.sign) {
                            (_, NoSign) => $a_owned,
                            (NoSign, _) => -$b_owned,
                            // opposite signs => keep the sign of the left with the sum of magnitudes
                            (Plus, Minus) | (Minus, Plus) => BigInt::from_biguint($a.sign, $a_data + $b_data),
                            // same sign => keep or toggle the sign of the left with the difference of magnitudes
                            (Plus, Plus) | (Minus, Minus) => match $a.data.cmp(&$b.data) {
                                Less => BigInt::from_biguint(-$a.sign, $b_data - $a_data),
                                Greater => BigInt::from_biguint($a.sign, $a_data - $b_data),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }

                impl Sub<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: &BigInt) -> BigInt {
                        bigint_sub!(
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }

                impl Sub<BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        bigint_sub!(self, self.clone(), &self.data, other, other, other.data)
                    }
                }

                impl Sub<&BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: &BigInt) -> BigInt {
                        bigint_sub!(self, self, self.data, other, other.clone(), &other.data)
                    }
                }

                impl Sub<BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        bigint_sub!(self, self, self.data, other, other, other.data)
                    }
                }

                impl SubAssign<&BigInt> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: &BigInt) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }
                forward_val_assign!(impl SubAssign for BigInt, sub_assign);

                promote_all_scalars!(impl Sub for BigInt, sub);
                promote_all_scalars_assign!(impl SubAssign for BigInt, sub_assign);
                forward_all_scalar_binop_to_val_val!(impl Sub<u32> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u64> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u128> for BigInt, sub);

                impl Sub<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: u32) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }
                impl SubAssign<u32> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: u32) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                impl Sub<BigInt> for u32 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<BigInt> for u64 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<BigInt> for u128 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: u64) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }

                impl SubAssign<u64> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: u64) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                impl Sub<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: u128) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }

                impl SubAssign<u128> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: u128) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Sub<i32> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<i64> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<i128> for BigInt, sub);

                impl Sub<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }
                impl SubAssign<i32> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i32 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl Sub<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }
                impl SubAssign<i64> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i64 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl Sub<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }

                impl SubAssign<i128> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i128 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl CheckedSub for BigInt 
                {
                    #[inline] fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.sub(v))
                    }
                }

            } pub use self::subtraction::{ * };

            pub mod bits
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                CheckedUnsignedAbs::{ Negative, Positive },
                                Sign::{ self,* },
                                BigInt, UnsignedAbs
                            },
                            big_digit::{ self, BigDigit, DoubleBigDigit },
                            biguint::IntDigits,
                            IsizePromotion, UsizePromotion,
                        },
                        traits::{ ToPrimitive, Zero },
                    },
                    ops::{ BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign },
                    vec::{ Vec },
                    *,
                };
                // Negation in two's complement.
                // acc must be initialized as 1 for least-significant digit.
                #[inline] fn negate_carry(a: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
                    *acc += DoubleBigDigit::from(!a);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }

                // + 1 & -ff = ...0 01 & ...f 01 = ...0 01 = + 1
                // +ff & - 1 = ...0 ff & ...f ff = ...0 ff = +ff
                // answer is pos, has length of a
                fn bitand_pos_neg(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut carry_b = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai &= twos_b;
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                }

                // - 1 & +ff = ...f ff & ...0 ff = ...0 ff = +ff
                // -ff & + 1 = ...f 01 & ...0 01 = ...0 01 = + 1
                // answer is pos, has length of b
                fn bitand_neg_pos(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = twos_a & bi;
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => a.truncate(b.len()),
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().cloned());
                        }
                    }
                }

                // - 1 & -ff = ...f ff & ...f 01 = ...f 01 = - ff
                // -ff & - 1 = ...f 01 & ...f ff = ...f 01 = - ff
                // -ff & -fe = ...f 01 & ...f 02 = ...f 00 = -100
                // answer is neg, has length of longest with a possible carry
                fn bitand_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_and = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(twos_a & twos_b, &mut carry_and);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                *ai = negate_carry(twos_a, &mut carry_and);
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_and)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                    if carry_and != 0 {
                        a.push(1);
                    }
                }

                forward_val_val_binop!(impl BitAnd for BigInt, bitand);
                forward_ref_val_binop!(impl BitAnd for BigInt, bitand);

                // do not use forward_ref_ref_binop_commutative! for bitand so that we can
                // clone as needed, avoiding over-allocation
                impl BitAnd<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline] fn bitand(self, other: &BigInt) -> BigInt {
                        match (self.sign, other.sign) {
                            (NoSign, _) | (_, NoSign) => BigInt::ZERO,
                            (Plus, Plus) => BigInt::from(&self.data & &other.data),
                            (Plus, Minus) => self.clone() & other,
                            (Minus, Plus) => other.clone() & self,
                            (Minus, Minus) => {
                                // forward to val-ref, choosing the larger to clone
                                if self.len() >= other.len() {
                                    self.clone() & other
                                } else {
                                    other.clone() & self
                                }
                            }
                        }
                    }
                }

                impl BitAnd<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline] fn bitand(mut self, other: &BigInt) -> BigInt {
                        self &= other;
                        self
                    }
                }

                forward_val_assign!(impl BitAndAssign for BigInt, bitand_assign);

                impl BitAndAssign<&BigInt> for BigInt {
                    fn bitand_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (NoSign, _) => {}
                            (_, NoSign) => self.set_zero(),
                            (Plus, Plus) => {
                                self.data &= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            (Plus, Minus) => {
                                bitand_pos_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitand_neg_pos(self.digits_mut(), other.digits());
                                self.sign = Plus;
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitand_neg_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                        }
                    }
                }

                // + 1 | -ff = ...0 01 | ...f 01 = ...f 01 = -ff
                // +ff | - 1 = ...0 ff | ...f ff = ...f ff = - 1
                // answer is neg, has length of b
                fn bitor_pos_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(*ai | twos_b, &mut carry_or);
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            a.truncate(b.len());
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_or)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                    // for carry_or to be non-zero, we would need twos_b == 0
                    debug_assert!(carry_or == 0);
                }

                // - 1 | +ff = ...f ff | ...0 ff = ...f ff = - 1
                // -ff | + 1 = ...f 01 | ...0 01 = ...f 01 = -ff
                // answer is neg, has length of a
                fn bitor_neg_pos(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = negate_carry(twos_a | bi, &mut carry_or);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    if a.len() > b.len() {
                        for ai in a[b.len()..].iter_mut() {
                            let twos_a = negate_carry(*ai, &mut carry_a);
                            *ai = negate_carry(twos_a, &mut carry_or);
                        }
                        debug_assert!(carry_a == 0);
                    }
                    // for carry_or to be non-zero, we would need twos_a == 0
                    debug_assert!(carry_or == 0);
                }

                // - 1 | -ff = ...f ff | ...f 01 = ...f ff = -1
                // -ff | - 1 = ...f 01 | ...f ff = ...f ff = -1
                // answer is neg, has length of shortest
                fn bitor_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(twos_a | twos_b, &mut carry_or);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    if a.len() > b.len() {
                        a.truncate(b.len());
                    }
                    // for carry_or to be non-zero, we would need twos_a == 0 or twos_b == 0
                    debug_assert!(carry_or == 0);
                }

                forward_val_val_binop!(impl BitOr for BigInt, bitor);
                forward_ref_val_binop!(impl BitOr for BigInt, bitor);

                // do not use forward_ref_ref_binop_commutative! for bitor so that we can
                // clone as needed, avoiding over-allocation
                impl BitOr<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline] fn bitor(self, other: &BigInt) -> BigInt {
                        match (self.sign, other.sign) {
                            (NoSign, _) => other.clone(),
                            (_, NoSign) => self.clone(),
                            (Plus, Plus) => BigInt::from(&self.data | &other.data),
                            (Plus, Minus) => other.clone() | self,
                            (Minus, Plus) => self.clone() | other,
                            (Minus, Minus) => {
                                // forward to val-ref, choosing the smaller to clone
                                if self.len() <= other.len() {
                                    self.clone() | other
                                } else {
                                    other.clone() | self
                                }
                            }
                        }
                    }
                }

                impl BitOr<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline] fn bitor(mut self, other: &BigInt) -> BigInt {
                        self |= other;
                        self
                    }
                }

                forward_val_assign!(impl BitOrAssign for BigInt, bitor_assign);

                impl BitOrAssign<&BigInt> for BigInt {
                    fn bitor_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (_, NoSign) => {}
                            (NoSign, _) => self.clone_from(other),
                            (Plus, Plus) => self.data |= &other.data,
                            (Plus, Minus) => {
                                bitor_pos_neg(self.digits_mut(), other.digits());
                                self.sign = Minus;
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitor_neg_pos(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitor_neg_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                        }
                    }
                }

                // + 1 ^ -ff = ...0 01 ^ ...f 01 = ...f 00 = -100
                // +ff ^ - 1 = ...0 ff ^ ...f ff = ...f 00 = -100
                // answer is neg, has length of longest with a possible carry
                fn bitxor_pos_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_b = 1;
                    let mut carry_xor = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(*ai ^ twos_b, &mut carry_xor);
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_b = !0;
                                *ai = negate_carry(*ai ^ twos_b, &mut carry_xor);
                            }
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_xor)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                    if carry_xor != 0 {
                        a.push(1);
                    }
                }

                // - 1 ^ +ff = ...f ff ^ ...0 ff = ...f 00 = -100
                // -ff ^ + 1 = ...f 01 ^ ...0 01 = ...f 00 = -100
                // answer is neg, has length of longest with a possible carry
                fn bitxor_neg_pos(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_xor = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = negate_carry(twos_a ^ bi, &mut carry_xor);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                *ai = negate_carry(twos_a, &mut carry_xor);
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_a = !0;
                                negate_carry(twos_a ^ bi, &mut carry_xor)
                            }));
                        }
                    }
                    if carry_xor != 0 {
                        a.push(1);
                    }
                }

                // - 1 ^ -ff = ...f ff ^ ...f 01 = ...0 fe = +fe
                // -ff & - 1 = ...f 01 ^ ...f ff = ...0 fe = +fe
                // answer is pos, has length of longest
                fn bitxor_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = twos_a ^ twos_b;
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                let twos_b = !0;
                                *ai = twos_a ^ twos_b;
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_a = !0;
                                let twos_b = negate_carry(bi, &mut carry_b);
                                twos_a ^ twos_b
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitXor for BigInt, bitxor);

                impl BitXor<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline] fn bitxor(mut self, other: &BigInt) -> BigInt {
                        self ^= other;
                        self
                    }
                }

                forward_val_assign!(impl BitXorAssign for BigInt, bitxor_assign);

                impl BitXorAssign<&BigInt> for BigInt {
                    fn bitxor_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (_, NoSign) => {}
                            (NoSign, _) => self.clone_from(other),
                            (Plus, Plus) => {
                                self.data ^= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            (Plus, Minus) => {
                                bitxor_pos_neg(self.digits_mut(), other.digits());
                                self.sign = Minus;
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitxor_neg_pos(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitxor_neg_neg(self.digits_mut(), other.digits());
                                self.sign = Plus;
                                self.normalize();
                            }
                        }
                    }
                }

                pub fn set_negative_bit(x: &mut BigInt, bit: u64, value: bool) {
                    debug_assert_eq!(x.sign, Minus);
                    let data = &mut x.data;

                    let bits_per_digit = u64::from(big_digit::BITS);
                    if bit >= bits_per_digit * data.len() as u64 {
                        if !value {
                            data.set_bit(bit, true);
                        }
                    } else {
                        // If the Uint number is
                        //   ... 0  x 1 0 ... 0
                        // then the two's complement is
                        //   ... 1 !x 1 0 ... 0
                        //            |-- bit at position 'trailing_zeros'
                        // where !x is obtained from x by flipping each bit
                        let trailing_zeros = data.trailing_zeros().unwrap();
                        if bit > trailing_zeros {
                            data.set_bit(bit, !value);
                        } else if bit == trailing_zeros && !value {
                            // Clearing the bit at position `trailing_zeros` is dealt with by doing
                            // similarly to what `bitand_neg_pos` does, except we start at digit
                            // `bit_index`. All digits below `bit_index` are guaranteed to be zero,
                            // so initially we have `carry_in` = `carry_out` = 1. Furthermore, we
                            // stop traversing the digits when there are no more carries.
                            let bit_index = (bit / bits_per_digit).to_usize().unwrap();
                            let bit_mask = (1 as BigDigit) << (bit % bits_per_digit);
                            let mut digit_iter = data.digits_mut().iter_mut().skip(bit_index);
                            let mut carry_in = 1;
                            let mut carry_out = 1;

                            let digit = digit_iter.next().unwrap();
                            let twos_in = negate_carry(*digit, &mut carry_in);
                            let twos_out = twos_in & !bit_mask;
                            *digit = negate_carry(twos_out, &mut carry_out);

                            for digit in digit_iter {
                                if carry_in == 0 && carry_out == 0 {
                                    // Exit the loop since no more digits can change
                                    break;
                                }
                                let twos = negate_carry(*digit, &mut carry_in);
                                *digit = negate_carry(twos, &mut carry_out);
                            }

                            if carry_out != 0 {
                                // All digits have been traversed and there is a carry
                                debug_assert_eq!(carry_in, 0);
                                data.digits_mut().push(1);
                            }
                        } else if bit < trailing_zeros && value {
                            // Flip each bit from position 'bit' to 'trailing_zeros', both inclusive
                            //       ... 1 !x 1 0 ... 0 ... 0
                            //                        |-- bit at position 'bit'
                            //                |-- bit at position 'trailing_zeros'
                            // bit_mask:      1 1 ... 1 0 .. 0
                            // This is done by xor'ing with the bit_mask
                            let index_lo = (bit / bits_per_digit).to_usize().unwrap();
                            let index_hi = (trailing_zeros / bits_per_digit).to_usize().unwrap();
                            let bit_mask_lo = big_digit::MAX << (bit % bits_per_digit);
                            let bit_mask_hi =
                                big_digit::MAX >> (bits_per_digit - 1 - (trailing_zeros % bits_per_digit));
                            let digits = data.digits_mut();

                            if index_lo == index_hi {
                                digits[index_lo] ^= bit_mask_lo & bit_mask_hi;
                            } else {
                                digits[index_lo] = bit_mask_lo;
                                for digit in &mut digits[index_lo + 1..index_hi] {
                                    *digit = big_digit::MAX;
                                }
                                digits[index_hi] ^= bit_mask_hi;
                            }
                        } else {
                            // We end up here in two cases:
                            //   bit == trailing_zeros && value: Bit is already set
                            //   bit < trailing_zeros && !value: Bit is already cleared
                        }
                    }
                }

            } pub use self::bits::{ * };

            pub mod convert
            {
                use ::
                {
                    cmp::Ordering::{Equal, Greater, Less},
                    convert::{ TryFrom },
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                Sign::{ self,* },
                                BigInt, ToBigInt
                            },
                            TryFromBigIntError, BigUint, ParseBigIntError, ToBigUint,
                        },
                        traits::{ FromPrimitive, Num, One, ToPrimitive, Zero },
                    },
                    str::{ self, FromStr },
                    vec::{ Vec },
                    *,
                };

                impl FromStr for BigInt {
                    type Err = ParseBigIntError;

                    #[inline] fn from_str(s: &str) -> Result<BigInt, ParseBigIntError> {
                        BigInt::from_str_radix(s, 10)
                    }
                }

                impl Num for BigInt {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a [`BigInt`].
                    #[inline] fn from_str_radix(mut s: &str, radix: u32) -> Result<BigInt, ParseBigIntError> {
                        let sign = if let Some(tail) = s.strip_prefix('-') {
                            if !tail.starts_with('+') {
                                s = tail
                            }
                            Minus
                        } else {
                            Plus
                        };
                        let bu = BigUint::from_str_radix(s, radix)?;
                        Ok(BigInt::from_biguint(sign, bu))
                    }
                }

                impl ToPrimitive for BigInt {
                    #[inline] fn to_i64(&self) -> Option<i64> {
                        match self.sign {
                            Plus => self.data.to_i64(),
                            NoSign => Some(0),
                            Minus => {
                                let n = self.data.to_u64()?;
                                let m: u64 = 1 << 63;
                                match n.cmp(&m) {
                                    Less => Some(-(n as i64)),
                                    Equal => Some(i64::MIN),
                                    Greater => None,
                                }
                            }
                        }
                    }

                    #[inline] fn to_i128(&self) -> Option<i128> {
                        match self.sign {
                            Plus => self.data.to_i128(),
                            NoSign => Some(0),
                            Minus => {
                                let n = self.data.to_u128()?;
                                let m: u128 = 1 << 127;
                                match n.cmp(&m) {
                                    Less => Some(-(n as i128)),
                                    Equal => Some(i128::MIN),
                                    Greater => None,
                                }
                            }
                        }
                    }

                    #[inline] fn to_u64(&self) -> Option<u64> {
                        match self.sign {
                            Plus => self.data.to_u64(),
                            NoSign => Some(0),
                            Minus => None,
                        }
                    }

                    #[inline] fn to_u128(&self) -> Option<u128> {
                        match self.sign {
                            Plus => self.data.to_u128(),
                            NoSign => Some(0),
                            Minus => None,
                        }
                    }

                    #[inline] fn to_f32(&self) -> Option<f32> {
                        let n = self.data.to_f32()?;
                        Some(if self.sign == Minus { -n } else { n })
                    }

                    #[inline] fn to_f64(&self) -> Option<f64> {
                        let n = self.data.to_f64()?;
                        Some(if self.sign == Minus { -n } else { n })
                    }
                }

                macro_rules! impl_try_from_bigint {
                    ($T:ty, $to_ty:path) => {
                        impl TryFrom<&BigInt> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: &BigInt) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }

                        impl TryFrom<BigInt> for $T {
                            type Error = TryFromBigIntError<BigInt>;

                            #[inline]
                            fn try_from(value: BigInt) -> Result<$T, TryFromBigIntError<BigInt>> {
                                <$T>::try_from(&value).map_err(|_| TryFromBigIntError::new(value))
                            }
                        }
                    };
                }

                impl_try_from_bigint!(u8, ToPrimitive::to_u8);
                impl_try_from_bigint!(u16, ToPrimitive::to_u16);
                impl_try_from_bigint!(u32, ToPrimitive::to_u32);
                impl_try_from_bigint!(u64, ToPrimitive::to_u64);
                impl_try_from_bigint!(usize, ToPrimitive::to_usize);
                impl_try_from_bigint!(u128, ToPrimitive::to_u128);

                impl_try_from_bigint!(i8, ToPrimitive::to_i8);
                impl_try_from_bigint!(i16, ToPrimitive::to_i16);
                impl_try_from_bigint!(i32, ToPrimitive::to_i32);
                impl_try_from_bigint!(i64, ToPrimitive::to_i64);
                impl_try_from_bigint!(isize, ToPrimitive::to_isize);
                impl_try_from_bigint!(i128, ToPrimitive::to_i128);

                impl FromPrimitive for BigInt {
                    #[inline] fn from_i64(n: i64) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline] fn from_i128(n: i128) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline] fn from_u64(n: u64) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline] fn from_u128(n: u128) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline] fn from_f64(n: f64) -> Option<BigInt> {
                        if n >= 0.0 {
                            BigUint::from_f64(n).map(BigInt::from)
                        } else {
                            let x = BigUint::from_f64(-n)?;
                            Some(-BigInt::from(x))
                        }
                    }
                }

                impl From<i64> for BigInt {
                    #[inline] fn from(n: i64) -> Self {
                        if n >= 0 {
                            BigInt::from(n as u64)
                        } else {
                            let u = u64::MAX - (n as u64) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from(u),
                            }
                        }
                    }
                }

                impl From<i128> for BigInt {
                    #[inline] fn from(n: i128) -> Self {
                        if n >= 0 {
                            BigInt::from(n as u128)
                        } else {
                            let u = u128::MAX - (n as u128) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from(u),
                            }
                        }
                    }
                }

                macro_rules! impl_bigint_from_int {
                    ($T:ty) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigInt::from(n as i64)
                            }
                        }
                    };
                }

                impl_bigint_from_int!(i8);
                impl_bigint_from_int!(i16);
                impl_bigint_from_int!(i32);
                impl_bigint_from_int!(isize);

                impl From<u64> for BigInt {
                    #[inline] fn from(n: u64) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from(n),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }

                impl From<u128> for BigInt {
                    #[inline] fn from(n: u128) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from(n),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }

                macro_rules! impl_bigint_from_uint {
                    ($T:ty) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigInt::from(n as u64)
                            }
                        }
                    };
                }

                impl_bigint_from_uint!(u8);
                impl_bigint_from_uint!(u16);
                impl_bigint_from_uint!(u32);
                impl_bigint_from_uint!(usize);

                impl From<BigUint> for BigInt {
                    #[inline] fn from(n: BigUint) -> Self {
                        if n.is_zero() {
                            Self::ZERO
                        } else {
                            BigInt {
                                sign: Plus,
                                data: n,
                            }
                        }
                    }
                }

                impl ToBigInt for BigInt {
                    #[inline] fn to_bigint(&self) -> Option<BigInt> {
                        Some(self.clone())
                    }
                }

                impl ToBigInt for BigUint {
                    #[inline] fn to_bigint(&self) -> Option<BigInt> {
                        if self.is_zero() {
                            Some(BigInt::ZERO)
                        } else {
                            Some(BigInt {
                                sign: Plus,
                                data: self.clone(),
                            })
                        }
                    }
                }

                impl ToBigUint for BigInt {
                    #[inline] fn to_biguint(&self) -> Option<BigUint> {
                        match self.sign() {
                            Plus => Some(self.data.clone()),
                            NoSign => Some(BigUint::ZERO),
                            Minus => None,
                        }
                    }
                }

                impl TryFrom<&BigInt> for BigUint {
                    type Error = TryFromBigIntError<()>;

                    #[inline] fn try_from(value: &BigInt) -> Result<BigUint, TryFromBigIntError<()>> {
                        value
                            .to_biguint()
                            .ok_or_else(|| TryFromBigIntError::new(()))
                    }
                }

                impl TryFrom<BigInt> for BigUint {
                    type Error = TryFromBigIntError<BigInt>;

                    #[inline] fn try_from(value: BigInt) -> Result<BigUint, TryFromBigIntError<BigInt>> {
                        if value.sign() == Sign::Minus {
                            Err(TryFromBigIntError::new(value))
                        } else {
                            Ok(value.data)
                        }
                    }
                }

                macro_rules! impl_to_bigint {
                    ($T:ty, $from_ty:path) => {
                        impl ToBigInt for $T {
                            #[inline]
                            fn to_bigint(&self) -> Option<BigInt> {
                                $from_ty(*self)
                            }
                        }
                    };
                }

                impl_to_bigint!(isize, FromPrimitive::from_isize);
                impl_to_bigint!(i8, FromPrimitive::from_i8);
                impl_to_bigint!(i16, FromPrimitive::from_i16);
                impl_to_bigint!(i32, FromPrimitive::from_i32);
                impl_to_bigint!(i64, FromPrimitive::from_i64);
                impl_to_bigint!(i128, FromPrimitive::from_i128);

                impl_to_bigint!(usize, FromPrimitive::from_usize);
                impl_to_bigint!(u8, FromPrimitive::from_u8);
                impl_to_bigint!(u16, FromPrimitive::from_u16);
                impl_to_bigint!(u32, FromPrimitive::from_u32);
                impl_to_bigint!(u64, FromPrimitive::from_u64);
                impl_to_bigint!(u128, FromPrimitive::from_u128);

                impl_to_bigint!(f32, FromPrimitive::from_f32);
                impl_to_bigint!(f64, FromPrimitive::from_f64);

                impl From<bool> for BigInt {
                    fn from(x: bool) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }

                #[inline] pub fn from_signed_bytes_be(digits: &[u8]) -> BigInt {
                    let sign = match digits.first() {
                        Some(v) if *v > 0x7f => Sign::Minus,
                        Some(_) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                        // two's-complement the content to retrieve the magnitude
                        let mut digits = Vec::from(digits);
                        twos_complement_be(&mut digits);
                        BigInt::from_biguint(sign, BigUint::from_bytes_be(&digits))
                    } else {
                        BigInt::from_biguint(sign, BigUint::from_bytes_be(digits))
                    }
                }

                #[inline] pub fn from_signed_bytes_le(digits: &[u8]) -> BigInt {
                    let sign = match digits.last() {
                        Some(v) if *v > 0x7f => Sign::Minus,
                        Some(_) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                        // two's-complement the content to retrieve the magnitude
                        let mut digits = Vec::from(digits);
                        twos_complement_le(&mut digits);
                        BigInt::from_biguint(sign, BigUint::from_bytes_le(&digits))
                    } else {
                        BigInt::from_biguint(sign, BigUint::from_bytes_le(digits))
                    }
                }

                #[inline] pub fn to_signed_bytes_be(x: &BigInt) -> Vec<u8> {
                    let mut bytes = x.data.to_bytes_be();
                    let first_byte = bytes.first().cloned().unwrap_or(0);
                    if first_byte > 0x7f
                        && !(first_byte == 0x80 && bytes.iter().skip(1).all(Zero::is_zero) && x.sign == Sign::Minus)
                    {
                        // msb used by magnitude, extend by 1 byte
                        bytes.insert(0, 0);
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_be(&mut bytes);
                    }
                    bytes
                }

                #[inline] pub fn to_signed_bytes_le(x: &BigInt) -> Vec<u8> {
                    let mut bytes = x.data.to_bytes_le();
                    let last_byte = bytes.last().cloned().unwrap_or(0);
                    if last_byte > 0x7f
                        && !(last_byte == 0x80
                            && bytes.iter().rev().skip(1).all(Zero::is_zero)
                            && x.sign == Sign::Minus)
                    {
                        // msb used by magnitude, extend by 1 byte
                        bytes.push(0);
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_le(&mut bytes);
                    }
                    bytes
                }
                /// Perform in-place two's complement of the given binary representation,
                /// in little-endian byte order.
                #[inline] fn twos_complement_le(digits: &mut [u8]) {
                    twos_complement(digits)
                }
                /// Perform in-place two's complement of the given binary representation
                /// in big-endian byte order.
                #[inline] fn twos_complement_be(digits: &mut [u8]) {
                    twos_complement(digits.iter_mut().rev())
                }
                /// Perform in-place two's complement of the given digit iterator
                /// starting from the least significant byte.
                #[inline] fn twos_complement<'a, I>(digits: I)
                where
                    I: IntoIterator<Item = &'a mut u8>,
                {
                    let mut carry = true;
                    for d in digits {
                        *d = !*d;
                        if carry {
                            *d = d.wrapping_add(1);
                            carry = d.is_zero();
                        }
                    }
                }
            } pub use self::convert::{ * };

            pub mod power
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            bigint::{ BigInt, Sign::{self, * }, },
                            BigUint,
                        },
                        integers::{ Integer },
                        traits::{ Pow, Signed, Zero },
                    },
                    *,
                };
                /// Computes pow, the effect of the exponent on the sign.
                #[inline] fn powsign<T: Integer>(sign: Sign, other: &T) -> Sign {
                    if other.is_zero() {
                        Plus
                    } else if sign != Minus || other.is_odd() {
                        sign
                    } else {
                        -sign
                    }
                }

                macro_rules! pow_impl {
                    ($T:ty) => {
                        impl Pow<$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: $T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, &rhs), self.data.pow(rhs))
                            }
                        }

                        impl Pow<&$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: &$T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, rhs), self.data.pow(rhs))
                            }
                        }

                        impl Pow<$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: $T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, &rhs), Pow::pow(&self.data, rhs))
                            }
                        }

                        impl Pow<&$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: &$T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, rhs), Pow::pow(&self.data, rhs))
                            }
                        }
                    };
                }

                pow_impl!(u8);
                pow_impl!(u16);
                pow_impl!(u32);
                pow_impl!(u64);
                pow_impl!(usize);
                pow_impl!(u128);
                pow_impl!(BigUint);

                pub fn modpow(x: &BigInt, exponent: &BigInt, modulus: &BigInt) -> BigInt {
                    assert!(
                        !exponent.is_negative(),
                        "negative exponentiation is not supported!"
                    );
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    let result = x.data.modpow(&exponent.data, &modulus.data);
                    if result.is_zero() {
                        return BigInt::ZERO;
                    }

                    // The sign of the result follows the modulus, like `mod_floor`.
                    let (sign, mag) = match (x.is_negative() && exponent.is_odd(), modulus.is_negative()) {
                        (false, false) => (Plus, result),
                        (true, false) => (Plus, &modulus.data - result),
                        (false, true) => (Minus, &modulus.data - result),
                        (true, true) => (Minus, result),
                    };
                    BigInt::from_biguint(sign, mag)
                }

            } pub use self::power::{ * };

            pub mod shift
            {
                use ::
                {
                    num::
                    {
                        big::{ BigInt, Sign::{ self, * }, },
                        traits::{ PrimInt, Signed, Zero },
                    },
                    ops::{Shl, ShlAssign, Shr, ShrAssign},
                    *,
                };
                
                macro_rules! impl_shift
                {
                    (@ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty) => {
                        impl $Shx<&$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigInt {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $Shx<&$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigInt {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigInt {
                            #[inline]
                            fn $shx_assign(&mut self, rhs: &$rhs) {
                                $ShxAssign::$shx_assign(self, *rhs);
                            }
                        }
                    };
                    ($($rhs:ty),+) => {$(
                        impl Shl<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigInt {
                                BigInt::from_biguint(self.sign, self.data << rhs)
                            }
                        }
                        impl Shl<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigInt {
                                BigInt::from_biguint(self.sign, &self.data << rhs)
                            }
                        }
                        impl ShlAssign<$rhs> for BigInt {
                            #[inline]
                            fn shl_assign(&mut self, rhs: $rhs) {
                                self.data <<= rhs
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }

                        impl Shr<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigInt {
                                let round_down = shr_round_down(&self, rhs);
                                let data = self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint(self.sign, data)
                            }
                        }
                        impl Shr<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigInt {
                                let round_down = shr_round_down(self, rhs);
                                let data = &self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint(self.sign, data)
                            }
                        }
                        impl ShrAssign<$rhs> for BigInt {
                            #[inline]
                            fn shr_assign(&mut self, rhs: $rhs) {
                                let round_down = shr_round_down(self, rhs);
                                self.data >>= rhs;
                                if round_down {
                                    self.data += 1u8;
                                } else if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }

                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }

                // Negative values need a rounding adjustment if there are any ones in the
                // bits that are getting shifted out.
                fn shr_round_down<T: PrimInt>(i: &BigInt, shift: T) -> bool {
                    if i.is_negative() 
                    {
                        let zeros = i.trailing_zeros().expect("negative values are non-zero");
                        shift > T::zero() && shift.to_u64().map(|shift| zeros < shift).unwrap_or(true)
                    } else {
                        false
                    }
                }
            } pub use self::shift::{ * };
            /// A `Sign` is a [`BigInt`]'s composing element.
            #[derive(PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash)]
            pub enum Sign 
            {
                Minus,
                NoSign,
                Plus,
            }

            impl Neg for Sign 
            {
                type Output = Sign;
                /// Negate `Sign` value.
                #[inline] fn neg(self) -> Sign {
                    match self {
                        Minus => Plus,
                        NoSign => NoSign,
                        Plus => Minus,
                    }
                }
            }
            /// A big signed integer type.
            pub struct BigInt 
            {
                sign: Sign,
                data: BigUint,
            }

            // Note: derived `Clone` doesn't specialize `clone_from`,
            // but we want to keep the allocation in `data`.
            impl Clone for BigInt 
            {
                #[inline] fn clone(&self) -> Self {
                    BigInt {
                        sign: self.sign,
                        data: self.data.clone(),
                    }
                }

                #[inline] fn clone_from(&mut self, other: &Self) {
                    self.sign = other.sign;
                    self.data.clone_from(&other.data);
                }
            }

            impl hash::Hash for BigInt 
            {
                #[inline] fn hash<H: hash::Hasher>(&self, state: &mut H) {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    self.sign.hash(state);
                    if self.sign != NoSign {
                        self.data.hash(state);
                    }
                }
            }

            impl PartialEq for BigInt 
            {
                #[inline] fn eq(&self, other: &BigInt) -> bool {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    debug_assert!((other.sign != NoSign) ^ other.data.is_zero());
                    self.sign == other.sign && (self.sign == NoSign || self.data == other.data)
                }
            }

            impl Eq for BigInt {}

            impl PartialOrd for BigInt 
            {
                #[inline] fn partial_cmp(&self, other: &BigInt) -> Option<Ordering> {
                    Some(self.cmp(other))
                }
            }

            impl Ord for BigInt 
            {
                #[inline] fn cmp(&self, other: &BigInt) -> Ordering {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    debug_assert!((other.sign != NoSign) ^ other.data.is_zero());
                    let scmp = self.sign.cmp(&other.sign);
                    if scmp != Equal {
                        return scmp;
                    }

                    match self.sign {
                        NoSign => Equal,
                        Plus => self.data.cmp(&other.data),
                        Minus => other.data.cmp(&self.data),
                    }
                }
            }

            impl Default for BigInt 
            {
                #[inline] fn default() -> BigInt {
                    Self::ZERO
                }
            }

            impl fmt::Debug for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Display::fmt(self, f)
                }
            }

            impl fmt::Display for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "", &self.data.to_str_radix(10))
                }
            }

            impl fmt::Binary for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "0b", &self.data.to_str_radix(2))
                }
            }

            impl fmt::Octal for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "0o", &self.data.to_str_radix(8))
                }
            }

            impl fmt::LowerHex for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "0x", &self.data.to_str_radix(16))
                }
            }

            impl fmt::UpperHex for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let mut s = self.data.to_str_radix(16);
                    s.make_ascii_uppercase();
                    f.pad_integral(!self.is_negative(), "0x", &s)
                }
            }
            
            impl Not for BigInt 
            {
                type Output = BigInt;

                fn not(mut self) -> BigInt {
                    match self.sign {
                        NoSign | Plus => {
                            self.data += 1u32;
                            self.sign = Minus;
                        }
                        Minus => {
                            self.data -= 1u32;
                            self.sign = if self.data.is_zero() { NoSign } else { Plus };
                        }
                    }
                    self
                }
            }

            impl Not for &BigInt 
            {
                type Output = BigInt;

                fn not(self) -> BigInt {
                    match self.sign {
                        NoSign => -BigInt::one(),
                        Plus => -BigInt::from(&self.data + 1u32),
                        Minus => BigInt::from(&self.data - 1u32),
                    }
                }
            }

            impl Zero for BigInt 
            {
                #[inline] fn zero() -> BigInt {
                    Self::ZERO
                }

                #[inline] fn set_zero(&mut self) {
                    self.data.set_zero();
                    self.sign = NoSign;
                }

                #[inline] fn is_zero(&self) -> bool {
                    self.sign == NoSign
                }
            }

            impl ConstZero for BigInt 
            {
                // forward to the inherent const
                const ZERO: Self = Self::ZERO;
            }

            impl One for BigInt 
            {
                #[inline] fn one() -> BigInt {
                    BigInt {
                        sign: Plus,
                        data: BigUint::one(),
                    }
                }

                #[inline] fn set_one(&mut self) {
                    self.data.set_one();
                    self.sign = Plus;
                }

                #[inline] fn is_one(&self) -> bool {
                    self.sign == Plus && self.data.is_one()
                }
            }

            impl Signed for BigInt 
            {
                #[inline] fn abs(&self) -> BigInt {
                    match self.sign {
                        Plus | NoSign => self.clone(),
                        Minus => BigInt::from(self.data.clone()),
                    }
                }

                #[inline] fn abs_sub(&self, other: &BigInt) -> BigInt {
                    if *self <= *other {
                        Self::ZERO
                    } else {
                        self - other
                    }
                }

                #[inline] fn signum(&self) -> BigInt {
                    match self.sign {
                        Plus => BigInt::one(),
                        Minus => -BigInt::one(),
                        NoSign => Self::ZERO,
                    }
                }

                #[inline] fn is_positive(&self) -> bool {
                    self.sign == Plus
                }

                #[inline] fn is_negative(&self) -> bool {
                    self.sign == Minus
                }
            }

            trait UnsignedAbs 
            {
                type Unsigned;

                fn checked_uabs(self) -> CheckedUnsignedAbs<Self::Unsigned>;
            }

            enum CheckedUnsignedAbs<T> 
            {
                Positive(T),
                Negative(T),
            }
            use self::CheckedUnsignedAbs::{Negative, Positive};

            macro_rules! impl_unsigned_abs 
            {
                ($Signed:ty, $Unsigned:ty) => {
                    impl UnsignedAbs for $Signed {
                        type Unsigned = $Unsigned;

                        #[inline] fn checked_uabs(self) -> CheckedUnsignedAbs<Self::Unsigned> {
                            if self >= 0 {
                                Positive(self as $Unsigned)
                            } else {
                                Negative(self.wrapping_neg() as $Unsigned)
                            }
                        }
                    }
                };
            }

            impl_unsigned_abs!(i8, u8);
            impl_unsigned_abs!(i16, u16);
            impl_unsigned_abs!(i32, u32);
            impl_unsigned_abs!(i64, u64);
            impl_unsigned_abs!(i128, u128);
            impl_unsigned_abs!(isize, usize);

            impl Neg for BigInt 
            {
                type Output = BigInt;

                #[inline] fn neg(mut self) -> BigInt {
                    self.sign = -self.sign;
                    self
                }
            }

            impl Neg for &BigInt 
            {
                type Output = BigInt;

                #[inline] fn neg(self) -> BigInt {
                    -self.clone()
                }
            }

            impl Integer for BigInt 
            {
                #[inline] fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {
                    // r.sign == self.sign
                    let (d_ui, r_ui) = self.data.div_rem(&other.data);
                    let d = BigInt::from_biguint(self.sign, d_ui);
                    let r = BigInt::from_biguint(self.sign, r_ui);
                    if other.is_negative() {
                        (-d, r)
                    } else {
                        (d, r)
                    }
                }

                #[inline] fn div_floor(&self, other: &BigInt) -> BigInt {
                    let (d_ui, m) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => d,
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                -d
                            } else {
                                -d - 1u32
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                #[inline] fn mod_floor(&self, other: &BigInt) -> BigInt {
                    // m.sign == other.sign
                    let m_ui = self.data.mod_floor(&other.data);
                    let m = BigInt::from_biguint(other.sign, m_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => m,
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                m
                            } else {
                                other - m
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {
                    // m.sign == other.sign
                    let (d_ui, m_ui) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    let m = BigInt::from_biguint(other.sign, m_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => (d, m),
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                (-d, m)
                            } else {
                                (-d - 1u32, other - m)
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                #[inline] fn div_ceil(&self, other: &Self) -> Self {
                    let (d_ui, m) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    match (self.sign, other.sign) {
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => -d,
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => {
                            if m.is_zero() {
                                d
                            } else {
                                d + 1u32
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }
                /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.
                ///
                /// The result is always positive.
                #[inline] fn gcd(&self, other: &BigInt) -> BigInt {
                    BigInt::from(self.data.gcd(&other.data))
                }
                /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                #[inline] fn lcm(&self, other: &BigInt) -> BigInt {
                    BigInt::from(self.data.lcm(&other.data))
                }
                /// Calculates the Greatest Common Divisor (GCD) and
                /// Lowest Common Multiple (LCM) together.
                #[inline] fn gcd_lcm(&self, other: &BigInt) -> (BigInt, BigInt) {
                    let (gcd, lcm) = self.data.gcd_lcm(&other.data);
                    (BigInt::from(gcd), BigInt::from(lcm))
                }
                /// Greatest common divisor, least common multiple, and Bézout coefficients.
                #[inline] fn extended_gcd_lcm(&self, other: &BigInt) -> ( ::num::integers::ExtendedGcd<BigInt>, BigInt) {
                    let egcd = self.extended_gcd(other);
                    let lcm = if egcd.gcd.is_zero() {
                        Self::ZERO
                    } else {
                        BigInt::from(&self.data / &egcd.gcd.data * &other.data)
                    };
                    (egcd, lcm)
                }
                /// Deprecated, use `is_multiple_of` instead.
                #[inline] fn divides(&self, other: &BigInt) -> bool {
                    self.is_multiple_of(other)
                }
                /// Returns `true` if the number is a multiple of `other`.
                #[inline] fn is_multiple_of(&self, other: &BigInt) -> bool {
                    self.data.is_multiple_of(&other.data)
                }
                /// Returns `true` if the number is divisible by `2`.
                #[inline] fn is_even(&self) -> bool {
                    self.data.is_even()
                }
                /// Returns `true` if the number is not divisible by `2`.
                #[inline] fn is_odd(&self) -> bool {
                    self.data.is_odd()
                }
                /// Rounds up to nearest multiple of argument.
                #[inline] fn next_multiple_of(&self, other: &Self) -> Self {
                    let m = self.mod_floor(other);
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + (other - m)
                    }
                }
                /// Rounds down to nearest multiple of argument.
                #[inline] fn prev_multiple_of(&self, other: &Self) -> Self {
                    self - self.mod_floor(other)
                }

                fn dec(&mut self) {
                    *self -= 1u32;
                }

                fn inc(&mut self) {
                    *self += 1u32;
                }
            }

            impl Roots for BigInt 
            {
                fn nth_root(&self, n: u32) -> Self {
                    assert!(
                        !(self.is_negative() && n.is_even()),
                        "root of degree {} is imaginary",
                        n
                    );

                    BigInt::from_biguint(self.sign, self.data.nth_root(n))
                }

                fn sqrt(&self) -> Self {
                    assert!(!self.is_negative(), "square root is imaginary");

                    BigInt::from_biguint(self.sign, self.data.sqrt())
                }

                fn cbrt(&self) -> Self {
                    BigInt::from_biguint(self.sign, self.data.cbrt())
                }
            }

            impl IntDigits for BigInt 
            {
                #[inline] fn digits(&self) -> &[BigDigit] {
                    self.data.digits()
                }
                #[inline] fn digits_mut(&mut self) -> &mut Vec<BigDigit> {
                    self.data.digits_mut()
                }
                #[inline] fn normalize(&mut self) {
                    self.data.normalize();
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
                #[inline] fn capacity(&self) -> usize {
                    self.data.capacity()
                }
                #[inline] fn len(&self) -> usize {
                    self.data.len()
                }
            }
            /// A generic trait for converting a value to a [`BigInt`].
            pub trait ToBigInt 
            {
                /// Converts the value of `self` to a [`BigInt`].
                fn to_bigint(&self) -> Option<BigInt>;
            }

            impl BigInt 
            {
                /// A constant `BigInt` with value 0, useful for static initialization.
                pub const ZERO: Self = BigInt {
                    sign: NoSign,
                    data: BigUint::ZERO,
                };
                /// Creates and initializes a [`BigInt`].
                ///
                /// The base 2<sup>32</sup> digits are ordered least significant digit first.
                #[inline] pub fn new(sign: Sign, digits: Vec<u32>) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::new(digits))
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_biguint(mut sign: Sign, mut data: BigUint) -> BigInt {
                    if sign == NoSign {
                        data.assign_from_slice(&[]);
                    } else if data.is_zero() {
                        sign = NoSign;
                    }

                    BigInt { sign, data }
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_slice(sign: Sign, slice: &[u32]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_slice(slice))
                }
                /// Reinitializes a [`BigInt`].
                #[inline] pub fn assign_from_slice(&mut self, sign: Sign, slice: &[u32]) {
                    if sign == NoSign {
                        self.set_zero();
                    } else {
                        self.data.assign_from_slice(slice);
                        self.sign = if self.data.is_zero() { NoSign } else { sign };
                    }
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_bytes_be(sign: Sign, bytes: &[u8]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_bytes_be(bytes))
                }
                /// Creates and initializes a [`BigInt`].
                ///
                /// The bytes are in little-endian byte order.
                #[inline] pub fn from_bytes_le(sign: Sign, bytes: &[u8]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_bytes_le(bytes))
                }
                /// Creates and initializes a [`BigInt`] from an array of bytes in
                /// two's complement binary representation.
                #[inline] pub fn from_signed_bytes_be(digits: &[u8]) -> BigInt {
                    convert::from_signed_bytes_be(digits)
                }
                /// Creates and initializes a [`BigInt`] from an array of bytes in two's complement.
                #[inline] pub fn from_signed_bytes_le(digits: &[u8]) -> BigInt {
                    convert::from_signed_bytes_le(digits)
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn parse_bytes(buf: &[u8], radix: u32) -> Option<BigInt> {
                    let s = str::from_utf8(buf).ok()?;
                    BigInt::from_str_radix(s, radix).ok()
                }
                /// Creates and initializes a [`BigInt`].
                pub fn from_radix_be(sign: Sign, buf: &[u8], radix: u32) -> Option<BigInt> {
                    let u = BigUint::from_radix_be(buf, radix)?;
                    Some(BigInt::from_biguint(sign, u))
                }
                /// Creates and initializes a [`BigInt`].
                pub fn from_radix_le(sign: Sign, buf: &[u8], radix: u32) -> Option<BigInt> {
                    let u = BigUint::from_radix_le(buf, radix)?;
                    Some(BigInt::from_biguint(sign, u))
                }
                /// Returns the sign and the byte representation of the [`BigInt`] in big-endian byte order.
                #[inline] pub fn to_bytes_be(&self) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_bytes_be())
                }
                /// Returns the sign and the byte representation of the [`BigInt`] in little-endian byte order.
                #[inline] pub fn to_bytes_le(&self) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_bytes_le())
                }
                /// Returns the sign and the `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn to_u32_digits(&self) -> (Sign, Vec<u32>) {
                    (self.sign, self.data.to_u32_digits())
                }
                /// Returns the sign and the `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn to_u64_digits(&self) -> (Sign, Vec<u64>) {
                    (self.sign, self.data.to_u64_digits())
                }
                /// Returns an iterator of `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u32_digits(&self) -> U32Digits<'_> {
                    self.data.iter_u32_digits()
                }
                /// Returns an iterator of `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u64_digits(&self) -> U64Digits<'_> {
                    self.data.iter_u64_digits()
                }
                /// Returns the two's-complement byte representation of the [`BigInt`] in big-endian byte order.
                #[inline] pub fn to_signed_bytes_be(&self) -> Vec<u8> {
                    convert::to_signed_bytes_be(self)
                }
                /// Returns the two's-complement byte representation of the [`BigInt`] in little-endian byte order.
                #[inline] pub fn to_signed_bytes_le(&self) -> Vec<u8> {
                    convert::to_signed_bytes_le(self)
                }
                /// Returns the integer formatted as a string in the given radix.
                /// `radix` must be in the range `2...36`.
                #[inline] pub fn to_str_radix(&self, radix: u32) -> String {
                    let mut v = to_str_radix_reversed(&self.data, radix);

                    if self.is_negative() {
                        v.push(b'-');
                    }

                    v.reverse();
                    unsafe { String::from_utf8_unchecked(v) }
                }
                /// Returns the integer in the requested base in big-endian digit order.
                #[inline] pub fn to_radix_be(&self, radix: u32) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_radix_be(radix))
                }
                /// Returns the integer in the requested base in little-endian digit order.
                #[inline] pub fn to_radix_le(&self, radix: u32) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_radix_le(radix))
                }
                /// Returns the sign of the [`BigInt`] as a [`Sign`].
                #[inline] pub fn sign(&self) -> Sign {
                    self.sign
                }
                /// Returns the magnitude of the [`BigInt`] as a [`BigUint`].
                #[inline] pub fn magnitude(&self) -> &BigUint {
                    &self.data
                }
                /// Convert this [`BigInt`] into its [`Sign`] and [`BigUint`] magnitude,
                /// the reverse of [`BigInt::from_biguint()`].
                #[inline] pub fn into_parts(self) -> (Sign, BigUint) {
                    (self.sign, self.data)
                }
                /// Determines the fewest bits necessary to express the [`BigInt`], not including the sign.
                #[inline] pub fn bits(&self) -> u64 {
                    self.data.bits()
                }
                /// Converts this [`BigInt`] into a [`BigUint`], if it's not negative.
                #[inline] pub fn to_biguint(&self) -> Option<BigUint> {
                    match self.sign {
                        Plus => Some(self.data.clone()),
                        NoSign => Some(BigUint::ZERO),
                        Minus => None,
                    }
                }

                #[inline] pub fn checked_add(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self + v)
                }

                #[inline] pub fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self - v)
                }

                #[inline] pub fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self * v)
                }

                #[inline] pub fn checked_div(&self, v: &BigInt) -> Option<BigInt> {
                    if v.is_zero() {
                        return None;
                    }
                    Some(self / v)
                }
                /// Returns `self ^ exponent`.
                pub fn pow(&self, exponent: u32) -> Self {
                    Pow::pow(self, exponent)
                }
                /// Returns `(self ^ exponent) mod modulus`
                pub fn modpow(&self, exponent: &Self, modulus: &Self) -> Self {
                    power::modpow(self, exponent, modulus)
                }
                /// Returns the modular multiplicative inverse if it exists, otherwise `None`.
                pub fn modinv(&self, modulus: &Self) -> Option<Self> {
                    let result = self.data.modinv(&modulus.data)?;
                    // The sign of the result follows the modulus, like `mod_floor`.
                    let (sign, mag) = match (self.is_negative(), modulus.is_negative()) {
                        (false, false) => (Plus, result),
                        (true, false) => (Plus, &modulus.data - result),
                        (false, true) => (Minus, &modulus.data - result),
                        (true, true) => (Minus, result),
                    };
                    Some(BigInt::from_biguint(sign, mag))
                }
                /// Returns the truncated principal square root of `self`
                pub fn sqrt(&self) -> Self {
                    Roots::sqrt(self)
                }
                /// Returns the truncated principal cube root of `self`
                pub fn cbrt(&self) -> Self {
                    Roots::cbrt(self)
                }
                /// Returns the truncated principal `n`th root of `self`
                pub fn nth_root(&self, n: u32) -> Self {
                    Roots::nth_root(self, n)
                }
                /// Returns the number of least-significant bits that are zero,
                /// or `None` if the entire number is zero.
                pub fn trailing_zeros(&self) -> Option<u64> {
                    self.data.trailing_zeros()
                }
                /// Returns whether the bit in position `bit` is set,
                /// using the two's complement for negative numbers
                pub fn bit(&self, bit: u64) -> bool {
                    if self.is_negative() {
                        // Let the binary representation of a number be
                        //   ... 0  x 1 0 ... 0
                        // Then the two's complement is
                        //   ... 1 !x 1 0 ... 0
                        // where !x is obtained from x by flipping each bit
                        if bit >= u64::from( big_digit::BITS ) * self.len() as u64 {
                            true
                        } else {
                            let trailing_zeros = self.data.trailing_zeros().unwrap();
                            match Ord::cmp(&bit, &trailing_zeros) {
                                Ordering::Less => false,
                                Ordering::Equal => true,
                                Ordering::Greater => !self.data.bit(bit),
                            }
                        }
                    } else {
                        self.data.bit(bit)
                    }
                }
                /// Sets or clears the bit in the given position,
                /// using the two's complement for negative numbers
                pub fn set_bit(&mut self, bit: u64, value: bool) {
                    match self.sign {
                        Sign::Plus => self.data.set_bit(bit, value),
                        Sign::Minus => bits::set_negative_bit(self, bit, value),
                        Sign::NoSign => {
                            if value {
                                self.data.set_bit(bit, true);
                                self.sign = Sign::Plus;
                            } else {
                                // Clearing a bit for zero is a no-op
                            }
                        }
                    }
                    // The top bit may have been cleared, so normalize
                    self.normalize();
                }
            }

            impl ::num::traits::FromBytes for BigInt 
            {
                type Bytes = [u8];

                fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                    Self::from_signed_bytes_be(bytes)
                }

                fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                    Self::from_signed_bytes_le(bytes)
                }
            }

            impl ::num::traits::ToBytes for BigInt 
            {
                type Bytes = Vec<u8>;

                fn to_be_bytes(&self) -> Self::Bytes {
                    self.to_signed_bytes_be()
                }

                fn to_le_bytes(&self) -> Self::Bytes {
                    self.to_signed_bytes_le()
                }
            }
        }

        pub mod bigrand
        {
            use ::
            {
                rand::
                {
                    distributions::uniform::{ SampleBorrow, SampleUniform, UniformSampler },
                    prelude::{ * },
                },
                num::
                {
                    big::
                    {
                        BigInt, BigUint, Sign::{ self, * },
                        biguint::{ biguint_from_vec },
                    },
                    integers::{ Integer },
                    traits::{ ToPrimitive, Zero },
                },
                *,
            };
            /// A trait for sampling random big integers.
            pub trait RandBigInt {
                /// Generate a random [`BigUint`] of the given bit size.
                fn gen_biguint(&mut self, bit_size: u64) -> BigUint;
                /// Generate a random [ BigInt`] of the given bit size.
                fn gen_bigint(&mut self, bit_size: u64) -> BigInt;
                /// Generate a random [`BigUint`] less than the given bound. Fails
                /// when the bound is zero.
                fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;
                /// Generate a random [`BigUint`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;
                /// Generate a random [`BigInt`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;
            }

            fn gen_bits<R: Rng + ?Sized>(rng: &mut R, data: &mut [u32], rem: u64) {
                // `fill` is faster than many `gen::<u32>` calls
                rng.fill(data);
                if rem > 0 {
                    let last = data.len() - 1;
                    data[last] >>= 32 - rem;
                }
            }

            impl<R: Rng + ?Sized> RandBigInt for R
            {
                fn gen_biguint(&mut self, bit_size: u64) -> BigUint
                {

                    let (digits, rem) = bit_size.div_rem(&32);
                    let len = (digits + (rem > 0) as u64)
                        .to_usize()
                        .expect("capacity overflow");
                    let native_digits = Integer::div_ceil(&bit_size, &64);
                    let native_len = native_digits.to_usize().expect("capacity overflow");
                    let mut data = vec![0u64; native_len];
                    unsafe {
                        // Generate bits in a `&mut [u32]` slice for value stability
                        let ptr = data.as_mut_ptr() as *mut u32;
                        debug_assert!(native_len * 2 >= len);
                        let data = slice::from_raw_parts_mut(ptr, len);
                        gen_bits(self, data, rem);
                    }
                    #[cfg(target_endian = "big")]
                    for digit in &mut data {
                        // swap u32 digits into u64 endianness
                        *digit = (*digit << 32) | (*digit >> 32);
                    }
                    biguint_from_vec(data)
                }

                fn gen_bigint(&mut self, bit_size: u64) -> BigInt {
                    loop {
                        // Generate a random BigUint...
                        let biguint = self.gen_biguint(bit_size);
                        // ...and then randomly assign it a Sign...
                        let sign = if biguint.is_zero() {
                            // ...except that if the BigUint is zero, we need to try
                            // again with probability 0.5. This is because otherwise,
                            // the probability of generating a zero BigInt would be
                            // double that of any other number.
                            if self.gen() {
                                continue;
                            } else {
                                NoSign
                            }
                        } else if self.gen() {
                            Plus
                        } else {
                            Minus
                        };
                        return BigInt::from_biguint(sign, biguint);
                    }
                }

                fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint {
                    assert!(!bound.is_zero());
                    let bits = bound.bits();
                    loop {
                        let n = self.gen_biguint(bits);
                        if n < *bound {
                            return n;
                        }
                    }
                }

                fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint {
                    assert!(*lbound < *ubound);
                    if lbound.is_zero() {
                        self.gen_biguint_below(ubound)
                    } else {
                        lbound + self.gen_biguint_below(&(ubound - lbound))
                    }
                }

                fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt {
                    assert!(*lbound < *ubound);
                    if lbound.is_zero() {
                        BigInt::from(self.gen_biguint_below(ubound.magnitude()))
                    } else if ubound.is_zero() {
                        lbound + BigInt::from(self.gen_biguint_below(lbound.magnitude()))
                    } else {
                        let delta = ubound - lbound;
                        lbound + BigInt::from(self.gen_biguint_below(delta.magnitude()))
                    }
                }
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigUint`].
            #[derive(Clone, Debug)]
            pub struct UniformBigUint {
                base: BigUint,
                len: BigUint,
            }

            impl UniformSampler for UniformBigUint {
                type X = BigUint;

                #[inline] fn new<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low < high);
                    UniformBigUint {
                        len: high - low,
                        base: low.clone(),
                    }
                }

                #[inline] fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low <= high);
                    Self::new(low, high + 1u32)
                }

                #[inline] fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
                    &self.base + rng.gen_biguint_below(&self.len)
                }

                #[inline] fn sample_single<R: Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_biguint_range(low.borrow(), high.borrow())
                }
            }

            impl SampleUniform for BigUint {
                type Sampler = UniformBigUint;
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigInt`].
            #[derive(Clone, Debug)]
            pub struct UniformBigInt {
                base: BigInt,
                len: BigUint,
            }

            impl UniformSampler for UniformBigInt {
                type X = BigInt;

                #[inline] fn new<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low < high);
                    UniformBigInt {
                        len: (high - low).into_parts().1,
                        base: low.clone(),
                    }
                }

                #[inline] fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low <= high);
                    Self::new(low, high + 1u32)
                }

                #[inline] fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
                    &self.base + BigInt::from(rng.gen_biguint_below(&self.len))
                }

                #[inline] fn sample_single<R: Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_bigint_range(low.borrow(), high.borrow())
                }
            }

            impl SampleUniform for BigInt {
                type Sampler = UniformBigInt;
            }
            /// A random distribution for [`BigUint`] and [`BigInt`] values of a particular bit size.
            #[derive(Clone, Copy, Debug)]
            pub struct RandomBits {
                bits: u64,
            }

            impl RandomBits {
                #[inline] pub fn new(bits: u64) -> RandomBits {
                    RandomBits { bits }
                }
            }

            impl Distribution<BigUint> for RandomBits {
                #[inline] fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> BigUint {
                    rng.gen_biguint(self.bits)
                }
            }

            impl Distribution<BigInt> for RandomBits {
                #[inline] fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> BigInt {
                    rng.gen_bigint(self.bits)
                }
            }

        }

        pub mod biguint
        {
            use ::
            {
                cmp::{ self, Ordering },
                default::{ Default },
                num::
                {
                    integers::{ Integer, Roots },
                    traits::{ ConstZero, Num, One, Pow, FromPrimitive, ToPrimitive, Unsigned, Zero },
                },
                string::{ String },
                vec::{ Vec },
                *,
            }; use super::big_digit::{self, BigDigit};

            pub mod addition
            {
                use ::
                {
                    iter::{ Sum },
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit },
                            biguint::{ BigUint, IntDigits },
                            UsizePromotion,
                        },
                        traits::{ CheckedAdd },
                    },
                    ops::{ Add, AddAssign },
                    *,
                };
                
                // Add with carry:
                #[inline] fn adc(carry: u8, a: u64, b: u64, out: &mut u64) -> u8 {
                    // Safety: There are absolutely no safety concerns with calling `_addcarry_u64`.
                    // It's just unsafe for API consistency with other intrinsics.
                    unsafe { arch::_addcarry_u64(carry, a, b, out) }
                }
                

                /// Two argument addition of raw slices, `a += b`, returning the carry.
                ///
                /// This is used when the data `Vec` might need to resize to push a non-zero carry, so we perform
                /// the addition first hoping that it will fit.
                ///
                /// The caller _must_ ensure that `a` is at least as long as `b`.
                #[inline] pub fn __add2(a: &mut [BigDigit], b: &[BigDigit]) -> BigDigit {
                    debug_assert!(a.len() >= b.len());

                    let mut carry = 0;
                    let (a_lo, a_hi) = a.split_at_mut(b.len());

                    for (a, b) in a_lo.iter_mut().zip(b) {
                        carry = adc(carry, *a, *b, a);
                    }

                    if carry != 0 {
                        for a in a_hi {
                            carry = adc(carry, *a, 0, a);
                            if carry == 0 {
                                break;
                            }
                        }
                    }

                    carry as BigDigit
                }
                /// Two argument addition of raw slices:
                /// a += b
                ///
                /// The caller _must_ ensure that a is big enough to store the result - typically this means
                /// resizing a to max(a.len(), b.len()) + 1, to fit a possible carry.
                pub fn add2(a: &mut [BigDigit], b: &[BigDigit]) {
                    let carry = __add2(a, b);

                    debug_assert!(carry == 0);
                }

                forward_all_binop_to_val_ref_commutative!(impl Add for BigUint, add);
                forward_val_assign!(impl AddAssign for BigUint, add_assign);

                impl Add<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn add(mut self, other: &BigUint) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<&BigUint> for BigUint {
                    #[inline] fn add_assign(&mut self, other: &BigUint) 
                    {
                        let self_len = self.data.len();
                        let carry = if self_len < other.data.len() {
                            let lo_carry = __add2(&mut self.data[..], &other.data[..self_len]);
                            self.data.extend_from_slice(&other.data[self_len..]);
                            __add2(&mut self.data[self_len..], &[lo_carry])
                        } else {
                            __add2(&mut self.data[..], &other.data[..])
                        };
                        if carry != 0 {
                            self.data.push(carry);
                        }
                    }
                }

                promote_unsigned_scalars!(impl Add for BigUint, add);
                promote_unsigned_scalars_assign!(impl AddAssign for BigUint, add_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u32> for BigUint, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u64> for BigUint, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u128> for BigUint, add);

                impl Add<u32> for BigUint {
                    type Output = BigUint;

                    #[inline] fn add(mut self, other: u32) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u32> for BigUint {
                    #[inline] fn add_assign(&mut self, other: u32) {
                        if other != 0 {
                            if self.data.is_empty() {
                                self.data.push(0);
                            }

                            let carry = __add2(&mut self.data, &[other as BigDigit]);
                            if carry != 0 {
                                self.data.push(carry);
                            }
                        }
                    }
                }

                impl Add<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn add(mut self, other: u64) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline] fn add_assign(&mut self, other: u64) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[lo, hi]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }

                        #[inline] fn add_assign(&mut self, other: u64) {
                            if other != 0 {
                                if self.data.is_empty() {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[other as BigDigit]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }
                    );
                }

                impl Add<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn add(mut self, other: u128) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline] fn add_assign(&mut self, other: u128) {
                            if other <= u128::from(u64::MAX) {
                                *self += other as u64
                            } else {
                                let (a, b, c, d) = super::u32_from_u128(other);
                                let carry = if a > 0 {
                                    while self.data.len() < 4 {
                                        self.data.push(0);
                                    }
                                    __add2(&mut self.data, &[d, c, b, a])
                                } else {
                                    debug_assert!(b > 0);
                                    while self.data.len() < 3 {
                                        self.data.push(0);
                                    }
                                    __add2(&mut self.data, &[d, c, b])
                                };

                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }

                        #[inline] fn add_assign(&mut self, other: u128) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[lo, hi]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }
                    );
                }

                impl CheckedAdd for BigUint {
                    #[inline] fn checked_add(&self, v: &BigUint) -> Option<BigUint> {
                        Some(self.add(v))
                    }
                }

                impl_sum_iter_type!(BigUint);
            }

            pub mod division
            {
                use ::
                {
                    cmp::Ordering::{Equal, Greater, Less},
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit, DoubleBigDigit },
                            biguint::{ addition::__add2, cmp_slice, BigUint },
                            UsizePromotion,
                        },
                        integers::{ Integer },
                        traits::{ CheckedDiv, CheckedEuclid, Euclid, One, ToPrimitive, Zero },
                    },
                    ops::{ Div, DivAssign, Rem, RemAssign },
                    *,
                };

                pub(super) const FAST_DIV_WIDE: bool = true;
                /// Divide a two digit numerator by a one digit divisor, returns quotient and remainder.
                #[inline] fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
                    // This debug assertion covers the potential #DE for divisor==0 or a quotient too large for one
                    // register, otherwise in release mode it will become a target-specific fault like SIGFPE.
                    // This should never occur with the inputs from our few `div_wide` callers.
                    debug_assert!(hi < divisor);

                    // SAFETY: The `div` instruction only affects registers, reading the explicit operand as the
                    // divisor, and implicitly reading RDX:RAX or EDX:EAX as the dividend. The result is implicitly
                    // written back to RAX or EAX for the quotient and RDX or EDX for the remainder. No memory is
                    // used, and flags are not preserved.
                    unsafe
                    {
                        let (div, rem);
                        macro_rules! div {
                            () => {
                                "div {0:r}"
                            };
                        }

                        ::arch::asm!(
                            div!(),
                            in(reg) divisor,
                            inout("dx") hi => rem,
                            inout("ax") lo => div,
                            options(pure, nomem, nostack),
                        );

                        (div, rem)
                    }
                }
                /// For small divisors, we can divide without promoting to `DoubleBigDigit` by
                /// using half-size pieces of digit, like long-division.
                #[inline] fn div_half(rem: BigDigit, digit: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
                    use ::num::big::big_digit::{HALF, HALF_BITS};

                    debug_assert!(rem < divisor && divisor <= HALF);
                    let (hi, rem) = ((rem << HALF_BITS) | (digit >> HALF_BITS)).div_rem(&divisor);
                    let (lo, rem) = ((rem << HALF_BITS) | (digit & HALF)).div_rem(&divisor);
                    ((hi << HALF_BITS) | lo, rem)
                }

                #[inline] pub fn div_rem_digit(mut a: BigUint, b: BigDigit) -> (BigUint, BigDigit) {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= big_digit::HALF {
                        for d in a.data.iter_mut().rev() {
                            let (q, r) = div_half(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    } else {
                        for d in a.data.iter_mut().rev() {
                            let (q, r) = div_wide(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    }

                    (a.normalized(), rem)
                }

                #[inline] fn rem_digit(a: &BigUint, b: BigDigit) -> BigDigit {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= big_digit::HALF {
                        for &digit in a.data.iter().rev() {
                            let (_, r) = div_half(rem, digit, b);
                            rem = r;
                        }
                    } else {
                        for &digit in a.data.iter().rev() {
                            let (_, r) = div_wide(rem, digit, b);
                            rem = r;
                        }
                    }

                    rem
                }
                /// Subtract a multiple.
                /// a -= b * c
                /// Returns a borrow (if a < b then borrow > 0).
                fn sub_mul_digit_same_len(a: &mut [BigDigit], b: &[BigDigit], c: BigDigit) -> BigDigit {
                    debug_assert!(a.len() == b.len());

                    // carry is between -big_digit::MAX and 0, so to avoid overflow we store
                    // offset_carry = carry + big_digit::MAX
                    let mut offset_carry = big_digit::MAX;

                    for (x, y) in a.iter_mut().zip(b) {
                        // We want to calculate sum = x - y * c + carry.
                        // sum >= -(big_digit::MAX * big_digit::MAX) - big_digit::MAX
                        // sum <= big_digit::MAX
                        // Offsetting sum by (big_digit::MAX << big_digit::BITS) puts it in DoubleBigDigit range.
                        let offset_sum = big_digit::to_doublebigdigit(big_digit::MAX, *x)
                            - big_digit::MAX as DoubleBigDigit
                            + offset_carry as DoubleBigDigit
                            - *y as DoubleBigDigit * c as DoubleBigDigit;

                        let (new_offset_carry, new_x) = big_digit::from_doublebigdigit(offset_sum);
                        offset_carry = new_offset_carry;
                        *x = new_x;
                    }

                    // Return the borrow.
                    big_digit::MAX - offset_carry
                }

                fn div_rem(mut u: BigUint, mut d: BigUint) -> (BigUint, BigUint) {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u, BigUint::ZERO);
                        }
                        let (div, rem) = div_rem_digit(u, d.data[0]);
                        // reuse d
                        d.data.clear();
                        d += rem;
                        return (div, d);
                    }

                    // Required or the q_len calculation below can underflow:
                    match u.cmp(&d) {
                        Less => return (BigUint::ZERO, u),
                        Equal => {
                            u.set_one();
                            return (u, BigUint::ZERO);
                        }
                        Greater => {} // Do nothing
                    }

                    // This algorithm is from Knuth, TAOCP vol 2 section 4.3, algorithm D:
                    //
                    // First, normalize the arguments so the highest bit in the highest digit of the divisor is
                    // set: the main loop uses the highest digit of the divisor for generating guesses, so we
                    // want it to be the largest number we can efficiently divide by.
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                        // no need to clone d
                        div_rem_core(u, &d.data)
                    } else {
                        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
                        // renormalize the remainder
                        (q, r >> shift)
                    }
                }

                pub fn div_rem_ref(u: &BigUint, d: &BigUint) -> (BigUint, BigUint) {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u.clone(), BigUint::ZERO);
                        }

                        let (div, rem) = div_rem_digit(u.clone(), d.data[0]);
                        return (div, rem.into());
                    }

                    // Required or the q_len calculation below can underflow:
                    match u.cmp(d) {
                        Less => return (BigUint::ZERO, u.clone()),
                        Equal => return (One::one(), BigUint::ZERO),
                        Greater => {} // Do nothing
                    }

                    // This algorithm is from Knuth, TAOCP vol 2 section 4.3, algorithm D:
                    //
                    // First, normalize the arguments so the highest bit in the highest digit of the divisor is
                    // set: the main loop uses the highest digit of the divisor for generating guesses, so we
                    // want it to be the largest number we can efficiently divide by.
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                        // no need to clone d
                        div_rem_core(u.clone(), &d.data)
                    } else {
                        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
                        // renormalize the remainder
                        (q, r >> shift)
                    }
                }
                /// An implementation of the base division algorithm.
                /// Knuth, TAOCP vol 2 section 4.3.1, algorithm D, with an improvement from exercises 19-21.
                fn div_rem_core(mut a: BigUint, b: &[BigDigit]) -> (BigUint, BigUint) {
                    debug_assert!(a.data.len() >= b.len() && b.len() > 1);
                    debug_assert!(b.last().unwrap().leading_zeros() == 0);

                    // The algorithm works by incrementally calculating "guesses", q0, for the next digit of the
                    // quotient. Once we have any number q0 such that (q0 << j) * b <= a, we can set
                    //
                    //     q += q0 << j
                    //     a -= (q0 << j) * b
                    //
                    // and then iterate until a < b. Then, (q, a) will be our desired quotient and remainder.
                    //
                    // q0, our guess, is calculated by dividing the last three digits of a by the last two digits of
                    // b - this will give us a guess that is close to the actual quotient, but is possibly greater.
                    // It can only be greater by 1 and only in rare cases, with probability at most
                    // 2^-(big_digit::BITS-1) for random a, see TAOCP 4.3.1 exercise 21.
                    //
                    // If the quotient turns out to be too large, we adjust it by 1:
                    // q -= 1 << j
                    // a += b << j

                    // a0 stores an additional extra most significant digit of the dividend, not stored in a.
                    let mut a0 = 0;

                    // [b1, b0] are the two most significant digits of the divisor. They never change.
                    let b0 = b[b.len() - 1];
                    let b1 = b[b.len() - 2];

                    let q_len = a.data.len() - b.len() + 1;
                    let mut q = BigUint {
                        data: vec![0; q_len],
                    };

                    for j in (0..q_len).rev() {
                        debug_assert!(a.data.len() == b.len() + j);

                        let a1 = *a.data.last().unwrap();
                        let a2 = a.data[a.data.len() - 2];

                        // The first q0 estimate is [a1,a0] / b0. It will never be too small, it may be too large
                        // by at most 2.
                        let (mut q0, mut r) = if a0 < b0 {
                            let (q0, r) = div_wide(a0, a1, b0);
                            (q0, r as DoubleBigDigit)
                        } else {
                            debug_assert!(a0 == b0);
                            // Avoid overflowing q0, we know the quotient fits in BigDigit.
                            // [a1,a0] = b0 * (1<<BITS - 1) + (a0 + a1)
                            (big_digit::MAX, a0 as DoubleBigDigit + a1 as DoubleBigDigit)
                        };

                        // r = [a1,a0] - q0 * b0
                        //
                        // Now we want to compute a more precise estimate [a2,a1,a0] / [b1,b0] which can only be
                        // less or equal to the current q0.
                        //
                        // q0 is too large if:
                        // [a2,a1,a0] < q0 * [b1,b0]
                        // (r << BITS) + a2 < q0 * b1
                        while r <= big_digit::MAX as DoubleBigDigit
                            && big_digit::to_doublebigdigit(r as BigDigit, a2)
                                < q0 as DoubleBigDigit * b1 as DoubleBigDigit
                        {
                            q0 -= 1;
                            r += b0 as DoubleBigDigit;
                        }

                        // q0 is now either the correct quotient digit, or in rare cases 1 too large.
                        // Subtract (q0 << j) from a. This may overflow, in which case we will have to correct.

                        let mut borrow = sub_mul_digit_same_len(&mut a.data[j..], b, q0);
                        if borrow > a0 {
                            // q0 is too large. We need to add back one multiple of b.
                            q0 -= 1;
                            borrow -= __add2(&mut a.data[j..], b);
                        }
                        // The top digit of a, stored in a0, has now been zeroed.
                        debug_assert!(borrow == a0);

                        q.data[j] = q0;

                        // Pop off the next top digit of a.
                        a0 = a.data.pop().unwrap();
                    }

                    a.data.push(a0);
                    a.normalize();

                    debug_assert_eq!(cmp_slice(&a.data, b), Less);

                    (q.normalized(), a)
                }

                forward_val_ref_binop!(impl Div for BigUint, div);
                forward_ref_val_binop!(impl Div for BigUint, div);
                forward_val_assign!(impl DivAssign for BigUint, div_assign);

                impl Div<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: BigUint) -> BigUint {
                        let (q, _) = div_rem(self, other);
                        q
                    }
                }

                impl Div<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: &BigUint) -> BigUint {
                        let (q, _) = self.div_rem(other);
                        q
                    }
                }
                impl DivAssign<&BigUint> for BigUint {
                    #[inline] fn div_assign(&mut self, other: &BigUint) {
                        *self = &*self / other;
                    }
                }

                promote_unsigned_scalars!(impl Div for BigUint, div);
                promote_unsigned_scalars_assign!(impl DivAssign for BigUint, div_assign);
                forward_all_scalar_binop_to_val_val!(impl Div<u32> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u64> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u128> for BigUint, div);

                impl Div<u32> for BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: u32) -> BigUint {
                        let (q, _) = div_rem_digit(self, other as BigDigit);
                        q
                    }
                }
                impl DivAssign<u32> for BigUint {
                    #[inline] fn div_assign(&mut self, other: u32) {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u32 {
                    type Output = BigUint;

                    #[inline] fn div(self, other: BigUint) -> BigUint {
                        match other.data.len() {
                            0 => panic!("attempt to divide by zero"),
                            1 => From::from(self as BigDigit / other.data[0]),
                            _ => BigUint::ZERO,
                        }
                    }
                }

                impl Div<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: u64) -> BigUint {
                        let (q, _) = div_rem(self, From::from(other));
                        q
                    }
                }
                impl DivAssign<u64> for BigUint {
                    #[inline] fn div_assign(&mut self, other: u64) {
                        // a vec of size 0 does not allocate, so this is fairly cheap
                        let temp = mem::replace(self, Self::ZERO);
                        *self = temp / other;
                    }
                }

                impl Div<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u64::from(other.data[0])),
                                2 => From::from(self / big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline] fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0]),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                impl Div<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: u128) -> BigUint {
                        let (q, _) = div_rem(self, From::from(other));
                        q
                    }
                }

                impl DivAssign<u128> for BigUint {
                    #[inline] fn div_assign(&mut self, other: u128) {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn div(self, other: BigUint) -> BigUint {
                            use super::u32_to_u128;
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u128::from(other.data[0])),
                                2 => From::from(
                                    self / u128::from(big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                ),
                                3 => From::from(self / u32_to_u128(0, other.data[2], other.data[1], other.data[0])),
                                4 => From::from(
                                    self / u32_to_u128(other.data[3], other.data[2], other.data[1], other.data[0]),
                                ),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline] fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0] as u128),
                                2 => From::from(self / big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                forward_val_ref_binop!(impl Rem for BigUint, rem);
                forward_ref_val_binop!(impl Rem for BigUint, rem);
                forward_val_assign!(impl RemAssign for BigUint, rem_assign);

                impl Rem<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: BigUint) -> BigUint {
                        if let Some(other) = other.to_u32() {
                            &self % other
                        } else {
                            let (_, r) = div_rem(self, other);
                            r
                        }
                    }
                }

                impl Rem<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: &BigUint) -> BigUint {
                        if let Some(other) = other.to_u32() {
                            self % other
                        } else {
                            let (_, r) = self.div_rem(other);
                            r
                        }
                    }
                }
                impl RemAssign<&BigUint> for BigUint {
                    #[inline] fn rem_assign(&mut self, other: &BigUint) {
                        *self = &*self % other;
                    }
                }

                promote_unsigned_scalars!(impl Rem for BigUint, rem);
                promote_unsigned_scalars_assign!(impl RemAssign for BigUint, rem_assign);
                forward_all_scalar_binop_to_ref_val!(impl Rem<u32> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u64> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u128> for BigUint, rem);

                impl Rem<u32> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: u32) -> BigUint {
                        rem_digit(self, other as BigDigit).into()
                    }
                }
                impl RemAssign<u32> for BigUint {
                    #[inline] fn rem_assign(&mut self, other: u32) {
                        *self = &*self % other;
                    }
                }

                impl Rem<&BigUint> for u32 {
                    type Output = BigUint;

                    #[inline] fn rem(mut self, other: &BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                macro_rules! impl_rem_assign_scalar {
                    ($scalar:ty, $to_scalar:ident) => {
                        forward_val_assign_scalar!(impl RemAssign for BigUint, $scalar, rem_assign);
                        impl RemAssign<&BigUint> for $scalar {
                            #[inline]
                            fn rem_assign(&mut self, other: &BigUint) {
                                *self = match other.$to_scalar() {
                                    None => *self,
                                    Some(0) => panic!("attempt to divide by zero"),
                                    Some(v) => *self % v
                                };
                            }
                        }
                    }
                }

                // we can scalar %= BigUint for any scalar, including signed types
                impl_rem_assign_scalar!(u128, to_u128);
                impl_rem_assign_scalar!(usize, to_usize);
                impl_rem_assign_scalar!(u64, to_u64);
                impl_rem_assign_scalar!(u32, to_u32);
                impl_rem_assign_scalar!(u16, to_u16);
                impl_rem_assign_scalar!(u8, to_u8);
                impl_rem_assign_scalar!(i128, to_i128);
                impl_rem_assign_scalar!(isize, to_isize);
                impl_rem_assign_scalar!(i64, to_i64);
                impl_rem_assign_scalar!(i32, to_i32);
                impl_rem_assign_scalar!(i16, to_i16);
                impl_rem_assign_scalar!(i8, to_i8);

                impl Rem<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: u64) -> BigUint {
                        let (_, r) = div_rem(self, From::from(other));
                        r
                    }
                }
                impl RemAssign<u64> for BigUint {
                    #[inline] fn rem_assign(&mut self, other: u64) {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u64 {
                    type Output = BigUint;

                    #[inline] fn rem(mut self, other: BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                impl Rem<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: u128) -> BigUint {
                        let (_, r) = div_rem(self, From::from(other));
                        r
                    }
                }

                impl RemAssign<u128> for BigUint {
                    #[inline] fn rem_assign(&mut self, other: u128) {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u128 {
                    type Output = BigUint;

                    #[inline] fn rem(mut self, other: BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                impl CheckedDiv for BigUint {
                    #[inline] fn checked_div(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div(v))
                    }
                }

                impl CheckedEuclid for BigUint {
                    #[inline] fn checked_div_euclid(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div_euclid(v))
                    }

                    #[inline] fn checked_rem_euclid(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.rem_euclid(v))
                    }

                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some(self.div_rem_euclid(v))
                    }
                }

                impl Euclid for BigUint {
                    #[inline] fn div_euclid(&self, v: &BigUint) -> BigUint {
                        // trivially same as regular division
                        self / v
                    }

                    #[inline] fn rem_euclid(&self, v: &BigUint) -> BigUint {
                        // trivially same as regular remainder
                        self % v
                    }

                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                        // trivially same as regular division and remainder
                        self.div_rem(v)
                    }
                }
            }

            pub mod multiplication
            {
                use ::
                {
                    cmp::{ Ordering },
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit, DoubleBigDigit },
                            biguint::
                            {
                                addition::{ __add2, add2 },
                                subtraction::{ sub2 },
                                biguint_from_vec, cmp_slice, BigUint, IntDigits,
                            },
                            BigInt, Sign::{ self, * }, UsizePromotion,
                        },
                        traits::{ CheckedMul, FromPrimitive, One, Zero },
                    },
                    ops::{ Mul, MulAssign },
                    *,
                };
                
                #[inline] pub fn mac_with_carry(
                    a: BigDigit,
                    b: BigDigit,
                    c: BigDigit,
                    acc: &mut DoubleBigDigit,
                ) -> BigDigit {
                    *acc += DoubleBigDigit::from(a);
                    *acc += DoubleBigDigit::from(b) * DoubleBigDigit::from(c);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }

                #[inline] fn mul_with_carry(a: BigDigit, b: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
                    *acc += DoubleBigDigit::from(a) * DoubleBigDigit::from(b);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }
                /// Three argument multiply accumulate:
                /// acc += b * c
                fn mac_digit(acc: &mut [BigDigit], b: &[BigDigit], c: BigDigit) {
                    if c == 0 {
                        return;
                    }

                    let mut carry = 0;
                    let (a_lo, a_hi) = acc.split_at_mut(b.len());

                    for (a, &b) in a_lo.iter_mut().zip(b) {
                        *a = mac_with_carry(*a, b, c, &mut carry);
                    }

                    let (carry_hi, carry_lo) = big_digit::from_doublebigdigit(carry);

                    let final_carry = if carry_hi == 0 {
                        __add2(a_hi, &[carry_lo])
                    } else {
                        __add2(a_hi, &[carry_hi, carry_lo])
                    };
                    assert_eq!(final_carry, 0, "carry overflow during multiplication!");
                }

                fn bigint_from_slice(slice: &[BigDigit]) -> BigInt {
                    BigInt::from(biguint_from_vec(slice.to_vec()))
                }
                /// Three argument multiply accumulate:
                /// acc += b * c
                #[allow(clippy::many_single_char_names)]
                fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) {
                    // Least-significant zeros have no effect on the output.
                    if let Some(&0) = b.first() {
                        if let Some(nz) = b.iter().position(|&d| d != 0) {
                            b = &b[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }
                    if let Some(&0) = c.first() {
                        if let Some(nz) = c.iter().position(|&d| d != 0) {
                            c = &c[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }

                    let acc = acc;
                    let (x, y) = if b.len() < c.len() { (b, c) } else { (c, b) };
                    
                    if x.len() <= 32 {
                        // Long multiplication:
                        for (i, xi) in x.iter().enumerate() {
                            mac_digit(&mut acc[i..], y, *xi);
                        }
                    } else if x.len() * 2 <= y.len() 
                    {
                        // Karatsuba Multiplication for factors with significant length disparity.
                        let m2 = y.len() / 2;
                        let (low2, high2) = y.split_at(m2);

                        // (x * high2) * NBASE ^ m2 + z0
                        mac3(acc, x, low2);
                        mac3(&mut acc[m2..], x, high2);
                    } else if x.len() <= 256 {
                        // Karatsuba multiplication:
                        let b = x.len() / 2;
                        let (x0, x1) = x.split_at(b);
                        let (y0, y1) = y.split_at(b);

                        // We reuse the same BigUint for all the intermediate multiplies and have to size p
                        // appropriately here: x1.len() >= x0.len and y1.len() >= y0.len():
                        let len = x1.len() + y1.len() + 1;
                        let mut p = BigUint { data: vec![0; len] };

                        // p2 = x1 * y1
                        mac3(&mut p.data, x1, y1);

                        // Not required, but the adds go faster if we drop any unneeded 0s from the end:
                        p.normalize();

                        add2(&mut acc[b..], &p.data);
                        add2(&mut acc[b * 2..], &p.data);

                        // Zero out p before the next multiply:
                        p.data.truncate(0);
                        p.data.resize(len, 0);

                        // p0 = x0 * y0
                        mac3(&mut p.data, x0, y0);
                        p.normalize();

                        add2(acc, &p.data);
                        add2(&mut acc[b..], &p.data);

                        // p1 = (x1 - x0) * (y1 - y0)
                        // We do this one last, since it may be negative and acc can't ever be negative:
                        let (j0_sign, j0) = sub_sign(x1, x0);
                        let (j1_sign, j1) = sub_sign(y1, y0);

                        match j0_sign * j1_sign {
                            Plus => {
                                p.data.truncate(0);
                                p.data.resize(len, 0);

                                mac3(&mut p.data, &j0.data, &j1.data);
                                p.normalize();

                                sub2(&mut acc[b..], &p.data);
                            }
                            Minus => {
                                mac3(&mut acc[b..], &j0.data, &j1.data);
                            }
                            NoSign => (),
                        }
                    } else {
                        // Toom-3 multiplication:
                        let i = y.len() / 3 + 1;

                        let x0_len = Ord::min(x.len(), i);
                        let x1_len = Ord::min(x.len() - x0_len, i);

                        let y0_len = i;
                        let y1_len = Ord::min(y.len() - y0_len, i);
                        
                        let x0 = bigint_from_slice(&x[..x0_len]);
                        let x1 = bigint_from_slice(&x[x0_len..x0_len + x1_len]);
                        let x2 = bigint_from_slice(&x[x0_len + x1_len..]);

                        // y(t) = y2*t^2 + y1*t + y0
                        let y0 = bigint_from_slice(&y[..y0_len]);
                        let y1 = bigint_from_slice(&y[y0_len..y0_len + y1_len]);
                        let y2 = bigint_from_slice(&y[y0_len + y1_len..]);
                        
                        let p = &x0 + &x2;

                        // y0 + y2, avoiding temporaries
                        let q = &y0 + &y2;

                        // x2 - x1 + x0, avoiding temporaries
                        let p2 = &p - &x1;

                        // y2 - y1 + y0, avoiding temporaries
                        let q2 = &q - &y1;

                        // w(0)
                        let r0 = &x0 * &y0;

                        // w(inf)
                        let r4 = &x2 * &y2;

                        // w(1)
                        let r1 = (p + x1) * (q + y1);

                        // w(-1)
                        let r2 = &p2 * &q2;

                        // w(-2)
                        let r3 = ((p2 + x2) * 2 - x0) * ((q2 + y2) * 2 - y0);

                        // Evaluating these points gives us the following system of linear equations.
                        let mut comp3: BigInt = (r3 - &r1) / 3u32;
                        let mut comp1: BigInt = (r1 - &r2) >> 1;
                        let mut comp2: BigInt = r2 - &r0;
                        comp3 = ((&comp2 - comp3) >> 1) + (&r4 << 1);
                        comp2 += &comp1 - &r4;
                        comp1 -= &comp3;

                        // Recomposition. The coefficients of the polynomial are now known.
                        for (j, result) in [&r0, &comp1, &comp2, &comp3, &r4].iter().enumerate().rev() {
                            match result.sign() {
                                Plus => add2(&mut acc[i * j..], result.digits()),
                                Minus => sub2(&mut acc[i * j..], result.digits()),
                                NoSign => {}
                            }
                        }
                    }
                }

                fn mul3(x: &[BigDigit], y: &[BigDigit]) -> BigUint {
                    let len = x.len() + y.len() + 1;
                    let mut prod = BigUint { data: vec![0; len] };

                    mac3(&mut prod.data, x, y);
                    prod.normalized()
                }

                fn scalar_mul(a: &mut BigUint, b: BigDigit) {
                    match b {
                        0 => a.set_zero(),
                        1 => {}
                        _ => {
                            if b.is_power_of_two() {
                                *a <<= b.trailing_zeros();
                            } else {
                                let mut carry = 0;
                                for a in a.data.iter_mut() {
                                    *a = mul_with_carry(*a, b, &mut carry);
                                }
                                if carry != 0 {
                                    a.data.push(carry as BigDigit);
                                }
                            }
                        }
                    }
                }

                fn sub_sign(mut a: &[BigDigit], mut b: &[BigDigit]) -> (Sign, BigUint) {
                    // Normalize:
                    if let Some(&0) = a.last() {
                        a = &a[..a.iter().rposition(|&x| x != 0).map_or(0, |i| i + 1)];
                    }
                    if let Some(&0) = b.last() {
                        b = &b[..b.iter().rposition(|&x| x != 0).map_or(0, |i| i + 1)];
                    }

                    match cmp_slice(a, b) {
                        Ordering::Greater => {
                            let mut a = a.to_vec();
                            sub2(&mut a, b);
                            (Plus, biguint_from_vec(a))
                        }
                        Ordering::Less => {
                            let mut b = b.to_vec();
                            sub2(&mut b, a);
                            (Minus, biguint_from_vec(b))
                        }
                        Ordering::Equal => (NoSign, BigUint::ZERO),
                    }
                }

                macro_rules! impl_mul {
                    ($(impl Mul<$Other:ty> for $Self:ty;)*) => {$(
                        impl Mul<$Other> for $Self {
                            type Output = BigUint;

                            #[inline]
                            fn mul(self, other: $Other) -> BigUint {
                                match (&*self.data, &*other.data) {
                                    // multiply by zero
                                    (&[], _) | (_, &[]) => BigUint::ZERO,
                                    // multiply by a scalar
                                    (_, &[digit]) => self * digit,
                                    (&[digit], _) => other * digit,
                                    // full multiplication
                                    (x, y) => mul3(x, y),
                                }
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigUint> for BigUint;
                    impl Mul<BigUint> for &BigUint;
                    impl Mul<&BigUint> for BigUint;
                    impl Mul<&BigUint> for &BigUint;
                }

                macro_rules! impl_mul_assign {
                    ($(impl MulAssign<$Other:ty> for BigUint;)*) => {$(
                        impl MulAssign<$Other> for BigUint {
                            #[inline]
                            fn mul_assign(&mut self, other: $Other) {
                                match (&*self.data, &*other.data) {
                                    // multiply by zero
                                    (&[], _) => {},
                                    (_, &[]) => self.set_zero(),
                                    // multiply by a scalar
                                    (_, &[digit]) => *self *= digit,
                                    (&[digit], _) => *self = other * digit,
                                    // full multiplication
                                    (x, y) => *self = mul3(x, y),
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigUint> for BigUint;
                    impl MulAssign<&BigUint> for BigUint;
                }

                promote_unsigned_scalars!(impl Mul for BigUint, mul);
                promote_unsigned_scalars_assign!(impl MulAssign for BigUint, mul_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u32> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u64> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u128> for BigUint, mul);

                impl Mul<u32> for BigUint {
                    type Output = BigUint;

                    #[inline] fn mul(mut self, other: u32) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u32> for BigUint {
                    #[inline] fn mul_assign(&mut self, other: u32) {
                        scalar_mul(self, other as BigDigit);
                    }
                }

                impl Mul<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn mul(mut self, other: u64) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline] fn mul_assign(&mut self, other: u64) {
                            if let Some(other) = BigDigit::from_u64(other) {
                                scalar_mul(self, other);
                            } else {
                                let (hi, lo) = big_digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }

                        #[inline] fn mul_assign(&mut self, other: u64) {
                            scalar_mul(self, other);
                        }
                    );
                }

                impl Mul<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn mul(mut self, other: u128) -> BigUint {
                        self *= other;
                        self
                    }
                }

                impl MulAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline] fn mul_assign(&mut self, other: u128) {
                            if let Some(other) = BigDigit::from_u128(other) {
                                scalar_mul(self, other);
                            } else {
                                *self = match super::u32_from_u128(other) {
                                    (0, 0, c, d) => mul3(&self.data, &[d, c]),
                                    (0, b, c, d) => mul3(&self.data, &[d, c, b]),
                                    (a, b, c, d) => mul3(&self.data, &[d, c, b, a]),
                                };
                            }
                        }

                        #[inline] fn mul_assign(&mut self, other: u128) {
                            if let Some(other) = BigDigit::from_u128(other) {
                                scalar_mul(self, other);
                            } else {
                                let (hi, lo) = big_digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }
                    );
                }

                impl CheckedMul for BigUint {
                    #[inline] fn checked_mul(&self, v: &BigUint) -> Option<BigUint> {
                        Some(self.mul(v))
                    }
                }

                impl_product_iter_type!(BigUint);
            }

            pub mod subtraction
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit },
                            biguint::{ BigUint },
                            UsizePromotion
                        },
                        traits::{ CheckedSub },
                    },
                    ops::{ Sub, SubAssign },
                    *,
                };
                
                
                #[inline] fn sbb(borrow: u8, a: u64, b: u64, out: &mut u64) -> u8 {
                    // Safety: There are absolutely no safety concerns with calling `_subborrow_u64`.
                    // It's just unsafe for API consistency with other intrinsics.
                    unsafe { ::arch::_subborrow_u64(borrow, a, b, out) }
                }
                
                pub fn sub2(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut borrow = 0;

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi) = a.split_at_mut(len);
                    let (b_lo, b_hi) = b.split_at(len);

                    for (a, b) in a_lo.iter_mut().zip(b_lo) {
                        borrow = sbb(borrow, *a, *b, a);
                    }

                    if borrow != 0 {
                        for a in a_hi {
                            borrow = sbb(borrow, *a, 0, a);
                            if borrow == 0 {
                                break;
                            }
                        }
                    }

                    // note: we're _required_ to fail on underflow
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }

                // Only for the Sub impl. `a` and `b` must have same length.
                #[inline] fn __sub2rev(a: &[BigDigit], b: &mut [BigDigit]) -> u8 {
                    debug_assert!(b.len() == a.len());

                    let mut borrow = 0;

                    for (ai, bi) in a.iter().zip(b) {
                        borrow = sbb(borrow, *ai, *bi, bi);
                    }

                    borrow
                }

                fn sub2rev(a: &[BigDigit], b: &mut [BigDigit]) {
                    debug_assert!(b.len() >= a.len());

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi) = a.split_at(len);
                    let (b_lo, b_hi) = b.split_at_mut(len);

                    let borrow = __sub2rev(a_lo, b_lo);

                    assert!(a_hi.is_empty());

                    // note: we're _required_ to fail on underflow
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }

                forward_val_val_binop!(impl Sub for BigUint, sub);
                forward_ref_ref_binop!(impl Sub for BigUint, sub);
                forward_val_assign!(impl SubAssign for BigUint, sub_assign);

                impl Sub<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn sub(mut self, other: &BigUint) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<&BigUint> for BigUint {
                    fn sub_assign(&mut self, other: &BigUint) {
                        sub2(&mut self.data[..], &other.data[..]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for &BigUint {
                    type Output = BigUint;

                    fn sub(self, mut other: BigUint) -> BigUint {
                        let other_len = other.data.len();
                        if other_len < self.data.len() {
                            let lo_borrow = __sub2rev(&self.data[..other_len], &mut other.data);
                            other.data.extend_from_slice(&self.data[other_len..]);
                            if lo_borrow != 0 {
                                sub2(&mut other.data[other_len..], &[1])
                            }
                        } else {
                            sub2rev(&self.data[..], &mut other.data[..]);
                        }
                        other.normalized()
                    }
                }

                promote_unsigned_scalars!(impl Sub for BigUint, sub);
                promote_unsigned_scalars_assign!(impl SubAssign for BigUint, sub_assign);
                forward_all_scalar_binop_to_val_val!(impl Sub<u32> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u64> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u128> for BigUint, sub);

                impl Sub<u32> for BigUint {
                    type Output = BigUint;

                    #[inline] fn sub(mut self, other: u32) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u32> for BigUint {
                    fn sub_assign(&mut self, other: u32) {
                        sub2(&mut self.data[..], &[other as BigDigit]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for u32 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.len() == 0 {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }

                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push(self as BigDigit);
                            } else {
                                sub2rev(&[self as BigDigit], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn sub(mut self, other: u64) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline] fn sub_assign(&mut self, other: u64) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }

                        #[inline] fn sub_assign(&mut self, other: u64) {
                            sub2(&mut self.data[..], &[other as BigDigit]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push(0);
                            }

                            let (hi, lo) = big_digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn sub(mut self, other: u128) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline] fn sub_assign(&mut self, other: u128) {
                            let (a, b, c, d) = super::u32_from_u128(other);
                            sub2(&mut self.data[..], &[d, c, b, a]);
                            self.normalize();
                        }

                        #[inline] fn sub_assign(&mut self, other: u128) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 4 {
                                other.data.push(0);
                            }

                            let (a, b, c, d) = super::u32_from_u128(self);
                            sub2rev(&[d, c, b, a], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push(0);
                            }

                            let (hi, lo) = big_digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }
                    );
                }

                impl CheckedSub for BigUint {
                    #[inline] fn checked_sub(&self, v: &BigUint) -> Option<BigUint> {
                        match self.cmp(v) {
                            Less => None,
                            Equal => Some(Self::ZERO),
                            Greater => Some(self.sub(v)),
                        }
                    }
                }
            }

            pub mod bits
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            biguint::{ BigUint, IntDigits }
                        },
                        traits::{},
                    },
                    ops::{ BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign },
                    *,
                };

                forward_val_val_binop!(impl BitAnd for BigUint, bitand);
                forward_ref_val_binop!(impl BitAnd for BigUint, bitand);

                // do not use forward_ref_ref_binop_commutative! for bitand so that we can
                // clone the smaller value rather than the larger, avoiding over-allocation
                impl BitAnd<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn bitand(self, other: &BigUint) -> BigUint {
                        // forward to val-ref, choosing the smaller to clone
                        if self.data.len() <= other.data.len() {
                            self.clone() & other
                        } else {
                            other.clone() & self
                        }
                    }
                }

                forward_val_assign!(impl BitAndAssign for BigUint, bitand_assign);

                impl BitAnd<&BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline] fn bitand(mut self, other: &BigUint) -> BigUint {
                        self &= other;
                        self
                    }
                }
                impl BitAndAssign<&BigUint> for BigUint {
                    #[inline] fn bitand_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai &= bi;
                        }
                        self.data.truncate(other.data.len());
                        self.normalize();
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitOr for BigUint, bitor);
                forward_val_assign!(impl BitOrAssign for BigUint, bitor_assign);

                impl BitOr<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn bitor(mut self, other: &BigUint) -> BigUint {
                        self |= other;
                        self
                    }
                }
                impl BitOrAssign<&BigUint> for BigUint {
                    #[inline] fn bitor_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai |= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitXor for BigUint, bitxor);
                forward_val_assign!(impl BitXorAssign for BigUint, bitxor_assign);

                impl BitXor<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn bitxor(mut self, other: &BigUint) -> BigUint {
                        self ^= other;
                        self
                    }
                }
                impl BitXorAssign<&BigUint> for BigUint {
                    #[inline] fn bitxor_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai ^= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                        self.normalize();
                    }
                }
            }

            pub mod convert
            {
                use ::
                {
                    cmp::Ordering::{Equal, Greater, Less},
                    convert::TryFrom,
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit },
                            biguint::
                            {
                                addition::add2,
                                division::{div_rem_digit, FAST_DIV_WIDE},
                                multiplication::mac_with_carry,
                                biguint_from_vec, BigUint, ToBigUint ,
                            },
                            TryFromBigIntError, ParseBigIntError,
                        },
                        integers::{Integer, Roots},
                        traits::{ float::FloatCore, FromPrimitive, Num, One, PrimInt, ToPrimitive, Zero },
                    },
                    str::FromStr,
                    vec::{ Vec },
                    *,
                };
                
                /// Find last set bit
                /// fls(0) == 0, fls(u32::MAX) == 32
                fn fls<T: PrimInt>(v: T) -> u8 
                {
                    mem::size_of::<T>() as u8 * 8 - v.leading_zeros() as u8
                }

                fn ilog2<T: PrimInt>(v: T) -> u8 
                {
                    fls(v) - 1
                }

                impl FromStr for BigUint
                {
                    type Err = ParseBigIntError;

                    #[inline] fn from_str(s: &str) -> Result<BigUint, ParseBigIntError>
                    {
                        BigUint::from_str_radix(s, 10)
                    }
                }

                // Convert from a power of two radix (bits == ilog2(radix)) where bits evenly divides
                // BigDigit::BITS
                pub fn from_bitwise_digits_le(v: &[u8], bits: u8) -> BigUint 
                {
                    debug_assert!(!v.is_empty() && bits <= 8 && big_digit::BITS % bits == 0);
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c) < (1 << bits)));

                    let digits_per_big_digit = big_digit::BITS / bits;

                    let data = v
                        .chunks(digits_per_big_digit.into())
                        .map(|chunk| {
                            chunk
                                .iter()
                                .rev()
                                .fold(0, |acc, &c| (acc << bits) | BigDigit::from(c))
                        })
                        .collect();

                    biguint_from_vec(data)
                }
                
                fn from_inexact_bitwise_digits_le(v: &[u8], bits: u8) -> BigUint 
                {
                    debug_assert!(!v.is_empty() && bits <= 8 && big_digit::BITS % bits != 0);
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c) < (1 << bits)));

                    let total_bits = (v.len() as u64).saturating_mul(bits.into());
                    let big_digits = Integer::div_ceil(&total_bits, &big_digit::BITS.into())
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut data = Vec::with_capacity(big_digits);

                    let mut d = 0;
                    let mut dbits = 0; // number of bits we currently have in d

                    // walk v accumululating bits in d; whenever we accumulate big_digit::BITS in d, spit out a
                    // big_digit:
                    for &c in v {
                        d |= BigDigit::from(c) << dbits;
                        dbits += bits;

                        if dbits >= big_digit::BITS {
                            data.push(d);
                            dbits -= big_digit::BITS;
                            // if dbits was > big_digit::BITS, we dropped some of the bits in c (they couldn't fit
                            // in d) - grab the bits we lost here:
                            d = BigDigit::from(c) >> (bits - dbits);
                        }
                    }

                    if dbits > 0 {
                        debug_assert!(dbits < big_digit::BITS);
                        data.push(d as BigDigit);
                    }

                    biguint_from_vec(data)
                }

                // Read little-endian radix digits
                fn from_radix_digits_be(v: &[u8], radix: u32) -> BigUint 
                {
                    debug_assert!(!v.is_empty() && !radix.is_power_of_two());
                    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));

                    // Estimate how big the result will be, so we can pre-allocate it.
                    let big_digits = {
                        let radix_log2 = f64::from(radix).log2();
                        let bits = radix_log2 * v.len() as f64;
                        (bits / big_digit::BITS as f64).ceil()
                    };

                    let mut data = Vec::with_capacity(big_digits.to_usize().unwrap_or(0));

                    let (base, power) = get_radix_base(radix);
                    let radix = radix as BigDigit;

                    let r = v.len() % power;
                    let i = if r == 0 { power } else { r };
                    let (head, tail) = v.split_at(i);

                    let first = head
                        .iter()
                        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                    data.push(first);

                    debug_assert!(tail.len() % power == 0);
                    for chunk in tail.chunks(power) {
                        if data.last() != Some(&0) {
                            data.push(0);
                        }

                        let mut carry = 0;
                        for d in data.iter_mut() {
                            *d = mac_with_carry(0, *d, base, &mut carry);
                        }
                        debug_assert!(carry == 0);

                        let n = chunk
                            .iter()
                            .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                        add2(&mut data, &[n]);
                    }

                    biguint_from_vec(data)
                }

                pub fn from_radix_be(buf: &[u8], radix: u32) -> Option<BigUint> 
                {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                        // Powers of two can use bitwise masks and shifting instead of multiplication
                        let bits = ilog2(radix);
                        let mut v = Vec::from(buf);
                        v.reverse();
                        if big_digit::BITS % bits == 0 {
                            from_bitwise_digits_le(&v, bits)
                        } else {
                            from_inexact_bitwise_digits_le(&v, bits)
                        }
                    } else {
                        from_radix_digits_be(buf, radix)
                    };

                    Some(res)
                }

                pub fn from_radix_le(buf: &[u8], radix: u32) -> Option<BigUint> 
                {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                        // Powers of two can use bitwise masks and shifting instead of multiplication
                        let bits = ilog2(radix);
                        if big_digit::BITS % bits == 0 {
                            from_bitwise_digits_le(buf, bits)
                        } else {
                            from_inexact_bitwise_digits_le(buf, bits)
                        }
                    } else {
                        let mut v = Vec::from(buf);
                        v.reverse();
                        from_radix_digits_be(&v, radix)
                    };

                    Some(res)
                }

                impl Num for BigUint 
                {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a `BigUint`.
                    fn from_str_radix(s: &str, radix: u32) -> Result<BigUint, ParseBigIntError> {
                        assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
                        let mut s = s;
                        if let Some(tail) = s.strip_prefix('+') {
                            if !tail.starts_with('+') {
                                s = tail
                            }
                        }

                        if s.is_empty() {
                            return Err(ParseBigIntError::empty());
                        }

                        if s.starts_with('_') {
                            // Must lead with a real digit!
                            return Err(ParseBigIntError::invalid());
                        }

                        // First normalize all characters to plain digit values
                        let mut v = Vec::with_capacity(s.len());
                        for b in s.bytes() {
                            let d = match b {
                                b'0'..=b'9' => b - b'0',
                                b'a'..=b'z' => b - b'a' + 10,
                                b'A'..=b'Z' => b - b'A' + 10,
                                b'_' => continue,
                                _ => u8::MAX,
                            };
                            if d < radix as u8 {
                                v.push(d);
                            } else {
                                return Err(ParseBigIntError::invalid());
                            }
                        }

                        let res = if radix.is_power_of_two() {
                            // Powers of two can use bitwise masks and shifting instead of multiplication
                            let bits = ilog2(radix);
                            v.reverse();
                            if big_digit::BITS % bits == 0 {
                                from_bitwise_digits_le(&v, bits)
                            } else {
                                from_inexact_bitwise_digits_le(&v, bits)
                            }
                        } else {
                            from_radix_digits_be(&v, radix)
                        };
                        Ok(res)
                    }
                }

                fn high_bits_to_u64(v: &BigUint) -> u64 
                {
                    match v.data.len() {
                        0 => 0,
                        1 => {
                            // XXX Conversion is useless if already 64-bit.
                            #[allow(clippy::useless_conversion)]
                            let v0 = u64::from(v.data[0]);
                            v0
                        }
                        _ => {
                            let mut bits = v.bits();
                            let mut ret = 0u64;
                            let mut ret_bits = 0;

                            for d in v.data.iter().rev() {
                                let digit_bits = (bits - 1) % u64::from(big_digit::BITS) + 1;
                                let bits_want = Ord::min(64 - ret_bits, digit_bits);

                                if bits_want != 0 {
                                    if bits_want != 64 {
                                        ret <<= bits_want;
                                    }
                                    // XXX Conversion is useless if already 64-bit.
                                    #[allow(clippy::useless_conversion)]
                                    let d0 = u64::from(*d) >> (digit_bits - bits_want);
                                    ret |= d0;
                                }

                                // Implement round-to-odd: If any lower bits are 1, set LSB to 1
                                // so that rounding again to floating point value using
                                // nearest-ties-to-even is correct.
                                //
                                // See: https://en.wikipedia.org/wiki/Rounding#Rounding_to_prepare_for_shorter_precision

                                if digit_bits - bits_want != 0 {
                                    // XXX Conversion is useless if already 64-bit.
                                    #[allow(clippy::useless_conversion)]
                                    let masked = u64::from(*d) << (64 - (digit_bits - bits_want) as u32);
                                    ret |= (masked != 0) as u64;
                                }

                                ret_bits += bits_want;
                                bits -= bits_want;
                            }

                            ret
                        }
                    }
                }

                impl ToPrimitive for BigUint 
                {
                    #[inline] fn to_i64(&self) -> Option<i64> {
                        self.to_u64().as_ref().and_then(u64::to_i64)
                    }

                    #[inline] fn to_i128(&self) -> Option<i128> {
                        self.to_u128().as_ref().and_then(u128::to_i128)
                    }

                    #[allow(clippy::useless_conversion)]
                    #[inline] fn to_u64(&self) -> Option<u64> {
                        let mut ret: u64 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 64 {
                                return None;
                            }

                            // XXX Conversion is useless if already 64-bit.
                            ret += u64::from(*i) << bits;
                            bits += big_digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline] fn to_u128(&self) -> Option<u128> {
                        let mut ret: u128 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 128 {
                                return None;
                            }

                            ret |= u128::from(*i) << bits;
                            bits += big_digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline] fn to_f32(&self) -> Option<f32> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f32::MAX_EXP as u64 {
                            Some(f32::INFINITY)
                        } else {
                            Some((mantissa as f32) * 2.0f32.powi(exponent as i32))
                        }
                    }

                    #[inline] fn to_f64(&self) -> Option<f64> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f64::MAX_EXP as u64 {
                            Some(f64::INFINITY)
                        } else {
                            Some((mantissa as f64) * 2.0f64.powi(exponent as i32))
                        }
                    }
                }

                macro_rules! impl_try_from_biguint 
                {
                    ($T:ty, $to_ty:path) => {
                        impl TryFrom<&BigUint> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: &BigUint) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }

                        impl TryFrom<BigUint> for $T {
                            type Error = TryFromBigIntError<BigUint>;

                            #[inline]
                            fn try_from(value: BigUint) -> Result<$T, TryFromBigIntError<BigUint>> {
                                <$T>::try_from(&value).map_err(|_| TryFromBigIntError::new(value))
                            }
                        }
                    };
                }

                impl_try_from_biguint!(u8, ToPrimitive::to_u8);
                impl_try_from_biguint!(u16, ToPrimitive::to_u16);
                impl_try_from_biguint!(u32, ToPrimitive::to_u32);
                impl_try_from_biguint!(u64, ToPrimitive::to_u64);
                impl_try_from_biguint!(usize, ToPrimitive::to_usize);
                impl_try_from_biguint!(u128, ToPrimitive::to_u128);

                impl_try_from_biguint!(i8, ToPrimitive::to_i8);
                impl_try_from_biguint!(i16, ToPrimitive::to_i16);
                impl_try_from_biguint!(i32, ToPrimitive::to_i32);
                impl_try_from_biguint!(i64, ToPrimitive::to_i64);
                impl_try_from_biguint!(isize, ToPrimitive::to_isize);
                impl_try_from_biguint!(i128, ToPrimitive::to_i128);

                impl FromPrimitive for BigUint
                {
                    #[inline] fn from_i64(n: i64) -> Option<BigUint> 
                    {
                        if n >= 0 {
                            Some(BigUint::from(n as u64))
                        } else {
                            None
                        }
                    }

                    #[inline] fn from_i128(n: i128) -> Option<BigUint> 
                    {
                        if n >= 0 {
                            Some(BigUint::from(n as u128))
                        } else {
                            None
                        }
                    }

                    #[inline] fn from_u64(n: u64) -> Option<BigUint> 
                    {
                        Some(BigUint::from(n))
                    }

                    #[inline] fn from_u128(n: u128) -> Option<BigUint> 
                    {
                        Some(BigUint::from(n))
                    }

                    #[inline] fn from_f64(mut n: f64) -> Option<BigUint> 
                    {
                        // handle NAN, INFINITY, NEG_INFINITY
                        if !n.is_finite() {
                            return None;
                        }

                        // match the rounding of casting from float to int
                        n = n.trunc();

                        // handle 0.x, -0.x
                        if n.is_zero() {
                            return Some(Self::ZERO);
                        }

                        let (mantissa, exponent, sign) = FloatCore::integer_decode(n);

                        if sign == -1 {
                            return None;
                        }

                        let mut ret = BigUint::from(mantissa);
                        match exponent.cmp(&0) {
                            Greater => ret <<= exponent as usize,
                            Equal => {}
                            Less => ret >>= (-exponent) as usize,
                        }
                        Some(ret)
                    }
                }

                impl From<u64> for BigUint 
                {
                    #[inline] fn from(mut n: u64) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                            // don't overflow if BITS is 64:
                            n = (n >> 1) >> (big_digit::BITS - 1);
                        }

                        ret
                    }
                }

                impl From<u128> for BigUint 
                {
                    #[inline] fn from(mut n: u128) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                            n >>= big_digit::BITS;
                        }

                        ret
                    }
                }

                macro_rules! impl_biguint_from_uint 
                {
                    ($T:ty) => {
                        impl From<$T> for BigUint {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigUint::from(n as u64)
                            }
                        }
                    };
                }

                impl_biguint_from_uint!(u8);
                impl_biguint_from_uint!(u16);
                impl_biguint_from_uint!(u32);
                impl_biguint_from_uint!(usize);

                macro_rules! impl_biguint_try_from_int 
                {
                    ($T:ty, $from_ty:path) => {
                        impl TryFrom<$T> for BigUint {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: $T) -> Result<BigUint, TryFromBigIntError<()>> {
                                $from_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }
                    };
                }

                impl_biguint_try_from_int!(i8, FromPrimitive::from_i8);
                impl_biguint_try_from_int!(i16, FromPrimitive::from_i16);
                impl_biguint_try_from_int!(i32, FromPrimitive::from_i32);
                impl_biguint_try_from_int!(i64, FromPrimitive::from_i64);
                impl_biguint_try_from_int!(isize, FromPrimitive::from_isize);
                impl_biguint_try_from_int!(i128, FromPrimitive::from_i128);

                impl ToBigUint for BigUint 
                {
                    #[inline] fn to_biguint(&self) -> Option<BigUint> {
                        Some(self.clone())
                    }
                }

                macro_rules! impl_to_biguint 
                {
                    ($T:ty, $from_ty:path) => {
                        impl ToBigUint for $T {
                            #[inline]
                            fn to_biguint(&self) -> Option<BigUint> {
                                $from_ty(*self)
                            }
                        }
                    };
                }

                impl_to_biguint!(isize, FromPrimitive::from_isize);
                impl_to_biguint!(i8, FromPrimitive::from_i8);
                impl_to_biguint!(i16, FromPrimitive::from_i16);
                impl_to_biguint!(i32, FromPrimitive::from_i32);
                impl_to_biguint!(i64, FromPrimitive::from_i64);
                impl_to_biguint!(i128, FromPrimitive::from_i128);

                impl_to_biguint!(usize, FromPrimitive::from_usize);
                impl_to_biguint!(u8, FromPrimitive::from_u8);
                impl_to_biguint!(u16, FromPrimitive::from_u16);
                impl_to_biguint!(u32, FromPrimitive::from_u32);
                impl_to_biguint!(u64, FromPrimitive::from_u64);
                impl_to_biguint!(u128, FromPrimitive::from_u128);

                impl_to_biguint!(f32, FromPrimitive::from_f32);
                impl_to_biguint!(f64, FromPrimitive::from_f64);

                impl From<bool> for BigUint 
                {
                    fn from(x: bool) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }

                // Extract bitwise digits that evenly divide BigDigit
                pub fn to_bitwise_digits_le(u: &BigUint, bits: u8) -> Vec<u8> 
                {
                    debug_assert!(!u.is_zero() && bits <= 8 && big_digit::BITS % bits == 0);

                    let last_i = u.data.len() - 1;
                    let mask: BigDigit = (1 << bits) - 1;
                    let digits_per_big_digit = big_digit::BITS / bits;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    for mut r in u.data[..last_i].iter().cloned() {
                        for _ in 0..digits_per_big_digit {
                            res.push((r & mask) as u8);
                            r >>= bits;
                        }
                    }

                    let mut r = u.data[last_i];
                    while r != 0 {
                        res.push((r & mask) as u8);
                        r >>= bits;
                    }

                    res
                }

                // Extract bitwise digits that don't evenly divide BigDigit
                fn to_inexact_bitwise_digits_le(u: &BigUint, bits: u8) -> Vec<u8> 
                {
                    debug_assert!(!u.is_zero() && bits <= 8 && big_digit::BITS % bits != 0);

                    let mask: BigDigit = (1 << bits) - 1;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    let mut r = 0;
                    let mut rbits = 0;

                    for c in &u.data {
                        r |= *c << rbits;
                        rbits += big_digit::BITS;

                        while rbits >= bits {
                            res.push((r & mask) as u8);
                            r >>= bits;

                            // r had more bits than it could fit - grab the bits we lost
                            if rbits > big_digit::BITS {
                                r = *c >> (big_digit::BITS - (rbits - bits));
                            }

                            rbits -= bits;
                        }
                    }

                    if rbits != 0 {
                        res.push(r as u8);
                    }

                    while let Some(&0) = res.last() {
                        res.pop();
                    }

                    res
                }

                // Extract little-endian radix digits
                #[inline(always)] // forced inline to get const-prop for radix=10
                pub fn to_radix_digits_le(u: &BigUint, radix: u32) -> Vec<u8> 
                {
                    debug_assert!(!u.is_zero() && !radix.is_power_of_two());

                    let radix_digits = {
                        let radix_log2 = f64::from(radix).log2();
                        ((u.bits() as f64) / radix_log2).ceil()
                    };

                    // Estimate how big the result will be, so we can pre-allocate it.
                    let mut res = Vec::with_capacity(radix_digits.to_usize().unwrap_or(0));

                    let mut digits = u.clone();

                    // X86 DIV can quickly divide by a full digit, otherwise we choose a divisor
                    // that's suitable for `div_half` to avoid slow `DoubleBigDigit` division.
                    let (base, power) = if FAST_DIV_WIDE {
                        get_radix_base(radix)
                    } else {
                        get_half_radix_base(radix)
                    };
                    let radix = radix as BigDigit;

                    // For very large numbers, the O(n²) loop of repeated `div_rem_digit` dominates the
                    // performance. We can mitigate this by dividing into chunks of a larger base first.
                    // The threshold for this was chosen by anecdotal performance measurements to
                    // approximate where this starts to make a noticeable difference.
                    if digits.data.len() >= 64 {
                        let mut big_base = BigUint::from(base);
                        let mut big_power = 1usize;

                        // Choose a target base length near √n.
                        let target_len = digits.data.len().sqrt();
                        while big_base.data.len() < target_len {
                            big_base = &big_base * &big_base;
                            big_power *= 2;
                        }

                        // This outer loop will run approximately √n times.
                        while digits > big_base {
                            // This is still the dominating factor, with n digits divided by √n digits.
                            let (q, mut big_r) = digits.div_rem(&big_base);
                            digits = q;

                            // This inner loop now has O(√n²)=O(n) behavior altogether.
                            for _ in 0..big_power {
                                let (q, mut r) = div_rem_digit(big_r, base);
                                big_r = q;
                                for _ in 0..power {
                                    res.push((r % radix) as u8);
                                    r /= radix;
                                }
                            }
                        }
                    }

                    while digits.data.len() > 1 {
                        let (q, mut r) = div_rem_digit(digits, base);
                        for _ in 0..power {
                            res.push((r % radix) as u8);
                            r /= radix;
                        }
                        digits = q;
                    }

                    let mut r = digits.data[0];
                    while r != 0 {
                        res.push((r % radix) as u8);
                        r /= radix;
                    }

                    res
                }

                pub fn to_radix_le(u: &BigUint, radix: u32) -> Vec<u8> 
                {
                    if u.is_zero() {
                        vec![0]
                    } else if radix.is_power_of_two() {
                        // Powers of two can use bitwise masks and shifting instead of division
                        let bits = ilog2(radix);
                        if big_digit::BITS % bits == 0 {
                            to_bitwise_digits_le(u, bits)
                        } else {
                            to_inexact_bitwise_digits_le(u, bits)
                        }
                    } else if radix == 10 {
                        // 10 is so common that it's worth separating out for const-propagation.
                        // Optimizers can often turn constant division into a faster multiplication.
                        to_radix_digits_le(u, 10)
                    } else {
                        to_radix_digits_le(u, radix)
                    }
                }

                pub fn to_str_radix_reversed(u: &BigUint, radix: u32) -> Vec<u8> 
                {
                    assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");

                    if u.is_zero() {
                        return vec![b'0'];
                    }

                    let mut res = to_radix_le(u, radix);

                    // Now convert everything to ASCII digits.
                    for r in &mut res {
                        debug_assert!(u32::from(*r) < radix);
                        if *r < 10 {
                            *r += b'0';
                        } else {
                            *r += b'a' - 10;
                        }
                    }
                    res
                }
                /// Returns the greatest power of the radix for the `BigDigit` bit size
                #[inline] fn get_radix_base(radix: u32) -> (BigDigit, usize) 
                {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(big_digit::MAX);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }
                /// Returns the greatest power of the radix for half the `BigDigit` bit size
                #[inline] fn get_half_radix_base(radix: u32) -> (BigDigit, usize) 
                {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(big_digit::HALF);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }
                /// Generate tables of the greatest power of each radix that is less that the given maximum.
                const fn generate_radix_bases(max: BigDigit) -> [(BigDigit, usize); 257] 
                {
                    let mut bases = [(0, 0); 257];

                    let mut radix: BigDigit = 3;
                    while radix < 256 {
                        if !radix.is_power_of_two() {
                            let mut power = 1;
                            let mut base = radix;

                            while let Some(b) = base.checked_mul(radix) {
                                if b > max {
                                    break;
                                }
                                base = b;
                                power += 1;
                            }
                            bases[radix as usize] = (base, power)
                        }
                        radix += 1;
                    }

                    bases
                }
            }

            pub mod iter
            {
                use ::
                {
                    iter::{ FusedIterator },
                    num::
                    {
                        big::
                        {
                            big_digit::{},
                            biguint::{}
                        },
                        traits::{},
                    },
                    *,
                };
                /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                /// ordered least significant digit first.
                pub struct U32Digits<'a> 
                {
                    data: &'a [u64],
                    next_is_lo: bool,
                    last_hi_is_zero: bool,
                }                
                
                impl<'a> U32Digits<'a> {
                    #[inline]
                    pub fn new(data: &'a [u64]) -> Self {
                        let last_hi_is_zero = data
                            .last()
                            .map(|&last| {
                                let last_hi = (last >> 32) as u32;
                                last_hi == 0
                            })
                            .unwrap_or(false);
                        U32Digits {
                            data,
                            next_is_lo: true,
                            last_hi_is_zero,
                        }
                    }
                }

                impl Iterator for U32Digits<'_> {
                    type Item = u32;
                    #[inline] fn next(&mut self) -> Option<u32> {
                        match self.data.split_first() {
                            Some((&first, data)) => {
                                let next_is_lo = self.next_is_lo;
                                self.next_is_lo = !next_is_lo;
                                if next_is_lo {
                                    Some(first as u32)
                                } else {
                                    self.data = data;
                                    if data.is_empty() && self.last_hi_is_zero {
                                        self.last_hi_is_zero = false;
                                        None
                                    } else {
                                        Some((first >> 32) as u32)
                                    }
                                }
                            }
                            None => None,
                        }
                    }

                    #[inline] fn size_hint(&self) -> (usize, Option<usize>) 
                    {
                        let len = self.len();
                        (len, Some(len))
                    }

                    #[inline] fn last(self) -> Option<u32> {
                        self.data.last().map(|&last| {
                            if self.last_hi_is_zero {
                                last as u32
                            } else {
                                (last >> 32) as u32
                            }
                        })
                    }

                    #[inline] fn count(self) -> usize {
                        self.len()
                    }
                }

                impl DoubleEndedIterator for U32Digits<'_>
                {
                    fn next_back(&mut self) -> Option<Self::Item> {
                        match self.data.split_last() {
                            Some((&last, data)) => {
                                let last_is_lo = self.last_hi_is_zero;
                                self.last_hi_is_zero = !last_is_lo;
                                if last_is_lo {
                                    self.data = data;
                                    if data.is_empty() && !self.next_is_lo {
                                        self.next_is_lo = true;
                                        None
                                    } else {
                                        Some(last as u32)
                                    }
                                } else {
                                    Some((last >> 32) as u32)
                                }
                            }
                            None => None,
                        }
                    }
                }

                impl ExactSizeIterator for U32Digits<'_> {
                    #[inline] fn len(&self) -> usize {
                        self.data.len() * 2
                            - usize::from(self.last_hi_is_zero)
                            - usize::from(!self.next_is_lo)
                    }
                }

                impl FusedIterator for U32Digits<'_> {}

                cfg_digit!(
                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: ::slice::Chunks<'a, u32>,
                    }

                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: ::slice::Iter<'a, u64>,
                    }
                );

                
                impl<'a> U64Digits<'a> {
                    #[inline]
                    pub fn new(data: &'a [u64]) -> Self {
                        Self { it: data.iter() }
                    }
                }

                impl Iterator for U64Digits<'_> {
                    type Item = u64;
                    #[inline] fn next(&mut self) -> Option<u64> {
                        self.it.next().cloned()
                    }

                    #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                        self.it.size_hint()
                    }

                    #[inline] fn nth(&mut self, n: usize) -> Option<u64> {
                        self.it.nth(n).cloned()
                    }

                    #[inline] fn last(self) -> Option<u64> {
                        self.it.last().cloned()
                    }

                    #[inline] fn count(self) -> usize {
                        self.it.count()
                    }
                }

                impl DoubleEndedIterator for U64Digits<'_>
                {
                    fn next_back(&mut self) -> Option<Self::Item> {
                        self.it.next_back().cloned()
                    }
                }

                impl ExactSizeIterator for U64Digits<'_> {
                    #[inline] fn len(&self) -> usize {
                        self.it.len()
                    }
                }

                impl FusedIterator for U64Digits<'_> {}
            }

            pub mod monty
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit, DoubleBigDigit },
                            biguint::{ BigUint },
                        },
                        traits::{ One },
                    },
                    ops::{ Shl },
                    vec::{ Vec },
                    *,
                };
                
                struct MontyReducer 
                {
                    n0inv: BigDigit,
                }

                // k0 = -m**-1 mod 2**BITS.
                fn inv_mod_alt(b: BigDigit) -> BigDigit 
                {
                    assert_ne!(b & 1, 0);

                    let mut k0 = BigDigit::wrapping_sub(2, b);
                    let mut t = b - 1;
                    let mut i = 1;
                    while i < big_digit::BITS {
                        t = t.wrapping_mul(t);
                        k0 = k0.wrapping_mul(t + 1);

                        i <<= 1;
                    }
                    debug_assert_eq!(k0.wrapping_mul(b), 1);
                    k0.wrapping_neg()
                }

                impl MontyReducer 
                {
                    fn new(n: &BigUint) -> Self {
                        let n0inv = inv_mod_alt(n.data[0]);
                        MontyReducer { n0inv }
                    }
                }
                /// Computes z mod m = x * y * 2 ** (-n*_W) mod m, assuming k = -1/m mod 2**_W
                fn montgomery(x: &BigUint, y: &BigUint, m: &BigUint, k: BigDigit, n: usize) -> BigUint 
                {
                    // This code assumes x, y, m are all the same length, n.
                    // (required by addMulVVW and the for loop).
                    // It also assumes that x, y are already reduced mod m,
                    // or else the result will not be properly reduced.
                    assert!(
                        x.data.len() == n && y.data.len() == n && m.data.len() == n,
                        "{:?} {:?} {:?} {}",
                        x,
                        y,
                        m,
                        n
                    );

                    let mut z = BigUint::ZERO;
                    z.data.resize(n * 2, 0);

                    let mut c: BigDigit = 0;
                    for i in 0..n {
                        let c2 = add_mul_vvw(&mut z.data[i..n + i], &x.data, y.data[i]);
                        let t = z.data[i].wrapping_mul(k);
                        let c3 = add_mul_vvw(&mut z.data[i..n + i], &m.data, t);
                        let cx = c.wrapping_add(c2);
                        let cy = cx.wrapping_add(c3);
                        z.data[n + i] = cy;
                        if cx < c2 || cy < c3 {
                            c = 1;
                        } else {
                            c = 0;
                        }
                    }

                    if c == 0 {
                        z.data = z.data[n..].to_vec();
                    } else {
                        {
                            let (first, second) = z.data.split_at_mut(n);
                            sub_vv(first, second, &m.data);
                        }
                        z.data = z.data[..n].to_vec();
                    }

                    z
                }

                #[inline( always )] fn add_mul_vvw(z: &mut [BigDigit], x: &[BigDigit], y: BigDigit) -> BigDigit 
                {
                    let mut c = 0;
                    for (zi, xi) in z.iter_mut().zip(x.iter()) 
                    {
                        let (z1, z0) = mul_add_www(*xi, y, *zi);
                        let (c_, zi_) = add_ww(z0, c, 0);
                        *zi = zi_;
                        c = c_ + z1;
                    }

                    c
                }
                /// The resulting carry c is either 0 or 1.
                #[inline( always )] fn sub_vv(z: &mut [BigDigit], x: &[BigDigit], y: &[BigDigit]) -> BigDigit 
                {
                    let mut c = 0;
                    for (i, (xi, yi)) in x.iter().zip(y.iter()).enumerate().take(z.len()) 
                    {
                        let zi = xi.wrapping_sub(*yi).wrapping_sub(c);
                        z[i] = zi;
                        // see "Hacker's Delight", section 2-12 (overflow detection)
                        c = ((yi & !xi) | ((yi | !xi) & zi)) >> (big_digit::BITS - 1)
                    }

                    c
                }
                /// z1<<_W + z0 = x+y+c, with c == 0 or 1
                #[inline( always )] fn add_ww(x: BigDigit, y: BigDigit, c: BigDigit) -> (BigDigit, BigDigit) 
                {
                    let yc = y.wrapping_add(c);
                    let z0 = x.wrapping_add(yc);
                    let z1 = if z0 < x || yc < y { 1 } else { 0 };

                    (z1, z0)
                }
                /// z1 << _W + z0 = x * y + c
                #[inline( always )] fn mul_add_www(x: BigDigit, y: BigDigit, c: BigDigit) -> (BigDigit, BigDigit) 
                {
                    let z = x as DoubleBigDigit * y as DoubleBigDigit + c as DoubleBigDigit;
                    ((z >> big_digit::BITS) as BigDigit, z as BigDigit)
                }
                /// Calculates x ** y mod m using a fixed, 4-bit window.
                #[allow(clippy::many_single_char_names)]
                pub fn monty_modpow(x: &BigUint, y: &BigUint, m: &BigUint) -> BigUint 
                {
                    assert!(m.data[0] & 1 == 1);
                    let mr = MontyReducer::new(m);
                    let num_words = m.data.len();

                    let mut x = x.clone();

                    // We want the lengths of x and m to be equal.
                    // It is OK if x >= m as long as len(x) == len(m).
                    if x.data.len() > num_words {
                        x %= m;
                        // Note: now len(x) <= numWords, not guaranteed ==.
                    }
                    if x.data.len() < num_words {
                        x.data.resize(num_words, 0);
                    }

                    // rr = 2**(2*_W*len(m)) mod m
                    let mut rr = BigUint::one();
                    rr = (rr.shl(2 * num_words as u64 * u64::from(big_digit::BITS))) % m;
                    if rr.data.len() < num_words {
                        rr.data.resize(num_words, 0);
                    }
                    // one = 1, with equal length to that of m
                    let mut one = BigUint::one();
                    one.data.resize(num_words, 0);

                    let n = 4;
                    // powers[i] contains x^i
                    let mut powers = Vec::with_capacity(1 << n);
                    powers.push(montgomery(&one, &rr, m, mr.n0inv, num_words));
                    powers.push(montgomery(&x, &rr, m, mr.n0inv, num_words));
                    for i in 2..1 << n {
                        let r = montgomery(&powers[i - 1], &powers[1], m, mr.n0inv, num_words);
                        powers.push(r);
                    }

                    // initialize z = 1 (Montgomery 1)
                    let mut z = powers[0].clone();
                    z.data.resize(num_words, 0);
                    let mut zz = BigUint::ZERO;
                    zz.data.resize(num_words, 0);

                    // same windowed exponent, but with Montgomery multiplications
                    for i in (0..y.data.len()).rev() 
                    {
                        let mut yi = y.data[i];
                        let mut j = 0;
                        while j < big_digit::BITS {
                            if i != y.data.len() - 1 || j != 0 {
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                            }
                            zz = montgomery(
                                &z,
                                &powers[(yi >> (big_digit::BITS - n)) as usize],
                                m,
                                mr.n0inv,
                                num_words,
                            );
                            mem::swap(&mut z, &mut zz);
                            yi <<= n;
                            j += n;
                        }
                    }

                    // convert to regular number
                    zz = montgomery(&z, &one, m, mr.n0inv, num_words);

                    zz.normalize();
                    // One last reduction, just in case.
                    // See golang.org/issue/13907.
                    if zz >= *m {
                        // Common case is m has high bit set; in that case,
                        // since zz is the same length as m, there can be just
                        // one multiple of m to remove. Just subtract.
                        // We think that the subtract should be sufficient in general,
                        // so do that unconditionally, but double-check,
                        // in case our beliefs are wrong.
                        // The div is not expected to be reached.
                        zz -= m;
                        if zz >= *m {
                            zz %= m;
                        }
                    }

                    zz.normalize();
                    zz
                }
            }

            pub mod power
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit },
                            biguint::
                            {
                                monty::{ monty_modpow },
                                BigUint,
                            },
                        },
                        integers::{ Integer },
                        traits::{ One, Pow, ToPrimitive, Zero },
                    },
                    *,
                };
                
                impl Pow<&BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: &BigUint) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            Self::ZERO
                        } else if let Some(exp) = exp.to_u64() {
                            self.pow(exp)
                        } else if let Some(exp) = exp.to_u128() {
                            self.pow(exp)
                        } else {
                            // At this point, `self >= 2` and `exp >= 2¹²⁸`. The smallest possible result given
                            // `2.pow(2¹²⁸)` would require far more memory than 64-bit targets can address!
                            panic!("memory overflow")
                        }
                    }
                }

                impl Pow<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: BigUint) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                impl Pow<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: &BigUint) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            BigUint::ZERO
                        } else {
                            self.clone().pow(exp)
                        }
                    }
                }

                impl Pow<BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: BigUint) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                macro_rules! pow_impl {
                    ($T:ty) => {
                        impl Pow<$T> for BigUint {
                            type Output = BigUint;

                            fn pow(self, mut exp: $T) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                let mut base = self;

                                while exp & 1 == 0 {
                                    base = &base * &base;
                                    exp >>= 1;
                                }

                                if exp == 1 {
                                    return base;
                                }

                                let mut acc = base.clone();
                                while exp > 1 {
                                    exp >>= 1;
                                    base = &base * &base;
                                    if exp & 1 == 1 {
                                        acc *= &base;
                                    }
                                }
                                acc
                            }
                        }

                        impl Pow<&$T> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }

                        impl Pow<$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: $T) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                Pow::pow(self.clone(), exp)
                            }
                        }

                        impl Pow<&$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }
                    };
                }

                pow_impl!(u8);
                pow_impl!(u16);
                pow_impl!(u32);
                pow_impl!(u64);
                pow_impl!(usize);
                pow_impl!(u128);

                pub fn modpow(x: &BigUint, exponent: &BigUint, modulus: &BigUint) -> BigUint {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    if modulus.is_odd() {
                        // For an odd modulus, we can use Montgomery multiplication in base 2^32.
                        monty_modpow(x, exponent, modulus)
                    } else {
                        // Otherwise do basically the same as `num::pow`, but with a modulus.
                        plain_modpow(x, &exponent.data, modulus)
                    }
                }

                fn plain_modpow(base: &BigUint, exp_data: &[BigDigit], modulus: &BigUint) -> BigUint {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    let i = match exp_data.iter().position(|&r| r != 0) {
                        None => return BigUint::one(),
                        Some(i) => i,
                    };

                    let mut base = base % modulus;
                    for _ in 0..i {
                        for _ in 0..big_digit::BITS {
                            base = &base * &base % modulus;
                        }
                    }

                    let mut r = exp_data[i];
                    let mut b = 0u8;
                    while r.is_even() {
                        base = &base * &base % modulus;
                        r >>= 1;
                        b += 1;
                    }

                    let mut exp_iter = exp_data[i + 1..].iter();
                    if exp_iter.len() == 0 && r.is_one() {
                        return base;
                    }

                    let mut acc = base.clone();
                    r >>= 1;
                    b += 1;

                    {
                        let mut unit = |exp_is_odd| {
                            base = &base * &base % modulus;
                            if exp_is_odd {
                                acc *= &base;
                                acc %= modulus;
                            }
                        };

                        if let Some(&last) = exp_iter.next_back() {
                            // consume exp_data[i]
                            for _ in b..big_digit::BITS {
                                unit(r.is_odd());
                                r >>= 1;
                            }

                            // consume all other digits before the last
                            for &r in exp_iter {
                                let mut r = r;
                                for _ in 0..big_digit::BITS {
                                    unit(r.is_odd());
                                    r >>= 1;
                                }
                            }
                            r = last;
                        }

                        debug_assert_ne!(r, 0);
                        while !r.is_zero() {
                            unit(r.is_odd());
                            r >>= 1;
                        }
                    }
                    acc
                }
            }

            pub mod shift
            {
                use ::
                {
                    borrow::{ Cow },
                    num::
                    {
                        big::
                        {
                            big_digit::{ self },
                            biguint::{ biguint_from_vec, BigUint },
                        },
                        traits::{ PrimInt, Zero },
                    },
                    ops::{ Shl, ShlAssign, Shr, ShrAssign },
                    vec::{ Vec },
                    *,
                };

                #[inline] fn biguint_shl<T: PrimInt>(n: Cow<'_, BigUint>, shift: T) -> BigUint {
                    if shift < T::zero() {
                        panic!("attempt to shift left with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(big_digit::BITS).unwrap();
                    let digits = (shift / bits).to_usize().expect("capacity overflow");
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shl2(n, digits, shift)
                }

                fn biguint_shl2(n: Cow<'_, BigUint>, digits: usize, shift: u8) -> BigUint {
                    let mut data = match digits {
                        0 => n.into_owned().data,
                        _ => {
                            let len = digits.saturating_add(n.data.len() + 1);
                            let mut data = Vec::with_capacity(len);
                            data.resize(digits, 0);
                            data.extend(n.data.iter());
                            data
                        }
                    };

                    if shift > 0 {
                        let mut carry = 0;
                        let carry_shift = big_digit::BITS - shift;
                        for elem in data[digits..].iter_mut() {
                            let new_carry = *elem >> carry_shift;
                            *elem = (*elem << shift) | carry;
                            carry = new_carry;
                        }
                        if carry != 0 {
                            data.push(carry);
                        }
                    }

                    biguint_from_vec(data)
                }

                #[inline] fn biguint_shr<T: PrimInt>(n: Cow<'_, BigUint>, shift: T) -> BigUint {
                    if shift < T::zero() {
                        panic!("attempt to shift right with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(big_digit::BITS).unwrap();
                    let digits = (shift / bits).to_usize().unwrap_or(usize::MAX);
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shr2(n, digits, shift)
                }

                fn biguint_shr2(n: Cow<'_, BigUint>, digits: usize, shift: u8) -> BigUint {
                    if digits >= n.data.len() 
                    {
                        let mut n = n.into_owned();
                        n.set_zero();
                        return n;
                    }
                    let mut data = match n {
                        Cow::Borrowed(n) => n.data[digits..].to_vec(),
                        Cow::Owned(mut n) => {
                            n.data.drain(..digits);
                            n.data
                        }
                    };

                    if shift > 0 {
                        let mut borrow = 0;
                        let borrow_shift = big_digit::BITS - shift;
                        for elem in data.iter_mut().rev() {
                            let new_borrow = *elem << borrow_shift;
                            *elem = (*elem >> shift) | borrow;
                            borrow = new_borrow;
                        }
                    }

                    biguint_from_vec(data)
                }

                macro_rules! impl_shift {
                    (@ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty) => {
                        impl $Shx<&$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $Shx<&$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigUint {
                            #[inline]
                            fn $shx_assign(&mut self, rhs: &$rhs) {
                                $ShxAssign::$shx_assign(self, *rhs);
                            }
                        }
                    };
                    ($($rhs:ty),+) => {$(
                        impl Shl<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigUint {
                                biguint_shl(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shl<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigUint {
                                biguint_shl(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShlAssign<$rhs> for BigUint {
                            #[inline]
                            fn shl_assign(&mut self, rhs: $rhs) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n << rhs;
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }

                        impl Shr<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigUint {
                                biguint_shr(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shr<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigUint {
                                biguint_shr(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShrAssign<$rhs> for BigUint {
                            #[inline]
                            fn shr_assign(&mut self, rhs: $rhs) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n >> rhs;
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }

                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }
            }

            pub use self::convert::to_str_radix_reversed;
            pub use self::iter::{U32Digits, U64Digits};
            /// A big unsigned integer type.
            pub struct BigUint
            {
                data: Vec<BigDigit>,
            }
            
            impl Clone for BigUint {
                #[inline] fn clone(&self) -> Self {
                    BigUint {
                        data: self.data.clone(),
                    }
                }

                #[inline] fn clone_from(&mut self, other: &Self) {
                    self.data.clone_from(&other.data);
                }
            }

            impl hash::Hash for BigUint {
                #[inline] fn hash<H: hash::Hasher>(&self, state: &mut H) {
                    debug_assert!(self.data.last() != Some(&0));
                    self.data.hash(state);
                }
            }

            impl PartialEq for BigUint {
                #[inline] fn eq(&self, other: &BigUint) -> bool {
                    debug_assert!(self.data.last() != Some(&0));
                    debug_assert!(other.data.last() != Some(&0));
                    self.data == other.data
                }
            }
            impl Eq for BigUint {}

            impl PartialOrd for BigUint {
                #[inline] fn partial_cmp(&self, other: &BigUint) -> Option<Ordering> {
                    Some(self.cmp(other))
                }
            }

            impl Ord for BigUint {
                #[inline] fn cmp(&self, other: &BigUint) -> Ordering {
                    cmp_slice(&self.data[..], &other.data[..])
                }
            }

            #[inline] fn cmp_slice(a: &[BigDigit], b: &[BigDigit]) -> Ordering {
                debug_assert!(a.last() != Some(&0));
                debug_assert!(b.last() != Some(&0));

                match Ord::cmp(&a.len(), &b.len()) {
                    Ordering::Equal => Iterator::cmp(a.iter().rev(), b.iter().rev()),
                    other => other,
                }
            }

            impl Default for BigUint {
                #[inline] fn default() -> BigUint {
                    Self::ZERO
                }
            }

            impl fmt::Debug for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Display::fmt(self, f)
                }
            }

            impl fmt::Display for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(true, "", &self.to_str_radix(10))
                }
            }

            impl fmt::LowerHex for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(true, "0x", &self.to_str_radix(16))
                }
            }

            impl fmt::UpperHex for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let mut s = self.to_str_radix(16);
                    s.make_ascii_uppercase();
                    f.pad_integral(true, "0x", &s)
                }
            }

            impl fmt::Binary for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(true, "0b", &self.to_str_radix(2))
                }
            }

            impl fmt::Octal for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(true, "0o", &self.to_str_radix(8))
                }
            }

            impl Zero for BigUint {
                #[inline] fn zero() -> BigUint {
                    Self::ZERO
                }

                #[inline] fn set_zero(&mut self) {
                    self.data.clear();
                }

                #[inline] fn is_zero(&self) -> bool {
                    self.data.is_empty()
                }
            }

            impl ConstZero for BigUint {
                // forward to the inherent const
                const ZERO: Self = Self::ZERO; // BigUint { data: Vec::new() };
            }

            impl One for BigUint {
                #[inline] fn one() -> BigUint {
                    BigUint { data: vec![1] }
                }

                #[inline] fn set_one(&mut self) {
                    self.data.clear();
                    self.data.push(1);
                }

                #[inline] fn is_one(&self) -> bool {
                    self.data[..] == [1]
                }
            }

            impl Unsigned for BigUint {}

            impl Integer for BigUint {
                #[inline] fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {
                    division::div_rem_ref(self, other)
                }

                #[inline] fn div_floor(&self, other: &BigUint) -> BigUint {
                    let (d, _) = division::div_rem_ref(self, other);
                    d
                }

                #[inline] fn mod_floor(&self, other: &BigUint) -> BigUint {
                    let (_, m) = division::div_rem_ref(self, other);
                    m
                }

                #[inline] fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {
                    division::div_rem_ref(self, other)
                }

                #[inline] fn div_ceil(&self, other: &BigUint) -> BigUint {
                    let (d, m) = division::div_rem_ref(self, other);
                    if m.is_zero() {
                        d
                    } else {
                        d + 1u32
                    }
                }
                /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.
                ///
                /// The result is always positive.
                #[inline] fn gcd(&self, other: &Self) -> Self {
                    #[inline] fn twos(x: &BigUint) -> u64 {
                        x.trailing_zeros().unwrap_or(0)
                    }

                    // Stein's algorithm
                    if self.is_zero() {
                        return other.clone();
                    }
                    if other.is_zero() {
                        return self.clone();
                    }
                    let mut m = self.clone();
                    let mut n = other.clone();

                    // find common factors of 2
                    let shift = cmp::min(twos(&n), twos(&m));

                    // divide m and n by 2 until odd
                    // m inside loop
                    n >>= twos(&n);

                    while !m.is_zero() {
                        m >>= twos(&m);
                        if n > m {
                            mem::swap(&mut n, &mut m)
                        }
                        m -= &n;
                    }

                    n << shift
                }
                /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                #[inline] fn lcm(&self, other: &BigUint) -> BigUint {
                    if self.is_zero() && other.is_zero() {
                        Self::ZERO
                    } else {
                        self / self.gcd(other) * other
                    }
                }
                /// Calculates the Greatest Common Divisor (GCD) and
                /// Lowest Common Multiple (LCM) together.
                #[inline] fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                    let gcd = self.gcd(other);
                    let lcm = if gcd.is_zero() {
                        Self::ZERO
                    } else {
                        self / &gcd * other
                    };
                    (gcd, lcm)
                }
                /// Deprecated, use `is_multiple_of` instead.
                #[inline] fn divides(&self, other: &BigUint) -> bool {
                    self.is_multiple_of(other)
                }
                /// Returns `true` if the number is a multiple of `other`.
                #[inline] fn is_multiple_of(&self, other: &BigUint) -> bool {
                    if other.is_zero() {
                        return self.is_zero();
                    }
                    (self % other).is_zero()
                }
                /// Returns `true` if the number is divisible by `2`.
                #[inline] fn is_even(&self) -> bool {
                    // Considering only the last digit.
                    match self.data.first() {
                        Some(x) => x.is_even(),
                        None => true,
                    }
                }
                /// Returns `true` if the number is not divisible by `2`.
                #[inline] fn is_odd(&self) -> bool {
                    !self.is_even()
                }
                /// Rounds up to nearest multiple of argument.
                #[inline] fn next_multiple_of(&self, other: &Self) -> Self {
                    let m = self.mod_floor(other);
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + (other - m)
                    }
                }
                /// Rounds down to nearest multiple of argument.
                #[inline] fn prev_multiple_of(&self, other: &Self) -> Self {
                    self - self.mod_floor(other)
                }

                fn dec(&mut self) {
                    *self -= 1u32;
                }

                fn inc(&mut self) {
                    *self += 1u32;
                }
            }

            #[inline] fn fixpoint<F>(mut x: BigUint, max_bits: u64, f: F) -> BigUint
            where
                F: Fn(&BigUint) -> BigUint,
            {
                let mut xn = f(&x);

                // If the value increased, then the initial guess must have been low.
                // Repeat until we reverse course.
                while x < xn {
                    // Sometimes an increase will go way too far, especially with large
                    // powers, and then take a long time to walk back.  We know an upper
                    // bound based on bit size, so saturate on that.
                    x = if xn.bits() > max_bits {
                        BigUint::one() << max_bits
                    } else {
                        xn
                    };
                    xn = f(&x);
                }

                // Now keep repeating while the estimate is decreasing.
                while x > xn {
                    x = xn;
                    xn = f(&x);
                }
                x
            }

            impl Roots for BigUint {
                // nth_root, sqrt and cbrt use Newton's method to compute
                // principal root of a given degree for a given integer.

                // Reference:
                // Brent & Zimmermann, Modern Computer Arithmetic, v0.5.9, Algorithm 1.14
                fn nth_root(&self, n: u32) -> Self {
                    assert!(n > 0, "root degree n must be at least 1");

                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }

                    match n {
                        // Optimize for small n
                        1 => return self.clone(),
                        2 => return self.sqrt(),
                        3 => return self.cbrt(),
                        _ => (),
                    }

                    // The root of non-zero values less than 2ⁿ can only be 1.
                    let bits = self.bits();
                    let n64 = u64::from(n);
                    if bits <= n64 {
                        return BigUint::one();
                    }

                    // If we fit in `u64`, compute the root that way.
                    if let Some(x) = self.to_u64() {
                        return x.nth_root(n).into();
                    }

                    let max_bits = bits / n64 + 1;
                    
                    let guess = match self.to_f64() {
                        Some(f) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;

                            // We fit in `f64` (lossy), so get a better initial guess from that.
                            BigUint::from_f64((f.ln() / f64::from(n)).exp()).unwrap()
                        }
                        _ => {
                            // Try to guess by scaling down such that it does fit in `f64`.
                            // With some (x * 2ⁿᵏ), its nth root ≈ (ⁿ√x * 2ᵏ)
                            let extra_bits = bits - (f64::MAX_EXP as u64 - 1);
                            let root_scale = Integer::div_ceil(&extra_bits, &n64);
                            let scale = root_scale * n64;
                            if scale < bits && bits - scale > n64 {
                                (self >> scale).nth_root(n) << root_scale
                            } else {
                                BigUint::one() << max_bits
                            }
                        }
                    };

                    let n_min_1 = n - 1;
                    fixpoint(guess, max_bits, move |s| {
                        let q = self / s.pow(n_min_1);
                        let t = n_min_1 * s + q;
                        t / n
                    })
                }

                // Reference:
                // Brent & Zimmermann, Modern Computer Arithmetic, v0.5.9, Algorithm 1.13
                fn sqrt(&self) -> Self {
                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }

                    // If we fit in `u64`, compute the root that way.
                    if let Some(x) = self.to_u64() {
                        return x.sqrt().into();
                    }

                    let bits = self.bits();
                    let max_bits = bits / 2 + 1;                    
                    let guess = match self.to_f64() {
                        Some(f) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;

                            // We fit in `f64` (lossy), so get a better initial guess from that.
                            BigUint::from_f64(f.sqrt()).unwrap()
                        }
                        _ => {
                            // Try to guess by scaling down such that it does fit in `f64`.
                            // With some (x * 2²ᵏ), its sqrt ≈ (√x * 2ᵏ)
                            let extra_bits = bits - (f64::MAX_EXP as u64 - 1);
                            let root_scale = (extra_bits + 1) / 2;
                            let scale = root_scale * 2;
                            (self >> scale).sqrt() << root_scale
                        }
                    };

                    fixpoint(guess, max_bits, move |s| {
                        let q = self / s;
                        let t = s + q;
                        t >> 1
                    })
                }

                fn cbrt(&self) -> Self {
                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }

                    // If we fit in `u64`, compute the root that way.
                    if let Some(x) = self.to_u64() {
                        return x.cbrt().into();
                    }

                    let bits = self.bits();
                    let max_bits = bits / 3 + 1;
                    
                    let guess = match self.to_f64() {
                        Some(f) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;

                            // We fit in `f64` (lossy), so get a better initial guess from that.
                            BigUint::from_f64(f.cbrt()).unwrap()
                        }
                        _ => {
                            // Try to guess by scaling down such that it does fit in `f64`.
                            // With some (x * 2³ᵏ), its cbrt ≈ (∛x * 2ᵏ)
                            let extra_bits = bits - (f64::MAX_EXP as u64 - 1);
                            let root_scale = (extra_bits + 2) / 3;
                            let scale = root_scale * 3;
                            (self >> scale).cbrt() << root_scale
                        }
                    };
                    
                    fixpoint(guess, max_bits, move |s| {
                        let q = self / (s * s);
                        let t = (s << 1) + q;
                        t / 3u32
                    })
                }
            }
            /// A generic trait for converting a value to a [`BigUint`].
            pub trait ToBigUint {
                /// Converts the value of `self` to a [`BigUint`].
                fn to_biguint(&self) -> Option<BigUint>;
            }
            /// Creates and initializes a [`BigUint`].
            #[inline] pub fn biguint_from_vec(digits: Vec<BigDigit>) -> BigUint {
                BigUint { data: digits }.normalized()
            }

            impl BigUint 
            {
                /// A constant `BigUint` with value 0, useful for static initialization.
                pub const ZERO: Self = BigUint { data: Vec::new() };
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn new(digits: Vec<u32>) -> BigUint {
                    let mut big = Self::ZERO;

                    cfg_digit_expr!(
                        {
                            big.data = digits;
                            big.normalize();
                        },
                        big.assign_from_slice(&digits)
                    );

                    big
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_slice(slice: &[u32]) -> BigUint {
                    let mut big = Self::ZERO;
                    big.assign_from_slice(slice);
                    big
                }
                /// Assign a value to a [`BigUint`].
                #[inline] pub fn assign_from_slice(&mut self, slice: &[u32]) {
                    self.data.clear();

                    cfg_digit_expr!(
                        self.data.extend_from_slice(slice),
                        self.data.extend(slice.chunks(2).map(u32_chunk_to_u64))
                    );

                    self.normalize();
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_bytes_be(bytes: &[u8]) -> BigUint {
                    if bytes.is_empty() {
                        Self::ZERO
                    } else {
                        let mut v = bytes.to_vec();
                        v.reverse();
                        BigUint::from_bytes_le(&v)
                    }
                }
                /// Creates and initializes a [`BigUint`].
                ///
                /// The bytes are in little-endian byte order.
                #[inline] pub fn from_bytes_le(bytes: &[u8]) -> BigUint {
                    if bytes.is_empty() {
                        Self::ZERO
                    } else {
                        convert::from_bitwise_digits_le(bytes, 8)
                    }
                }
                /// Creates and initializes a [`BigUint`]
                #[inline] pub fn parse_bytes(buf: &[u8], radix: u32) -> Option<BigUint> {
                    let s = str::from_utf8(buf).ok()?;
                    BigUint::from_str_radix(s, radix).ok()
                }
                /// Creates and initializes a [`BigUint`].
                pub fn from_radix_be(buf: &[u8], radix: u32) -> Option<BigUint> {
                    convert::from_radix_be(buf, radix)
                }
                /// Creates and initializes a [`BigUint`].
                pub fn from_radix_le(buf: &[u8], radix: u32) -> Option<BigUint> {
                    convert::from_radix_le(buf, radix)
                }
                /// Returns the byte representation of the [`BigUint`] in big-endian byte order.
                #[inline] pub fn to_bytes_be(&self) -> Vec<u8> {
                    let mut v = self.to_bytes_le();
                    v.reverse();
                    v
                }
                /// Returns the byte representation of the [`BigUint`] in little-endian byte order.
                #[inline] pub fn to_bytes_le(&self) -> Vec<u8> {
                    if self.is_zero() {
                        vec![0]
                    } else {
                        convert::to_bitwise_digits_le(self, 8)
                    }
                }
                /// Returns the `u32` digits representation of the [`BigUint`] ordered least significant digit
                /// first.
                #[inline] pub fn to_u32_digits(&self) -> Vec<u32> {
                    self.iter_u32_digits().collect()
                }
                /// Returns the `u64` digits representation of the [`BigUint`] ordered least significant digit
                /// first.
                #[inline] pub fn to_u64_digits(&self) -> Vec<u64> {
                    self.iter_u64_digits().collect()
                }
                /// Returns an iterator of `u32` digits representation of the [`BigUint`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u32_digits(&self) -> U32Digits<'_> {
                    U32Digits::new(self.data.as_slice())
                }
                /// Returns an iterator of `u64` digits representation of the [`BigUint`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u64_digits(&self) -> U64Digits<'_> {
                    U64Digits::new(self.data.as_slice())
                }
                /// Returns the integer formatted as a string in the given radix.
                /// `radix` must be in the range `2...36`.
                #[inline] pub fn to_str_radix(&self, radix: u32) -> String {
                    let mut v = to_str_radix_reversed(self, radix);
                    v.reverse();
                    unsafe { String::from_utf8_unchecked(v) }
                }
                /// Returns the integer in the requested base in big-endian digit order.
                #[inline] pub fn to_radix_be(&self, radix: u32) -> Vec<u8> {
                    let mut v = convert::to_radix_le(self, radix);
                    v.reverse();
                    v
                }
                /// Returns the integer in the requested base in little-endian digit order.
                #[inline] pub fn to_radix_le(&self, radix: u32) -> Vec<u8> {
                    convert::to_radix_le(self, radix)
                }
                /// Determines the fewest bits necessary to express the [`BigUint`].
                #[inline] pub fn bits(&self) -> u64 {
                    if self.is_zero() {
                        return 0;
                    }
                    let zeros: u64 = self.data.last().unwrap().leading_zeros().into();
                    self.data.len() as u64 * u64::from(big_digit::BITS) - zeros
                }
                /// Strips off trailing zero bigdigit
                #[inline] fn normalize(&mut self) {
                    if let Some(&0) = self.data.last() 
                    {
                        let len = self.data.iter().rposition(|&d| d != 0).map_or(0, |i| i + 1);
                        self.data.truncate(len);
                    }
                    if self.data.len() < self.data.capacity() / 4 {
                        self.data.shrink_to_fit();
                    }
                }
                /// Returns a normalized [`BigUint`].
                #[inline] fn normalized(mut self) -> BigUint {
                    self.normalize();
                    self
                }
                /// Returns `self ^ exponent`.
                pub fn pow(&self, exponent: u32) -> Self {
                    Pow::pow(self, exponent)
                }
                /// Returns `(self ^ exponent) % modulus`.
                pub fn modpow(&self, exponent: &Self, modulus: &Self) -> Self {
                    power::modpow(self, exponent, modulus)
                }
                /// Returns the modular multiplicative inverse if it exists, otherwise `None`.
                pub fn modinv(&self, modulus: &Self) -> Option<Self> {
                    // Based on the inverse pseudocode listed here:
                    // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Modular_integers
                    // TODO: consider Binary or Lehmer's GCD algorithms for optimization.

                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );
                    if modulus.is_one() {
                        return Some(Self::zero());
                    }

                    let mut r0; // = modulus.clone();
                    let mut r1 = self % modulus;
                    let mut t0; // = Self::zero();
                    let mut t1; // = Self::one();

                    // Lift and simplify the first iteration to avoid some initial allocations.
                    if r1.is_zero() {
                        return None;
                    } else if r1.is_one() {
                        return Some(r1);
                    } else {
                        let (q, r2) = modulus.div_rem(&r1);
                        if r2.is_zero() {
                            return None;
                        }
                        r0 = r1;
                        r1 = r2;
                        t0 = Self::one();
                        t1 = modulus - q;
                    }

                    while !r1.is_zero() 
                    {
                        let (q, r2) = r0.div_rem(&r1);
                        r0 = r1;
                        r1 = r2;

                        // let t2 = (t0 - q * t1) % modulus;
                        let qt1 = q * &t1 % modulus;
                        let t2 = if t0 < qt1 {
                            t0 + (modulus - qt1)
                        } else {
                            t0 - qt1
                        };
                        t0 = t1;
                        t1 = t2;
                    }

                    if r0.is_one() {
                        Some(t0)
                    } else {
                        None
                    }
                }
                /// Returns the truncated principal square root of `self`
                pub fn sqrt(&self) -> Self {
                    Roots::sqrt(self)
                }
                /// Returns the truncated principal cube root of `self`
                pub fn cbrt(&self) -> Self {
                    Roots::cbrt(self)
                }
                /// Returns the truncated principal `n`th root of `self`
                pub fn nth_root(&self, n: u32) -> Self {
                    Roots::nth_root(self, n)
                }
                /// Returns the number of least-significant bits that are zero,
                /// or `None` if the entire number is zero.
                pub fn trailing_zeros(&self) -> Option<u64> {
                    let i = self.data.iter().position(|&digit| digit != 0)?;
                    let zeros: u64 = self.data[i].trailing_zeros().into();
                    Some(i as u64 * u64::from(big_digit::BITS) + zeros)
                }
                /// Returns the number of least-significant bits that are ones.
                pub fn trailing_ones(&self) -> u64 {
                    if let Some(i) = self.data.iter().position(|&digit| !digit != 0) 
                    {
                        let ones: u64 = self.data[i].trailing_ones().into();
                        i as u64 * u64::from(big_digit::BITS) + ones
                    } else {
                        self.data.len() as u64 * u64::from(big_digit::BITS)
                    }
                }
                /// Returns the number of one bits.
                pub fn count_ones(&self) -> u64 {
                    self.data.iter().map(|&d| u64::from(d.count_ones())).sum()
                }
                /// Returns whether the bit in the given position is set
                pub fn bit(&self, bit: u64) -> bool {
                    let bits_per_digit = u64::from(big_digit::BITS);
                    if let Some(digit_index) = (bit / bits_per_digit).to_usize() {
                        if let Some(digit) = self.data.get(digit_index) {
                            let bit_mask = (1 as BigDigit) << (bit % bits_per_digit);
                            return (digit & bit_mask) != 0;
                        }
                    }
                    false
                }
                /// Sets or clears the bit in the given position.
                pub fn set_bit(&mut self, bit: u64, value: bool)
                {
                    let bits_per_digit = u64::from(big_digit::BITS);
                    let digit_index = (bit / bits_per_digit).to_usize().unwrap_or(usize::MAX);
                    let bit_mask = (1 as BigDigit) << (bit % bits_per_digit);
                    if value
                    {
                        if digit_index >= self.data.len()
                        {
                            let new_len = digit_index.saturating_add(1);
                            self.data.resize(new_len, 0);
                        }
                        self.data[digit_index] |= bit_mask;
                    }
                    else if digit_index < self.data.len()
                    {
                        self.data[digit_index] &= !bit_mask;
                        self.normalize();
                    }
                }
            }

            impl ::num::traits::FromBytes for BigUint
            {
                type Bytes = [u8];
                fn from_be_bytes(bytes: &Self::Bytes) -> Self { Self::from_bytes_be(bytes) }
                fn from_le_bytes(bytes: &Self::Bytes) -> Self { Self::from_bytes_le(bytes) }
            }

            impl ::num::traits::ToBytes for BigUint
            {
                type Bytes = Vec<u8>;
                fn to_be_bytes(&self) -> Self::Bytes { self.to_bytes_be() }
                fn to_le_bytes(&self) -> Self::Bytes { self.to_bytes_le() }
            }

           pub trait IntDigits
           {
                fn digits(&self) -> &[BigDigit];
                fn digits_mut(&mut self) -> &mut Vec<BigDigit>;
                fn normalize(&mut self);
                fn capacity(&self) -> usize;
                fn len(&self) -> usize;
            }

            impl IntDigits for BigUint
            {
                #[inline] fn digits(&self) -> &[BigDigit] {
                    &self.data
                }
                #[inline] fn digits_mut(&mut self) -> &mut Vec<BigDigit> {
                    &mut self.data
                }
                #[inline] fn normalize(&mut self) {
                    self.normalize();
                }
                #[inline] fn capacity(&self) -> usize {
                    self.data.capacity()
                }
                #[inline] fn len(&self) -> usize {
                    self.data.len()
                }
            }
            /// Convert a `u32` chunk (len is either 1 or 2) to a single `u64` digit
            #[inline] fn u32_chunk_to_u64(chunk: &[u32]) -> u64 {
                // raw could have odd length
                let mut digit = chunk[0] as u64;
                if let Some(&hi) = chunk.get(1) {
                    digit |= (hi as u64) << 32;
                }
                digit
            }
        }
        
        type UsizePromotion = u64;
        type IsizePromotion = i64;

        #[derive( Debug, Clone, PartialEq, Eq )]
        pub struct ParseBigIntError 
        {
            kind: BigIntErrorKind,
        }

        #[derive( Debug, Clone, PartialEq, Eq )]
        enum BigIntErrorKind 
        {
            Empty,
            InvalidDigit,
        }

        impl ParseBigIntError 
        
        {
            fn __description(&self) -> &str 
            {
                use self::BigIntErrorKind::*;
                match self.kind {
                    Empty => "cannot parse integer from empty string",
                    InvalidDigit => "invalid digit found in string",
                }
            }

            fn empty() -> Self 
            {
                ParseBigIntError {
                    kind: BigIntErrorKind::Empty,
                }
            }

            fn invalid() -> Self 
            {
                ParseBigIntError {
                    kind: BigIntErrorKind::InvalidDigit,
                }
            }
        }

        impl fmt::Display for ParseBigIntError 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
            {
                self.__description().fmt(f)
            }
        }
        
        impl ::error::Error for ParseBigIntError 
        
        {
            fn description(&self) -> &str 
            {
                self.__description()
            }
        }
        /// The error type returned when a checked conversion regarding big integer fails.
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TryFromBigIntError<T> 
        {
            original: T,
        }

        impl<T> TryFromBigIntError<T> 
        
        {
            fn new(original: T) -> Self {
                TryFromBigIntError { original }
            }

            fn __description(&self) -> &str {
                "out of range conversion regarding big integer attempted"
            }
            /// Extract the original value, if available. The value will be available
            /// if the type before conversion was either [`BigInt`] or [`BigUint`].
            pub fn into_original(self) -> T {
                self.original
            }
        }
        
        impl<T> std::error::Error for TryFromBigIntError<T> where
        T: fmt::Debug
        
        {
            fn description(&self) -> &str 
            {
                self.__description()
            }
        }

        impl<T> fmt::Display for TryFromBigIntError<T> 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
            {
                self.__description().fmt(f)
            }
        }

        pub use self::biguint::BigUint;
        pub use self::biguint::ToBigUint;
        pub use self::biguint::U32Digits;
        pub use self::biguint::U64Digits;
        pub use self::bigint::BigInt;
        pub use self::bigint::Sign;
        pub use self::bigint::ToBigInt;
        
        pub use self::bigrand::{RandBigInt, RandomBits, UniformBigInt, UniformBigUint};

        mod big_digit 
        {
            /// A [`BigDigit`] is a [`BigUint`]'s composing element.
            pub type BigDigit = u64;
            /// A [`DoubleBigDigit`] is the internal type used to do the computations.
            pub type DoubleBigDigit = u128;

            pub const BITS: u8 = BigDigit::BITS as u8;
            pub const HALF_BITS: u8 = BITS / 2;
            pub const HALF: BigDigit = (1 << HALF_BITS) - 1;
            pub const MAX: BigDigit = BigDigit::MAX;
            pub const LO_MASK: DoubleBigDigit = MAX as DoubleBigDigit;

            #[inline] fn get_hi(n: DoubleBigDigit) -> BigDigit 
            {
                (n >> BITS) as BigDigit
            }
            #[inline] fn get_lo(n: DoubleBigDigit) -> BigDigit 
            {
                (n & LO_MASK) as BigDigit
            }
            /// Split one [`DoubleBigDigit`] into two [`BigDigit`]s.
            #[inline] pub fn from_doublebigdigit(n: DoubleBigDigit) -> (BigDigit, BigDigit) 
            {
                (get_hi(n), get_lo(n))
            }
            /// Join two [`BigDigit`]s into one [`DoubleBigDigit`].
            #[inline] pub fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit 
            {
                DoubleBigDigit::from(lo) | (DoubleBigDigit::from(hi) << BITS)
            }
        }
    }
    
    pub mod complex
    {
        //! Complex Numbers
        use ::
        {
            error::Error,
            iter::{ Product, Sum },
            num::traits::{ ConstOne, ConstZero, float::{ Float, FloatConst, FloatCore }, Inv, MulAdd, Num, One, Pow, Signed, Zero },
            ops::{ Add, Div, Mul, Neg, Rem, Sub },
            str::FromStr,
            *,
        };
        
        pub mod cast
        {
            use ::
            {
                num::traits::{ AsPrimitive, FromPrimitive, Num, NumCast, ToPrimitive },
                *,
            }; use super::Complex;

            macro_rules! impl_to_primitive
            {
                ($ty:ty, $to:ident) => {
                    #[inline] fn $to(&self) -> Option<$ty> {
                        if self.im.is_zero() {
                            self.re.$to()
                        } else {
                            None
                        }
                    }
                };
            } // impl_to_primitive

            // Returns None if Complex part is non-zero
            impl<T: ToPrimitive + Num> ToPrimitive for Complex<T> {
                impl_to_primitive!(usize, to_usize);
                impl_to_primitive!(isize, to_isize);
                impl_to_primitive!(u8, to_u8);
                impl_to_primitive!(u16, to_u16);
                impl_to_primitive!(u32, to_u32);
                impl_to_primitive!(u64, to_u64);
                impl_to_primitive!(i8, to_i8);
                impl_to_primitive!(i16, to_i16);
                impl_to_primitive!(i32, to_i32);
                impl_to_primitive!(i64, to_i64);
                impl_to_primitive!(u128, to_u128);
                impl_to_primitive!(i128, to_i128);
                impl_to_primitive!(f32, to_f32);
                impl_to_primitive!(f64, to_f64);
            }

            macro_rules! impl_from_primitive {
                ($ty:ty, $from_xx:ident) => {
                    #[inline] fn $from_xx(n: $ty) -> Option<Self> {
                        Some(Complex {
                            re: T::$from_xx(n)?,
                            im: T::zero(),
                        })
                    }
                };
            } // impl_from_primitive

            impl<T: FromPrimitive + Num> FromPrimitive for Complex<T> {
                impl_from_primitive!(usize, from_usize);
                impl_from_primitive!(isize, from_isize);
                impl_from_primitive!(u8, from_u8);
                impl_from_primitive!(u16, from_u16);
                impl_from_primitive!(u32, from_u32);
                impl_from_primitive!(u64, from_u64);
                impl_from_primitive!(i8, from_i8);
                impl_from_primitive!(i16, from_i16);
                impl_from_primitive!(i32, from_i32);
                impl_from_primitive!(i64, from_i64);
                impl_from_primitive!(u128, from_u128);
                impl_from_primitive!(i128, from_i128);
                impl_from_primitive!(f32, from_f32);
                impl_from_primitive!(f64, from_f64);
            }

            impl<T: NumCast + Num> NumCast for Complex<T> {
                fn from<U: ToPrimitive>(n: U) -> Option<Self> {
                    Some(Complex {
                        re: T::from(n)?,
                        im: T::zero(),
                    })
                }
            }

            impl<T, U> AsPrimitive<U> for Complex<T>
            where
                T: AsPrimitive<U>,
                U: 'static + Copy,
            {
                fn as_(self) -> U {
                    self.re.as_()
                }
            }
        }

        pub mod pow
        {
            use ::
            {
                num::traits::{ Float, Num, One, Pow },
                ops::Neg,
                *,
            }; use super::Complex;

            macro_rules! pow_impl
            {
                ($U:ty, $S:ty) => {
                    impl<'a, T: Clone + Num> Pow<$U> for &'a Complex<T> {
                        type Output = Complex<T>;

                        #[inline]
                        fn pow(self, mut exp: $U) -> Self::Output {
                            if exp == 0 {
                                return Complex::one();
                            }
                            let mut base = self.clone();

                            while exp & 1 == 0 {
                                base = base.clone() * base;
                                exp >>= 1;
                            }

                            if exp == 1 {
                                return base;
                            }

                            let mut acc = base.clone();
                            while exp > 1 {
                                exp >>= 1;
                                base = base.clone() * base;
                                if exp & 1 == 1 {
                                    acc = acc * base.clone();
                                }
                            }
                            acc
                        }
                    }

                    impl<'a, 'b, T: Clone + Num> Pow<&'b $U> for &'a Complex<T> {
                        type Output = Complex<T>;

                        #[inline]
                        fn pow(self, exp: &$U) -> Self::Output {
                            self.pow(*exp)
                        }
                    }

                    impl<'a, T: Clone + Num + Neg<Output = T>> Pow<$S> for &'a Complex<T> {
                        type Output = Complex<T>;

                        #[inline]
                        fn pow(self, exp: $S) -> Self::Output {
                            if exp < 0 {
                                Pow::pow(&self.inv(), exp.wrapping_neg() as $U)
                            } else {
                                Pow::pow(self, exp as $U)
                            }
                        }
                    }

                    impl<'a, 'b, T: Clone + Num + Neg<Output = T>> Pow<&'b $S> for &'a Complex<T> {
                        type Output = Complex<T>;

                        #[inline]
                        fn pow(self, exp: &$S) -> Self::Output {
                            self.pow(*exp)
                        }
                    }
                };
            }

            pow_impl!(u8, i8);
            pow_impl!(u16, i16);
            pow_impl!(u32, i32);
            pow_impl!(u64, i64);
            pow_impl!(usize, isize);
            pow_impl!(u128, i128);

            macro_rules! powf_impl {
                ($F:ty) => {
                    impl<'a, T: Float> Pow<$F> for &'a Complex<T>
                    where
                        $F: Into<T>,
                    {
                        type Output = Complex<T>;

                        #[inline]
                        fn pow(self, exp: $F) -> Self::Output {
                            self.powf(exp.into())
                        }
                    }
                    
                    impl<'a, 'b, T: Float> Pow<&'b $F> for &'a Complex<T>
                    where
                        $F: Into<T>,
                    {
                        type Output = Complex<T>;

                        #[inline]
                        fn pow(self, &exp: &$F) -> Self::Output {
                            self.powf(exp.into())
                        }
                    }
                    
                    impl<T: Float> Pow<$F> for Complex<T>
                    where
                        $F: Into<T>,
                    {
                        type Output = Complex<T>;

                        #[inline]
                        fn pow(self, exp: $F) -> Self::Output {
                            self.powf(exp.into())
                        }
                    }
                    
                    impl<'b, T: Float> Pow<&'b $F> for Complex<T>
                    where
                        $F: Into<T>,
                    {
                        type Output = Complex<T>;

                        #[inline]
                        fn pow(self, &exp: &$F) -> Self::Output {
                            self.powf(exp.into())
                        }
                    }
                };
            }

            powf_impl!(f32);
            powf_impl!(f64);
            
            impl<'a, T: Float> Pow<Complex<T>> for &'a Complex<T> {
                type Output = Complex<T>;

                #[inline] fn pow(self, exp: Complex<T>) -> Self::Output {
                    self.powc(exp)
                }
            }

            
            impl<'a, 'b, T: Float> Pow<&'b Complex<T>> for &'a Complex<T> {
                type Output = Complex<T>;

                #[inline] fn pow(self, &exp: &'b Complex<T>) -> Self::Output {
                    self.powc(exp)
                }
            }

            
            impl<T: Float> Pow<Complex<T>> for Complex<T> {
                type Output = Complex<T>;

                #[inline] fn pow(self, exp: Complex<T>) -> Self::Output {
                    self.powc(exp)
                }
            }

            
            impl<'b, T: Float> Pow<&'b Complex<T>> for Complex<T> {
                type Output = Complex<T>;

                #[inline] fn pow(self, &exp: &'b Complex<T>) -> Self::Output {
                    self.powc(exp)
                }
            }
        }

        pub mod complex_float
        {
            use ::
            {
                num::traits::{ Float, FloatConst, Num, NumCast },
                ops::Neg,
                *,
            }; use super::Complex;
            
            mod private
            {
                use ::num::traits::{Float, FloatConst};

                use super::super::Complex;

                pub trait Seal {}

                impl<T> Seal for T where T: Float + FloatConst {}
                impl<T: Float + FloatConst> Seal for Complex<T> {}
            }
            /// Generic trait for floating point complex numbers.
            pub trait ComplexFloat: Num + NumCast + Copy + Neg<Output = Self> + private::Seal 
            {
                /// The type used to represent the real coefficients of this complex number.
                type Real: Float + FloatConst;
                /// Returns `true` if this value is `NaN` and false otherwise.
                fn is_nan(self) -> bool;
                /// Returns `true` if this value is positive infinity or negative infinity and false otherwise.
                fn is_infinite(self) -> bool;
                /// Returns `true` if this number is neither infinite nor `NaN`.
                fn is_finite(self) -> bool;
                /// Returns `true` if the number is neither zero, infinite, or `NaN`.
                fn is_normal(self) -> bool;
                /// Take the reciprocal (inverse) of a number, `1/x`. See also [Complex::finv].
                fn recip(self) -> Self;
                /// Raises `self` to a signed integer power.
                fn powi(self, exp: i32) -> Self;
                /// Raises `self` to a real power.
                fn powf(self, exp: Self::Real) -> Self;
                /// Raises `self` to a complex power.
                fn powc(self, exp: Complex<Self::Real>) -> Complex<Self::Real>;
                /// Take the square root of a number.
                fn sqrt(self) -> Self;
                /// Returns `e^(self)`, (the exponential function).
                fn exp(self) -> Self;
                /// Returns `2^(self)`.
                fn exp2(self) -> Self;
                /// Returns `base^(self)`.
                fn expf(self, base: Self::Real) -> Self;
                /// Returns the natural logarithm of the number.
                fn ln(self) -> Self;
                /// Returns the logarithm of the number with respect to an arbitrary base.
                fn log(self, base: Self::Real) -> Self;
                /// Returns the base 2 logarithm of the number.
                fn log2(self) -> Self;
                /// Returns the base 10 logarithm of the number.
                fn log10(self) -> Self;
                /// Take the cubic root of a number.
                fn cbrt(self) -> Self;
                /// Computes the sine of a number (in radians).
                fn sin(self) -> Self;
                /// Computes the cosine of a number (in radians).
                fn cos(self) -> Self;
                /// Computes the tangent of a number (in radians).
                fn tan(self) -> Self;
                /// Computes the arcsine of a number.
                fn asin(self) -> Self;
                /// Computes the arccosine of a number.
                fn acos(self) -> Self;
                /// Computes the arctangent of a number.
                fn atan(self) -> Self;
                /// Hyperbolic sine function.
                fn sinh(self) -> Self;
                /// Hyperbolic cosine function.
                fn cosh(self) -> Self;
                /// Hyperbolic tangent function.
                fn tanh(self) -> Self;
                /// Inverse hyperbolic sine function.
                fn asinh(self) -> Self;
                /// Inverse hyperbolic cosine function.
                fn acosh(self) -> Self;
                /// Inverse hyperbolic tangent function.
                fn atanh(self) -> Self;
                /// Returns the real part of the number.
                fn re(self) -> Self::Real;
                /// Returns the imaginary part of the number.
                fn im(self) -> Self::Real;
                /// Returns the absolute value of the number. See also [Complex::norm]
                fn abs(self) -> Self::Real;
                /// Returns the L1 norm `|re| + |im|` -- the [Manhattan distance] from the origin.
                fn l1_norm(&self) -> Self::Real;
                /// Computes the argument of the number.
                fn arg(self) -> Self::Real;
                /// Computes the complex conjugate of the number.
                fn conj(self) -> Self;
            }

            macro_rules! forward 
            {
                ($( $base:ident :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline]
                        fn $method(self $( , $arg : $ty )* ) -> $ret {
                            $base::$method(self $( , $arg )* )
                        }
                    )*};
            }

            macro_rules! forward_ref 
            {
                ($( Self :: $method:ident ( & self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline]
                        fn $method(self $( , $arg : $ty )* ) -> $ret {
                            Self::$method(&self $( , $arg )* )
                        }
                    )*};
            }

            impl<T> ComplexFloat for T where
            T: Float + FloatConst
            {
                type Real = T;

                fn re(self) -> Self::Real {
                    self
                }

                fn im(self) -> Self::Real {
                    T::zero()
                }

                fn l1_norm(&self) -> Self::Real {
                    self.abs()
                }

                fn arg(self) -> Self::Real {
                    if self.is_nan() {
                        self
                    } else if self.is_sign_negative() {
                        T::PI()
                    } else {
                        T::zero()
                    }
                }

                fn powc(self, exp: Complex<Self::Real>) -> Complex<Self::Real> {
                    Complex::new(self, T::zero()).powc(exp)
                }

                fn conj(self) -> Self {
                    self
                }

                fn expf(self, base: Self::Real) -> Self {
                    base.powf(self)
                }

                forward! {
                    Float::is_normal(self) -> bool;
                    Float::is_infinite(self) -> bool;
                    Float::is_finite(self) -> bool;
                    Float::is_nan(self) -> bool;
                    Float::recip(self) -> Self;
                    Float::powi(self, n: i32) -> Self;
                    Float::powf(self, f: Self) -> Self;
                    Float::sqrt(self) -> Self;
                    Float::cbrt(self) -> Self;
                    Float::exp(self) -> Self;
                    Float::exp2(self) -> Self;
                    Float::ln(self) -> Self;
                    Float::log(self, base: Self) -> Self;
                    Float::log2(self) -> Self;
                    Float::log10(self) -> Self;
                    Float::sin(self) -> Self;
                    Float::cos(self) -> Self;
                    Float::tan(self) -> Self;
                    Float::asin(self) -> Self;
                    Float::acos(self) -> Self;
                    Float::atan(self) -> Self;
                    Float::sinh(self) -> Self;
                    Float::cosh(self) -> Self;
                    Float::tanh(self) -> Self;
                    Float::asinh(self) -> Self;
                    Float::acosh(self) -> Self;
                    Float::atanh(self) -> Self;
                    Float::abs(self) -> Self;
                }
            }

            impl<T: Float + FloatConst> ComplexFloat for Complex<T> 
            {
                type Real = T;

                fn re(self) -> Self::Real {
                    self.re
                }

                fn im(self) -> Self::Real {
                    self.im
                }

                fn abs(self) -> Self::Real {
                    self.norm()
                }

                fn recip(self) -> Self {
                    self.finv()
                }

                // `Complex::l1_norm` uses `Signed::abs` to let it work
                // for integers too, but we can just use `Float::abs`.
                fn l1_norm(&self) -> Self::Real {
                    self.re.abs() + self.im.abs()
                }

                // `Complex::is_*` methods use `T: FloatCore`, but we
                // have `T: Float` that can do them as well.
                fn is_nan(self) -> bool {
                    self.re.is_nan() || self.im.is_nan()
                }

                fn is_infinite(self) -> bool {
                    !self.is_nan() && (self.re.is_infinite() || self.im.is_infinite())
                }

                fn is_finite(self) -> bool {
                    self.re.is_finite() && self.im.is_finite()
                }

                fn is_normal(self) -> bool {
                    self.re.is_normal() && self.im.is_normal()
                }

                forward! {
                    Complex::arg(self) -> Self::Real;
                    Complex::powc(self, exp: Complex<Self::Real>) -> Complex<Self::Real>;
                    Complex::exp2(self) -> Self;
                    Complex::log(self, base: Self::Real) -> Self;
                    Complex::log2(self) -> Self;
                    Complex::log10(self) -> Self;
                    Complex::powf(self, f: Self::Real) -> Self;
                    Complex::sqrt(self) -> Self;
                    Complex::cbrt(self) -> Self;
                    Complex::exp(self) -> Self;
                    Complex::expf(self, base: Self::Real) -> Self;
                    Complex::ln(self) -> Self;
                    Complex::sin(self) -> Self;
                    Complex::cos(self) -> Self;
                    Complex::tan(self) -> Self;
                    Complex::asin(self) -> Self;
                    Complex::acos(self) -> Self;
                    Complex::atan(self) -> Self;
                    Complex::sinh(self) -> Self;
                    Complex::cosh(self) -> Self;
                    Complex::tanh(self) -> Self;
                    Complex::asinh(self) -> Self;
                    Complex::acosh(self) -> Self;
                    Complex::atanh(self) -> Self;
                }

                forward_ref! {
                    Self::powi(&self, n: i32) -> Self;
                    Self::conj(&self) -> Self;
                }
            }

        } pub use self::complex_float::ComplexFloat;

        pub mod crand
        {
            //! Rand implementations for complex numbers
            use ::
            {
                num::traits::{ Num },
                rand::{ distributions::Standard, prelude::* },
                *,
            }; use super::Complex;

            impl<T> Distribution<Complex<T>> for Standard
            where
                T: Num + Clone,
                Standard: Distribution<T>,
            {
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Complex<T> {
                    Complex::new(self.sample(rng), self.sample(rng))
                }
            }
            /// A generic random value distribution for complex numbers.
            #[derive(Clone, Copy, Debug)]
            pub struct ComplexDistribution<Re, Im = Re> {
                re: Re,
                im: Im,
            }

            impl<Re, Im> ComplexDistribution<Re, Im> {
                /// Creates a complex distribution from independent
                /// distributions of the real and imaginary parts.
                pub fn new(re: Re, im: Im) -> Self {
                    ComplexDistribution { re, im }
                }
            }

            impl<T, Re, Im> Distribution<Complex<T>> for ComplexDistribution<Re, Im>
            where
                T: Num + Clone,
                Re: Distribution<T>,
                Im: Distribution<T>,
            {
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Complex<T> {
                    Complex::new(self.re.sample(rng), self.im.sample(rng))
                }
            }

        } pub use self::crand::ComplexDistribution;
        /// A complex number in Cartesian form.
        #[repr( C )] #[derive( PartialEq, Eq, Copy, Clone, Hash, Debug, Default )]
        pub struct Complex<T> 
        {
            /// Real portion of the complex number
            pub re: T,
            /// Imaginary portion of the complex number
            pub im: T,
        }
        /// Alias for a [`Complex<f32>`]
        pub type Complex32 = Complex<f32>;
        /// Create a new [`Complex<f32>`] with arguments that can convert [`Into<f32>`].
        #[inline] pub fn c32<T: Into<f32>>(re: T, im: T) -> Complex32 
        {
            Complex::new(re.into(), im.into())
        }
        /// Alias for a [`Complex<f64>`]
        pub type Complex64 = Complex<f64>;
        /// Create a new [`Complex<f64>`] with arguments that can convert [`Into<f64>`].
        #[inline] pub fn c64<T: Into<f64>>(re: T, im: T) -> Complex64 
        {
            Complex::new(re.into(), im.into())
        }

        impl<T> Complex<T> 
        {
            /// Create a new `Complex`
            #[inline] pub const fn new(re: T, im: T) -> Self 
            {
                Complex { re, im }
            }
        }

        impl<T: Clone + Num> Complex<T> 
        {
            /// Returns the imaginary unit.
            #[inline] pub fn i() -> Self 
            {
                Self::new(T::zero(), T::one())
            }
            /// Returns the square of the norm, i.e. `re^2 + im^2`.
            #[inline] pub fn norm_sqr(&self) -> T 
            {
                self.re.clone() * self.re.clone() + self.im.clone() * self.im.clone()
            }
            /// Multiplies `self` by the scalar `t`.
            #[inline] pub fn scale(&self, t: T) -> Self 
            {
                Self::new(self.re.clone() * t.clone(), self.im.clone() * t)
            }
            /// Divides `self` by the scalar `t`.
            #[inline] pub fn unscale(&self, t: T) -> Self 
            {
                Self::new(self.re.clone() / t.clone(), self.im.clone() / t)
            }
            /// Raises `self` to an unsigned integer power.
            #[inline] pub fn powu(&self, exp: u32) -> Self 
            {
                Pow::pow(self, exp)
            }
        }

        impl<T: Clone + Num + Neg<Output = T>> Complex<T> 
        {
            /// Returns the complex conjugate. i.e. `re - i im`
            #[inline] pub fn conj(&self) -> Self 
            {
                Self::new(self.re.clone(), -self.im.clone())
            }
            /// Returns `1/self`
            #[inline] pub fn inv(&self) -> Self 
            {
                let norm_sqr = self.norm_sqr();
                Self::new(
                    self.re.clone() / norm_sqr.clone(),
                    -self.im.clone() / norm_sqr,
                )
            }
            /// Raises `self` to a signed integer power.
            #[inline] pub fn powi(&self, exp: i32) -> Self 
            {
                Pow::pow(self, exp)
            }
        }

        impl<T: Clone + Signed> Complex<T> 
        {
            /// Returns the L1 norm `|re| + |im|` -- the [Manhattan distance] from the origin.
            #[inline] pub fn l1_norm(&self) -> T 
            {
                self.re.abs() + self.im.abs()
            }
        }
        
        impl<T: Float> Complex<T> 
        {
            /// Create a new Complex with a given phase: `exp(i * phase)`.
            #[inline] pub fn cis(phase: T) -> Self 
            {
                Self::new(phase.cos(), phase.sin())
            }
            /// Calculate |self|
            #[inline] pub fn norm(self) -> T 
            {
                self.re.hypot(self.im)
            }
            /// Calculate the principal Arg of self.
            #[inline] pub fn arg(self) -> T 
            {
                self.im.atan2(self.re)
            }
            /// Convert to polar form (r, theta), such that
            /// `self = r * exp(i * theta)`
            #[inline] pub fn to_polar(self) -> (T, T) 
            {
                (self.norm(), self.arg())
            }
            /// Convert a polar representation into a complex number.
            #[inline] pub fn from_polar(r: T, theta: T) -> Self 
            {
                Self::new(r * theta.cos(), r * theta.sin())
            }
            /// Computes `e^(self)`, where `e` is the base of the natural logarithm.
            #[inline] pub fn exp(self) -> Self 
            {
                // formula: e^(a + bi) = e^a (cos(b) + i*sin(b)) = from_polar(e^a, b)

                let Complex { re, mut im } = self;
                // Treat the corner cases +∞, -∞, and NaN
                if re.is_infinite() {
                    if re < T::zero() {
                        if !im.is_finite() {
                            return Self::new(T::zero(), T::zero());
                        }
                    } else if im == T::zero() || !im.is_finite() {
                        if im.is_infinite() {
                            im = T::nan();
                        }
                        return Self::new(re, im);
                    }
                } else if re.is_nan() && im == T::zero() {
                    return self;
                }

                Self::from_polar(re.exp(), im)
            }
            /// Computes the principal value of natural logarithm of `self`.
            #[inline] pub fn ln(self) -> Self 
            {
                // formula: ln(z) = ln|z| + i*arg(z)
                let (r, theta) = self.to_polar();
                Self::new(r.ln(), theta)
            }
            /// Computes the principal value of the square root of `self`.
            #[inline] pub fn sqrt(self) -> Self 
            {
                if self.im.is_zero() {
                    if self.re.is_sign_positive() {
                        // simple positive real √r, and copy `im` for its sign
                        Self::new(self.re.sqrt(), self.im)
                    } else {
                        // √(r e^(iπ)) = √r e^(iπ/2) = i√r
                        // √(r e^(-iπ)) = √r e^(-iπ/2) = -i√r
                        let re = T::zero();
                        let im = (-self.re).sqrt();
                        if self.im.is_sign_positive() {
                            Self::new(re, im)
                        } else {
                            Self::new(re, -im)
                        }
                    }
                } else if self.re.is_zero() {
                    // √(r e^(iπ/2)) = √r e^(iπ/4) = √(r/2) + i√(r/2)
                    // √(r e^(-iπ/2)) = √r e^(-iπ/4) = √(r/2) - i√(r/2)
                    let one = T::one();
                    let two = one + one;
                    let x = (self.im.abs() / two).sqrt();
                    if self.im.is_sign_positive() {
                        Self::new(x, x)
                    } else {
                        Self::new(x, -x)
                    }
                } else {
                    // formula: sqrt(r e^(it)) = sqrt(r) e^(it/2)
                    let one = T::one();
                    let two = one + one;
                    let (r, theta) = self.to_polar();
                    Self::from_polar(r.sqrt(), theta / two)
                }
            }
            /// Computes the principal value of the cube root of `self`.
            #[inline] pub fn cbrt(self) -> Self 
            {
                if self.im.is_zero() {
                    if self.re.is_sign_positive() {
                        // simple positive real ∛r, and copy `im` for its sign
                        Self::new(self.re.cbrt(), self.im)
                    } else {
                        // ∛(r e^(iπ)) = ∛r e^(iπ/3) = ∛r/2 + i∛r√3/2
                        // ∛(r e^(-iπ)) = ∛r e^(-iπ/3) = ∛r/2 - i∛r√3/2
                        let one = T::one();
                        let two = one + one;
                        let three = two + one;
                        let re = (-self.re).cbrt() / two;
                        let im = three.sqrt() * re;
                        if self.im.is_sign_positive() {
                            Self::new(re, im)
                        } else {
                            Self::new(re, -im)
                        }
                    }
                } else if self.re.is_zero() {
                    // ∛(r e^(iπ/2)) = ∛r e^(iπ/6) = ∛r√3/2 + i∛r/2
                    // ∛(r e^(-iπ/2)) = ∛r e^(-iπ/6) = ∛r√3/2 - i∛r/2
                    let one = T::one();
                    let two = one + one;
                    let three = two + one;
                    let im = self.im.abs().cbrt() / two;
                    let re = three.sqrt() * im;
                    if self.im.is_sign_positive() {
                        Self::new(re, im)
                    } else {
                        Self::new(re, -im)
                    }
                } else {
                    // formula: cbrt(r e^(it)) = cbrt(r) e^(it/3)
                    let one = T::one();
                    let three = one + one + one;
                    let (r, theta) = self.to_polar();
                    Self::from_polar(r.cbrt(), theta / three)
                }
            }
            /// Raises `self` to a floating point power.
            #[inline] pub fn powf(self, exp: T) -> Self 
            {
                if exp.is_zero() {
                    return Self::one();
                }
                // formula: x^y = (ρ e^(i θ))^y = ρ^y e^(i θ y)
                // = from_polar(ρ^y, θ y)
                let (r, theta) = self.to_polar();
                Self::from_polar(r.powf(exp), theta * exp)
            }
            /// Returns the logarithm of `self` with respect to an arbitrary base.
            #[inline] pub fn log(self, base: T) -> Self 
            {
                // formula: log_y(x) = log_y(ρ e^(i θ))
                // = log_y(ρ) + log_y(e^(i θ)) = log_y(ρ) + ln(e^(i θ)) / ln(y)
                // = log_y(ρ) + i θ / ln(y)
                let (r, theta) = self.to_polar();
                Self::new(r.log(base), theta / base.ln())
            }
            /// Raises `self` to a complex power.
            #[inline] pub fn powc(self, exp: Self) -> Self 
            {
                if exp.is_zero() {
                    return Self::one();
                }
                // formula: x^y = exp(y * ln(x))
                (exp * self.ln()).exp()
            }
            /// Raises a floating point number to the complex power `self`.
            #[inline] pub fn expf(self, base: T) -> Self 
            {
                // formula: x^(a+bi) = x^a x^bi = x^a e^(b ln(x) i)
                // = from_polar(x^a, b ln(x))
                Self::from_polar(base.powf(self.re), self.im * base.ln())
            }
            /// Computes the sine of `self`.
            #[inline] pub fn sin(self) -> Self 
            {
                // formula: sin(a + bi) = sin(a)cosh(b) + i*cos(a)sinh(b)
                Self::new(
                    self.re.sin() * self.im.cosh(),
                    self.re.cos() * self.im.sinh(),
                )
            }
            /// Computes the cosine of `self`.
            #[inline] pub fn cos(self) -> Self 
            {
                // formula: cos(a + bi) = cos(a)cosh(b) - i*sin(a)sinh(b)
                Self::new(
                    self.re.cos() * self.im.cosh(),
                    -self.re.sin() * self.im.sinh(),
                )
            }
            /// Computes the tangent of `self`.
            #[inline] pub fn tan(self) -> Self 
            {
                // formula: tan(a + bi) = (sin(2a) + i*sinh(2b))/(cos(2a) + cosh(2b))
                let (two_re, two_im) = (self.re + self.re, self.im + self.im);
                Self::new(two_re.sin(), two_im.sinh()).unscale(two_re.cos() + two_im.cosh())
            }
            /// Computes the principal value of the inverse sine of `self`.
            #[inline] pub fn asin(self) -> Self 
            {
                // formula: arcsin(z) = -i ln(sqrt(1-z^2) + iz)
                let i = Self::i();
                -i * ((Self::one() - self * self).sqrt() + i * self).ln()
            }
            /// Computes the principal value of the inverse cosine of `self`.
            #[inline] pub fn acos(self) -> Self 
            {
                // formula: arccos(z) = -i ln(i sqrt(1-z^2) + z)
                let i = Self::i();
                -i * (i * (Self::one() - self * self).sqrt() + self).ln()
            }
            /// Computes the principal value of the inverse tangent of `self`.
            #[inline] pub fn atan(self) -> Self 
            {
                // formula: arctan(z) = (ln(1+iz) - ln(1-iz))/(2i)
                let i = Self::i();
                let one = Self::one();
                let two = one + one;
                if self == i {
                    return Self::new(T::zero(), T::infinity());
                } else if self == -i {
                    return Self::new(T::zero(), -T::infinity());
                }
                ((one + i * self).ln() - (one - i * self).ln()) / (two * i)
            }
            /// Computes the hyperbolic sine of `self`.
            #[inline] pub fn sinh(self) -> Self 
            {
                // formula: sinh(a + bi) = sinh(a)cos(b) + i*cosh(a)sin(b)
                Self::new(
                    self.re.sinh() * self.im.cos(),
                    self.re.cosh() * self.im.sin(),
                )
            }
            /// Computes the hyperbolic cosine of `self`.
            #[inline] pub fn cosh(self) -> Self 
            {
                // formula: cosh(a + bi) = cosh(a)cos(b) + i*sinh(a)sin(b)
                Self::new(
                    self.re.cosh() * self.im.cos(),
                    self.re.sinh() * self.im.sin(),
                )
            }
            /// Computes the hyperbolic tangent of `self`.
            #[inline] pub fn tanh(self) -> Self 
            {
                // formula: tanh(a + bi) = (sinh(2a) + i*sin(2b))/(cosh(2a) + cos(2b))
                let (two_re, two_im) = (self.re + self.re, self.im + self.im);
                Self::new(two_re.sinh(), two_im.sin()).unscale(two_re.cosh() + two_im.cos())
            }
            /// Computes the principal value of inverse hyperbolic sine of `self`.
            #[inline] pub fn asinh(self) -> Self 
            {
                // formula: arcsinh(z) = ln(z + sqrt(1+z^2))
                let one = Self::one();
                (self + (one + self * self).sqrt()).ln()
            }
            /// Computes the principal value of inverse hyperbolic cosine of `self`.
            #[inline] pub fn acosh(self) -> Self 
            {
                // formula: arccosh(z) = 2 ln(sqrt((z+1)/2) + sqrt((z-1)/2))
                let one = Self::one();
                let two = one + one;
                two * (((self + one) / two).sqrt() + ((self - one) / two).sqrt()).ln()
            }
            /// Computes the principal value of inverse hyperbolic tangent of `self`.
            #[inline] pub fn atanh(self) -> Self 
            {
                // formula: arctanh(z) = (ln(1+z) - ln(1-z))/2
                let one = Self::one();
                let two = one + one;
                if self == one {
                    return Self::new(T::infinity(), T::zero());
                } else if self == -one {
                    return Self::new(-T::infinity(), T::zero());
                }
                ((one + self).ln() - (one - self).ln()) / two
            }
            /// Returns `1/self` using floating-point operations.
            #[inline] pub fn finv(self) -> Complex<T> 
            {
                let norm = self.norm();
                self.conj() / norm / norm
            }
            /// Returns `self/other` using floating-point operations.
            #[inline] pub fn fdiv(self, other: Complex<T>) -> Complex<T> 
            {
                self * other.finv()
            }
        }
        
        impl<T: Float + FloatConst> Complex<T> 
        {
            /// Computes `2^(self)`.
            #[inline] pub fn exp2(self) -> Self {
                // formula: 2^(a + bi) = 2^a (cos(b*log2) + i*sin(b*log2))
                // = from_polar(2^a, b*log2)
                Self::from_polar(self.re.exp2(), self.im * T::LN_2())
            }
            /// Computes the principal value of log base 2 of `self`.
            #[inline] pub fn log2(self) -> Self {
                Self::ln(self) / T::LN_2()
            }
            /// Computes the principal value of log base 10 of `self`.
            #[inline] pub fn log10(self) -> Self {
                Self::ln(self) / T::LN_10()
            }
        }

        impl<T: FloatCore> Complex<T> 
        {
            /// Checks if the given complex number is NaN
            #[inline] pub fn is_nan(self) -> bool {
                self.re.is_nan() || self.im.is_nan()
            }
            /// Checks if the given complex number is infinite
            #[inline] pub fn is_infinite(self) -> bool {
                !self.is_nan() && (self.re.is_infinite() || self.im.is_infinite())
            }
            /// Checks if the given complex number is finite
            #[inline] pub fn is_finite(self) -> bool {
                self.re.is_finite() && self.im.is_finite()
            }
            /// Checks if the given complex number is normal
            #[inline] pub fn is_normal(self) -> bool {
                self.re.is_normal() && self.im.is_normal()
            }
        }

        impl<T: Clone + Num> From<T> for Complex<T> 
        {
            #[inline] fn from(re: T) -> Self {
                Self::new(re, T::zero())
            }
        }

        impl<'a, T: Clone + Num> From<&'a T> for Complex<T> 
        {
            #[inline] fn from(re: &T) -> Self {
                From::from(re.clone())
            }
        }

        macro_rules! forward_ref_ref_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, 'b, T: Clone + Num> $imp<&'b Complex<T>> for &'a Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: &Complex<T>) -> Self::Output {
                        self.clone().$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_ref_val_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T: Clone + Num> $imp<Complex<T>> for &'a Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: Complex<T>) -> Self::Output {
                        self.clone().$method(other)
                    }
                }
            };
        }

        macro_rules! forward_val_ref_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T: Clone + Num> $imp<&'a Complex<T>> for Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: &Complex<T>) -> Self::Output {
                        self.$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_all_binop 
        {
            (impl $imp:ident, $method:ident) => {
                forward_ref_ref_binop!(impl $imp, $method);
                forward_ref_val_binop!(impl $imp, $method);
                forward_val_ref_binop!(impl $imp, $method);
            };
        }

        forward_all_binop!(impl Add, add);
        
        impl<T: Clone + Num> Add<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn add(self, other: Self) -> Self::Output {
                Self::Output::new(self.re + other.re, self.im + other.im)
            }
        }

        forward_all_binop!(impl Sub, sub);
        
        impl<T: Clone + Num> Sub<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn sub(self, other: Self) -> Self::Output {
                Self::Output::new(self.re - other.re, self.im - other.im)
            }
        }

        forward_all_binop!(impl Mul, mul);
        
        impl<T: Clone + Num> Mul<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn mul(self, other: Self) -> Self::Output {
                let re = self.re.clone() * other.re.clone() - self.im.clone() * other.im.clone();
                let im = self.re * other.im + self.im * other.re;
                Self::Output::new(re, im)
            }
        }
        
        impl<T: Clone + Num + MulAdd<Output = T>> MulAdd<Complex<T>> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn mul_add(self, other: Complex<T>, add: Complex<T>) -> Complex<T> {
                let re = self.re.clone().mul_add(other.re.clone(), add.re)
                    - (self.im.clone() * other.im.clone()); // FIXME: use mulsub when available in rust
                let im = self.re.mul_add(other.im, self.im.mul_add(other.re, add.im));
                Complex::new(re, im)
            }
        }

        impl<'a, 'b, T: Clone + Num + MulAdd<Output = T>> MulAdd<&'b Complex<T>> for &'a Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn mul_add(self, other: &Complex<T>, add: &Complex<T>) -> Complex<T> {
                self.clone().mul_add(other.clone(), add.clone())
            }
        }

        forward_all_binop!(impl Div, div);
        
        impl<T: Clone + Num> Div<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn div(self, other: Self) -> Self::Output {
                let norm_sqr = other.norm_sqr();
                let re = self.re.clone() * other.re.clone() + self.im.clone() * other.im.clone();
                let im = self.im * other.re - self.re * other.im;
                Self::Output::new(re / norm_sqr.clone(), im / norm_sqr)
            }
        }

        forward_all_binop!(impl Rem, rem);

        impl<T: Clone + Num> Complex<T> 
        {
            /// Find the gaussian integer corresponding to the true ratio rounded towards zero.
            fn div_trunc(&self, divisor: &Self) -> Self {
                let Complex { re, im } = self / divisor;
                Complex::new(re.clone() - re % T::one(), im.clone() - im % T::one())
            }
        }

        impl<T: Clone + Num> Rem<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn rem(self, modulus: Self) -> Self::Output {
                let gaussian = self.div_trunc(&modulus);
                self - modulus * gaussian
            }
        }
        
        mod opassign 
        {
            use ::
            {
                num::traits::{ MulAddAssign, NumAssign },
                ops::{ AddAssign, DivAssign, MulAssign, RemAssign, SubAssign },
                *,
            }; use super::Complex;

            impl<T: Clone + NumAssign> AddAssign for Complex<T> 
            {
                fn add_assign(&mut self, other: Self) {
                    self.re += other.re;
                    self.im += other.im;
                }
            }

            impl<T: Clone + NumAssign> SubAssign for Complex<T> 
            {
                fn sub_assign(&mut self, other: Self) {
                    self.re -= other.re;
                    self.im -= other.im;
                }
            }

            // (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)
            impl<T: Clone + NumAssign> MulAssign for Complex<T> 
            {
                fn mul_assign(&mut self, other: Self) {
                    let a = self.re.clone();

                    self.re *= other.re.clone();
                    self.re -= self.im.clone() * other.im.clone();

                    self.im *= other.re;
                    self.im += a * other.im;
                }
            }

            // (a + i b) * (c + i d) + (e + i f) == ((a*c + e) - b*d) + i (b*c + (a*d + f))
            impl<T: Clone + NumAssign + MulAddAssign> MulAddAssign for Complex<T> 
            {
                fn mul_add_assign(&mut self, other: Complex<T>, add: Complex<T>) {
                    let a = self.re.clone();

                    self.re.mul_add_assign(other.re.clone(), add.re); // (a*c + e)
                    self.re -= self.im.clone() * other.im.clone(); // ((a*c + e) - b*d)

                    let mut adf = a;
                    adf.mul_add_assign(other.im, add.im); // (a*d + f)
                    self.im.mul_add_assign(other.re, adf); // (b*c + (a*d + f))
                }
            }

            impl<'a, 'b, T: Clone + NumAssign + MulAddAssign> MulAddAssign<&'a Complex<T>, &'b Complex<T>>
                for Complex<T>
            {
                fn mul_add_assign(&mut self, other: &Complex<T>, add: &Complex<T>) {
                    self.mul_add_assign(other.clone(), add.clone());
                }
            }

            // (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)
            //   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]
            impl<T: Clone + NumAssign> DivAssign for Complex<T> 
            {
                fn div_assign(&mut self, other: Self) {
                    let a = self.re.clone();
                    let norm_sqr = other.norm_sqr();

                    self.re *= other.re.clone();
                    self.re += self.im.clone() * other.im.clone();
                    self.re /= norm_sqr.clone();

                    self.im *= other.re;
                    self.im -= a * other.im;
                    self.im /= norm_sqr;
                }
            }

            impl<T: Clone + NumAssign> RemAssign for Complex<T> 
            {
                fn rem_assign(&mut self, modulus: Self) {
                    let gaussian = self.div_trunc(&modulus);
                    *self -= modulus * gaussian;
                }
            }

            impl<T: Clone + NumAssign> AddAssign<T> for Complex<T> 
            {
                fn add_assign(&mut self, other: T) {
                    self.re += other;
                }
            }

            impl<T: Clone + NumAssign> SubAssign<T> for Complex<T> 
            {
                fn sub_assign(&mut self, other: T) {
                    self.re -= other;
                }
            }

            impl<T: Clone + NumAssign> MulAssign<T> for Complex<T> 
            {
                fn mul_assign(&mut self, other: T) {
                    self.re *= other.clone();
                    self.im *= other;
                }
            }

            impl<T: Clone + NumAssign> DivAssign<T> for Complex<T> 
            {
                fn div_assign(&mut self, other: T) {
                    self.re /= other.clone();
                    self.im /= other;
                }
            }

            impl<T: Clone + NumAssign> RemAssign<T> for Complex<T> 
            {
                fn rem_assign(&mut self, other: T) {
                    self.re %= other.clone();
                    self.im %= other;
                }
            }

            macro_rules! forward_op_assign 
            {
                (impl $imp:ident, $method:ident) => {
                    impl<'a, T: Clone + NumAssign> $imp<&'a Complex<T>> for Complex<T> {
                        #[inline]
                        fn $method(&mut self, other: &Self) {
                            self.$method(other.clone())
                        }
                    }
                    impl<'a, T: Clone + NumAssign> $imp<&'a T> for Complex<T> {
                        #[inline]
                        fn $method(&mut self, other: &T) {
                            self.$method(other.clone())
                        }
                    }
                };
            }

            forward_op_assign!(impl AddAssign, add_assign);
            forward_op_assign!(impl SubAssign, sub_assign);
            forward_op_assign!(impl MulAssign, mul_assign);
            forward_op_assign!(impl DivAssign, div_assign);
            forward_op_assign!(impl RemAssign, rem_assign);
        }

        impl<T: Clone + Num + Neg<Output = T>> Neg for Complex<T> 
        {
            type Output = Self;

            #[inline] fn neg(self) -> Self::Output {
                Self::Output::new(-self.re, -self.im)
            }
        }

        impl<'a, T: Clone + Num + Neg<Output = T>> Neg for &'a Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn neg(self) -> Self::Output {
                -self.clone()
            }
        }

        impl<T: Clone + Num + Neg<Output = T>> Inv for Complex<T> 
        {
            type Output = Self;

            #[inline] fn inv(self) -> Self::Output {
                Complex::inv(&self)
            }
        }

        impl<'a, T: Clone + Num + Neg<Output = T>> Inv for &'a Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn inv(self) -> Self::Output {
                Complex::inv(self)
            }
        }

        macro_rules! real_arithmetic 
        {
            (@forward $imp:ident::$method:ident for $($real:ident),*) => (
                impl<'a, T: Clone + Num> $imp<&'a T> for Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: &T) -> Self::Output {
                        self.$method(other.clone())
                    }
                }
                impl<'a, T: Clone + Num> $imp<T> for &'a Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: T) -> Self::Output {
                        self.clone().$method(other)
                    }
                }
                impl<'a, 'b, T: Clone + Num> $imp<&'a T> for &'b Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: &T) -> Self::Output {
                        self.clone().$method(other.clone())
                    }
                }
                $(
                    impl<'a> $imp<&'a Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline]
                        fn $method(self, other: &Complex<$real>) -> Complex<$real> {
                            self.$method(other.clone())
                        }
                    }
                    impl<'a> $imp<Complex<$real>> for &'a $real {
                        type Output = Complex<$real>;

                        #[inline]
                        fn $method(self, other: Complex<$real>) -> Complex<$real> {
                            self.clone().$method(other)
                        }
                    }
                    impl<'a, 'b> $imp<&'a Complex<$real>> for &'b $real {
                        type Output = Complex<$real>;

                        #[inline]
                        fn $method(self, other: &Complex<$real>) -> Complex<$real> {
                            self.clone().$method(other.clone())
                        }
                    }
                )*
            );
            ($($real:ident),*) => (
                real_arithmetic!(@forward Add::add for $($real),*);
                real_arithmetic!(@forward Sub::sub for $($real),*);
                real_arithmetic!(@forward Mul::mul for $($real),*);
                real_arithmetic!(@forward Div::div for $($real),*);
                real_arithmetic!(@forward Rem::rem for $($real),*);

                $(
                    impl Add<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline]
                        fn add(self, other: Complex<$real>) -> Self::Output {
                            Self::Output::new(self + other.re, other.im)
                        }
                    }

                    impl Sub<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline]
                        fn sub(self, other: Complex<$real>) -> Self::Output  {
                            Self::Output::new(self - other.re, $real::zero() - other.im)
                        }
                    }

                    impl Mul<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline]
                        fn mul(self, other: Complex<$real>) -> Self::Output {
                            Self::Output::new(self * other.re, self * other.im)
                        }
                    }

                    impl Div<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline]
                        fn div(self, other: Complex<$real>) -> Self::Output {
                            // a / (c + i d) == [a * (c - i d)] / (c*c + d*d)
                            let norm_sqr = other.norm_sqr();
                            Self::Output::new(self * other.re / norm_sqr.clone(),
                                            $real::zero() - self * other.im / norm_sqr)
                        }
                    }

                    impl Rem<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline]
                        fn rem(self, other: Complex<$real>) -> Self::Output {
                            Self::Output::new(self, Self::zero()) % other
                        }
                    }
                )*
            );
        }

        impl<T: Clone + Num> Add<T> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn add(self, other: T) -> Self::Output {
                Self::Output::new(self.re + other, self.im)
            }
        }

        impl<T: Clone + Num> Sub<T> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn sub(self, other: T) -> Self::Output {
                Self::Output::new(self.re - other, self.im)
            }
        }

        impl<T: Clone + Num> Mul<T> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn mul(self, other: T) -> Self::Output {
                Self::Output::new(self.re * other.clone(), self.im * other)
            }
        }

        impl<T: Clone + Num> Div<T> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn div(self, other: T) -> Self::Output {
                Self::Output::new(self.re / other.clone(), self.im / other)
            }
        }

        impl<T: Clone + Num> Rem<T> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn rem(self, other: T) -> Self::Output {
                Self::Output::new(self.re % other.clone(), self.im % other)
            }
        }

        real_arithmetic!(usize, u8, u16, u32, u64, u128, isize, i8, i16, i32, i64, i128, f32, f64);
        
        impl<T: ConstZero> Complex<T> 
        {
            /// A constant `Complex` 0.
            pub const ZERO: Self = Self::new(T::ZERO, T::ZERO);
        }

        impl<T: Clone + Num + ConstZero> ConstZero for Complex<T> 
        {
            const ZERO: Self = Self::ZERO;
        }

        impl<T: Clone + Num> Zero for Complex<T> 
        {
            #[inline] fn zero() -> Self {
                Self::new(Zero::zero(), Zero::zero())
            }

            #[inline] fn is_zero(&self) -> bool {
                self.re.is_zero() && self.im.is_zero()
            }

            #[inline] fn set_zero(&mut self) {
                self.re.set_zero();
                self.im.set_zero();
            }
        }

        impl<T: ConstOne + ConstZero> Complex<T> 
        {
            /// A constant `Complex` 1.
            pub const ONE: Self = Self::new(T::ONE, T::ZERO);

            /// A constant `Complex` _i_, the imaginary unit.
            pub const I: Self = Self::new(T::ZERO, T::ONE);
        }

        impl<T: Clone + Num + ConstOne + ConstZero> ConstOne for Complex<T> 
        {
            const ONE: Self = Self::ONE;
        }

        impl<T: Clone + Num> One for Complex<T> 
        {
            #[inline] fn one() -> Self {
                Self::new(One::one(), Zero::zero())
            }

            #[inline] fn is_one(&self) -> bool {
                self.re.is_one() && self.im.is_zero()
            }

            #[inline] fn set_one(&mut self) {
                self.re.set_one();
                self.im.set_zero();
            }
        }

        macro_rules! write_complex 
        {
            ($f:ident, $t:expr, $prefix:expr, $re:expr, $im:expr, $T:ident) => {{
                let abs_re = if $re < Zero::zero() {
                    $T::zero() - $re.clone()
                } else {
                    $re.clone()
                };
                let abs_im = if $im < Zero::zero() {
                    $T::zero() - $im.clone()
                } else {
                    $im.clone()
                };

                return if let Some(prec) = $f.precision() {
                    fmt_re_im(
                        $f,
                        $re < $T::zero(),
                        $im < $T::zero(),
                        format_args!(concat!("{:.1$", $t, "}"), abs_re, prec),
                        format_args!(concat!("{:.1$", $t, "}"), abs_im, prec),
                    )
                } else {
                    fmt_re_im(
                        $f,
                        $re < $T::zero(),
                        $im < $T::zero(),
                        format_args!(concat!("{:", $t, "}"), abs_re),
                        format_args!(concat!("{:", $t, "}"), abs_im),
                    )
                };

                fn fmt_re_im(
                    f: &mut fmt::Formatter<'_>,
                    re_neg: bool,
                    im_neg: bool,
                    real: fmt::Arguments<'_>,
                    imag: fmt::Arguments<'_>,
                ) -> fmt::Result {
                    let prefix = if f.alternate() { $prefix } else { "" };
                    let sign = if re_neg {
                        "-"
                    } else if f.sign_plus() {
                        "+"
                    } else {
                        ""
                    };

                    if im_neg {
                        fmt_complex(
                            f,
                            format_args!(
                                "{}{pre}{re}-{pre}{im}i",
                                sign,
                                re = real,
                                im = imag,
                                pre = prefix
                            ),
                        )
                    } else {
                        fmt_complex(
                            f,
                            format_args!(
                                "{}{pre}{re}+{pre}{im}i",
                                sign,
                                re = real,
                                im = imag,
                                pre = prefix
                            ),
                        )
                    }
                }
                
                // Currently, we can only apply width using an intermediate `String` (and thus `std`)
                fn fmt_complex(f: &mut fmt::Formatter<'_>, complex: fmt::Arguments<'_>) -> fmt::Result {
                    use std::string::ToString;
                    if let Some(width) = f.width() {
                        write!(f, "{0: >1$}", complex.to_string(), width)
                    } else {
                        write!(f, "{}", complex)
                    }
                }
            }};
        }
        
        impl<T> fmt::Display for Complex<T> where
        T: fmt::Display + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "", "", self.re, self.im, T)
            }
        }

        impl<T> fmt::LowerExp for Complex<T> where
            T: fmt::LowerExp + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "e", "", self.re, self.im, T)
            }
        }

        impl<T> fmt::UpperExp for Complex<T> where
            T: fmt::UpperExp + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "E", "", self.re, self.im, T)
            }
        }

        impl<T> fmt::LowerHex for Complex<T> where
            T: fmt::LowerHex + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "x", "0x", self.re, self.im, T)
            }
        }

        impl<T> fmt::UpperHex for Complex<T> where
            T: fmt::UpperHex + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "X", "0x", self.re, self.im, T)
            }
        }

        impl<T> fmt::Octal for Complex<T> where
            T: fmt::Octal + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "o", "0o", self.re, self.im, T)
            }
        }

        impl<T> fmt::Binary for Complex<T> where
            T: fmt::Binary + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "b", "0b", self.re, self.im, T)
            }
        }

        fn from_str_generic<T, E, F>(s: &str, from: F) -> Result<Complex<T>, ParseComplexError<E>> where
            F: Fn(&str) -> Result<T, E>,
            T: Clone + Num,
        {
            let imag = match s.rfind('j') {
                None => 'i',
                _ => 'j',
            };

            let mut neg_b = false;
            let mut a = s;
            let mut b = "";

            for (i, w) in s.as_bytes().windows(2).enumerate() {
                let p = w[0];
                let c = w[1];

                // ignore '+'/'-' if part of an exponent
                if (c == b'+' || c == b'-') && !(p == b'e' || p == b'E') {
                    // trim whitespace around the separator
                    a = s[..=i].trim_end_matches(char::is_whitespace);
                    b = s[i + 2..].trim_start_matches(char::is_whitespace);
                    neg_b = c == b'-';

                    if b.is_empty() || (neg_b && b.starts_with('-')) {
                        return Err(ParseComplexError::expr_error());
                    }
                    break;
                }
            }

            // split off real and imaginary parts
            if b.is_empty() {
                // input was either pure real or pure imaginary
                b = if a.ends_with(imag) { "0" } else { "0i" };
            }

            let re;
            let neg_re;
            let im;
            let neg_im;
            if a.ends_with(imag) {
                im = a;
                neg_im = false;
                re = b;
                neg_re = neg_b;
            } else if b.ends_with(imag) {
                re = a;
                neg_re = false;
                im = b;
                neg_im = neg_b;
            } else {
                return Err(ParseComplexError::expr_error());
            }

            // parse re
            let re = from(re).map_err(ParseComplexError::from_error)?;
            let re = if neg_re { T::zero() - re } else { re };

            // pop imaginary unit off
            let mut im = &im[..im.len() - 1];
            // handle im == "i" or im == "-i"
            if im.is_empty() || im == "+" {
                im = "1";
            } else if im == "-" {
                im = "-1";
            }

            // parse im
            let im = from(im).map_err(ParseComplexError::from_error)?;
            let im = if neg_im { T::zero() - im } else { im };

            Ok(Complex::new(re, im))
        }

        impl<T> FromStr for Complex<T> where
            T: FromStr + Num + Clone,
        {
            type Err = ParseComplexError<T::Err>;

            /// Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                from_str_generic(s, T::from_str)
            }
        }

        impl<T: Num + Clone> Num for Complex<T> 
        {
            type FromStrRadixErr = ParseComplexError<T::FromStrRadixErr>;

            /// Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`
            fn from_str_radix(s: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> 
            {
                assert!(
                    radix <= 36,
                    "from_str_radix: radix is too high (maximum 36)"
                );

                // larger radix would include 'i' and 'j' as digits, which cannot be supported
                if radix > 18 {
                    return Err(ParseComplexError::unsupported_radix());
                }

                from_str_generic(s, |x| -> Result<T, T::FromStrRadixErr> {
                    T::from_str_radix(x, radix)
                })
            }
        }

        impl<T: Num + Clone> Sum for Complex<T> 
        
        {
            fn sum<I>(iter: I) -> Self where
                I: Iterator<Item = Self>,
            {
                iter.fold(Self::zero(), |acc, c| acc + c)
            }
        }

        impl<'a, T: 'a + Num + Clone> Sum<&'a Complex<T>> for Complex<T> 
        
        {
            fn sum<I>(iter: I) -> Self where
                I: Iterator<Item = &'a Complex<T>>,
            {
                iter.fold(Self::zero(), |acc, c| acc + c)
            }
        }

        impl<T: Num + Clone> Product for Complex<T> 
        
        {
            fn product<I>(iter: I) -> Self where
                I: Iterator<Item = Self>,
            {
                iter.fold(Self::one(), |acc, c| acc * c)
            }
        }

        impl<'a, T: 'a + Num + Clone> Product<&'a Complex<T>> for Complex<T> 
        
        {
            fn product<I>(iter: I) -> Self where
                I: Iterator<Item = &'a Complex<T>>,
            {
                iter.fold(Self::one(), |acc, c| acc * c)
            }
        }

        #[derive(Debug, PartialEq)]
        pub struct ParseComplexError<E> 
        {
            kind: ComplexErrorKind<E>,
        }

        #[derive(Debug, PartialEq)]
        enum ComplexErrorKind<E> 
        {
            ParseError(E),
            ExprError,
            UnsupportedRadix,
        }

        impl<E> ParseComplexError<E> 
        
        {
            fn expr_error() -> Self 
            {
                ParseComplexError {
                    kind: ComplexErrorKind::ExprError,
                }
            }

            fn unsupported_radix() -> Self 
            {
                ParseComplexError {
                    kind: ComplexErrorKind::UnsupportedRadix,
                }
            }

            fn from_error(error: E) -> Self 
            {
                ParseComplexError {
                    kind: ComplexErrorKind::ParseError(error),
                }
            }
        }
        
        impl<E: Error> Error for ParseComplexError<E> 
        
        {
            fn description(&self) -> &str 
            {
                match self.kind {
                    ComplexErrorKind::ParseError(ref e) => e.description(),
                    ComplexErrorKind::ExprError => "invalid or unsupported complex expression",
                    ComplexErrorKind::UnsupportedRadix => "unsupported radix for conversion",
                }
            }
        }

        impl<E: fmt::Display> fmt::Display for ParseComplexError<E> 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
            {
                match self.kind {
                    ComplexErrorKind::ParseError(ref e) => e.fmt(f),
                    ComplexErrorKind::ExprError => "invalid or unsupported complex expression".fmt(f),
                    ComplexErrorKind::UnsupportedRadix => "unsupported radix for conversion".fmt(f),
                }
            }
        }
    }

    pub mod fractional
    {
        use ::
        {
            num::
            {
                big::{ BigInt },
                rational::{ BigRational },
                traits::{ FromPrimitive, pow },
            },
            *,
        };

        pub fn frac_from_whole_and_dec(whole: BigInt, decimal: BigInt, dec_len: usize) -> BigRational
        {
            let denom = pow(BigInt::from_u8(10).unwrap(), dec_len);
            BigRational::new(whole, 1.into()) + BigRational::new(decimal, denom)
        }
    }
    
    pub mod integers
    {
        //! Integer trait and functions.
        use ::
        {
            ops::{ Add },
            num::traits::{ Num, Signed, Zero },
            *,
        };

        mod roots
        {
            use ::
            {
                num::
                {
                    integers::{ Integer },
                    traits::{checked_pow, PrimInt},
                },
                *,
            };
            /// Provides methods to compute an integer's square root, cube root,
            /// and arbitrary `n`th root.
            pub trait Roots: Integer
            {
                /// Returns the truncated principal `n`th root of an integer | `if x >= 0 { ⌊ⁿ√x⌋ } else { ⌈ⁿ√x⌉ }`
                fn nth_root(&self, n: u32) -> Self;
                /// Returns the truncated principal square root of an integer -- `⌊√x⌋`
                #[inline] fn sqrt(&self) -> Self {
                    self.nth_root(2)
                }
                /// Returns the truncated principal cube root of an integer | `if x >= 0 { ⌊∛x⌋ } else { ⌈∛x⌉ }`
                #[inline] fn cbrt(&self) -> Self {
                    self.nth_root(3)
                }
            }
            /// Returns the truncated principal square root of an integer
            #[inline] pub fn sqrt<T: Roots>(x: T) -> T
                {    x.sqrt()
            }
            /// Returns the truncated principal cube root of an integer
            #[inline] pub fn cbrt<T: Roots>(x: T) -> T
                {    x.cbrt()
            }
            /// Returns the truncated principal `n`th root of an integer
            #[inline] pub fn nth_root<T: Roots>(x: T, n: u32) -> T
                {    x.nth_root(n)
            }

            macro_rules! signed_roots {
                ($T:ty, $U:ty) => {
                    impl Roots for $T {
                        #[inline] fn nth_root(&self, n: u32) -> Self {
                            if *self >= 0 {
                                (*self as $U).nth_root(n) as Self
                            } else {
                                assert!(n.is_odd(), "even roots of a negative are imaginary");
                                -((self.wrapping_neg() as $U).nth_root(n) as Self)
                            }
                        }

                        #[inline] fn sqrt(&self) -> Self {
                            assert!(*self >= 0, "the square root of a negative is imaginary");
                            (*self as $U).sqrt() as Self
                        }

                        #[inline] fn cbrt(&self) -> Self {
                            if *self >= 0 {
                                (*self as $U).cbrt() as Self
                            } else {
                                -((self.wrapping_neg() as $U).cbrt() as Self)
                            }
                        }
                    }
                };
            }

            signed_roots!(i8, u8);
            signed_roots!(i16, u16);
            signed_roots!(i32, u32);
            signed_roots!(i64, u64);
            signed_roots!(i128, u128);
            signed_roots!(isize, usize);

            #[inline] fn fixpoint<T, F>(mut x: T, f: F) -> T where
                T: Integer + Copy,
                F: Fn(T) -> T,
            {
                let mut xn = f(x);
                while x < xn {
                    x = xn;
                    xn = f(x);
                }
                while x > xn {
                    x = xn;
                    xn = f(x);
                }
                x
            }

            #[inline] fn bits<T>() -> u32 {
                8 * mem::size_of::<T>() as u32
            }

            #[inline] fn log2<T: PrimInt>(x: T) -> u32 {
                debug_assert!(x > T::zero());
                bits::<T>() - 1 - x.leading_zeros()
            }

            macro_rules! unsigned_roots {
                ($T:ident) => {
                    impl Roots for $T {
                        #[inline] fn nth_root(&self, n: u32) -> Self {
                            fn go(a: $T, n: u32) -> $T {
                                // Specialize small roots
                                match n {
                                    0 => panic!("can't find a root of degree 0!"),
                                    1 => return a,
                                    2 => return a.sqrt(),
                                    3 => return a.cbrt(),
                                    _ => (),
                                }

                                // The root of values less than 2ⁿ can only be 0 or 1.
                                if bits::<$T>() <= n || a < (1 << n) {
                                    return (a > 0) as $T;
                                }

                                if bits::<$T>() > 64 {
                                    // 128-bit division is slow, so do a bitwise `nth_root` until it's small enough.
                                    return if a <= std::u64::MAX as $T {
                                        (a as u64).nth_root(n) as $T
                                    } else {
                                        let lo = (a >> n).nth_root(n) << 1;
                                        let hi = lo + 1;
                                        // 128-bit `checked_mul` also involves division, but we can't always
                                        // compute `hiⁿ` without risking overflow.  Try to avoid it though...
                                        if hi.next_power_of_two().trailing_zeros() * n >= bits::<$T>() {
                                            match checked_pow(hi, n as usize) {
                                                Some(x) if x <= a => hi,
                                                _ => lo,
                                            }
                                        } else {
                                            if hi.pow(n) <= a {
                                                hi
                                            } else {
                                                lo
                                            }
                                        }
                                    };
                                }
                                
                                #[inline]
                                fn guess(x: $T, n: u32) -> $T {
                                    // for smaller inputs, `f64` doesn't justify its cost.
                                    if bits::<$T>() <= 32 || x <= std::u32::MAX as $T {
                                        1 << ((log2(x) + n - 1) / n)
                                    } else {
                                        ((x as f64).ln() / f64::from(n)).exp() as $T
                                    }
                                }

                                // https://en.wikipedia.org/wiki/Nth_root_algorithm
                                let n1 = n - 1;
                                let next = |x: $T| {
                                    let y = match checked_pow(x, n1 as usize) {
                                        Some(ax) => a / ax,
                                        None => 0,
                                    };
                                    (y + x * n1 as $T) / n as $T
                                };
                                fixpoint(guess(a, n), next)
                            }
                            go(*self, n)
                        }

                        #[inline] fn sqrt(&self) -> Self {
                            fn go(a: $T) -> $T {
                                if bits::<$T>() > 64 {
                                    // 128-bit division is slow, so do a bitwise `sqrt` until it's small enough.
                                    return if a <= std::u64::MAX as $T {
                                        (a as u64).sqrt() as $T
                                    } else {
                                        let lo = (a >> 2u32).sqrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }

                                if a < 4 {
                                    return (a > 0) as $T;
                                }

                                #[inline]
                                fn guess(x: $T) -> $T {
                                    (x as f64).sqrt() as $T
                                }

                                // https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
                                let next = |x: $T| (a / x + x) >> 1;
                                fixpoint(guess(a), next)
                            }
                            go(*self)
                        }

                        #[inline] fn cbrt(&self) -> Self {
                            fn go(a: $T) -> $T {
                                if bits::<$T>() > 64 {
                                    // 128-bit division is slow, so do a bitwise `cbrt` until it's small enough.
                                    return if a <= std::u64::MAX as $T {
                                        (a as u64).cbrt() as $T
                                    } else {
                                        let lo = (a >> 3u32).cbrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }

                                if bits::<$T>() <= 32 {
                                    // Implementation based on Hacker's Delight `icbrt2`
                                    let mut x = a;
                                    let mut y2 = 0;
                                    let mut y = 0;
                                    let smax = bits::<$T>() / 3;
                                    for s in (0..smax + 1).rev() {
                                        let s = s * 3;
                                        y2 *= 4;
                                        y *= 2;
                                        let b = 3 * (y2 + y) + 1;
                                        if x >> s >= b {
                                            x -= b << s;
                                            y2 += 2 * y + 1;
                                            y += 1;
                                        }
                                    }
                                    return y;
                                }

                                if a < 8 {
                                    return (a > 0) as $T;
                                }
                                if a <= std::u32::MAX as $T {
                                    return (a as u32).cbrt() as $T;
                                }

                                #[inline]
                                fn guess(x: $T) -> $T {
                                    (x as f64).cbrt() as $T
                                }
                                
                                // https://en.wikipedia.org/wiki/Cube_root#Numerical_methods
                                let next = |x: $T| (a / (x * x) + x * 2) / 3;
                                fixpoint(guess(a), next)
                            }
                            go(*self)
                        }
                    }
                };
            }

            unsigned_roots!(u8);
            unsigned_roots!(u16);
            unsigned_roots!(u32);
            unsigned_roots!(u64);
            unsigned_roots!(u128);
            unsigned_roots!(usize);
        }
        pub use self::roots::Roots;
        pub use self::roots::{cbrt, nth_root, sqrt};

        mod average
        {
            use ::
            {
                num::integers::Integer,
                ops::{BitAnd, BitOr, BitXor, Shr},
                *,
            };
            /// Provides methods to compute the average of two integers, without overflows.
            pub trait Average: Integer
            {
                /// Returns the ceiling value of the average of `self` and `other`.
                fn average_ceil(&self, other: &Self) -> Self;
                /// Returns the floor value of the average of `self` and `other`.
                fn average_floor(&self, other: &Self) -> Self;
            }

            impl<I> Average for I where
                I: Integer + Shr<usize, Output = I>,
                for<'a, 'b> &'a I:
                    BitAnd<&'b I, Output = I> + BitOr<&'b I, Output = I> + BitXor<&'b I, Output = I>,
            {
                // The Henry Gordon Dietz implementation as shown in the Hacker's Delight,
                // see http://aggregate.org/MAGIC/#Average%20of%20Integers

                /// Returns the floor value of the average of `self` and `other`.
                #[inline] fn average_floor(&self, other: &I) -> I {
                    (self & other) + ((self ^ other) >> 1)
                }
                /// Returns the ceil value of the average of `self` and `other`.
                #[inline] fn average_ceil(&self, other: &I) -> I {
                    (self | other) - ((self ^ other) >> 1)
                }
            }
            /// Returns the floor value of the average of `x` and `y` --
            /// see [Average::average_floor](trait.Average.html#tymethod.average_floor).
            #[inline] pub fn average_floor<T: Average>(x: T, y: T) -> T
                {    x.average_floor(&y)
            }
            /// Returns the ceiling value of the average of `x` and `y` --
            /// see [Average::average_ceil](trait.Average.html#tymethod.average_ceil).
            #[inline] pub fn average_ceil<T: Average>(x: T, y: T) -> T
                {    x.average_ceil(&y)
            }
        }
        pub use self::average::Average;
        pub use self::average::{average_ceil, average_floor};

        pub trait Integer: Sized + Num + PartialOrd + Ord + Eq 
        {
            /// Floored integer division.
            fn div_floor(&self, other: &Self) -> Self;

            /// Floored integer modulo
            fn mod_floor(&self, other: &Self) -> Self;

            /// Ceiled integer division.
            fn div_ceil(&self, other: &Self) -> Self {
                let (q, r) = self.div_mod_floor(other);
                if r.is_zero() {
                    q
                } else {
                    q + Self::one()
                }
            }
            /// Greatest Common Divisor (GCD).
            fn gcd(&self, other: &Self) -> Self;

            /// Lowest Common Multiple (LCM).
            fn lcm(&self, other: &Self) -> Self;

            /// Greatest Common Divisor (GCD) and
            /// Lowest Common Multiple (LCM) together.
            #[inline] fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                (self.gcd(other), self.lcm(other))
            }
            /// Greatest common divisor and Bézout coefficients.
            #[inline] fn extended_gcd(&self, other: &Self) -> ExtendedGcd<Self> where
                Self: Clone,
            {
                let mut s = (Self::zero(), Self::one());
                let mut t = (Self::one(), Self::zero());
                let mut r = (other.clone(), self.clone());

                while !r.0.is_zero() {
                    let q = r.1.clone() / r.0.clone();
                    let f = |mut r: (Self, Self)| {
                        mem::swap(&mut r.0, &mut r.1);
                        r.0 = r.0 - q.clone() * r.1.clone();
                        r
                    };
                    r = f(r);
                    s = f(s);
                    t = f(t);
                }

                if r.1 >= Self::zero() {
                    ExtendedGcd {
                        gcd: r.1,
                        x: s.1,
                        y: t.1,
                    }
                } else {
                    ExtendedGcd {
                        gcd: Self::zero() - r.1,
                        x: Self::zero() - s.1,
                        y: Self::zero() - t.1,
                    }
                }
            }
            /// Greatest common divisor, least common multiple, and Bézout coefficients.
            #[inline] fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) where
                Self: Clone + Signed,
            {
                (self.extended_gcd(other), self.lcm(other))
            }
            /// Deprecated, use `is_multiple_of` instead.
            #[deprecated(note = "Please use is_multiple_of instead")]
            #[inline] fn divides(&self, other: &Self) -> bool {
                self.is_multiple_of(other)
            }
            /// Returns `true` if `self` is a multiple of `other`.
            fn is_multiple_of(&self, other: &Self) -> bool;

            /// Returns `true` if the number is even.
            fn is_even(&self) -> bool;

            /// Returns `true` if the number is odd.
            fn is_odd(&self) -> bool;

            /// Simultaneous truncated integer division and modulus.
            fn div_rem(&self, other: &Self) -> (Self, Self);

            /// Simultaneous floored integer division and modulus.
            fn div_mod_floor(&self, other: &Self) -> (Self, Self) {
                (self.div_floor(other), self.mod_floor(other))
            }
            /// Rounds up to nearest multiple of argument.
            #[inline] fn next_multiple_of(&self, other: &Self) -> Self where
                Self: Clone,
            {
                let m = self.mod_floor(other);
                self.clone()
                    + if m.is_zero() {
                        Self::zero()
                    } else {
                        other.clone() - m
                    }
            }
            /// Rounds down to nearest multiple of argument.
            #[inline] fn prev_multiple_of(&self, other: &Self) -> Self where
                Self: Clone,
            {
                self.clone() - self.mod_floor(other)
            }
            /// Decrements self by one.
            fn dec(&mut self) where
                Self: Clone,
            {
                *self = self.clone() - Self::one()
            }
            /// Increments self by one.
            fn inc(&mut self) where
                Self: Clone,
            {
                *self = self.clone() + Self::one()
            }
        }
        /// Greatest common divisor and Bézout coefficients
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        pub struct ExtendedGcd<A> {
            pub gcd: A,
            pub x: A,
            pub y: A,
        }
        /// Simultaneous integer division and modulus
        #[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) {
            x.div_rem(&y)
        }
        /// Floored integer division
        #[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T
                {x.div_floor(&y)
        }
        /// Floored integer modulus
        #[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T
                {x.mod_floor(&y)
        }
        /// Simultaneous floored integer division and modulus
        #[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) {
            x.div_mod_floor(&y)
        }
        /// Ceiled integer division
        #[inline] pub fn div_ceil<T: Integer>(x: T, y: T) -> T
                {x.div_ceil(&y)
        }
        /// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The
        /// result is always non-negative.
        #[inline( always )] pub fn gcd<T: Integer>(x: T, y: T) -> T
                {x.gcd(&y)
        }
        /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
        #[inline( always )] pub fn lcm<T: Integer>(x: T, y: T) -> T
                {x.lcm(&y)
        }
        /// Calculates the Greatest Common Divisor (GCD) and
        /// Lowest Common Multiple (LCM) of the number and `other`.
        #[inline( always )] pub fn gcd_lcm<T: Integer>(x: T, y: T) -> (T, T) {
            x.gcd_lcm(&y)
        }

        macro_rules! impl_integer_for_isize {
            ($T:ty, $test_mod:ident) => {
                impl Integer for $T {
                    /// Floored integer division
                    #[inline] fn div_floor(&self, other: &Self) -> Self {
                        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,
                        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            d - 1
                        } else {
                            d
                        }
                    }

                    /// Floored integer modulo
                    #[inline] fn mod_floor(&self, other: &Self) -> Self {
                        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,
                        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)
                        let r = *self % *other;
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            r + *other
                        } else {
                            r
                        }
                    }

                    /// Calculates `div_floor` and `mod_floor` simultaneously
                    #[inline] fn div_mod_floor(&self, other: &Self) -> (Self, Self) {
                        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,
                        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            (d - 1, r + *other)
                        } else {
                            (d, r)
                        }
                    }

                    #[inline] fn div_ceil(&self, other: &Self) -> Self {
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other > 0) || (r < 0 && *other < 0) {
                            d + 1
                        } else {
                            d
                        }
                    }

                    /// Calculates the Greatest Common Divisor (GCD) of the number and
                    /// `other`. The result is always non-negative.
                    #[inline] fn gcd(&self, other: &Self) -> Self {
                        // Use Stein's algorithm
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return (m | n).abs();
                        }
                        
                        let shift = (m | n).trailing_zeros();
                        
                        if m == Self::min_value() || n == Self::min_value() {
                            return (1 << shift).abs();
                        }

                        // guaranteed to be positive now, rest like unsigned algorithm
                        m = m.abs();
                        n = n.abs();

                        // divide n and m by 2 until odd
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }

                    #[inline] fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) 
                    {
                        let egcd = self.extended_gcd(other);
                        // should not have to recalculate abs
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            (*self * (*other / egcd.gcd)).abs()
                        };
                        (egcd, lcm)
                    }

                    /// Calculates the Lowest Common Multiple (LCM) of the number and
                    /// `other`.
                    #[inline] fn lcm(&self, other: &Self) -> Self {
                        self.gcd_lcm(other).1
                    }

                    /// Calculates the Greatest Common Divisor (GCD) and
                    /// Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline] fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                        if self.is_zero() && other.is_zero() {
                            return (Self::zero(), Self::zero());
                        }
                        let gcd = self.gcd(other);
                        // should not have to recalculate abs
                        let lcm = (*self * (*other / gcd)).abs();
                        (gcd, lcm)
                    }

                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline] fn is_multiple_of(&self, other: &Self) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    /// Returns `true` if the number is divisible by `2`
                    #[inline] fn is_even(&self) -> bool {
                        (*self) & 1 == 0
                    }

                    /// Returns `true` if the number is not divisible by `2`
                    #[inline] fn is_odd(&self) -> bool {
                        !self.is_even()
                    }

                    /// Simultaneous truncated integer division and modulus.
                    #[inline] fn div_rem(&self, other: &Self) -> (Self, Self) {
                        (*self / *other, *self % *other)
                    }

                    /// Rounds up to nearest multiple of argument.
                    #[inline] fn next_multiple_of(&self, other: &Self) -> Self {
                        // Avoid the overflow of `MIN % -1`
                        if *other == -1 {
                            return *self;
                        }

                        let m = Integer::mod_floor(self, other);
                        *self + if m == 0 { 0 } else { other - m }
                    }

                    /// Rounds down to nearest multiple of argument.
                    #[inline] fn prev_multiple_of(&self, other: &Self) -> Self {
                        // Avoid the overflow of `MIN % -1`
                        if *other == -1 {
                            return *self;
                        }

                        *self - Integer::mod_floor(self, other)
                    }
                }
            };
        }

        impl_integer_for_isize!(i8, test_integer_i8);
        impl_integer_for_isize!(i16, test_integer_i16);
        impl_integer_for_isize!(i32, test_integer_i32);
        impl_integer_for_isize!(i64, test_integer_i64);
        impl_integer_for_isize!(i128, test_integer_i128);
        impl_integer_for_isize!(isize, test_integer_isize);

        macro_rules! impl_integer_for_usize {
            ($T:ty, $test_mod:ident) => {
                impl Integer for $T {
                    /// Unsigned integer division. Returns the same result as `div` (`/`).
                    #[inline] fn div_floor(&self, other: &Self) -> Self {
                        *self / *other
                    }

                    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).
                    #[inline] fn mod_floor(&self, other: &Self) -> Self {
                        *self % *other
                    }

                    #[inline] fn div_ceil(&self, other: &Self) -> Self {
                        *self / *other + (0 != *self % *other) as Self
                    }

                    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`
                    #[inline] fn gcd(&self, other: &Self) -> Self {
                        // Use Stein's algorithm
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return m | n;
                        }

                        // find common factors of 2
                        let shift = (m | n).trailing_zeros();

                        // divide n and m by 2 until odd
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }

                    #[inline] fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) 
                    {
                        let egcd = self.extended_gcd(other);
                        // should not have to recalculate abs
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            *self * (*other / egcd.gcd)
                        };
                        (egcd, lcm)
                    }

                    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline] fn lcm(&self, other: &Self) -> Self {
                        self.gcd_lcm(other).1
                    }

                    /// Calculates the Greatest Common Divisor (GCD) and
                    /// Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline] fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                        if self.is_zero() && other.is_zero() {
                            return (Self::zero(), Self::zero());
                        }
                        let gcd = self.gcd(other);
                        let lcm = *self * (*other / gcd);
                        (gcd, lcm)
                    }

                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline] fn is_multiple_of(&self, other: &Self) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    /// Returns `true` if the number is divisible by `2`.
                    #[inline] fn is_even(&self) -> bool {
                        *self % 2 == 0
                    }

                    /// Returns `true` if the number is not divisible by `2`.
                    #[inline] fn is_odd(&self) -> bool {
                        !self.is_even()
                    }

                    /// Simultaneous truncated integer division and modulus.
                    #[inline] fn div_rem(&self, other: &Self) -> (Self, Self) {
                        (*self / *other, *self % *other)
                    }
                }
            };
        }

        impl_integer_for_usize!(u8, test_integer_u8);
        impl_integer_for_usize!(u16, test_integer_u16);
        impl_integer_for_usize!(u32, test_integer_u32);
        impl_integer_for_usize!(u64, test_integer_u64);
        impl_integer_for_usize!(u128, test_integer_u128);
        impl_integer_for_usize!(usize, test_integer_usize);
        /// An iterator over binomial coefficients.
        pub struct IterBinomial<T> {
            a: T,
            n: T,
            k: T,
        }

        impl<T> IterBinomial<T> where
            T: Integer,
        {
            /// For n, iterate over all binomial coefficients binomial(n, k), for k=0...n.
            pub fn new(n: T) -> IterBinomial<T> {
                IterBinomial {
                    k: T::zero(),
                    a: T::one(),
                    n,
                }
            }
        }

        impl<T> Iterator for IterBinomial<T> where
            T: Integer + Clone,
        {
            type Item = T;

            fn next(&mut self) -> Option<T> {
                if self.k > self.n {
                    return None;
                }
                self.a = if !self.k.is_zero() {
                    multiply_and_divide(
                        self.a.clone(),
                        self.n.clone() - self.k.clone() + T::one(),
                        self.k.clone(),
                    )
                } else {
                    T::one()
                };
                self.k = self.k.clone() + T::one();
                Some(self.a.clone())
            }
        }
        /// Calculate r * a / b, avoiding overflows and fractions.
        fn multiply_and_divide<T: Integer + Clone>(r: T, a: T, b: T) -> T
                {// See http://blog.plover.com/math/choose-2.html for the idea.
            let g = gcd(r.clone(), b.clone());
            r / g.clone() * (a / (b / g))
        }
        /// Calculate the binomial coefficient.
        pub fn binomial<T: Integer + Clone>(mut n: T, k: T) -> T
                {// See http://blog.plover.com/math/choose.html for the idea.
            if k > n {
                return T::zero();
            }
            if k > n.clone() - k.clone() {
                return binomial(n.clone(), n - k);
            }
            let mut r = T::one();
            let mut d = T::one();
            loop {
                if d > k {
                    break;
                }
                r = multiply_and_divide(r, n.clone(), d.clone());
                n = n - T::one();
                d = d + T::one();
            }
            r
        }
        /// Calculate the multinomial coefficient.
        pub fn multinomial<T: Integer + Clone>(k: &[T]) -> T where
            for<'a> T: Add<&'a T, Output = T>,
        {
            let mut r = T::one();
            let mut p = T::zero();
            for i in k {
                p = p + i;
                r = r * binomial(p.clone(), i.clone());
            }
            r
        }
    }
    
    pub mod rational
    {
        //! Rational numbers
        use ::
        {
            error::{ Error },
            fmt::{ self, Binary, Display, Formatter, LowerExp, LowerHex, Octal, UpperExp, UpperHex },
            hash::{ Hash, Hasher },
            num::
            {
                big::{ BigInt, BigUint, Sign, ToBigInt },
                integers::Integer,
                traits::
                {
                    Bounded, CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, ConstOne, ConstZero, FromPrimitive, 
                    Inv, Num, NumCast, One, Pow, Signed, ToPrimitive, Unsigned, Zero, FloatCore
                },
            },
            ops::{ Add, Div, Mul, Neg, Rem, ShlAssign, Sub },
            str::FromStr,
            *,
        };
        
        mod pow
        {
            use ::
            {
                num::
                {
                    integers::{ Integer },
                    traits::{ One, Pow },
                },
                *,
            };

            use super::Ratio;

            macro_rules! pow_unsigned_impl
            {
                (@ $exp:ty) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: $exp) -> Ratio<T> {
                        Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))
                    }
                };
                ($exp:ty) => {
                    impl<T: Clone + Integer + Pow<$exp, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_unsigned_impl!(@ $exp);
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        pow_unsigned_impl!(@ $exp);
                    }
                    impl<'b, T: Clone + Integer + Pow<$exp, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                };
            }
            pow_unsigned_impl!(u8);
            pow_unsigned_impl!(u16);
            pow_unsigned_impl!(u32);
            pow_unsigned_impl!(u64);
            pow_unsigned_impl!(u128);
            pow_unsigned_impl!(usize);

            macro_rules! pow_signed_impl {
                (@ &'b BigInt, BigUint) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: &'b BigInt) -> Ratio<T> {
                        match expon.sign() {
                            Sign::NoSign => One::one(),
                            Sign::Minus => {
                                Pow::pow(self, expon.magnitude()).into_recip()
                            }
                            Sign::Plus => Pow::pow(self, expon.magnitude()),
                        }
                    }
                };
                (@ $exp:ty, $unsigned:ty) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: $exp) -> Ratio<T> {
                        match expon.cmp(&0) {
                            cmp::Ordering::Equal => One::one(),
                            cmp::Ordering::Less => {
                                let expon = expon.wrapping_abs() as $unsigned;
                                Pow::pow(self, expon).into_recip()
                            }
                            cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),
                        }
                    }
                };
                ($exp:ty, $unsigned:ty) => {
                    impl<T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_signed_impl!(@ $exp, $unsigned);
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        pow_signed_impl!(@ $exp, $unsigned);
                    }
                    impl<'b, T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                };
            }
            pow_signed_impl!(i8, u8);
            pow_signed_impl!(i16, u16);
            pow_signed_impl!(i32, u32);
            pow_signed_impl!(i64, u64);
            pow_signed_impl!(i128, u128);
            pow_signed_impl!(isize, usize);

            #[cfg(feature = "num-bigint")]
            mod bigint {
                use super::*;
                use num_bigint::{BigInt, BigUint, Sign};

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigUint> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: BigUint) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigUint> for &'a Ratio<T>
                where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: BigUint) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigUint> for Ratio<T> {
                    pow_unsigned_impl!(@ &'b BigUint);
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigUint> for &'a Ratio<T>
                where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_unsigned_impl!(@ &'b BigUint);
                }

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigInt> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: BigInt) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigInt> for &'a Ratio<T>
                where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: BigInt) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigInt> for Ratio<T> {
                    pow_signed_impl!(@ &'b BigInt, BigUint);
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigInt> for &'a Ratio<T>
                where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_signed_impl!(@ &'b BigInt, BigUint);
                }
            }
        }
        /// Represents the ratio between two numbers.
        #[derive(Copy, Clone, Debug)]
        pub struct Ratio<T> 
        {
            /// Numerator.
            numer: T,
            /// Denominator.
            denom: T,
        }
        /// Alias for a `Ratio` of machine-sized integers.
        #[deprecated(
            since = "0.4.0",
            note = "it's better to use a specific size, like `Rational32` or `Rational64`"
        )]
        pub type Rational = Ratio<isize>;
        /// Alias for a `Ratio` of 32-bit-sized integers.
        pub type Rational32 = Ratio<i32>;
        /// Alias for a `Ratio` of 64-bit-sized integers.
        pub type Rational64 = Ratio<i64>;
        
        /// Alias for arbitrary precision rationals.
        pub type BigRational = Ratio<BigInt>;
        /// These method are `const`.
        impl<T> Ratio<T> 
        {
            /// Creates a `Ratio` without checking for `denom == 0` or reducing.
            #[inline] pub const fn new_raw(numer: T, denom: T) -> Ratio<T> {
                Ratio { numer, denom }
            }
            /// Deconstructs a `Ratio` into its numerator and denominator.
            #[inline] pub fn into_raw(self) -> (T, T) {
                (self.numer, self.denom)
            }
            /// Gets an immutable reference to the numerator.
            #[inline] pub const fn numer(&self) -> &T {
                &self.numer
            }
            /// Gets an immutable reference to the denominator.
            #[inline] pub const fn denom(&self) -> &T {
                &self.denom
            }
        }

        impl<T: Clone + Integer> Ratio<T>
        {
            /// Creates a new `Ratio`.
            #[inline] pub fn new(numer: T, denom: T) -> Ratio<T> {
                let mut ret = Ratio::new_raw(numer, denom);
                ret.reduce();
                ret
            }
            /// Creates a `Ratio` representing the integer `t`.
            #[inline] pub fn from_integer(t: T) -> Ratio<T> {
                Ratio::new_raw(t, One::one())
            }
            /// Converts to an integer, rounding towards zero.
            #[inline] pub fn to_integer(&self) -> T {
                self.trunc().numer
            }
            /// Returns true if the rational number is an integer (denominator is 1).
            #[inline] pub fn is_integer(&self) -> bool {
                self.denom.is_one()
            }
            /// Puts self into lowest terms, with `denom` > 0.
            fn reduce(&mut self) {
                if self.denom.is_zero() {
                    panic!("denominator == 0");
                }
                if self.numer.is_zero() {
                    self.denom.set_one();
                    return;
                }
                if self.numer == self.denom {
                    self.set_one();
                    return;
                }
                let g: T = self.numer.gcd(&self.denom);
                
                #[inline] fn replace_with<T: Zero>(x: &mut T, f: impl FnOnce(T) -> T) {
                    let y = ::mem::replace(x, T::zero());
                    *x = f(y);
                }

                // self.numer /= g;
                replace_with(&mut self.numer, |x| x / g.clone());

                // self.denom /= g;
                replace_with(&mut self.denom, |x| x / g);

                // keep denom positive!
                if self.denom < T::zero() {
                    replace_with(&mut self.numer, |x| T::zero() - x);
                    replace_with(&mut self.denom, |x| T::zero() - x);
                }
            }
            /// Returns a reduced copy of self.
            pub fn reduced(&self) -> Ratio<T> {
                let mut ret = self.clone();
                ret.reduce();
                ret
            }
            /// Returns the reciprocal.
            #[inline] pub fn recip(&self) -> Ratio<T> {
                self.clone().into_recip()
            }

            #[inline] fn into_recip(self) -> Ratio<T> {
                match self.numer.cmp(&T::zero()) {
                    cmp::Ordering::Equal => panic!("division by zero"),
                    cmp::Ordering::Greater => Ratio::new_raw(self.denom, self.numer),
                    cmp::Ordering::Less => Ratio::new_raw(T::zero() - self.denom, T::zero() - self.numer),
                }
            }
            /// Rounds towards minus infinity.
            #[inline] pub fn floor(&self) -> Ratio<T> {
                if *self < Zero::zero() {
                    let one: T = One::one();
                    Ratio::from_integer(
                        (self.numer.clone() - self.denom.clone() + one) / self.denom.clone(),
                    )
                } else {
                    Ratio::from_integer(self.numer.clone() / self.denom.clone())
                }
            }
            /// Rounds towards plus infinity.
            #[inline] pub fn ceil(&self) -> Ratio<T> {
                if *self < Zero::zero() {
                    Ratio::from_integer(self.numer.clone() / self.denom.clone())
                } else {
                    let one: T = One::one();
                    Ratio::from_integer(
                        (self.numer.clone() + self.denom.clone() - one) / self.denom.clone(),
                    )
                }
            }
            /// Rounds to the nearest integer. Rounds half-way cases away from zero.
            #[inline] pub fn round(&self) -> Ratio<T> {
                let zero: Ratio<T> = Zero::zero();
                let one: T = One::one();
                let two: T = one.clone() + one.clone();

                // Find unsigned fractional part of rational number
                let mut fractional = self.fract();
                if fractional < zero {
                    fractional = zero - fractional
                };

                // The algorithm compares the unsigned fractional part with 1/2, that
                // is, a/b >= 1/2, or a >= b/2. For odd denominators, we use
                // a >= (b/2)+1. This avoids overflow issues.
                let half_or_larger = if fractional.denom.is_even() {
                    fractional.numer >= fractional.denom / two
                } else {
                    fractional.numer >= (fractional.denom / two) + one
                };

                if half_or_larger {
                    let one: Ratio<T> = One::one();
                    if *self >= Zero::zero() {
                        self.trunc() + one
                    } else {
                        self.trunc() - one
                    }
                } else {
                    self.trunc()
                }
            }
            /// Rounds towards zero.
            #[inline] pub fn trunc(&self) -> Ratio<T> {
                Ratio::from_integer(self.numer.clone() / self.denom.clone())
            }
            /// Returns the fractional part of a number, with division rounded towards zero.
            #[inline] pub fn fract(&self) -> Ratio<T> {
                Ratio::new_raw(self.numer.clone() % self.denom.clone(), self.denom.clone())
            }
            /// Raises the `Ratio` to the power of an exponent.
            #[inline] pub fn pow(&self, expon: i32) -> Ratio<T> where
            for<'a> &'a T: Pow<u32, Output = T>
            {
                Pow::pow(self, expon)
            }
        }
        
        impl Ratio<BigInt> 
        {
            /// Converts a float into a rational number.
            pub fn from_float<T: FloatCore>(f: T) -> Option<BigRational> 
            {
                if !f.is_finite() {
                    return None;
                }
                let (mantissa, exponent, sign) = f.integer_decode();
                let bigint_sign = if sign == 1 { Sign::Plus } else { Sign::Minus };
                if exponent < 0 {
                    let one: BigInt = One::one();
                    let denom: BigInt = one << ((-exponent) as usize);
                    let numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();
                    Some(Ratio::new(BigInt::from_biguint(bigint_sign, numer), denom))
                } else {
                    let mut numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();
                    numer <<= exponent as usize;
                    Some(Ratio::from_integer(BigInt::from_biguint(
                        bigint_sign,
                        numer,
                    )))
                }
            }
        }

        impl<T: Clone + Integer> Default for Ratio<T> 
        {
            /// Returns zero
            fn default() -> Self {
                Ratio::zero()
            }
        }

        // From integer
        impl<T> From<T> for Ratio<T> where
            T: Clone + Integer,
        
        {
            fn from(x: T) -> Ratio<T> {
                Ratio::from_integer(x)
            }
        }

        // From pair (through the `new` constructor)
        impl<T> From<(T, T)> for Ratio<T> where
            T: Clone + Integer,
        
        {
            fn from(pair: (T, T)) -> Ratio<T> {
                Ratio::new(pair.0, pair.1)
            }
        }
        
        impl<T: Clone + Integer> Ord for Ratio<T> 
        {
            #[inline] fn cmp(&self, other: &Self) -> cmp::Ordering {
                // With equal denominators, the numerators can be directly compared
                if self.denom == other.denom {
                    let ord = self.numer.cmp(&other.numer);
                    return if self.denom < T::zero() {
                        ord.reverse()
                    } else {
                        ord
                    };
                }

                // With equal numerators, the denominators can be inversely compared
                if self.numer == other.numer {
                    if self.numer.is_zero() {
                        return cmp::Ordering::Equal;
                    }
                    let ord = self.denom.cmp(&other.denom);
                    return if self.numer < T::zero() {
                        ord
                    } else {
                        ord.reverse()
                    };
                }

                // Unfortunately, we don't have CheckedMul to try.  That could sometimes avoid all the
                // division below, or even always avoid it for BigInt and BigUint.
                // FIXME- future breaking change to add Checked* to Integer?

                // Compare as floored integers and remainders
                let (self_int, self_rem) = self.numer.div_mod_floor(&self.denom);
                let (other_int, other_rem) = other.numer.div_mod_floor(&other.denom);
                match self_int.cmp(&other_int) {
                    cmp::Ordering::Greater => cmp::Ordering::Greater,
                    cmp::Ordering::Less => cmp::Ordering::Less,
                    cmp::Ordering::Equal => {
                        match (self_rem.is_zero(), other_rem.is_zero()) {
                            (true, true) => cmp::Ordering::Equal,
                            (true, false) => cmp::Ordering::Less,
                            (false, true) => cmp::Ordering::Greater,
                            (false, false) => {
                                // Compare the reciprocals of the remaining fractions in reverse
                                let self_recip = Ratio::new_raw(self.denom.clone(), self_rem);
                                let other_recip = Ratio::new_raw(other.denom.clone(), other_rem);
                                self_recip.cmp(&other_recip).reverse()
                            }
                        }
                    }
                }
            }
        }

        impl<T: Clone + Integer> PartialOrd for Ratio<T> 
        {
            #[inline] fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
                Some(self.cmp(other))
            }
        }

        impl<T: Clone + Integer> PartialEq for Ratio<T> 
        {
            #[inline] fn eq(&self, other: &Self) -> bool {
                self.cmp(other) == cmp::Ordering::Equal
            }
        }

        impl<T: Clone + Integer> Eq for Ratio<T> {}
        
        impl<T: Clone + Integer + Hash> Hash for Ratio<T> 
        
        {
            fn hash<H: Hasher>(&self, state: &mut H) {
                recurse(&self.numer, &self.denom, state);

                fn recurse<T: Integer + Hash, H: Hasher>(numer: &T, denom: &T, state: &mut H) {
                    if !denom.is_zero() 
                    {
                        let (int, rem) = numer.div_mod_floor(denom);
                        int.hash(state);
                        recurse(denom, &rem, state);
                    } else {
                        denom.hash(state);
                    }
                }
            }
        }

        mod iter_sum_product
        {
            use ::
            {
                iter::{ Product, Sum },
                num::
                {
                    integers::{ Integer },
                    traits::{ One, Zero },
                },
                *,
            }; use super::Ratio;

            impl<T: Integer + Clone> Sum for Ratio<T> {
                fn sum<I>(iter: I) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold(Self::zero(), |sum, num| sum + num)
                }
            }

            impl<'a, T: Integer + Clone> Sum<&'a Ratio<T>> for Ratio<T> {
                fn sum<I>(iter: I) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold(Self::zero(), |sum, num| sum + num)
                }
            }

            impl<T: Integer + Clone> Product for Ratio<T> {
                fn product<I>(iter: I) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold(Self::one(), |prod, num| prod * num)
                }
            }

            impl<'a, T: Integer + Clone> Product<&'a Ratio<T>> for Ratio<T> {
                fn product<I>(iter: I) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold(Self::one(), |prod, num| prod * num)
                }
            }
        }

        mod opassign
        {
            use ::
            {
                ops::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign},
                num::
                {
                    integers::{ Integer },
                    traits::{ NumAssign },
                },
                *,
            }; use super::Ratio;

            impl<T: Clone + Integer + NumAssign> AddAssign for Ratio<T> {
                fn add_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer += other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer + rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }

            // (a/b) / (c/d) = (a/gcd_ac)*(d/gcd_bd) / ((c/gcd_ac)*(b/gcd_bd))
            impl<T: Clone + Integer + NumAssign> DivAssign for Ratio<T> {
                fn div_assign(&mut self, other: Ratio<T>) {
                    let gcd_ac = self.numer.gcd(&other.numer);
                    let gcd_bd = self.denom.gcd(&other.denom);
                    self.numer /= gcd_ac.clone();
                    self.numer *= other.denom / gcd_bd.clone();
                    self.denom /= gcd_bd;
                    self.denom *= other.numer / gcd_ac;
                    self.reduce(); // TODO: remove this line. see #8.
                }
            }

            // a/b * c/d = (a/gcd_ad)*(c/gcd_bc) / ((d/gcd_ad)*(b/gcd_bc))
            impl<T: Clone + Integer + NumAssign> MulAssign for Ratio<T> {
                fn mul_assign(&mut self, other: Ratio<T>) {
                    let gcd_ad = self.numer.gcd(&other.denom);
                    let gcd_bc = self.denom.gcd(&other.numer);
                    self.numer /= gcd_ad.clone();
                    self.numer *= other.numer / gcd_bc.clone();
                    self.denom /= gcd_bc;
                    self.denom *= other.denom / gcd_ad;
                    self.reduce(); // TODO: remove this line. see #8.
                }
            }

            impl<T: Clone + Integer + NumAssign> RemAssign for Ratio<T> {
                fn rem_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer %= other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer % rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> SubAssign for Ratio<T> {
                fn sub_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer -= other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer - rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }

            // a/b + c/1 = (a*1 + b*c) / (b*1) = (a + b*c) / b
            impl<T: Clone + Integer + NumAssign> AddAssign<T> for Ratio<T> {
                fn add_assign(&mut self, other: T) {
                    self.numer += self.denom.clone() * other;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> DivAssign<T> for Ratio<T> {
                fn div_assign(&mut self, other: T) {
                    let gcd = self.numer.gcd(&other);
                    self.numer /= gcd.clone();
                    self.denom *= other / gcd;
                    self.reduce(); // TODO: remove this line. see #8.
                }
            }

            impl<T: Clone + Integer + NumAssign> MulAssign<T> for Ratio<T> {
                fn mul_assign(&mut self, other: T) {
                    let gcd = self.denom.gcd(&other);
                    self.denom /= gcd.clone();
                    self.numer *= other / gcd;
                    self.reduce(); // TODO: remove this line. see #8.
                }
            }

            // a/b % c/1 = (a*1 % b*c) / (b*1) = (a % b*c) / b
            impl<T: Clone + Integer + NumAssign> RemAssign<T> for Ratio<T> {
                fn rem_assign(&mut self, other: T) {
                    self.numer %= self.denom.clone() * other;
                    self.reduce();
                }
            }

            // a/b - c/1 = (a*1 - b*c) / (b*1) = (a - b*c) / b
            impl<T: Clone + Integer + NumAssign> SubAssign<T> for Ratio<T> {
                fn sub_assign(&mut self, other: T) {
                    self.numer -= self.denom.clone() * other;
                    self.reduce();
                }
            }

            macro_rules! forward_op_assign {
                (impl $imp:ident, $method:ident) => {
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a Ratio<T>> for Ratio<T> {
                        #[inline]
                        fn $method(&mut self, other: &Ratio<T>) {
                            self.$method(other.clone())
                        }
                    }
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a T> for Ratio<T> {
                        #[inline]
                        fn $method(&mut self, other: &T) {
                            self.$method(other.clone())
                        }
                    }
                };
            }

            forward_op_assign!(impl AddAssign, add_assign);
            forward_op_assign!(impl DivAssign, div_assign);
            forward_op_assign!(impl MulAssign, mul_assign);
            forward_op_assign!(impl RemAssign, rem_assign);
            forward_op_assign!(impl SubAssign, sub_assign);
        }

        macro_rules! forward_ref_ref_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, 'b, T: Clone + Integer> $imp<&'b Ratio<T>> for &'a Ratio<T> {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: &'b Ratio<T>) -> Ratio<T> {
                        self.clone().$method(other.clone())
                    }
                }
                impl<'a, 'b, T: Clone + Integer> $imp<&'b T> for &'a Ratio<T> {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: &'b T) -> Ratio<T> {
                        self.clone().$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_ref_val_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T> $imp<Ratio<T>> for &'a Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: Ratio<T>) -> Ratio<T> {
                        self.clone().$method(other)
                    }
                }
                impl<'a, T> $imp<T> for &'a Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: T) -> Ratio<T> {
                        self.clone().$method(other)
                    }
                }
            };
        }

        macro_rules! forward_val_ref_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T> $imp<&'a Ratio<T>> for Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: &Ratio<T>) -> Ratio<T> {
                        self.$method(other.clone())
                    }
                }
                impl<'a, T> $imp<&'a T> for Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: &T) -> Ratio<T> {
                        self.$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_all_binop 
        {
            (impl $imp:ident, $method:ident) => {
                forward_ref_ref_binop!(impl $imp, $method);
                forward_ref_val_binop!(impl $imp, $method);
                forward_val_ref_binop!(impl $imp, $method);
            };
        }

        // Arithmetic
        forward_all_binop!(impl Mul, mul);
        // a/b * c/d = (a/gcd_ad)*(c/gcd_bc) / ((d/gcd_ad)*(b/gcd_bc))
        impl<T> Mul<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline] fn mul(self, rhs: Ratio<T>) -> Ratio<T> {
                let gcd_ad = self.numer.gcd(&rhs.denom);
                let gcd_bc = self.denom.gcd(&rhs.numer);
                Ratio::new(
                    self.numer / gcd_ad.clone() * (rhs.numer / gcd_bc.clone()),
                    self.denom / gcd_bc * (rhs.denom / gcd_ad),
                )
            }
        }
        // a/b * c/1 = (a*c) / (b*1) = (a*c) / b
        impl<T> Mul<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline] fn mul(self, rhs: T) -> Ratio<T> {
                let gcd = self.denom.gcd(&rhs);
                Ratio::new(self.numer * (rhs / gcd.clone()), self.denom / gcd)
            }
        }

        forward_all_binop!(impl Div, div);
        // (a/b) / (c/d) = (a/gcd_ac)*(d/gcd_bd) / ((c/gcd_ac)*(b/gcd_bd))
        impl<T> Div<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn div(self, rhs: Ratio<T>) -> Ratio<T> {
                let gcd_ac = self.numer.gcd(&rhs.numer);
                let gcd_bd = self.denom.gcd(&rhs.denom);
                Ratio::new(
                    self.numer / gcd_ac.clone() * (rhs.denom / gcd_bd.clone()),
                    self.denom / gcd_bd * (rhs.numer / gcd_ac),
                )
            }
        }
        // (a/b) / (c/1) = (a*1) / (b*c) = a / (b*c)
        impl<T> Div<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn div(self, rhs: T) -> Ratio<T> {
                let gcd = self.numer.gcd(&rhs);
                Ratio::new(self.numer / gcd.clone(), self.denom * (rhs / gcd))
            }
        }

        macro_rules! arith_impl 
        {
            (impl $imp:ident, $method:ident) => {
                forward_all_binop!(impl $imp, $method);
                // Abstracts a/b `op` c/d = (a*lcm/b `op` c*lcm/d)/lcm where lcm = lcm(b,d)
                impl<T: Clone + Integer> $imp<Ratio<T>> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn $method(self, rhs: Ratio<T>) -> Ratio<T> {
                        if self.denom == rhs.denom {
                            return Ratio::new(self.numer.$method(rhs.numer), rhs.denom);
                        }
                        let lcm = self.denom.lcm(&rhs.denom);
                        let lhs_numer = self.numer * (lcm.clone() / self.denom);
                        let rhs_numer = rhs.numer * (lcm.clone() / rhs.denom);
                        Ratio::new(lhs_numer.$method(rhs_numer), lcm)
                    }
                }
                // Abstracts the a/b `op` c/1 = (a*1 `op` b*c) / (b*1) = (a `op` b*c) / b pattern
                impl<T: Clone + Integer> $imp<T> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn $method(self, rhs: T) -> Ratio<T> {
                        Ratio::new(self.numer.$method(self.denom.clone() * rhs), self.denom)
                    }
                }
            };
        }

        arith_impl!(impl Add, add);
        arith_impl!(impl Sub, sub);
        arith_impl!(impl Rem, rem);

        // a/b * c/d = (a*c)/(b*d)
        impl<T> CheckedMul for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline] fn checked_mul(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                let gcd_ad = self.numer.gcd(&rhs.denom);
                let gcd_bc = self.denom.gcd(&rhs.numer);
                Some(Ratio::new(
                    (self.numer.clone() / gcd_ad.clone())
                        .checked_mul(&(rhs.numer.clone() / gcd_bc.clone()))?,
                    (self.denom.clone() / gcd_bc).checked_mul(&(rhs.denom.clone() / gcd_ad))?,
                ))
            }
        }

        // (a/b) / (c/d) = (a*d)/(b*c)
        impl<T> CheckedDiv for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline] fn checked_div(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                if rhs.is_zero() {
                    return None;
                }
                let (numer, denom) = if self.denom == rhs.denom {
                    (self.numer.clone(), rhs.numer.clone())
                } else if self.numer == rhs.numer {
                    (rhs.denom.clone(), self.denom.clone())
                } else {
                    let gcd_ac = self.numer.gcd(&rhs.numer);
                    let gcd_bd = self.denom.gcd(&rhs.denom);
                    (
                        (self.numer.clone() / gcd_ac.clone())
                            .checked_mul(&(rhs.denom.clone() / gcd_bd.clone()))?,
                        (self.denom.clone() / gcd_bd).checked_mul(&(rhs.numer.clone() / gcd_ac))?,
                    )
                };
                // Manual `reduce()`, avoiding sharp edges
                if denom.is_zero() {
                    None
                } else if numer.is_zero() {
                    Some(Self::zero())
                } else if numer == denom {
                    Some(Self::one())
                } else {
                    let g = numer.gcd(&denom);
                    let numer = numer / g.clone();
                    let denom = denom / g;
                    let raw = if denom < T::zero() {
                        // We need to keep denom positive, but 2's-complement MIN may
                        // overflow negation -- instead we can check multiplying -1.
                        let n1 = T::zero() - T::one();
                        Ratio::new_raw(numer.checked_mul(&n1)?, denom.checked_mul(&n1)?)
                    } else {
                        Ratio::new_raw(numer, denom)
                    };
                    Some(raw)
                }
            }
        }

        // As arith_impl! but for Checked{Add,Sub} traits
        macro_rules! checked_arith_impl {
            (impl $imp:ident, $method:ident) => {
                impl<T: Clone + Integer + CheckedMul + $imp> $imp for Ratio<T> {
                    #[inline] fn $method(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                        let gcd = self.denom.clone().gcd(&rhs.denom);
                        let lcm = (self.denom.clone() / gcd.clone()).checked_mul(&rhs.denom)?;
                        let lhs_numer = (lcm.clone() / self.denom.clone()).checked_mul(&self.numer)?;
                        let rhs_numer = (lcm.clone() / rhs.denom.clone()).checked_mul(&rhs.numer)?;
                        Some(Ratio::new(lhs_numer.$method(&rhs_numer)?, lcm))
                    }
                }
            };
        }

        // a/b + c/d = (lcm/b*a + lcm/d*c)/lcm, where lcm = lcm(b,d)
        checked_arith_impl!(impl CheckedAdd, checked_add);

        // a/b - c/d = (lcm/b*a - lcm/d*c)/lcm, where lcm = lcm(b,d)
        checked_arith_impl!(impl CheckedSub, checked_sub);

        impl<T> Neg for Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline] fn neg(self) -> Ratio<T> {
                Ratio::new_raw(-self.numer, self.denom)
            }
        }

        impl<'a, T> Neg for &'a Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline] fn neg(self) -> Ratio<T> {
                -self.clone()
            }
        }

        impl<T> Inv for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn inv(self) -> Ratio<T> {
                self.recip()
            }
        }

        impl<'a, T> Inv for &'a Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn inv(self) -> Ratio<T> {
                self.recip()
            }
        }

        // Constants
        impl<T: ConstZero + ConstOne> Ratio<T> 
        {
            /// A constant `Ratio` 0/1.
            pub const ZERO: Self = Self::new_raw(T::ZERO, T::ONE);
        }

        impl<T: Clone + Integer + ConstZero + ConstOne> ConstZero for Ratio<T> 
        {
            const ZERO: Self = Self::ZERO;
        }

        impl<T: Clone + Integer> Zero for Ratio<T> 
        {
            #[inline] fn zero() -> Ratio<T> {
                Ratio::new_raw(Zero::zero(), One::one())
            }

            #[inline] fn is_zero(&self) -> bool {
                self.numer.is_zero()
            }

            #[inline] fn set_zero(&mut self) {
                self.numer.set_zero();
                self.denom.set_one();
            }
        }

        impl<T: ConstOne> Ratio<T> 
        {
            /// A constant `Ratio` 1/1.
            pub const ONE: Self = Self::new_raw(T::ONE, T::ONE);
        }

        impl<T: Clone + Integer + ConstOne> ConstOne for Ratio<T> 
        {
            const ONE: Self = Self::ONE;
        }

        impl<T: Clone + Integer> One for Ratio<T> 
        {
            #[inline] fn one() -> Ratio<T> {
                Ratio::new_raw(One::one(), One::one())
            }

            #[inline] fn is_one(&self) -> bool {
                self.numer == self.denom
            }

            #[inline] fn set_one(&mut self) {
                self.numer.set_one();
                self.denom.set_one();
            }
        }

        impl<T: Clone + Integer> Num for Ratio<T> 
        {
            type FromStrRadixErr = ParseRatioError;

            /// Parses `numer/denom` where the numbers are in base `radix`.
            fn from_str_radix(s: &str, radix: u32) -> Result<Ratio<T>, ParseRatioError> {
                if s.splitn(2, '/').count() == 2 {
                    let mut parts = s.splitn(2, '/').map(|ss| {
                        T::from_str_radix(ss, radix).map_err(|_| ParseRatioError {
                            kind: RatioErrorKind::ParseError,
                        })
                    });
                    let numer: T = parts.next().unwrap()?;
                    let denom: T = parts.next().unwrap()?;
                    if denom.is_zero() {
                        Err(ParseRatioError {
                            kind: RatioErrorKind::ZeroDenominator,
                        })
                    } else {
                        Ok(Ratio::new(numer, denom))
                    }
                } else {
                    Err(ParseRatioError {
                        kind: RatioErrorKind::ParseError,
                    })
                }
            }
        }

        impl<T: Clone + Integer + Signed> Signed for Ratio<T> 
        {
            #[inline] fn abs(&self) -> Ratio<T> {
                if self.is_negative() {
                    -self.clone()
                } else {
                    self.clone()
                }
            }

            #[inline] fn abs_sub(&self, other: &Ratio<T>) -> Ratio<T> {
                if *self <= *other {
                    Zero::zero()
                } else {
                    self - other
                }
            }

            #[inline] fn signum(&self) -> Ratio<T> {
                if self.is_positive() {
                    Self::one()
                } else if self.is_zero() {
                    Self::zero()
                } else {
                    -Self::one()
                }
            }

            #[inline] fn is_positive(&self) -> bool {
                (self.numer.is_positive() && self.denom.is_positive())
                    || (self.numer.is_negative() && self.denom.is_negative())
            }

            #[inline] fn is_negative(&self) -> bool {
                (self.numer.is_negative() && self.denom.is_positive())
                    || (self.numer.is_positive() && self.denom.is_negative())
            }
        }

        // String conversions
        macro_rules! impl_formatting 
        {
            ($fmt_trait:ident, $prefix:expr, $fmt_str:expr, $fmt_alt:expr) => {
                impl<T: $fmt_trait + Clone + Integer> $fmt_trait for Ratio<T>
                {
                    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                        let pre_pad = if self.denom.is_one() {
                            format!($fmt_str, self.numer)
                        } else {
                            if f.alternate() {
                                format!(concat!($fmt_str, "/", $fmt_alt), self.numer, self.denom)
                            } else {
                                format!(concat!($fmt_str, "/", $fmt_str), self.numer, self.denom)
                            }
                        };
                        if let Some(pre_pad) = pre_pad.strip_prefix("-") {
                            f.pad_integral(false, $prefix, pre_pad)
                        } else {
                            f.pad_integral(true, $prefix, &pre_pad)
                        }
                    }
                }
            };
        }

        impl_formatting!(Display, "", "{}", "{:#}");
        impl_formatting!(Octal, "0o", "{:o}", "{:#o}");
        impl_formatting!(Binary, "0b", "{:b}", "{:#b}");
        impl_formatting!(LowerHex, "0x", "{:x}", "{:#x}");
        impl_formatting!(UpperHex, "0x", "{:X}", "{:#X}");
        impl_formatting!(LowerExp, "", "{:e}", "{:#e}");
        impl_formatting!(UpperExp, "", "{:E}", "{:#E}");

        impl<T: FromStr + Clone + Integer> FromStr for Ratio<T> 
        {
            type Err = ParseRatioError;

            /// Parses `numer/denom` or just `numer`.
            fn from_str(s: &str) -> Result<Ratio<T>, ParseRatioError> {
                let mut split = s.splitn(2, '/');

                let n = split.next().ok_or(ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;
                let num = FromStr::from_str(n).map_err(|_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;

                let d = split.next().unwrap_or("1");
                let den = FromStr::from_str(d).map_err(|_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;

                if Zero::is_zero(&den) {
                    Err(ParseRatioError {
                        kind: RatioErrorKind::ZeroDenominator,
                    })
                } else {
                    Ok(Ratio::new(num, den))
                }
            }
        }

        impl<T> From<Ratio<T>> for (T, T) 
        
        {
            fn from(val: Ratio<T>) -> Self {
                (val.numer, val.denom)
            }
        } 

        // FIXME: Bubble up specific errors
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct ParseRatioError 
        {
            kind: RatioErrorKind,
        }

        #[derive(Copy, Clone, Debug, PartialEq)]
        enum RatioErrorKind 
        {
            ParseError,
            ZeroDenominator,
        }

        impl fmt::Display for ParseRatioError 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                self.kind.description().fmt(f)
            }
        }
        
        impl Error for ParseRatioError 
        
        {
            fn description(&self) -> &str {
                self.kind.description()
            }
        }

        impl RatioErrorKind 
        
        {
            fn description(&self) -> &'static str {
                match *self {
                    RatioErrorKind::ParseError => "failed to parse integer",
                    RatioErrorKind::ZeroDenominator => "zero value denominator",
                }
            }
        }
        
        impl FromPrimitive for Ratio<BigInt> 
        
        {
            fn from_i64(n: i64) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_i128(n: i128) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_u64(n: u64) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_u128(n: u128) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_f32(n: f32) -> Option<Self> {
                Ratio::from_float(n)
            }

            fn from_f64(n: f64) -> Option<Self> {
                Ratio::from_float(n)
            }
        }

        macro_rules! from_primitive_integer 
        {
            ($typ:ty, $approx:ident) => {
                impl FromPrimitive for Ratio<$typ>
                {
                    fn from_i64(n: i64) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)
                    }

                    fn from_i128(n: i128) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)
                    }

                    fn from_u64(n: u64) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)
                    }

                    fn from_u128(n: u128) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)
                    }

                    fn from_f32(n: f32) -> Option<Self> {
                        $approx(n, 10e-20, 30)
                    }

                    fn from_f64(n: f64) -> Option<Self> {
                        $approx(n, 10e-20, 30)
                    }
                }
            };
        }

        from_primitive_integer!(i8, approximate_float);
        from_primitive_integer!(i16, approximate_float);
        from_primitive_integer!(i32, approximate_float);
        from_primitive_integer!(i64, approximate_float);
        from_primitive_integer!(i128, approximate_float);
        from_primitive_integer!(isize, approximate_float);

        from_primitive_integer!(u8, approximate_float_unsigned);
        from_primitive_integer!(u16, approximate_float_unsigned);
        from_primitive_integer!(u32, approximate_float_unsigned);
        from_primitive_integer!(u64, approximate_float_unsigned);
        from_primitive_integer!(u128, approximate_float_unsigned);
        from_primitive_integer!(usize, approximate_float_unsigned);

        impl<T: Integer + Signed + Bounded + NumCast + Clone> Ratio<T> 
        {
            pub fn approximate_float<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>> {
                // 1/10e-20 < 1/2**32 which seems like a good default, and 30 seems
                // to work well. Might want to choose something based on the types in the future, e.g.
                // T::max().recip() and T::bits() or something similar.
                let epsilon = <F as NumCast>::from(10e-20).expect("Can't convert 10e-20");
                approximate_float(f, epsilon, 30)
            }
        }

        impl<T: Integer + Unsigned + Bounded + NumCast + Clone> Ratio<T> 
        {
            pub fn approximate_float_unsigned<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>> {
                // 1/10e-20 < 1/2**32 which seems like a good default, and 30 seems
                // to work well. Might want to choose something based on the types in the future, e.g.
                // T::max().recip() and T::bits() or something similar.
                let epsilon = <F as NumCast>::from(10e-20).expect("Can't convert 10e-20");
                approximate_float_unsigned(f, epsilon, 30)
            }
        }

        fn approximate_float<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>> where
            T: Integer + Signed + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
            let negative = val.is_sign_negative();
            let abs_val = val.abs();

            let r = approximate_float_unsigned(abs_val, max_error, max_iterations)?;

            // Make negative again if needed
            Some(if negative { r.neg() } else { r })
        }

        // No Unsigned constraint because this also works on positive integers and is called
        // like that, see above
        fn approximate_float_unsigned<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>> where
            T: Integer + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
            // Continued fractions algorithm
            // https://web.archive.org/web/20200629111319/http://mathforum.org:80/dr.math/faq/faq.fractions.html#decfrac

            if val < F::zero() || val.is_nan() {
                return None;
            }

            let mut q = val;
            let mut n0 = T::zero();
            let mut d0 = T::one();
            let mut n1 = T::one();
            let mut d1 = T::zero();

            let t_max = T::max_value();
            let t_max_f = <F as NumCast>::from(t_max.clone())?;

            // 1/epsilon > T::MAX
            let epsilon = t_max_f.recip();

            // Overflow
            if q > t_max_f {
                return None;
            }

            for _ in 0..max_iterations {
                let a = match <T as NumCast>::from(q) {
                    None => break,
                    Some(a) => a,
                };

                let a_f = match <F as NumCast>::from(a.clone()) {
                    None => break,
                    Some(a_f) => a_f,
                };
                let f = q - a_f;

                // Prevent overflow
                if !a.is_zero()
                    && (n1 > t_max.clone() / a.clone()
                        || d1 > t_max.clone() / a.clone()
                        || a.clone() * n1.clone() > t_max.clone() - n0.clone()
                        || a.clone() * d1.clone() > t_max.clone() - d0.clone())
                {
                    break;
                }

                let n = a.clone() * n1.clone() + n0.clone();
                let d = a.clone() * d1.clone() + d0.clone();

                n0 = n1;
                d0 = d1;
                n1 = n.clone();
                d1 = d.clone();

                // Simplify fraction. Doing so here instead of at the end
                // allows us to get closer to the target value without overflows
                let g = Integer::gcd(&n1, &d1);
                if !g.is_zero() {
                    n1 = n1 / g.clone();
                    d1 = d1 / g.clone();
                }

                // Close enough?
                let (n_f, d_f) = match (<F as NumCast>::from(n), <F as NumCast>::from(d)) {
                    (Some(n_f), Some(d_f)) => (n_f, d_f),
                    _ => break,
                };
                if (n_f / d_f - val).abs() < max_error {
                    break;
                }

                // Prevent division by ~0
                if f < epsilon {
                    break;
                }
                q = f.recip();
            }

            // Overflow
            if d1.is_zero() {
                return None;
            }

            Some(Ratio::new(n1, d1))
        }
        
        impl<T: Clone + Integer + ToPrimitive + ToBigInt> ToPrimitive for Ratio<T> 
        
        {
            fn to_i64(&self) -> Option<i64> {
                self.to_integer().to_i64()
            }

            fn to_i128(&self) -> Option<i128> {
                self.to_integer().to_i128()
            }

            fn to_u64(&self) -> Option<u64> {
                self.to_integer().to_u64()
            }

            fn to_u128(&self) -> Option<u128> {
                self.to_integer().to_u128()
            }

            fn to_f64(&self) -> Option<f64> {
                let float = match (self.numer.to_i64(), self.denom.to_i64()) {
                    (Some(numer), Some(denom)) => ratio_to_f64(
                        <i128 as From<_>>::from(numer),
                        <i128 as From<_>>::from(denom),
                    ),
                    _ => {
                        let numer: BigInt = self.numer.to_bigint()?;
                        let denom: BigInt = self.denom.to_bigint()?;
                        ratio_to_f64(numer, denom)
                    }
                };
                if float.is_nan() {
                    None
                } else {
                    Some(float)
                }
            }
        }

        trait Bits 
        
        {
            fn bits(&self) -> u64;
        }
        
        impl Bits for BigInt 
        
        {
            fn bits(&self) -> u64 {
                self.bits()
            }
        }

        impl Bits for i128 
        
        {
            fn bits(&self) -> u64 {
                (128 - self.wrapping_abs().leading_zeros()).into()
            }
        }
        /// Converts a ratio of `T` to an f64.
        fn ratio_to_f64<T: Bits + Clone + Integer + Signed + ShlAssign<usize> + ToPrimitive>( numer: T, denom: T, ) ->
        f64 
        {
            use std::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, MIN_EXP, RADIX};

            assert_eq!(
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
            );

            // Inclusive upper and lower bounds to the range of exactly-representable ints in an f64.
            const MAX_EXACT_INT: i64 = 1i64 << MANTISSA_DIGITS;
            const MIN_EXACT_INT: i64 = -MAX_EXACT_INT;

            let flo_sign = numer.signum().to_f64().unwrap() / denom.signum().to_f64().unwrap();
            if !flo_sign.is_normal() {
                return flo_sign;
            }

            // Fast track: both sides can losslessly be converted to f64s. In this case, letting the
            // FPU do the job is faster and easier. In any other case, converting to f64s may lead
            // to an inexact result: https://stackoverflow.com/questions/56641441/.
            if let (Some(n), Some(d)) = (numer.to_i64(), denom.to_i64()) {
                let exact = MIN_EXACT_INT..=MAX_EXACT_INT;
                if exact.contains(&n) && exact.contains(&d) {
                    return n.to_f64().unwrap() / d.to_f64().unwrap();
                }
            }

            // Otherwise, the goal is to obtain a quotient with at least 55 bits. 53 of these bits will
            // be used as the mantissa of the resulting float, and the remaining two are for rounding.
            // There's an error of up to 1 on the number of resulting bits, so we may get either 55 or
            // 56 bits.
            let mut numer = numer.abs();
            let mut denom = denom.abs();
            let (is_diff_positive, absolute_diff) = match numer.bits().checked_sub(denom.bits()) {
                Some(diff) => (true, diff),
                None => (false, denom.bits() - numer.bits()),
            };

            // Filter out overflows and underflows. After this step, the signed difference fits in an
            // isize.
            if is_diff_positive && absolute_diff > MAX_EXP as u64 {
                return INFINITY * flo_sign;
            }
            if !is_diff_positive && absolute_diff > -MIN_EXP as u64 + MANTISSA_DIGITS as u64 + 1 {
                return 0.0 * flo_sign;
            }
            let diff = if is_diff_positive {
                absolute_diff.to_isize().unwrap()
            } else {
                -absolute_diff.to_isize().unwrap()
            };

            // Shift is chosen so that the quotient will have 55 or 56 bits. The exception is if the
            // quotient is going to be subnormal, in which case it may have fewer bits.
            let shift: isize = diff.max(MIN_EXP as isize) - MANTISSA_DIGITS as isize - 2;
            if shift >= 0 {
                denom <<= shift as usize
            } else {
                numer <<= -shift as usize
            };

            let (quotient, remainder) = numer.div_rem(&denom);

            // This is guaranteed to fit since we've set up quotient to be at most 56 bits.
            let mut quotient = quotient.to_u64().unwrap();
            let n_rounding_bits = {
                let quotient_bits = 64 - quotient.leading_zeros() as isize;
                let subnormal_bits = MIN_EXP as isize - shift;
                quotient_bits.max(subnormal_bits) - MANTISSA_DIGITS as isize
            } as usize;
            debug_assert!(n_rounding_bits == 2 || n_rounding_bits == 3);
            let rounding_bit_mask = (1u64 << n_rounding_bits) - 1;

            // Round to 53 bits with round-to-even. For rounding, we need to take into account both
            // our rounding bits and the division's remainder.
            let ls_bit = quotient & (1u64 << n_rounding_bits) != 0;
            let ms_rounding_bit = quotient & (1u64 << (n_rounding_bits - 1)) != 0;
            let ls_rounding_bits = quotient & (rounding_bit_mask >> 1) != 0;
            if ms_rounding_bit && (ls_bit || ls_rounding_bits || !remainder.is_zero()) {
                quotient += 1u64 << n_rounding_bits;
            }
            quotient &= !rounding_bit_mask;

            // The quotient is guaranteed to be exactly representable as it's now 53 bits + 2 or 3
            // trailing zeros, so there is no risk of a rounding error here.
            let q_float = quotient as f64 * flo_sign;
            ldexp(q_float, shift as i32)
        }
        /// Multiply `x` by 2 to the power of `exp`. Returns an accurate result even if `2^exp` is not representable.
        fn ldexp(x: f64, exp: i32) -> f64 
        {
            use std::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, RADIX};

            assert_eq!(
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
            );

            const EXPONENT_MASK: u64 = 0x7ff << 52;
            const MAX_UNSIGNED_EXPONENT: i32 = 0x7fe;
            const MIN_SUBNORMAL_POWER: i32 = MANTISSA_DIGITS as i32;

            if x.is_zero() || x.is_infinite() || x.is_nan() {
                return x;
            }

            // Filter out obvious over / underflows to make sure the resulting exponent fits in an isize.
            if exp > 3 * MAX_EXP {
                return INFINITY * x.signum();
            } else if exp < -3 * MAX_EXP {
                return 0.0 * x.signum();
            }

            // curr_exp is the x's *biased* exponent, and is in the [-54, MAX_UNSIGNED_EXPONENT] range.
            let (bits, curr_exp) = if !x.is_normal() {
                // If x is subnormal, we make it normal by multiplying by 2^53. This causes no loss of
                // precision or rounding.
                let normal_x = x * 2f64.powi(MIN_SUBNORMAL_POWER);
                let bits = normal_x.to_bits();
                // This cast is safe because the exponent is at most 0x7fe, which fits in an i32.
                (
                    bits,
                    ((bits & EXPONENT_MASK) >> 52) as i32 - MIN_SUBNORMAL_POWER,
                )
            } else {
                let bits = x.to_bits();
                let curr_exp = (bits & EXPONENT_MASK) >> 52;
                // This cast is safe because the exponent is at most 0x7fe, which fits in an i32.
                (bits, curr_exp as i32)
            };

            // The addition can't overflow because exponent is between 0 and 0x7fe, and exp is between
            // -2*MAX_EXP and 2*MAX_EXP.
            let new_exp = curr_exp + exp;

            if new_exp > MAX_UNSIGNED_EXPONENT {
                INFINITY * x.signum()
            } else if new_exp > 0 {
                // Normal case: exponent is not too large nor subnormal.
                let new_bits = (bits & !EXPONENT_MASK) | ((new_exp as u64) << 52);
                f64::from_bits(new_bits)
            } else if new_exp >= -(MANTISSA_DIGITS as i32) {
                // Result is subnormal but may not be zero.
                // In this case, we increase the exponent by 54 to make it normal, then multiply the end
                // result by 2^-53. This results in a single multiplication with no prior rounding error,
                // so there is no risk of double rounding.
                let new_exp = new_exp + MIN_SUBNORMAL_POWER;
                debug_assert!(new_exp >= 0);
                let new_bits = (bits & !EXPONENT_MASK) | ((new_exp as u64) << 52);
                f64::from_bits(new_bits) * 2f64.powi(-MIN_SUBNORMAL_POWER)
            } else {
                // Result is zero.
                return 0.0 * x.signum();
            }
        }
    }
    
    pub mod traits
    {
        //! Numeric traits for generic mathematics
        use ::
        {
            cmp::{ Ordering },
            hash::{ Hash, Hasher },
            num::
            {
                Wrapping 
            },
            ops::{ Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Sub, SubAssign },
            *,
        };
        /*   
        // pub use real::{FloatCore, Real}; // NOTE: Don't do this, it breaks `use num_traits::*;`. */
        #[macro_use] pub mod macros
        {
            use ::
            {
                *,
            };
            /// Forward a method to an inherent method or a base trait method.
            macro_rules! forward
            {
                ($( Self :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method(self $( , $arg : $ty )* ) -> $ret {
                            Self::$method(self $( , $arg )* )
                        }
                    )*};
                ($( $base:ident :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method(self $( , $arg : $ty )* ) -> $ret {
                            <Self as $base>::$method(self $( , $arg )* )
                        }
                    )*};
                ($( $base:ident :: $method:ident ( $( $arg:ident : $ty:ty ),* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method( $( $arg : $ty ),* ) -> $ret {
                            <Self as $base>::$method( $( $arg ),* )
                        }
                    )*};
                ($( $imp:path as $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method(self $( , $arg : $ty )* ) -> $ret {
                            $imp(self $( , $arg )* )
                        }
                    )*};
            }

            macro_rules! constant
            {
                ($( $method:ident () -> $ret:expr ; )*) => 
                {$(
                        #[inline] fn $method() -> Self
                        {
                            $ret
                        }
                )*};
            }
        }

        pub mod bounds
        {
            use ::
            {
                num::{ Wrapping },
                *,
            };
            /// Numbers which have upper and lower bounds
            pub trait Bounded 
            {
                // FIXME (#5527): These should be associated constants
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }
            /// Numbers which have lower bounds
            pub trait LowerBounded 
            {
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
            }
            
            impl<T: Bounded> LowerBounded for T 
            {
                fn min_value() -> T
                {
                    Bounded::min_value()
                }
            }
            /// Numbers which have upper bounds
            pub trait UpperBounded 
            {
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }

            impl<T: Bounded> UpperBounded for T 
            {
                fn max_value() -> T
                {        Bounded::max_value()
                }
            }

            macro_rules! bounded_impl 
            {
                ($t:ty, $min:expr, $max:expr) => {
                    impl Bounded for $t {
                        #[inline] fn min_value() -> $t {
                            $min
                        }

                        #[inline] fn max_value() -> $t {
                            $max
                        }
                    }
                };
            }

            bounded_impl!(usize, usize::MIN, usize::MAX);
            bounded_impl!(u8, u8::MIN, u8::MAX);
            bounded_impl!(u16, u16::MIN, u16::MAX);
            bounded_impl!(u32, u32::MIN, u32::MAX);
            bounded_impl!(u64, u64::MIN, u64::MAX);
            bounded_impl!(u128, u128::MIN, u128::MAX);

            bounded_impl!(isize, isize::MIN, isize::MAX);
            bounded_impl!(i8, i8::MIN, i8::MAX);
            bounded_impl!(i16, i16::MIN, i16::MAX);
            bounded_impl!(i32, i32::MIN, i32::MAX);
            bounded_impl!(i64, i64::MIN, i64::MAX);
            bounded_impl!(i128, i128::MIN, i128::MAX);

            impl<T: Bounded> Bounded for Wrapping<T> 
            {
                fn min_value() -> Self {
                    Wrapping(T::min_value())
                }
                fn max_value() -> Self {
                    Wrapping(T::max_value())
                }
            }

            bounded_impl!(f32, f32::MIN, f32::MAX);

            macro_rules! for_each_tuple_ 
            {
                ( $m:ident !! ) => (
                    $m! { }
                );
                ( $m:ident !! $h:ident, $($t:ident,)* ) => (
                    $m! { $h $($t)* }
                    for_each_tuple_! { $m !! $($t,)* }
                );
            }
            macro_rules! for_each_tuple 
            {
                ($m:ident) => {
                    for_each_tuple_! { $m !! A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, }
                };
            }

            macro_rules! bounded_tuple 
            {
                ( $($name:ident)* ) => (
                    impl<$($name: Bounded,)*> Bounded for ($($name,)*) {
                        #[inline] fn min_value() -> Self {
                            ($($name::min_value(),)*)
                        }
                        #[inline] fn max_value() -> Self {
                            ($($name::max_value(),)*)
                        }
                    }
                );
            }

            for_each_tuple!(bounded_tuple);
            bounded_impl!(f64, f64::MIN, f64::MAX);
        } pub use self::bounds::{ * };

        pub mod cast
        {
            use ::
            {
                num::
                {
                    Wrapping 
                },
                mem::size_of,
                *,
            };
            /// A generic trait for converting a value to a number.
            pub trait ToPrimitive {
                /// Converts the value of `self` to an `isize`. If the value cannot be
                /// represented by an `isize`, then `None` is returned.
                #[inline] fn to_isize(&self) -> Option<isize> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_isize)
                }
                /// Converts the value of `self` to an `i8`. If the value cannot be
                /// represented by an `i8`, then `None` is returned.
                #[inline] fn to_i8(&self) -> Option<i8> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i8)
                }
                /// Converts the value of `self` to an `i16`. If the value cannot be
                /// represented by an `i16`, then `None` is returned.
                #[inline] fn to_i16(&self) -> Option<i16> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i16)
                }
                /// Converts the value of `self` to an `i32`. If the value cannot be
                /// represented by an `i32`, then `None` is returned.
                #[inline] fn to_i32(&self) -> Option<i32> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i32)
                }
                /// Converts the value of `self` to an `i64`. If the value cannot be
                /// represented by an `i64`, then `None` is returned.
                fn to_i64(&self) -> Option<i64>;
                /// Converts the value of `self` to an `i128`. If the value cannot be
                /// represented by an `i128` (`i64` under the default implementation), then
                /// `None` is returned.
                ///
                /// The default implementation converts through `to_i64()`. Types implementing
                /// this trait should override this method if they can represent a greater range.
                #[inline] fn to_i128(&self) -> Option<i128> {
                    self.to_i64().map(From::from)
                }
                /// Converts the value of `self` to a `usize`. If the value cannot be
                /// represented by a `usize`, then `None` is returned.
                #[inline] fn to_usize(&self) -> Option<usize> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_usize)
                }
                /// Converts the value of `self` to a `u8`. If the value cannot be
                /// represented by a `u8`, then `None` is returned.
                #[inline] fn to_u8(&self) -> Option<u8> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u8)
                }
                /// Converts the value of `self` to a `u16`. If the value cannot be
                /// represented by a `u16`, then `None` is returned.
                #[inline] fn to_u16(&self) -> Option<u16> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u16)
                }
                /// Converts the value of `self` to a `u32`. If the value cannot be
                /// represented by a `u32`, then `None` is returned.
                #[inline] fn to_u32(&self) -> Option<u32> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u32)
                }
                /// Converts the value of `self` to a `u64`. If the value cannot be
                /// represented by a `u64`, then `None` is returned.
                fn to_u64(&self) -> Option<u64>;
                /// Converts the value of `self` to a `u128`. If the value cannot be
                /// represented by a `u128` (`u64` under the default implementation), then
                /// `None` is returned.
                #[inline] fn to_u128(&self) -> Option<u128> {
                    self.to_u64().map(From::from)
                }
                /// Converts the value of `self` to an `f32`. Overflows may map to positive
                /// or negative inifinity, otherwise `None` is returned if the value cannot
                /// be represented by an `f32`.
                #[inline] fn to_f32(&self) -> Option<f32> {
                    self.to_f64().as_ref().and_then(ToPrimitive::to_f32)
                }
                /// Converts the value of `self` to an `f64`. Overflows may map to positive
                /// or negative inifinity, otherwise `None` is returned if the value cannot
                /// be represented by an `f64`.
                #[inline] fn to_f64(&self) -> Option<f64> {
                    match self.to_i64() {
                        Some(i) => i.to_f64(),
                        None => self.to_u64().as_ref().and_then(ToPrimitive::to_f64),
                    }
                }
            }

            macro_rules! impl_to_primitive_int_to_int {
                ($SrcT:ident : $( $(#[$cfg:meta])* fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$DstT> {
                        let min = $DstT::MIN as $SrcT;
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_int_to_uint {
                ($SrcT:ident : $( $(#[$cfg:meta])* fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_int {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_int_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_int_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline] fn to_f32(&self) -> Option<f32> {
                            Some(*self as f32)
                        }
                        #[inline] fn to_f64(&self) -> Option<f64> {
                            Some(*self as f64)
                        }
                    }
                };
            }

            impl_to_primitive_int!(isize);
            impl_to_primitive_int!(i8);
            impl_to_primitive_int!(i16);
            impl_to_primitive_int!(i32);
            impl_to_primitive_int!(i64);
            impl_to_primitive_int!(i128);

            macro_rules! impl_to_primitive_uint_to_int {
                ($SrcT:ident : $( $(#[$cfg:meta])* fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_uint_to_uint {
                ($SrcT:ident : $( $(#[$cfg:meta])* fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_uint {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_uint_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_uint_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline] fn to_f32(&self) -> Option<f32> {
                            Some(*self as f32)
                        }
                        #[inline] fn to_f64(&self) -> Option<f64> {
                            Some(*self as f64)
                        }
                    }
                };
            }

            impl_to_primitive_uint!(usize);
            impl_to_primitive_uint!(u8);
            impl_to_primitive_uint!(u16);
            impl_to_primitive_uint!(u32);
            impl_to_primitive_uint!(u64);
            impl_to_primitive_uint!(u128);

            macro_rules! impl_to_primitive_float_to_float {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline] fn $method(&self) -> Option<$DstT> {
                        // We can safely cast all values, whether NaN, +-inf, or finite.
                        // Finite values that are reducing size may saturate to +-inf.
                        Some(*self as $DstT)
                    }
                )*}
            }

            macro_rules! float_to_int_unchecked {
                // SAFETY: Must not be NaN or infinite; must be representable as the integer after truncating.
                // We already checked that the float is in the exclusive range `(MIN-1, MAX+1)`.
                ($float:expr => $int:ty) => {
                    unsafe { $float.to_int_unchecked::<$int>() }
                };
            }

            macro_rules! impl_to_primitive_float_to_signed_int {
                ($f:ident : $( $(#[$cfg:meta])* fn $method:ident -> $i:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$i> {
                        // Float as int truncates toward zero, so we want to allow values
                        // in the exclusive range `(MIN-1, MAX+1)`.
                        if size_of::<$f>() > size_of::<$i>() {
                            // With a larger size, we can represent the range exactly.
                            const MIN_M1: $f = $i::MIN as $f - 1.0;
                            const MAX_P1: $f = $i::MAX as $f + 1.0;
                            if *self > MIN_M1 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $i));
                            }
                        } else {
                            // We can't represent `MIN-1` exactly, but there's no fractional part
                            // at this magnitude, so we can just use a `MIN` inclusive boundary.
                            const MIN: $f = $i::MIN as $f;
                            // We can't represent `MAX` exactly, but it will round up to exactly
                            // `MAX+1` (a power of two) when we cast it.
                            const MAX_P1: $f = $i::MAX as $f;
                            if *self >= MIN && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $i));
                            }
                        }
                        None
                    }
                )*}
            }

            macro_rules! impl_to_primitive_float_to_unsigned_int {
                ($f:ident : $( $(#[$cfg:meta])* fn $method:ident -> $u:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$u> {
                        // Float as int truncates toward zero, so we want to allow values
                        // in the exclusive range `(-1, MAX+1)`.
                        if size_of::<$f>() > size_of::<$u>() {
                            // With a larger size, we can represent the range exactly.
                            const MAX_P1: $f = $u::MAX as $f + 1.0;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $u));
                            }
                        } else {
                            // We can't represent `MAX` exactly, but it will round up to exactly
                            // `MAX+1` (a power of two) when we cast it.
                            // (`u128::MAX as f32` is infinity, but this is still ok.)
                            const MAX_P1: $f = $u::MAX as $f;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $u));
                            }
                        }
                        None
                    }
                )*}
            }

            macro_rules! impl_to_primitive_float {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_float_to_signed_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_float_to_unsigned_int! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        impl_to_primitive_float_to_float! { $T:
                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }

            impl_to_primitive_float!(f32);
            impl_to_primitive_float!(f64);
            /// A generic trait for converting a number to a value.
            pub trait FromPrimitive: Sized {
                /// Converts an `isize` to return an optional value of this type.
                #[inline] fn from_isize(n: isize) -> Option<Self> {
                    n.to_i64().and_then(FromPrimitive::from_i64)
                }
                /// Converts an `i8` to return an optional value of this type.
                #[inline] fn from_i8(n: i8) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }
                /// Converts an `i16` to return an optional value of this type.
                #[inline] fn from_i16(n: i16) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }
                /// Converts an `i32` to return an optional value of this type.
                #[inline] fn from_i32(n: i32) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }
                /// Converts an `i64` to return an optional value of this type.
                fn from_i64(n: i64) -> Option<Self>;
                /// Converts an `i128` to return an optional value of this type.
                ///
                /// The default implementation converts through `from_i64()`.
                #[inline] fn from_i128(n: i128) -> Option<Self> {
                    n.to_i64().and_then(FromPrimitive::from_i64)
                }
                /// Converts a `usize` to return an optional value of this type.
                #[inline] fn from_usize(n: usize) -> Option<Self> {
                    n.to_u64().and_then(FromPrimitive::from_u64)
                }
                /// Converts an `u8` to return an optional value of this type.
                #[inline] fn from_u8(n: u8) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }
                /// Converts an `u16` to return an optional value of this type.
                #[inline] fn from_u16(n: u16) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }
                /// Converts an `u32` to return an optional value of this type.
                #[inline] fn from_u32(n: u32) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }
                /// Converts an `u64` to return an optional value of this type.
                fn from_u64(n: u64) -> Option<Self>;
                /// Converts an `u128` to return an optional value of this type.
                ///
                /// The default implementation converts through `from_u64()`.
                #[inline] fn from_u128(n: u128) -> Option<Self> {
                    n.to_u64().and_then(FromPrimitive::from_u64)
                }
                /// Converts a `f32` to return an optional value of this type.
                #[inline] fn from_f32(n: f32) -> Option<Self> {
                    FromPrimitive::from_f64(From::from(n))
                }
                /// Converts a `f64` to return an optional value of this type.
                #[inline] fn from_f64(n: f64) -> Option<Self> {
                    match n.to_i64() {
                        Some(i) => FromPrimitive::from_i64(i),
                        None => n.to_u64().and_then(FromPrimitive::from_u64),
                    }
                }
            }

            macro_rules! impl_from_primitive {
                ($T:ty, $to_ty:ident) => {
                    #[allow(deprecated)]
                    impl FromPrimitive for $T {
                        #[inline] fn from_isize(n: isize) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i8(n: i8) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i16(n: i16) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i32(n: i32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i64(n: i64) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i128(n: i128) -> Option<$T> {
                            n.$to_ty()
                        }

                        #[inline] fn from_usize(n: usize) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u8(n: u8) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u16(n: u16) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u32(n: u32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u64(n: u64) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u128(n: u128) -> Option<$T> {
                            n.$to_ty()
                        }

                        #[inline] fn from_f32(n: f32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_f64(n: f64) -> Option<$T> {
                            n.$to_ty()
                        }
                    }
                };
            }

            impl_from_primitive!(isize, to_isize);
            impl_from_primitive!(i8, to_i8);
            impl_from_primitive!(i16, to_i16);
            impl_from_primitive!(i32, to_i32);
            impl_from_primitive!(i64, to_i64);
            impl_from_primitive!(i128, to_i128);
            impl_from_primitive!(usize, to_usize);
            impl_from_primitive!(u8, to_u8);
            impl_from_primitive!(u16, to_u16);
            impl_from_primitive!(u32, to_u32);
            impl_from_primitive!(u64, to_u64);
            impl_from_primitive!(u128, to_u128);
            impl_from_primitive!(f32, to_f32);
            impl_from_primitive!(f64, to_f64);

            macro_rules! impl_to_primitive_wrapping {
                ($( $(#[$cfg:meta])* fn $method:ident -> $i:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$i> {
                        (self.0).$method()
                    }
                )*}
            }

            impl<T: ToPrimitive> ToPrimitive for Wrapping<T> {
                impl_to_primitive_wrapping! {
                    fn to_isize -> isize;
                    fn to_i8 -> i8;
                    fn to_i16 -> i16;
                    fn to_i32 -> i32;
                    fn to_i64 -> i64;
                    fn to_i128 -> i128;

                    fn to_usize -> usize;
                    fn to_u8 -> u8;
                    fn to_u16 -> u16;
                    fn to_u32 -> u32;
                    fn to_u64 -> u64;
                    fn to_u128 -> u128;

                    fn to_f32 -> f32;
                    fn to_f64 -> f64;
                }
            }

            macro_rules! impl_from_primitive_wrapping {
                ($( $(#[$cfg:meta])* fn $method:ident ( $i:ident ); )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(n: $i) -> Option<Self> {
                        T::$method(n).map(Wrapping)
                    }
                )*}
            }

            impl<T: FromPrimitive> FromPrimitive for Wrapping<T> {
                impl_from_primitive_wrapping! {
                    fn from_isize(isize);
                    fn from_i8(i8);
                    fn from_i16(i16);
                    fn from_i32(i32);
                    fn from_i64(i64);
                    fn from_i128(i128);

                    fn from_usize(usize);
                    fn from_u8(u8);
                    fn from_u16(u16);
                    fn from_u32(u32);
                    fn from_u64(u64);
                    fn from_u128(u128);

                    fn from_f32(f32);
                    fn from_f64(f64);
                }
            }
            /// Cast from one machine scalar to another.
            #[inline] pub fn cast<T: NumCast, U: NumCast>(n: T) -> Option<U> {
                NumCast::from(n)
            }
            /// An interface for casting between machine scalars.
            pub trait NumCast: Sized + ToPrimitive {
                /// Creates a number from another value that can be converted into
                /// a primitive via the `ToPrimitive` trait.
                fn from<T: ToPrimitive>(n: T) -> Option<Self>;
            }

            macro_rules! impl_num_cast {
                ($T:ty, $conv:ident) => {
                    impl NumCast for $T {
                        #[inline]
                        #[allow(deprecated)]
                        fn from<N: ToPrimitive>(n: N) -> Option<$T> {
                            // `$conv` could be generated using `concat_idents!`, but that
                            // macro seems to be broken at the moment
                            n.$conv()
                        }
                    }
                };
            }

            impl_num_cast!(u8, to_u8);
            impl_num_cast!(u16, to_u16);
            impl_num_cast!(u32, to_u32);
            impl_num_cast!(u64, to_u64);
            impl_num_cast!(u128, to_u128);
            impl_num_cast!(usize, to_usize);
            impl_num_cast!(i8, to_i8);
            impl_num_cast!(i16, to_i16);
            impl_num_cast!(i32, to_i32);
            impl_num_cast!(i64, to_i64);
            impl_num_cast!(i128, to_i128);
            impl_num_cast!(isize, to_isize);
            impl_num_cast!(f32, to_f32);
            impl_num_cast!(f64, to_f64);

            impl<T: NumCast> NumCast for Wrapping<T> {
                fn from<U: ToPrimitive>(n: U) -> Option<Self> {
                    T::from(n).map(Wrapping)
                }
            }
            /// A generic interface for casting between machine scalars with the
            /// `as` operator, which admits narrowing and precision loss.
            pub trait AsPrimitive<T>: 'static + Copy where
                T: 'static + Copy,
            {
                /// Convert a value to another, using the `as` operator.
                fn as_(self) -> T;
            }

            macro_rules! impl_as_primitive {
                (@ $T: ty => $(#[$cfg:meta])* impl $U: ty ) => {
                    $(#[$cfg])*
                    impl AsPrimitive<$U> for $T {
                        #[inline] fn as_(self) -> $U { self as $U }
                    }
                };
                (@ $T: ty => { $( $U: ty ),* } ) => {$(
                    impl_as_primitive!(@ $T => impl $U);
                )*};
                ($T: ty => { $( $U: ty ),* } ) => {
                    impl_as_primitive!(@ $T => { $( $U ),* });
                    impl_as_primitive!(@ $T => { u8, u16, u32, u64, u128, usize });
                    impl_as_primitive!(@ $T => { i8, i16, i32, i64, i128, isize });
                };
            }

            impl_as_primitive!(u8 => { char, f32, f64 });
            impl_as_primitive!(i8 => { f32, f64 });
            impl_as_primitive!(u16 => { f32, f64 });
            impl_as_primitive!(i16 => { f32, f64 });
            impl_as_primitive!(u32 => { f32, f64 });
            impl_as_primitive!(i32 => { f32, f64 });
            impl_as_primitive!(u64 => { f32, f64 });
            impl_as_primitive!(i64 => { f32, f64 });
            impl_as_primitive!(u128 => { f32, f64 });
            impl_as_primitive!(i128 => { f32, f64 });
            impl_as_primitive!(usize => { f32, f64 });
            impl_as_primitive!(isize => { f32, f64 });
            impl_as_primitive!(f32 => { f32, f64 });
            impl_as_primitive!(f64 => { f32, f64 });
            impl_as_primitive!(char => { char });
            impl_as_primitive!(bool => {});
        } pub use self::cast::{ * };

        pub mod float
        {
            use ::
            {
                cmp::Ordering,
                num::
                { 
                    traits::
                    {
                        Num, NumCast, ToPrimitive
                    },
                    FpCategory 
                },
                ops::{ Add, Div, Neg },
                *,
            };
            /// Generic trait for floating point numbers that works with `no_std`.
            pub trait FloatCore: Num + NumCast + Neg<Output = Self> + PartialOrd + Copy 
            {
                /// Returns positive infinity.
                fn infinity() -> Self;
                /// Returns negative infinity.
                fn neg_infinity() -> Self;
                /// Returns NaN.
                fn nan() -> Self;
                /// Returns `-0.0`.
                fn neg_zero() -> Self;
                /// Returns the smallest finite value that this type can represent.
                fn min_value() -> Self;
                /// Returns the smallest positive, normalized value that this type can represent.
                fn min_positive_value() -> Self;
                /// Returns epsilon, a small positive value.
                fn epsilon() -> Self;
                /// Returns the largest finite value that this type can represent.
                fn max_value() -> Self;
                /// Returns `true` if the number is NaN.
                #[inline] fn is_nan(self) -> bool
                {
                    self != self
                }
                /// Returns `true` if the number is infinite.
                #[inline] fn is_infinite(self) -> bool {
                    self == Self::infinity() || self == Self::neg_infinity()
                }
                /// Returns `true` if the number is neither infinite or NaN.
                #[inline] fn is_finite(self) -> bool {
                    !(self.is_nan() || self.is_infinite())
                }
                /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.
                #[inline] fn is_normal(self) -> bool {
                    self.classify() == FpCategory::Normal
                }
                /// Returns `true` if the number is [subnormal].
                #[inline] fn is_subnormal(self) -> bool {
                    self.classify() == FpCategory::Subnormal
                }
                /// Returns the floating point category of the number.
                fn classify(self) -> FpCategory;
                /// Returns the largest integer less than or equal to a number.
                #[inline] fn floor(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self < Self::zero() {
                        self - f - Self::one()
                    } else {
                        self - f
                    }
                }
                /// Returns the smallest integer greater than or equal to a number.
                #[inline] fn ceil(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        self - f + Self::one()
                    } else {
                        self - f
                    }
                }
                /// Returns the nearest integer to a number. Round half-way cases away from `0.0`.
                #[inline] fn round(self) -> Self {
                    let one = Self::one();
                    let h = Self::from(0.5).expect("Unable to cast from 0.5");
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        if f < h {
                            self - f
                        } else {
                            self - f + one
                        }
                    } else if -f < h {
                        self - f
                    } else {
                        self - f - one
                    }
                }
                /// Return the integer part of a number.
                #[inline] fn trunc(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() {
                        self
                    } else {
                        self - f
                    }
                }
                /// Returns the fractional part of a number.
                #[inline] fn fract(self) -> Self {
                    if self.is_zero() {
                        Self::zero()
                    } else {
                        self % Self::one()
                    }
                }
                /// Computes the absolute value of `self`.
                #[inline] fn abs(self) -> Self {
                    if self.is_sign_positive() {
                        return self;
                    }
                    if self.is_sign_negative() {
                        return -self;
                    }
                    Self::nan()
                }
                /// Returns a number that represents the sign of `self`.
                #[inline] fn signum(self) -> Self {
                    if self.is_nan() {
                        Self::nan()
                    } else if self.is_sign_negative() {
                        -Self::one()
                    } else {
                        Self::one()
                    }
                }
                /// Returns `true` if `self` is positive, including `+0.0` and
                /// `FloatCore::infinity()`, and `FloatCore::nan()`.
                #[inline] fn is_sign_positive(self) -> bool {
                    !self.is_sign_negative()
                }
                /// Returns `true` if `self` is negative, including `-0.0` and
                /// `FloatCore::neg_infinity()`, and `-FloatCore::nan()`.
                #[inline] fn is_sign_negative(self) -> bool {
                    let (_, _, sign) = self.integer_decode();
                    sign < 0
                }
                /// Returns the minimum of the two numbers.
                #[inline] fn min(self, other: Self) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self < other {
                        self
                    } else {
                        other
                    }
                }
                /// Returns the maximum of the two numbers.
                #[inline] fn max(self, other: Self) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self > other {
                        self
                    } else {
                        other
                    }
                }
                /// A value bounded by a minimum and a maximum
                fn clamp(self, min: Self, max: Self) -> Self {
                    ::num::traits::clamp(self, min, max)
                }
                /// Returns the reciprocal (multiplicative inverse) of the number.
                #[inline] fn recip(self) -> Self {
                    Self::one() / self
                }
                /// Raise a number to an integer power.
                #[inline] fn powi(mut self, mut exp: i32) -> Self {
                    if exp < 0 {
                        exp = exp.wrapping_neg();
                        self = self.recip();
                    }
                    
                    super::pow(self, (exp as u32).to_usize().unwrap())
                }
                /// Converts to degrees, assuming the number is in radians.
                fn to_degrees(self) -> Self;
                /// Converts to radians, assuming the number is in degrees.
                fn to_radians(self) -> Self;
                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.
                fn integer_decode(self) -> (u64, i16, i8);
            }

            impl FloatCore for f32 {
                constant! {
                    infinity() -> f32::INFINITY;
                    neg_infinity() -> f32::NEG_INFINITY;
                    nan() -> f32::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f32::MIN;
                    min_positive_value() -> f32::MIN_POSITIVE;
                    epsilon() -> f32::EPSILON;
                    max_value() -> f32::MAX;
                }

                #[inline] fn integer_decode(self) -> (u64, i16, i8) {
                    integer_decode_f32(self)
                }

                forward! {
                    Self::is_nan(self) -> bool;
                    Self::is_infinite(self) -> bool;
                    Self::is_finite(self) -> bool;
                    Self::is_normal(self) -> bool;
                    Self::is_subnormal(self) -> bool;
                    Self::clamp(self, min: Self, max: Self) -> Self;
                    Self::classify(self) -> FpCategory;
                    Self::is_sign_positive(self) -> bool;
                    Self::is_sign_negative(self) -> bool;
                    Self::min(self, other: Self) -> Self;
                    Self::max(self, other: Self) -> Self;
                    Self::recip(self) -> Self;
                    Self::to_degrees(self) -> Self;
                    Self::to_radians(self) -> Self;
                }
                
                forward! {
                    Self::floor(self) -> Self;
                    Self::ceil(self) -> Self;
                    Self::round(self) -> Self;
                    Self::trunc(self) -> Self;
                    Self::fract(self) -> Self;
                    Self::abs(self) -> Self;
                    Self::signum(self) -> Self;
                    Self::powi(self, n: i32) -> Self;
                }
            }

            impl FloatCore for f64 {
                constant! {
                    infinity() -> f64::INFINITY;
                    neg_infinity() -> f64::NEG_INFINITY;
                    nan() -> f64::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f64::MIN;
                    min_positive_value() -> f64::MIN_POSITIVE;
                    epsilon() -> f64::EPSILON;
                    max_value() -> f64::MAX;
                }

                #[inline] fn integer_decode(self) -> (u64, i16, i8) {
                    integer_decode_f64(self)
                }

                forward! {
                    Self::is_nan(self) -> bool;
                    Self::is_infinite(self) -> bool;
                    Self::is_finite(self) -> bool;
                    Self::is_normal(self) -> bool;
                    Self::is_subnormal(self) -> bool;
                    Self::clamp(self, min: Self, max: Self) -> Self;
                    Self::classify(self) -> FpCategory;
                    Self::is_sign_positive(self) -> bool;
                    Self::is_sign_negative(self) -> bool;
                    Self::min(self, other: Self) -> Self;
                    Self::max(self, other: Self) -> Self;
                    Self::recip(self) -> Self;
                    Self::to_degrees(self) -> Self;
                    Self::to_radians(self) -> Self;
                }
                
                forward! {
                    Self::floor(self) -> Self;
                    Self::ceil(self) -> Self;
                    Self::round(self) -> Self;
                    Self::trunc(self) -> Self;
                    Self::fract(self) -> Self;
                    Self::abs(self) -> Self;
                    Self::signum(self) -> Self;
                    Self::powi(self, n: i32) -> Self;
                }
            }
            /// Generic trait for floating point numbers
            pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> 
            {
                /// Returns the `NaN` value.
                fn infinity() -> Self;
                /// Returns NaN.
                fn nan() -> Self;
                /// Returns the negative infinite value.
                fn neg_infinity() -> Self;
                /// Returns `-0.0`.
                fn neg_zero() -> Self;
                /// Returns the smallest finite value that this type can represent.
                fn min_value() -> Self;
                /// Returns the smallest positive, normalized value that this type can represent.
                fn min_positive_value() -> Self;
                /// Returns epsilon, a small positive value.
                fn epsilon() -> Self {
                    Self::from(f32::EPSILON).expect("Unable to cast from f32::EPSILON")
                }
                /// Returns the largest finite value that this type can represent.
                fn max_value() -> Self;
                /// Returns `true` if this value is `NaN` and false otherwise.
                fn is_nan(self) -> bool;
                /// `true` if this value is positive infinity or negative infinity and
                /// `false` otherwise.
                fn is_infinite(self) -> bool;
                /// Returns `true` if this number is neither infinite nor `NaN`.
                fn is_finite(self) -> bool;
                /// Returns `true` if the number is neither zero, infinite,
                /// [subnormal][subnormal], or `NaN`.
                fn is_normal(self) -> bool;
                /// Returns `true` if the number is [subnormal].
                #[inline] fn is_subnormal(self) -> bool {
                    self.classify() == FpCategory::Subnormal
                }
                /// Returns the floating point category of the number.
                fn classify(self) -> FpCategory;
                /// Returns the largest integer less than or equal to a number.
                fn floor(self) -> Self;
                /// Returns the smallest integer greater than or equal to a number.
                fn ceil(self) -> Self;
                /// Returns the nearest integer to a number. Round half-way cases away from
                /// `0.0`.
                fn round(self) -> Self;
                /// Return the integer part of a number.
                fn trunc(self) -> Self;
                /// Returns the fractional part of a number.
                fn fract(self) -> Self;
                /// Computes the absolute value of `self`.
                fn abs(self) -> Self;
                /// Returns a number that represents the sign of `self`.
                fn signum(self) -> Self;
                /// Returns `true` if `self` is positive, including `+0.0`,
                /// `Float::infinity()`, and `Float::nan()`.
                fn is_sign_positive(self) -> bool;
                /// Returns `true` if `self` is negative, including `-0.0`,
                /// `Float::neg_infinity()`, and `-Float::nan()`.
                fn is_sign_negative(self) -> bool;
                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                fn mul_add(self, a: Self, b: Self) -> Self;
                /// Take the reciprocal (inverse) of a number, `1/x`.
                fn recip(self) -> Self;
                /// Raise a number to an integer power.
                fn powi(self, n: i32) -> Self;
                /// Raise a number to a floating point power.
                fn powf(self, n: Self) -> Self;
                /// Take the square root of a number.
                fn sqrt(self) -> Self;
                /// Returns `e^(self)`, (the exponential function).
                fn exp(self) -> Self;
                /// Returns `2^(self)`.
                fn exp2(self) -> Self;
                /// Returns the natural logarithm of the number.
                fn ln(self) -> Self;
                /// Returns the logarithm of the number with respect to an arbitrary base.
                fn log(self, base: Self) -> Self;
                /// Returns the base 2 logarithm of the number.
                fn log2(self) -> Self;
                /// Returns the base 10 logarithm of the number.
                fn log10(self) -> Self;
                /// Converts radians to degrees.
                #[inline] fn to_degrees(self) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from(90u8).unwrap();
                    self * ninety / halfpi
                }
                /// Converts degrees to radians.
                #[inline] fn to_radians(self) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from(90u8).unwrap();
                    self * halfpi / ninety
                }
                /// Returns the maximum of the two numbers.
                fn max(self, other: Self) -> Self;
                /// Returns the minimum of the two numbers.
                fn min(self, other: Self) -> Self;
                /// Clamps a value between a min and max.
                fn clamp(self, min: Self, max: Self) -> Self {
                    ::num::traits::clamp(self, min, max)
                }
                /// The positive difference of two numbers.
                fn abs_sub(self, other: Self) -> Self;
                /// Take the cubic root of a number.
                fn cbrt(self) -> Self;
                /// Calculate the length of the hypotenuse of a right-angle triangle given
                /// legs of length `x` and `y`.
                fn hypot(self, other: Self) -> Self;
                /// Computes the sine of a number (in radians).
                fn sin(self) -> Self;
                /// Computes the cosine of a number (in radians).
                fn cos(self) -> Self;
                /// Computes the tangent of a number (in radians).
                fn tan(self) -> Self;
                /// Computes the arcsine of a number.
                fn asin(self) -> Self;
                /// Computes the arccosine of a number.
                fn acos(self) -> Self;
                /// Computes the arctangent of a number.
                fn atan(self) -> Self;
                /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).
                fn atan2(self, other: Self) -> Self;
                /// Simultaneously computes the sine and cosine of the number, `x`.
                fn sin_cos(self) -> (Self, Self);
                /// Returns `e^(self) - 1` in a way that is accurate even if the
                /// number is close to zero.
                fn exp_m1(self) -> Self;
                /// Returns `ln(1+n)` (natural logarithm) more accurately than if
                /// the operations were performed separately.
                fn ln_1p(self) -> Self;
                /// Hyperbolic sine function.
                fn sinh(self) -> Self;
                /// Hyperbolic cosine function.
                fn cosh(self) -> Self;
                /// Hyperbolic tangent function.
                fn tanh(self) -> Self;
                /// Inverse hyperbolic sine function.
                fn asinh(self) -> Self;
                /// Inverse hyperbolic cosine function.
                fn acosh(self) -> Self;
                /// Inverse hyperbolic tangent function.
                fn atanh(self) -> Self;
                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                fn integer_decode(self) -> (u64, i16, i8);
                /// Returns a number composed of the magnitude of `self` and the sign of
                /// `sign`.
                fn copysign(self, sign: Self) -> Self {
                    if self.is_sign_negative() == sign.is_sign_negative() {
                        self
                    } else {
                        self.neg()
                    }
                }
            }
            
            macro_rules! float_impl_std {
                ($T:ident $decode:ident) => {
                    impl Float for $T {
                        constant! {
                            nan() -> $T::NAN;
                            infinity() -> $T::INFINITY;
                            neg_infinity() -> $T::NEG_INFINITY;
                            neg_zero() -> -0.0;
                            min_value() -> $T::MIN;
                            min_positive_value() -> $T::MIN_POSITIVE;
                            epsilon() -> $T::EPSILON;
                            max_value() -> $T::MAX;
                        }

                        #[inline]
                        #[allow(deprecated)]
                        fn abs_sub(self, other: Self) -> Self {
                            <$T>::abs_sub(self, other)
                        }

                        #[inline] fn integer_decode(self) -> (u64, i16, i8) {
                            $decode(self)
                        }

                        forward! {
                            Self::is_nan(self) -> bool;
                            Self::is_infinite(self) -> bool;
                            Self::is_finite(self) -> bool;
                            Self::is_normal(self) -> bool;
                            Self::is_subnormal(self) -> bool;
                            Self::classify(self) -> FpCategory;
                            Self::clamp(self, min: Self, max: Self) -> Self;
                            Self::floor(self) -> Self;
                            Self::ceil(self) -> Self;
                            Self::round(self) -> Self;
                            Self::trunc(self) -> Self;
                            Self::fract(self) -> Self;
                            Self::abs(self) -> Self;
                            Self::signum(self) -> Self;
                            Self::is_sign_positive(self) -> bool;
                            Self::is_sign_negative(self) -> bool;
                            Self::mul_add(self, a: Self, b: Self) -> Self;
                            Self::recip(self) -> Self;
                            Self::powi(self, n: i32) -> Self;
                            Self::powf(self, n: Self) -> Self;
                            Self::sqrt(self) -> Self;
                            Self::exp(self) -> Self;
                            Self::exp2(self) -> Self;
                            Self::ln(self) -> Self;
                            Self::log(self, base: Self) -> Self;
                            Self::log2(self) -> Self;
                            Self::log10(self) -> Self;
                            Self::to_degrees(self) -> Self;
                            Self::to_radians(self) -> Self;
                            Self::max(self, other: Self) -> Self;
                            Self::min(self, other: Self) -> Self;
                            Self::cbrt(self) -> Self;
                            Self::hypot(self, other: Self) -> Self;
                            Self::sin(self) -> Self;
                            Self::cos(self) -> Self;
                            Self::tan(self) -> Self;
                            Self::asin(self) -> Self;
                            Self::acos(self) -> Self;
                            Self::atan(self) -> Self;
                            Self::atan2(self, other: Self) -> Self;
                            Self::sin_cos(self) -> (Self, Self);
                            Self::exp_m1(self) -> Self;
                            Self::ln_1p(self) -> Self;
                            Self::sinh(self) -> Self;
                            Self::cosh(self) -> Self;
                            Self::tanh(self) -> Self;
                            Self::asinh(self) -> Self;
                            Self::acosh(self) -> Self;
                            Self::atanh(self) -> Self;
                            Self::copysign(self, sign: Self) -> Self;
                        }
                    }
                };
            }
            
            fn integer_decode_f32(f: f32) -> (u64, i16, i8) {
                let bits: u32 = f.to_bits();
                let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;
                let mantissa = if exponent == 0 {
                    (bits & 0x7fffff) << 1
                } else {
                    (bits & 0x7fffff) | 0x800000
                };
                // Exponent bias + mantissa shift
                exponent -= 127 + 23;
                (mantissa as u64, exponent, sign)
            }

            fn integer_decode_f64(f: f64) -> (u64, i16, i8) {
                let bits: u64 = f.to_bits();
                let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;
                let mantissa = if exponent == 0 {
                    (bits & 0xfffffffffffff) << 1
                } else {
                    (bits & 0xfffffffffffff) | 0x10000000000000
                };
                // Exponent bias + mantissa shift
                exponent -= 1023 + 52;
                (mantissa, exponent, sign)
            }
            
            float_impl_std!(f32 integer_decode_f32);
            
            float_impl_std!(f64 integer_decode_f64);

            macro_rules! float_const_impl
            {
                ($(#[$doc:meta] $constant:ident,)+) => (
                    #[allow(non_snake_case)]
                    pub trait FloatConst {
                        $(#[$doc] fn $constant() -> Self;)+
                        #[doc = "Return the full circle constant `τ`."]
                        #[inline] fn TAU() -> Self where Self: Sized + Add<Self, Output = Self> {
                            Self::PI() + Self::PI()
                        }
                        #[doc = "Return `log10(2.0)`."]
                        #[inline] fn LOG10_2() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_2() / Self::LN_10()
                        }
                        #[doc = "Return `log2(10.0)`."]
                        #[inline] fn LOG2_10() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_10() / Self::LN_2()
                        }
                    }
                    float_const_impl! { @float f32, $($constant,)+ }
                    float_const_impl! { @float f64, $($constant,)+ }
                );
                (@float $T:ident, $($constant:ident,)+) => (
                    impl FloatConst for $T {
                        constant! {
                            $( $constant() -> std::$T::consts::$constant; )+
                            TAU() -> 6.28318530717958647692528676655900577;
                            LOG10_2() -> 0.301029995663981195213738894724493027;
                            LOG2_10() -> 3.32192809488736234787031942948939018;
                        }
                    }
                );
            }

            float_const_impl! {
                #[doc = "Return Euler’s number."]
                E,
                #[doc = "Return `1.0 / π`."]
                FRAC_1_PI,
                #[doc = "Return `1.0 / sqrt(2.0)`."]
                FRAC_1_SQRT_2,
                #[doc = "Return `2.0 / π`."]
                FRAC_2_PI,
                #[doc = "Return `2.0 / sqrt(π)`."]
                FRAC_2_SQRT_PI,
                #[doc = "Return `π / 2.0`."]
                FRAC_PI_2,
                #[doc = "Return `π / 3.0`."]
                FRAC_PI_3,
                #[doc = "Return `π / 4.0`."]
                FRAC_PI_4,
                #[doc = "Return `π / 6.0`."]
                FRAC_PI_6,
                #[doc = "Return `π / 8.0`."]
                FRAC_PI_8,
                #[doc = "Return `ln(10.0)`."]
                LN_10,
                #[doc = "Return `ln(2.0)`."]
                LN_2,
                #[doc = "Return `log10(e)`."]
                LOG10_E,
                #[doc = "Return `log2(e)`."]
                LOG2_E,
                #[doc = "Return Archimedes’ constant `π`."]
                PI,
                #[doc = "Return `sqrt(2.0)`."]
                SQRT_2,
            }
            /// Trait for floating point numbers that provide an implementation
            /// of the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)
            /// floating point standard.
            pub trait TotalOrder 
            {
                /// Return the ordering between `self` and `other`.
                fn total_cmp(&self, other: &Self) -> Ordering;
            }

            macro_rules! totalorder_impl {
                ($T:ident, $I:ident, $U:ident, $bits:expr) => {
                    impl TotalOrder for $T {
                        #[inline]
                        #[cfg(has_total_cmp)]
                        fn total_cmp(&self, other: &Self) -> Ordering {
                            // Forward to the core implementation
                            Self::total_cmp(&self, other)
                        }
                        #[inline]
                        #[cfg(not(has_total_cmp))]
                        fn total_cmp(&self, other: &Self) -> Ordering {
                            // Backport the core implementation (since 1.62)
                            let mut left = self.to_bits() as $I;
                            let mut right = other.to_bits() as $I;

                            left ^= (((left >> ($bits - 1)) as $U) >> 1) as $I;
                            right ^= (((right >> ($bits - 1)) as $U) >> 1) as $I;

                            left.cmp(&right)
                        }
                    }
                };
            }
            totalorder_impl!(f64, i64, u64, 64);
            totalorder_impl!(f32, i32, u32, 32);
        } pub use self::float::{ * };

        pub mod identities
        {
            use ::
            {
                num::
                {
                    Wrapping 
                },
                ops::{ Add, Mul },
                *,
            };
            /// Defines an additive identity element for `Self`.
            pub trait Zero: Sized + Add<Self, Output = Self> {
                /// Returns the additive identity element of `Self`, `0`.
                fn zero() -> Self;
                /// Sets `self` to the additive identity element of `Self`, `0`.
                fn set_zero(&mut self) {
                    *self = Zero::zero();
                }
                /// Returns `true` if `self` is equal to the additive identity.
                fn is_zero(&self) -> bool;
            }
            /// Defines an associated constant representing the additive identity element
            /// for `Self`.
            pub trait ConstZero: Zero {
                /// The additive identity element of `Self`, `0`.
                const ZERO: Self;
            }

            macro_rules! zero_impl {
                ($t:ty, $v:expr) => {
                    impl Zero for $t {
                        #[inline] fn zero() -> $t {
                            $v
                        }
                        #[inline] fn is_zero(&self) -> bool {
                            *self == $v
                        }
                    }

                    impl ConstZero for $t {
                        const ZERO: Self = $v;
                    }
                };
            }

            zero_impl!(usize, 0);
            zero_impl!(u8, 0);
            zero_impl!(u16, 0);
            zero_impl!(u32, 0);
            zero_impl!(u64, 0);
            zero_impl!(u128, 0);

            zero_impl!(isize, 0);
            zero_impl!(i8, 0);
            zero_impl!(i16, 0);
            zero_impl!(i32, 0);
            zero_impl!(i64, 0);
            zero_impl!(i128, 0);

            zero_impl!(f32, 0.0);
            zero_impl!(f64, 0.0);

            impl<T: Zero> Zero for Wrapping<T> where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                fn is_zero(&self) -> bool {
                    self.0.is_zero()
                }

                fn set_zero(&mut self) {
                    self.0.set_zero();
                }

                fn zero() -> Self {
                    Wrapping(T::zero())
                }
            }

            impl<T: ConstZero> ConstZero for Wrapping<T> where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                const ZERO: Self = Wrapping(T::ZERO);
            }
            /// Defines a multiplicative identity element for `Self`.
            pub trait One: Sized + Mul<Self, Output = Self> {
                /// Returns the multiplicative identity element of `Self`, `1`.
                fn one() -> Self;
                /// Sets `self` to the multiplicative identity element of `Self`, `1`.
                fn set_one(&mut self) {
                    *self = One::one();
                }
                /// Returns `true` if `self` is equal to the multiplicative identity.
                #[inline] fn is_one(&self) -> bool
                where
                    Self: PartialEq,
                {
                    *self == Self::one()
                }
            }
            /// Defines an associated constant representing the multiplicative identity
            /// element for `Self`.
            pub trait ConstOne: One {
                /// The multiplicative identity element of `Self`, `1`.
                const ONE: Self;
            }

            macro_rules! one_impl {
                ($t:ty, $v:expr) => {
                    impl One for $t {
                        #[inline] fn one() -> $t {
                            $v
                        }
                        #[inline] fn is_one(&self) -> bool {
                            *self == $v
                        }
                    }

                    impl ConstOne for $t {
                        const ONE: Self = $v;
                    }
                };
            }

            one_impl!(usize, 1);
            one_impl!(u8, 1);
            one_impl!(u16, 1);
            one_impl!(u32, 1);
            one_impl!(u64, 1);
            one_impl!(u128, 1);

            one_impl!(isize, 1);
            one_impl!(i8, 1);
            one_impl!(i16, 1);
            one_impl!(i32, 1);
            one_impl!(i64, 1);
            one_impl!(i128, 1);

            one_impl!(f32, 1.0);
            one_impl!(f64, 1.0);

            impl<T: One> One for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                fn set_one(&mut self) {
                    self.0.set_one();
                }

                fn one() -> Self {
                    Wrapping(T::one())
                }
            }

            impl<T: ConstOne> ConstOne for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                const ONE: Self = Wrapping(T::ONE);
            }

            // Some helper functions provided for backwards compatibility.

            /// Returns the additive identity, `0`.
            #[inline( always )] pub fn zero<T: Zero>() -> T
                {    Zero::zero()
            }
            /// Returns the multiplicative identity, `1`.
            #[inline( always )] pub fn one<T: One>() -> T
                {    One::one()
            }
        } pub use self::identities::{ * };

        pub mod int
        {
            use ::
            {
                num::
                { 
                    traits::
                    {
                        bounds::Bounded,
                        ops::checked::*,
                        ops::saturating::Saturating,
                        Num, NumCast,
                    },
                    Wrapping 
                },
                ops::{ BitAnd, BitOr, BitXor, Not, Shl, Shr },
                *,
            };
            /// Generic trait for primitive integers.
            pub trait PrimInt:
                Sized
                + Copy
                + Num
                + NumCast
                + Bounded
                + PartialOrd
                + Ord
                + Eq
                + Not<Output = Self>
                + BitAnd<Output = Self>
                + BitOr<Output = Self>
                + BitXor<Output = Self>
                + Shl<usize, Output = Self>
                + Shr<usize, Output = Self>
                + CheckedAdd<Output = Self>
                + CheckedSub<Output = Self>
                + CheckedMul<Output = Self>
                + CheckedDiv<Output = Self>
                + Saturating
            {
                /// Returns the number of ones in the binary representation of `self`.
                fn count_ones(self) -> u32;
                /// Returns the number of zeros in the binary representation of `self`.
                fn count_zeros(self) -> u32;
                /// Returns the number of leading ones in the binary representation
                /// of `self`.
                fn leading_ones(self) -> u32 {
                    (!self).leading_zeros()
                }
                /// Returns the number of leading zeros in the binary representation
                /// of `self`.
                fn leading_zeros(self) -> u32;
                /// Returns the number of trailing ones in the binary representation
                /// of `self`.
                fn trailing_ones(self) -> u32 {
                    (!self).trailing_zeros()
                }
                /// Returns the number of trailing zeros in the binary representation
                /// of `self`.
                fn trailing_zeros(self) -> u32;
                /// Shifts the bits to the left by a specified amount, `n`, wrapping
                /// the truncated bits to the end of the resulting integer.
                fn rotate_left(self, n: u32) -> Self;
                /// Shifts the bits to the right by a specified amount, `n`, wrapping
                /// the truncated bits to the beginning of the resulting integer.
                fn rotate_right(self, n: u32) -> Self;
                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                fn signed_shl(self, n: u32) -> Self;
                /// Shifts the bits to the right by a specified amount, `n`, copying
                /// the "sign bit" in the most significant bits even for unsigned types.
                fn signed_shr(self, n: u32) -> Self;
                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                fn unsigned_shl(self, n: u32) -> Self;
                /// Shifts the bits to the right by a specified amount, `n`, filling
                /// zeros in the most significant bits.
                fn unsigned_shr(self, n: u32) -> Self;
                /// Reverses the byte order of the integer.
                fn swap_bytes(self) -> Self;
                /// Reverses the order of bits in the integer.
                fn reverse_bits(self) -> Self {
                    reverse_bits_fallback(self)
                }
                /// Convert an integer from big endian to the target's endianness.
                fn from_be(x: Self) -> Self;
                /// Convert an integer from little endian to the target's endianness.
                fn from_le(x: Self) -> Self;
                /// Convert `self` to big endian from the target's endianness.
                fn to_be(self) -> Self;
                /// Convert `self` to little endian from the target's endianness. 
                fn to_le(self) -> Self;
                /// Raises self to the power of `exp`, using exponentiation by squaring.
                fn pow(self, exp: u32) -> Self;
            }

            fn one_per_byte<P: PrimInt>() -> P {
                let mut ret = P::one();
                let mut shift = 8;
                let mut b = ret.count_zeros() >> 3;
                while b != 0 {
                    ret = (ret << shift) | ret;
                    shift <<= 1;
                    b >>= 1;
                }
                ret
            }

            fn reverse_bits_fallback<P: PrimInt>(i: P) -> P {
                let rep_01: P = one_per_byte();
                let rep_03 = (rep_01 << 1) | rep_01;
                let rep_05 = (rep_01 << 2) | rep_01;
                let rep_0f = (rep_03 << 2) | rep_03;
                let rep_33 = (rep_03 << 4) | rep_03;
                let rep_55 = (rep_05 << 4) | rep_05;

                // code above only used to determine rep_0f, rep_33, rep_55;
                // optimizer should be able to do it in compile time
                let mut ret = i.swap_bytes();
                ret = ((ret & rep_0f) << 4) | ((ret >> 4) & rep_0f);
                ret = ((ret & rep_33) << 2) | ((ret >> 2) & rep_33);
                ret = ((ret & rep_55) << 1) | ((ret >> 1) & rep_55);
                ret
            }

            macro_rules! prim_int_impl {
                ($T:ty, $S:ty, $U:ty) => {
                    impl PrimInt for $T {
                        #[inline] fn count_ones(self) -> u32 {
                            <$T>::count_ones(self)
                        }

                        #[inline] fn count_zeros(self) -> u32 {
                            <$T>::count_zeros(self)
                        }

                        #[inline] fn leading_ones(self) -> u32 {
                            <$T>::leading_ones(self)
                        }

                        #[inline] fn leading_zeros(self) -> u32 {
                            <$T>::leading_zeros(self)
                        }

                        #[inline] fn trailing_ones(self) -> u32 {
                            <$T>::trailing_ones(self)
                        }

                        #[inline] fn trailing_zeros(self) -> u32 {
                            <$T>::trailing_zeros(self)
                        }

                        #[inline] fn rotate_left(self, n: u32) -> Self {
                            <$T>::rotate_left(self, n)
                        }

                        #[inline] fn rotate_right(self, n: u32) -> Self {
                            <$T>::rotate_right(self, n)
                        }

                        #[inline] fn signed_shl(self, n: u32) -> Self {
                            ((self as $S) << n) as $T
                        }

                        #[inline] fn signed_shr(self, n: u32) -> Self {
                            ((self as $S) >> n) as $T
                        }

                        #[inline] fn unsigned_shl(self, n: u32) -> Self {
                            ((self as $U) << n) as $T
                        }

                        #[inline] fn unsigned_shr(self, n: u32) -> Self {
                            ((self as $U) >> n) as $T
                        }

                        #[inline] fn swap_bytes(self) -> Self {
                            <$T>::swap_bytes(self)
                        }

                        #[inline] fn reverse_bits(self) -> Self {
                            <$T>::reverse_bits(self)
                        }

                        #[inline] fn from_be(x: Self) -> Self {
                            <$T>::from_be(x)
                        }

                        #[inline] fn from_le(x: Self) -> Self {
                            <$T>::from_le(x)
                        }

                        #[inline] fn to_be(self) -> Self {
                            <$T>::to_be(self)
                        }

                        #[inline] fn to_le(self) -> Self {
                            <$T>::to_le(self)
                        }

                        #[inline] fn pow(self, exp: u32) -> Self {
                            <$T>::pow(self, exp)
                        }
                    }
                };
            }

            // prim_int_impl!(type, signed, unsigned);
            prim_int_impl!(u8, i8, u8);
            prim_int_impl!(u16, i16, u16);
            prim_int_impl!(u32, i32, u32);
            prim_int_impl!(u64, i64, u64);
            prim_int_impl!(u128, i128, u128);
            prim_int_impl!(usize, isize, usize);
            prim_int_impl!(i8, i8, u8);
            prim_int_impl!(i16, i16, u16);
            prim_int_impl!(i32, i32, u32);
            prim_int_impl!(i64, i64, u64);
            prim_int_impl!(i128, i128, u128);
            prim_int_impl!(isize, isize, usize);
        } pub use self::int::{ * };

        pub mod ops
        {
            pub mod bytes
            {
                use ::
                {
                    borrow::{Borrow, BorrowMut},
                    cmp::{Eq, Ord, PartialEq, PartialOrd},
                    fmt::Debug,
                    hash::Hash,
                    *,
                };
                
                pub trait NumBytes:
                    Debug
                    + AsRef<[u8]>
                    + AsMut<[u8]>
                    + PartialEq
                    + Eq
                    + PartialOrd
                    + Ord
                    + Hash
                    + Borrow<[u8]>
                    + BorrowMut<[u8]>
                {
                }

                impl<T> NumBytes for T where
                    T: Debug
                        + AsRef<[u8]>
                        + AsMut<[u8]>
                        + PartialEq
                        + Eq
                        + PartialOrd
                        + Ord
                        + Hash
                        + Borrow<[u8]>
                        + BorrowMut<[u8]>
                        + ?Sized
                {
                }

                pub trait ToBytes {
                    type Bytes: NumBytes;

                    /// Return the memory representation of this number as a byte array in big-endian byte order.
                    fn to_be_bytes(&self) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in little-endian byte order.
                    fn to_le_bytes(&self) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in native byte order.
                    fn to_ne_bytes(&self) -> Self::Bytes {
                        #[cfg(target_endian = "big")]
                        let bytes = self.to_be_bytes();
                        #[cfg(target_endian = "little")]
                        let bytes = self.to_le_bytes();
                        bytes
                    }
                }

                pub trait FromBytes: Sized {
                    type Bytes: NumBytes + ?Sized;

                    /// Create a number from its representation as a byte array in big endian.
                    fn from_be_bytes(bytes: &Self::Bytes) -> Self;

                    /// Create a number from its representation as a byte array in little endian.
                    fn from_le_bytes(bytes: &Self::Bytes) -> Self;

                    /// Create a number from its memory representation as a byte array in native endianness.
                    fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                        #[cfg(target_endian = "big")]
                        let this = Self::from_be_bytes(bytes);
                        #[cfg(target_endian = "little")]
                        let this = Self::from_le_bytes(bytes);
                        this
                    }
                }

                macro_rules! float_to_from_bytes_impl {
                    ($T:ty, $L:expr) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes(&self) -> Self::Bytes {
                                <$T>::to_be_bytes(*self)
                            }

                            #[inline]
                            fn to_le_bytes(&self) -> Self::Bytes {
                                <$T>::to_le_bytes(*self)
                            }

                            #[inline]
                            fn to_ne_bytes(&self) -> Self::Bytes {
                                <$T>::to_ne_bytes(*self)
                            }
                        }

                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_be_bytes(*bytes)
                            }

                            #[inline]
                            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_le_bytes(*bytes)
                            }

                            #[inline]
                            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_ne_bytes(*bytes)
                            }
                        }
                    };
                }

                macro_rules! int_to_from_bytes_impl {
                    ($T:ty, $L:expr) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes(&self) -> Self::Bytes {
                                <$T>::to_be_bytes(*self)
                            }

                            #[inline]
                            fn to_le_bytes(&self) -> Self::Bytes {
                                <$T>::to_le_bytes(*self)
                            }

                            #[inline]
                            fn to_ne_bytes(&self) -> Self::Bytes {
                                <$T>::to_ne_bytes(*self)
                            }
                        }

                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_be_bytes(*bytes)
                            }

                            #[inline]
                            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_le_bytes(*bytes)
                            }

                            #[inline]
                            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_ne_bytes(*bytes)
                            }
                        }
                    };
                }

                int_to_from_bytes_impl!(u8, 1);
                int_to_from_bytes_impl!(u16, 2);
                int_to_from_bytes_impl!(u32, 4);
                int_to_from_bytes_impl!(u64, 8);
                int_to_from_bytes_impl!(u128, 16);
                int_to_from_bytes_impl!(usize, 8);

                int_to_from_bytes_impl!(i8, 1);
                int_to_from_bytes_impl!(i16, 2);
                int_to_from_bytes_impl!(i32, 4);
                int_to_from_bytes_impl!(i64, 8);
                int_to_from_bytes_impl!(i128, 16);
                int_to_from_bytes_impl!(isize, 8);

                float_to_from_bytes_impl!(f32, 4);
                float_to_from_bytes_impl!(f64, 8);
            } pub use self::bytes::{ * };
            
            pub mod checked
            {
                use ::
                {
                    ops::{Add, Div, Mul, Rem, Shl, Shr, Sub},
                    *,
                };
                /// Performs addition, returning `None` if overflow occurred.
                pub trait CheckedAdd: Sized + Add<Self, Output = Self> {
                    /// Adds two numbers, checking for overflow. If overflow happens, `None` is
                    /// returned.
                    fn checked_add(&self, v: &Self) -> Option<Self>;
                }

                macro_rules! checked_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &$t) -> Option<$t> {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                checked_impl!(CheckedAdd, checked_add, u8);
                checked_impl!(CheckedAdd, checked_add, u16);
                checked_impl!(CheckedAdd, checked_add, u32);
                checked_impl!(CheckedAdd, checked_add, u64);
                checked_impl!(CheckedAdd, checked_add, usize);
                checked_impl!(CheckedAdd, checked_add, u128);

                checked_impl!(CheckedAdd, checked_add, i8);
                checked_impl!(CheckedAdd, checked_add, i16);
                checked_impl!(CheckedAdd, checked_add, i32);
                checked_impl!(CheckedAdd, checked_add, i64);
                checked_impl!(CheckedAdd, checked_add, isize);
                checked_impl!(CheckedAdd, checked_add, i128);
                /// Performs subtraction, returning `None` if overflow occurred.
                pub trait CheckedSub: Sized + Sub<Self, Output = Self> {
                    /// Subtracts two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_sub(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedSub, checked_sub, u8);
                checked_impl!(CheckedSub, checked_sub, u16);
                checked_impl!(CheckedSub, checked_sub, u32);
                checked_impl!(CheckedSub, checked_sub, u64);
                checked_impl!(CheckedSub, checked_sub, usize);
                checked_impl!(CheckedSub, checked_sub, u128);

                checked_impl!(CheckedSub, checked_sub, i8);
                checked_impl!(CheckedSub, checked_sub, i16);
                checked_impl!(CheckedSub, checked_sub, i32);
                checked_impl!(CheckedSub, checked_sub, i64);
                checked_impl!(CheckedSub, checked_sub, isize);
                checked_impl!(CheckedSub, checked_sub, i128);
                /// Performs multiplication, returning `None` if overflow occurred.
                pub trait CheckedMul: Sized + Mul<Self, Output = Self> {
                    /// Multiplies two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_mul(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedMul, checked_mul, u8);
                checked_impl!(CheckedMul, checked_mul, u16);
                checked_impl!(CheckedMul, checked_mul, u32);
                checked_impl!(CheckedMul, checked_mul, u64);
                checked_impl!(CheckedMul, checked_mul, usize);
                checked_impl!(CheckedMul, checked_mul, u128);

                checked_impl!(CheckedMul, checked_mul, i8);
                checked_impl!(CheckedMul, checked_mul, i16);
                checked_impl!(CheckedMul, checked_mul, i32);
                checked_impl!(CheckedMul, checked_mul, i64);
                checked_impl!(CheckedMul, checked_mul, isize);
                checked_impl!(CheckedMul, checked_mul, i128);
                /// Performs division, returning `None` on division by zero or if overflow
                /// occurred.
                pub trait CheckedDiv: Sized + Div<Self, Output = Self> {
                    /// Divides two numbers, checking for overflow and division by
                    /// zero. If any of that happens, `None` is returned.
                    fn checked_div(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedDiv, checked_div, u8);
                checked_impl!(CheckedDiv, checked_div, u16);
                checked_impl!(CheckedDiv, checked_div, u32);
                checked_impl!(CheckedDiv, checked_div, u64);
                checked_impl!(CheckedDiv, checked_div, usize);
                checked_impl!(CheckedDiv, checked_div, u128);

                checked_impl!(CheckedDiv, checked_div, i8);
                checked_impl!(CheckedDiv, checked_div, i16);
                checked_impl!(CheckedDiv, checked_div, i32);
                checked_impl!(CheckedDiv, checked_div, i64);
                checked_impl!(CheckedDiv, checked_div, isize);
                checked_impl!(CheckedDiv, checked_div, i128);
                /// Performs integral remainder, returning `None` on division by zero or if
                /// overflow occurred.
                pub trait CheckedRem: Sized + Rem<Self, Output = Self> {
                    /// Finds the remainder of dividing two numbers, checking for overflow and
                    /// division by zero. If any of that happens, `None` is returned.
                    fn checked_rem(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedRem, checked_rem, u8);
                checked_impl!(CheckedRem, checked_rem, u16);
                checked_impl!(CheckedRem, checked_rem, u32);
                checked_impl!(CheckedRem, checked_rem, u64);
                checked_impl!(CheckedRem, checked_rem, usize);
                checked_impl!(CheckedRem, checked_rem, u128);

                checked_impl!(CheckedRem, checked_rem, i8);
                checked_impl!(CheckedRem, checked_rem, i16);
                checked_impl!(CheckedRem, checked_rem, i32);
                checked_impl!(CheckedRem, checked_rem, i64);
                checked_impl!(CheckedRem, checked_rem, isize);
                checked_impl!(CheckedRem, checked_rem, i128);

                macro_rules! checked_impl_unary {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self) -> Option<$t> {
                                <$t>::$method(*self)
                            }
                        }
                    };
                }
                /// Performs negation, returning `None` if the result can't be represented.
                pub trait CheckedNeg: Sized {
                    /// Negates a number, returning `None` for results that can't be represented, like signed `MIN`
                    /// values that can't be positive, or non-zero unsigned values that can't be negative.
                    fn checked_neg(&self) -> Option<Self>;
                }

                checked_impl_unary!(CheckedNeg, checked_neg, u8);
                checked_impl_unary!(CheckedNeg, checked_neg, u16);
                checked_impl_unary!(CheckedNeg, checked_neg, u32);
                checked_impl_unary!(CheckedNeg, checked_neg, u64);
                checked_impl_unary!(CheckedNeg, checked_neg, usize);
                checked_impl_unary!(CheckedNeg, checked_neg, u128);

                checked_impl_unary!(CheckedNeg, checked_neg, i8);
                checked_impl_unary!(CheckedNeg, checked_neg, i16);
                checked_impl_unary!(CheckedNeg, checked_neg, i32);
                checked_impl_unary!(CheckedNeg, checked_neg, i64);
                checked_impl_unary!(CheckedNeg, checked_neg, isize);
                checked_impl_unary!(CheckedNeg, checked_neg, i128);
                /// Performs shift left, returning `None` on shifts larger than or equal to
                /// the type width.
                pub trait CheckedShl: Sized + Shl<u32, Output = Self> {
                    /// Checked shift left. Computes `self << rhs`, returning `None`
                    /// if `rhs` is larger than or equal to the number of bits in `self`.
                    fn checked_shl(&self, rhs: u32) -> Option<Self>;
                }

                macro_rules! checked_shift_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, rhs: u32) -> Option<$t> {
                                <$t>::$method(*self, rhs)
                            }
                        }
                    };
                }

                checked_shift_impl!(CheckedShl, checked_shl, u8);
                checked_shift_impl!(CheckedShl, checked_shl, u16);
                checked_shift_impl!(CheckedShl, checked_shl, u32);
                checked_shift_impl!(CheckedShl, checked_shl, u64);
                checked_shift_impl!(CheckedShl, checked_shl, usize);
                checked_shift_impl!(CheckedShl, checked_shl, u128);

                checked_shift_impl!(CheckedShl, checked_shl, i8);
                checked_shift_impl!(CheckedShl, checked_shl, i16);
                checked_shift_impl!(CheckedShl, checked_shl, i32);
                checked_shift_impl!(CheckedShl, checked_shl, i64);
                checked_shift_impl!(CheckedShl, checked_shl, isize);
                checked_shift_impl!(CheckedShl, checked_shl, i128);
                /// Performs shift right, returning `None` on shifts larger than or equal to
                /// the type width.
                pub trait CheckedShr: Sized + Shr<u32, Output = Self> {
                    /// Checked shift right. Computes `self >> rhs`, returning `None`
                    /// if `rhs` is larger than or equal to the number of bits in `self`.
                    fn checked_shr(&self, rhs: u32) -> Option<Self>;
                }

                checked_shift_impl!(CheckedShr, checked_shr, u8);
                checked_shift_impl!(CheckedShr, checked_shr, u16);
                checked_shift_impl!(CheckedShr, checked_shr, u32);
                checked_shift_impl!(CheckedShr, checked_shr, u64);
                checked_shift_impl!(CheckedShr, checked_shr, usize);
                checked_shift_impl!(CheckedShr, checked_shr, u128);

                checked_shift_impl!(CheckedShr, checked_shr, i8);
                checked_shift_impl!(CheckedShr, checked_shr, i16);
                checked_shift_impl!(CheckedShr, checked_shr, i32);
                checked_shift_impl!(CheckedShr, checked_shr, i64);
                checked_shift_impl!(CheckedShr, checked_shr, isize);
                checked_shift_impl!(CheckedShr, checked_shr, i128);
            } pub use self::checked::{ * };
            
            pub mod euclid
            {
                use ::
                {
                    ops::{Div, Rem},
                    *,
                };
                
                pub trait Euclid: Sized + Div<Self, Output = Self> + Rem<Self, Output = Self> {
                    /// Calculates Euclidean division, the matching method for `rem_euclid`.
                    fn div_euclid(&self, v: &Self) -> Self;

                    /// Calculates the least nonnegative remainder of `self (mod v)`.
                    fn rem_euclid(&self, v: &Self) -> Self;

                    /// Returns both the quotient and remainder from Euclidean division.
                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                        (self.div_euclid(v), self.rem_euclid(v))
                    }
                }

                macro_rules! euclid_forward_impl {
                    ($($t:ty)*) => {$(
                        impl Euclid for $t {
                            #[inline]
                            fn div_euclid(&self, v: &$t) -> Self {
                                <$t>::div_euclid(*self, *v)
                            }

                            #[inline]
                            fn rem_euclid(&self, v: &$t) -> Self {
                                <$t>::rem_euclid(*self, *v)
                            }
                        }
                    )*}
                }

                euclid_forward_impl!(isize i8 i16 i32 i64 i128);
                euclid_forward_impl!(usize u8 u16 u32 u64 u128);
                euclid_forward_impl!(f32 f64);

                pub trait CheckedEuclid: Euclid {
                    /// Performs euclid division, returning `None` on division by zero or if
                    /// overflow occurred.
                    fn checked_div_euclid(&self, v: &Self) -> Option<Self>;

                    /// Finds the euclid remainder of dividing two numbers, returning `None` on
                    /// division by zero or if overflow occurred.
                    fn checked_rem_euclid(&self, v: &Self) -> Option<Self>;

                    /// Returns both the quotient and remainder from checked Euclidean division,
                    /// returning `None` on division by zero or if overflow occurred.
                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some((self.checked_div_euclid(v)?, self.checked_rem_euclid(v)?))
                    }
                }

                macro_rules! checked_euclid_forward_impl {
                    ($($t:ty)*) => {$(
                        impl CheckedEuclid for $t {
                            #[inline]
                            fn checked_div_euclid(&self, v: &$t) -> Option<Self> {
                                <$t>::checked_div_euclid(*self, *v)
                            }

                            #[inline]
                            fn checked_rem_euclid(&self, v: &$t) -> Option<Self> {
                                <$t>::checked_rem_euclid(*self, *v)
                            }
                        }
                    )*}
                }

                checked_euclid_forward_impl!(isize i8 i16 i32 i64 i128);
                checked_euclid_forward_impl!(usize u8 u16 u32 u64 u128);
            } pub use self::euclid::{ * };
            
            pub mod inv
            {
                use ::
                {
                    *,
                };
                /// Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.
                pub trait Inv {
                    /// The result after applying the operator.
                    type Output;

                    /// Returns the multiplicative inverse of `self`.
                    fn inv(self) -> Self::Output;
                }

                impl Inv for f32 {
                    type Output = f32;
                    #[inline] fn inv(self) -> f32 {
                        1.0 / self
                    }
                }
                impl Inv for f64 {
                    type Output = f64;
                    #[inline] fn inv(self) -> f64 {
                        1.0 / self
                    }
                }
                impl<'a> Inv for &'a f32 {
                    type Output = f32;
                    #[inline] fn inv(self) -> f32 {
                        1.0 / *self
                    }
                }
                impl<'a> Inv for &'a f64 {
                    type Output = f64;
                    #[inline] fn inv(self) -> f64 {
                        1.0 / *self
                    }
                }
            } pub use self::inv::{ * };
            
            pub mod mul_add
            {
                use ::
                {
                    *,
                };
                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                pub trait MulAdd<A = Self, B = Self> {
                    /// The resulting type after applying the fused multiply-add.
                    type Output;

                    /// Performs the fused multiply-add operation `(self * a) + b`
                    fn mul_add(self, a: A, b: B) -> Self::Output;
                }
                /// The fused multiply-add assignment operation `*self = (*self * a) + b`
                pub trait MulAddAssign<A = Self, B = Self> {
                    /// Performs the fused multiply-add assignment operation `*self = (*self * a) + b`
                    fn mul_add_assign(&mut self, a: A, b: B);
                }
                
                impl MulAdd<f32, f32> for f32 {
                    type Output = Self;

                    #[inline] fn mul_add(self, a: Self, b: Self) -> Self::Output {
                        <Self as ::num::traits::Float>::mul_add(self, a, b)
                    }
                }
                
                impl MulAdd<f64, f64> for f64 {
                    type Output = Self;

                    #[inline] fn mul_add(self, a: Self, b: Self) -> Self::Output {
                        <Self as ::num::traits::Float>::mul_add(self, a, b)
                    }
                }

                macro_rules! mul_add_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            type Output = Self;

                            #[inline]
                            fn mul_add(self, a: Self, b: Self) -> Self::Output {
                                (self * a) + b
                            }
                        }
                    )*}
                }

                mul_add_impl!(MulAdd for isize i8 i16 i32 i64 i128);
                mul_add_impl!(MulAdd for usize u8 u16 u32 u64 u128);
                
                impl MulAddAssign<f32, f32> for f32 {
                    #[inline] fn mul_add_assign(&mut self, a: Self, b: Self) {
                        *self = <Self as ::num::traits::Float>::mul_add(*self, a, b)
                    }
                }
                
                impl MulAddAssign<f64, f64> for f64 {
                    #[inline] fn mul_add_assign(&mut self, a: Self, b: Self) {
                        *self = <Self as ::num::traits::Float>::mul_add(*self, a, b)
                    }
                }

                macro_rules! mul_add_assign_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            #[inline]
                            fn mul_add_assign(&mut self, a: Self, b: Self) {
                                *self = (*self * a) + b
                            }
                        }
                    )*}
                }

                mul_add_assign_impl!(MulAddAssign for isize i8 i16 i32 i64 i128);
                mul_add_assign_impl!(MulAddAssign for usize u8 u16 u32 u64 u128);
            } pub use self::mul_add::{ * };
            
            pub mod overflowing
            {
                use ::
                {
                    ops::{ Add, Mul, Sub },
                    *,
                };

                macro_rules! overflowing_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> (Self, bool) {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }
                /// Performs addition with a flag for overflow.
                pub trait OverflowingAdd: Sized + Add<Self, Output = Self> {
                    /// Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_add(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingAdd, overflowing_add, u8);
                overflowing_impl!(OverflowingAdd, overflowing_add, u16);
                overflowing_impl!(OverflowingAdd, overflowing_add, u32);
                overflowing_impl!(OverflowingAdd, overflowing_add, u64);
                overflowing_impl!(OverflowingAdd, overflowing_add, usize);
                overflowing_impl!(OverflowingAdd, overflowing_add, u128);

                overflowing_impl!(OverflowingAdd, overflowing_add, i8);
                overflowing_impl!(OverflowingAdd, overflowing_add, i16);
                overflowing_impl!(OverflowingAdd, overflowing_add, i32);
                overflowing_impl!(OverflowingAdd, overflowing_add, i64);
                overflowing_impl!(OverflowingAdd, overflowing_add, isize);
                overflowing_impl!(OverflowingAdd, overflowing_add, i128);
                /// Performs substraction with a flag for overflow.
                pub trait OverflowingSub: Sized + Sub<Self, Output = Self> {
                    /// Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_sub(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingSub, overflowing_sub, u8);
                overflowing_impl!(OverflowingSub, overflowing_sub, u16);
                overflowing_impl!(OverflowingSub, overflowing_sub, u32);
                overflowing_impl!(OverflowingSub, overflowing_sub, u64);
                overflowing_impl!(OverflowingSub, overflowing_sub, usize);
                overflowing_impl!(OverflowingSub, overflowing_sub, u128);

                overflowing_impl!(OverflowingSub, overflowing_sub, i8);
                overflowing_impl!(OverflowingSub, overflowing_sub, i16);
                overflowing_impl!(OverflowingSub, overflowing_sub, i32);
                overflowing_impl!(OverflowingSub, overflowing_sub, i64);
                overflowing_impl!(OverflowingSub, overflowing_sub, isize);
                overflowing_impl!(OverflowingSub, overflowing_sub, i128);
                /// Performs multiplication with a flag for overflow.
                pub trait OverflowingMul: Sized + Mul<Self, Output = Self> {
                    /// Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_mul(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingMul, overflowing_mul, u8);
                overflowing_impl!(OverflowingMul, overflowing_mul, u16);
                overflowing_impl!(OverflowingMul, overflowing_mul, u32);
                overflowing_impl!(OverflowingMul, overflowing_mul, u64);
                overflowing_impl!(OverflowingMul, overflowing_mul, usize);
                overflowing_impl!(OverflowingMul, overflowing_mul, u128);

                overflowing_impl!(OverflowingMul, overflowing_mul, i8);
                overflowing_impl!(OverflowingMul, overflowing_mul, i16);
                overflowing_impl!(OverflowingMul, overflowing_mul, i32);
                overflowing_impl!(OverflowingMul, overflowing_mul, i64);
                overflowing_impl!(OverflowingMul, overflowing_mul, isize);
                overflowing_impl!(OverflowingMul, overflowing_mul, i128);
            } pub use self::overflowing::{ * };
            
            pub mod saturating
            {
                use ::
                {
                    ops::{Add, Mul, Sub},
                    *,
                };
                /// Saturating math operations. Deprecated, use `SaturatingAdd`, `SaturatingSub` and
                /// `SaturatingMul` instead.
                pub trait Saturating {
                    /// Saturating addition operator.
                    /// Returns a+b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_add(self, v: Self) -> Self;

                    /// Saturating subtraction operator.
                    /// Returns a-b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_sub(self, v: Self) -> Self;
                }

                macro_rules! deprecated_saturating_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            #[inline]
                            fn saturating_add(self, v: Self) -> Self {
                                Self::saturating_add(self, v)
                            }

                            #[inline]
                            fn saturating_sub(self, v: Self) -> Self {
                                Self::saturating_sub(self, v)
                            }
                        }
                    )*}
                }

                deprecated_saturating_impl!(Saturating for isize i8 i16 i32 i64 i128);
                deprecated_saturating_impl!(Saturating for usize u8 u16 u32 u64 u128);

                macro_rules! saturating_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }
                /// Performs addition that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingAdd: Sized + Add<Self, Output = Self> {
                    /// Saturating addition. Computes `self + other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_add(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingAdd, saturating_add, u8);
                saturating_impl!(SaturatingAdd, saturating_add, u16);
                saturating_impl!(SaturatingAdd, saturating_add, u32);
                saturating_impl!(SaturatingAdd, saturating_add, u64);
                saturating_impl!(SaturatingAdd, saturating_add, usize);
                saturating_impl!(SaturatingAdd, saturating_add, u128);

                saturating_impl!(SaturatingAdd, saturating_add, i8);
                saturating_impl!(SaturatingAdd, saturating_add, i16);
                saturating_impl!(SaturatingAdd, saturating_add, i32);
                saturating_impl!(SaturatingAdd, saturating_add, i64);
                saturating_impl!(SaturatingAdd, saturating_add, isize);
                saturating_impl!(SaturatingAdd, saturating_add, i128);
                /// Performs subtraction that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingSub: Sized + Sub<Self, Output = Self> {
                    /// Saturating subtraction. Computes `self - other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_sub(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingSub, saturating_sub, u8);
                saturating_impl!(SaturatingSub, saturating_sub, u16);
                saturating_impl!(SaturatingSub, saturating_sub, u32);
                saturating_impl!(SaturatingSub, saturating_sub, u64);
                saturating_impl!(SaturatingSub, saturating_sub, usize);
                saturating_impl!(SaturatingSub, saturating_sub, u128);

                saturating_impl!(SaturatingSub, saturating_sub, i8);
                saturating_impl!(SaturatingSub, saturating_sub, i16);
                saturating_impl!(SaturatingSub, saturating_sub, i32);
                saturating_impl!(SaturatingSub, saturating_sub, i64);
                saturating_impl!(SaturatingSub, saturating_sub, isize);
                saturating_impl!(SaturatingSub, saturating_sub, i128);
                /// Performs multiplication that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingMul: Sized + Mul<Self, Output = Self> {
                    /// Saturating multiplication. Computes `self * other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_mul(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingMul, saturating_mul, u8);
                saturating_impl!(SaturatingMul, saturating_mul, u16);
                saturating_impl!(SaturatingMul, saturating_mul, u32);
                saturating_impl!(SaturatingMul, saturating_mul, u64);
                saturating_impl!(SaturatingMul, saturating_mul, usize);
                saturating_impl!(SaturatingMul, saturating_mul, u128);

                saturating_impl!(SaturatingMul, saturating_mul, i8);
                saturating_impl!(SaturatingMul, saturating_mul, i16);
                saturating_impl!(SaturatingMul, saturating_mul, i32);
                saturating_impl!(SaturatingMul, saturating_mul, i64);
                saturating_impl!(SaturatingMul, saturating_mul, isize);
                saturating_impl!(SaturatingMul, saturating_mul, i128);
            } pub use self::saturating::{ * };
            
            pub mod wrapping
            {
                use ::
                {
                    num::{ Wrapping },
                    ops::{Add, Mul, Neg, Shl, Shr, Sub},
                    *,
                };
                
                macro_rules! wrapping_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                    ($trait_name:ident, $method:ident, $t:ty, $rhs:ty) => {
                        impl $trait_name<$rhs> for $t {
                            #[inline]
                            fn $method(&self, v: &$rhs) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }
                /// Performs addition that wraps around on overflow.
                pub trait WrappingAdd: Sized + Add<Self, Output = Self> {
                    /// Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of
                    /// the type.
                    fn wrapping_add(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingAdd, wrapping_add, u8);
                wrapping_impl!(WrappingAdd, wrapping_add, u16);
                wrapping_impl!(WrappingAdd, wrapping_add, u32);
                wrapping_impl!(WrappingAdd, wrapping_add, u64);
                wrapping_impl!(WrappingAdd, wrapping_add, usize);
                wrapping_impl!(WrappingAdd, wrapping_add, u128);

                wrapping_impl!(WrappingAdd, wrapping_add, i8);
                wrapping_impl!(WrappingAdd, wrapping_add, i16);
                wrapping_impl!(WrappingAdd, wrapping_add, i32);
                wrapping_impl!(WrappingAdd, wrapping_add, i64);
                wrapping_impl!(WrappingAdd, wrapping_add, isize);
                wrapping_impl!(WrappingAdd, wrapping_add, i128);
                /// Performs subtraction that wraps around on overflow.
                pub trait WrappingSub: Sized + Sub<Self, Output = Self> {
                    /// Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_sub(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingSub, wrapping_sub, u8);
                wrapping_impl!(WrappingSub, wrapping_sub, u16);
                wrapping_impl!(WrappingSub, wrapping_sub, u32);
                wrapping_impl!(WrappingSub, wrapping_sub, u64);
                wrapping_impl!(WrappingSub, wrapping_sub, usize);
                wrapping_impl!(WrappingSub, wrapping_sub, u128);

                wrapping_impl!(WrappingSub, wrapping_sub, i8);
                wrapping_impl!(WrappingSub, wrapping_sub, i16);
                wrapping_impl!(WrappingSub, wrapping_sub, i32);
                wrapping_impl!(WrappingSub, wrapping_sub, i64);
                wrapping_impl!(WrappingSub, wrapping_sub, isize);
                wrapping_impl!(WrappingSub, wrapping_sub, i128);
                /// Performs multiplication that wraps around on overflow.
                pub trait WrappingMul: Sized + Mul<Self, Output = Self> {
                    /// Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_mul(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingMul, wrapping_mul, u8);
                wrapping_impl!(WrappingMul, wrapping_mul, u16);
                wrapping_impl!(WrappingMul, wrapping_mul, u32);
                wrapping_impl!(WrappingMul, wrapping_mul, u64);
                wrapping_impl!(WrappingMul, wrapping_mul, usize);
                wrapping_impl!(WrappingMul, wrapping_mul, u128);

                wrapping_impl!(WrappingMul, wrapping_mul, i8);
                wrapping_impl!(WrappingMul, wrapping_mul, i16);
                wrapping_impl!(WrappingMul, wrapping_mul, i32);
                wrapping_impl!(WrappingMul, wrapping_mul, i64);
                wrapping_impl!(WrappingMul, wrapping_mul, isize);
                wrapping_impl!(WrappingMul, wrapping_mul, i128);

                macro_rules! wrapping_unary_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self) -> $t {
                                <$t>::$method(*self)
                            }
                        }
                    };
                }
                /// Performs a negation that does not panic.
                pub trait WrappingNeg: Sized {
                    /// Wrapping (modular) negation. Computes `-self`,
                    /// wrapping around at the boundary of the type.
                    fn wrapping_neg(&self) -> Self;
                }

                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u8);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u16);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u32);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u64);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, usize);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u128);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i8);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i16);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i32);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i64);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, isize);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i128);

                macro_rules! wrapping_shift_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, rhs: u32) -> $t {
                                <$t>::$method(*self, rhs)
                            }
                        }
                    };
                }
                /// Performs a left shift that does not panic.
                pub trait WrappingShl: Sized + Shl<usize, Output = Self> {
                    /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    fn wrapping_shl(&self, rhs: u32) -> Self;
                }

                wrapping_shift_impl!(WrappingShl, wrapping_shl, u8);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u16);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u32);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u64);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, usize);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u128);

                wrapping_shift_impl!(WrappingShl, wrapping_shl, i8);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i16);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i32);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i64);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, isize);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i128);
                /// Performs a right shift that does not panic.
                pub trait WrappingShr: Sized + Shr<usize, Output = Self> {
                    /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    fn wrapping_shr(&self, rhs: u32) -> Self;
                }

                wrapping_shift_impl!(WrappingShr, wrapping_shr, u8);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u16);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u32);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u64);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, usize);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u128);

                wrapping_shift_impl!(WrappingShr, wrapping_shr, i8);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i16);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i32);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i64);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, isize);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i128);

                // Well this is a bit funny, but all the more appropriate.
                impl<T: WrappingAdd> WrappingAdd for Wrapping<T>
                where
                    Wrapping<T>: Add<Output = Wrapping<T>>,
                {
                    fn wrapping_add(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_add(&v.0))
                    }
                }
                impl<T: WrappingSub> WrappingSub for Wrapping<T>
                where
                    Wrapping<T>: Sub<Output = Wrapping<T>>,
                {
                    fn wrapping_sub(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_sub(&v.0))
                    }
                }
                impl<T: WrappingMul> WrappingMul for Wrapping<T>
                where
                    Wrapping<T>: Mul<Output = Wrapping<T>>,
                {
                    fn wrapping_mul(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_mul(&v.0))
                    }
                }
                impl<T: WrappingNeg> WrappingNeg for Wrapping<T>
                where
                    Wrapping<T>: Neg<Output = Wrapping<T>>,
                {
                    fn wrapping_neg(&self) -> Self {
                        Wrapping(self.0.wrapping_neg())
                    }
                }
                impl<T: WrappingShl> WrappingShl for Wrapping<T>
                where
                    Wrapping<T>: Shl<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shl(&self, rhs: u32) -> Self {
                        Wrapping(self.0.wrapping_shl(rhs))
                    }
                }
                impl<T: WrappingShr> WrappingShr for Wrapping<T>
                where
                    Wrapping<T>: Shr<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shr(&self, rhs: u32) -> Self {
                        Wrapping(self.0.wrapping_shr(rhs))
                    }
                }
            } pub use self::wrapping::{ * };
        } pub use self::ops::{ * };

        pub mod pow
        {
            use ::
            {
                num::
                { 
                    traits::
                    {
                        CheckedMul, One,
                    },
                    Wrapping 
                },
                ops::{ Mul },
                *,
            };
            /// Binary operator for raising a value to a power.
            pub trait Pow<RHS> 
            {
                /// The result after applying the operator.
                type Output;
                /// Returns `self` to the power `rhs`.
                fn pow(self, rhs: RHS) -> Self::Output;
            }

            macro_rules! pow_impl 
            {
                ($t:ty) => {
                    pow_impl!($t, u8);
                    pow_impl!($t, usize);
                };
                ($t:ty, $rhs:ty) => {
                    pow_impl!($t, $rhs, usize, pow);
                };
                ($t:ty, $rhs:ty, $desired_rhs:ty, $method:expr) => {
                    impl Pow<$rhs> for $t {
                        type Output = $t;
                        #[inline] fn pow(self, rhs: $rhs) -> $t {
                            ($method)(self, <$desired_rhs>::from(rhs))
                        }
                    }

                    impl<'a> Pow<&'a $rhs> for $t {
                        type Output = $t;
                        #[inline] fn pow(self, rhs: &'a $rhs) -> $t {
                            ($method)(self, <$desired_rhs>::from(*rhs))
                        }
                    }

                    impl<'a> Pow<$rhs> for &'a $t {
                        type Output = $t;
                        #[inline] fn pow(self, rhs: $rhs) -> $t {
                            ($method)(*self, <$desired_rhs>::from(rhs))
                        }
                    }

                    impl<'a, 'b> Pow<&'a $rhs> for &'b $t {
                        type Output = $t;
                        #[inline] fn pow(self, rhs: &'a $rhs) -> $t {
                            ($method)(*self, <$desired_rhs>::from(*rhs))
                        }
                    }
                };
            }

            pow_impl!(u8, u8, u32, u8::pow);
            pow_impl!(u8, u16, u32, u8::pow);
            pow_impl!(u8, u32, u32, u8::pow);
            pow_impl!(u8, usize);
            pow_impl!(i8, u8, u32, i8::pow);
            pow_impl!(i8, u16, u32, i8::pow);
            pow_impl!(i8, u32, u32, i8::pow);
            pow_impl!(i8, usize);
            pow_impl!(u16, u8, u32, u16::pow);
            pow_impl!(u16, u16, u32, u16::pow);
            pow_impl!(u16, u32, u32, u16::pow);
            pow_impl!(u16, usize);
            pow_impl!(i16, u8, u32, i16::pow);
            pow_impl!(i16, u16, u32, i16::pow);
            pow_impl!(i16, u32, u32, i16::pow);
            pow_impl!(i16, usize);
            pow_impl!(u32, u8, u32, u32::pow);
            pow_impl!(u32, u16, u32, u32::pow);
            pow_impl!(u32, u32, u32, u32::pow);
            pow_impl!(u32, usize);
            pow_impl!(i32, u8, u32, i32::pow);
            pow_impl!(i32, u16, u32, i32::pow);
            pow_impl!(i32, u32, u32, i32::pow);
            pow_impl!(i32, usize);
            pow_impl!(u64, u8, u32, u64::pow);
            pow_impl!(u64, u16, u32, u64::pow);
            pow_impl!(u64, u32, u32, u64::pow);
            pow_impl!(u64, usize);
            pow_impl!(i64, u8, u32, i64::pow);
            pow_impl!(i64, u16, u32, i64::pow);
            pow_impl!(i64, u32, u32, i64::pow);
            pow_impl!(i64, usize);

            pow_impl!(u128, u8, u32, u128::pow);
            pow_impl!(u128, u16, u32, u128::pow);
            pow_impl!(u128, u32, u32, u128::pow);
            pow_impl!(u128, usize);

            pow_impl!(i128, u8, u32, i128::pow);
            pow_impl!(i128, u16, u32, i128::pow);
            pow_impl!(i128, u32, u32, i128::pow);
            pow_impl!(i128, usize);

            pow_impl!(usize, u8, u32, usize::pow);
            pow_impl!(usize, u16, u32, usize::pow);
            pow_impl!(usize, u32, u32, usize::pow);
            pow_impl!(usize, usize);
            pow_impl!(isize, u8, u32, isize::pow);
            pow_impl!(isize, u16, u32, isize::pow);
            pow_impl!(isize, u32, u32, isize::pow);
            pow_impl!(isize, usize);
            pow_impl!(Wrapping<u8>);
            pow_impl!(Wrapping<i8>);
            pow_impl!(Wrapping<u16>);
            pow_impl!(Wrapping<i16>);
            pow_impl!(Wrapping<u32>);
            pow_impl!(Wrapping<i32>);
            pow_impl!(Wrapping<u64>);
            pow_impl!(Wrapping<i64>);
            pow_impl!(Wrapping<u128>);
            pow_impl!(Wrapping<i128>);
            pow_impl!(Wrapping<usize>);
            pow_impl!(Wrapping<isize>);
            
            mod float_impls 
            {
                use super::Pow;
                use ::num::traits::Float;

                pow_impl!(f32, i8, i32, <f32 as Float>::powi);
                pow_impl!(f32, u8, i32, <f32 as Float>::powi);
                pow_impl!(f32, i16, i32, <f32 as Float>::powi);
                pow_impl!(f32, u16, i32, <f32 as Float>::powi);
                pow_impl!(f32, i32, i32, <f32 as Float>::powi);
                pow_impl!(f64, i8, i32, <f64 as Float>::powi);
                pow_impl!(f64, u8, i32, <f64 as Float>::powi);
                pow_impl!(f64, i16, i32, <f64 as Float>::powi);
                pow_impl!(f64, u16, i32, <f64 as Float>::powi);
                pow_impl!(f64, i32, i32, <f64 as Float>::powi);
                pow_impl!(f32, f32, f32, <f32 as Float>::powf);
                pow_impl!(f64, f32, f64, <f64 as Float>::powf);
                pow_impl!(f64, f64, f64, <f64 as Float>::powf);
            }
            /// Raises a value to the power of exp, using exponentiation by squaring.
            #[inline] pub fn pow<T: Clone + One + Mul<T, Output = T>>(mut base: T, mut exp: usize) -> T 
            {
                if exp == 0 {
                    return T::one();
                }

                while exp & 1 == 0 {
                    base = base.clone() * base;
                    exp >>= 1;
                }
                if exp == 1 {
                    return base;
                }

                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.clone() * base;
                    if exp & 1 == 1 {
                        acc = acc * base.clone();
                    }
                }
                acc
            }
            /// Raises a value to the power of exp, returning `None` if an overflow occurred.
            #[inline] pub fn checked_pow<T: Clone + One + CheckedMul>(mut base: T, mut exp: usize) -> Option<T> 
            {
                if exp == 0 {
                    return Some(T::one());
                }

                while exp & 1 == 0 {
                    base = base.checked_mul(&base)?;
                    exp >>= 1;
                }
                if exp == 1 {
                    return Some(base);
                }

                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.checked_mul(&base)?;
                    if exp & 1 == 1 {
                        acc = acc.checked_mul(&base)?;
                    }
                }
                Some(acc)
            }
        } pub use self::pow::{ * };

        pub mod real
        {
            use ::
            {
                num::
                {
                    traits::{ Float, Num, NumCast },
                },
                ops::{ Neg },
                *,
            };
            /// A trait for real number types that do not necessarily have
            /// floating-point-specific characteristics such as NaN and infinity.
            pub trait Real: Num + Copy + NumCast + PartialOrd + Neg<Output = Self>
            {
                /// Returns the smallest finite value that this type can represent.
                fn min_value() -> Self;
                /// Returns the smallest positive, normalized value that this type can represent.
                fn min_positive_value() -> Self;
                /// Returns epsilon, a small positive value.
                fn epsilon() -> Self;
                /// Returns the largest finite value that this type can represent.
                fn max_value() -> Self;
                /// Returns the largest integer less than or equal to a number.
                fn floor(self) -> Self;
                /// Returns the smallest integer greater than or equal to a number.
                fn ceil(self) -> Self;
                /// Returns the nearest integer to a number. Round half-way cases away from
                /// `0.0`.
                fn round(self) -> Self;
                /// Return the integer part of a number.
                fn trunc(self) -> Self;
                /// Returns the fractional part of a number.
                fn fract(self) -> Self;
                /// Computes the absolute value of `self`. Returns `Float::nan()` if the
                /// number is `Float::nan()`.
                fn abs(self) -> Self;
                /// Returns a number that represents the sign of `self`.
                fn signum(self) -> Self;
                /// Returns `true` if `self` is positive, including `+0.0`,
                /// `Float::infinity()`, and with newer versions of Rust `f64::NAN`.
                fn is_sign_positive(self) -> bool;
                /// Returns `true` if `self` is negative, including `-0.0`,
                /// `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.
                fn is_sign_negative(self) -> bool;
                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                fn mul_add(self, a: Self, b: Self) -> Self;
                /// Take the reciprocal (inverse) of a number, `1/x`.
                fn recip(self) -> Self;
                /// Raise a number to an integer power.
                fn powi(self, n: i32) -> Self;
                /// Raise a number to a real number power.
                fn powf(self, n: Self) -> Self;
                /// Take the square root of a number.
                fn sqrt(self) -> Self;
                /// Returns `e^(self)`, (the exponential function).
                fn exp(self) -> Self;
                /// Returns `2^(self)`.
                fn exp2(self) -> Self;
                /// Returns the natural logarithm of the number.
                fn ln(self) -> Self;
                /// Returns the logarithm of the number with respect to an arbitrary base.
                fn log(self, base: Self) -> Self;
                /// Returns the base 2 logarithm of the number.
                fn log2(self) -> Self;
                /// Returns the base 10 logarithm of the number.
                fn log10(self) -> Self;
                /// Converts radians to degrees.
                fn to_degrees(self) -> Self;
                /// Converts degrees to radians.
                fn to_radians(self) -> Self;
                /// Returns the maximum of the two numbers.
                fn max(self, other: Self) -> Self;
                /// Returns the minimum of the two numbers.
                fn min(self, other: Self) -> Self;
                /// The positive difference of two numbers.
                fn abs_sub(self, other: Self) -> Self;
                /// Take the cubic root of a number.
                fn cbrt(self) -> Self;
                /// Calculate the length of the hypotenuse of a right-angle triangle given
                /// legs of length `x` and `y`.
                fn hypot(self, other: Self) -> Self;
                /// Computes the sine of a number (in radians).
                fn sin(self) -> Self;
                /// Computes the cosine of a number (in radians).
                fn cos(self) -> Self;
                /// Computes the tangent of a number (in radians).
                fn tan(self) -> Self;
                /// Computes the arcsine of a number. Return value is in radians in
                /// the range [-pi/2, pi/2] or NaN if the number is outside the range
                /// [-1, 1].
                fn asin(self) -> Self;
                /// Computes the arccosine of a number. Return value is in radians in
                /// the range [0, pi] or NaN if the number is outside the range
                /// [-1, 1].
                fn acos(self) -> Self;
                /// Computes the arctangent of a number. Return value is in radians in the
                /// range [-pi/2, pi/2];
                fn atan(self) -> Self;
                /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).
                fn atan2(self, other: Self) -> Self;
                /// Simultaneously computes the sine and cosine of the number, `x`. Returns
                /// `(sin(x), cos(x))`.
                fn sin_cos(self) -> (Self, Self);
                /// Returns `e^(self) - 1` in a way that is accurate even if the
                /// number is close to zero.
                fn exp_m1(self) -> Self;
                /// Returns `ln(1+n)` (natural logarithm) more accurately than if
                /// the operations were performed separately.
                fn ln_1p(self) -> Self;
                /// Hyperbolic sine function.
                fn sinh(self) -> Self;
                /// Hyperbolic cosine function.
                fn cosh(self) -> Self;
                /// Hyperbolic tangent function.
                fn tanh(self) -> Self;
                /// Inverse hyperbolic sine function.
                fn asinh(self) -> Self;
                /// Inverse hyperbolic cosine function.
                fn acosh(self) -> Self;
                /// Inverse hyperbolic tangent function.
                fn atanh(self) -> Self;
            }

            impl<T: Float> Real for T
            {
                forward! {
                    Float::min_value() -> Self;
                    Float::min_positive_value() -> Self;
                    Float::epsilon() -> Self;
                    Float::max_value() -> Self;
                }
                forward! {
                    Float::floor(self) -> Self;
                    Float::ceil(self) -> Self;
                    Float::round(self) -> Self;
                    Float::trunc(self) -> Self;
                    Float::fract(self) -> Self;
                    Float::abs(self) -> Self;
                    Float::signum(self) -> Self;
                    Float::is_sign_positive(self) -> bool;
                    Float::is_sign_negative(self) -> bool;
                    Float::mul_add(self, a: Self, b: Self) -> Self;
                    Float::recip(self) -> Self;
                    Float::powi(self, n: i32) -> Self;
                    Float::powf(self, n: Self) -> Self;
                    Float::sqrt(self) -> Self;
                    Float::exp(self) -> Self;
                    Float::exp2(self) -> Self;
                    Float::ln(self) -> Self;
                    Float::log(self, base: Self) -> Self;
                    Float::log2(self) -> Self;
                    Float::log10(self) -> Self;
                    Float::to_degrees(self) -> Self;
                    Float::to_radians(self) -> Self;
                    Float::max(self, other: Self) -> Self;
                    Float::min(self, other: Self) -> Self;
                    Float::abs_sub(self, other: Self) -> Self;
                    Float::cbrt(self) -> Self;
                    Float::hypot(self, other: Self) -> Self;
                    Float::sin(self) -> Self;
                    Float::cos(self) -> Self;
                    Float::tan(self) -> Self;
                    Float::asin(self) -> Self;
                    Float::acos(self) -> Self;
                    Float::atan(self) -> Self;
                    Float::atan2(self, other: Self) -> Self;
                    Float::sin_cos(self) -> (Self, Self);
                    Float::exp_m1(self) -> Self;
                    Float::ln_1p(self) -> Self;
                    Float::sinh(self) -> Self;
                    Float::cosh(self) -> Self;
                    Float::tanh(self) -> Self;
                    Float::asinh(self) -> Self;
                    Float::acosh(self) -> Self;
                    Float::atanh(self) -> Self;
                }
            }
        } pub use self::real::{ * };

        pub mod sign
        {
            use ::
            {
                num::
                { 
                    traits::
                    {
                        float::{ FloatCore },
                        Num,
                    },
                    Wrapping 
                },
                ops::{ Neg },
                *,
            };
            /// Useful functions for signed numbers (i.e. numbers that can be negative).
            pub trait Signed: Sized + Num + Neg<Output = Self> 
            {
                /// Computes the absolute value.
                ///
                /// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`.
                ///
                /// For signed integers, `::MIN` will be returned if the number is `::MIN`.
                fn abs(&self) -> Self;
                /// The positive difference of two numbers.
                ///
                /// Returns `zero` if the number is less than or equal to `other`, otherwise the difference
                /// between `self` and `other` is returned.
                fn abs_sub(&self, other: &Self) -> Self;
                /// Returns the sign of the number.
                ///
                /// For `f32` and `f64`:
                ///
                /// * `1.0` if the number is positive, `+0.0` or `INFINITY`
                /// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
                /// * `NaN` if the number is `NaN`
                ///
                /// For signed integers:
                ///
                /// * `0` if the number is zero
                /// * `1` if the number is positive
                /// * `-1` if the number is negative
                fn signum(&self) -> Self;
                /// Returns true if the number is positive and false if the number is zero or negative.
                fn is_positive(&self) -> bool;
                /// Returns true if the number is negative and false if the number is zero or positive.
                fn is_negative(&self) -> bool;
            }

            macro_rules! signed_impl 
            {
                ($($t:ty)*) => ($(
                    impl Signed for $t {
                        #[inline] fn abs(&self) -> $t {
                            if self.is_negative() { -*self } else { *self }
                        }

                        #[inline] fn abs_sub(&self, other: &$t) -> $t {
                            if *self <= *other { 0 } else { *self - *other }
                        }

                        #[inline] fn signum(&self) -> $t {
                            match *self {
                                n if n > 0 => 1,
                                0 => 0,
                                _ => -1,
                            }
                        }

                        #[inline] fn is_positive(&self) -> bool { *self > 0 }

                        #[inline] fn is_negative(&self) -> bool { *self < 0 }
                    }
                )*)
            }

            signed_impl!(isize i8 i16 i32 i64 i128);

            impl<T: Signed> Signed for Wrapping<T> where
                Wrapping<T>: Num + Neg<Output = Wrapping<T>>,
            {
                #[inline] fn abs(&self) -> Self {
                    Wrapping(self.0.abs())
                }

                #[inline] fn abs_sub(&self, other: &Self) -> Self {
                    Wrapping(self.0.abs_sub(&other.0))
                }

                #[inline] fn signum(&self) -> Self {
                    Wrapping(self.0.signum())
                }

                #[inline] fn is_positive(&self) -> bool {
                    self.0.is_positive()
                }

                #[inline] fn is_negative(&self) -> bool {
                    self.0.is_negative()
                }
            }

            macro_rules! signed_float_impl 
            {
                ($t:ty) => {
                    impl Signed for $t {
                        /// Computes the absolute value. Returns `NAN` if the number is `NAN`.
                        #[inline] fn abs(&self) -> $t {
                            FloatCore::abs(*self)
                        }

                        /// The positive difference of two numbers. Returns `0.0` if the number is
                        /// less than or equal to `other`, otherwise the difference between`self`
                        /// and `other` is returned.
                        #[inline] fn abs_sub(&self, other: &$t) -> $t {
                            if *self <= *other {
                                0.
                            } else {
                                *self - *other
                            }
                        }

                        /// # Returns
                        ///
                        /// - `1.0` if the number is positive, `+0.0` or `INFINITY`
                        /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
                        /// - `NAN` if the number is NaN
                        #[inline] fn signum(&self) -> $t {
                            FloatCore::signum(*self)
                        }

                        /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`
                        #[inline] fn is_positive(&self) -> bool {
                            FloatCore::is_sign_positive(*self)
                        }

                        /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`
                        #[inline] fn is_negative(&self) -> bool {
                            FloatCore::is_sign_negative(*self)
                        }
                    }
                };
            }

            signed_float_impl!(f32);
            signed_float_impl!(f64);
            /// Computes the absolute value.
            #[inline( always )] pub fn abs<T: Signed>(value: T) -> T
                {    value.abs()
            }
            /// The positive difference of two numbers.
            #[inline( always )] pub fn abs_sub<T: Signed>(x: T, y: T) -> T
                {    x.abs_sub(&y)
            }
            /// Returns the sign of the number.
            #[inline( always )] pub fn signum<T: Signed>(value: T) -> T
                {    value.signum()
            }
            /// A trait for values which cannot be negative
            pub trait Unsigned: Num {}

            macro_rules! empty_trait_impl {
                ($name:ident for $($t:ty)*) => ($(
                    impl $name for $t {}
                )*)
            }

            empty_trait_impl!(Unsigned for usize u8 u16 u32 u64 u128);

            impl<T: Unsigned> Unsigned for Wrapping<T> where Wrapping<T>: Num {}
        } pub use self::sign::{ * };
        /// The base trait for numeric types, covering `0` and `1` values, 
        /// comparisons, basic numeric operations, and string conversion.
        pub trait Num: PartialEq + Zero + One + NumOps
        {
            type FromStrRadixErr;
            /// Convert from a string and radix (typically `2..=36`).
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr>;
        }
        /// Generic trait for types implementing basic numeric operations
        pub trait NumOps<Rhs = Self, Output = Self>:
        Add<Rhs, Output = Output>
        + Sub<Rhs, Output = Output>
        + Mul<Rhs, Output = Output>
        + Div<Rhs, Output = Output>
        + Rem<Rhs, Output = Output>
        {
        }

        impl<T, Rhs, Output> NumOps<Rhs, Output> for T where
        T: Add<Rhs, Output = Output>
                + Sub<Rhs, Output = Output>
                + Mul<Rhs, Output = Output>
                + Div<Rhs, Output = Output>
                + Rem<Rhs, Output = Output>
        {
        }
        /// The trait for `Num` types which also implement numeric operations taking
        /// the second operand by reference.
        pub trait NumRef: Num + for<'r> NumOps<&'r Self> {}
        impl<T> NumRef for T where T: Num + for<'r> NumOps<&'r T> {}
        /// The trait for `Num` references which implement numeric operations, taking the
        /// second operand either by value or by reference.
        pub trait RefNum<Base>: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        impl<T, Base> RefNum<Base> for T where T: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        /// Generic trait for types implementing numeric assignment operators (like `+=`).
        pub trait NumAssignOps<Rhs = Self>:
            AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }

        impl<T, Rhs> NumAssignOps<Rhs> for T where
            T: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }
        /// The trait for `Num` types which also implement assignment operators.
        pub trait NumAssign: Num + NumAssignOps {}
        impl<T> NumAssign for T where T: Num + NumAssignOps {}
        /// The trait for `NumAssign` types which also implement assignment operations
        /// taking the second operand by reference.
        pub trait NumAssignRef: NumAssign + for<'r> NumAssignOps<&'r Self> {}
        impl<T> NumAssignRef for T where T: NumAssign + for<'r> NumAssignOps<&'r T> {}

        macro_rules! int_trait_impl 
        {
            ($name:ident for $($t:ty)*) => ($(
                impl $name for $t {
                    type FromStrRadixErr = ::num::ParseIntError;
                    #[inline] fn from_str_radix(s: &str, radix: u32)
                                    -> Result<Self, ::num::ParseIntError>
                    {
                        <$t>::from_str_radix(s, radix)
                    }
                }
            )*)
        }
        int_trait_impl!(Num for usize u8 u16 u32 u64 u128);
        int_trait_impl!(Num for isize i8 i16 i32 i64 i128);

        impl<T: Num> Num for Wrapping<T> where
        Wrapping<T>: NumOps
        {
            type FromStrRadixErr = T::FromStrRadixErr;
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> {
                T::from_str_radix(str, radix).map(Wrapping)
            }
        }

        #[derive( Debug )]
        pub enum FloatErrorKind 
        {
            Empty,
            Invalid,
        }
        
        #[derive( Debug )]
        pub struct ParseFloatError 
        {
            pub kind: FloatErrorKind,
        }

        impl fmt::Display for ParseFloatError 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let description = match self.kind {
                    FloatErrorKind::Empty => "cannot parse float from empty string",
                    FloatErrorKind::Invalid => "invalid float literal",
                };

                description.fmt(f)
            }
        }

        fn str_to_ascii_lower_eq_str(a: &str, b: &str) -> bool 
        {
            a.len() == b.len()
                && a.bytes().zip(b.bytes()).all(|(a, b)| {
                    let a_to_ascii_lower = a | (((b'A' <= a && a <= b'Z') as u8) << 5);
                    a_to_ascii_lower == b
                })
        }
        
        macro_rules! float_trait_impl 
        {
            ($name:ident for $($t:ident)*) => ($(
                impl $name for $t {
                    type FromStrRadixErr = ParseFloatError;

                    fn from_str_radix(src: &str, radix: u32)
                                    -> Result<Self, Self::FromStrRadixErr>
                    {
                        use self::FloatErrorKind::*;
                        use self::ParseFloatError as PFE;

                        // Special case radix 10 to use more accurate standard library implementation
                        if radix == 10 {
                            return src.parse().map_err(|_| PFE {
                                kind: if src.is_empty() { Empty } else { Invalid },
                            });
                        }

                        // Special values
                        if str_to_ascii_lower_eq_str(src, "inf")
                            || str_to_ascii_lower_eq_str(src, "infinity")
                        {
                            return Ok(std::$t::INFINITY);
                        } else if str_to_ascii_lower_eq_str(src, "-inf")
                            || str_to_ascii_lower_eq_str(src, "-infinity")
                        {
                            return Ok(std::$t::NEG_INFINITY);
                        } else if str_to_ascii_lower_eq_str(src, "nan") {
                            return Ok(std::$t::NAN);
                        } else if str_to_ascii_lower_eq_str(src, "-nan") {
                            return Ok(-std::$t::NAN);
                        }

                        fn slice_shift_char(src: &str) -> Option<(char, &str)> {
                            let mut chars = src.chars();
                            Some((chars.next()?, chars.as_str()))
                        }

                        let (is_positive, src) =  match slice_shift_char(src) {
                            None             => return Err(PFE { kind: Empty }),
                            Some(('-', ""))  => return Err(PFE { kind: Empty }),
                            Some(('-', src)) => (false, src),
                            Some((_, _))     => (true,  src),
                        };

                        // The significand to accumulate
                        let mut sig = if is_positive { 0.0 } else { -0.0 };
                        // Necessary to detect overflow
                        let mut prev_sig = sig;
                        let mut cs = src.chars().enumerate();
                        // Exponent prefix and exponent index offset
                        let mut exp_info = None::<(char, usize)>;

                        // Parse the integer part of the significand
                        for (i, c) in cs.by_ref() {
                            match c.to_digit(radix) {
                                Some(digit) => {
                                    // shift significand one digit left
                                    sig *= radix as $t;

                                    // add/subtract current digit depending on sign
                                    if is_positive {
                                        sig += (digit as isize) as $t;
                                    } else {
                                        sig -= (digit as isize) as $t;
                                    }

                                    // Detect overflow by comparing to last value, except
                                    // if we've not seen any non-zero digits.
                                    if prev_sig != 0.0 {
                                        if is_positive && sig <= prev_sig
                                            { return Ok(std::$t::INFINITY); }
                                        if !is_positive && sig >= prev_sig
                                            { return Ok(std::$t::NEG_INFINITY); }

                                        // Detect overflow by reversing the shift-and-add process
                                        if is_positive && (prev_sig != (sig - digit as $t) / radix as $t)
                                            { return Ok(std::$t::INFINITY); }
                                        if !is_positive && (prev_sig != (sig + digit as $t) / radix as $t)
                                            { return Ok(std::$t::NEG_INFINITY); }
                                    }
                                    prev_sig = sig;
                                },
                                None => match c {
                                    'e' | 'E' | 'p' | 'P' => {
                                        exp_info = Some((c, i + 1));
                                        break;  // start of exponent
                                    },
                                    '.' => {
                                        break;  // start of fractional part
                                    },
                                    _ => {
                                        return Err(PFE { kind: Invalid });
                                    },
                                },
                            }
                        }

                        if exp_info.is_none() {
                            let mut power = 1.0;
                            for (i, c) in cs.by_ref() {
                                match c.to_digit(radix) {
                                    Some(digit) => {
                                        // Decrease power one order of magnitude
                                        power /= radix as $t;
                                        // add/subtract current digit depending on sign
                                        sig = if is_positive {
                                            sig + (digit as $t) * power
                                        } else {
                                            sig - (digit as $t) * power
                                        };
                                        // Detect overflow by comparing to last value
                                        if is_positive && sig < prev_sig
                                            { return Ok(std::$t::INFINITY); }
                                        if !is_positive && sig > prev_sig
                                            { return Ok(std::$t::NEG_INFINITY); }
                                        prev_sig = sig;
                                    },
                                    None => match c {
                                        'e' | 'E' | 'p' | 'P' => {
                                            exp_info = Some((c, i + 1));
                                            break; // start of exponent
                                        },
                                        _ => {
                                            return Err(PFE { kind: Invalid });
                                        },
                                    },
                                }
                            }
                        }

                        // Parse and calculate the exponent
                        let exp = match exp_info {
                            Some((c, offset)) => {
                                let base = match c {
                                    'E' | 'e' if radix == 10 => 10.0,
                                    'P' | 'p' if radix == 16 => 2.0,
                                    _ => return Err(PFE { kind: Invalid }),
                                };

                                // Parse the exponent as decimal integer
                                let src = &src[offset..];
                                let (is_positive, exp) = match slice_shift_char(src) {
                                    Some(('-', src)) => (false, src.parse::<usize>()),
                                    Some(('+', src)) => (true,  src.parse::<usize>()),
                                    Some((_, _))     => (true,  src.parse::<usize>()),
                                    None             => return Err(PFE { kind: Invalid }),
                                };
                                
                                fn pow(base: $t, exp: usize) -> $t {
                                    Float::powi(base, exp as i32)
                                }
                                // otherwise uses the generic `pow` from the root

                                match (is_positive, exp) {
                                    (true,  Ok(exp)) => pow(base, exp),
                                    (false, Ok(exp)) => 1.0 / pow(base, exp),
                                    (_, Err(_))      => return Err(PFE { kind: Invalid }),
                                }
                            },
                            None => 1.0, // no exponent
                        };

                        Ok(sig * exp)
                    }
                }
            )*)
        }
        float_trait_impl!(Num for f32 f64);
        /// A value bounded by a minimum and a maximum
        #[inline] pub fn clamp<T: PartialOrd>( input:T, min:T, max:T ) -> T
        {
            debug_assert!(min <= max, "min must be less than or equal to max");
            if input < min {
                min
            } else if input > max {
                max
            } else {
                input
            }
        }
        /// A value bounded by a minimum value
        #[inline] pub fn clamp_min<T: PartialOrd>( input:T, min:T ) -> T
        {
            debug_assert!(min == min, "min must not be NAN");
            if input < min {
                min
            } else {
                input
            }
        }
        /// A value bounded by a maximum value
        #[inline] pub fn clamp_max<T: PartialOrd>( input:T, max:T ) -> T
        {
            debug_assert!(max == max, "max must not be NAN");
            if input > max {
                max
            } else {
                input
            }
        }
        
        macro_rules! define_valid_range_type 
        {
            ($(
                $(#[$m:meta])*
                $vis:vis struct $name:ident($int:ident as $uint:ident in $low:literal..=$high:literal);
            )+) => 
            {$(
                #[derive(Clone, Copy, Eq)]
                #[repr(transparent)]
                $(#[$m])*
                $vis struct $name($int);

                const _: () = 
                {
                    assert!(<$uint>::MIN == 0);
                    let ulow: $uint = $low;
                    let uhigh: $uint = $high;
                    assert!(ulow <= uhigh);
                    assert!(size_of::<$int>() == size_of::<$uint>());
                };

                impl $name 
                {
                    #[inline] pub const fn new(val: $int) -> Option<Self>
                    {
                        if (val as $uint) >= ($low as $uint) && (val as $uint) <= ($high as $uint)
                        { Some(unsafe { $name(val) }) } 
                        
                        else { None }
                    }

                    /// Constructs an instance of this type from the underlying integer primitive without checking whether its zero.
                    #[inline] pub const unsafe fn new_unchecked(val: $int) -> Self { unsafe { $name(val) } }
                    #[inline] pub const fn as_inner(self) -> $int { unsafe { ::mem::transmute(self) } }
                }
                
                /* impl StructuralPartialEq for $name {} */

                impl PartialEq for $name
                {
                    #[inline] fn eq(&self, other: &Self) -> bool { self.as_inner() == other.as_inner() }
                }

                impl Ord for $name
                {
                    #[inline] fn cmp(&self, other: &Self) -> Ordering { Ord::cmp(&self.as_inner(), &other.as_inner()) }
                }

                impl PartialOrd for $name
                {
                    #[inline] fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ord::cmp(self, other)) }
                }

                impl Hash for $name
                {
                    fn hash<H: Hasher>(&self, state: &mut H) { Hash::hash(&self.as_inner(), state); }
                }

                impl fmt::Debug for $name
                {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                    { <$int as fmt::Debug>::fmt(&self.as_inner(), f) }
                }
            )+};
        }

        define_valid_range_type! { pub struct Nanoseconds(u32 as u32 in 0..=999_999_999); }

        impl Nanoseconds
        { 
            pub const ZERO: Self = unsafe { Nanoseconds::new_unchecked(0) };
        }

        impl Default for Nanoseconds
        {
            #[inline] fn default() -> Self { Self::ZERO }
        }

        define_valid_range_type! 
        {
            pub struct NonZeroU8Inner(u8 as u8 in 1..=0xff);
            pub struct NonZeroU16Inner(u16 as u16 in 1..=0xff_ff);
            pub struct NonZeroU32Inner(u32 as u32 in 1..=0xffff_ffff);
            pub struct NonZeroU64Inner(u64 as u64 in 1..=0xffffffff_ffffffff);
            pub struct NonZeroU128Inner(u128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);

            pub struct NonZeroI8Inner(i8 as u8 in 1..=0xff);
            pub struct NonZeroI16Inner(i16 as u16 in 1..=0xff_ff);
            pub struct NonZeroI32Inner(i32 as u32 in 1..=0xffff_ffff);
            pub struct NonZeroI64Inner(i64 as u64 in 1..=0xffffffff_ffffffff);
            pub struct NonZeroI128Inner(i128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);
        }
        
        define_valid_range_type! 
        {
            pub struct UsizeNoHighBit(usize as usize in 0..=0x7fff_ffff_ffff_ffff);
            pub struct NonZeroUsizeInner(usize as usize in 1..=0xffff_ffff_ffff_ffff);
            pub struct NonZeroIsizeInner(isize as usize in 1..=0xffff_ffff_ffff_ffff);
        }

        define_valid_range_type! 
        {
            pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);
            pub struct I32NotAllOnes(i32 as u32 in 0..=0xffff_fffe);

            pub struct U64NotAllOnes(u64 as u64 in 0..=0xffff_ffff_ffff_fffe);
            pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);
        }

        pub trait NotAllOnesHelper
        {
            type Type;
        }

        pub type NotAllOnes<T> = <T as NotAllOnesHelper>::Type;
        impl NotAllOnesHelper for u32 { type Type = U32NotAllOnes; }
        impl NotAllOnesHelper for i32 { type Type = I32NotAllOnes; }
        impl NotAllOnesHelper for u64 { type Type = U64NotAllOnes; }
        impl NotAllOnesHelper for i64 { type Type = I64NotAllOnes; }
    }
}

pub mod ops
{
    pub use std::ops::{ * };
}

pub mod option
{
    pub use std::option::{ * };
}

pub mod parsers
{
    /*
    nom 7.1.3*/
    pub mod nom
    {
        //! # nom, eating data byte by byte
        #[macro_use] pub mod macros
        {
            use ::
            {
                *,
            };

            #[macro_export] macro_rules! succ 
            (
                (0, $submac:ident ! ($($rest:tt)*)) => ($submac!(1, $($rest)*));
                (1, $submac:ident ! ($($rest:tt)*)) => ($submac!(2, $($rest)*));
                (2, $submac:ident ! ($($rest:tt)*)) => ($submac!(3, $($rest)*));
                (3, $submac:ident ! ($($rest:tt)*)) => ($submac!(4, $($rest)*));
                (4, $submac:ident ! ($($rest:tt)*)) => ($submac!(5, $($rest)*));
                (5, $submac:ident ! ($($rest:tt)*)) => ($submac!(6, $($rest)*));
                (6, $submac:ident ! ($($rest:tt)*)) => ($submac!(7, $($rest)*));
                (7, $submac:ident ! ($($rest:tt)*)) => ($submac!(8, $($rest)*));
                (8, $submac:ident ! ($($rest:tt)*)) => ($submac!(9, $($rest)*));
                (9, $submac:ident ! ($($rest:tt)*)) => ($submac!(10, $($rest)*));
                (10, $submac:ident ! ($($rest:tt)*)) => ($submac!(11, $($rest)*));
                (11, $submac:ident ! ($($rest:tt)*)) => ($submac!(12, $($rest)*));
                (12, $submac:ident ! ($($rest:tt)*)) => ($submac!(13, $($rest)*));
                (13, $submac:ident ! ($($rest:tt)*)) => ($submac!(14, $($rest)*));
                (14, $submac:ident ! ($($rest:tt)*)) => ($submac!(15, $($rest)*));
                (15, $submac:ident ! ($($rest:tt)*)) => ($submac!(16, $($rest)*));
                (16, $submac:ident ! ($($rest:tt)*)) => ($submac!(17, $($rest)*));
                (17, $submac:ident ! ($($rest:tt)*)) => ($submac!(18, $($rest)*));
                (18, $submac:ident ! ($($rest:tt)*)) => ($submac!(19, $($rest)*));
                (19, $submac:ident ! ($($rest:tt)*)) => ($submac!(20, $($rest)*));
                (20, $submac:ident ! ($($rest:tt)*)) => ($submac!(21, $($rest)*));
            );
        }

        #[macro_use] pub mod error
        {
            //! Error management
            use ::
            {
                collections::{ HashMap },
                fmt::{ self, Write},
                hash::{ Hash, Hasher },
                parsers::nom::
                {
                    HexDisplay,
                    internal::Parser,
                    traits::Offset,
                },
                *,
            };
            /// Creates a parse error from a `nom::ErrorKind` and the position in the input
            #[macro_export(local_inner_macros)]
            macro_rules! error_position
            (
                ($input:expr, $code:expr) => 
                ({
                    ::parsers::nom::error::make_error($input, $code)
                });
            );
            /// Creates a parse error from a `nom::ErrorKind`, 
            /// the position in the input and the next error in the parsing tree.
            #[macro_export(local_inner_macros)] macro_rules! error_node_position
            (
                ($input:expr, $code:expr, $next:expr) => 
                ({
                    ::parsers::nom::error::append_error($input, $code, $next)
                });
            );
            /// This trait must be implemented by the error type of a nom parser.
            pub trait ParseError<I>: Sized 
            {
                /// Creates an error from the input position and an [ErrorKind]
                fn from_error_kind(input: I, kind: ErrorKind) -> Self;
                /// Combines an existing error with a new one created from the input position and an [ErrorKind].
                fn append(input: I, kind: ErrorKind, other: Self) -> Self;
                /// Creates an error from an input position and an expected character
                fn from_char(input: I, _: char) -> Self { Self::from_error_kind(input, ErrorKind::Char) }
                /// Combines two existing errors.
                fn or(self, other: Self) -> Self { other }
            }
            /// This trait is required by the `context` combinator to add a static string to an existing error.
            pub trait ContextError<I>: Sized 
            {
                /// Creates a new error from an input position, a static string and an existing error.
                fn add_context(_input: I, _ctx: &'static str, other: Self) -> Self { other }
            }
            /// Required by the `map_res` combinator to integrate error types from external functions.
            pub trait FromExternalError<I, E>
            {
                /// Creates a new error from an input position, 
                /// an [ErrorKind] indicating the wrapping parser, and an external error
                fn from_external_error(input: I, kind: ErrorKind, e: E) -> Self;
            }
            /// default error type, only contains the error' location and code
            #[derive(Debug, PartialEq)]
            pub struct Error<I>
            {
                /// position of the error in the input data
                pub input: I,
                /// nom error code
                pub code: ErrorKind,
            }

            impl<I> Error<I>
            {
                /// creates a new basic error
                pub fn new(input: I, code: ErrorKind) -> Error<I> { Error { input, code } }
            }

            impl<I> ParseError<I> for Error<I>
            {
                fn from_error_kind(input: I, kind: ErrorKind) -> Self { Error { input, code: kind } }

                fn append(_: I, _: ErrorKind, other: Self) -> Self { other }
            }

            impl<I> ContextError<I> for Error<I> {}

            impl<I, E> FromExternalError<I, E> for Error<I>
            {
                /// Create a new error from an input position and an external error
                fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self
                {
                    Error { input, code: kind }
                }
            }
            /// The Display implementation allows the ::error::Error implementation
            impl<I: fmt::Display> fmt::Display for Error<I>
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    write!(f, "error {:?} at: {}", self.code, self.input)
                }
            }
            
            impl<I: fmt::Debug + fmt::Display> ::error::Error for Error<I> {}
            
            impl<I> ParseError<I> for (I, ErrorKind)
            {
                fn from_error_kind(input: I, kind: ErrorKind) -> Self { (input, kind) }
                fn append(_: I, _: ErrorKind, other: Self) -> Self { other }
            }

            impl<I> ContextError<I> for (I, ErrorKind) {}

            impl<I, E> FromExternalError<I, E> for (I, ErrorKind)
            {
                fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self { (input, kind) }
            }

            impl<I> ParseError<I> for ()
            {
                fn from_error_kind(_: I, _: ErrorKind) -> Self {}
                fn append(_: I, _: ErrorKind, _: Self) -> Self {}
            }

            impl<I> ContextError<I> for () {}

            impl<I, E> FromExternalError<I, E> for ()
            {
                fn from_external_error(_input: I, _kind: ErrorKind, _e: E) -> Self {}
            }
            /// Creates an error from the input position and an [ErrorKind]
            pub fn make_error<I, E: ParseError<I>>(input: I, kind: ErrorKind) -> E
            {
                E::from_error_kind(input, kind)
            }
            /// Combines an existing error with a new one created from the input position and an [ErrorKind].
            pub fn append_error<I, E: ParseError<I>>(input: I, kind: ErrorKind, other: E) -> E
            {
                E::append(input, kind, other)
            }
            /// This error type accumulates errors and their position when backtracking through a parse tree.
            #[derive(Clone, Debug, PartialEq)]
            pub struct VerboseError<I> 
        {
            /// List of errors accumulated by `VerboseError`, containing the affected
            /// part of input data, and some context
            pub errors: ::vec::Vec<(I, VerboseErrorKind)>,
            }
            /// Error context for `VerboseError`
            #[derive(Clone, Debug, PartialEq)]
            pub enum VerboseErrorKind
            {
                /// Static string added by the `context` function
                Context(&'static str),
                /// Indicates which character was expected by the `char` function
                Char(char),
                /// Error kind given by various nom parsers
                Nom(ErrorKind),
            }

            impl<I> ParseError<I> for VerboseError<I>
            {
                fn from_error_kind(input: I, kind: ErrorKind) -> Self
                {
                    VerboseError
                    {
                        errors: vec![(input, VerboseErrorKind::Nom(kind))],
                    }
                }

                fn append(input: I, kind: ErrorKind, mut other: Self) -> Self
                {
                    other.errors.push((input, VerboseErrorKind::Nom(kind)));
                    other
                }

                fn from_char(input: I, c: char) -> Self
                {
                    VerboseError
                    {
                        errors: vec![(input, VerboseErrorKind::Char(c))],
                    }
                }
            }

            impl<I> ContextError<I> for VerboseError<I>
            {
                fn add_context(input: I, ctx: &'static str, mut other: Self) -> Self
                {
                    other.errors.push((input, VerboseErrorKind::Context(ctx)));
                    other
                }
            }

            impl<I, E> FromExternalError<I, E> for VerboseError<I>
            {
                /// Create a new error from an input position and an external error
                fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self { Self::from_error_kind(input, kind) }
            }

            impl<I: fmt::Display> fmt::Display for VerboseError<I>
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    writeln!(f, "Parse error:")?;
                    for (input, error) in &self.errors
                    {
                        match error
                        {
                            VerboseErrorKind::Nom(e) => writeln!(f, "{:?} at: {}", e, input)?,
                            VerboseErrorKind::Char(c) => writeln!(f, "expected '{}' at: {}", c, input)?,
                            VerboseErrorKind::Context(s) => writeln!(f, "in section '{}', at: {}", s, input)?,
                        }
                    }

                    Ok(())
                }
            }
            
            impl<I: fmt::Debug + fmt::Display> ::error::Error for VerboseError<I> {}

            use super::internal::{Err, IResult};
            /// Create a new error from an input position, a static string and an existing error.
            pub fn context<I: Clone, E: ContextError<I>, F, O>( context: &'static str, mut f: F ) 
            -> impl FnMut(I) -> IResult<I, O, E> where
            F: Parser<I, O, E>
            {
                move |i: I| match f.parse(i.clone())
                {
                    Ok(o) => Ok(o),
                    Err(Err::Incomplete(i)) => Err(Err::Incomplete(i)),
                    Err(Err::Error(e)) => Err(Err::Error(E::add_context(i, context, e))),
                    Err(Err::Failure(e)) => Err(Err::Failure(E::add_context(i, context, e))),
                }
            }
            /// Transforms a `VerboseError` into a trace with input position information
            pub fn convert_error<I: ::ops::Deref<Target = str>>( input: I, e: VerboseError<I> ) 
            -> ::string::String 
            {
                let mut result = ::string::String::new();

                for (i, (substring, kind)) in e.errors.iter().enumerate()
                {
                    let offset = input.offset(substring);

                    if input.is_empty()
                    {
                        match kind
                        {
                            VerboseErrorKind::Char(c) => { write!(&mut result, "{}: expected '{}', got empty input\n\n", i, c) }
                            VerboseErrorKind::Context(s) => write!(&mut result, "{}: in {}, got empty input\n\n", i, s),
                            VerboseErrorKind::Nom(e) => write!(&mut result, "{}: in {:?}, got empty input\n\n", i, e),
                        }
                    }
                    
                    else
                    {
                        let prefix = &input.as_bytes()[..offset];
                        let line_number = prefix.iter().filter(|&&b| b == b'\n').count() + 1;
                        let line_begin = prefix
                        .iter()
                        .rev()
                        .position(|&b| b == b'\n')
                        .map(|pos| offset - pos)
                        .unwrap_or(0);
                        
                        let line = input[line_begin..]
                        .lines()
                        .next()
                        .unwrap_or(&input[line_begin..])
                        .trim_end();
                        
                        let column_number = line.offset(substring) + 1;

                        match kind 
                        {
                            VerboseErrorKind::Char(c) =>
                            {
                                if let Some(actual) = substring.chars().next()
                                {
                                    write!
                                    (
                                        &mut result,
                                        "{i}: at line {line_number}:\n\
                                        {line}\n\
                                        {caret:>column$}\n\
                                        expected '{expected}', found {actual}\n\n",
                                        i = i,
                                        line_number = line_number,
                                        line = line,
                                        caret = '^',
                                        column = column_number,
                                        expected = c,
                                        actual = actual,
                                    )
                                }

                                else
                                {
                                    write!
                                    (
                                        &mut result,
                                        "{i}: at line {line_number}:\n\
                                        {line}\n\
                                        {caret:>column$}\n\
                                        expected '{expected}', got end of input\n\n",
                                        i = i,
                                        line_number = line_number,
                                        line = line,
                                        caret = '^',
                                        column = column_number,
                                        expected = c,
                                    )
                                }
                            }

                            VerboseErrorKind::Context(s) => write!
                            (
                                &mut result,
                                "{i}: at line {line_number}, in {context}:\n\
                                    {line}\n\
                                    {caret:>column$}\n\n",
                                i = i,
                                line_number = line_number,
                                context = s,
                                line = line,
                                caret = '^',
                                column = column_number,
                            ),

                            VerboseErrorKind::Nom(e) => write!
                            (
                                &mut result,
                                "{i}: at line {line_number}, in {nom_err:?}:\n\
                                    {line}\n\
                                    {caret:>column$}\n\n",
                                i = i,
                                line_number = line_number,
                                nom_err = e,
                                line = line,
                                caret = '^',
                                column = column_number,
                            ),
                        }
                    }.unwrap();
                }

                result
            }
            /// Indicates which parser returned an error
            #[derive( Debug,PartialEq,Eq,Hash,Clone,Copy )]
            pub enum ErrorKind
            {
                Tag,
                MapRes,
                MapOpt,
                Alt,
                IsNot,
                IsA,
                SeparatedList,
                SeparatedNonEmptyList,
                Many0,
                Many1,
                ManyTill,
                Count,
                TakeUntil,
                LengthValue,
                TagClosure,
                Alpha,
                Digit,
                HexDigit,
                OctDigit,
                AlphaNumeric,
                Space,
                MultiSpace,
                LengthValueFn,
                Eof,
                Switch,
                TagBits,
                OneOf,
                NoneOf,
                Char,
                CrLf,
                RegexpMatch,
                RegexpMatches,
                RegexpFind,
                RegexpCapture,
                RegexpCaptures,
                TakeWhile1,
                Complete,
                Fix,
                Escaped,
                EscapedTransform,
                NonEmpty,
                ManyMN,
                Not,
                Permutation,
                Verify,
                TakeTill1,
                TakeWhileMN,
                TooLarge,
                Many0Count,
                Many1Count,
                Float,
                Satisfy,
                Fail,
            }
            /// Converts an ErrorKind to a number
            pub fn error_to_u32(e: &ErrorKind) -> u32 
            {
                match *e
                {
                    ErrorKind::Tag                       => 1,
                    ErrorKind::MapRes                    => 2,
                    ErrorKind::MapOpt                    => 3,
                    ErrorKind::Alt                       => 4,
                    ErrorKind::IsNot                     => 5,
                    ErrorKind::IsA                       => 6,
                    ErrorKind::SeparatedList             => 7,
                    ErrorKind::SeparatedNonEmptyList     => 8,
                    ErrorKind::Many1                     => 9,
                    ErrorKind::Count                     => 10,
                    ErrorKind::TakeUntil                 => 12,
                    ErrorKind::LengthValue               => 15,
                    ErrorKind::TagClosure                => 16,
                    ErrorKind::Alpha                     => 17,
                    ErrorKind::Digit                     => 18,
                    ErrorKind::AlphaNumeric              => 19,
                    ErrorKind::Space                     => 20,
                    ErrorKind::MultiSpace                => 21,
                    ErrorKind::LengthValueFn             => 22,
                    ErrorKind::Eof                       => 23,
                    ErrorKind::Switch                    => 27,
                    ErrorKind::TagBits                   => 28,
                    ErrorKind::OneOf                     => 29,
                    ErrorKind::NoneOf                    => 30,
                    ErrorKind::Char                      => 40,
                    ErrorKind::CrLf                      => 41,
                    ErrorKind::RegexpMatch               => 42,
                    ErrorKind::RegexpMatches             => 43,
                    ErrorKind::RegexpFind                => 44,
                    ErrorKind::RegexpCapture             => 45,
                    ErrorKind::RegexpCaptures            => 46,
                    ErrorKind::TakeWhile1                => 47,
                    ErrorKind::Complete                  => 48,
                    ErrorKind::Fix                       => 49,
                    ErrorKind::Escaped                   => 50,
                    ErrorKind::EscapedTransform          => 51,
                    ErrorKind::NonEmpty                  => 56,
                    ErrorKind::ManyMN                    => 57,
                    ErrorKind::HexDigit                  => 59,
                    ErrorKind::OctDigit                  => 61,
                    ErrorKind::Many0                     => 62,
                    ErrorKind::Not                       => 63,
                    ErrorKind::Permutation               => 64,
                    ErrorKind::ManyTill                  => 65,
                    ErrorKind::Verify                    => 66,
                    ErrorKind::TakeTill1                 => 67,
                    ErrorKind::TakeWhileMN               => 69,
                    ErrorKind::TooLarge                  => 70,
                    ErrorKind::Many0Count                => 71,
                    ErrorKind::Many1Count                => 72,
                    ErrorKind::Float                     => 73,
                    ErrorKind::Satisfy                   => 74,
                    ErrorKind::Fail                      => 75,
                }
            }

            impl ErrorKind 
            {
                /// Converts an ErrorKind to a text description
                pub fn description(&self) -> &str
                {
                    match *self
                    {
                        ErrorKind::Tag                       => "Tag",
                        ErrorKind::MapRes                    => "Map on Result",
                        ErrorKind::MapOpt                    => "Map on Option",
                        ErrorKind::Alt                       => "Alternative",
                        ErrorKind::IsNot                     => "IsNot",
                        ErrorKind::IsA                       => "IsA",
                        ErrorKind::SeparatedList             => "Separated list",
                        ErrorKind::SeparatedNonEmptyList     => "Separated non empty list",
                        ErrorKind::Many0                     => "Many0",
                        ErrorKind::Many1                     => "Many1",
                        ErrorKind::Count                     => "Count",
                        ErrorKind::TakeUntil                 => "Take until",
                        ErrorKind::LengthValue               => "Length followed by value",
                        ErrorKind::TagClosure                => "Tag closure",
                        ErrorKind::Alpha                     => "Alphabetic",
                        ErrorKind::Digit                     => "Digit",
                        ErrorKind::AlphaNumeric              => "AlphaNumeric",
                        ErrorKind::Space                     => "Space",
                        ErrorKind::MultiSpace                => "Multiple spaces",
                        ErrorKind::LengthValueFn             => "LengthValueFn",
                        ErrorKind::Eof                       => "End of file",
                        ErrorKind::Switch                    => "Switch",
                        ErrorKind::TagBits                   => "Tag on bitstream",
                        ErrorKind::OneOf                     => "OneOf",
                        ErrorKind::NoneOf                    => "NoneOf",
                        ErrorKind::Char                      => "Char",
                        ErrorKind::CrLf                      => "CrLf",
                        ErrorKind::RegexpMatch               => "RegexpMatch",
                        ErrorKind::RegexpMatches             => "RegexpMatches",
                        ErrorKind::RegexpFind                => "RegexpFind",
                        ErrorKind::RegexpCapture             => "RegexpCapture",
                        ErrorKind::RegexpCaptures            => "RegexpCaptures",
                        ErrorKind::TakeWhile1                => "TakeWhile1",
                        ErrorKind::Complete                  => "Complete",
                        ErrorKind::Fix                       => "Fix",
                        ErrorKind::Escaped                   => "Escaped",
                        ErrorKind::EscapedTransform          => "EscapedTransform",
                        ErrorKind::NonEmpty                  => "NonEmpty",
                        ErrorKind::ManyMN                    => "Many(m, n)",
                        ErrorKind::HexDigit                  => "Hexadecimal Digit",
                        ErrorKind::OctDigit                  => "Octal digit",
                        ErrorKind::Not                       => "Negation",
                        ErrorKind::Permutation               => "Permutation",
                        ErrorKind::ManyTill                  => "ManyTill",
                        ErrorKind::Verify                    => "predicate verification",
                        ErrorKind::TakeTill1                 => "TakeTill1",
                        ErrorKind::TakeWhileMN               => "TakeWhileMN",
                        ErrorKind::TooLarge                  => "Needed data size is too large",
                        ErrorKind::Many0Count                => "Count occurrence of >=0 patterns",
                        ErrorKind::Many1Count                => "Count occurrence of >=1 patterns",
                        ErrorKind::Float                     => "Float",
                        ErrorKind::Satisfy                   => "Satisfy",
                        ErrorKind::Fail                      => "Fail",
                    }
                }
            }
            /// Prints a message and the input if the parser fails.
            pub fn dbg_dmp<'a, F, O, E: ::fmt::Debug>( f:F, context:&'static str ) 
            -> impl Fn(&'a [u8]) -> IResult<&'a [u8], O, E> where
            F: Fn(&'a [u8]) -> IResult<&'a [u8], O, E>,
            { 
                move |i: &'a [u8]| match f(i) 
                {
                    Err(e) => {
                    println!("{}: Error({:?}) at:\n{}", context, e, i.to_hex(8));
                    Err(e)
                    }
                    a => a,
                }
            }
        }

        pub mod branch
        {
            //! Choice combinators
            use ::
            {
                *,
            };
            use super::error::{ ErrorKind, ParseError };
            use super::internal::{Err, IResult, Parser};
            
            macro_rules! alt_trait
            (
                ($first:ident $second:ident $($id: ident)+) => (
                    alt_trait!(__impl $first $second; $($id)+);
                );
                (__impl $($current:ident)*; $head:ident $($id: ident)+) => (
                    alt_trait_impl!($($current)*);

                    alt_trait!(__impl $($current)* $head; $($id)+);
                );
                (__impl $($current:ident)*; $head:ident) => (
                    alt_trait_impl!($($current)*);
                    alt_trait_impl!($($current)* $head);
                );
            );

            macro_rules! alt_trait_impl
            (
                ($($id:ident)+) => (
                    impl<
                    Input: Clone, Output, Error: ParseError<Input>,
                    $($id: Parser<Input, Output, Error>),+
                    > Alt<Input, Output, Error> for ( $($id),+ ) {

                    fn choice(&mut self, input: Input) -> IResult<Input, Output, Error> {
                        match self.0.parse(input.clone()) {
                        Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),
                        res => res,
                        }
                    }
                    }
                );
            );

            macro_rules! alt_trait_inner
            (
                ($it:tt, $self:expr, $input:expr, $err:expr, $head:ident $($id:ident)+) => (
                    match $self.$it.parse($input.clone()) {
                    Err(Err::Error(e)) => {
                        let err = $err.or(e);
                        succ!($it, alt_trait_inner!($self, $input, err, $($id)+))
                    }
                    res => res,
                    }
                );
                ($it:tt, $self:expr, $input:expr, $err:expr, $head:ident) => (
                    Err(Err::Error(Error::append($input, ErrorKind::Alt, $err)))
                );
            );
            
            macro_rules! permutation_trait
            (
                (
                    $name1:ident $ty1:ident $item1:ident
                    $name2:ident $ty2:ident $item2:ident
                    $($name3:ident $ty3:ident $item3:ident)*
                ) => (
                    permutation_trait!(__impl $name1 $ty1 $item1, $name2 $ty2 $item2; $($name3 $ty3 $item3)*);
                );
                (
                    __impl $($name:ident $ty:ident $item:ident),+;
                    $name1:ident $ty1:ident $item1:ident $($name2:ident $ty2:ident $item2:ident)*
                ) => (
                    permutation_trait_impl!($($name $ty $item),+);
                    permutation_trait!(__impl $($name $ty $item),+ , $name1 $ty1 $item1; $($name2 $ty2 $item2)*);
                );
                (__impl $($name:ident $ty:ident $item:ident),+;) => (
                    permutation_trait_impl!($($name $ty $item),+);
                );
            );

            macro_rules! permutation_trait_impl
            (
                ($($name:ident $ty:ident $item:ident),+) => (
                    impl<
                    Input: Clone, $($ty),+ , Error: ParseError<Input>,
                    $($name: Parser<Input, $ty, Error>),+
                    > Permutation<Input, ( $($ty),+ ), Error> for ( $($name),+ )
                    {

                        fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>
                        {
                            let mut res = ($(Option::<$ty>::None),+);

                            loop
                            {
                                let mut err: Option<Error> = None;
                                permutation_trait_inner!(0, self, input, res, err, $($name)+);
                                
                                if let Some(err) = err
                                {
                                    return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));
                                }
                                
                                match res
                                {
                                    ($(Some($item)),+) => return Ok((input, ($($item),+))),
                                    _ => unreachable!(),
                                }
                            }
                        }
                    }
                );
            );

            macro_rules! permutation_trait_inner
            (
                ($it:tt, $self:expr, $input:ident, $res:expr, $err:expr, $head:ident $($id:ident)*) => (
                    if $res.$it.is_none() {
                    match $self.$it.parse($input.clone()) {
                        Ok((i, o)) => {
                        $input = i;
                        $res.$it = Some(o);
                        continue;
                        }
                        Err(Err::Error(e)) => {
                        $err = Some(match $err {
                            Some(err) => err.or(e),
                            None => e,
                        });
                        }
                        Err(e) => return Err(e),
                    };
                    }
                    succ!($it, permutation_trait_inner!($self, $input, $res, $err, $($id)*));
                );
                ($it:tt, $self:expr, $input:ident, $res:expr, $err:expr,) => ();
            );
            /// Helper trait for the [alt()] combinator.
            pub trait Alt<I, O, E> 
            {
                /// Tests each parser in the tuple and returns the result of the first one that succeeds
                fn choice(&mut self, input: I) -> IResult<I, O, E>;
            }
            /// Tests a list of parsers one by one until one succeeds.
            pub fn alt<I: Clone, O, E: ParseError<I>, List: Alt<I, O, E>>(
            mut l: List,
            ) -> impl FnMut(I) -> IResult<I, O, E>
            {
                move |i: I| l.choice(i)
            }
            /// Helper trait for the [permutation()] combinator.
            pub trait Permutation<I, O, E>
            {
                /// Tries to apply all parsers in the tuple in various orders until all of them succeed
                fn permutation(&mut self, input: I) -> IResult<I, O, E>;
            }
            /// Applies a list of parsers in any order.
            pub fn permutation<I: Clone, O, E: ParseError<I>, List: Permutation<I, O, E>>( mut l: List ) -> 
            impl FnMut(I) -> IResult<I, O, E>
            { move |i: I| l.permutation(i) }

            alt_trait!(A B C D E F G H I J K L M N O P Q R S T U);
            
            impl<Input, Output, Error: ParseError<Input>, A: Parser<Input, Output, Error>>
            Alt<Input, Output, Error> for (A,)
            {
                fn choice(&mut self, input: Input) -> IResult<Input, Output, Error> { self.0.parse(input) }
            }

            permutation_trait!
            (
                FnA A a
                FnB B b
                FnC C c
                FnD D d
                FnE E e
                FnF F f
                FnG G g
                FnH H h
                FnI I i
                FnJ J j
                FnK K k
                FnL L l
                FnM M m
                FnN N n
                FnO O o
                FnP P p
                FnQ Q q
                FnR R r
                FnS S s
                FnT T t
                FnU U u
            );
        }
        
        pub mod combinator
        {
            use ::
            {
                boxed::{ Box },
                borrow::{ Borrow },
                convert::{ Into },
                fmt::{ Debug },
                mem::{ transmute },
                ops::{Range, RangeFrom, RangeTo},
                parsers::nom::
                {
                    error::{ErrorKind, FromExternalError, ParseError},
                    internal::*,
                    traits::{AsChar, Compare, CompareResult, Offset, Slice, InputIter, InputLength, InputTakeAtPosition, ParseTo},
                },
                *,
            };
            /// Return the remaining input.
            #[inline] pub fn rest<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>>,
            T: InputLength,
            {
                Ok((input.slice(input.input_len()..), input))
            }
            /// Return the length of the remaining input.
            #[inline] pub fn rest_len<T, E: ParseError<T>>(input: T) -> IResult<T, usize, E> where
            T: InputLength,
            {
                let len = input.input_len();
                Ok((input, len))
            }
            /// Maps a function on the result of a parser.
            pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: FnMut(O1) -> O2,
            {
                move |input: I| {
                    let (input, o1) = parser.parse(input)?;
                    Ok((input, f(o1)))
                }
            }
            /// Applies a function returning a `Result` over the result of a parser.
            pub fn map_res<I: Clone, O1, O2, E: FromExternalError<I, E2>, E2, F, G>(
            mut parser: F,
            mut f: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: FnMut(O1) -> Result<O2, E2>,
            {
                move |input: I| {
                    let i = input.clone();
                    let (input, o1) = parser.parse(input)?;
                    match f(o1) {
                    Ok(o2) => Ok((input, o2)),
                    Err(e) => Err(Err::Error(E::from_external_error(i, ErrorKind::MapRes, e))),
                    }
                }
            }
            /// Applies a function returning an `Option` over the result of a parser.
            pub fn map_opt<I: Clone, O1, O2, E: ParseError<I>, F, G>(
            mut parser: F,
            mut f: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: FnMut(O1) -> Option<O2>,
            {
                move |input: I| {
                    let i = input.clone();
                    let (input, o1) = parser.parse(input)?;
                    match f(o1) {
                    Some(o2) => Ok((input, o2)),
                    None => Err(Err::Error(E::from_error_kind(i, ErrorKind::MapOpt))),
                    }
                }
            }
            /// Applies a parser over the result of another one.
            pub fn map_parser<I, O1, O2, E: ParseError<I>, F, G>(
            mut parser: F,
            mut applied_parser: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: Parser<O1, O2, E>,
            {
                move |input: I| {
                    let (input, o1) = parser.parse(input)?;
                    let (_, o2) = applied_parser.parse(o1)?;
                    Ok((input, o2))
                }
            }
            /// Creates a new parser from the output of the first parser,
            /// then apply that parser over the rest of the input.
            pub fn flat_map<I, O1, O2, E: ParseError<I>, F, G, H>(
            mut parser: F,
            mut applied_parser: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: FnMut(O1) -> H,
            H: Parser<I, O2, E>,
            {
                move |input: I| {
                    let (input, o1) = parser.parse(input)?;
                    applied_parser(o1).parse(input)
                }
            }
            /// Optional parser, will return `None` on [`Err::Error`].
            pub fn opt<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Option<O>, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| {
                    let i = input.clone();
                    match f.parse(input) {
                    Ok((i, o)) => Ok((i, Some(o))),
                    Err(Err::Error(_)) => Ok((i, None)),
                    Err(e) => Err(e),
                    }
                }
            }
            /// Calls the parser if the condition is met.
            pub fn cond<I, O, E: ParseError<I>, F>(
            b: bool,
            mut f: F,
            ) -> impl FnMut(I) -> IResult<I, Option<O>, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| {
                    if b {
                    match f.parse(input) {
                        Ok((i, o)) => Ok((i, Some(o))),
                        Err(e) => Err(e),
                    }
                    } else {
                    Ok((input, None))
                    }
                }
            }
            /// Tries to apply its parser without consuming the input.
            pub fn peek<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| {
                    let i = input.clone();
                    match f.parse(input) {
                    Ok((_, o)) => Ok((i, o)),
                    Err(e) => Err(e),
                    }
                }
            }
            /// returns its input if it is at the end of input data.
            pub fn eof<I: InputLength + Clone, E: ParseError<I>>( input:I ) -> IResult<I, I, E>
            {
                if input.input_len() == 0 {
                    let clone = input.clone();
                    Ok((input, clone))
                } else {
                    Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof)))
                }
            }
            /// Transforms Incomplete into `Error`.
            pub fn complete<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| {
                    let i = input.clone();
                    match f.parse(input) {
                    Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),
                    rest => rest,
                    }
                }
            }
            /// Succeeds if all the input has been consumed by its child parser.
            pub fn all_consuming<I, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E> where
            I: InputLength,
            F: Parser<I, O, E>,
            {
                move |input: I| {
                    let (input, res) = f.parse(input)?;
                    if input.input_len() == 0 {
                    Ok((input, res))
                    } else {
                    Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof)))
                    }
                }
            }
            /// Returns the result of the child parser if it satisfies a verification function.
            pub fn verify<I: Clone, O1, O2, E: ParseError<I>, F, G>(
            mut first: F,
            second: G,
            ) -> impl FnMut(I) -> IResult<I, O1, E> where
            F: Parser<I, O1, E>,
            G: Fn(&O2) -> bool,
            O1: Borrow<O2>,
            O2: ?Sized,
            {
                move |input: I| {
                    let i = input.clone();
                    let (input, o) = first.parse(input)?;

                    if second(o.borrow()) {
                    Ok((input, o))
                    } else {
                    Err(Err::Error(E::from_error_kind(i, ErrorKind::Verify)))
                    }
                }
            }
            /// Returns the provided value if the child parser succeeds.
            pub fn value<I, O1: Clone, O2, E: ParseError<I>, F>(
            val: O1,
            mut parser: F,
            ) -> impl FnMut(I) -> IResult<I, O1, E> where
            F: Parser<I, O2, E>,
            {
                move |input: I| parser.parse(input).map(|(i, _)| (i, val.clone()))
            }
            /// Succeeds if the child parser returns an error.
            pub fn not<I: Clone, O, E: ParseError<I>, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, (), E> where
            F: Parser<I, O, E>,
            {
                move |input: I| {
                    let i = input.clone();
                    match parser.parse(input) {
                    Ok(_) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Not))),
                    Err(Err::Error(_)) => Ok((i, ())),
                    Err(e) => Err(e),
                    }
                }
            }
            /// If the child parser was successful, return the consumed input as produced value.
            pub fn recognize<I: Clone + Offset + Slice<RangeTo<usize>>, O, E: ParseError<I>, F>(
            mut parser: F,
            ) -> impl FnMut(I) -> IResult<I, I, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| {
                    let i = input.clone();
                    match parser.parse(i) {
                    Ok((i, _)) => {
                        let index = input.offset(&i);
                        Ok((i, input.slice(..index)))
                    }
                    Err(e) => Err(e),
                    }
                }
            }
            /// if the child parser was successful, return the consumed input with the output as a tuple.
            pub fn consumed<I, O, F, E>(mut parser: F) -> impl FnMut(I) -> IResult<I, (I, O), E> where
            I: Clone + Offset + Slice<RangeTo<usize>>,
            E: ParseError<I>,
            F: Parser<I, O, E>,
            {
                move |input: I| {
                    let i = input.clone();
                    match parser.parse(i) {
                    Ok((remaining, result)) => {
                        let index = input.offset(&remaining);
                        let consumed = input.slice(..index);
                        Ok((remaining, (consumed, result)))
                    }
                    Err(e) => Err(e),
                    }
                }
            }
            /// Transforms an [`Err::Error`] (recoverable) to [`Err::Failure`] (unrecoverable)
            pub fn cut<I, O, E: ParseError<I>, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, O, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| match parser.parse(input) {
                    Err(Err::Error(e)) => Err(Err::Failure(e)),
                    rest => rest,
                }
            }
            /// automatically converts the child parser's result to another type
            pub fn into<I, O1, O2, E1, E2, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, O2, E2> where
            O1: Into<O2>,
            E1: Into<E2>,
            E1: ParseError<I>,
            E2: ParseError<I>,
            F: Parser<I, O1, E1>,
            {
                //map(parser, Into::into)
                move |input: I| match parser.parse(input) {
                    Ok((i, o)) => Ok((i, o.into())),
                    Err(Err::Error(e)) => Err(Err::Error(e.into())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.into())),
                    Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),
                }
            }
            /// Creates an iterator from input data and a parser.
            pub fn iterator<Input, Output, Error, F>(input: Input, f: F) -> ParserIterator<Input, Error, F> where
            F: Parser<Input, Output, Error>,
            Error: ParseError<Input>,
            {
                ParserIterator {
                    iterator: f,
                    input,
                    state: Some(State::Running),
                }
            }
            /// Main structure associated to the [iterator] function.
            pub struct ParserIterator<I, E, F>
            {
                iterator: F,
                input: I,
                state: Option<State<E>>,
            }

            impl<I: Clone, E, F> ParserIterator<I, E, F> 
            {
                /// Returns the remaining input if parsing was successful, or the error if we encountered an error.
                pub fn finish(mut self) -> IResult<I, (), E> {
                    match self.state.take().unwrap() {
                    State::Running | State::Done => Ok((self.input, ())),
                    State::Failure(e) => Err(Err::Failure(e)),
                    State::Incomplete(i) => Err(Err::Incomplete(i)),
                    }
                }
            }

            impl<'a, Input, Output, Error, F> ::iter::Iterator for &'a mut ParserIterator<Input, Error, F> where
            F: FnMut(Input) -> IResult<Input, Output, Error>,
            Input: Clone,
            {
                type Item = Output;

                fn next(&mut self) -> Option<Self::Item> {
                    if let State::Running = self.state.take().unwrap() {
                    let input = self.input.clone();

                    match (self.iterator)(input) {
                        Ok((i, o)) => {
                        self.input = i;
                        self.state = Some(State::Running);
                        Some(o)
                        }
                        Err(Err::Error(_)) => {
                        self.state = Some(State::Done);
                        None
                        }
                        Err(Err::Failure(e)) => {
                        self.state = Some(State::Failure(e));
                        None
                        }
                        Err(Err::Incomplete(i)) => {
                        self.state = Some(State::Incomplete(i));
                        None
                        }
                    }
                    } else {
                    None
                    }
                }
            }

            enum State<E>
            {
                Running,
                Done,
                Failure(E),
                Incomplete(Needed),
            }
            /// a parser which always succeeds with given value without consuming any input.
            pub fn success<I, O: Clone, E: ParseError<I>>(val: O) -> impl Fn(I) -> IResult<I, O, E> 
            {
                move |input: I| Ok((input, val.clone()))
            }
            /// A parser which always fails.
            pub fn fail<I, O, E: ParseError<I>>(i: I) -> IResult<I, O, E>
            {
                Err(Err::Error(E::from_error_kind(i, ErrorKind::Fail)))
            }
        }

        pub mod internal
        {
            //! Basic types to build the parsers
            use ::
            {
                borrow::{ ToOwned },
                boxed::{ Box },
                marker::{ PhantomData, Sized },
                num::NonZeroUsize,
                parsers::nom::
                {
                    error::{ self, ErrorKind, ParseError }
                },
                string::{ String },
                vec::{ Vec },
                *,
            };
            /// Holds the result of parsing functions.
            pub type IResult<I, O, E = error::Error<I>> = Result<(I, O), Err<E>>;
            /// Helper trait to convert a parser's result to a more manageable type
            pub trait Finish<I, O, E>
            {
                /// Converts the parser's result to a type that is more consumable by error management libraries.
                fn finish(self) -> Result<(I, O), E>;
            }

            impl<I, O, E> Finish<I, O, E> for IResult<I, O, E> 
            {
                fn finish(self) -> Result<(I, O), E> 
                {
                    match self {
                    Ok(res) => Ok(res),
                    Err(Err::Error(e)) | Err(Err::Failure(e)) => Err(e),
                    Err(Err::Incomplete(_)) => {
                        panic!("Cannot call `finish()` on `Err(Err::Incomplete(_))`: this result means that the parser does not have enough data to decide, you should gather more data and try to reapply  the parser instead")
                    }
                    }
                }
            }
            /// Contains information on needed data if a parser returned `Incomplete`
            #[derive(Debug, PartialEq, Eq, Clone, Copy)]
            pub enum Needed 
            {
                /// Needs more data, but we do not know how much
                Unknown,
                /// Contains the required data size in bytes
                Size(NonZeroUsize),
            }

            impl Needed 
            {
                /// Creates `Needed` instance, returns `Needed::Unknown` if the argument is zero
                pub fn new(s: usize) -> Self 
                {
                    match NonZeroUsize::new(s) {
                    Some(sz) => Needed::Size(sz),
                    None => Needed::Unknown,
                    }
                }
                /// Indicates if we know how many bytes we need
                pub fn is_known(&self) -> bool { *self != Needed::Unknown }
                /// Maps a `Needed` to `Needed` by applying a function to a contained `Size` value.
                #[inline] pub fn map<F: Fn(NonZeroUsize) -> usize>(self, f: F) -> Needed
                {
                    match self 
                    {
                        Needed::Unknown => Needed::Unknown,
                        Needed::Size(n) => Needed::new(f(n)),
                    }
                }
            }
            /// The `Err` enum indicates the parser was not successful.
            #[derive(Debug, Clone, PartialEq)]
            pub enum Err<E>
            {
                /// There was not enough data
                Incomplete(Needed),
                /// The parser had an error (recoverable)
                Error(E),
                /// The parser had an unrecoverable error: we got to the right
                /// branch and we know other branches won't work, so backtrack
                /// as fast as possible
                Failure(E),
            }

            impl<E> Err<E> 
            {
                /// Tests if the result is Incomplete
                pub fn is_incomplete(&self) -> bool {
                    if let Err::Incomplete(_) = self {
                    true
                    } else {
                    false
                    }
                }
                /// Applies the given function to the inner error
                pub fn map<E2, F>(self, f: F) -> Err<E2> where
                    F: FnOnce(E) -> E2,
                {
                    match self {
                    Err::Incomplete(n) => Err::Incomplete(n),
                    Err::Failure(t) => Err::Failure(f(t)),
                    Err::Error(t) => Err::Error(f(t)),
                    }
                }
                /// Automatically converts between errors if the underlying type supports it
                pub fn convert<F>(e: Err<F>) -> Self where
                    E: From<F>,
                {
                    e.map( ::convert::Into::into )
                }
            }

            impl<T> Err<(T, ErrorKind)>
            {
                /// Maps `Err<(T, ErrorKind)>` to `Err<(U, ErrorKind)>` with the given `F: T -> U`
                pub fn map_input<U, F>(self, f: F) -> Err<(U, ErrorKind)> where
                    F: FnOnce(T) -> U,
                {
                    match self {
                    Err::Incomplete(n) => Err::Incomplete(n),
                    Err::Failure((input, k)) => Err::Failure((f(input), k)),
                    Err::Error((input, k)) => Err::Error((f(input), k)),
                    }
                }
            }

            impl<T> Err<error::Error<T>> 
            {
                /// Maps `Err<error::Error<T>>` to `Err<error::Error<U>>` with the given `F: T -> U`
                pub fn map_input<U, F>(self, f: F) -> Err<error::Error<U>> where
                    F: FnOnce(T) -> U,
                {
                    match self {
                    Err::Incomplete(n) => Err::Incomplete(n),
                    Err::Failure(error::Error { input, code }) => Err::Failure(error::Error {
                        input: f(input),
                        code,
                    }),
                    Err::Error(error::Error { input, code }) => Err::Error(error::Error {
                        input: f(input),
                        code,
                    }),
                    }
                }
            }
            
            impl Err<(&[u8], ErrorKind)>
            {
                /// Obtaining ownership
                pub fn to_owned(self) -> Err<(Vec<u8>, ErrorKind)> {
                    self.map_input(ToOwned::to_owned)
                }
            }
            
            impl Err<(&str, ErrorKind)>
            {
                /// Obtaining ownership
                pub fn to_owned(self) -> Err<(String, ErrorKind)> {
                    self.map_input(ToOwned::to_owned)
                }
            }
            
            impl Err<error::Error<&[u8]>>
            {
                /// Obtaining ownership
                pub fn to_owned(self) -> Err<error::Error<Vec<u8>>> {
                    self.map_input(ToOwned::to_owned)
                }
            }
            
            impl Err<error::Error<&str>>
            {
                /// Obtaining ownership
                pub fn to_owned(self) -> Err<error::Error<String>> {
                    self.map_input(ToOwned::to_owned)
                }
            }

            impl<E: Eq> Eq for Err<E> {}

            impl<E> fmt::Display for Err<E> where
            E: fmt::Debug,
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    match self {
                    Err::Incomplete(Needed::Size(u)) => write!(f, "Parsing requires {} bytes/chars", u),
                    Err::Incomplete(Needed::Unknown) => write!(f, "Parsing requires more data"),
                    Err::Failure(c) => write!(f, "Parsing Failure: {:?}", c),
                    Err::Error(c) => write!(f, "Parsing Error: {:?}", c),
                    }
                }
            }
            
            use ::error::Error;
            
            impl<E> Error for Err<E> where
            E: fmt::Debug,
            {
                fn source(&self) -> Option<&(dyn Error + 'static)> {
                    None // no underlying error
                }
            }
            /// All nom parsers implement this trait
            pub trait Parser<I, O, E>
            {
                /// A parser takes in input type, 
                /// and returns a `Result` containing either the remaining input and the output value, or an error.
                fn parse(&mut self, input: I) -> IResult<I, O, E>;
                /// Maps a function over the result of a parser
                fn map<G, O2>(self, g: G) -> Map<Self, G, O> where
                    G: Fn(O) -> O2,
                    Self: Sized,
                {
                    Map {
                    f: self,
                    g,
                    phantom: PhantomData,
                    }
                }
                /// Creates a second parser from the output of the first one, then apply over the rest of the input
                fn flat_map<G, H, O2>(self, g: G) -> FlatMap<Self, G, O> where
                    G: FnMut(O) -> H,
                    H: Parser<I, O2, E>,
                    Self: Sized,
                {
                    FlatMap {
                    f: self,
                    g,
                    phantom: PhantomData,
                    }
                }
                /// Applies a second parser over the output of the first one
                fn and_then<G, O2>(self, g: G) -> AndThen<Self, G, O> where
                    G: Parser<O, O2, E>,
                    Self: Sized,
                {
                    AndThen {
                    f: self,
                    g,
                    phantom: PhantomData,
                    }
                }
                /// Applies a second parser after the first one, return their results as a tuple
                fn and<G, O2>(self, g: G) -> And<Self, G> where
                    G: Parser<I, O2, E>,
                    Self: Sized,
                {
                    And { f: self, g }
                }
                /// Applies a second parser over the input if the first one failed
                fn or<G>(self, g: G) -> Or<Self, G> where
                    G: Parser<I, O, E>,
                    Self: Sized,
                {
                    Or { f: self, g }
                }
                /// automatically converts the parser's output and error values to another type, as long as they
                /// implement the `From` trait
                fn into<O2: From<O>, E2: From<E>>(self) -> Into<Self, O, O2, E, E2> where
                    Self: Sized,
                {
                    Into {
                    f: self,
                    phantom_out1: PhantomData,
                    phantom_err1: PhantomData,
                    phantom_out2: PhantomData,
                    phantom_err2: PhantomData,
                    }
                }
            }

            impl<'a, I, O, E, F> Parser<I, O, E> for F where
            F: FnMut(I) -> IResult<I, O, E> + 'a,
            {
                fn parse(&mut self, i: I) -> IResult<I, O, E> {
                    self(i)
                }
            }
            
            impl<'a, I, O, E> Parser<I, O, E> for Box<dyn Parser<I, O, E> + 'a> 
            {
                fn parse(&mut self, input: I) -> IResult<I, O, E> {
                    (**self).parse(input)
                }
            }
            /// Implementation of `Parser::map`            
            pub struct Map<F, G, O1>
            {
                f: F,
                g: G,
                phantom: PhantomData<O1>,
            }

            impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Fn(O1) -> O2> Parser<I, O2, E> for Map<F, G, O1>
            {
                fn parse(&mut self, i: I) -> IResult<I, O2, E> {
                    match self.f.parse(i) {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, (self.g)(o))),
                    }
                }
            }
            /// Implementation of `Parser::flat_map`
            pub struct FlatMap<F, G, O1> 
            {
                f: F,
                g: G,
                phantom: PhantomData<O1>,
            }

            impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Fn(O1) -> H, H: Parser<I, O2, E>> Parser<I, O2, E>
            for FlatMap<F, G, O1>
            {
                fn parse(&mut self, i: I) -> IResult<I, O2, E> {
                    let (i, o1) = self.f.parse(i)?;
                    (self.g)(o1).parse(i)
                }
            }
            /// Implementation of `Parser::and_then`            
            pub struct AndThen<F, G, O1> 
            {
                f: F,
                g: G,
                phantom: PhantomData<O1>,
            }

            impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Parser<O1, O2, E>> Parser<I, O2, E>
            for AndThen<F, G, O1>
            {
                fn parse(&mut self, i: I) -> IResult<I, O2, E> {
                    let (i, o1) = self.f.parse(i)?;
                    let (_, o2) = self.g.parse(o1)?;
                    Ok((i, o2))
                }
            }
            /// Implementation of `Parser::and`            
            pub struct And<F, G> 
            {
                f: F,
                g: G,
            }

            impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Parser<I, O2, E>> Parser<I, (O1, O2), E>
            for And<F, G>
            {
                fn parse(&mut self, i: I) -> IResult<I, (O1, O2), E> {
                    let (i, o1) = self.f.parse(i)?;
                    let (i, o2) = self.g.parse(i)?;
                    Ok((i, (o1, o2)))
                }
            }
            /// Implementation of `Parser::or`            
            pub struct Or<F, G> 
            {
                f: F,
                g: G,
            }

            impl<'a, I: Clone, O, E: ParseError<I>, F: Parser<I, O, E>, G: Parser<I, O, E>>
            Parser<I, O, E> for Or<F, G>
            {
                fn parse(&mut self, i: I) -> IResult<I, O, E> {
                    match self.f.parse(i.clone()) {
                    Err(Err::Error(e1)) => match self.g.parse(i) {
                        Err(Err::Error(e2)) => Err(Err::Error(e1.or(e2))),
                        res => res,
                    },
                    res => res,
                    }
                }
            }
            /// Implementation of `Parser::into`
            pub struct Into<F, O1, O2: From<O1>, E1, E2: From<E1>> 
            {
                f: F,
                phantom_out1: PhantomData<O1>,
                phantom_err1: PhantomData<E1>,
                phantom_out2: PhantomData<O2>,
                phantom_err2: PhantomData<E2>,
            }

            impl<
                'a,
                I: Clone,
                O1,
                O2: From<O1>,
                E1,
                E2: ParseError<I> + From<E1>,
                F: Parser<I, O1, E1>,
            > Parser<I, O2, E2> for Into<F, O1, O2, E1, E2>
            {
                fn parse(&mut self, i: I) -> IResult<I, O2, E2> 
                {
                    match self.f.parse(i) {
                    Ok((i, o)) => Ok((i, o.into())),
                    Err(Err::Error(e)) => Err(Err::Error(e.into())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.into())),
                    Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),
                    }
                }
            }

        } pub use self::internal::*;
        
        pub mod multi
        {
            use ::
            {
                mem::{ size_of },
                num::{ NonZeroUsize },
                parsers::nom::
                {
                    error::{ ErrorKind, ParseError },
                    internal::{ Err, IResult, Needed, Parser },
                    traits::{ InputLength, InputTake, ToUsize },
                },
                vec::{ Vec },
                *,
            };
            /// Don't pre-allocate more than 64KiB when calling `Vec::with_capacity`.
            const MAX_INITIAL_CAPACITY_BYTES: usize = 65536;
            /// Repeats the embedded parser, gathering the results in a `Vec`.
            pub fn many0<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |mut i: I| {
                    let mut acc = Vec::with_capacity(4);
                    loop {
                    let len = i.input_len();
                    match f.parse(i.clone()) {
                        Err(Err::Error(_)) => return Ok((i, acc)),
                        Err(e) => return Err(e),
                        Ok((i1, o)) => {
                        // infinite loop check: the parser must always consume
                        if i1.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many0)));
                        }

                        i = i1;
                        acc.push(o);
                        }
                    }
                    }
                }
            }
            /// Runs the embedded parser, gathering the results in a `Vec`.
            pub fn many1<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |mut i: I| match f.parse(i.clone()) {
                    Err(Err::Error(err)) => Err(Err::Error(E::append(i, ErrorKind::Many1, err))),
                    Err(e) => Err(e),
                    Ok((i1, o)) => {
                    let mut acc = Vec::with_capacity(4);
                    acc.push(o);
                    i = i1;

                    loop {
                        let len = i.input_len();
                        match f.parse(i.clone()) {
                        Err(Err::Error(_)) => return Ok((i, acc)),
                        Err(e) => return Err(e),
                        Ok((i1, o)) => {
                            // infinite loop check: the parser must always consume
                            if i1.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1)));
                            }

                            i = i1;
                            acc.push(o);
                        }
                        }
                    }
                    }
                }
            }
            /// Applies the parser `f` until the parser `g` produces a result.
            pub fn many_till<I, O, P, E, F, G>(
            mut f: F,
            mut g: G,
            ) -> impl FnMut(I) -> IResult<I, (Vec<O>, P), E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: Parser<I, P, E>,
            E: ParseError<I>,
            {
                move |mut i: I| {
                    let mut res = Vec::new();
                    loop {
                    let len = i.input_len();
                    match g.parse(i.clone()) {
                        Ok((i1, o)) => return Ok((i1, (res, o))),
                        Err(Err::Error(_)) => {
                        match f.parse(i.clone()) {
                            Err(Err::Error(err)) => return Err(Err::Error(E::append(i, ErrorKind::ManyTill, err))),
                            Err(e) => return Err(e),
                            Ok((i1, o)) => {
                            // infinite loop check: the parser must always consume
                            if i1.input_len() == len {
                                return Err(Err::Error(E::from_error_kind(i1, ErrorKind::ManyTill)));
                            }

                            res.push(o);
                            i = i1;
                            }
                        }
                        }
                        Err(e) => return Err(e),
                    }
                    }
                }
            }
            /// Alternates between two parsers to produce a list of elements.
            pub fn separated_list0<I, O, O2, E, F, G>(
            mut sep: G,
            mut f: F,
            ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: Parser<I, O2, E>,
            E: ParseError<I>,
            {
                move |mut i: I| {
                    let mut res = Vec::new();

                    match f.parse(i.clone()) {
                    Err(Err::Error(_)) => return Ok((i, res)),
                    Err(e) => return Err(e),
                    Ok((i1, o)) => {
                        res.push(o);
                        i = i1;
                    }
                    }

                    loop {
                    let len = i.input_len();
                    match sep.parse(i.clone()) {
                        Err(Err::Error(_)) => return Ok((i, res)),
                        Err(e) => return Err(e),
                        Ok((i1, _)) => {
                        // infinite loop check: the parser must always consume
                        if i1.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList)));
                        }

                        match f.parse(i1.clone()) {
                            Err(Err::Error(_)) => return Ok((i, res)),
                            Err(e) => return Err(e),
                            Ok((i2, o)) => {
                            res.push(o);
                            i = i2;
                            }
                        }
                        }
                    }
                    }
                }
            }
            /// Alternates between two parsers to produce a list of elements until [`Err::Error`].
            pub fn separated_list1<I, O, O2, E, F, G>(
            mut sep: G,
            mut f: F,
            ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: Parser<I, O2, E>,
            E: ParseError<I>,
            {
                move |mut i: I| {
                    let mut res = Vec::new();

                    // Parse the first element
                    match f.parse(i.clone()) {
                    Err(e) => return Err(e),
                    Ok((i1, o)) => {
                        res.push(o);
                        i = i1;
                    }
                    }

                    loop {
                    let len = i.input_len();
                    match sep.parse(i.clone()) {
                        Err(Err::Error(_)) => return Ok((i, res)),
                        Err(e) => return Err(e),
                        Ok((i1, _)) => {
                        // infinite loop check: the parser must always consume
                        if i1.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList)));
                        }

                        match f.parse(i1.clone()) {
                            Err(Err::Error(_)) => return Ok((i, res)),
                            Err(e) => return Err(e),
                            Ok((i2, o)) => {
                            res.push(o);
                            i = i2;
                            }
                        }
                        }
                    }
                    }
                }
            }
            /// Repeats the embedded parser `m..=n` times.
            pub fn many_m_n<I, O, E, F>(
            min: usize,
            max: usize,
            mut parse: F,
            ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |mut input: I| {
                    if min > max {
                    return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN)));
                    }

                    let max_initial_capacity = MAX_INITIAL_CAPACITY_BYTES / size_of::<O>().max(1);
                    let mut res = Vec::with_capacity(min.min(max_initial_capacity));
                    for count in 0..max {
                    let len = input.input_len();
                    match parse.parse(input.clone()) {
                        Ok((tail, value)) => {
                        // infinite loop check: the parser must always consume
                        if tail.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(input, ErrorKind::ManyMN)));
                        }

                        res.push(value);
                        input = tail;
                        }
                        Err(Err::Error(e)) => {
                        if count < min {
                            return Err(Err::Error(E::append(input, ErrorKind::ManyMN, e)));
                        } else {
                            return Ok((input, res));
                        }
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }

                    Ok((input, res))
                }
            }
            /// Repeats the embedded parser, counting the results.
            pub fn many0_count<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, usize, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| {
                    let mut input = i;
                    let mut count = 0;

                    loop {
                    let input_ = input.clone();
                    let len = input.input_len();
                    match f.parse(input_) {
                        Ok((i, _)) => {
                        // infinite loop check: the parser must always consume
                        if i.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0Count)));
                        }

                        input = i;
                        count += 1;
                        }

                        Err(Err::Error(_)) => return Ok((input, count)),

                        Err(e) => return Err(e),
                    }
                    }
                }
            }
            /// Runs the embedded parser, counting the results.
            pub fn many1_count<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, usize, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| {
                    let i_ = i.clone();
                    match f.parse(i_) {
                    Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count))),
                    Err(i) => Err(i),
                    Ok((i1, _)) => {
                        let mut count = 1;
                        let mut input = i1;

                        loop {
                        let len = input.input_len();
                        let input_ = input.clone();
                        match f.parse(input_) {
                            Err(Err::Error(_)) => return Ok((input, count)),
                            Err(e) => return Err(e),
                            Ok((i, _)) => {
                            // infinite loop check: the parser must always consume
                            if i.input_len() == len {
                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count)));
                            }

                            count += 1;
                            input = i;
                            }
                        }
                        }
                    }
                    }
                }
            }
            /// Runs the embedded parser `count` times, gathering the results in a `Vec`.
            pub fn count<I, O, E, F>(mut f: F, count: usize) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + PartialEq,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| {
                    let mut input = i.clone();
                    let max_initial_capacity = MAX_INITIAL_CAPACITY_BYTES / size_of::<O>().max(1);
                    let mut res = Vec::with_capacity(count.min(max_initial_capacity));

                    for _ in 0..count {
                    let input_ = input.clone();
                    match f.parse(input_) {
                        Ok((i, o)) => {
                        res.push(o);
                        input = i;
                        }
                        Err(Err::Error(e)) => {
                        return Err(Err::Error(E::append(i, ErrorKind::Count, e)));
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }

                    Ok((input, res))
                }
            }
            /// Runs the embedded parser repeatedly, filling the given slice with results.
            pub fn fill<'a, I, O, E, F>(f: F, buf: &'a mut [O]) -> impl FnMut(I) -> IResult<I, (), E> + 'a where
            I: Clone + PartialEq,
            F: Fn(I) -> IResult<I, O, E> + 'a,
            E: ParseError<I>,
            {
                move |i: I| {
                    let mut input = i.clone();

                    for elem in buf.iter_mut() {
                    let input_ = input.clone();
                    match f(input_) {
                        Ok((i, o)) => {
                        *elem = o;
                        input = i;
                        }
                        Err(Err::Error(e)) => {
                        return Err(Err::Error(E::append(i, ErrorKind::Count, e)));
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }

                    Ok((input, ()))
                }
            }
            /// Repeats the embedded parser, calling `g` to gather the results.
            pub fn fold_many0<I, O, E, F, G, H, R>(
            mut f: F,
            mut init: H,
            mut g: G,
            ) -> impl FnMut(I) -> IResult<I, R, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: FnMut(R, O) -> R,
            H: FnMut() -> R,
            E: ParseError<I>,
            {
                move |i: I| {
                    let mut res = init();
                    let mut input = i;

                    loop {
                    let i_ = input.clone();
                    let len = input.input_len();
                    match f.parse(i_) {
                        Ok((i, o)) => {
                        // infinite loop check: the parser must always consume
                        if i.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0)));
                        }

                        res = g(res, o);
                        input = i;
                        }
                        Err(Err::Error(_)) => {
                        return Ok((input, res));
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }
                }
            }
            /// Repeats the embedded parser, calling `g` to gather the results.
            pub fn fold_many1<I, O, E, F, G, H, R>(
            mut f: F,
            mut init: H,
            mut g: G,
            ) -> impl FnMut(I) -> IResult<I, R, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: FnMut(R, O) -> R,
            H: FnMut() -> R,
            E: ParseError<I>,
            {
                move |i: I| {
                    let _i = i.clone();
                    let init = init();
                    match f.parse(_i) {
                    Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1))),
                    Err(e) => Err(e),
                    Ok((i1, o1)) => {
                        let mut acc = g(init, o1);
                        let mut input = i1;

                        loop {
                        let _input = input.clone();
                        let len = input.input_len();
                        match f.parse(_input) {
                            Err(Err::Error(_)) => {
                            break;
                            }
                            Err(e) => return Err(e),
                            Ok((i, o)) => {
                            // infinite loop check: the parser must always consume
                            if i.input_len() == len {
                                return Err(Err::Failure(E::from_error_kind(i, ErrorKind::Many1)));
                            }

                            acc = g(acc, o);
                            input = i;
                            }
                        }
                        }

                        Ok((input, acc))
                    }
                    }
                }
            }
            /// Repeats the embedded parser `m..=n` times, calling `g` to gather the results.
            pub fn fold_many_m_n<I, O, E, F, G, H, R>(
            min: usize,
            max: usize,
            mut parse: F,
            mut init: H,
            mut fold: G,
            ) -> impl FnMut(I) -> IResult<I, R, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: FnMut(R, O) -> R,
            H: FnMut() -> R,
            E: ParseError<I>,
            {
                move |mut input: I| {
                    if min > max {
                    return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN)));
                    }

                    let mut acc = init();
                    for count in 0..max {
                    let len = input.input_len();
                    match parse.parse(input.clone()) {
                        Ok((tail, value)) => {
                        if tail.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(tail, ErrorKind::ManyMN)));
                        }

                        acc = fold(acc, value);
                        input = tail;
                        }
                        Err(Err::Error(err)) => {
                        if count < min {
                            return Err(Err::Error(E::append(input, ErrorKind::ManyMN, err)));
                        } else {
                            break;
                        }
                        }
                        Err(e) => return Err(e),
                    }
                    }

                    Ok((input, acc))
                }
            }
            /// Gets a number from the parser and returns a subslice of the input of that size.
            pub fn length_data<I, N, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, I, E> where
            I: InputLength + InputTake,
            N: ToUsize,
            F: Parser<I, N, E>,
            E: ParseError<I>,
            {
                move |i: I| {
                    let (i, length) = f.parse(i)?;

                    let length: usize = length.to_usize();

                    if let Some(needed) = length
                    .checked_sub(i.input_len())
                    .and_then(NonZeroUsize::new)
                    {
                    Err(Err::Incomplete(Needed::Size(needed)))
                    } else {
                    Ok(i.take_split(length))
                    }
                }
            }
            /// Gets a number from the first parser, takes a subslice of the input of that size, 
            /// then applies the second parser on that subslice.
            pub fn length_value<I, O, N, E, F, G>(mut f: F, mut g: G) -> impl FnMut(I) -> IResult<I, O, E> where
            I: Clone + InputLength + InputTake,
            N: ToUsize,
            F: Parser<I, N, E>,
            G: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| {
                    let (i, length) = f.parse(i)?;

                    let length: usize = length.to_usize();

                    if let Some(needed) = length
                    .checked_sub(i.input_len())
                    .and_then(NonZeroUsize::new)
                    {
                    Err(Err::Incomplete(Needed::Size(needed)))
                    } else {
                    let (rest, i) = i.take_split(length);
                    match g.parse(i.clone()) {
                        Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),
                        Err(e) => Err(e),
                        Ok((_, o)) => Ok((rest, o)),
                    }
                    }
                }
            }
            /// Gets a number from the first parser, then applies the second parser that many times.
            pub fn length_count<I, O, N, E, F, G>(mut f: F, mut g: G) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone,
            N: ToUsize,
            F: Parser<I, N, E>,
            G: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| {
                    let (i, count) = f.parse(i)?;
                    let mut input = i.clone();
                    let mut res = Vec::new();

                    for _ in 0..count.to_usize() {
                    let input_ = input.clone();
                    match g.parse(input_) {
                        Ok((i, o)) => {
                        res.push(o);
                        input = i;
                        }
                        Err(Err::Error(e)) => {
                        return Err(Err::Error(E::append(i, ErrorKind::Count, e)));
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }

                    Ok((input, res))
                }
            }
        }
        
        pub mod sequence
        {
            //! Combinators applying parsers in sequence
            use ::
            {                
                parsers::nom::
                {
                    error::ParseError,
                    internal::{IResult, Parser},
                },
                *,
            };            

            macro_rules! tuple_trait
            (
                ($name1:ident $ty1:ident, $name2: ident $ty2:ident, $($name:ident $ty:ident),*) => (
                    tuple_trait!(__impl $name1 $ty1, $name2 $ty2; $($name $ty),*);
                );
                (__impl $($name:ident $ty: ident),+; $name1:ident $ty1:ident, $($name2:ident $ty2:ident),*) => (
                    tuple_trait_impl!($($name $ty),+);
                    tuple_trait!(__impl $($name $ty),+ , $name1 $ty1; $($name2 $ty2),*);
                );
                (__impl $($name:ident $ty: ident),+; $name1:ident $ty1:ident) => (
                    tuple_trait_impl!($($name $ty),+);
                    tuple_trait_impl!($($name $ty),+, $name1 $ty1);
                );
            );

            macro_rules! tuple_trait_impl
            (
                ($($name:ident $ty: ident),+) => (
                    impl<
                    Input: Clone, $($ty),+ , Error: ParseError<Input>,
                    $($name: Parser<Input, $ty, Error>),+
                    > Tuple<Input, ( $($ty),+ ), Error> for ( $($name),+ ) {

                    fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error> {
                        tuple_trait_inner!(0, self, input, (), $($name)+)

                    }
                    }
                );
            );

            macro_rules! tuple_trait_inner
            (
                ($it:tt, $self:expr, $input:expr, (), $head:ident $($id:ident)+) => ({
                    let (i, o) = $self.$it.parse($input.clone())?;

                    succ!($it, tuple_trait_inner!($self, i, ( o ), $($id)+))
                });
                ($it:tt, $self:expr, $input:expr, ($($parsed:tt)*), $head:ident $($id:ident)+) => ({
                    let (i, o) = $self.$it.parse($input.clone())?;

                    succ!($it, tuple_trait_inner!($self, i, ($($parsed)* , o), $($id)+))
                });
                ($it:tt, $self:expr, $input:expr, ($($parsed:tt)*), $head:ident) => ({
                    let (i, o) = $self.$it.parse($input.clone())?;

                    Ok((i, ($($parsed)* , o)))
                });
            );
            /// Gets an object from the first parser, then gets another object from the second parser.
            pub fn pair<I, O1, O2, E: ParseError<I>, F, G>(
            mut first: F,
            mut second: G,
            ) -> impl FnMut(I) -> IResult<I, (O1, O2), E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            {
                move |input: I| {
                    let (input, o1) = first.parse(input)?;
                    second.parse(input).map(|(i, o2)| (i, (o1, o2)))
                }
            }
            /// Matches an object from the first parser and discards it,
            /// then gets an object from the second parser.
            pub fn preceded<I, O1, O2, E: ParseError<I>, F, G>(
            mut first: F,
            mut second: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            {
                move |input: I| {
                    let (input, _) = first.parse(input)?;
                    second.parse(input)
                }
            }
            /// Gets an object from the first parser,
            /// then matches an object from the second parser and discards it.
            pub fn terminated<I, O1, O2, E: ParseError<I>, F, G>(
            mut first: F,
            mut second: G,
            ) -> impl FnMut(I) -> IResult<I, O1, E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            {
                move |input: I| {
                    let (input, o1) = first.parse(input)?;
                    second.parse(input).map(|(i, _)| (i, o1))
                }
            }
            /// Gets an object from the first parser,
            /// then matches an object from the sep_parser and discards it,
            /// then gets another object from the second parser.
            pub fn separated_pair<I, O1, O2, O3, E: ParseError<I>, F, G, H>(
            mut first: F,
            mut sep: G,
            mut second: H,
            ) -> impl FnMut(I) -> IResult<I, (O1, O3), E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            H: Parser<I, O3, E>,
            {
                move |input: I| {
                    let (input, o1) = first.parse(input)?;
                    let (input, _) = sep.parse(input)?;
                    second.parse(input).map(|(i, o2)| (i, (o1, o2)))
                }
            }
            /// Matches an object from the first parser and discards it,
            /// then gets an object from the second parser,
            /// and finally matches an object from the third parser and discards it.
            pub fn delimited<I, O1, O2, O3, E: ParseError<I>, F, G, H>(
            mut first: F,
            mut second: G,
            mut third: H,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            H: Parser<I, O3, E>,
            {
                move |input: I| {
                    let (input, _) = first.parse(input)?;
                    let (input, o2) = second.parse(input)?;
                    third.parse(input).map(|(i, _)| (i, o2))
                }
            }
            /// Helper trait for the tuple combinator.
            pub trait Tuple<I, O, E>
            {
                /// Parses the input and returns a tuple of results of each parser.
                fn parse(&mut self, input: I) -> IResult<I, O, E>;
            }

            impl<Input, Output, Error: ParseError<Input>, F: Parser<Input, Output, Error>>
            Tuple<Input, (Output,), Error> for (F,)
            {
                fn parse(&mut self, input: Input) -> IResult<Input, (Output,), Error>
                {
                    self.0.parse(input).map(|(i, o)| (i, (o,)))
                }
            }

            tuple_trait!(FnA A, FnB B, FnC C, FnD D, FnE E, FnF F, FnG G, FnH H, FnI I, FnJ J, FnK K, FnL L,
            FnM M, FnN N, FnO O, FnP P, FnQ Q, FnR R, FnS S, FnT T, FnU U);
            
            impl<I, E: ParseError<I>> Tuple<I, (), E> for () 
            {
                fn parse(&mut self, input: I) -> IResult<I, (), E> {
                    Ok((input, ()))
                }
            }
            /// Applies a tuple of parsers one by one and returns their results as a tuple.
            pub fn tuple<I, O, E: ParseError<I>, List: Tuple<I, O, E>>(
            mut l: List,
            ) -> impl FnMut(I) -> IResult<I, O, E> 
            {
                move |i: I| l.parse(i)
            }
        }
        
        pub mod traits
        {
            //! Traits input types have to implement to work with nom combinators            
            use ::
            {
                iter::{Copied, Enumerate},
                ops::{Range, RangeFrom, RangeFull, RangeTo},
                parsers::nom::
                {
                    error::{ self, ErrorKind, ParseError},
                    internal::{Err, IResult, Needed},
                },
                slice::Iter,
                str::{ Chars, CharIndices, FromStr, from_utf8, },
                string::{ String },
                vec::{ Vec },
                *,
            };
            
            macro_rules! as_bytes_array_impls 
            {
                ($($N:expr)+) => {
                    $(
                    impl<'a> AsBytes for &'a [u8; $N] 
                    {
                        #[inline(always)]
                        fn as_bytes(&self) -> &[u8] 
                        {
                        *self
                        }
                    }

                    impl AsBytes for [u8; $N] 
                    {
                        #[inline(always)]
                        fn as_bytes(&self) -> &[u8] 
                        {
                        self
                        }
                    }
                    )+
                };
            }
            
            macro_rules! impl_fn_slice
            {
                ( $ty:ty ) =>
                {
                    fn slice(&self, range: $ty) -> Self {
                    &self[range]
                    }
                };
            }

            macro_rules! slice_range_impl
            {
                ( [ $for_type:ident ], $ty:ty ) => {
                    impl<'a, $for_type> Slice<$ty> for &'a [$for_type] {
                    impl_fn_slice!($ty);
                    }
                };
                ( $for_type:ty, $ty:ty ) => {
                    impl<'a> Slice<$ty> for &'a $for_type {
                    impl_fn_slice!($ty);
                    }
                };
            }

            macro_rules! slice_ranges_impl
            {
                ( [ $for_type:ident ] ) => {
                    slice_range_impl! {[$for_type], Range<usize>}
                    slice_range_impl! {[$for_type], RangeTo<usize>}
                    slice_range_impl! {[$for_type], RangeFrom<usize>}
                    slice_range_impl! {[$for_type], RangeFull}
                };
                ( $for_type:ty ) => {
                    slice_range_impl! {$for_type, Range<usize>}
                    slice_range_impl! {$for_type, RangeTo<usize>}
                    slice_range_impl! {$for_type, RangeFrom<usize>}
                    slice_range_impl! {$for_type, RangeFull}
                };
            }

            macro_rules! array_impls
            {
                ($($N:expr)+) => {
                    $(
                    impl InputLength for [u8; $N] {
                        #[inline] fn input_len(&self) -> usize {
                        self.len()
                        }
                    }

                    impl<'a> InputLength for &'a [u8; $N] {
                        #[inline] fn input_len(&self) -> usize {
                        self.len()
                        }
                    }

                    impl<'a> InputIter for &'a [u8; $N] {
                        type Item = u8;
                        type Iter = Enumerate<Self::IterElem>;
                        type IterElem = Copied<Iter<'a, u8>>;

                        fn iter_indices(&self) -> Self::Iter {
                        (&self[..]).iter_indices()
                        }

                        fn iter_elements(&self) -> Self::IterElem {
                        (&self[..]).iter_elements()
                        }

                        fn position<P>(&self, predicate: P) -> Option<usize>
                        where P: Fn(Self::Item) -> bool {
                        (&self[..]).position(predicate)
                        }

                        fn slice_index(&self, count: usize) -> Result<usize, Needed> {
                        (&self[..]).slice_index(count)
                        }
                    }

                    impl<'a> Compare<[u8; $N]> for &'a [u8] {
                        #[inline(always)]
                        fn compare(&self, t: [u8; $N]) -> CompareResult {
                        self.compare(&t[..])
                        }

                        #[inline(always)]
                        fn compare_no_case(&self, t: [u8;$N]) -> CompareResult {
                        self.compare_no_case(&t[..])
                        }
                    }

                    impl<'a,'b> Compare<&'b [u8; $N]> for &'a [u8] {
                        #[inline(always)]
                        fn compare(&self, t: &'b [u8; $N]) -> CompareResult {
                        self.compare(&t[..])
                        }

                        #[inline(always)]
                        fn compare_no_case(&self, t: &'b [u8;$N]) -> CompareResult {
                        self.compare_no_case(&t[..])
                        }
                    }

                    impl FindToken<u8> for [u8; $N] {
                        fn find_token(&self, token: u8) -> bool {
                        memchr::memchr(token, &self[..]).is_some()
                        }
                    }

                    impl<'a> FindToken<&'a u8> for [u8; $N] {
                        fn find_token(&self, token: &u8) -> bool {
                        self.find_token(*token)
                        }
                    }
                    )+
                };
            }
            /// Abstract method to calculate the input length
            pub trait InputLength 
            {
                /// Calculates the input length, as indicated by its name,
                /// and the name of the trait itself
                fn input_len(&self) -> usize;
            }

            impl<'a, T> InputLength for &'a [T] 
            {
                #[inline] fn input_len(&self) -> usize 
                {
                    self.len()
                }
            }

            impl<'a> InputLength for &'a str 
            {
                #[inline] fn input_len(&self) -> usize 
                {
                    self.len()
                }
            }

            impl<'a> InputLength for (&'a [u8], usize) 
            {
                #[inline] fn input_len(&self) -> usize 
                {
                    //println!("bit input length for ({:?}, {}):", self.0, self.1);
                    //println!("-> {}", self.0.len() * 8 - self.1);
                    self.0.len() * 8 - self.1
                }
            }
            /// Useful functions to calculate the offset between slices and show a hexdump of a slice
            pub trait Offset 
            {
                /// Offset between the first byte of self and the first byte of the argument
                fn offset(&self, second: &Self) -> usize;
            }

            impl Offset for [u8] 
            {
                fn offset(&self, second: &Self) -> usize {
                    let fst = self.as_ptr();
                    let snd = second.as_ptr();

                    snd as usize - fst as usize
                }
            }

            impl<'a> Offset for &'a [u8]
            {
                fn offset(&self, second: &Self) -> usize {
                    let fst = self.as_ptr();
                    let snd = second.as_ptr();

                    snd as usize - fst as usize
                }
            }

            impl Offset for str
            {
                fn offset(&self, second: &Self) -> usize {
                    let fst = self.as_ptr();
                    let snd = second.as_ptr();

                    snd as usize - fst as usize
                }
            }

            impl<'a> Offset for &'a str
            {
                fn offset(&self, second: &Self) -> usize {
                    let fst = self.as_ptr();
                    let snd = second.as_ptr();

                    snd as usize - fst as usize
                }
            }
            /// Helper trait for types that can be viewed as a byte slice
            pub trait AsBytes 
            {
                /// Casts the input type to a byte slice
                fn as_bytes(&self) -> &[u8];
            }

            impl<'a> AsBytes for &'a str
            {
                #[inline( always )] fn as_bytes(&self) -> &[u8] {
                    (*self).as_bytes()
                }
            }

            impl AsBytes for str 
            {
                #[inline( always )] fn as_bytes(&self) -> &[u8]  { self.as_ref() }
            }

            impl<'a> AsBytes for &'a [u8] 
            {
                #[inline( always )] fn as_bytes(&self) -> &[u8] 
                {
                    *self
                }
            }

            impl AsBytes for [u8] 
            {
                #[inline( always )] fn as_bytes(&self) -> &[u8] 
                {
                    self
                }
            }

            as_bytes_array_impls!
            {
                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
                17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
            }
            /// Transforms common types to a char for basic token parsing
            pub trait AsChar 
            {
                /// makes a char from self
                fn as_char(self) -> char;
                /// Tests that self is an alphabetic character
                ///
                /// Warning: for `&str` it recognizes alphabetic
                /// characters outside of the 52 ASCII letters
                fn is_alpha(self) -> bool;
                /// Tests that self is an alphabetic character
                /// or a decimal digit
                fn is_alphanum(self) -> bool;
                /// Tests that self is a decimal digit
                fn is_dec_digit(self) -> bool;
                /// Tests that self is an hex digit
                fn is_hex_digit(self) -> bool;
                /// Tests that self is an octal digit
                fn is_oct_digit(self) -> bool;
                /// Gets the len in bytes for self
                fn len(self) -> usize;
            }

            impl AsChar for u8 
            {
                #[inline] fn as_char(self) -> char {
                    self as char
                }
                #[inline] fn is_alpha(self) -> bool {
                    (self >= 0x41 && self <= 0x5A) || (self >= 0x61 && self <= 0x7A)
                }
                #[inline] fn is_alphanum(self) -> bool {
                    self.is_alpha() || self.is_dec_digit()
                }
                #[inline] fn is_dec_digit(self) -> bool {
                    self >= 0x30 && self <= 0x39
                }
                #[inline] fn is_hex_digit(self) -> bool {
                    (self >= 0x30 && self <= 0x39)
                    || (self >= 0x41 && self <= 0x46)
                    || (self >= 0x61 && self <= 0x66)
                }
                #[inline] fn is_oct_digit(self) -> bool {
                    self >= 0x30 && self <= 0x37
                }
                #[inline] fn len(self) -> usize {
                    1
                }
            }

            impl<'a> AsChar for &'a u8
            {
                #[inline] fn as_char(self) -> char {
                    *self as char
                }
                #[inline] fn is_alpha(self) -> bool {
                    (*self >= 0x41 && *self <= 0x5A) || (*self >= 0x61 && *self <= 0x7A)
                }
                #[inline] fn is_alphanum(self) -> bool {
                    self.is_alpha() || self.is_dec_digit()
                }
                #[inline] fn is_dec_digit(self) -> bool {
                    *self >= 0x30 && *self <= 0x39
                }
                #[inline] fn is_hex_digit(self) -> bool {
                    (*self >= 0x30 && *self <= 0x39)
                    || (*self >= 0x41 && *self <= 0x46)
                    || (*self >= 0x61 && *self <= 0x66)
                }
                #[inline] fn is_oct_digit(self) -> bool {
                    *self >= 0x30 && *self <= 0x37
                }
                #[inline] fn len(self) -> usize {
                    1
                }
            }

            impl AsChar for char
            {
                #[inline] fn as_char(self) -> char {
                    self
                }
                #[inline] fn is_alpha(self) -> bool {
                    self.is_ascii_alphabetic()
                }
                #[inline] fn is_alphanum(self) -> bool {
                    self.is_alpha() || self.is_dec_digit()
                }
                #[inline] fn is_dec_digit(self) -> bool {
                    self.is_ascii_digit()
                }
                #[inline] fn is_hex_digit(self) -> bool {
                    self.is_ascii_hexdigit()
                }
                #[inline] fn is_oct_digit(self) -> bool {
                    self.is_digit(8)
                }
                #[inline] fn len(self) -> usize {
                    self.len_utf8()
                }
            }

            impl<'a> AsChar for &'a char
            {
                #[inline] fn as_char(self) -> char 
                {
                    *self
                }

                #[inline] fn is_alpha(self) -> bool 
                {
                    self.is_ascii_alphabetic()
                }

                #[inline] fn is_alphanum(self) -> bool 
                {
                    self.is_alpha() || self.is_dec_digit()
                }

                #[inline] fn is_dec_digit(self) -> bool 
                {
                    self.is_ascii_digit()
                }

                #[inline] fn is_hex_digit(self) -> bool 
                {
                    self.is_ascii_hexdigit()
                }

                #[inline] fn is_oct_digit(self) -> bool 
                {
                    self.is_digit(8)
                }

                #[inline] fn len(self) -> usize 
                {
                    self.len_utf8()
                }

            }
            /// Abstracts common iteration operations on the input type
            pub trait InputIter 
            {
                /// The current input type is a sequence of that `Item` type.
                ///
                /// Example: `u8` for `&[u8]` or `char` for `&str`
                type Item;
                /// An iterator over the input type, producing the item and its position
                /// for use with [Slice]. If we're iterating over `&str`, the position
                /// corresponds to the byte index of the character
                type Iter: Iterator<Item = (usize, Self::Item)>;
                /// An iterator over the input type, producing the item
                type IterElem: Iterator<Item = Self::Item>;
                /// Returns an iterator over the elements and their byte offsets
                fn iter_indices(&self) -> Self::Iter;
                /// Returns an iterator over the elements
                fn iter_elements(&self) -> Self::IterElem;
                /// Finds the byte position of the element
                fn position<P>(&self, predicate: P) -> Option<usize> where
                    P: Fn(Self::Item) -> bool;
                /// Get the byte offset from the element's position in the stream
                fn slice_index(&self, count: usize) -> Result<usize, Needed>;
            }
            /// Abstracts slicing operations
            pub trait InputTake: Sized
            {
                /// Returns a slice of `count` bytes. panics if count > length
                fn take(&self, count: usize) -> Self;
                /// Split the stream at the `count` byte offset. panics if count > length
                fn take_split(&self, count: usize) -> (Self, Self);
            }

            impl<'a> InputIter for &'a [u8]
            {
                type Item = u8;
                type Iter = Enumerate<Self::IterElem>;
                type IterElem = Copied<Iter<'a, u8>>;

                #[inline] fn iter_indices(&self) -> Self::Iter {
                    self.iter_elements().enumerate()
                }
                #[inline] fn iter_elements(&self) -> Self::IterElem {
                    self.iter().copied()
                }
                #[inline] fn position<P>(&self, predicate: P) -> Option<usize> where
                    P: Fn(Self::Item) -> bool,
                {
                    self.iter().position(|b| predicate(*b))
                }
                #[inline] fn slice_index(&self, count: usize) -> Result<usize, Needed> {
                    if self.len() >= count {
                    Ok(count)
                    } else {
                    Err(Needed::new(count - self.len()))
                    }
                }
            }

            impl<'a> InputTake for &'a [u8]
            {
                #[inline] fn take(&self, count: usize) -> Self {
                    &self[0..count]
                }
                #[inline] fn take_split(&self, count: usize) -> (Self, Self) {
                    let (prefix, suffix) = self.split_at(count);
                    (suffix, prefix)
                }
            }

            impl<'a> InputIter for &'a str
            {
                type Item = char;
                type Iter = CharIndices<'a>;
                type IterElem = Chars<'a>;
                #[inline] fn iter_indices(&self) -> Self::Iter {
                    self.char_indices()
                }
                #[inline] fn iter_elements(&self) -> Self::IterElem {
                    self.chars()
                }
                fn position<P>(&self, predicate: P) -> Option<usize> where
                    P: Fn(Self::Item) -> bool,
                {
                    for (o, c) in self.char_indices() {
                    if predicate(c) {
                        return Some(o);
                    }
                    }
                    None
                }
                #[inline] fn slice_index(&self, count: usize) -> Result<usize, Needed> {
                    let mut cnt = 0;
                    for (index, _) in self.char_indices() {
                    if cnt == count {
                        return Ok(index);
                    }
                    cnt += 1;
                    }
                    if cnt == count {
                    return Ok(self.len());
                    }
                    Err(Needed::Unknown)
                }
            }

            impl<'a> InputTake for &'a str
            {
                #[inline] fn take(&self, count: usize) -> Self {
                    &self[..count]
                }
                
                #[inline] fn take_split(&self, count: usize) -> (Self, Self) {
                    let (prefix, suffix) = self.split_at(count);
                    (suffix, prefix)
                }
            }
            /// Dummy trait used for default implementations.
            pub trait UnspecializedInput {}
            /// Methods to take as much input as possible 
            /// until the provided function returns true for the current element.
            pub trait InputTakeAtPosition: Sized 
            {
                /// The current input type is a sequence of that `Item` type.
                type Item;
                /// Looks for the first element of the input type for which the condition returns true,
                /// and returns the input up to this position.
                fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool;
                /// Looks for the first element of the input type for which the condition returns true
                /// and returns the input up to this position.
                fn split_at_position1<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool;
                /// Looks for the first element of the input type for which the condition returns true,
                /// and returns the input up to this position.
                fn split_at_position_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool;
                /// Looks for the first element of the input type for which the condition returns true
                /// and returns the input up to this position.
                fn split_at_position1_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool;
            }

            impl<T: InputLength + InputIter + InputTake + Clone + UnspecializedInput> InputTakeAtPosition
            for T
            {
                type Item = <T as InputIter>::Item;

                fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.position(predicate) {
                    Some(n) => Ok(self.take_split(n)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position1<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.position(predicate) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self.clone(), e))),
                    Some(n) => Ok(self.take_split(n)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.split_at_position(predicate) {
                    Err(Err::Incomplete(_)) => Ok(self.take_split(self.input_len())),
                    res => res,
                    }
                }

                fn split_at_position1_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.split_at_position1(predicate, e) {
                    Err(Err::Incomplete(_)) => {
                        if self.input_len() == 0 {
                        Err(Err::Error(E::from_error_kind(self.clone(), e)))
                        } else {
                        Ok(self.take_split(self.input_len()))
                        }
                    }
                    res => res,
                    }
                }
            }

            impl<'a> InputTakeAtPosition for &'a [u8] 
            {
                type Item = u8;

                fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.iter().position(|c| predicate(*c)) {
                    Some(i) => Ok(self.take_split(i)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position1<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.iter().position(|c| predicate(*c)) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => Ok(self.take_split(i)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.iter().position(|c| predicate(*c)) {
                    Some(i) => Ok(self.take_split(i)),
                    None => Ok(self.take_split(self.input_len())),
                    }
                }

                fn split_at_position1_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.iter().position(|c| predicate(*c)) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => Ok(self.take_split(i)),
                    None => {
                        if self.is_empty() {
                        Err(Err::Error(E::from_error_kind(self, e)))
                        } else {
                        Ok(self.take_split(self.input_len()))
                        }
                    }
                    }
                }
            }

            impl<'a> InputTakeAtPosition for &'a str 
            {
                type Item = char;

                fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.find(predicate) {
                    // find() returns a byte index that is already in the slice at a char boundary
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position1<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.find(predicate) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    // find() returns a byte index that is already in the slice at a char boundary
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.find(predicate) {
                    // find() returns a byte index that is already in the slice at a char boundary
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    // the end of slice is a char boundary
                    None => unsafe {
                        Ok((
                        self.get_unchecked(self.len()..),
                        self.get_unchecked(..self.len()),
                        ))
                    },
                    }
                }

                fn split_at_position1_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.find(predicate) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    // find() returns a byte index that is already in the slice at a char boundary
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => {
                        if self.is_empty() {
                        Err(Err::Error(E::from_error_kind(self, e)))
                        } else {
                        // the end of slice is a char boundary
                        unsafe {
                            Ok((
                            self.get_unchecked(self.len()..),
                            self.get_unchecked(..self.len()),
                            ))
                        }
                        }
                    }
                    }
                }
            }
            /// Indicates whether a comparison was successful, an error, or if more data was needed
            #[derive(Debug, PartialEq)]
            pub enum CompareResult
            {
                /// Comparison was successful
                Ok,
                /// We need more data to be sure
                Incomplete,
                /// Comparison failed
                Error,
            }
            /// Abstracts comparison operations
            pub trait Compare<T> 
            {
                /// Compares self to another value for equality
                fn compare(&self, t: T) -> CompareResult;
                /// Compares self to another value for equality
                /// independently of the case.
                fn compare_no_case(&self, t: T) -> CompareResult;
            }

            fn lowercase_byte(c: u8) -> u8 
            {
                match c {
                    b'A'..=b'Z' => c - b'A' + b'a',
                    _ => c,
                }
            }

            impl<'a, 'b> Compare<&'b [u8]> for &'a [u8] 
            {
                #[inline( always )] fn compare(&self, t: &'b [u8]) -> CompareResult {
                    let pos = self.iter().zip(t.iter()).position(|(a, b)| a != b);

                    match pos {
                    Some(_) => CompareResult::Error,
                    None => {
                        if self.len() >= t.len() {
                        CompareResult::Ok
                        } else {
                        CompareResult::Incomplete
                        }
                    }
                    }
                }

                #[inline( always )] fn compare_no_case(&self, t: &'b [u8]) -> CompareResult {
                    if self
                    .iter()
                    .zip(t)
                    .any(|(a, b)| lowercase_byte(*a) != lowercase_byte(*b))
                    {
                    CompareResult::Error
                    } else if self.len() < t.len() {
                    CompareResult::Incomplete
                    } else {
                    CompareResult::Ok
                    }
                }
            }

            impl<
                T: InputLength + InputIter<Item = u8> + InputTake + UnspecializedInput,
                O: InputLength + InputIter<Item = u8> + InputTake,
            > Compare<O> for T
            {
                #[inline( always )] fn compare(&self, t: O) -> CompareResult {
                    let pos = self
                    .iter_elements()
                    .zip(t.iter_elements())
                    .position(|(a, b)| a != b);

                    match pos {
                    Some(_) => CompareResult::Error,
                    None => {
                        if self.input_len() >= t.input_len() {
                        CompareResult::Ok
                        } else {
                        CompareResult::Incomplete
                        }
                    }
                    }
                }

                #[inline( always )] fn compare_no_case(&self, t: O) -> CompareResult {
                    if self
                    .iter_elements()
                    .zip(t.iter_elements())
                    .any(|(a, b)| lowercase_byte(a) != lowercase_byte(b))
                    {
                    CompareResult::Error
                    } else if self.input_len() < t.input_len() {
                    CompareResult::Incomplete
                    } else {
                    CompareResult::Ok
                    }
                }
            }

            impl<'a, 'b> Compare<&'b str> for &'a [u8] 
            {
                #[inline( always )] fn compare(&self, t: &'b str) -> CompareResult {
                    self.compare(AsBytes::as_bytes(t))
                }
                #[inline( always )] fn compare_no_case(&self, t: &'b str) -> CompareResult {
                    self.compare_no_case(AsBytes::as_bytes(t))
                }
            }

            impl<'a, 'b> Compare<&'b str> for &'a str 
            {
                #[inline( always )] fn compare(&self, t: &'b str) -> CompareResult {
                    self.as_bytes().compare(t.as_bytes())
                }
                
                #[inline( always )] fn compare_no_case(&self, t: &'b str) -> CompareResult {
                    let pos = self
                    .chars()
                    .zip(t.chars())
                    .position(|(a, b)| a.to_lowercase().ne(b.to_lowercase()));

                    match pos {
                    Some(_) => CompareResult::Error,
                    None => {
                        if self.len() >= t.len() {
                        CompareResult::Ok
                        } else {
                        CompareResult::Incomplete
                        }
                    }
                    }
                }
            }

            impl<'a, 'b> Compare<&'b [u8]> for &'a str 
            {
                #[inline( always )] fn compare(&self, t: &'b [u8]) -> CompareResult {
                    AsBytes::as_bytes(self).compare(t)
                }
                #[inline( always )] fn compare_no_case(&self, t: &'b [u8]) -> CompareResult {
                    AsBytes::as_bytes(self).compare_no_case(t)
                }
            }
            /// Look for a token in self
            pub trait FindToken<T> 
            {
                /// Returns true if self contains the token
                fn find_token(&self, token: T) -> bool;
            }

            impl<'a> FindToken<u8> for &'a [u8] 
            {
                fn find_token(&self, token: u8) -> bool {
                    memchr::memchr(token, self).is_some()
                }
            }

            impl<'a> FindToken<u8> for &'a str 
            {
                fn find_token(&self, token: u8) -> bool {
                    self.as_bytes().find_token(token)
                }
            }

            impl<'a, 'b> FindToken<&'a u8> for &'b [u8] 
            {
                fn find_token(&self, token: &u8) -> bool {
                    self.find_token(*token)
                }
            }

            impl<'a, 'b> FindToken<&'a u8> for &'b str 
            {
                fn find_token(&self, token: &u8) -> bool {
                    self.as_bytes().find_token(token)
                }
            }

            impl<'a> FindToken<char> for &'a [u8] 
            {
                fn find_token(&self, token: char) -> bool {
                    self.iter().any(|i| *i == token as u8)
                }
            }

            impl<'a> FindToken<char> for &'a str 
            {
                fn find_token(&self, token: char) -> bool {
                    self.chars().any(|i| i == token)
                }
            }

            impl<'a> FindToken<char> for &'a [char] 
            {
                fn find_token(&self, token: char) -> bool {
                    self.iter().any(|i| *i == token)
                }
            }

            impl<'a, 'b> FindToken<&'a char> for &'b [char] 
            {
                fn find_token(&self, token: &char) -> bool {
                    self.find_token(*token)
                }
            }
            /// Look for a substring in self
            pub trait FindSubstring<T> 
            {
                /// Returns the byte position of the substring if it is found
                fn find_substring(&self, substr: T) -> Option<usize>;
            }

            impl<'a, 'b> FindSubstring<&'b [u8]> for &'a [u8] 
            {
                fn find_substring(&self, substr: &'b [u8]) -> Option<usize>
                {
                    if substr.len() > self.len() {
                    return None;
                    }

                    let (&substr_first, substr_rest) = match substr.split_first() 
                    {
                        Some(split) => split,
                        None => return Some(0),
                    };

                    if substr_rest.is_empty() {
                    return memchr::memchr(substr_first, self);
                    }

                    let mut offset = 0;
                    let haystack = &self[..self.len() - substr_rest.len()];

                    while let Some(position) = memchr::memchr(substr_first, &haystack[offset..]) {
                    offset += position;
                    let next_offset = offset + 1;
                    if &self[next_offset..][..substr_rest.len()] == substr_rest {
                        return Some(offset);
                    }

                    offset = next_offset;
                    }

                    None
                }
            }

            impl<'a, 'b> FindSubstring<&'b str> for &'a [u8]
            {
                fn find_substring(&self, substr: &'b str) -> Option<usize> {
                    self.find_substring(AsBytes::as_bytes(substr))
                }
            }

            impl<'a, 'b> FindSubstring<&'b str> for &'a str 
            {
                fn find_substring(&self, substr: &'b str) -> Option<usize> {
                    self.find(substr)
                }
            }
            /// Used to integrate `str`'s `parse()` method
            pub trait ParseTo<R> 
            {
                /// Succeeds if `parse()` succeeded. The byte slice implementation
                /// will first convert it to a `&str`, then apply the `parse()` function
                fn parse_to(&self) -> Option<R>;
            }

            impl<'a, R: FromStr> ParseTo<R> for &'a [u8]
            {
                fn parse_to(&self) -> Option<R> {
                    from_utf8(self).ok().and_then(|s| s.parse().ok())
                }
            }

            impl<'a, R: FromStr> ParseTo<R> for &'a str
            {
                fn parse_to(&self) -> Option<R> {
                    self.parse().ok()
                }
            }
            /// Slicing operations using ranges.
            pub trait Slice<R>
            {
                /// Slices self according to the range argument
                fn slice(&self, range: R) -> Self;
            }

            slice_ranges_impl! {str}
            slice_ranges_impl! {[T]}

            array_impls!
            {
                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 
                17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
            }
            /// Abstracts something which can extend an `Extend`.
            pub trait ExtendInto 
            {
                /// The current input type is a sequence of that `Item` type.
                type Item;
                /// The type that will be produced
                type Extender;
                /// Create a new `Extend` of the correct type
                fn new_builder(&self) -> Self::Extender;
                /// Accumulate the input into an accumulator
                fn extend_into(&self, acc: &mut Self::Extender);
            }
            
            impl ExtendInto for [u8] 
            {
                type Item = u8;
                type Extender = Vec<u8>;

                #[inline] fn new_builder(&self) -> Vec<u8> {
                    Vec::new()
                }
                #[inline] fn extend_into(&self, acc: &mut Vec<u8>) {
                    acc.extend(self.iter().cloned());
                }
            }
            
            impl ExtendInto for &[u8] 
            {
                type Item = u8;
                type Extender = Vec<u8>;

                #[inline] fn new_builder(&self) -> Vec<u8> {
                    Vec::new()
                }
                #[inline] fn extend_into(&self, acc: &mut Vec<u8>) {
                    acc.extend_from_slice(self);
                }
            }
            
            impl ExtendInto for str 
            {
                type Item = char;
                type Extender = String;

                #[inline] fn new_builder(&self) -> String {
                    String::new()
                }
                #[inline] fn extend_into(&self, acc: &mut String) {
                    acc.push_str(self);
                }
            }
            
            impl ExtendInto for &str 
            {
                type Item = char;
                type Extender = String;

                #[inline] fn new_builder(&self) -> String {
                    String::new()
                }
                #[inline] fn extend_into(&self, acc: &mut String) {
                    acc.push_str(self);
                }
            }
            
            impl ExtendInto for char 
            {
                type Item = char;
                type Extender = String;

                #[inline] fn new_builder(&self) -> String {
                    String::new()
                }
                #[inline] fn extend_into(&self, acc: &mut String) {
                    acc.push(*self);
                }
            }
            /// Helper trait to convert numbers to usize.
            pub trait ToUsize 
            {
                /// converts self to usize
                fn to_usize(&self) -> usize;
            }

            impl ToUsize for u8 
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self as usize
                }
            }

            impl ToUsize for u16 
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self as usize
                }
            }

            impl ToUsize for usize
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self
                }
            }
            
            impl ToUsize for u32
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self as usize
                }
            }
            
            impl ToUsize for u64
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self as usize
                }
            }
            /// Equivalent From implementation to avoid orphan rules in bits parsers
            pub trait ErrorConvert<E>
            {
                /// Transform to another error type
                fn convert(self) -> E;
            }

            impl<I> ErrorConvert<(I, ErrorKind)> for ((I, usize), ErrorKind) 
            {
                fn convert(self) -> (I, ErrorKind) {
                    ((self.0).0, self.1)
                }
            }

            impl<I> ErrorConvert<((I, usize), ErrorKind)> for (I, ErrorKind)
            {
                fn convert(self) -> ((I, usize), ErrorKind) {
                    ((self.0, 0), self.1)
                }
            }
            
            impl<I> ErrorConvert<error::Error<I>> for error::Error<(I, usize)> 
            {
                fn convert(self) -> error::Error<I> {
                    error::Error {
                    input: self.input.0,
                    code: self.code,
                    }
                }
            }

            impl<I> ErrorConvert<error::Error<(I, usize)>> for error::Error<I> 
            {
                fn convert(self) -> error::Error<(I, usize)> {
                    error::Error {
                    input: (self.input, 0),
                    code: self.code,
                    }
                }
            }
            
            impl<I> ErrorConvert<error::VerboseError<I>> for error::VerboseError<(I, usize)> 
            {
                fn convert(self) -> error::VerboseError<I> {
                    error::VerboseError {
                    errors: self.errors.into_iter().map(|(i, e)| (i.0, e)).collect(),
                    }
                }
            }
            
            impl<I> ErrorConvert<error::VerboseError<(I, usize)>> for error::VerboseError<I>
            {
                fn convert(self) -> error::VerboseError<(I, usize)> {
                    error::VerboseError {
                    errors: self.errors.into_iter().map(|(i, e)| ((i, 0), e)).collect(),
                    }
                }
            }

            impl ErrorConvert<()> for ()
            {
                fn convert(self) {}
            }
            /// Helper trait to show a byte slice as a hex dump
            pub trait HexDisplay
            {
                /// Converts the value of `self` to a hex dump, returning the owned
                /// `String`.
                fn to_hex(&self, chunk_size: usize) -> String;
                /// Converts the value of `self` to a hex dump beginning at `from` address, returning the owned
                /// `String`.
                fn to_hex_from(&self, chunk_size: usize, from: usize) -> String;
            }
            
            static CHARS: &[u8] = b"0123456789abcdef";
            
            impl HexDisplay for [u8]
            {
                #[allow(unused_variables)]
                fn to_hex(&self, chunk_size: usize) -> String {
                    self.to_hex_from(chunk_size, 0)
                }

                #[allow(unused_variables)]
                fn to_hex_from(&self, chunk_size: usize, from: usize) -> String {
                    let mut v = Vec::with_capacity(self.len() * 3);
                    let mut i = from;
                    for chunk in self.chunks(chunk_size) {
                    let s = format!("{:08x}", i);
                    for &ch in s.as_bytes().iter() {
                        v.push(ch);
                    }
                    v.push(b'\t');

                    i += chunk_size;

                    for &byte in chunk {
                        v.push(CHARS[(byte >> 4) as usize]);
                        v.push(CHARS[(byte & 0xf) as usize]);
                        v.push(b' ');
                    }
                    if chunk_size > chunk.len() {
                        for j in 0..(chunk_size - chunk.len()) {
                        v.push(b' ');
                        v.push(b' ');
                        v.push(b' ');
                        }
                    }
                    v.push(b'\t');

                    for &byte in chunk {
                        if (byte >= 32 && byte <= 126) || byte >= 128 {
                        v.push(byte);
                        } else {
                        v.push(b'.');
                        }
                    }
                    v.push(b'\n');
                    }

                    String::from_utf8_lossy(&v[..]).into_owned()
                }
            }
            
            impl HexDisplay for str
            {
                #[allow(unused_variables)]
                fn to_hex(&self, chunk_size: usize) -> String {
                    self.to_hex_from(chunk_size, 0)
                }

                #[allow(unused_variables)]
                fn to_hex_from(&self, chunk_size: usize, from: usize) -> String {
                    self.as_bytes().to_hex_from(chunk_size, from)
                }
            }
        } pub use self::traits::*;
        
        pub mod bits
        {
            use ::
            {
                ops::RangeFrom,
                parsers::nom::
                {
                    error::{ErrorKind, ParseError},
                    internal::{Err, IResult, Needed, Parser},
                    traits::{ErrorConvert, Slice},
                },
                *,
            };

            pub mod complete
            {
                //! Bit level parsers
                use ::
                {
                    ops::{AddAssign, Div, RangeFrom, Shl, Shr},
                    parsers::nom::
                    {
                        error::{ErrorKind, ParseError},
                        internal::{Err, IResult},
                        traits::{InputIter, InputLength, Slice, ToUsize},
                    },
                    *
                };
                /// Generates a parser taking `count` bits
                pub fn take<I, O, C, E: ParseError<(I, usize)>>(
                count: C,
                ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                C: ToUsize,
                O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>,
                {
                    let count = count.to_usize();
                    move |(input, bit_offset): (I, usize)| {
                        if count == 0 {
                        Ok(((input, bit_offset), 0u8.into()))
                        } else {
                        let cnt = (count + bit_offset).div(8);
                        if input.input_len() * 8 < count + bit_offset {
                            Err(Err::Error(E::from_error_kind(
                            (input, bit_offset),
                            ErrorKind::Eof,
                            )))
                        } else {
                            let mut acc: O = 0_u8.into();
                            let mut offset: usize = bit_offset;
                            let mut remaining: usize = count;
                            let mut end_offset: usize = 0;

                            for byte in input.iter_elements().take(cnt + 1) {
                            if remaining == 0 {
                                break;
                            }
                            let val: O = if offset == 0 {
                                byte.into()
                            } else {
                                ((byte << offset) as u8 >> offset).into()
                            };

                            if remaining < 8 - offset {
                                acc += val >> (8 - offset - remaining);
                                end_offset = remaining + offset;
                                break;
                            } else {
                                acc += val << (remaining - (8 - offset));
                                remaining -= 8 - offset;
                                offset = 0;
                            }
                            }
                            Ok(((input.slice(cnt..), end_offset), acc))
                        }
                        }
                    }
                }
                /// Generates a parser taking `count` bits and comparing them to `pattern`
                pub fn tag<I, O, C, E: ParseError<(I, usize)>>(
                pattern: O,
                count: C,
                ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength + Clone,
                C: ToUsize,
                O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq,
                {
                    let count = count.to_usize();
                    move |input: (I, usize)| {
                        let inp = input.clone();

                        take(count)(input).and_then(|(i, o)| {
                        if pattern == o {
                            Ok((i, o))
                        } else {
                            Err(Err::Error(error_position!(inp, ErrorKind::TagBits)))
                        }
                        })
                    }
                }
                /// Parses one specific bit as a bool.
                pub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let (res, bit): (_, u32) = take(1usize)(input)?;
                    Ok((res, bit != 0))
                }
            }

            pub mod streaming
            {
                use ::
                {
                    ops::{AddAssign, Div, RangeFrom, Shl, Shr},
                    parsers::nom::
                    {
                        error::{ErrorKind, ParseError},
                        internal::{Err, IResult, Needed},
                        traits::{InputIter, InputLength, Slice, ToUsize},
                    },
                    *
                };
                /// Generates a parser taking `count` bits
                pub fn take<I, O, C, E: ParseError<(I, usize)>>(
                count: C,
                ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                C: ToUsize,
                O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>,
                {
                    let count = count.to_usize();
                    move |(input, bit_offset): (I, usize)| {
                        if count == 0 {
                        Ok(((input, bit_offset), 0u8.into()))
                        } else {
                        let cnt = (count + bit_offset).div(8);
                        if input.input_len() * 8 < count + bit_offset {
                            Err(Err::Incomplete(Needed::new(count as usize)))
                        } else {
                            let mut acc: O = 0_u8.into();
                            let mut offset: usize = bit_offset;
                            let mut remaining: usize = count;
                            let mut end_offset: usize = 0;

                            for byte in input.iter_elements().take(cnt + 1) {
                            if remaining == 0 {
                                break;
                            }
                            let val: O = if offset == 0 {
                                byte.into()
                            } else {
                                ((byte << offset) as u8 >> offset).into()
                            };

                            if remaining < 8 - offset {
                                acc += val >> (8 - offset - remaining);
                                end_offset = remaining + offset;
                                break;
                            } else {
                                acc += val << (remaining - (8 - offset));
                                remaining -= 8 - offset;
                                offset = 0;
                            }
                            }
                            Ok(((input.slice(cnt..), end_offset), acc))
                        }
                        }
                    }
                }
                /// Generates a parser taking `count` bits and comparing them to `pattern`
                pub fn tag<I, O, C, E: ParseError<(I, usize)>>(
                pattern: O,
                count: C,
                ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength + Clone,
                C: ToUsize,
                O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq,
                {
                    let count = count.to_usize();
                    move |input: (I, usize)| {
                        let inp = input.clone();

                        take(count)(input).and_then(|(i, o)| {
                        if pattern == o {
                            Ok((i, o))
                        } else {
                            Err(Err::Error(error_position!(inp, ErrorKind::TagBits)))
                        }
                        })
                    }
                }
                /// Parses one specific bit as a bool.
                pub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let (res, bit): (_, u32) = take(1usize)(input)?;
                    Ok((res, bit != 0))
                }
            }
            /// Converts a byte-level input to a bit-level input, for consumption by a parser that uses bits.
            pub fn bits<I, O, E1, E2, P>(mut parser: P) -> impl FnMut(I) -> IResult<I, O, E2> where
            E1: ParseError<(I, usize)> + ErrorConvert<E2>,
            E2: ParseError<I>,
            I: Slice<RangeFrom<usize>>,
            P: Parser<(I, usize), O, E1>,
            {
                move |input: I| match parser.parse((input, 0)) {
                    Ok(((rest, offset), result)) => {
                    let remaining_bytes_index = offset / 8 + if offset % 8 == 0 { 0 } else { 1 };
                    Ok((rest.slice(remaining_bytes_index..), result))
                    }
                    Err(Err::Incomplete(n)) => Err(Err::Incomplete(n.map(|u| u.get() / 8 + 1))),
                    Err(Err::Error(e)) => Err(Err::Error(e.convert())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),
                }
            }
            /// Counterpart to `bits`, `bytes` transforms its bit stream input into a byte slice for the underlying
            /// parser, allowing byte-slice parsers to work on bit streams.
            pub fn bytes<I, O, E1, E2, P>(mut parser: P) -> impl FnMut((I, usize)) -> IResult<(I, usize), O, E2> where
            E1: ParseError<I> + ErrorConvert<E2>,
            E2: ParseError<(I, usize)>,
            I: Slice<RangeFrom<usize>> + Clone,
            P: Parser<I, O, E1>,
            {
                move |(input, offset): (I, usize)| {
                    let inner = if offset % 8 != 0 {
                    input.slice((1 + offset / 8)..)
                    } else {
                    input.slice((offset / 8)..)
                    };
                    let i = (input, offset);
                    match parser.parse(inner) {
                    Ok((rest, res)) => Ok(((rest, 0), res)),
                    Err(Err::Incomplete(Needed::Unknown)) => Err(Err::Incomplete(Needed::Unknown)),
                    Err(Err::Incomplete(Needed::Size(sz))) => Err(match sz.get().checked_mul(8) {
                        Some(v) => Err::Incomplete(Needed::new(v)),
                        None => Err::Failure(E2::from_error_kind(i, ErrorKind::TooLarge)),
                    }),
                    Err(Err::Error(e)) => Err(Err::Error(e.convert())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),
                    }
                }
            }
        }
    
        pub mod bytes
        {
            //! Parsers recognizing bytes streams
            use ::
            {
                *,
            };

            pub mod complete
            {
                use ::
                {
                    ops::RangeFrom,
                    parsers::nom::
                    {
                        error::{ ErrorKind, ParseError },
                        internal::{ Err, IResult, Parser },
                        traits::
                        {
                            AsChar, Compare, CompareResult, ExtendInto, FindSubstring, FindToken, InputIter, InputLength, InputTake,
                            InputTakeAtPosition, Offset, Slice, ToUsize,
                        },
                    },
                    result::Result::*,
                    *
                };
                /// Recognizes a pattern.
                pub fn tag<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + Compare<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| {
                        let tag_len = tag.input_len();
                        let t = tag.clone();
                        let res: IResult<_, _, Error> = match i.compare(t) {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        _ => {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                        };
                        res
                    }
                }
                /// Recognizes a case insensitive pattern.
                pub fn tag_no_case<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + Compare<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| {
                        let tag_len = tag.input_len();
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match (i).compare_no_case(t) {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        _ => {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                        };
                        res
                    }
                }
                /// Parse till certain characters are met.
                pub fn is_not<T, Input, Error: ParseError<Input>>(
                arr: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                T: FindToken<<Input as InputTakeAtPosition>::Item>,
                {
                    move |i: Input| {
                        let e: ErrorKind = ErrorKind::IsNot;
                        i.split_at_position1_complete(|c| arr.find_token(c), e)
                    }
                }
                /// Returns the longest slice of the matches the pattern.
                pub fn is_a<T, Input, Error: ParseError<Input>>(
                arr: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                T: FindToken<<Input as InputTakeAtPosition>::Item>,
                {
                    move |i: Input| {
                        let e: ErrorKind = ErrorKind::IsA;
                        i.split_at_position1_complete(|c| !arr.find_token(c), e)
                    }
                }
                /// Returns the longest input slice (if any) that matches the predicate.
                pub fn take_while<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| i.split_at_position_complete(|c| !cond(c))
                }
                /// Returns the longest (at least 1) input slice that matches the predicate.
                pub fn take_while1<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| {
                        let e: ErrorKind = ErrorKind::TakeWhile1;
                        i.split_at_position1_complete(|c| !cond(c), e)
                    }
                }
                /// Returns the longest (m <= len <= n) input slice  that matches the predicate.
                pub fn take_while_m_n<F, Input, Error: ParseError<Input>>(
                m: usize,
                n: usize,
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputIter + InputLength + Slice<RangeFrom<usize>>,
                F: Fn(<Input as InputIter>::Item) -> bool,
                {
                    move |i: Input| {
                        let input = i;

                        match input.position(|c| !cond(c)) {
                        Some(idx) => {
                            if idx >= m {
                            if idx <= n {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(idx) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            } else {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(n) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            }
                            } else {
                            let e = ErrorKind::TakeWhileMN;
                            Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }
                        None => {
                            let len = input.input_len();
                            if len >= n {
                            match input.slice_index(n) {
                                Ok(index) => Ok(input.take_split(index)),
                                Err(_needed) => Err(Err::Error(Error::from_error_kind(
                                input,
                                ErrorKind::TakeWhileMN,
                                ))),
                            }
                            } else if len >= m && len <= n {
                            let res: IResult<_, _, Error> = Ok((input.slice(len..), input));
                            res
                            } else {
                            let e = ErrorKind::TakeWhileMN;
                            Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }
                        }
                    }
                }
                /// Returns the longest input slice (if any) till a predicate is met.
                pub fn take_till<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| i.split_at_position_complete(|c| cond(c))
                }
                /// Returns the longest (at least 1) input slice till a predicate is met.
                pub fn take_till1<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| {
                        let e: ErrorKind = ErrorKind::TakeTill1;
                        i.split_at_position1_complete(|c| cond(c), e)
                    }
                }
                /// Returns an input slice containing the first N input elements (Input[..N]).
                pub fn take<C, Input, Error: ParseError<Input>>(
                count: C,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputIter + InputTake,
                C: ToUsize,
                {
                    let c = count.to_usize();
                    move |i: Input| match i.slice_index(c) {
                        Err(_needed) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Eof))),
                        Ok(index) => Ok(i.take_split(index)),
                    }
                }
                /// Returns the input slice up to the first occurrence of the pattern.
                pub fn take_until<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + FindSubstring<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| {
                        let t = tag.clone();
                        let res: IResult<_, _, Error> = match i.find_substring(t) {
                        None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(index) => Ok(i.take_split(index)),
                        };
                        res
                    }
                }
                /// Returns the non empty input slice up to the first occurrence of the pattern.
                pub fn take_until1<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + FindSubstring<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| {
                        let t = tag.clone();
                        let res: IResult<_, _, Error> = match i.find_substring(t) {
                        None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(index) => Ok(i.take_split(index)),
                        };
                        res
                    }
                }
                /// Matches a byte string with escaped characters.
                pub fn escaped<'a, Input: 'a, Error, F, G, O1, O2>(
                mut normal: F,
                control_char: char,
                mut escapable: G,
                ) -> impl FnMut(Input) -> IResult<Input, Input, Error> where
                Input: Clone
                    + Offset
                    + InputLength
                    + InputTake
                    + InputTakeAtPosition
                    + Slice<RangeFrom<usize>>
                    + InputIter,
                <Input as InputIter>::Item: AsChar,
                F: Parser<Input, O1, Error>,
                G: Parser<Input, O2, Error>,
                Error: ParseError<Input>,
                {
                    move |input: Input|
                    {
                        let mut i = input.clone();

                        while i.input_len() > 0 {
                        let current_len = i.input_len();

                        match normal.parse(i.clone()) {
                            Ok((i2, _)) => {
                            if i2.input_len() == 0 {
                                return Ok((input.slice(input.input_len()..), input));
                            } else if i2.input_len() == current_len {
                                let index = input.offset(&i2);
                                return Ok(input.take_split(index));
                            } else {
                                i = i2;
                            }
                            }
                            Err(Err::Error(_)) => {
                            if i.iter_elements().next().unwrap().as_char() == control_char {
                                let next = control_char.len_utf8();
                                if next >= i.input_len() {
                                return Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::Escaped,
                                )));
                                } else {
                                match escapable.parse(i.slice(next..)) {
                                    Ok((i2, _)) => {
                                    if i2.input_len() == 0 {
                                        return Ok((input.slice(input.input_len()..), input));
                                    } else {
                                        i = i2;
                                    }
                                    }
                                    Err(e) => return Err(e),
                                }
                                }
                            } else {
                                let index = input.offset(&i);
                                if index == 0 {
                                return Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::Escaped,
                                )));
                                }
                                return Ok(input.take_split(index));
                            }
                            }
                            Err(e) => {
                            return Err(e);
                            }
                        }
                        }

                        Ok((input.slice(input.input_len()..), input))
                    }
                }
                /// Matches a byte string with escaped characters.
                pub fn escaped_transform<Input, Error, F, G, O1, O2, ExtendItem, Output>(
                mut normal: F,
                control_char: char,
                mut transform: G,
                ) -> impl FnMut(Input) -> IResult<Input, Output, Error> where
                Input: Clone
                    + Offset
                    + InputLength
                    + InputTake
                    + InputTakeAtPosition
                    + Slice<RangeFrom<usize>>
                    + InputIter,
                Input: ExtendInto<Item = ExtendItem, Extender = Output>,
                O1: ExtendInto<Item = ExtendItem, Extender = Output>,
                O2: ExtendInto<Item = ExtendItem, Extender = Output>,
                <Input as InputIter>::Item: AsChar,
                F: Parser<Input, O1, Error>,
                G: Parser<Input, O2, Error>,
                Error: ParseError<Input>,
                {
                    move | input:Input |
                    {
                        let mut index = 0;
                        let mut res = input.new_builder();

                        let i = input.clone();

                        while index < i.input_len() 
                    {
                        let current_len = i.input_len();
                        let remainder = i.slice(index..);
                        match normal.parse(remainder.clone()) {
                            Ok((i2, o)) => {
                            o.extend_into(&mut res);
                            if i2.input_len() == 0 {
                                return Ok((i.slice(i.input_len()..), res));
                            } else if i2.input_len() == current_len {
                                return Ok((remainder, res));
                            } else {
                                index = input.offset(&i2);
                            }
                            }
                            Err(Err::Error(_)) => {
                            if remainder.iter_elements().next().unwrap().as_char() == control_char {
                                let next = index + control_char.len_utf8();
                                let input_len = input.input_len();

                                if next >= input_len {
                                return Err(Err::Error(Error::from_error_kind(
                                    remainder,
                                    ErrorKind::EscapedTransform,
                                )));
                                } else {
                                match transform.parse(i.slice(next..)) {
                                    Ok((i2, o)) => {
                                    o.extend_into(&mut res);
                                    if i2.input_len() == 0 {
                                        return Ok((i.slice(i.input_len()..), res));
                                    } else {
                                        index = input.offset(&i2);
                                    }
                                    }
                                    Err(e) => return Err(e),
                                }
                                }
                            } else {
                                if index == 0 {
                                return Err(Err::Error(Error::from_error_kind(
                                    remainder,
                                    ErrorKind::EscapedTransform,
                                )));
                                }
                                return Ok((remainder, res));
                            }
                            }
                            Err(e) => return Err(e),
                        }
                        }
                        Ok((input.slice(index..), res))
                    }
                }
            }

            pub mod streaming
            {
                use ::
                {
                    ops::RangeFrom,
                    parsers::nom::
                    {
                        error::{ ErrorKind, ParseError },
                        internal::{Err, IResult, Needed, Parser},
                        traits::
                        {
                            AsChar, Compare, CompareResult, ExtendInto, FindSubstring, FindToken, InputIter, InputLength, InputTake,
                            InputTakeAtPosition, Offset, Slice, ToUsize,
                        },
                    },
                    result::Result::*,
                    *
                };
                /// Recognizes a pattern.
                pub fn tag<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputLength + Compare<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| {
                        let tag_len = tag.input_len();
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match i.compare(t) {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),
                        CompareResult::Error => {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                        };
                        res
                    }
                }
                /// Recognizes a case insensitive pattern.
                pub fn tag_no_case<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputLength + Compare<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| {
                        let tag_len = tag.input_len();
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match (i).compare_no_case(t) {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),
                        CompareResult::Error => {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                        };
                        res
                    }
                }
                /// Parse till certain characters are met.
                pub fn is_not<T, Input, Error: ParseError<Input>>(
                arr: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                T: FindToken<<Input as InputTakeAtPosition>::Item>,
                {
                    move |i: Input| {
                        let e: ErrorKind = ErrorKind::IsNot;
                        i.split_at_position1(|c| arr.find_token(c), e)
                    }
                }
                /// Returns the longest slice of the matches the pattern.
                pub fn is_a<T, Input, Error: ParseError<Input>>(
                arr: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                T: FindToken<<Input as InputTakeAtPosition>::Item>,
                {
                    move |i: Input| 
                    {
                        let e: ErrorKind = ErrorKind::IsA;
                        i.split_at_position1(|c| !arr.find_token(c), e)
                    }
                }
                /// Returns the longest input slice (if any) that matches the predicate.
                pub fn take_while<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| i.split_at_position(|c| !cond(c))
                }
                /// Returns the longest (at least 1) input slice that matches the predicate.
                pub fn take_while1<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| {
                        let e: ErrorKind = ErrorKind::TakeWhile1;
                        i.split_at_position1(|c| !cond(c), e)
                    }
                }
                /// Returns the longest (m <= len <= n) input slice  that matches the predicate.
                pub fn take_while_m_n<F, Input, Error: ParseError<Input>>(
                m: usize,
                n: usize,
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputIter + InputLength,
                F: Fn(<Input as InputIter>::Item) -> bool,
                {
                    move |i: Input| {
                        let input = i;

                        match input.position(|c| !cond(c)) {
                        Some(idx) => {
                            if idx >= m {
                            if idx <= n {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(idx) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            } else {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(n) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            }
                            } else {
                            let e = ErrorKind::TakeWhileMN;
                            Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }
                        None => {
                            let len = input.input_len();
                            if len >= n {
                            match input.slice_index(n) {
                                Ok(index) => Ok(input.take_split(index)),
                                Err(_needed) => Err(Err::Error(Error::from_error_kind(
                                input,
                                ErrorKind::TakeWhileMN,
                                ))),
                            }
                            } else {
                            let needed = if m > len { m - len } else { 1 };
                            Err(Err::Incomplete(Needed::new(needed)))
                            }
                        }
                        }
                    }
                }
                /// Returns the longest input slice (if any) till a predicate is met.
                pub fn take_till<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| i.split_at_position(|c| cond(c))
                }
                /// Returns the longest (at least 1) input slice till a predicate is met.
                pub fn take_till1<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| {
                        let e: ErrorKind = ErrorKind::TakeTill1;
                        i.split_at_position1(|c| cond(c), e)
                    }
                }
                /// Returns an input slice containing the first N input elements (Input[..N]).
                pub fn take<C, Input, Error: ParseError<Input>>(
                count: C,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputIter + InputTake + InputLength,
                C: ToUsize,
                {
                    let c = count.to_usize();
                    move |i: Input| match i.slice_index(c) {
                        Err(i) => Err(Err::Incomplete(i)),
                        Ok(index) => Ok(i.take_split(index)),
                    }
                }
                /// Returns the input slice up to the first occurrence of the pattern.
                pub fn take_until<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputLength + FindSubstring<T>,
                T: Clone,
                {
                    move |i: Input| {
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match i.find_substring(t) {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some(index) => Ok(i.take_split(index)),
                        };
                        res
                    }
                }
                /// Returns the non empty input slice up to the first occurrence of the pattern.
                pub fn take_until1<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputLength + FindSubstring<T>,
                T: Clone,
                {
                    move |i: Input| {
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match i.find_substring(t) {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(index) => Ok(i.take_split(index)),
                        };
                        res
                    }
                }
                /// Matches a byte string with escaped characters.
                pub fn escaped<Input, Error, F, G, O1, O2>(
                mut normal: F,
                control_char: char,
                mut escapable: G,
                ) -> impl FnMut(Input) -> IResult<Input, Input, Error> where
                Input: Clone
                    + Offset
                    + InputLength
                    + InputTake
                    + InputTakeAtPosition
                    + Slice<RangeFrom<usize>>
                    + InputIter,
                <Input as InputIter>::Item: AsChar,
                F: Parser<Input, O1, Error>,
                G: Parser<Input, O2, Error>,
                Error: ParseError<Input>,
                {
                    move | input:Input |
                    {
                        let mut i = input.clone();

                        while i.input_len() > 0 {
                        let current_len = i.input_len();

                        match normal.parse(i.clone()) {
                            Ok((i2, _)) => {
                            if i2.input_len() == 0 {
                                return Err(Err::Incomplete(Needed::Unknown));
                            } else if i2.input_len() == current_len {
                                let index = input.offset(&i2);
                                return Ok(input.take_split(index));
                            } else {
                                i = i2;
                            }
                            }
                            Err(Err::Error(_)) => {
                            if i.iter_elements().next().unwrap().as_char() == control_char {
                                let next = control_char.len_utf8();
                                if next >= i.input_len() {
                                return Err(Err::Incomplete(Needed::new(1)));
                                } else {
                                match escapable.parse(i.slice(next..)) {
                                    Ok((i2, _)) => {
                                    if i2.input_len() == 0 {
                                        return Err(Err::Incomplete(Needed::Unknown));
                                    } else {
                                        i = i2;
                                    }
                                    }
                                    Err(e) => return Err(e),
                                }
                                }
                            } else {
                                let index = input.offset(&i);
                                return Ok(input.take_split(index));
                            }
                            }
                            Err(e) => {
                            return Err(e);
                            }
                        }
                        }

                        Err(Err::Incomplete(Needed::Unknown))
                    }
                }
                /// Matches a byte string with escaped characters.
                pub fn escaped_transform<Input, Error, F, G, O1, O2, ExtendItem, Output>(
                mut normal: F,
                control_char: char,
                mut transform: G,
                ) -> impl FnMut(Input) -> IResult<Input, Output, Error> where
                Input: Clone
                    + Offset
                    + InputLength
                    + InputTake
                    + InputTakeAtPosition
                    + Slice<RangeFrom<usize>>
                    + InputIter,
                Input: ExtendInto<Item = ExtendItem, Extender = Output>,
                O1: ExtendInto<Item = ExtendItem, Extender = Output>,
                O2:  ExtendInto<Item = ExtendItem, Extender = Output>,
                <Input as InputIter>::Item: AsChar,
                F: Parser<Input, O1, Error>,
                G: Parser<Input, O2, Error>,
                Error: ParseError<Input>,
                {
                    move | input:Input |
                    {
                        let mut index = 0;
                        let mut res = input.new_builder();

                        let i = input.clone();

                        while index < i.input_len() 
                    {
                        let current_len = i.input_len();
                        let remainder = i.slice(index..);
                        match normal.parse(remainder.clone()) {
                            Ok((i2, o)) => {
                            o.extend_into(&mut res);
                            if i2.input_len() == 0 {
                                return Err(Err::Incomplete(Needed::Unknown));
                            } else if i2.input_len() == current_len {
                                return Ok((remainder, res));
                            } else {
                                index = input.offset(&i2);
                            }
                            }
                            Err(Err::Error(_)) => {
                            // unwrap() should be safe here since index < $i.input_len()
                            if remainder.iter_elements().next().unwrap().as_char() == control_char {
                                let next = index + control_char.len_utf8();
                                let input_len = input.input_len();

                                if next >= input_len {
                                return Err(Err::Incomplete(Needed::Unknown));
                                } else {
                                match transform.parse(i.slice(next..)) {
                                    Ok((i2, o)) => {
                                    o.extend_into(&mut res);
                                    if i2.input_len() == 0 {
                                        return Err(Err::Incomplete(Needed::Unknown));
                                    } else {
                                        index = input.offset(&i2);
                                    }
                                    }
                                    Err(e) => return Err(e),
                                }
                                }
                            } else {
                                return Ok((remainder, res));
                            }
                            }
                            Err(e) => return Err(e),
                        }
                        }
                        Err(Err::Incomplete(Needed::Unknown))
                    }
                }
            }

        } pub use self::bytes::*;
        
        pub mod character
        {
            use ::
            {
                *,
            };

            pub mod complete
            {
                //! Character specific parsers and combinators, complete input version.
                //! Functions recognizing specific characters.
                use ::
                {
                    ops::{ Range, RangeFrom, RangeTo },
                    parsers::nom::
                    {
                        branch::alt,
                        bytes::complete::tag,
                        combinator::{ opt, value },
                        error::{ ErrorKind, ParseError },
                        internal::{Err, IResult},
                        traits::{ AsChar, Compare, CompareResult, FindToken, InputIter, InputLength, InputTake, InputTakeAtPosition, Slice, },
                    },
                    *
                };
                
                macro_rules! ints 
                {
                    ($($t:tt)+) => {
                        $(
                        /// will parse a number in text form to a number
                        ///
                        /// *Complete version*: can parse until the end of input.
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                            where
                            T: InputIter + Slice<RangeFrom<usize>> + InputLength + InputTake + Clone,
                            <T as InputIter>::Item: AsChar,
                            T: for <'a> Compare<&'a[u8]>,
                            {
                                let (i, sign) = sign(input.clone())?;

                                if i.input_len() == 0 {
                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                }

                                let mut value: $t = 0;
                                if sign {
                                    for (pos, c) in i.iter_indices() {
                                        match c.as_char().to_digit(10) {
                                            None => {
                                                if pos == 0 {
                                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                                } else {
                                                    return Ok((i.slice(pos..), value));
                                                }
                                            },
                                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                                Some(v) => value = v,
                                            }
                                        }
                                    }
                                } else {
                                    for (pos, c) in i.iter_indices() {
                                        match c.as_char().to_digit(10) {
                                            None => {
                                                if pos == 0 {
                                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                                } else {
                                                    return Ok((i.slice(pos..), value));
                                                }
                                            },
                                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {
                                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                                Some(v) => value = v,
                                            }
                                        }
                                    }
                                }

                                Ok((i.slice(i.input_len()..), value))
                            }
                        )+
                    }
                }
                
                macro_rules! uints
                {
                    ($($t:tt)+) => {
                        $(
                        /// will parse a number in text form to a number
                        ///
                        /// *Complete version*: can parse until the end of input.
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                            where
                            T: InputIter + Slice<RangeFrom<usize>> + InputLength,
                            <T as InputIter>::Item: AsChar,
                            {
                                let i = input;

                                if i.input_len() == 0 {
                                    return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));
                                }

                                let mut value: $t = 0;
                                for (pos, c) in i.iter_indices() {
                                    match c.as_char().to_digit(10) {
                                        None => {
                                            if pos == 0 {
                                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));
                                            } else {
                                                return Ok((i.slice(pos..), value));
                                            }
                                        },
                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }

                                Ok((i.slice(i.input_len()..), value))
                            }
                        )+
                    }
                }
                /// Recognizes one character.
                pub fn char<I, Error: ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                {
                    move |i: I| match (i).iter_elements().next().map(|t| {
                        let b = t.as_char() == c;
                        (&c, b)
                    }) {
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                        _ => Err(Err::Error(Error::from_char(i, c))),
                    }
                }
                /// Recognizes one character and checks that it satisfies a predicate
                pub fn satisfy<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                F: Fn(char) -> bool,
                {
                    move |i: I| match (i).iter_elements().next().map(|t| {
                        let c = t.as_char();
                        let b = cond(c);
                        (c, b)
                    }) {
                        Some((c, true)) => Ok((i.slice(c.len()..), c)),
                        _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Satisfy))),
                    }
                }
                /// Recognizes one of the provided characters.
                pub fn one_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar + Copy,
                T: FindToken<<I as InputIter>::Item>,
                {
                    move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c))) {
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                        _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::OneOf))),
                    }
                }
                /// Recognizes a character that is not in the provided characters.
                pub fn none_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar + Copy,
                T: FindToken<<I as InputIter>::Item>,
                {
                    move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c))) {
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                        _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::NoneOf))),
                    }
                }
                /// Recognizes the string "\r\n".
                pub fn crlf<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>>,
                T: InputIter,
                T: Compare<&'static str>,
                {
                    match input.compare("\r\n") {
                        //FIXME: is this the right index?
                        CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                        _ => {
                        let e: ErrorKind = ErrorKind::CrLf;
                        Err(Err::Error(E::from_error_kind(input, e)))
                        }
                    }
                }
                /// Recognizes a string of any char except '\r\n' or '\n'.
                pub fn not_line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter + InputLength,
                T: Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                <T as InputIter>::Item: AsChar,
                {
                    match input.position(|item| {
                        let c = item.as_char();
                        c == '\r' || c == '\n'
                    }) {
                        None => Ok((input.slice(input.input_len()..), input)),
                        Some(index) => {
                        let mut it = input.slice(index..).iter_elements();
                        let nth = it.next().unwrap().as_char();
                        if nth == '\r' {
                            let sliced = input.slice(index..);
                            let comp = sliced.compare("\r\n");
                            match comp {
                            //FIXME: calculate the right index
                            CompareResult::Ok => Ok((input.slice(index..), input.slice(..index))),
                            _ => {
                                let e: ErrorKind = ErrorKind::Tag;
                                Err(Err::Error(E::from_error_kind(input, e)))
                            }
                            }
                        } else {
                            Ok((input.slice(index..), input.slice(..index)))
                        }
                        }
                    }
                }
                /// Recognizes an end of line (both '\n' and '\r\n').
                pub fn line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter + InputLength,
                T: Compare<&'static str>,
                {
                    match input.compare("\n") {
                        CompareResult::Ok => Ok((input.slice(1..), input.slice(0..1))),
                        CompareResult::Incomplete => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                        CompareResult::Error => {
                        match input.compare("\r\n") {
                            //FIXME: is this the right index?
                            CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                            _ => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                        }
                        }
                    }
                }
                /// Matches a newline character '\n'.
                pub fn newline<I, Error: ParseError<I>>( input:I ) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                {
                    char('\n')(input)
                }
                /// Matches a tab character '\t'.
                pub fn tab<I, Error: ParseError<I>>( input:I ) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                {
                    char('\t')(input)
                }
                /// Matches one byte as a character. Note that the input type will
                /// accept a `str`, but not a `&[u8]`, unlike many other nom parsers.
                pub fn anychar<T, E: ParseError<T>>(input: T) -> IResult<T, char, E> where
                T: InputIter + InputLength + Slice<RangeFrom<usize>>,
                <T as InputIter>::Item: AsChar,
                {
                    let mut it = input.iter_indices();
                    match it.next() {
                        None => Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof))),
                        Some((_, c)) => match it.next() {
                        None => Ok((input.slice(input.input_len()..), c.as_char())),
                        Some((idx, _)) => Ok((input.slice(idx..), c.as_char())),
                        },
                    }
                }
                /// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
                pub fn alpha0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_alpha())
                }
                /// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
                pub fn alpha1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_alpha(), ErrorKind::Alpha)
                }
                /// Recognizes zero or more ASCII numerical characters: 0-9
                pub fn digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_dec_digit())
                }
                /// Recognizes one or more ASCII numerical characters: 0-9
                pub fn digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_dec_digit(), ErrorKind::Digit)
                }
                /// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f
                pub fn hex_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_hex_digit())
                }
                /// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f
                pub fn hex_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_hex_digit(), ErrorKind::HexDigit)
                }
                /// Recognizes zero or more octal characters: 0-7
                pub fn oct_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_oct_digit())
                }
                /// Recognizes one or more octal characters: 0-7
                pub fn oct_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_oct_digit(), ErrorKind::OctDigit)
                }
                /// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z
                pub fn alphanumeric0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_alphanum())
                }
                /// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z
                pub fn alphanumeric1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_alphanum(), ErrorKind::AlphaNumeric)
                }
                /// Recognizes zero or more spaces and tabs.
                pub fn space0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position_complete(|item| {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                    })
                }
                /// Recognizes one or more spaces and tabs.
                pub fn space1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position1_complete(
                        |item| {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                        },
                        ErrorKind::Space,
                    )
                }
                /// Recognizes zero or more spaces, tabs, carriage returns and line feeds.
                pub fn multispace0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position_complete(|item| {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                    })
                }
                /// Recognizes one or more spaces, tabs, carriage returns and line feeds.
                pub fn multispace1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position1_complete(
                        |item| {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                        },
                        ErrorKind::MultiSpace,
                    )
                }

                pub fn sign<T, E: ParseError<T>>(input: T) -> IResult<T, bool, E> where
                T: Clone + InputTake,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, opt_sign) = opt(alt((
                        value(false, tag(&b"-"[..])),
                        value(true, tag(&b"+"[..])),
                    )))(input)?;
                    let sign = opt_sign.unwrap_or(true);

                    Ok((i, sign))
                }

                ints! { i8 i16 i32 i64 i128 }

                uints! { u8 u16 u32 u64 u128 }
            }

            pub mod streaming
            {
                use ::
                {
                    ops::{Range, RangeFrom, RangeTo},
                    parsers::nom::
                    {
                       branch::alt,
                       bytes::streaming::tag,
                       combinator::{ opt, value },
                       error::ErrorKind,
                       error::ParseError,
                       internal::{Err, IResult, Needed},
                       traits::{ AsChar, Compare, CompareResult, FindToken, InputIter, InputLength, InputTake, InputTakeAtPosition, Slice, },
                    },
                    *
                };
                
                macro_rules! ints 
                {
                    ($($t:tt)+) => {
                        $(
                        /// will parse a number in text form to a number
                        ///
                        /// *Complete version*: can parse until the end of input.
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                            where
                            T: InputIter + Slice<RangeFrom<usize>> + InputLength + InputTake + Clone,
                            <T as InputIter>::Item: AsChar,
                            T: for <'a> Compare<&'a[u8]>,
                            {
                            let (i, sign) = sign(input.clone())?;

                                if i.input_len() == 0 {
                                    return Err(Err::Incomplete(Needed::new(1)));
                                }

                                let mut value: $t = 0;
                                if sign {
                                    for (pos, c) in i.iter_indices() {
                                        match c.as_char().to_digit(10) {
                                            None => {
                                                if pos == 0 {
                                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                                } else {
                                                    return Ok((i.slice(pos..), value));
                                                }
                                            },
                                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                                Some(v) => value = v,
                                            }
                                        }
                                    }
                                } else {
                                    for (pos, c) in i.iter_indices() {
                                        match c.as_char().to_digit(10) {
                                            None => {
                                                if pos == 0 {
                                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                                } else {
                                                    return Ok((i.slice(pos..), value));
                                                }
                                            },
                                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {
                                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                                Some(v) => value = v,
                                            }
                                        }
                                    }
                                }

                                Err(Err::Incomplete(Needed::new(1)))
                            }
                        )+
                    }
                }
                
                macro_rules! uints
                {
                    ($($t:tt)+) => {
                        $(
                        /// will parse a number in text form to a number
                        ///
                        /// *Complete version*: can parse until the end of input.
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                            where
                            T: InputIter + Slice<RangeFrom<usize>> + InputLength,
                            <T as InputIter>::Item: AsChar,
                            {
                                let i = input;

                                if i.input_len() == 0 {
                                    return Err(Err::Incomplete(Needed::new(1)));
                                }

                                let mut value: $t = 0;
                                for (pos, c) in i.iter_indices() {
                                    match c.as_char().to_digit(10) {
                                        None => {
                                            if pos == 0 {
                                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));
                                            } else {
                                                return Ok((i.slice(pos..), value));
                                            }
                                        },
                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }

                                Err(Err::Incomplete(Needed::new(1)))
                            }
                        )+
                    }
                }
                /// Recognizes one character.
                pub fn char<I, Error: ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter + InputLength,
                <I as InputIter>::Item: AsChar,
                {
                    move |i: I| match (i).iter_elements().next().map(|t| {
                        let b = t.as_char() == c;
                        (&c, b)
                    }) {
                        None => Err(Err::Incomplete(Needed::new(c.len() - i.input_len()))),
                        Some((_, false)) => Err(Err::Error(Error::from_char(i, c))),
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    }
                }
                /// Recognizes one character and checks that it satisfies a predicate.
                pub fn satisfy<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                F: Fn(char) -> bool,
                {
                    move |i: I| match (i).iter_elements().next().map(|t| {
                        let c = t.as_char();
                        let b = cond(c);
                        (c, b)
                    }) {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Satisfy))),
                        Some((c, true)) => Ok((i.slice(c.len()..), c)),
                    }
                }
                /// Recognizes one of the provided characters.
                pub fn one_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar + Copy,
                T: FindToken<<I as InputIter>::Item>,
                {
                    move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c))) {
                        None => Err(Err::Incomplete(Needed::new(1))),
                        Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::OneOf))),
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    }
                }
                /// Recognizes a character that is not in the provided characters.
                pub fn none_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar + Copy,
                T: FindToken<<I as InputIter>::Item>,
                {
                    move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c))) {
                        None => Err(Err::Incomplete(Needed::new(1))),
                        Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::NoneOf))),
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    }
                }
                /// Recognizes the string "\r\n".
                pub fn crlf<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter,
                T: Compare<&'static str>,
                {
                    match input.compare("\r\n") {
                        CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),
                        CompareResult::Error => {
                        let e: ErrorKind = ErrorKind::CrLf;
                        Err(Err::Error(E::from_error_kind(input, e)))
                        }
                    }
                }
                /// Recognizes a string of any char except '\r\n' or '\n'.
                pub fn not_line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter + InputLength,
                T: Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                <T as InputIter>::Item: AsChar,
                {
                    match input.position(|item| {
                        let c = item.as_char();
                        c == '\r' || c == '\n'
                    }) {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some(index) => {
                        let mut it = input.slice(index..).iter_elements();
                        let nth = it.next().unwrap().as_char();
                        if nth == '\r' {
                            let sliced = input.slice(index..);
                            let comp = sliced.compare("\r\n");
                            match comp {
                            //FIXME: calculate the right index
                            CompareResult::Incomplete => Err(Err::Incomplete(Needed::Unknown)),
                            CompareResult::Error => {
                                let e: ErrorKind = ErrorKind::Tag;
                                Err(Err::Error(E::from_error_kind(input, e)))
                            }
                            CompareResult::Ok => Ok((input.slice(index..), input.slice(..index))),
                            }
                        } else {
                            Ok((input.slice(index..), input.slice(..index)))
                        }
                        }
                    }
                }
                /// Recognizes an end of line (both '\n' and '\r\n').
                pub fn line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter + InputLength,
                T: Compare<&'static str>,
                {
                    match input.compare("\n") {
                        CompareResult::Ok => Ok((input.slice(1..), input.slice(0..1))),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(1))),
                        CompareResult::Error => {
                        match input.compare("\r\n") {
                            //FIXME: is this the right index?
                            CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                            CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),
                            CompareResult::Error => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                        }
                        }
                    }
                }
                /// Matches a newline character '\\n'.
                pub fn newline<I, Error: ParseError<I>>( input:I ) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter + InputLength,
                <I as InputIter>::Item: AsChar,
                {
                    char('\n')(input)
                }
                /// Matches a tab character '\t'.
                pub fn tab<I, Error: ParseError<I>>( input:I ) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter + InputLength,
                <I as InputIter>::Item: AsChar,
                {
                    char('\t')(input)
                }
                /// Matches one byte as a character. Note that the input type will
                /// accept a `str`, but not a `&[u8]`, unlike many other nom parsers.
                pub fn anychar<T, E: ParseError<T>>(input: T) -> IResult<T, char, E> where
                T: InputIter + InputLength + Slice<RangeFrom<usize>>,
                <T as InputIter>::Item: AsChar,
                {
                    let mut it = input.iter_indices();
                    match it.next() {
                        None => Err(Err::Incomplete(Needed::new(1))),
                        Some((_, c)) => match it.next() {
                        None => Ok((input.slice(input.input_len()..), c.as_char())),
                        Some((idx, _)) => Ok((input.slice(idx..), c.as_char())),
                        },
                    }
                }
                /// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
                pub fn alpha0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_alpha())
                }
                /// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
                pub fn alpha1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_alpha(), ErrorKind::Alpha)
                }
                /// Recognizes zero or more ASCII numerical characters: 0-9.
                pub fn digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_dec_digit())
                }
                /// Recognizes one or more ASCII numerical characters: 0-9.
                pub fn digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_dec_digit(), ErrorKind::Digit)
                }
                /// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f
                pub fn hex_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_hex_digit())
                }
                /// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f.
                pub fn hex_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_hex_digit(), ErrorKind::HexDigit)
                }
                /// Recognizes zero or more octal characters: 0-7.
                pub fn oct_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_oct_digit())
                }
                /// Recognizes one or more octal characters: 0-7.
                pub fn oct_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_oct_digit(), ErrorKind::OctDigit)
                }
                /// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
                pub fn alphanumeric0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_alphanum())
                }
                /// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
                pub fn alphanumeric1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_alphanum(), ErrorKind::AlphaNumeric)
                }
                /// Recognizes zero or more spaces and tabs.
                pub fn space0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position(|item| {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                    })
                }
                /// Recognizes one or more spaces and tabs.
                pub fn space1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position1(
                        |item| {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                        },
                        ErrorKind::Space,
                    )
                }
                /// Recognizes zero or more spaces, tabs, carriage returns and line feeds.
                pub fn multispace0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position(|item| {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                    })
                }
                /// Recognizes one or more spaces, tabs, carriage returns and line feeds.
                pub fn multispace1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position1(
                        |item| {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                        },
                        ErrorKind::MultiSpace,
                    )
                }

                pub fn sign<T, E: ParseError<T>>(input: T) -> IResult<T, bool, E> where
                T: Clone + InputTake + InputLength,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, opt_sign) = opt(alt((
                        value(false, tag(&b"-"[..])),
                        value(true, tag(&b"+"[..])),
                    )))(input)?;
                    let sign = opt_sign.unwrap_or(true);

                    Ok((i, sign))
                }

                ints! { i8 i16 i32 i64 i128 }
                uints! { u8 u16 u32 u64 u128 }
            }

        }
        
        pub mod number
        {
            use ::
            {
                parsers::nom::
                {

                },
                *,
            };

            pub mod complete
            {
                use ::
                {
                    ops::{ Range, RangeFrom, RangeTo },
                    parsers::nom::
                    {
                        branch::alt,
                        bytes::complete::{ is_a, tag, tag_no_case },
                        character::complete::{char, digit1, sign},
                        combinator::{cut, map, opt, recognize},
                        error::{ ErrorKind, make_error, ParseError },
                        internal::*,
                        number::{ Endianness },
                        sequence::{pair, tuple},
                        traits::{ AsBytes, AsChar, Compare, InputIter, InputLength, InputTake, InputTakeAtPosition, Offset, ParseTo, Slice },
                    },
                    *
                };
                /// Recognizes an unsigned 1 byte integer.
                #[inline] pub fn be_u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 2 bytes integer.
                #[inline] pub fn be_u16<I, E: ParseError<I>>( input:I ) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 2;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u16;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u16;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 3 byte integer.
                #[inline] pub fn be_u24<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 3;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u32;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u32;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 4 bytes integer.
                #[inline] pub fn be_u32<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 4;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u32;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u32;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 8 bytes integer.
                #[inline] pub fn be_u64<I, E: ParseError<I>>( input:I ) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 8;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u64;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u64;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 16 bytes integer.
                #[inline] pub fn be_u128<I, E: ParseError<I>>( input:I ) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 16;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u128;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u128;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a signed 1 byte integer.
                #[inline] pub fn be_i8<I, E: ParseError<I>>( input:I ) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u8.map(|x| x as i8).parse(input)
                }
                /// Recognizes a big endian signed 2 bytes integer.
                #[inline] pub fn be_i16<I, E: ParseError<I>>( input:I ) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u16.map(|x| x as i16).parse(input)
                }
                /// Recognizes a big endian signed 3 bytes integer.
                #[inline] pub fn be_i24<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    // Same as the unsigned version but we need to sign-extend manually here
                    be_u24
                        .map(|x| {
                        if x & 0x80_00_00 != 0 {
                            (x | 0xff_00_00_00) as i32
                        } else {
                            x as i32
                        }
                        })
                        .parse(input)
                }
                /// Recognizes a big endian signed 4 bytes integer.
                #[inline] pub fn be_i32<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u32.map(|x| x as i32).parse(input)
                }
                /// Recognizes a big endian signed 8 bytes integer.
                #[inline] pub fn be_i64<I, E: ParseError<I>>( input:I ) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u64.map(|x| x as i64).parse(input)
                }
                /// Recognizes a big endian signed 16 bytes integer.
                #[inline] pub fn be_i128<I, E: ParseError<I>>( input:I ) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u128.map(|x| x as i128).parse(input)
                }
                /// Recognizes an unsigned 1 byte integer.
                #[inline] pub fn le_u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 2 bytes integer.
                #[inline] pub fn le_u16<I, E: ParseError<I>>( input:I ) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 2;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u16;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u16) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 3 byte integer.
                #[inline] pub fn le_u24<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 3;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u32;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u32) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 4 bytes integer.
                #[inline] pub fn le_u32<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 4;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u32;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u32) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 8 bytes integer.
                #[inline] pub fn le_u64<I, E: ParseError<I>>( input:I ) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 8;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u64;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u64) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 16 bytes integer.
                #[inline] pub fn le_u128<I, E: ParseError<I>>( input:I ) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 16;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u128;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u128) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a signed 1 byte integer.
                #[inline] pub fn le_i8<I, E: ParseError<I>>( input:I ) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u8.map(|x| x as i8).parse(input)
                }
                /// Recognizes a little endian signed 2 bytes integer.
                #[inline] pub fn le_i16<I, E: ParseError<I>>( input:I ) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u16.map(|x| x as i16).parse(input)
                }
                /// Recognizes a little endian signed 3 bytes integer.
                #[inline] pub fn le_i24<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u24
                    .map(|x| {
                    if x & 0x80_00_00 != 0 {
                        (x | 0xff_00_00_00) as i32
                    } else {
                        x as i32
                    }
                    })
                    .parse(input)
                }
                /// Recognizes a little endian signed 4 bytes integer.
                #[inline] pub fn le_i32<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                le_u32.map(|x| x as i32).parse(input)
                }
                /// Recognizes a little endian signed 8 bytes integer.
                #[inline] pub fn le_i64<I, E: ParseError<I>>( input:I ) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u64.map(|x| x as i64).parse(input)
                }
                /// Recognizes a little endian signed 16 bytes integer.
                #[inline] pub fn le_i128<I, E: ParseError<I>>( input:I ) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u128.map(|x| x as i128).parse(input)
                }
                /// Recognizes an unsigned 1 byte integer
                #[inline] pub fn u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes an unsigned 2 bytes integer
                #[inline] pub fn u16<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u16,
                        Endianness::Little => le_u16,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u16,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u16,
                    }
                }
                /// Recognizes an unsigned 3 byte integer
                #[inline] pub fn u24<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u24,
                        Endianness::Little => le_u24,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u24,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u24,
                    }
                }
                /// Recognizes an unsigned 4 byte integer
                #[inline] pub fn u32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u32,
                        Endianness::Little => le_u32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u32,
                    }
                }
                /// Recognizes an unsigned 8 byte integer
                #[inline] pub fn u64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u64,
                        Endianness::Little => le_u64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u64,
                    }
                }
                /// Recognizes an unsigned 16 byte integer.
                #[inline] pub fn u128<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u128,
                        Endianness::Little => le_u128,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u128,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u128,
                    }
                }
                /// Recognizes a signed 1 byte integer
                #[inline] pub fn i8<I, E: ParseError<I>>(i: I) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    u8.map(|x| x as i8).parse(i)
                }
                /// Recognizes a signed 2 byte integer
                #[inline] pub fn i16<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i16,
                        Endianness::Little => le_i16,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i16,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i16,
                    }
                }
                /// Recognizes a signed 3 byte integer.
                #[inline] pub fn i24<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i24,
                        Endianness::Little => le_i24,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i24,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i24,
                    }
                }
                /// Recognizes a signed 4 byte integer.
                #[inline] pub fn i32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i32,
                        Endianness::Little => le_i32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i32,
                    }
                }
                /// Recognizes a signed 8 byte integer
                #[inline] pub fn i64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i64,
                        Endianness::Little => le_i64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i64,
                    }
                }
                /// Recognizes a signed 16 byte integer
                #[inline] pub fn i128<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i128,
                        Endianness::Little => le_i128,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i128,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i128,
                    }
                }
                /// Recognizes a big endian 4 bytes floating point number.
                #[inline] pub fn be_f32<I, E: ParseError<I>>( input:I ) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match be_u32(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f32::from_bits(o))),
                    }
                }
                /// Recognizes a big endian 8 bytes floating point number.
                #[inline] pub fn be_f64<I, E: ParseError<I>>( input:I ) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match be_u64(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f64::from_bits(o))),
                    }
                }
                /// Recognizes a little endian 4 bytes floating point number.
                #[inline] pub fn le_f32<I, E: ParseError<I>>( input:I ) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match le_u32(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f32::from_bits(o))),
                    }
                }
                /// Recognizes a little endian 8 bytes floating point number.
                #[inline] pub fn le_f64<I, E: ParseError<I>>( input:I ) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match le_u64(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f64::from_bits(o))),
                    }
                }
                /// Recognizes a 4 byte floating point number
                #[inline] pub fn f32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_f32,
                        Endianness::Little => le_f32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_f32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_f32,
                    }
                }
                /// Recognizes an 8 byte floating point number
                #[inline] pub fn f64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_f64,
                        Endianness::Little => le_f64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_f64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_f64,
                    }
                }
                /// Recognizes a hex-encoded integer.
                #[inline] pub fn hex_u32<'a, E: ParseError<&'a [u8]>>(input: &'a [u8]) -> IResult<&'a [u8], u32, E>
                {
                    let (i, o) = is_a(&b"0123456789abcdefABCDEF"[..])(input)?;
                    
                    let (parsed, remaining) = if o.len() <= 8 {
                        (o, i)
                    } else {
                        (&input[..8], &input[8..])
                    };

                    let res = parsed
                        .iter()
                        .rev()
                        .enumerate()
                        .map(|(k, &v)| {
                        let digit = v as char;
                        digit.to_digit(16).unwrap_or(0) << (k * 4)
                        })
                        .sum();

                    Ok((remaining, res))
                }
                /// Recognizes floating point number in a byte string and returns the corresponding slice.
                pub fn recognize_float<T, E:ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    recognize(
                        tuple((
                        opt(alt((char('+'), char('-')))),
                        alt((
                            map(tuple((digit1, opt(pair(char('.'), opt(digit1))))), |_| ()),
                            map(tuple((char('.'), digit1)), |_| ())
                        )),
                        opt(tuple((
                            alt((char('e'), char('E'))),
                            opt(alt((char('+'), char('-')))),
                            cut(digit1)
                        )))
                        ))
                    )(input)
                }
                
                pub fn recognize_float_or_exceptions<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + InputTake + Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    alt((
                        |i: T| {
                        recognize_float::<_, E>(i.clone()).map_err(|e| match e {
                            ::parsers::nom::Err::Error(_) => ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)),
                            ::parsers::nom::Err::Failure(_) => ::parsers::nom::Err::Failure(E::from_error_kind(i, ErrorKind::Float)),
                            ::parsers::nom::Err::Incomplete(needed) => ::parsers::nom::Err::Incomplete(needed),
                        })
                        },
                        |i: T| {
                        tag_no_case::<_, _, E>("nan")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                        |i: T| {
                        tag_no_case::<_, _, E>("inf")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                        |i: T| {
                        tag_no_case::<_, _, E>("infinity")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                    ))(input)
                }
                /// Recognizes a floating point number in text format
                pub fn recognize_float_parts<T, E: ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
                T: Clone + Offset,
                T: InputIter + InputTake,
                <T as InputIter>::Item: AsChar + Copy,
                T: InputTakeAtPosition + InputLength,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: for<'a> Compare<&'a [u8]>,
                T: AsBytes,
                {
                    let (i, sign) = sign(input.clone())?;

                    //let (i, zeroes) = take_while(|c: <T as InputTakeAtPosition>::Item| c.as_char() == '0')(i)?;
                    let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0') {
                        Some(index) => i.take_split(index),
                        None => i.take_split(i.input_len()),
                    };
                    //let (i, mut integer) = digit0(i)?;
                    let (i, mut integer) = match i
                        .as_bytes()
                        .iter()
                        .position(|c| !(*c >= b'0' && *c <= b'9'))
                    {
                        Some(index) => i.take_split(index),
                        None => i.take_split(i.input_len()),
                    };

                    if integer.input_len() == 0 && zeroes.input_len() > 0 {
                        // keep the last zero if integer is empty
                        integer = zeroes.slice(zeroes.input_len() - 1..);
                    }

                    let (i, opt_dot) = opt(tag(&b"."[..]))(i)?;
                    let (i, fraction) = if opt_dot.is_none() 
                    {
                        let i2 = i.clone();
                        (i2, i.slice(..0))
                    } else {
                        // match number, trim right zeroes
                        let mut zero_count = 0usize;
                        let mut position = None;
                        for (pos, c) in i.as_bytes().iter().enumerate() {
                        if *c >= b'0' && *c <= b'9' {
                            if *c == b'0' {
                            zero_count += 1;
                            } else {
                            zero_count = 0;
                            }
                        } else {
                            position = Some(pos);
                            break;
                        }
                        }

                        let position = position.unwrap_or(i.input_len());

                        let index = if zero_count == 0 {
                        position
                        } else if zero_count == position {
                        position - zero_count + 1
                        } else {
                        position - zero_count
                        };

                        (i.slice(position..), i.slice(..index))
                    };

                    if integer.input_len() == 0 && fraction.input_len() == 0 {
                        return Err(Err::Error(E::from_error_kind(input, ErrorKind::Float)));
                    }

                    let i2 = i.clone();
                    let (i, e) = match i.as_bytes().iter().next() {
                        Some(b'e') => (i.slice(1..), true),
                        Some(b'E') => (i.slice(1..), true),
                        _ => (i, false),
                    };

                    let (i, exp) = if e {
                        cut( ::parsers::nom::character::complete::i32)(i)?
                    } else {
                        (i2, 0)
                    };

                    Ok((i, (sign, integer, fraction, exp)))
                }
                /// Recognizes floating point number in text format and returns a f32.
                pub fn float<T, E: ParseError<T>>(input: T) -> IResult<T, f32, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
                T: Clone + Offset + ParseTo<f32> + Compare<&'static str>,
                T: InputIter + InputLength + InputTake,
                <T as InputIter>::Item: AsChar + Copy,
                <T as InputIter>::IterElem: Clone,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: AsBytes,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, s) = recognize_float_or_exceptions(input)?;
                    match s.parse_to() {
                        Some(f) => Ok((i, f)),
                        None => Err(::parsers::nom::Err::Error(E::from_error_kind(
                        i,
                        ErrorKind::Float,
                        ))),
                    }
                }
                /// Recognizes floating point number in text format and returns a f64.
                pub fn double<T, E: ParseError<T>>(input: T) -> IResult<T, f64, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
                T: Clone + Offset + ParseTo<f64> + Compare<&'static str>,
                T: InputIter + InputLength + InputTake,
                <T as InputIter>::Item: AsChar + Copy,
                <T as InputIter>::IterElem: Clone,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: AsBytes,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, s) = recognize_float_or_exceptions(input)?;
                    match s.parse_to() {
                        Some(f) => Ok((i, f)),
                        None => Err( ::parsers::nom::Err::Error(E::from_error_kind(
                        i,
                        ErrorKind::Float,
                        ))),
                    }
                }

            }

            pub mod streaming
            {
                //! Parsers recognizing numbers, streaming version
                use ::
                {
                    ops::{RangeFrom, RangeTo},
                    parsers::nom::
                    {
                        branch::alt,
                        bytes::streaming::{ is_a, tag, tag_no_case },
                        character::streaming::{char, digit1, sign},
                        combinator::{cut, map, opt, recognize},
                        error::{ErrorKind, ParseError},
                        internal::*,
                        number::{ Endianness },
                        sequence::{pair, tuple},
                        traits::{ AsBytes, AsChar, Compare, InputIter, InputLength, InputTake, InputTakeAtPosition, Offset, ParseTo, Slice },

                    },
                    *
                };
                /// Recognizes an unsigned 1 byte integer.
                #[inline] pub fn be_u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(1)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 2 bytes integer.
                #[inline] pub fn be_u16<I, E: ParseError<I>>( input:I ) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 2;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u16;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u16;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 3 byte integer.
                #[inline] pub fn be_u24<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 3;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u32;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u32;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 4 bytes integer.
                #[inline] pub fn be_u32<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 4;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u32;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u32;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 8 bytes integer.
                #[inline] pub fn be_u64<I, E: ParseError<I>>( input:I ) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 8;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u64;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u64;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 16 bytes integer.
                #[inline] pub fn be_u128<I, E: ParseError<I>>( input:I ) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 16;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u128;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u128;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a signed 1 byte integer.
                #[inline] pub fn be_i8<I, E: ParseError<I>>( input:I ) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u8.map(|x| x as i8).parse(input)
                }
                /// Recognizes a big endian signed 2 bytes integer.
                #[inline] pub fn be_i16<I, E: ParseError<I>>( input:I ) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u16.map(|x| x as i16).parse(input)
                }
                /// Recognizes a big endian signed 3 bytes integer.
                #[inline] pub fn be_i24<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u24
                        .map(|x| {
                        if x & 0x80_00_00 != 0 {
                            (x | 0xff_00_00_00) as i32
                        } else {
                            x as i32
                        }
                        })
                        .parse(input)
                }
                /// Recognizes a big endian signed 4 bytes integer.
                #[inline] pub fn be_i32<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u32.map(|x| x as i32).parse(input)
                }
                /// Recognizes a big endian signed 8 bytes integer.
                #[inline] pub fn be_i64<I, E: ParseError<I>>( input:I ) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u64.map(|x| x as i64).parse(input)
                }
                /// Recognizes a big endian signed 16 bytes integer.
                #[inline] pub fn be_i128<I, E: ParseError<I>>( input:I ) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u128.map(|x| x as i128).parse(input)
                }
                /// Recognizes an unsigned 1 byte integer.
                #[inline] pub fn le_u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(1)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 2 bytes integer.
                #[inline] pub fn le_u16<I, E: ParseError<I>>( input:I ) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 2;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u16;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u16) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 3 bytes integer.
                #[inline] pub fn le_u24<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 3;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u32;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u32) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 4 bytes integer.
                #[inline] pub fn le_u32<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 4;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u32;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u32) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 8 bytes integer.
                #[inline] pub fn le_u64<I, E: ParseError<I>>( input:I ) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 8;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u64;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u64) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 16 bytes integer.
                #[inline] pub fn le_u128<I, E: ParseError<I>>( input:I ) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 16;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u128;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u128) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a signed 1 byte integer.
                #[inline] pub fn le_i8<I, E: ParseError<I>>( input:I ) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u8.map(|x| x as i8).parse(input)
                }
                /// Recognizes a little endian signed 2 bytes integer.
                #[inline] pub fn le_i16<I, E: ParseError<I>>( input:I ) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u16.map(|x| x as i16).parse(input)
                }
                /// Recognizes a little endian signed 3 bytes integer.
                #[inline] pub fn le_i24<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u24
                        .map(|x| {
                        if x & 0x80_00_00 != 0 {
                            (x | 0xff_00_00_00) as i32
                        } else {
                            x as i32
                        }
                        })
                        .parse(input)
                }
                /// Recognizes a little endian signed 4 bytes integer.
                #[inline] pub fn le_i32<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u32.map(|x| x as i32).parse(input)
                }
                /// Recognizes a little endian signed 8 bytes integer.
                #[inline] pub fn le_i64<I, E: ParseError<I>>( input:I ) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u64.map(|x| x as i64).parse(input)
                }
                /// Recognizes a little endian signed 16 bytes integer.
                #[inline] pub fn le_i128<I, E: ParseError<I>>( input:I ) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u128.map(|x| x as i128).parse(input)
                }
                /// Recognizes an unsigned 1 byte integer
                #[inline] pub fn u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(1)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes an unsigned 2 bytes integer
                #[inline] pub fn u16<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u16,
                        Endianness::Little => le_u16,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u16,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u16,
                    }
                }
                /// Recognizes an unsigned 3 byte integer
                #[inline] pub fn u24<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u24,
                        Endianness::Little => le_u24,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u24,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u24,
                    }
                }
                /// Recognizes an unsigned 4 byte integer.
                #[inline] pub fn u32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u32,
                        Endianness::Little => le_u32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u32,
                    }
                }
                /// Recognizes an unsigned 8 byte integer
                #[inline] pub fn u64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u64,
                        Endianness::Little => le_u64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u64,
                    }
                }
                /// Recognizes an unsigned 16 byte integer
                #[inline] pub fn u128<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u128,
                        Endianness::Little => le_u128,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u128,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u128,
                    }
                }
                /// Recognizes a signed 1 byte integer
                #[inline] pub fn i8<I, E: ParseError<I>>(i: I) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    u8.map(|x| x as i8).parse(i)
                }
                /// Recognizes a signed 2 byte integer
                #[inline] pub fn i16<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i16,
                        Endianness::Little => le_i16,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i16,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i16,
                    }
                }
                /// Recognizes a signed 3 byte integer.
                #[inline] pub fn i24<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i24,
                        Endianness::Little => le_i24,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i24,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i24,
                    }
                }
                /// Recognizes a signed 4 byte integer
                #[inline] pub fn i32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i32,
                        Endianness::Little => le_i32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i32,
                    }
                }
                /// Recognizes a signed 8 byte integer
                #[inline] pub fn i64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i64,
                        Endianness::Little => le_i64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i64,
                    }
                }
                /// Recognizes a signed 16 byte integer.
                #[inline] pub fn i128<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i128,
                        Endianness::Little => le_i128,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i128,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i128,
                    }
                }
                /// Recognizes a big endian 4 bytes floating point number.
                #[inline] pub fn be_f32<I, E: ParseError<I>>( input:I ) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match be_u32(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f32::from_bits(o))),
                    }
                }
                /// Recognizes a big endian 8 bytes floating point number.
                #[inline] pub fn be_f64<I, E: ParseError<I>>( input:I ) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match be_u64(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f64::from_bits(o))),
                    }
                }
                /// Recognizes a little endian 4 bytes floating point number.
                #[inline] pub fn le_f32<I, E: ParseError<I>>( input:I ) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match le_u32(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f32::from_bits(o))),
                    }
                }
                /// Recognizes a little endian 8 bytes floating point number.
                #[inline] pub fn le_f64<I, E: ParseError<I>>( input:I ) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match le_u64(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f64::from_bits(o))),
                    }
                }
                /// Recognizes a 4 byte floating point number
                #[inline] pub fn f32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_f32,
                        Endianness::Little => le_f32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_f32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_f32,
                    }
                }
                /// Recognizes an 8 byte floating point number
                #[inline] pub fn f64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_f64,
                        Endianness::Little => le_f64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_f64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_f64,
                    }
                }
                /// Recognizes a hex-encoded integer.
                #[inline] pub fn hex_u32<'a, E: ParseError<&'a [u8]>>(input: &'a [u8]) -> IResult<&'a [u8], u32, E>
                {
                    let (i, o) = is_a(&b"0123456789abcdefABCDEF"[..])(input)?;
                    
                    let (parsed, remaining) = if o.len() <= 8 {
                        (o, i)
                    } else {
                        (&input[..8], &input[8..])
                    };

                    let res = parsed
                        .iter()
                        .rev()
                        .enumerate()
                        .map(|(k, &v)| {
                        let digit = v as char;
                        digit.to_digit(16).unwrap_or(0) << (k * 4)
                        })
                        .sum();

                    Ok((remaining, res))
                }
                /// Recognizes a floating point number in text format and returns the corresponding part of the input.
                pub fn recognize_float<T, E:ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition + InputLength,
                <T as InputTakeAtPosition>::Item: AsChar
                {
                    recognize(
                        tuple((
                        opt(alt((char('+'), char('-')))),
                        alt((
                            map(tuple((digit1, opt(pair(char('.'), opt(digit1))))), |_| ()),
                            map(tuple((char('.'), digit1)), |_| ())
                        )),
                        opt(tuple((
                            alt((char('e'), char('E'))),
                            opt(alt((char('+'), char('-')))),
                            cut(digit1)
                        )))
                        ))
                    )(input)
                }
                
                pub fn recognize_float_or_exceptions<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + InputTake + InputLength + Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    alt((
                        |i: T| {
                        recognize_float::<_, E>(i.clone()).map_err(|e| match e {
                            ::parsers::nom::Err::Error(_) => ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)),
                            ::parsers::nom::Err::Failure(_) => ::parsers::nom::Err::Failure(E::from_error_kind(i, ErrorKind::Float)),
                            ::parsers::nom::Err::Incomplete(needed) => ::parsers::nom::Err::Incomplete(needed),
                        })
                        },
                        |i: T| {
                        tag_no_case::<_, _, E>("nan")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                        |i: T| {
                        tag_no_case::<_, _, E>("inf")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                        |i: T| {
                        tag_no_case::<_, _, E>("infinity")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                    ))(input)
                }
                /// Recognizes a floating point number in text format
                pub fn recognize_float_parts<T, E: ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + ParseTo<i32>,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition + InputTake + InputLength,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: for<'a> Compare<&'a [u8]>,
                T: AsBytes,
                {
                    let (i, sign) = sign(input.clone())?;

                    //let (i, zeroes) = take_while(|c: <T as InputTakeAtPosition>::Item| c.as_char() == '0')(i)?;
                    let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0') {
                        Some(index) => i.take_split(index),
                        None => i.take_split(i.input_len()),
                    };

                    //let (i, mut integer) = digit0(i)?;
                    let (i, mut integer) = match i
                        .as_bytes()
                        .iter()
                        .position(|c| !(*c >= b'0' && *c <= b'9'))
                    {
                        Some(index) => i.take_split(index),
                        None => i.take_split(i.input_len()),
                    };

                    if integer.input_len() == 0 && zeroes.input_len() > 0 {
                        // keep the last zero if integer is empty
                        integer = zeroes.slice(zeroes.input_len() - 1..);
                    }

                    let (i, opt_dot) = opt(tag(&b"."[..]))(i)?;
                    let (i, fraction) = if opt_dot.is_none() 
                    {
                        let i2 = i.clone();
                        (i2, i.slice(..0))
                    } else {
                        // match number, trim right zeroes
                        let mut zero_count = 0usize;
                        let mut position = None;
                        for (pos, c) in i.as_bytes().iter().enumerate() {
                        if *c >= b'0' && *c <= b'9' {
                            if *c == b'0' {
                            zero_count += 1;
                            } else {
                            zero_count = 0;
                            }
                        } else {
                            position = Some(pos);
                            break;
                        }
                        }

                        let position = match position {
                        Some(p) => p,
                        None => return Err(Err::Incomplete(Needed::new(1))),
                        };

                        let index = if zero_count == 0 {
                        position
                        } else if zero_count == position {
                        position - zero_count + 1
                        } else {
                        position - zero_count
                        };

                        (i.slice(position..), i.slice(..index))
                    };

                    if integer.input_len() == 0 && fraction.input_len() == 0 {
                        return Err(Err::Error(E::from_error_kind(input, ErrorKind::Float)));
                    }

                    let i2 = i.clone();
                    let (i, e) = match i.as_bytes().iter().next() {
                        Some(b'e') => (i.slice(1..), true),
                        Some(b'E') => (i.slice(1..), true),
                        _ => (i, false),
                    };

                    let (i, exp) = if e {
                        cut( ::parsers::nom::character::streaming::i32)(i)?
                    } else {
                        (i2, 0)
                    };

                    Ok((i, (sign, integer, fraction, exp)))
                }
                /// Recognizes floating point number in text format and returns a f32.
                pub fn float<T, E: ParseError<T>>(input: T) -> IResult<T, f32, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + InputLength + InputTake + ParseTo<f32> + Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                <T as InputIter>::IterElem: Clone,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: AsBytes,
                T: for<'a> Compare<&'a [u8]>,
                { 
                    let (i, s) = recognize_float_or_exceptions(input)?;
                    match s.parse_to() {
                        Some(f) => Ok((i, f)),
                        None => Err(::parsers::nom::Err::Error(E::from_error_kind(
                        i,
                        ErrorKind::Float,
                        ))),
                    }
                }
                /// Recognizes floating point number in text format and returns a f64.
                pub fn double<T, E: ParseError<T>>(input: T) -> IResult<T, f64, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + InputLength + InputTake + ParseTo<f64> + Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                <T as InputIter>::IterElem: Clone,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: AsBytes,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, s) = recognize_float_or_exceptions(input)?;
                    match s.parse_to() {
                        Some(f) => Ok((i, f)),
                        None => Err( parsers::nom::Err::Error(E::from_error_kind(
                        i,
                        ErrorKind::Float,
                        ))),
                    }
                }
            }
            /// Configurable endianness
            #[derive(Debug, PartialEq, Eq, Clone, Copy)]
            pub enum Endianness
            {
                /// Big endian
                Big,
                /// Little endian
                Little,
                /// Will match the host's endianness
                Native,
            }
        }
    }
}

pub mod path
{
    pub use std::path::{ * };
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod rc
{
    pub use std::rc::{ * };
}

pub mod result
{
    pub use std::result::{ * };
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod str
{
    pub use std::str::{ * };    
    use ::
    {
        borrow::{ Borrow, BorrowMut, Cow },
        boxed::{ Box },
        cmp::{ Ordering },
        fs::{ File },
        hash::{Hash, Hasher},
        iter::{ FromIterator },
        io::{ self, Read, Write },
        string::{ String },
        vec::{ Array, SmallVec },
        *,
    };
    /* smallstr v0.3.0 */
    use std::ffi::{OsStr, OsString};
    /// A `String`-like container that can store a small number of bytes inline.
    #[derive(Clone, Default)]
    pub struct SmallString<A: Array<Item = u8>>
    {
        data: SmallVec<A>,
    }

    impl<A: Array<Item = u8>> SmallString<A>
    {
        /// Construct an empty string.
        #[inline] pub fn new() -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::new(),
            }
        }
        /// Construct an empty string with enough capacity pre-allocated to store  at least `n` bytes.
        #[inline] pub fn with_capacity(n: usize) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::with_capacity(n),
            }
        }
        /// Construct a `SmallString` by copying data from a `&str`.
        #[inline] pub fn from_str(s: &str) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::from_slice(s.as_bytes()),
            }
        }
        /// Construct a `SmallString` by using an existing allocation.
        #[inline] pub fn from_string(s: String) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::from_vec(s.into_bytes()),
            }
        }
        /// Constructs a new `SmallString` on the stack using UTF-8 bytes.
        #[inline] pub fn from_buf(buf: A) -> Result<SmallString<A>, FromUtf8Error<A>>
        {
            let data = SmallVec::from_buf(buf);

            match str::from_utf8(&data)
            {
                Ok(_) => Ok(SmallString { data }),
                Err(error) =>
                {
                    let buf = data.into_inner().ok().unwrap();

                    Err(FromUtf8Error { buf, error })
                }
            }
        }
        /// Constructs a new `SmallString` on the stack using the provided byte array
        /// without checking that the array contains valid UTF-8.
        #[inline] pub unsafe fn from_buf_unchecked(buf: A) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::from_buf(buf),
            }
        }
        /// The maximum number of bytes this string can hold inline.
        #[inline] pub fn inline_size(&self) -> usize { A::size() }
        /// Returns the length of this string, in bytes.
        #[inline] pub fn len(&self) -> usize { self.data.len() }
        /// Returns `true` if this string is empty.
        #[inline] pub fn is_empty(&self) -> bool { self.data.is_empty() }
        /// Returns the number of bytes this string can hold without reallocating.
        #[inline] pub fn capacity(&self) -> usize { self.data.capacity() }
        /// Returns `true` if the data has spilled into a separate heap-allocated buffer.
        #[inline] pub fn spilled(&self) -> bool { self.data.spilled() }
        /// Empties the string and returns an iterator over its former contents.
        pub fn drain(&mut self) -> Drain
        {
            unsafe
            {
                let len = self.len();
                self.data.set_len(0);
                let ptr = self.as_ptr();
                let slice = slice::from_raw_parts(ptr, len);
                let s = str::from_utf8_unchecked(slice);
                Drain { iter: s.chars() }
            }
        }
        /// Appends the given `char` to the end of this string.
        #[inline] pub fn push(&mut self, ch: char)
        {
            match ch.len_utf8()
            {
                1 => self.data.push(ch as u8),
                _ => self.push_str(ch.encode_utf8(&mut [0; 4])),
            }
        }
        /// Appends the given string slice to the end of this string.
        #[inline] pub fn push_str(&mut self, s: &str)
        {
            self.data.extend_from_slice(s.as_bytes());
        }
        /// Removes the last character from this string and returns it.
        #[inline] pub fn pop(&mut self) -> Option<char>
        {
            match self.chars().next_back()
            {
                Some(ch) => unsafe
                {
                    let new_len = self.len() - ch.len_utf8();
                    self.data.set_len(new_len);
                    Some(ch)
                },
                None => None,
            }
        }
        /// Reallocates to set the new capacity to `new_cap`.
        #[inline] pub fn grow(&mut self, new_cap: usize) { self.data.grow(new_cap); }
        /// Ensures that this string's capacity is at least `additional` bytes larger than its length.
        #[inline] pub fn reserve(&mut self, additional: usize) { self.data.reserve(additional); }
        /// Ensures that this string's capacity is `additional` bytes larger than its length.
        #[inline] pub fn reserve_exact(&mut self, additional: usize) { self.data.reserve(additional); }
        /// Shrink the capacity of the string as much as possible.
        #[inline] pub fn shrink_to_fit(&mut self) { self.data.shrink_to_fit(); }
        /// Shorten the string, keeping the first `len` bytes.
        #[inline] pub fn truncate(&mut self, len: usize)
        {
            assert!(self.is_char_boundary(len));
            self.data.truncate(len);
        }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_str(&self) -> &str
        {
            self
        }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_mut_str(&mut self) -> &mut str
        {
            self
        }
        /// Removes all contents of the string.
        #[inline] pub fn clear(&mut self)
        {
            self.data.clear();
        }
        /// Removes a `char` from this string at a byte position and returns it.
        #[inline] pub fn remove(&mut self, idx: usize) -> char
        {
            unsafe
            {
                let ch = match self[idx..].chars().next()
                {
                    Some(ch) => ch,
                    None => panic!("cannot remove a char from the end of a string"),
                };

                let ch_len = ch.len_utf8();
                let next = idx + ch_len;
                let len = self.len();
                ptr::copy
                (
                    self.as_ptr().add(next),
                    self.as_mut_ptr().add(idx),
                    len - next,
                );
                self.data.set_len(len - ch_len);
                ch
            }
        }
        /// Inserts a `char` into this string at the given byte position.
        #[inline] pub fn insert(&mut self, idx: usize, ch: char)
        {
            assert!(self.is_char_boundary(idx));

            match ch.len_utf8()
            {
                1 => self.data.insert(idx, ch as u8),
                _ => self.insert_str(idx, ch.encode_utf8(&mut [0; 4])),
            }
        }
        /// Inserts a `&str` into this string at the given byte position.
        #[inline] pub fn insert_str(&mut self, idx: usize, s: &str)
        {
            unsafe
            {
                assert!(self.is_char_boundary(idx));
                let len = self.len();
                let amt = s.len();
                self.data.reserve(amt);
                ptr::copy
                (
                    self.as_ptr().add(idx),
                    self.as_mut_ptr().add(idx + amt),
                    len - idx,
                );
                ptr::copy_nonoverlapping(s.as_ptr(), self.as_mut_ptr().add(idx), amt);
                self.data.set_len(len + amt);
            }
        }
        /// Returns a mutable reference to the contents of the `SmallString`.
        #[inline] pub unsafe fn as_mut_vec(&mut self) -> &mut SmallVec<A> { &mut self.data }
        /// Converts the `SmallString` into a `String`, without reallocating if the
        /// `SmallString` has already spilled onto the heap.
        #[inline] pub fn into_string(self) -> String { unsafe { String::from_utf8_unchecked(self.data.into_vec()) } }
        /// Converts the `SmallString` into a `Box<str>`, without reallocating if the
        /// `SmallString` has already spilled onto the heap.
        #[inline] pub fn into_boxed_str(self) -> Box<str> { self.into_string().into_boxed_str() }
        /// Convert the `SmallString` into `A`, if possible. Otherwise, return `Err(self)`.
        #[inline] pub fn into_inner(self) -> Result<A, Self> 
        { self.data.into_inner().map_err(|data| SmallString { data }) }
        /// Retains only the characters specified by the predicate.
        #[inline] pub fn retain<F: FnMut(char) -> bool>(&mut self, mut f: F)
        {
            struct SetLenOnDrop<'a, A: Array<Item = u8>>
            {
                s: &'a mut SmallString<A>,
                idx: usize,
                del_bytes: usize,
            }

            impl<'a, A: Array<Item = u8>> Drop for SetLenOnDrop<'a, A>
            {
                fn drop(&mut self)
                {
                    let new_len = self.idx - self.del_bytes;
                    debug_assert!(new_len <= self.s.len());
                    unsafe { self.s.data.set_len(new_len) };
                }
            }

            let len = self.len();
            let mut guard = SetLenOnDrop
            {
            
                s: self,
                idx: 0,
                del_bytes: 0,
            };

            while guard.idx < len
            {
                let ch = unsafe
                {
                    guard
                        .s
                        .get_unchecked(guard.idx..len)
                        .chars()
                        .next()
                        .unwrap()
                };

                let ch_len = ch.len_utf8();

                if !f(ch) { guard.del_bytes += ch_len; }

                else if guard.del_bytes > 0
                {
                    unsafe
                    {
                        ptr::copy
                        (
                            guard.s.data.as_ptr().add(guard.idx),
                            guard.s.data.as_mut_ptr().add(guard.idx - guard.del_bytes),
                            ch_len,
                        );
                    }
                }
                
                guard.idx += ch_len;
            }

            drop(guard);
        }

        fn as_mut_ptr(&mut self) -> *mut u8 { self.as_ptr() as *mut u8 }
    }

    impl<A: Array<Item = u8>> ops::Deref for SmallString<A> 
    {
        type Target = str;
        #[inline] fn deref(&self) -> &str
        {
            let bytes: &[u8] = &self.data;
            unsafe { str::from_utf8_unchecked(bytes) }
        }
    }

    impl<A: Array<Item = u8>> ops::DerefMut for SmallString<A>
    {
        #[inline] fn deref_mut(&mut self) -> &mut str
        {
            let bytes: &mut [u8] = &mut self.data;
            unsafe { str::from_utf8_unchecked_mut(bytes) }
        }
    }

    impl<A: Array<Item = u8>> AsRef<str> for SmallString<A>
    {
        #[inline] fn as_ref(&self) -> &str
        {
            self
        }
    }

    impl<A: Array<Item = u8>> AsMut<str> for SmallString<A>
    {
        #[inline] fn as_mut(&mut self) -> &mut str
        {
            self
        }
    }

    impl<A: Array<Item = u8>> Borrow<str> for SmallString<A>
    {
        #[inline] fn borrow(&self) -> &str { self }
    }

    impl<A: Array<Item = u8>> BorrowMut<str> for SmallString<A>
    {
        #[inline] fn borrow_mut(&mut self) -> &mut str { self }
    }

    impl<A: Array<Item = u8>> AsRef<[u8]> for SmallString<A>
    {
        #[inline] fn as_ref(&self) -> &[u8] { self.data.as_ref() }
    }

    impl<A: Array<Item = u8>> fmt::Write for SmallString<A>
    {
        #[inline] fn write_str(&mut self, s: &str) -> fmt::Result
        {
            self.push_str(s);
            Ok(())
        }

        #[inline] fn write_char(&mut self, ch: char) -> fmt::Result
        {
            self.push(ch);
            Ok(())
        }
    }

    impl<A: Array<Item = u8>> From<char> for SmallString<A>
    {
        #[inline] fn from(ch: char) -> SmallString<A> { SmallString::from_str(ch.encode_utf8(&mut [0; 4])) }
    }

    impl<'a, A: Array<Item = u8>> From<&'a str> for SmallString<A>
    {
        #[inline] fn from(s: &str) -> SmallString<A> { SmallString::from_str(s) }
    }

    impl<A: Array<Item = u8>> From<Box<str>> for SmallString<A>
    {
        #[inline] fn from(s: Box<str>) -> SmallString<A> { SmallString::from_string(s.into()) }
    }

    impl<A: Array<Item = u8>> From<String> for SmallString<A>
    {
        #[inline] fn from(s: String) -> SmallString<A> { SmallString::from_string(s) }
    }

    impl<'a, A: Array<Item = u8>> From<Cow<'a, str>> for SmallString<A>
    {
        fn from(value: Cow<'a, str>) -> Self
        {
            match value
            {
                Cow::Borrowed(s) => Self::from_str(s),
                Cow::Owned(s) => Self::from_string(s),
            }
        }
    }

    macro_rules! impl_index_str
    {
        ($index_type: ty) =>
        {
            impl<A: Array<Item = u8>> ops::Index<$index_type> for SmallString<A>
            {
                type Output = str;
                #[inline] fn index(&self, index: $index_type) -> &str { &self.as_str()[index] }
            }

            impl<A: Array<Item = u8>> ops::IndexMut<$index_type> for SmallString<A>
            {
                #[inline] fn index_mut(&mut self, index: $index_type) -> &mut str {  &mut self.as_mut_str()[index] }
            }
        };
    }

    impl_index_str!(ops::Range<usize>);
    impl_index_str!(ops::RangeFrom<usize>);
    impl_index_str!(ops::RangeTo<usize>);
    impl_index_str!(ops::RangeFull);

    impl<A: Array<Item = u8>> FromIterator<char> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a char> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter.into_iter().cloned());
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<Cow<'a, str>> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a str> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<A: Array<Item = u8>> FromIterator<String> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<A: Array<Item = u8>> Extend<char> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I)
        {
            let iter = iter.into_iter();
            let (lo, _) = iter.size_hint();

            self.reserve(lo);

            for ch in iter
            {
                self.push(ch);
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a char> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I)
        {
            self.extend(iter.into_iter().cloned());
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<Cow<'a, str>> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I)
        {
            for s in iter
            {
                self.push_str(&s);
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a str> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I)
        {
            for s in iter
            {
                self.push_str(s);
            }
        }
    }

    impl<A: Array<Item = u8>> Extend<String> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I)
        {
            for s in iter
            {
                self.push_str(&s);
            }
        }
    }

    impl<A: Array<Item = u8>> fmt::Debug for SmallString<A>
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Debug::fmt(&**self, f) }
    }

    impl<A: Array<Item = u8>> fmt::Display for SmallString<A>
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(&**self, f) }
    }

    macro_rules! eq_str
    {
        ( $rhs:ty ) =>
        {
            impl<'a, A: Array<Item = u8>> PartialEq<$rhs> for SmallString<A>
            {
                #[inline] fn eq(&self, rhs: &$rhs) -> bool { &self[..] == &rhs[..] }
                #[inline] fn ne(&self, rhs: &$rhs) -> bool { &self[..] != &rhs[..] }
            }
        };
    }

    eq_str!(str);
    eq_str!(&'a str);
    eq_str!(String);
    eq_str!(Cow<'a, str>);
    
    impl<A: Array<Item = u8>> PartialEq<OsStr> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &OsStr) -> bool
        {
            &self[..] == rhs
        }

        #[inline] fn ne(&self, rhs: &OsStr) -> bool
        {
            &self[..] != rhs
        }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<&'a OsStr> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &&OsStr) -> bool { &self[..] == *rhs }
        #[inline] fn ne(&self, rhs: &&OsStr) -> bool { &self[..] != *rhs }
    }
    
    impl<A: Array<Item = u8>> PartialEq<OsString> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &OsString) -> bool { &self[..] == rhs }
        #[inline] fn ne(&self, rhs: &OsString) -> bool { &self[..] != rhs }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<Cow<'a, OsStr>> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &Cow<OsStr>) -> bool { self[..] == **rhs }
        #[inline] fn ne(&self, rhs: &Cow<OsStr>) -> bool { self[..] != **rhs }
    }

    impl<A, B> PartialEq<SmallString<B>> for SmallString<A> where
    A: Array<Item = u8>,
    B: Array<Item = u8>
    {
        #[inline] fn eq(&self, rhs: &SmallString<B>) -> bool { &self[..] == &rhs[..] }

        #[inline] fn ne(&self, rhs: &SmallString<B>) -> bool { &self[..] != &rhs[..] }
    }

    impl<A: Array<Item = u8>> Eq for SmallString<A> {}

    impl<A: Array<Item = u8>> PartialOrd for SmallString<A>
    {
        #[inline] fn partial_cmp(&self, rhs: &SmallString<A>) -> Option<Ordering>
        {
            self[..].partial_cmp(&rhs[..])
        }
    }

    impl<A: Array<Item = u8>> Ord for SmallString<A>
    {
        #[inline] fn cmp(&self, rhs: &SmallString<A>) -> Ordering
        {
            self[..].cmp(&rhs[..])
        }
    }

    impl<A: Array<Item = u8>> Hash for SmallString<A>
    {
        #[inline] fn hash<H: Hasher>(&self, state: &mut H)
        {
            self[..].hash(state)
        }
    }
    /// A draining iterator for `SmallString`.
    pub struct Drain<'a>
    {
        iter: Chars<'a>,
    }

    impl<'a> Iterator for Drain<'a>
    {
        type Item = char;

        #[inline] fn next(&mut self) -> Option<char> { self.iter.next() }

        #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
    }

    impl<'a> DoubleEndedIterator for Drain<'a>
    {
        #[inline] fn next_back(&mut self) -> Option<char> { self.iter.next_back() }
    }
    /// A possible error value when creating a `SmallString` from a byte array.
    #[derive(Debug)]
    pub struct FromUtf8Error<A: Array<Item = u8>>
    {
        buf: A,
        error: Utf8Error,
    }

    impl<A: Array<Item = u8>> FromUtf8Error<A>
    {
        /// Returns the slice of `[u8]` bytes that were attempted to convert to a `SmallString`.
        #[inline] pub fn as_bytes(&self) -> &[u8] 
        {
            let ptr = &self.buf as *const _ as *const u8;
            unsafe { slice::from_raw_parts(ptr, A::size()) }
        }
        /// Returns the byte array that was attempted to convert into a `SmallString`.
        #[inline] pub fn into_buf(self) -> A  { self.buf }
        /// Returns the `Utf8Error` to get more details about the conversion failure.
        #[inline] pub fn utf8_error(&self) -> Utf8Error  { self.error }
    }

    impl<A: Array<Item = u8>> fmt::Display for FromUtf8Error<A>
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
        {
            fmt::Display::fmt(&self.error, f)
        }
    }
    /*
    pub fn write_file_str(...) -> io::Result<()> */
    /// Writes a strand to a file.
    pub fn write_file(fname: &str, contents: &str) -> io::Result<()>
    {
        let mut file = File::create(fname)?;
        file.write_all(contents.as_bytes())?;
        Ok(())
    }
    /*
    pub fn read_file_str(...) -> io::Result<String> */
    /// Reads a file and returns its contents in a string.
    pub fn read_file(fname: &str) -> io::Result<String>
    {
        // Open a file in read-only mode
        let mut file = File::open(fname)?;

        let mut contents = String::new();
        let _ = file.read_to_string(&mut contents)?;

        Ok(contents)
    }
    /// Iterator over string prefixes.
    pub struct Prefixes<'a>
    {
        s: &'a str,
        iter: CharIndices<'a>,
    }
    /// Returns an iterator over all non-empty prefixes of `s`, beginning with the shortest.
    #[inline] pub fn prefixes(s: &str) -> Prefixes
    {
        Prefixes
        {
            s,
            iter: s.char_indices(),
        }
    }

    impl<'a> Iterator for Prefixes<'a>
    {
        type Item = &'a str;
        fn next(&mut self) -> Option<&'a str>
        {
            self.iter.next().map(|(idx, ch)| &self.s[..idx + ch.len_utf8()])
        }
    }    
    /// Mask of the value bits of a continuation byte.
    pub const CONT_MASK: u8 = 0b0011_1111;
    /// Returns the initial codepoint accumulator for the first byte.
    #[inline] pub const fn utf8_first_byte(byte: u8, width: u32) -> u32
    {
        (byte & (0x7F >> width)) as u32
    }
    /// Returns the value of `ch` updated with continuation byte `byte`.
    #[inline] pub const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {
        (ch << 6) | (byte & CONT_MASK) as u32
    }
    /// Reads the next code point out of a byte iterator (assuming a UTF-8-like encoding).
    #[inline] pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32>
    {
        let x = *bytes.next()?;
        if x < 128 { return Some(x as u32); }
        
        let init = utf8_first_byte(x, 2);
        
        let y = unsafe { *bytes.next().unwrap_unchecked() };
        let mut ch = utf8_acc_cont_byte(init, y);
        if x >= 0xE0
        {
            let z = unsafe { *bytes.next().unwrap_unchecked() };
            let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);
            ch = init << 12 | y_z;
            if x >= 0xF0
            {
                let w = unsafe { *bytes.next().unwrap_unchecked() };
                ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);
            }
        }

        Some(ch)
    }
}

pub mod string
{
    pub use std::string::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };

    pub fn map_lock_result<F, T, U>(res: LockResult<T>, f: F) -> LockResult<U> where F: FnOnce(T) -> U
    {
        match res
        {
            Ok(t) => Ok(f(t)),
            Err(e) => Err(PoisonError::new(f(e.into_inner()))),
        }
    }

    pub fn map_try_lock_result<F, T, U>(res: TryLockResult<T>, f: F) -> TryLockResult<U> where 
    F: FnOnce(T) -> U
    {
        match res
        {
            Ok(t) => Ok(f(t)),
            Err(TryLockError::Poisoned(p)) => Err(TryLockError::Poisoned( PoisonError::new(f(p.into_inner())))),
            Err(TryLockError::WouldBlock) => Err(TryLockError::WouldBlock),
        }
    }

    pub fn map2_lock_result<F, T, U, R>(res: LockResult<T>, res2: LockResult<U>, f: F) -> 
    LockResult<R> where 
    F: FnOnce(T, U) -> R
    {
        match (res, res2)
        {
            (Ok(a), Ok(b)) => Ok(f(a, b)),
            (Ok(a), Err(b)) => Err(PoisonError::new(f(a, b.into_inner()))),
            (Err(a), Ok(b)) => Err(PoisonError::new(f(a.into_inner(), b))),
            (Err(a), Err(b)) => Err(PoisonError::new(f(a.into_inner(), b.into_inner()))),
        }
    }

    pub fn map2_try_lock_result<F, T, U, R>( res: TryLockResult<T>, res2: TryLockResult<U>, f: F) -> 
    TryLockResult<R> where 
    F: FnOnce(T, U) -> R
    {
        match (res, res2)
        {
            (Ok(a), Ok(b)) => Ok(f(a, b)),
            (Err(TryLockError::WouldBlock), _) => Err(TryLockError::WouldBlock),
            (_, Err(TryLockError::WouldBlock)) => Err(TryLockError::WouldBlock),
            (Ok(a), Err(TryLockError::Poisoned(b))) => Err(TryLockError::Poisoned(PoisonError::new(f(a, b.into_inner())))),
            (Err(TryLockError::Poisoned(a)), Ok(b)) => Err(TryLockError::Poisoned(PoisonError::new(f(a.into_inner(), b)))),
            (Err(TryLockError::Poisoned(a)), Err(TryLockError::Poisoned(b))) => Err(TryLockError::Poisoned(PoisonError::new( f(a.into_inner(), b.into_inner())))),
        }
    }
}
/*
linefeed*/
pub mod system
{
    use ::
    {
        *,
    };
    
    pub mod common
    {
        //! Platform-independent platform abstraction
        use ::
        {
            *,
        };
        /// A trait for viewing representations from std types
        pub trait AsInner<Inner: ?Sized>
        {
            fn as_inner(&self) -> &Inner;
        }
        /// A trait for viewing representations from std types
        pub trait AsInnerMut<Inner: ?Sized>
        {
            fn as_inner_mut(&mut self) -> &mut Inner;
        }
        /// A trait for extracting representations from std types
        pub trait IntoInner<Inner>
        {
            fn into_inner(self) -> Inner;
        }
        /// A trait for creating std types from internal representations
        pub trait FromInner<Inner>
        {
            fn from_inner(inner: Inner) -> Self;
        }
    }
}

pub mod time
{
    pub use ::timed::{ * };
    mod std
    {
        pub use std::time::{ * };
    }
}

pub mod vec
{
    pub use std::vec::{ * };
    pub use ::smallvec::
    { 
        Drain as SmallDrain,
        IntoIter as SmallIntoIter,
        *
    };
}

fn main() -> ::result::Result<(), Box<dyn std::error::Error>>
{
    use ::database::Database;
    use ::str::FromStr;

    let over:String = r#"
    receipt: "Oz-Ware Purchase Invoice"
    date:    "2012-08-06"
    customer: 
    {
        first_name:  "Dorothy"
        family_name: "Gale"
    }

    items: 
    [
        {
            part_no:  "A4786"
            descrip:  "Water Bucket (Filled)"
            price:    01.47
            quantity: 4
        }
        {
            part_no:  "E1628"
            descrip:  "High Heeled \"Ruby\" Slippers"
            size:     8
            price:    133.70
            quantity: 1
        }
    ]

    bill_to: 
    {
        street:
        # A multi-line string. Can also be written as "123 Tornado Alley\nSuite16"
        "123 Tornado Alley
        Suite 16"
        city:  "East Centerville"
        state: "KS"
    }

    ship_to: bill_to

    specialDelivery: "Follow the Yellow Brick Road to the Emerald City. 
    Pay no attention to the man behind the curtain."
    "#.to_string();
        
        // let mut db = Obj::from_str( &over.as_str() )?;
        let mut db = Database::new().build();
        println!( r#"::database::
    {:?}
    "#, db);

    Ok(())
}
// #\[stable\(feature = ".+", since = ".+"\)\]
// #\[unstable\(feature = ".+", issue = ".+"\)\]
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 35854
