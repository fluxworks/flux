#![feature
(
    tool_lints
)]

#![allow
(
    unknown_lints,
    unused_imports,
)]
/**/
#[macro_use] extern crate lazy_static;
/**/
extern crate libc;
extern crate nix;
extern crate regex;
//#[macro_use] extern crate pest_derive;
//extern crate clap;
//extern crate errno;
//extern crate exec;
//extern crate glob;
//extern crate lineread;
//extern crate pest;
//extern crate pest_derive;
//extern crate rusqlite;
//extern crate yaml_rust;

use lineread::{Command, Interface, ReadResult};


#[macro_use] mod macros
{
    use ::
    {
        *,
    };

    #[macro_export] macro_rules! log
    {
        ($fmt:expr) =>
        (
            let log_file = if let Ok(x) = std::env::var("CICADA_LOG_FILE") { x.clone() }
            else { String::new() };

            if !log_file.is_empty()
            {
                use std::io::Write as _;

                let msg = $fmt;
                match std::fs::OpenOptions::new().append(true).create(true).open(&log_file)
                {
                    Ok(mut cfile) =>
                    {
                        let pid = $crate::tlog::getpid();
                        let now = $crate::ctime::DateTime::now();
                        let msg = format!("[{}][{}] {}", now, pid, msg);
                        let msg = if msg.ends_with('\n') { msg } else { format!("{}\n", msg) };
                        match cfile.write_all(msg.as_bytes())
                        {
                            Ok(_) => {}
                            Err(_) => println!("tlog: write_all error")
                        }
                    }

                    Err(_) => println!("tlog: open file error"),
                }

            }
        );

        ($fmt:expr, $($arg:tt)*) =>
        (
            let msg = format!($fmt, $($arg)*);
            log!(&msg);
        );
    }

    #[macro_export] macro_rules! println_stderr
    {
        ($fmt:expr) =>
        (
            match writeln!(&mut ::std::io::stderr(), $fmt)
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );

        ($fmt:expr, $($arg:tt)*) =>
        (
            match writeln!(&mut ::std::io::stderr(), $fmt, $($arg)*)
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );
    }
}

pub mod env
{
    pub use std::env::{ * };
}

pub mod io
{
    pub use std::io::{ * };
} use std::io::Write;


pub mod process
{
    pub use std::process::{*};
    pub fn getpid() -> i32 { unsafe { libc::getpid() } }
}

pub mod sync
{
    pub use std::sync::{ * };
} use std::sync::Arc;

pub mod clap
{
    //! > **Command Line Argument Parser for Rust**
    use ::
    {
        *,
    };

    pub mod clap_builder
    {
        use ::
        {
            *,
        };
        
        #[macro_use] pub mod macros
        {
            use ::
            {
                *,
            };

            /// Allows you to pull the version from your Cargo.toml at compile time as `MAJOR.MINOR.PATCH_PKGVERSION_PRE`
            #[macro_export] macro_rules! crate_version {
                () => {
                    env!("CARGO_PKG_VERSION")
                };
            }
            /// Allows you to pull the authors for the command from your Cargo.toml at
            /// compile time in the form:
            /// `"author1 lastname <author1@example.com>:author2 lastname <author2@example.com>"`
            #[macro_export] macro_rules! crate_authors {
                ($sep:expr) => {{
                    static AUTHORS: &str = env!("CARGO_PKG_AUTHORS");
                    if AUTHORS.contains(':') {
                        static CACHED: std::sync::OnceLock<String> = std::sync::OnceLock::new();
                        let s = CACHED.get_or_init(|| AUTHORS.replace(':', $sep));
                        let s: &'static str = &*s;
                        s
                    } else {
                        AUTHORS
                    }
                }};
                () => {
                    env!("CARGO_PKG_AUTHORS")
                };
            }
            /// Allows you to pull the description from your Cargo.toml at compile time.
            #[macro_export] macro_rules! crate_description {
                () => {
                    env!("CARGO_PKG_DESCRIPTION")
                };
            }
            /// Allows you to pull the name from your Cargo.toml at compile time.
            #[macro_export] macro_rules! crate_name {
                () => {
                    env!("CARGO_PKG_NAME")
                };
            }
            /// Allows you to build the `Command` instance from your Cargo.toml at compile time.
            #[macro_export] macro_rules! command {
                () => {{
                    $crate::command!($crate::crate_name!())
                }};
                ($name:expr) => {{
                    let mut cmd = $crate::Command::new($name).version($crate::crate_version!());

                    let author = $crate::crate_authors!();
                    if !author.is_empty() {
                        cmd = cmd.author(author)
                    }

                    let about = $crate::crate_description!();
                    if !about.is_empty() {
                        cmd = cmd.about(about)
                    }

                    cmd
                }};
            }
            /// Requires `cargo` feature flag to be enabled.
            #[macro_export] macro_rules! command {
                () => {{
                    compile_error!("`cargo` feature flag is required");
                }};
                ($name:expr) => {{
                    compile_error!("`cargo` feature flag is required");
                }};
            }

            #[macro_export] macro_rules! arg_impl {
                ( @string $val:ident ) => {
                    stringify!($val)
                };
                ( @string $val:literal ) => {{
                    let ident_or_string_literal: &str = $val;
                    ident_or_string_literal
                }};
                ( @string $val:tt ) => {
                    ::std::compile_error!("Only identifiers or string literals supported");
                };
                ( @string ) => {
                    None
                };

                ( @char $val:ident ) => {{
                    let ident_or_char_literal = stringify!($val);
                    debug_assert_eq!(
                        ident_or_char_literal.len(),
                        1,
                        "Single-letter identifier expected, got {ident_or_char_literal}",
                    );
                    ident_or_char_literal.chars().next().unwrap()
                }};
                ( @char $val:literal ) => {{
                    let ident_or_char_literal: char = $val;
                    ident_or_char_literal
                }};
                ( @char ) => {{
                    None
                }};

                (
                    @arg
                    ($arg:expr)
                    --$long:ident
                    $($tail:tt)*
                ) => {{
                    debug_assert_eq!($arg.get_value_names(), None, "Flags should precede values");
                    debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");

                    let mut arg = $arg;
                    let long = $crate::arg_impl! { @string $long };
                    if arg.get_id() == "" {
                        arg = arg.id(long);
                    }
                    let action = $crate::ArgAction::SetTrue;
                    let arg = arg
                        .long(long)
                        .action(action);
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)*
                    };
                    arg
                }};
                (
                    @arg
                    ($arg:expr)
                    --$long:literal
                    $($tail:tt)*
                ) => {{
                    debug_assert_eq!($arg.get_value_names(), None, "Flags should precede values");
                    debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");

                    let mut arg = $arg;
                    let long = $crate::arg_impl! { @string $long };
                    if arg.get_id() == "" {
                        arg = arg.id(long);
                    }
                    let action = $crate::ArgAction::SetTrue;
                    let arg = arg
                        .long(long)
                        .action(action);
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)*
                    };
                    arg
                }};
                (
                    @arg
                    ($arg:expr)
                    -$short:ident
                    $($tail:tt)*
                ) => {{
                    debug_assert_eq!($arg.get_long(), None, "Short flags should precede long flags");
                    debug_assert_eq!($arg.get_value_names(), None, "Flags should precede values");
                    debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");

                    let action = $crate::ArgAction::SetTrue;
                    let arg = $arg
                        .short($crate::arg_impl! { @char $short })
                        .action(action);
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)*
                    };
                    arg
                }};
                (
                    @arg
                    ($arg:expr)
                    -$short:literal
                    $($tail:tt)*
                ) => {{
                    debug_assert_eq!($arg.get_long(), None, "Short flags should precede long flags");
                    debug_assert_eq!($arg.get_value_names(), None, "Flags should precede values");
                    debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");

                    let action = $crate::ArgAction::SetTrue;
                    let arg = $arg
                        .short($crate::arg_impl! { @char $short })
                        .action(action);
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)*
                    };
                    arg
                }};
                (
                    @arg
                    ($arg:expr)
                    <$value_name:ident>
                    $($tail:tt)*
                ) => {{
                    debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");
                    debug_assert_eq!($arg.get_value_names(), None, "Multiple values not yet supported");

                    let mut arg = $arg;

                    if arg.get_long().is_none() && arg.get_short().is_none() {
                        arg = arg.required(true);
                    }

                    let value_name = $crate::arg_impl! { @string $value_name };
                    if arg.get_id() == "" {
                        arg = arg.id(value_name);
                    }
                    let arg = arg
                        .value_name(value_name)
                        .action($crate::ArgAction::Set);
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)*
                    };
                    arg
                }};
                (
                    @arg
                    ($arg:expr)
                    <$value_name:literal>
                    $($tail:tt)*
                ) => {{
                    debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");
                    debug_assert_eq!($arg.get_value_names(), None, "Multiple values not yet supported");

                    let mut arg = $arg;

                    if arg.get_long().is_none() && arg.get_short().is_none() {
                        arg = arg.required(true);
                    }

                    let value_name = $crate::arg_impl! { @string $value_name };
                    if arg.get_id() == "" {
                        arg = arg.id(value_name);
                    }
                    let arg = arg
                        .value_name(value_name)
                        .action($crate::ArgAction::Set);
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)*
                    };
                    arg
                }};
                (
                    @arg
                    ($arg:expr)
                    [$value_name:ident]
                    $($tail:tt)*
                ) => {{
                    debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");
                    debug_assert_eq!($arg.get_value_names(), None, "Multiple values not yet supported");

                    let mut arg = $arg;

                    if arg.get_long().is_none() && arg.get_short().is_none() {
                        arg = arg.required(false);
                    } else {
                        arg = arg.num_args(0..=1);
                    }

                    let value_name = $crate::arg_impl! { @string $value_name };
                    if arg.get_id() == "" {
                        arg = arg.id(value_name);
                    }
                    let arg = arg
                        .value_name(value_name)
                        .action($crate::ArgAction::Set);
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)*
                    };
                    arg
                }};
                (
                    @arg
                    ($arg:expr)
                    [$value_name:literal]
                    $($tail:tt)*
                ) => {{
                    debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");
                    debug_assert_eq!($arg.get_value_names(), None, "Multiple values not yet supported");

                    let mut arg = $arg;

                    if arg.get_long().is_none() && arg.get_short().is_none() {
                        arg = arg.required(false);
                    } else {
                        arg = arg.num_args(0..=1);
                    }

                    let value_name = $crate::arg_impl! { @string $value_name };
                    if arg.get_id() == "" {
                        arg = arg.id(value_name);
                    }
                    let arg = arg
                        .value_name(value_name)
                        .action($crate::ArgAction::Set);
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)*
                    };
                    arg
                }};
                (
                    @arg
                    ($arg:expr)
                    ...
                    $($tail:tt)*
                ) => {{
                    let arg = match $arg.get_action() {
                        $crate::ArgAction::Set => {
                            if $arg.get_long().is_none() && $arg.get_short().is_none() {
                                $arg.num_args(1..)
                                    // Allow collecting arguments interleaved with flags
                                    .action($crate::ArgAction::Append)
                            } else {
                                $arg.action($crate::ArgAction::Append)
                            }
                        },
                        $crate::ArgAction::SetTrue | $crate::ArgAction::Help | $crate::ArgAction::Version => {
                            $arg.action($crate::ArgAction::Count)
                        }
                        action => {
                            panic!("Unexpected action {action:?}")
                        }
                    };
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)*
                    };
                    arg
                }};
                (
                    @arg
                    ($arg:expr)
                    $help:literal
                ) => {{
                    $arg.help($help)
                }};
                (
                    @arg
                    ($arg:expr)
                ) => {{
                    $arg
                }};
            }
            /// Create an [`Arg`] from a usage string.
            #[macro_export] macro_rules! arg {
                ( $name:ident: $($tail:tt)+ ) => {{
                    let arg = $crate::Arg::new($crate::arg_impl! { @string $name });
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)+
                    };
                    arg
                }};
                ( $($tail:tt)+ ) => {{
                    let arg = $crate::Arg::default();
                    let arg = $crate::arg_impl! {
                        @arg (arg) $($tail)+
                    };
                    debug_assert_ne!(arg.get_id(), "", "Without a value or long flag, the `name:` prefix is required");
                    arg
                }};
            }
            
            macro_rules! debug {
                ($($arg:tt)*) => {};
            }

            macro_rules! ok {
                ($expr:expr) => {
                    match $expr {
                        Ok(val) => val,
                        Err(err) => {
                            return Err(err);
                        }
                    }
                };
            }

            macro_rules! some {
                ($expr:expr) => {
                    match $expr {
                        Some(val) => val,
                        None => {
                            return None;
                        }
                    }
                };
            }
        }

        pub mod derive
        {   
            //! This module contains traits that are usable with the `#[derive(...)]` macros in `clap_derive`. 
            use ::
            {
                *,
            };
            /*
            use clap::builder::PossibleValue;
            use clap::{ArgMatches, Command, Error};
            use std::ffi::OsString;
            */
            /// Parse command-line arguments into `Self`.
            pub trait Parser: FromArgMatches + CommandFactory + Sized 
            {

                /// Parse from `std::env::args_os()`, [exit][Error::exit] on error.
                fn parse() -> Self {
                    let mut matches = <Self as CommandFactory>::command().get_matches();
                    let res = <Self as FromArgMatches>::from_arg_matches_mut(&mut matches)
                        .map_err(format_error::<Self>);
                    match res {
                        Ok(s) => s,
                        Err(e) => {
                            // Since this is more of a development-time error, we aren't doing as fancy of a quit
                            // as `get_matches`
                            e.exit()
                        }
                    }
                }
                /// Parse from `std::env::args_os()`, return Err on error.
                fn try_parse() -> Result<Self, Error> {
                    let mut matches = ok!(<Self as CommandFactory>::command().try_get_matches());
                    <Self as FromArgMatches>::from_arg_matches_mut(&mut matches).map_err(format_error::<Self>)
                }
                /// Parse from iterator, [exit][Error::exit] on error.
                fn parse_from<I, T>(itr: I) -> Self where
                    I: IntoIterator<Item = T>,
                    T: Into<OsString> + Clone,
                {
                    let mut matches = <Self as CommandFactory>::command().get_matches_from(itr);
                    let res = <Self as FromArgMatches>::from_arg_matches_mut(&mut matches)
                        .map_err(format_error::<Self>);
                    match res {
                        Ok(s) => s,
                        Err(e) => {
                            // Since this is more of a development-time error, we aren't doing as fancy of a quit
                            // as `get_matches_from`
                            e.exit()
                        }
                    }
                }
                /// Parse from iterator, return Err on error.
                fn try_parse_from<I, T>(itr: I) -> Result<Self, Error> where
                    I: IntoIterator<Item = T>,
                    T: Into<OsString> + Clone,
                {
                    let mut matches = ok!(<Self as CommandFactory>::command().try_get_matches_from(itr));
                    <Self as FromArgMatches>::from_arg_matches_mut(&mut matches).map_err(format_error::<Self>)
                }
                /// Update from iterator, [exit][Error::exit] on error.
                fn update_from<I, T>(&mut self, itr: I)  where
                    I: IntoIterator<Item = T>,
                    T: Into<OsString> + Clone,
                {
                    let mut matches = <Self as CommandFactory>::command_for_update().get_matches_from(itr);
                    let res = <Self as FromArgMatches>::update_from_arg_matches_mut(self, &mut matches)
                        .map_err(format_error::<Self>);
                    if let Err(e) = res {
                        // Since this is more of a development-time error, we aren't doing as fancy of a quit
                        // as `get_matches_from`
                        e.exit()
                    }
                }
                /// Update from iterator, return Err on error.
                fn try_update_from<I, T>(&mut self, itr: I) -> Result<(), Error> where
                    I: IntoIterator<Item = T>,
                    T: Into<OsString> + Clone,
                {
                    let mut matches =
                        ok!(<Self as CommandFactory>::command_for_update().try_get_matches_from(itr));
                    <Self as FromArgMatches>::update_from_arg_matches_mut(self, &mut matches)
                        .map_err(format_error::<Self>)
                }

            }
            /// Create a [`Command`] relevant for a user-defined container.
            pub trait CommandFactory: Sized 
            {
                /// Build a [`Command`] that can instantiate `Self`.
                ///
                /// See [`FromArgMatches::from_arg_matches_mut`] for instantiating `Self`.
                fn command() -> Command;
                /// Build a [`Command`] that can update `self`.
                ///
                /// See [`FromArgMatches::update_from_arg_matches_mut`] for updating `self`.
                fn command_for_update() -> Command;
            }
            /// Converts an instance of [`ArgMatches`] to a user-defined container.
            pub trait FromArgMatches: Sized 
            {
                /// Instantiate `Self` from [`ArgMatches`], parsing the arguments as needed.
                fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error>;

                /// Instantiate `Self` from [`ArgMatches`], parsing the arguments as needed.
                fn from_arg_matches_mut(matches: &mut ArgMatches) -> Result<Self, Error> {
                    Self::from_arg_matches(matches)
                }
                /// Assign values from `ArgMatches` to `self`.
                fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error>;

                /// Assign values from `ArgMatches` to `self`.
                fn update_from_arg_matches_mut(&mut self, matches: &mut ArgMatches) -> Result<(), Error> {
                    self.update_from_arg_matches(matches)
                }
            }
            /// Parse a set of arguments into a user-defined container.
            pub trait Args: FromArgMatches + Sized 
            {
                /// Report the [`ArgGroup::id`][crate::ArgGroup::id] for this set of arguments
                fn group_id() -> Option<crate::Id> {
                    None
                }
                /// Append to [`Command`] so it can instantiate `Self` via
                /// [`FromArgMatches::from_arg_matches_mut`]
                ///
                /// This is used to implement `#[command(flatten)]`
                ///
                /// See also [`CommandFactory::command`].
                fn augment_args(cmd: Command) -> Command;
                /// Append to [`Command`] so it can instantiate `self` via
                /// [`FromArgMatches::update_from_arg_matches_mut`]
                ///
                /// This is used to implement `#[command(flatten)]`
                ///
                /// See also [`CommandFactory::command_for_update`].
                fn augment_args_for_update(cmd: Command) -> Command;
            }
            /// Parse a sub-command into a user-defined enum.
            pub trait Subcommand: FromArgMatches + Sized 
            {
                /// Append to [`Command`] so it can instantiate `Self` via
                /// [`FromArgMatches::from_arg_matches_mut`]
                ///
                /// This is used to implement `#[command(flatten)]`
                ///
                /// See also [`CommandFactory::command`].
                fn augment_subcommands(cmd: Command) -> Command;
                /// Append to [`Command`] so it can instantiate `self` via
                /// [`FromArgMatches::update_from_arg_matches_mut`]
                ///
                /// This is used to implement `#[command(flatten)]`
                ///
                /// See also [`CommandFactory::command_for_update`].
                fn augment_subcommands_for_update(cmd: Command) -> Command;
                /// Test whether `Self` can parse a specific subcommand
                fn has_subcommand(name: &str) -> bool;
            }
            /// Parse arguments into enums.
            pub trait ValueEnum: Sized + Clone 
            {
                /// All possible argument values, in display order.
                fn value_variants<'a>() -> &'a [Self];

                /// Parse an argument into `Self`.
                fn from_str(input: &str, ignore_case: bool) -> Result<Self, String> {
                    Self::value_variants()
                        .iter()
                        .find(|v| {
                            v.to_possible_value()
                                .expect("ValueEnum::value_variants contains only values with a corresponding ValueEnum::to_possible_value")
                                .matches(input, ignore_case)
                        })
                        .cloned()
                        .ok_or_else(|| format!("invalid variant: {input}"))
                }
                /// The canonical argument value.
                ///
                /// The value is `None` for skipped variants.
                fn to_possible_value(&self) -> Option<PossibleValue>;
            }

            impl<T: Parser> Parser for Box<T> 
            {
                fn parse() -> Self {
                    Box::new(<T as Parser>::parse())
                }

                fn try_parse() -> Result<Self, Error> {
                    <T as Parser>::try_parse().map(Box::new)
                }

                fn parse_from<I, It>(itr: I) -> Self where
                    I: IntoIterator<Item = It>,
                    It: Into<OsString> + Clone,
                {
                    Box::new(<T as Parser>::parse_from(itr))
                }

                fn try_parse_from<I, It>(itr: I) -> Result<Self, Error> where
                    I: IntoIterator<Item = It>,
                    It: Into<OsString> + Clone,
                {
                    <T as Parser>::try_parse_from(itr).map(Box::new)
                }
            }

            impl<T: CommandFactory> CommandFactory for Box<T> 
            {
                fn command() -> Command {
                    <T as CommandFactory>::command()
                }
                fn command_for_update() -> Command {
                    <T as CommandFactory>::command_for_update()
                }
            }

            impl<T: FromArgMatches> FromArgMatches for Box<T> 
            {
                fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error> {
                    <T as FromArgMatches>::from_arg_matches(matches).map(Box::new)
                }
                fn from_arg_matches_mut(matches: &mut ArgMatches) -> Result<Self, Error> {
                    <T as FromArgMatches>::from_arg_matches_mut(matches).map(Box::new)
                }
                fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error> {
                    <T as FromArgMatches>::update_from_arg_matches(self, matches)
                }
                fn update_from_arg_matches_mut(&mut self, matches: &mut ArgMatches) -> Result<(), Error> {
                    <T as FromArgMatches>::update_from_arg_matches_mut(self, matches)
                }
            }

            impl<T: Args> Args for Box<T> 
            {
                fn augment_args(cmd: Command) -> Command {
                    <T as Args>::augment_args(cmd)
                }
                fn augment_args_for_update(cmd: Command) -> Command {
                    <T as Args>::augment_args_for_update(cmd)
                }
            }

            impl<T: Subcommand> Subcommand for Box<T> 
            {
                fn augment_subcommands(cmd: Command) -> Command {
                    <T as Subcommand>::augment_subcommands(cmd)
                }
                fn augment_subcommands_for_update(cmd: Command) -> Command {
                    <T as Subcommand>::augment_subcommands_for_update(cmd)
                }
                fn has_subcommand(name: &str) -> bool {
                    <T as Subcommand>::has_subcommand(name)
                }
            }

            fn format_error<I: CommandFactory>(err: Error) -> Error 
            {
                let mut cmd = I::command();
                err.format(&mut cmd)
            }
        }

        pub mod builder
        {   
            //! Define [`Command`] line [arguments][`Arg`] 
            use ::
            {
                *,
            };
            
            pub mod action
            {
                use ::
                {
                    *,
                };
                /*
                #[cfg(debug_assertions)]
                use crate::util::AnyValueId;

                use crate::builder::ValueRange;
                */
                /// Behavior of arguments when they are encountered while parsing.
                #[non_exhaustive] #[derive(Clone, Debug)]                
                pub enum ArgAction
                {
                    /// When encountered, store the associated value(s) in [`ArgMatches`][crate::ArgMatches]
                    Set,
                    /// When encountered, store the associated value(s) in [`ArgMatches`][crate::ArgMatches]
                    Append,
                    /// When encountered, act as if `"true"` was encountered on the command-line.
                    SetTrue,
                    /// When encountered, act as if `"false"` was encountered on the command-line.
                    SetFalse,
                    /// When encountered, increment a `u8` counter starting from `0`.
                    Count,
                    /// When encountered, display [`Command::print_help`][super::Command::print_help]
                    Help,
                    /// When encountered, display [`Command::print_help`][super::Command::print_help]
                    HelpShort,
                    /// When encountered, display [`Command::print_long_help`][super::Command::print_long_help]
                    HelpLong,
                    /// When encountered, display [`Command::version`][super::Command::version]
                    Version,
                }

                impl ArgAction 
                {
                    /// Returns whether this action accepts values on the command-line
                    ///
                    /// [`default_values`][super::Arg::default_values] and [`env`][super::Arg::env] may still be
                    /// processed.
                    pub fn takes_values(&self) -> bool {
                        match self {
                            Self::Set => true,
                            Self::Append => true,
                            Self::SetTrue => false,
                            Self::SetFalse => false,
                            Self::Count => false,
                            Self::Help => false,
                            Self::HelpShort => false,
                            Self::HelpLong => false,
                            Self::Version => false,
                        }
                    }

                    #[cfg(debug_assertions)]
                    pub fn max_num_args(&self) -> ValueRange {
                        match self {
                            Self::Set => ValueRange::FULL,
                            Self::Append => ValueRange::FULL,
                            Self::SetTrue => ValueRange::OPTIONAL,
                            Self::SetFalse => ValueRange::OPTIONAL,
                            Self::Count => ValueRange::EMPTY,
                            Self::Help => ValueRange::EMPTY,
                            Self::HelpShort => ValueRange::EMPTY,
                            Self::HelpLong => ValueRange::EMPTY,
                            Self::Version => ValueRange::EMPTY,
                        }
                    }

                    pub fn default_num_args(&self) -> ValueRange {
                        match self {
                            Self::Set => ValueRange::SINGLE,
                            Self::Append => ValueRange::SINGLE,
                            Self::SetTrue => ValueRange::EMPTY,
                            Self::SetFalse => ValueRange::EMPTY,
                            Self::Count => ValueRange::EMPTY,
                            Self::Help => ValueRange::EMPTY,
                            Self::HelpShort => ValueRange::EMPTY,
                            Self::HelpLong => ValueRange::EMPTY,
                            Self::Version => ValueRange::EMPTY,
                        }
                    }

                    pub fn default_value(&self) -> Option<&'static std::ffi::OsStr> {
                        match self {
                            Self::Set => None,
                            Self::Append => None,
                            Self::SetTrue => Some(std::ffi::OsStr::new("false")),
                            Self::SetFalse => Some(std::ffi::OsStr::new("true")),
                            Self::Count => Some(std::ffi::OsStr::new("0")),
                            Self::Help => None,
                            Self::HelpShort => None,
                            Self::HelpLong => None,
                            Self::Version => None,
                        }
                    }

                    pub fn default_missing_value(&self) -> Option<&'static std::ffi::OsStr> {
                        match self {
                            Self::Set => None,
                            Self::Append => None,
                            Self::SetTrue => Some(std::ffi::OsStr::new("true")),
                            Self::SetFalse => Some(std::ffi::OsStr::new("false")),
                            Self::Count => None,
                            Self::Help => None,
                            Self::HelpShort => None,
                            Self::HelpLong => None,
                            Self::Version => None,
                        }
                    }

                    pub fn default_value_parser(&self) -> Option<super::ValueParser> {
                        match self {
                            Self::Set => None,
                            Self::Append => None,
                            Self::SetTrue => Some(super::ValueParser::bool()),
                            Self::SetFalse => Some(super::ValueParser::bool()),
                            Self::Count => Some(crate::value_parser!(u8).into()),
                            Self::Help => None,
                            Self::HelpShort => None,
                            Self::HelpLong => None,
                            Self::Version => None,
                        }
                    }

                    #[cfg(debug_assertions)]
                    pub fn value_type_id(&self) -> Option<AnyValueId> {
                        match self {
                            Self::Set => None,
                            Self::Append => None,
                            Self::SetTrue => None,
                            Self::SetFalse => None,
                            Self::Count => Some(AnyValueId::of::<CountType>()),
                            Self::Help => None,
                            Self::HelpShort => None,
                            Self::HelpLong => None,
                            Self::Version => None,
                        }
                    }
                }

                pub type CountType = u8;
            }

            pub mod app_settings
            {
                use ::
                {
                    *,
                };
                /*
                #[allow(unused)]
                use crate::Arg;
                #[allow(unused)]
                use crate::Command;
                */
                #[derive(Default, Copy, Clone, Debug, PartialEq, Eq)]
                pub struct AppFlags(u32);

                impl AppFlags
                {
                    pub fn set(&mut self, setting: AppSettings) 
                    {
                        self.0 |= setting.bit();
                    }

                    pub fn unset(&mut self, setting: AppSettings) 
                    {
                        self.0 &= !setting.bit();
                    }

                    pub fn is_set(&self, setting: AppSettings) -> bool 
                    {
                        self.0 & setting.bit() != 0
                    }

                    pub fn insert(&mut self, other: Self) 
                    {
                        self.0 |= other.0;
                    }
                }

                impl std::ops::BitOr for AppFlags
                {
                    type Output = Self;
                    fn bitor(mut self, rhs: Self) -> Self::Output
                    {
                        self.insert(rhs);
                        self
                    }
                }
                /// Application level settings, which affect how [`Command`] operates.
                #[repr(u8)] #[derive(Debug, PartialEq, Copy, Clone)]
                pub enum AppSettings
                {
                    IgnoreErrors,
                    AllowHyphenValues,
                    AllowNegativeNumbers,
                    AllArgsOverrideSelf,
                    AllowMissingPositional,
                    TrailingVarArg,
                    DontDelimitTrailingValues,
                    InferLongArgs,
                    InferSubcommands,
                    SubcommandRequired,
                    AllowExternalSubcommands,
                    Multicall,
                    SubcommandsNegateReqs,
                    ArgsNegateSubcommands,
                    SubcommandPrecedenceOverArg,
                    FlattenHelp,
                    ArgRequiredElseHelp,
                    NextLineHelp,
                    DisableColoredHelp,
                    DisableHelpFlag,
                    DisableHelpSubcommand,
                    DisableVersionFlag,
                    PropagateVersion,
                    Hidden,
                    HidePossibleValues,
                    HelpExpected,
                    NoBinaryName,
                    ColorAuto,
                    ColorAlways,
                    ColorNever,
                    Built,
                    BinNameBuilt,
                }

                impl AppSettings
                {
                    fn bit(self) -> u32
                    {
                        1 << (self as u8)
                    }
                }
            }

            pub mod arg
            {
                use ::
                {
                    *,
                };
                /*
                // Std
                #[cfg(feature = "env")]
                use std::env;
                #[cfg(feature = "env")]
                use std::ffi::OsString;
                use std::{
                    cmp::{Ord, Ordering},
                    fmt::{self, Display, Formatter},
                    str,
                };

                // Internal
                use super::{ArgFlags, ArgSettings};
                // crate                
                use crate::builder::ext::Extension;
                use crate::builder::ext::Extensions;
                use crate::builder::ArgPredicate;
                use crate::builder::IntoResettable;
                use crate::builder::OsStr;
                use crate::builder::PossibleValue;
                use crate::builder::Str;
                use crate::builder::StyledStr;
                use crate::builder::Styles;
                use crate::builder::ValueRange;
                use crate::util::AnyValueId;
                use crate::ArgAction;
                use crate::Id;
                use crate::ValueHint;
                use crate::INTERNAL_ERROR_MSG;
                */
                
                //pub mod arg_group
                pub mod group
                {
                    use ::
                    {
                        *,
                    };
                    // Internal
                    use crate::builder::IntoResettable;
                    use crate::util::Id;
                    /// Family of related [arguments].
                    #[derive(Default, Clone, Debug, PartialEq, Eq)]
                    pub struct ArgGroup {
                        pub id: Id,
                        pub args: Vec<Id>,
                        pub required: bool,
                        pub requires: Vec<Id>,
                        pub conflicts: Vec<Id>,
                        pub multiple: bool,
                    }
                    /// # Builder
                    impl ArgGroup {
                        /// Create a `ArgGroup` using a unique name.
                        pub fn new(id: impl Into<Id>) -> Self {
                            ArgGroup::default().id(id)
                        }

                        /// Sets the group name.
                        #[must_use]
                        pub fn id(mut self, id: impl Into<Id>) -> Self {
                            self.id = id.into();
                            self
                        }

                        /// Adds an [argument] to this group by name.
                        #[must_use]
                        pub fn arg(mut self, arg_id: impl IntoResettable<Id>) -> Self {
                            if let Some(arg_id) = arg_id.into_resettable().into_option() {
                                self.args.push(arg_id);
                            } else {
                                self.args.clear();
                            }
                            self
                        }

                        /// Adds multiple [arguments] to this group by name.
                        #[must_use]
                        pub fn args(mut self, ns: impl IntoIterator<Item = impl Into<Id>>) -> Self {
                            for n in ns {
                                self = self.arg(n);
                            }
                            self
                        }

                        /// Getters for all args. It will return a vector of `Id`.
                        pub fn get_args(&self) -> impl Iterator<Item = &Id> {
                            self.args.iter()
                        }

                        /// Allows more than one of the [`Arg`]s in this group to be used. (Default: `false`).
                        #[inline]
                        #[must_use]
                        pub fn multiple(mut self, yes: bool) -> Self {
                            self.multiple = yes;
                            self
                        }

                        /// Return true if the group allows more than one of the arguments in this group to be used. (Default: `false`)
                        pub fn is_multiple(&mut self) -> bool {
                            self.multiple
                        }

                        /// Require an argument from the group to be present when parsing.
                        #[inline]
                        #[must_use]
                        pub fn required(mut self, yes: bool) -> Self {
                            self.required = yes;
                            self
                        }

                        /// Specify an argument or group that must be present when this group is.
                        #[must_use]
                        pub fn requires(mut self, id: impl IntoResettable<Id>) -> Self {
                            if let Some(id) = id.into_resettable().into_option() {
                                self.requires.push(id);
                            } else {
                                self.requires.clear();
                            }
                            self
                        }

                        /// Specify arguments or groups that must be present when this group is.
                        #[must_use]
                        pub fn requires_all(mut self, ns: impl IntoIterator<Item = impl Into<Id>>) -> Self {
                            for n in ns {
                                self = self.requires(n);
                            }
                            self
                        }

                        /// Specify an argument or group that must **not** be present when this group is.
                        #[must_use]
                        pub fn conflicts_with(mut self, id: impl IntoResettable<Id>) -> Self {
                            if let Some(id) = id.into_resettable().into_option() {
                                self.conflicts.push(id);
                            } else {
                                self.conflicts.clear();
                            }
                            self
                        }

                        /// Specify arguments or groups that must **not** be present when this group is.
                        #[must_use]
                        pub fn conflicts_with_all(mut self, ns: impl IntoIterator<Item = impl Into<Id>>) -> Self {
                            for n in ns {
                                self = self.conflicts_with(n);
                            }
                            self
                        }
                    }
                    /// # Reflection
                    impl ArgGroup {
                        /// Get the name of the group
                        #[inline]
                        pub fn get_id(&self) -> &Id {
                            &self.id
                        }

                        /// Reports whether [`ArgGroup::required`] is set
                        #[inline]
                        pub fn is_required_set(&self) -> bool {
                            self.required
                        }
                    }

                    impl From<&'_ ArgGroup> for ArgGroup {
                        fn from(g: &ArgGroup) -> Self {
                            g.clone()
                        }
                    }
                }
                //pub mod arg_predicate
                pub mod predicate
                {
                    use ::
                    {
                        *,
                    };
                    use crate::builder::OsStr;

                    /// Operations to perform on argument values
                    ///
                    /// These do not apply to [`ValueSource::DefaultValue`][crate::parser::ValueSource::DefaultValue]
                    #[derive(Clone, Debug, PartialEq, Eq)]
                    #[cfg_attr(feature = "unstable-v5", non_exhaustive)]
                    pub enum ArgPredicate {
                        /// Is the argument present?
                        IsPresent,
                        /// Does the argument match the specified value?
                        Equals(OsStr),
                    }

                    impl<S: Into<OsStr>> From<S> for ArgPredicate {
                        fn from(other: S) -> Self {
                            Self::Equals(other.into())
                        }
                    }
                }
                //pub mod arg_settings
                pub mod settings
                {
                    use ::
                    {
                        *,
                    };
                    #[allow(unused)]
                    use crate::Arg;

                    #[derive(Default, Copy, Clone, Debug, PartialEq, Eq)]
                    pub struct ArgFlags(u32);

                    impl ArgFlags {
                        pub fn set(&mut self, setting: ArgSettings) {
                            self.0 |= setting.bit();
                        }

                        pub fn unset(&mut self, setting: ArgSettings) {
                            self.0 &= !setting.bit();
                        }

                        pub fn is_set(&self, setting: ArgSettings) -> bool {
                            self.0 & setting.bit() != 0
                        }

                        pub fn insert(&mut self, other: Self) {
                            self.0 |= other.0;
                        }
                    }

                    impl std::ops::BitOr for ArgFlags {
                        type Output = Self;

                        fn bitor(mut self, rhs: Self) -> Self::Output {
                            self.insert(rhs);
                            self
                        }
                    }
                    /// Various settings that apply to arguments and may be set, unset, and checked via getter/setter
                    /// methods [`Arg::setting`], [`Arg::unset_setting`], and [`Arg::is_set`]. This is what the
                    /// [`Arg`] methods which accept a `bool` use internally.
                    ///
                    /// [`Arg`]: crate::Arg
                    /// [`Arg::setting`]: crate::Arg::setting()
                    /// [`Arg::unset_setting`]: crate::Arg::unset_setting()
                    /// [`Arg::is_set`]: crate::Arg::is_set()
                    #[derive(Debug, PartialEq, Copy, Clone)]
                    #[repr(u8)]
                    pub enum ArgSettings {
                        Required,
                        Global,
                        Hidden,
                        NextLineHelp,
                        HidePossibleValues,
                        AllowHyphenValues,
                        AllowNegativeNumbers,
                        RequireEquals,
                        Last,
                        TrailingVarArg,
                        HideDefaultValue,
                        IgnoreCase,
                        #[cfg(feature = "env")]
                        HideEnv,
                        #[cfg(feature = "env")]
                        HideEnvValues,
                        HiddenShortHelp,
                        HiddenLongHelp,
                        Exclusive,
                    }

                    impl ArgSettings {
                        fn bit(self) -> u32 {
                            1 << (self as u8)
                        }
                    }
                }
                /// The abstract representation of a command line argument.
                #[derive(Default, Clone)]
                pub struct Arg 
                {
                    pub id: Id,
                    pub help: Option<StyledStr>,
                    pub long_help: Option<StyledStr>,
                    pub action: Option<ArgAction>,
                    pub value_parser: Option<super::ValueParser>,
                    pub blacklist: Vec<Id>,
                    pub settings: ArgFlags,
                    pub overrides: Vec<Id>,
                    pub groups: Vec<Id>,
                    pub requires: Vec<(ArgPredicate, Id)>,
                    pub r_ifs: Vec<(Id, OsStr)>,
                    pub r_ifs_all: Vec<(Id, OsStr)>,
                    pub r_unless: Vec<Id>,
                    pub r_unless_all: Vec<Id>,
                    pub short: Option<char>,
                    pub long: Option<Str>,
                    pub aliases: Vec<(Str, bool)>, // (name, visible)
                    pub short_aliases: Vec<(char, bool)>, // (name, visible)
                    pub disp_ord: Option<usize>,
                    pub val_names: Vec<Str>,
                    pub num_vals: Option<ValueRange>,
                    pub val_delim: Option<char>,
                    pub default_vals: Vec<OsStr>,
                    pub default_vals_ifs: Vec<(Id, ArgPredicate, Option<OsStr>)>,
                    pub default_missing_vals: Vec<OsStr>,
                    #[cfg(feature = "env")]
                    pub env: Option<(OsStr, Option<OsString>)>,
                    pub terminator: Option<Str>,
                    pub index: Option<usize>,
                    pub help_heading: Option<Option<Str>>,
                    pub ext: Extensions,
                }
                /// # Basic API
                impl Arg
                {
                    /// Create a new [`Arg`] with a unique name.
                    pub fn new(id: impl Into<Id>) -> Self {
                        Arg::default().id(id)
                    }
                    /// Set the identifier used for referencing this argument in the clap API.
                    #[must_use] pub fn id(mut self, id: impl Into<Id>) -> Self {
                        self.id = id.into();
                        self
                    }
                    /// Sets the short version of the argument without the preceding `-`.
                    #[inline] #[must_use] pub fn short(mut self, s: impl IntoResettable<char>) -> Self {
                        if let Some(s) = s.into_resettable().into_option() {
                            debug_assert!(s != '-', "short option name cannot be `-`");
                            self.short = Some(s);
                        } else {
                            self.short = None;
                        }
                        self
                    }
                    /// Sets the long version of the argument without the preceding `--`.
                    #[inline] #[must_use] pub fn long(mut self, l: impl IntoResettable<Str>) -> Self {
                        self.long = l.into_resettable().into_option();
                        self
                    }
                    /// Add an alias, which functions as a hidden long flag.
                    #[must_use] pub fn alias(mut self, name: impl IntoResettable<Str>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            self.aliases.push((name, false));
                        } else {
                            self.aliases.clear();
                        }
                        self
                    }
                    /// Add an alias, which functions as a hidden short flag.
                    #[must_use] pub fn short_alias(mut self, name: impl IntoResettable<char>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            debug_assert!(name != '-', "short alias name cannot be `-`");
                            self.short_aliases.push((name, false));
                        } else {
                            self.short_aliases.clear();
                        }
                        self
                    }
                    /// Add aliases, which function as hidden long flags.
                    #[must_use] pub fn aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
                        self.aliases
                            .extend(names.into_iter().map(|x| (x.into(), false)));
                        self
                    }
                    /// Add aliases, which functions as a hidden short flag.
                    #[must_use] pub fn short_aliases(mut self, names: impl IntoIterator<Item = char>) -> Self {
                        for s in names {
                            debug_assert!(s != '-', "short alias name cannot be `-`");
                            self.short_aliases.push((s, false));
                        }
                        self
                    }
                    /// Add an alias, which functions as a visible long flag.
                    #[must_use] pub fn visible_alias(mut self, name: impl IntoResettable<Str>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            self.aliases.push((name, true));
                        } else {
                            self.aliases.clear();
                        }
                        self
                    }
                    /// Add an alias, which functions as a visible short flag.
                    #[must_use] pub fn visible_short_alias(mut self, name: impl IntoResettable<char>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            debug_assert!(name != '-', "short alias name cannot be `-`");
                            self.short_aliases.push((name, true));
                        } else {
                            self.short_aliases.clear();
                        }
                        self
                    }
                    /// Add aliases, which function as visible long flags.
                    #[must_use] pub fn visible_aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
                        self.aliases
                            .extend(names.into_iter().map(|n| (n.into(), true)));
                        self
                    }
                    /// Add aliases, which function as visible short flags.
                    #[must_use] pub fn visible_short_aliases(mut self, names: impl IntoIterator<Item = char>) -> Self {
                        for n in names {
                            debug_assert!(n != '-', "short alias name cannot be `-`");
                            self.short_aliases.push((n, true));
                        }
                        self
                    }
                    /// Specifies the index of a positional argument **starting at** 1.
                    #[inline] #[must_use] pub fn index(mut self, idx: impl IntoResettable<usize>) -> Self {
                        self.index = idx.into_resettable().into_option();
                        self
                    }
                    /// This is a "var arg" and everything that follows should be captured by it, as if the user had used a `--`.
                    pub fn trailing_var_arg(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::TrailingVarArg)
                        } else {
                            self.unset_setting(ArgSettings::TrailingVarArg)
                        }
                    }
                    /// This arg is the last, or final, positional argument (i.e. has the highest
                    /// index) and is *only* able to be accessed via the `--` syntax (i.e. `$ prog args --
                    /// last_arg`).
                    #[inline] #[must_use] pub fn last(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::Last)
                        } else {
                            self.unset_setting(ArgSettings::Last)
                        }
                    }
                    /// Specifies that the argument must be present.
                    #[inline] #[must_use] pub fn required(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::Required)
                        } else {
                            self.unset_setting(ArgSettings::Required)
                        }
                    }
                    /// Sets an argument that is required when this one is present.
                    #[must_use] pub fn requires(mut self, arg_id: impl IntoResettable<Id>) -> Self {
                        if let Some(arg_id) = arg_id.into_resettable().into_option() {
                            self.requires.push((ArgPredicate::IsPresent, arg_id));
                        } else {
                            self.requires.clear();
                        }
                        self
                    }
                    /// This argument must be passed alone; it conflicts with all other arguments.
                    #[inline] #[must_use] pub fn exclusive(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::Exclusive)
                        } else {
                            self.unset_setting(ArgSettings::Exclusive)
                        }
                    }
                    /// Specifies that an argument can be matched to all child [`Subcommand`]s.
                    #[inline] #[must_use] pub fn global(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::Global)
                        } else {
                            self.unset_setting(ArgSettings::Global)
                        }
                    }

                    #[inline] pub fn is_set(&self, s: ArgSettings) -> bool {
                        self.settings.is_set(s)
                    }

                    #[inline] #[must_use] pub fn setting(mut self, setting: ArgSettings) -> Self {
                        self.settings.set(setting);
                        self
                    }

                    #[inline] #[must_use] pub fn unset_setting(mut self, setting: ArgSettings) -> Self {
                        self.settings.unset(setting);
                        self
                    }
                    /// Extend [`Arg`] with [`ArgExt`] data
                    pub fn add<T: ArgExt + Extension>(mut self, tagged: T) -> Self {
                        self.ext.set(tagged);
                        self
                    }
                }
                /// # Value Handling
                impl Arg 
                {
                    /// Specify how to react to an argument when parsing it.
                    #[inline] #[must_use] pub fn action(mut self, action: impl IntoResettable<ArgAction>) -> Self {
                        self.action = action.into_resettable().into_option();
                        self
                    }
                    /// Specify the typed behavior of the argument.
                    pub fn value_parser(mut self, parser: impl IntoResettable<super::ValueParser>) -> Self {
                        self.value_parser = parser.into_resettable().into_option();
                        self
                    }
                    /// Specifies the number of arguments parsed per occurrence.
                    #[inline] #[must_use] pub fn num_args(mut self, qty: impl IntoResettable<ValueRange>) -> Self {
                        self.num_vals = qty.into_resettable().into_option();
                        self
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::num_args`")
                    )]
                    pub fn number_of_values(self, qty: usize) -> Self {
                        self.num_args(qty)
                    }
                    /// Placeholder for the argument's value in the help message / usage.
                    #[inline] #[must_use] pub fn value_name(mut self, name: impl IntoResettable<Str>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            self.value_names([name])
                        } else {
                            self.val_names.clear();
                            self
                        }
                    }
                    /// Placeholders for the argument's values in the help message / usage.
                    #[must_use] pub fn value_names(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
                        self.val_names = names.into_iter().map(|s| s.into()).collect();
                        self
                    }
                    /// Provide the shell a hint about how to complete this argument.
                    #[must_use] pub fn value_hint(mut self, value_hint: impl IntoResettable<ValueHint>) -> Self {
                        // HACK: we should use `Self::add` and `Self::remove` to type-check that `ArgExt` is used
                        match value_hint.into_resettable().into_option() {
                            Some(value_hint) => {
                                self.ext.set(value_hint);
                            }
                            None => {
                                self.ext.remove::<ValueHint>();
                            }
                        }
                        self
                    }
                    /// Match values against [`PossibleValuesParser`][crate::builder::PossibleValuesParser] without matching case.
                    #[inline] #[must_use] pub fn ignore_case(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::IgnoreCase)
                        } else {
                            self.unset_setting(ArgSettings::IgnoreCase)
                        }
                    }
                    /// Allows values which start with a leading hyphen (`-`)
                    #[inline] #[must_use] pub fn allow_hyphen_values(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::AllowHyphenValues)
                        } else {
                            self.unset_setting(ArgSettings::AllowHyphenValues)
                        }
                    }
                    /// Allows negative numbers to pass as values.
                    #[inline] pub fn allow_negative_numbers(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::AllowNegativeNumbers)
                        } else {
                            self.unset_setting(ArgSettings::AllowNegativeNumbers)
                        }
                    }
                    /// Requires that options use the `--option=val` syntax.
                    #[inline] #[must_use] pub fn require_equals(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::RequireEquals)
                        } else {
                            self.unset_setting(ArgSettings::RequireEquals)
                        }
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::value_delimiter`")
                    )]
                    pub fn use_value_delimiter(mut self, yes: bool) -> Self {
                        if yes {
                            self.val_delim.get_or_insert(',');
                        } else {
                            self.val_delim = None;
                        }
                        self
                    }
                    /// Allow grouping of multiple values via a delimiter.
                    #[inline] #[must_use] pub fn value_delimiter(mut self, d: impl IntoResettable<char>) -> Self {
                        self.val_delim = d.into_resettable().into_option();
                        self
                    }
                    /// Sentinel to **stop** parsing multiple values of a given argument.
                    #[inline] #[must_use] pub fn value_terminator(mut self, term: impl IntoResettable<Str>) -> Self {
                        self.terminator = term.into_resettable().into_option();
                        self
                    }
                    /// Consume all following arguments.
                    #[inline] #[must_use] pub fn raw(mut self, yes: bool) -> Self {
                        if yes {
                            self.num_vals.get_or_insert_with(|| (1..).into());
                        }
                        self.allow_hyphen_values(yes).last(yes)
                    }
                    /// Value for the argument when not present.
                    #[inline] #[must_use] pub fn default_value(mut self, val: impl IntoResettable<OsStr>) -> Self {
                        if let Some(val) = val.into_resettable().into_option() {
                            self.default_values([val])
                        } else {
                            self.default_vals.clear();
                            self
                        }
                    }

                    #[inline]
                    #[must_use]
                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::default_value`")
                    )]
                    pub fn default_value_os(self, val: impl Into<OsStr>) -> Self {
                        self.default_values([val])
                    }
                    /// Value for the argument when not present.
                    #[inline] #[must_use] pub fn default_values(mut self, vals: impl IntoIterator<Item = impl Into<OsStr>>) -> Self {
                        self.default_vals = vals.into_iter().map(|s| s.into()).collect();
                        self
                    }

                    #[inline]
                    #[must_use]
                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::default_values`")
                    )]
                    pub fn default_values_os(self, vals: impl IntoIterator<Item = impl Into<OsStr>>) -> Self {
                        self.default_values(vals)
                    }
                    /// Value for the argument when the flag is present but no value is specified.
                    #[inline] #[must_use] pub fn default_missing_value(mut self, val: impl IntoResettable<OsStr>) -> Self {
                        if let Some(val) = val.into_resettable().into_option() {
                            self.default_missing_values_os([val])
                        } else {
                            self.default_missing_vals.clear();
                            self
                        }
                    }
                    /// Value for the argument when the flag is present but no value is specified.
                    #[inline] #[must_use] pub fn default_missing_value_os(self, val: impl Into<OsStr>) -> Self {
                        self.default_missing_values_os([val])
                    }
                    /// Value for the argument when the flag is present but no value is specified.
                    #[inline] #[must_use] pub fn default_missing_values(self, vals: impl IntoIterator<Item = impl Into<OsStr>>) -> Self {
                        self.default_missing_values_os(vals)
                    }
                    /// Value for the argument when the flag is present but no value is specified.
                    #[inline] #[must_use] pub fn default_missing_values_os(
                        mut self,
                        vals: impl IntoIterator<Item = impl Into<OsStr>>,
                    ) -> Self {
                        self.default_missing_vals = vals.into_iter().map(|s| s.into()).collect();
                        self
                    }
                    /// Read from `name` environment variable when argument is not present.
                    #[cfg(feature = "env")]
                    #[inline] #[must_use] pub fn env(mut self, name: impl IntoResettable<OsStr>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            let value = env::var_os(&name);
                            self.env = Some((name, value));
                        } else {
                            self.env = None;
                        }
                        self
                    }

                    #[cfg(feature = "env")]
                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::env`")
                    )]
                    pub fn env_os(self, name: impl Into<OsStr>) -> Self {
                        self.env(name)
                    }
                }
                /// # Help
                impl Arg 
                {
                    /// Sets the description of the argument for short help (`-h`).
                    #[inline] #[must_use] pub fn help(mut self, h: impl IntoResettable<StyledStr>) -> Self {
                        self.help = h.into_resettable().into_option();
                        self
                    }
                    /// Sets the description of the argument for long help (`--help`).
                    #[inline] #[must_use] pub fn long_help(mut self, h: impl IntoResettable<StyledStr>) -> Self {
                        self.long_help = h.into_resettable().into_option();
                        self
                    }
                    /// Allows custom ordering of args within the help message.
                    #[inline] #[must_use] pub fn display_order(mut self, ord: impl IntoResettable<usize>) -> Self {
                        self.disp_ord = ord.into_resettable().into_option();
                        self
                    }
                    /// Override the [current] help section.
                    ///
                    /// [current]: crate::Command::next_help_heading
                    #[inline] #[must_use] pub fn help_heading(mut self, heading: impl IntoResettable<Str>) -> Self {
                        self.help_heading = Some(heading.into_resettable().into_option());
                        self
                    }
                    /// Render the [help][Arg::help] on the line after the argument.
                    #[inline] #[must_use] pub fn next_line_help(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::NextLineHelp)
                        } else {
                            self.unset_setting(ArgSettings::NextLineHelp)
                        }
                    }
                    /// Do not display the argument in help message.
                    #[inline] #[must_use] pub fn hide(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::Hidden)
                        } else {
                            self.unset_setting(ArgSettings::Hidden)
                        }
                    }
                    /// Do not display the [possible values][crate::builder::ValueParser::possible_values] in the help message.
                    #[inline] #[must_use] pub fn hide_possible_values(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::HidePossibleValues)
                        } else {
                            self.unset_setting(ArgSettings::HidePossibleValues)
                        }
                    }
                    /// Do not display the default value of the argument in the help message.
                    #[inline] #[must_use] pub fn hide_default_value(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::HideDefaultValue)
                        } else {
                            self.unset_setting(ArgSettings::HideDefaultValue)
                        }
                    }
                    /// Do not display in help the environment variable name.
                    #[cfg(feature = "env")]
                    #[inline] #[must_use] pub fn hide_env(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::HideEnv)
                        } else {
                            self.unset_setting(ArgSettings::HideEnv)
                        }
                    }
                    /// Do not display in help any values inside the associated ENV variables for the argument.
                    #[cfg(feature = "env")]
                    #[inline] #[must_use] pub fn hide_env_values(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::HideEnvValues)
                        } else {
                            self.unset_setting(ArgSettings::HideEnvValues)
                        }
                    }
                    /// Hides an argument from short help (`-h`).
                    #[inline] #[must_use] pub fn hide_short_help(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::HiddenShortHelp)
                        } else {
                            self.unset_setting(ArgSettings::HiddenShortHelp)
                        }
                    }
                    /// Hides an argument from long help (`--help`).
                    #[inline] #[must_use] pub fn hide_long_help(self, yes: bool) -> Self {
                        if yes {
                            self.setting(ArgSettings::HiddenLongHelp)
                        } else {
                            self.unset_setting(ArgSettings::HiddenLongHelp)
                        }
                    }
                }
                /// # Advanced Argument Relations
                impl Arg 
                {
                    /// The name of the [`ArgGroup`] the argument belongs to.
                    #[must_use] pub fn group(mut self, group_id: impl IntoResettable<Id>) -> Self {
                        if let Some(group_id) = group_id.into_resettable().into_option() {
                            self.groups.push(group_id);
                        } else {
                            self.groups.clear();
                        }
                        self
                    }
                    /// The names of [`ArgGroup`]'s the argument belongs to.
                    #[must_use] pub fn groups(mut self, group_ids: impl IntoIterator<Item = impl Into<Id>>) -> Self {
                        self.groups.extend(group_ids.into_iter().map(Into::into));
                        self
                    }
                    /// Specifies the value of the argument if `arg` has been used at runtime.
                    #[must_use] pub fn default_value_if(
                        mut self,
                        arg_id: impl Into<Id>,
                        predicate: impl Into<ArgPredicate>,
                        default: impl IntoResettable<OsStr>,
                    ) -> Self {
                        self.default_vals_ifs.push((
                            arg_id.into(),
                            predicate.into(),
                            default.into_resettable().into_option(),
                        ));
                        self
                    }

                    #[must_use]
                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::default_value_if`")
                    )]
                    pub fn default_value_if_os(
                        self,
                        arg_id: impl Into<Id>,
                        predicate: impl Into<ArgPredicate>,
                        default: impl IntoResettable<OsStr>,
                    ) -> Self {
                        self.default_value_if(arg_id, predicate, default)
                    }
                    /// Specifies multiple values and conditions in the same manner as [`Arg::default_value_if`].
                    #[must_use] pub fn default_value_ifs(
                        mut self,
                        ifs: impl IntoIterator<
                            Item = (
                                impl Into<Id>,
                                impl Into<ArgPredicate>,
                                impl IntoResettable<OsStr>,
                            ),
                        >,
                    ) -> Self {
                        for (arg, predicate, default) in ifs {
                            self = self.default_value_if(arg, predicate, default);
                        }
                        self
                    }

                    #[must_use]
                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::default_value_ifs`")
                    )]
                    pub fn default_value_ifs_os(
                        self,
                        ifs: impl IntoIterator<
                            Item = (
                                impl Into<Id>,
                                impl Into<ArgPredicate>,
                                impl IntoResettable<OsStr>,
                            ),
                        >,
                    ) -> Self {
                        self.default_value_ifs(ifs)
                    }
                    /// Set this arg as [required] as long as the specified argument is not present at runtime.
                    #[must_use] pub fn required_unless_present(mut self, arg_id: impl IntoResettable<Id>) -> Self {
                        if let Some(arg_id) = arg_id.into_resettable().into_option() {
                            self.r_unless.push(arg_id);
                        } else {
                            self.r_unless.clear();
                        }
                        self
                    }
                    /// Sets this arg as [required] unless *all* of the specified arguments are present at runtime.
                    #[must_use] pub fn required_unless_present_all(
                        mut self,
                        names: impl IntoIterator<Item = impl Into<Id>>,
                    ) -> Self {
                        self.r_unless_all.extend(names.into_iter().map(Into::into));
                        self
                    }
                    /// Sets this arg as [required] unless *any* of the specified arguments are present at runtime.
                    #[must_use] pub fn required_unless_present_any(
                        mut self,
                        names: impl IntoIterator<Item = impl Into<Id>>,
                    ) -> Self {
                        self.r_unless.extend(names.into_iter().map(Into::into));
                        self
                    }
                    /// This argument is [required] only if the specified `arg` is present at runtime and its value
                    #[must_use] pub fn required_if_eq(mut self, arg_id: impl Into<Id>, val: impl Into<OsStr>) -> Self {
                        self.r_ifs.push((arg_id.into(), val.into()));
                        self
                    }
                    /// Specify this argument is [required] based on multiple conditions.
                    #[must_use] pub fn required_if_eq_any(
                        mut self,
                        ifs: impl IntoIterator<Item = (impl Into<Id>, impl Into<OsStr>)>,
                    ) -> Self {
                        self.r_ifs
                            .extend(ifs.into_iter().map(|(id, val)| (id.into(), val.into())));
                        self
                    }
                    /// Specify this argument is [required] based on multiple conditions.
                    #[must_use] pub fn required_if_eq_all(
                        mut self,
                        ifs: impl IntoIterator<Item = (impl Into<Id>, impl Into<OsStr>)>,
                    ) -> Self {
                        self.r_ifs_all
                            .extend(ifs.into_iter().map(|(id, val)| (id.into(), val.into())));
                        self
                    }
                    /// Require another argument if this arg matches the [`ArgPredicate`]
                    #[must_use] pub fn requires_if(mut self, val: impl Into<ArgPredicate>, arg_id: impl Into<Id>) -> Self {
                        self.requires.push((val.into(), arg_id.into()));
                        self
                    }
                    /// Allows multiple conditional requirements.
                    #[must_use] pub fn requires_ifs(
                        mut self,
                        ifs: impl IntoIterator<Item = (impl Into<ArgPredicate>, impl Into<Id>)>,
                    ) -> Self {
                        self.requires
                            .extend(ifs.into_iter().map(|(val, arg)| (val.into(), arg.into())));
                        self
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::requires_ifs`")
                    )]
                    pub fn requires_all(self, ids: impl IntoIterator<Item = impl Into<Id>>) -> Self {
                        self.requires_ifs(ids.into_iter().map(|id| (ArgPredicate::IsPresent, id)))
                    }
                    /// This argument is mutually exclusive with the specified argument.
                    #[must_use] pub fn conflicts_with(mut self, arg_id: impl IntoResettable<Id>) -> Self {
                        if let Some(arg_id) = arg_id.into_resettable().into_option() {
                            self.blacklist.push(arg_id);
                        } else {
                            self.blacklist.clear();
                        }
                        self
                    }
                    /// This argument is mutually exclusive with the specified arguments.
                    #[must_use] pub fn conflicts_with_all(mut self, names: impl IntoIterator<Item = impl Into<Id>>) -> Self {
                        self.blacklist.extend(names.into_iter().map(Into::into));
                        self
                    }
                    /// Sets an overridable argument.
                    #[must_use] pub fn overrides_with(mut self, arg_id: impl IntoResettable<Id>) -> Self {
                        if let Some(arg_id) = arg_id.into_resettable().into_option() {
                            self.overrides.push(arg_id);
                        } else {
                            self.overrides.clear();
                        }
                        self
                    }
                    /// Sets multiple mutually overridable arguments by name.
                    #[must_use] pub fn overrides_with_all(mut self, names: impl IntoIterator<Item = impl Into<Id>>) -> Self {
                        self.overrides.extend(names.into_iter().map(Into::into));
                        self
                    }
                }
                /// # Reflection
                impl Arg 
                {
                    /// Get the name of the argument
                    #[inline] pub fn get_id(&self) -> &Id {
                        &self.id
                    }
                    /// Get the help specified for this argument, if any
                    #[inline] pub fn get_help(&self) -> Option<&StyledStr> {
                        self.help.as_ref()
                    }
                    /// Get the long help specified for this argument, if any.
                    #[inline] pub fn get_long_help(&self) -> Option<&StyledStr> {
                        self.long_help.as_ref()
                    }
                    /// Get the placement within help
                    #[inline] pub fn get_display_order(&self) -> usize {
                        self.disp_ord.unwrap_or(999)
                    }
                    /// Get the help heading specified for this argument, if any
                    #[inline] pub fn get_help_heading(&self) -> Option<&str> {
                        self.help_heading
                            .as_ref()
                            .map(|s| s.as_deref())
                            .unwrap_or_default()
                    }
                    /// Get the short option name for this argument, if any
                    #[inline] pub fn get_short(&self) -> Option<char> {
                        self.short
                    }
                    /// Get visible short aliases for this argument, if any
                    #[inline] pub fn get_visible_short_aliases(&self) -> Option<Vec<char>> {
                        if self.short_aliases.is_empty() {
                            None
                        } else {
                            Some(
                                self.short_aliases
                                    .iter()
                                    .filter_map(|(c, v)| if *v { Some(c) } else { None })
                                    .copied()
                                    .collect(),
                            )
                        }
                    }
                    /// Get *all* short aliases for this argument, if any, both visible and hidden.
                    #[inline] pub fn get_all_short_aliases(&self) -> Option<Vec<char>> {
                        if self.short_aliases.is_empty() {
                            None
                        } else {
                            Some(self.short_aliases.iter().map(|(s, _)| s).copied().collect())
                        }
                    }
                    /// Get the short option name and its visible aliases, if any
                    #[inline] pub fn get_short_and_visible_aliases(&self) -> Option<Vec<char>> {
                        let mut shorts = match self.short {
                            Some(short) => vec![short],
                            None => return None,
                        };
                        if let Some(aliases) = self.get_visible_short_aliases() {
                            shorts.extend(aliases);
                        }
                        Some(shorts)
                    }
                    /// Get the long option name for this argument, if any
                    #[inline] pub fn get_long(&self) -> Option<&str> {
                        self.long.as_deref()
                    }
                    /// Get visible aliases for this argument, if any
                    #[inline] pub fn get_visible_aliases(&self) -> Option<Vec<&str>> {
                        if self.aliases.is_empty() {
                            None
                        } else {
                            Some(
                                self.aliases
                                    .iter()
                                    .filter_map(|(s, v)| if *v { Some(s.as_str()) } else { None })
                                    .collect(),
                            )
                        }
                    }
                    /// Get *all* aliases for this argument, if any, both visible and hidden.
                    #[inline] pub fn get_all_aliases(&self) -> Option<Vec<&str>> {
                        if self.aliases.is_empty() {
                            None
                        } else {
                            Some(self.aliases.iter().map(|(s, _)| s.as_str()).collect())
                        }
                    }
                    /// Get the long option name and its visible aliases, if any
                    #[inline] pub fn get_long_and_visible_aliases(&self) -> Option<Vec<&str>> {
                        let mut longs = match self.get_long() {
                            Some(long) => vec![long],
                            None => return None,
                        };
                        if let Some(aliases) = self.get_visible_aliases() {
                            longs.extend(aliases);
                        }
                        Some(longs)
                    }
                    /// Get hidden aliases for this argument, if any
                    #[inline] pub fn get_aliases(&self) -> Option<Vec<&str>> {
                        if self.aliases.is_empty() {
                            None
                        } else {
                            Some(
                                self.aliases
                                    .iter()
                                    .filter_map(|(s, v)| if !*v { Some(s.as_str()) } else { None })
                                    .collect(),
                            )
                        }
                    }
                    /// Get the names of possible values for this argument. Only useful for user
                    /// facing applications, such as building help messages or man files
                    pub fn get_possible_values(&self) -> Vec<PossibleValue> {
                        if !self.is_takes_value_set() {
                            vec![]
                        } else {
                            self.get_value_parser()
                                .possible_values()
                                .map(|pvs| pvs.collect())
                                .unwrap_or_default()
                        }
                    }
                    /// Get the names of values for this argument.
                    #[inline] pub fn get_value_names(&self) -> Option<&[Str]> {
                        if self.val_names.is_empty() {
                            None
                        } else {
                            Some(&self.val_names)
                        }
                    }
                    /// Get the number of values for this argument.
                    #[inline] pub fn get_num_args(&self) -> Option<ValueRange> {
                        self.num_vals
                    }

                    #[inline] pub fn get_min_vals(&self) -> usize {
                        self.get_num_args().expect(INTERNAL_ERROR_MSG).min_values()
                    }
                    /// Get the delimiter between multiple values
                    #[inline] pub fn get_value_delimiter(&self) -> Option<char> {
                        self.val_delim
                    }
                    /// Get the value terminator for this argument. The `value_terminator` is a value
                    /// that terminates parsing of multi-valued arguments.
                    #[inline] pub fn get_value_terminator(&self) -> Option<&Str> {
                        self.terminator.as_ref()
                    }
                    /// Get the index of this argument, if any
                    #[inline] pub fn get_index(&self) -> Option<usize> {
                        self.index
                    }
                    /// Get the value hint of this argument
                    pub fn get_value_hint(&self) -> ValueHint {
                        // HACK: we should use `Self::add` and `Self::remove` to type-check that `ArgExt` is used
                        self.ext.get::<ValueHint>().copied().unwrap_or_else(|| {
                            if self.is_takes_value_set() {
                                let type_id = self.get_value_parser().type_id();
                                if type_id == AnyValueId::of::<std::path::PathBuf>() {
                                    ValueHint::AnyPath
                                } else {
                                    ValueHint::default()
                                }
                            } else {
                                ValueHint::default()
                            }
                        })
                    }
                    /// Get the environment variable name specified for this argument, if any.
                    #[cfg(feature = "env")]
                    pub fn get_env(&self) -> Option<&std::ffi::OsStr> {
                        self.env.as_ref().map(|x| x.0.as_os_str())
                    }
                    /// Get the default values specified for this argument, if any.
                    pub fn get_default_values(&self) -> &[OsStr] {
                        &self.default_vals
                    }
                    /// Checks whether this argument is a positional or not.
                    pub fn is_positional(&self) -> bool {
                        self.get_long().is_none() && self.get_short().is_none()
                    }
                    /// Reports whether [`Arg::required`] is set
                    pub fn is_required_set(&self) -> bool {
                        self.is_set(ArgSettings::Required)
                    }

                    pub fn is_multiple_values_set(&self) -> bool {
                        self.get_num_args().unwrap_or_default().is_multiple()
                    }

                    pub fn is_takes_value_set(&self) -> bool {
                        self.get_num_args()
                            .unwrap_or_else(|| 1.into())
                            .takes_values()
                    }
                    /// Report whether [`Arg::allow_hyphen_values`] is set
                    pub fn is_allow_hyphen_values_set(&self) -> bool {
                        self.is_set(ArgSettings::AllowHyphenValues)
                    }
                    /// Report whether [`Arg::allow_negative_numbers`] is set
                    pub fn is_allow_negative_numbers_set(&self) -> bool {
                        self.is_set(ArgSettings::AllowNegativeNumbers)
                    }
                    /// Behavior when parsing the argument
                    pub fn get_action(&self) -> &ArgAction {
                        const DEFAULT: ArgAction = ArgAction::Set;
                        self.action.as_ref().unwrap_or(&DEFAULT)
                    }
                    /// Configured parser for argument values.
                    pub fn get_value_parser(&self) -> &super::ValueParser {
                        if let Some(value_parser) = self.value_parser.as_ref() {
                            value_parser
                        } else {
                            static DEFAULT: super::ValueParser = super::ValueParser::string();
                            &DEFAULT
                        }
                    }
                    /// Report whether [`Arg::global`] is set
                    pub fn is_global_set(&self) -> bool {
                        self.is_set(ArgSettings::Global)
                    }
                    /// Report whether [`Arg::next_line_help`] is set
                    pub fn is_next_line_help_set(&self) -> bool {
                        self.is_set(ArgSettings::NextLineHelp)
                    }
                    /// Report whether [`Arg::hide`] is set
                    pub fn is_hide_set(&self) -> bool {
                        self.is_set(ArgSettings::Hidden)
                    }
                    /// Report whether [`Arg::hide_default_value`] is set
                    pub fn is_hide_default_value_set(&self) -> bool {
                        self.is_set(ArgSettings::HideDefaultValue)
                    }
                    /// Report whether [`Arg::hide_possible_values`] is set
                    pub fn is_hide_possible_values_set(&self) -> bool {
                        self.is_set(ArgSettings::HidePossibleValues)
                    }
                    /// Report whether [`Arg::hide_env`] is set
                    #[cfg(feature = "env")]
                    pub fn is_hide_env_set(&self) -> bool {
                        self.is_set(ArgSettings::HideEnv)
                    }
                    /// Report whether [`Arg::hide_env_values`] is set
                    #[cfg(feature = "env")]
                    pub fn is_hide_env_values_set(&self) -> bool {
                        self.is_set(ArgSettings::HideEnvValues)
                    }
                    /// Report whether [`Arg::hide_short_help`] is set
                    pub fn is_hide_short_help_set(&self) -> bool {
                        self.is_set(ArgSettings::HiddenShortHelp)
                    }
                    /// Report whether [`Arg::hide_long_help`] is set
                    pub fn is_hide_long_help_set(&self) -> bool {
                        self.is_set(ArgSettings::HiddenLongHelp)
                    }
                    /// Report whether [`Arg::require_equals`] is set
                    pub fn is_require_equals_set(&self) -> bool {
                        self.is_set(ArgSettings::RequireEquals)
                    }
                    /// Reports whether [`Arg::exclusive`] is set
                    pub fn is_exclusive_set(&self) -> bool {
                        self.is_set(ArgSettings::Exclusive)
                    }
                    /// Report whether [`Arg::trailing_var_arg`] is set
                    pub fn is_trailing_var_arg_set(&self) -> bool {
                        self.is_set(ArgSettings::TrailingVarArg)
                    }
                    /// Reports whether [`Arg::last`] is set
                    pub fn is_last_set(&self) -> bool {
                        self.is_set(ArgSettings::Last)
                    }
                    /// Reports whether [`Arg::ignore_case`] is set
                    pub fn is_ignore_case_set(&self) -> bool {
                        self.is_set(ArgSettings::IgnoreCase)
                    }
                    /// Access an [`ArgExt`]
                    
                    pub fn get<T: ArgExt + Extension>(&self) -> Option<&T> {
                        self.ext.get::<T>()
                    }
                    /// Remove an [`ArgExt`]
                    
                    pub fn remove<T: ArgExt + Extension>(mut self) -> Option<T> {
                        self.ext.remove::<T>()
                    }
                }
                /// # Internally used only
                impl Arg 
                {
                    pub fn _build(&mut self) {
                        if self.action.is_none() {
                            if self.num_vals == Some(ValueRange::EMPTY) {
                                let action = ArgAction::SetTrue;
                                self.action = Some(action);
                            } else {
                                let action =
                                    if self.is_positional() && self.num_vals.unwrap_or_default().is_unbounded() {
                                        // Allow collecting arguments interleaved with flags
                                        //
                                        // Bounded values are probably a group and the user should explicitly opt-in to
                                        // Append
                                        ArgAction::Append
                                    } else {
                                        ArgAction::Set
                                    };
                                self.action = Some(action);
                            }
                        }
                        if let Some(action) = self.action.as_ref() {
                            if let Some(default_value) = action.default_value() {
                                if self.default_vals.is_empty() {
                                    self.default_vals = vec![default_value.into()];
                                }
                            }
                            if let Some(default_value) = action.default_missing_value() {
                                if self.default_missing_vals.is_empty() {
                                    self.default_missing_vals = vec![default_value.into()];
                                }
                            }
                        }

                        if self.value_parser.is_none() {
                            if let Some(default) = self.action.as_ref().and_then(|a| a.default_value_parser()) {
                                self.value_parser = Some(default);
                            } else {
                                self.value_parser = Some(super::ValueParser::string());
                            }
                        }

                        let val_names_len = self.val_names.len();
                        if val_names_len > 1 {
                            self.num_vals.get_or_insert(val_names_len.into());
                        } else {
                            let nargs = self.get_action().default_num_args();
                            self.num_vals.get_or_insert(nargs);
                        }
                    }

                    // Used for positionals when printing
                    pub fn name_no_brackets(&self) -> String {
                        debug!("Arg::name_no_brackets:{}", self.get_id());
                        let delim = " ";
                        if !self.val_names.is_empty() {
                            debug!("Arg::name_no_brackets: val_names={:#?}", self.val_names);

                            if self.val_names.len() > 1 {
                                self.val_names
                                    .iter()
                                    .map(|n| format!("<{n}>"))
                                    .collect::<Vec<_>>()
                                    .join(delim)
                            } else {
                                self.val_names
                                    .first()
                                    .expect(INTERNAL_ERROR_MSG)
                                    .as_str()
                                    .to_owned()
                            }
                        } else {
                            debug!("Arg::name_no_brackets: just name");
                            self.get_id().as_str().to_owned()
                        }
                    }

                    pub fn stylized(&self, styles: &Styles, required: Option<bool>) -> StyledStr {
                        use std::fmt::Write as _;
                        let literal = styles.get_literal();

                        let mut styled = StyledStr::new();
                        // Write the name such --long or -l
                        if let Some(l) = self.get_long() {
                            let _ = write!(styled, "{literal}--{l}{literal:#}",);
                        } else if let Some(s) = self.get_short() {
                            let _ = write!(styled, "{literal}-{s}{literal:#}");
                        }
                        styled.push_styled(&self.stylize_arg_suffix(styles, required));
                        styled
                    }

                    pub fn stylize_arg_suffix(&self, styles: &Styles, required: Option<bool>) -> StyledStr {
                        use std::fmt::Write as _;
                        let literal = styles.get_literal();
                        let placeholder = styles.get_placeholder();
                        let mut styled = StyledStr::new();

                        let mut need_closing_bracket = false;
                        if self.is_takes_value_set() && !self.is_positional() {
                            let is_optional_val = self.get_min_vals() == 0;
                            let (style, start) = if self.is_require_equals_set() {
                                if is_optional_val {
                                    need_closing_bracket = true;
                                    (placeholder, "[=")
                                } else {
                                    (literal, "=")
                                }
                            } else if is_optional_val {
                                need_closing_bracket = true;
                                (placeholder, " [")
                            } else {
                                (placeholder, " ")
                            };
                            let _ = write!(styled, "{style}{start}{style:#}");
                        }
                        if self.is_takes_value_set() || self.is_positional() {
                            let required = required.unwrap_or_else(|| self.is_required_set());
                            let arg_val = self.render_arg_val(required);
                            let _ = write!(styled, "{placeholder}{arg_val}{placeholder:#}",);
                        } else if matches!(*self.get_action(), ArgAction::Count) {
                            let _ = write!(styled, "{placeholder}...{placeholder:#}",);
                        }
                        if need_closing_bracket {
                            let _ = write!(styled, "{placeholder}]{placeholder:#}",);
                        }

                        styled
                    }
                    /// Write the values such as `<name1> <name2>`
                    fn render_arg_val(&self, required: bool) -> String {
                        let mut rendered = String::new();

                        let num_vals = self.get_num_args().unwrap_or_else(|| 1.into());

                        let mut val_names = if self.val_names.is_empty() {
                            vec![self.id.as_internal_str().to_owned()]
                        } else {
                            self.val_names.clone()
                        };
                        if val_names.len() == 1 {
                            let min = num_vals.min_values().max(1);
                            let val_name = val_names.pop().unwrap();
                            val_names = vec![val_name; min];
                        }

                        debug_assert!(self.is_takes_value_set());
                        for (n, val_name) in val_names.iter().enumerate() {
                            let arg_name = if self.is_positional() && (num_vals.min_values() == 0 || !required) {
                                format!("[{val_name}]")
                            } else {
                                format!("<{val_name}>")
                            };

                            if n != 0 {
                                rendered.push(' ');
                            }
                            rendered.push_str(&arg_name);
                        }

                        let mut extra_values = false;
                        extra_values |= val_names.len() < num_vals.max_values();
                        if self.is_positional() && matches!(*self.get_action(), ArgAction::Append) {
                            extra_values = true;
                        }
                        if extra_values {
                            rendered.push_str("...");
                        }

                        rendered
                    }
                    /// Either multiple values or occurrences
                    pub fn is_multiple(&self) -> bool {
                        self.is_multiple_values_set() || matches!(*self.get_action(), ArgAction::Append)
                    }
                }

                impl From<&'_ Arg> for Arg 
                {
                    fn from(a: &Arg) -> Self {
                        a.clone()
                    }
                }

                impl PartialEq for Arg 
                {
                    fn eq(&self, other: &Arg) -> bool {
                        self.get_id() == other.get_id()
                    }
                }

                impl PartialOrd for Arg 
                {
                    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
                        Some(self.cmp(other))
                    }
                }

                impl Ord for Arg 
                {
                    fn cmp(&self, other: &Arg) -> Ordering {
                        self.get_id().cmp(other.get_id())
                    }
                }

                impl Eq for Arg {}

                impl Display for Arg 
                {
                    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                        let plain = Styles::plain();
                        self.stylized(&plain, None).fmt(f)
                    }
                }

                impl fmt::Debug for Arg 
                {
                    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
                        let mut ds = f.debug_struct("Arg");

                        #[allow(unused_mut)]
                        let mut ds = ds
                            .field("id", &self.id)
                            .field("help", &self.help)
                            .field("long_help", &self.long_help)
                            .field("action", &self.action)
                            .field("value_parser", &self.value_parser)
                            .field("blacklist", &self.blacklist)
                            .field("settings", &self.settings)
                            .field("overrides", &self.overrides)
                            .field("groups", &self.groups)
                            .field("requires", &self.requires)
                            .field("r_ifs", &self.r_ifs)
                            .field("r_unless", &self.r_unless)
                            .field("short", &self.short)
                            .field("long", &self.long)
                            .field("aliases", &self.aliases)
                            .field("short_aliases", &self.short_aliases)
                            .field("disp_ord", &self.disp_ord)
                            .field("val_names", &self.val_names)
                            .field("num_vals", &self.num_vals)
                            .field("val_delim", &self.val_delim)
                            .field("default_vals", &self.default_vals)
                            .field("default_vals_ifs", &self.default_vals_ifs)
                            .field("terminator", &self.terminator)
                            .field("index", &self.index)
                            .field("help_heading", &self.help_heading)
                            .field("default_missing_vals", &self.default_missing_vals)
                            .field("ext", &self.ext);

                        #[cfg(feature = "env")]
                        {
                            ds = ds.field("env", &self.env);
                        }

                        ds.finish()
                    }
                }
                /// User-provided data that can be attached to an [`Arg`]
                pub trait ArgExt: Extension {}
            }

            pub mod command
            {
                use ::
                {
                    *,
                };
                /*
                // Std
                use std::env;
                use std::ffi::OsString;
                use std::fmt;
                use std::io;
                use std::ops::Index;
                use std::path::Path;

                // Internal
                use crate::builder::app_settings::{AppFlags, AppSettings};
                use crate::builder::arg_settings::ArgSettings;
                use crate::builder::ext::Extension;
                use crate::builder::ext::Extensions;
                use crate::builder::ArgAction;
                use crate::builder::IntoResettable;
                use crate::builder::PossibleValue;
                use crate::builder::Str;
                use crate::builder::StyledStr;
                use crate::builder::Styles;
                use crate::builder::{Arg, ArgGroup, ArgPredicate};
                use crate::error::ErrorKind;
                use crate::error::Result as ClapResult;
                use crate::mkeymap::MKeyMap;
                use crate::output::fmt::Stream;
                use crate::output::{fmt::Colorizer, write_help, Usage};
                use crate::parser::{ArgMatcher, ArgMatches, Parser};
                use crate::util::ChildGraph;
                use crate::util::{color::ColorChoice, Id};
                use crate::{Error, INTERNAL_ERROR_MSG};

                #[cfg(debug_assertions)]
                use crate::builder::debug_asserts::assert_app;
                */

                /// Build a command-line interface.
                #[derive(Debug, Clone)]
                pub struct Command 
                {
                    name: Str,
                    long_flag: Option<Str>,
                    short_flag: Option<char>,
                    display_name: Option<String>,
                    bin_name: Option<String>,
                    author: Option<Str>,
                    version: Option<Str>,
                    long_version: Option<Str>,
                    about: Option<StyledStr>,
                    long_about: Option<StyledStr>,
                    before_help: Option<StyledStr>,
                    before_long_help: Option<StyledStr>,
                    after_help: Option<StyledStr>,
                    after_long_help: Option<StyledStr>,
                    aliases: Vec<(Str, bool)>,             // (name, visible)
                    short_flag_aliases: Vec<(char, bool)>, // (name, visible)
                    long_flag_aliases: Vec<(Str, bool)>,   // (name, visible)
                    usage_str: Option<StyledStr>,
                    usage_name: Option<String>,
                    help_str: Option<StyledStr>,
                    disp_ord: Option<usize>,
                    #[cfg(feature = "help")]
                    template: Option<StyledStr>,
                    settings: AppFlags,
                    g_settings: AppFlags,
                    args: MKeyMap,
                    subcommands: Vec<Command>,
                    groups: Vec<ArgGroup>,
                    current_help_heading: Option<Str>,
                    current_disp_ord: Option<usize>,
                    subcommand_value_name: Option<Str>,
                    subcommand_heading: Option<Str>,
                    external_value_parser: Option<super::ValueParser>,
                    long_help_exists: bool,
                    deferred: Option<fn(Command) -> Command>,
                    
                    ext: Extensions,
                    app_ext: Extensions,
                }
                /// # Basic API
                impl Command 
                {
                    /// Creates a new instance of an `Command`.
                    pub fn new(name: impl Into<Str>) -> Self {
                        /// The actual implementation of `new`, non-generic to save code size.
                        ///
                        /// If we don't do this rustc will unnecessarily generate multiple versions
                        /// of this code.
                        fn new_inner(name: Str) -> Command {
                            Command {
                                name,
                                ..Default::default()
                            }
                        }

                        new_inner(name.into())
                    }
                    /// Adds an [argument] to the list of valid possibilities.
                    #[must_use] pub fn arg(mut self, a: impl Into<Arg>) -> Self {
                        let arg = a.into();
                        self.arg_internal(arg);
                        self
                    }

                    fn arg_internal(&mut self, mut arg: Arg) {
                        if let Some(current_disp_ord) = self.current_disp_ord.as_mut() {
                            if !arg.is_positional() {
                                let current = *current_disp_ord;
                                arg.disp_ord.get_or_insert(current);
                                *current_disp_ord = current + 1;
                            }
                        }

                        arg.help_heading
                            .get_or_insert_with(|| self.current_help_heading.clone());
                        self.args.push(arg);
                    }
                    /// Adds multiple [arguments] to the list of valid possibilities.
                    #[must_use] pub fn args(mut self, args: impl IntoIterator<Item = impl Into<Arg>>) -> Self {
                        for arg in args {
                            self = self.arg(arg);
                        }
                        self
                    }
                    /// Allows one to mutate an [`Arg`] after it's been added to a [`Command`].
                    #[must_use]
                    #[cfg_attr(debug_assertions, track_caller)]
                    pub fn mut_arg<F>(mut self, arg_id: impl AsRef<str>, f: F) -> Self
                    where
                        F: FnOnce(Arg) -> Arg,
                    {
                        let id = arg_id.as_ref();
                        let a = self
                            .args
                            .remove_by_name(id)
                            .unwrap_or_else(|| panic!("Argument `{id}` is undefined"));

                        self.args.push(f(a));
                        self
                    }
                    /// Allows one to mutate all [`Arg`]s after they've been added to a [`Command`].
                    #[cfg_attr(feature = "string", doc = "```")]
                    #[cfg_attr(not(feature = "string"), doc = "```ignore")]
                    
                    #[must_use]
                    #[cfg_attr(debug_assertions, track_caller)]
                    pub fn mut_args<F>(mut self, f: F) -> Self
                    where
                        F: FnMut(Arg) -> Arg,
                    {
                        self.args.mut_args(f);
                        self
                    }
                    /// Allows one to mutate an [`ArgGroup`] after it's been added to a [`Command`].
                    #[must_use]
                    #[cfg_attr(debug_assertions, track_caller)]
                    pub fn mut_group<F>(mut self, arg_id: impl AsRef<str>, f: F) -> Self
                    where
                        F: FnOnce(ArgGroup) -> ArgGroup,
                    {
                        let id = arg_id.as_ref();
                        let index = self
                            .groups
                            .iter()
                            .position(|g| g.get_id() == id)
                            .unwrap_or_else(|| panic!("Group `{id}` is undefined"));
                        let a = self.groups.remove(index);

                        self.groups.push(f(a));
                        self
                    }
                    /// Allows one to mutate a [`Command`] after it's been added as a subcommand.
                    #[must_use] pub fn mut_subcommand<F>(mut self, name: impl AsRef<str>, f: F) -> Self
                    where
                        F: FnOnce(Self) -> Self,
                    {
                        let name = name.as_ref();
                        let pos = self.subcommands.iter().position(|s| s.name == name);

                        let subcmd = if let Some(idx) = pos {
                            self.subcommands.remove(idx)
                        } else {
                            panic!("Command `{name}` is undefined")
                        };

                        self.subcommands.push(f(subcmd));
                        self
                    }
                    /// Adds an [`ArgGroup`] to the application.
                    #[inline] #[must_use] pub fn group(mut self, group: impl Into<ArgGroup>) -> Self {
                        self.groups.push(group.into());
                        self
                    }
                    /// Adds multiple [`ArgGroup`]s to the [`Command`] at once.
                    #[must_use] pub fn groups(mut self, groups: impl IntoIterator<Item = impl Into<ArgGroup>>) -> Self {
                        for g in groups {
                            self = self.group(g.into());
                        }
                        self
                    }
                    /// Adds a subcommand to the list of valid possibilities.
                    #[inline] #[must_use] pub fn subcommand(self, subcmd: impl Into<Command>) -> Self {
                        let subcmd = subcmd.into();
                        self.subcommand_internal(subcmd)
                    }

                    fn subcommand_internal(mut self, mut subcmd: Self) -> Self {
                        if let Some(current_disp_ord) = self.current_disp_ord.as_mut() {
                            let current = *current_disp_ord;
                            subcmd.disp_ord.get_or_insert(current);
                            *current_disp_ord = current + 1;
                        }
                        self.subcommands.push(subcmd);
                        self
                    }
                    /// Adds multiple subcommands to the list of valid possibilities.
                    #[must_use] pub fn subcommands(mut self, subcmds: impl IntoIterator<Item = impl Into<Self>>) -> Self {
                        for subcmd in subcmds {
                            self = self.subcommand(subcmd);
                        }
                        self
                    }
                    /// Delay initialization for parts of the `Command`
                    pub fn defer(mut self, deferred: fn(Command) -> Command) -> Self {
                        self.deferred = Some(deferred);
                        self
                    }
                    /// Catch problems earlier in the development cycle.
                    pub fn debug_assert(mut self) {
                        self.build();
                    }
                    /// Custom error message for post-parsing validation
                    pub fn error(&mut self, kind: ErrorKind, message: impl fmt::Display) -> Error {
                        Error::raw(kind, message).format(self)
                    }
                    /// Parse [`env::args_os`], [exiting][Error::exit] on failure.
                    #[inline] pub fn get_matches(self) -> ArgMatches {
                        self.get_matches_from(env::args_os())
                    }
                    /// Parse [`env::args_os`], [exiting][Error::exit] on failure.
                    pub fn get_matches_mut(&mut self) -> ArgMatches {
                        self.try_get_matches_from_mut(env::args_os())
                            .unwrap_or_else(|e| e.exit())
                    }
                    /// Parse [`env::args_os`], returning a [`clap::Result`] on failure.
                    #[inline] pub fn try_get_matches(self) -> ClapResult<ArgMatches> {
                        // Start the parsing
                        self.try_get_matches_from(env::args_os())
                    }
                    /// Parse the specified arguments, [exiting][Error::exit] on failure.
                    pub fn get_matches_from<I, T>(mut self, itr: I) -> ArgMatches
                    where
                        I: IntoIterator<Item = T>,
                        T: Into<OsString> + Clone,
                    {
                        self.try_get_matches_from_mut(itr).unwrap_or_else(|e| {
                            drop(self);
                            e.exit()
                        })
                    }
                    /// Parse the specified arguments, returning a [`clap::Result`] on failure.
                    pub fn try_get_matches_from<I, T>(mut self, itr: I) -> ClapResult<ArgMatches>
                    where
                        I: IntoIterator<Item = T>,
                        T: Into<OsString> + Clone,
                    {
                        self.try_get_matches_from_mut(itr)
                    }
                    /// Parse the specified arguments, returning a [`clap::Result`] on failure.
                    pub fn try_get_matches_from_mut<I, T>(&mut self, itr: I) -> ClapResult<ArgMatches>
                    where
                        I: IntoIterator<Item = T>,
                        T: Into<OsString> + Clone,
                    {
                        let mut raw_args = clap_lex::RawArgs::new(itr);
                        let mut cursor = raw_args.cursor();

                        if self.settings.is_set(AppSettings::Multicall) {
                            if let Some(argv0) = raw_args.next_os(&mut cursor) {
                                let argv0 = Path::new(&argv0);
                                if let Some(command) = argv0.file_stem().and_then(|f| f.to_str()) {
                                    // Stop borrowing command so we can get another mut ref to it.
                                    let command = command.to_owned();
                                    debug!("Command::try_get_matches_from_mut: Parsed command {command} from argv");

                                    debug!("Command::try_get_matches_from_mut: Reinserting command into arguments so subcommand parser matches it");
                                    raw_args.insert(&cursor, [&command]);
                                    debug!("Command::try_get_matches_from_mut: Clearing name and bin_name so that displayed command name starts with applet name");
                                    self.name = "".into();
                                    self.bin_name = None;
                                    return self._do_parse(&mut raw_args, cursor);
                                }
                            }
                        };

                        // Get the name of the program (argument 1 of env::args()) and determine the
                        // actual file
                        // that was used to execute the program. This is because a program called
                        // ./target/release/my_prog -a
                        // will have two arguments, './target/release/my_prog', '-a' but we don't want
                        // to display
                        // the full path when displaying help messages and such
                        if !self.settings.is_set(AppSettings::NoBinaryName) {
                            if let Some(name) = raw_args.next_os(&mut cursor) {
                                let p = Path::new(name);

                                if let Some(f) = p.file_name() {
                                    if let Some(s) = f.to_str() {
                                        if self.bin_name.is_none() {
                                            self.bin_name = Some(s.to_owned());
                                        }
                                    }
                                }
                            }
                        }

                        self._do_parse(&mut raw_args, cursor)
                    }
                    /// Prints the short help message (`-h`) to [`io::stdout()`].
                    pub fn print_help(&mut self) -> io::Result<()> {
                        self._build_self(false);
                        let color = self.color_help();

                        let mut styled = StyledStr::new();
                        let usage = Usage::new(self);
                        write_help(&mut styled, self, &usage, false);

                        let c = Colorizer::new(Stream::Stdout, color).with_content(styled);
                        c.print()
                    }
                    /// Prints the long help message (`--help`) to [`io::stdout()`].
                    pub fn print_long_help(&mut self) -> io::Result<()> {
                        self._build_self(false);
                        let color = self.color_help();

                        let mut styled = StyledStr::new();
                        let usage = Usage::new(self);
                        write_help(&mut styled, self, &usage, true);

                        let c = Colorizer::new(Stream::Stdout, color).with_content(styled);
                        c.print()
                    }
                    /// Render the short help message (`-h`) to a [`StyledStr`]
                    pub fn render_help(&mut self) -> StyledStr {
                        self._build_self(false);

                        let mut styled = StyledStr::new();
                        let usage = Usage::new(self);
                        write_help(&mut styled, self, &usage, false);
                        styled
                    }
                    /// Render the long help message (`--help`) to a [`StyledStr`].
                    pub fn render_long_help(&mut self) -> StyledStr {
                        self._build_self(false);

                        let mut styled = StyledStr::new();
                        let usage = Usage::new(self);
                        write_help(&mut styled, self, &usage, true);
                        styled
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Command::render_help`")
                    )]
                    pub fn write_help<W: io::Write>(&mut self, w: &mut W) -> io::Result<()> {
                        self._build_self(false);

                        let mut styled = StyledStr::new();
                        let usage = Usage::new(self);
                        write_help(&mut styled, self, &usage, false);
                        ok!(write!(w, "{styled}"));
                        w.flush()
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Command::render_long_help`")
                    )]
                    pub fn write_long_help<W: io::Write>(&mut self, w: &mut W) -> io::Result<()> {
                        self._build_self(false);

                        let mut styled = StyledStr::new();
                        let usage = Usage::new(self);
                        write_help(&mut styled, self, &usage, true);
                        ok!(write!(w, "{styled}"));
                        w.flush()
                    }
                    /// Version message rendered as if the user ran `-V`.
                    pub fn render_version(&self) -> String {
                        self._render_version(false)
                    }
                    /// Version message rendered as if the user ran `--version`.
                    pub fn render_long_version(&self) -> String {
                        self._render_version(true)
                    }
                    /// Usage statement
                    pub fn render_usage(&mut self) -> StyledStr {
                        self.render_usage_().unwrap_or_default()
                    }

                    pub fn render_usage_(&mut self) -> Option<StyledStr> {
                        // If there are global arguments, or settings we need to propagate them down to subcommands
                        // before parsing incase we run into a subcommand
                        self._build_self(false);

                        Usage::new(self).create_usage_with_title(&[])
                    }
                    /// Extend [`Command`] with [`CommandExt`] data
                    
                    
                    pub fn add<T: CommandExt + Extension>(mut self, tagged: T) -> Self {
                        self.ext.set(tagged);
                        self
                    }
                }
                /// # Application-wide Settings
                impl Command 
                {
                    /// Specifies that the parser should not assume the first argument passed is the binary name.
                    #[inline] pub fn no_binary_name(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::NoBinaryName)
                        } else {
                            self.unset_global_setting(AppSettings::NoBinaryName)
                        }
                    }
                    /// Try not to fail on parse errors, like missing option values.
                    #[inline] pub fn ignore_errors(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::IgnoreErrors)
                        } else {
                            self.unset_global_setting(AppSettings::IgnoreErrors)
                        }
                    }
                    /// Replace prior occurrences of arguments rather than error
                    #[inline] pub fn args_override_self(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::AllArgsOverrideSelf)
                        } else {
                            self.unset_global_setting(AppSettings::AllArgsOverrideSelf)
                        }
                    }
                    /// Disables the automatic delimiting of values after `--` or when [`Arg::trailing_var_arg`]
                    #[inline] pub fn dont_delimit_trailing_values(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::DontDelimitTrailingValues)
                        } else {
                            self.unset_global_setting(AppSettings::DontDelimitTrailingValues)
                        }
                    }
                    /// Sets when to color output.
                    #[cfg(feature = "color")]
                    #[inline] #[must_use] pub fn color(self, color: ColorChoice) -> Self {
                        let cmd = self
                            .unset_global_setting(AppSettings::ColorAuto)
                            .unset_global_setting(AppSettings::ColorAlways)
                            .unset_global_setting(AppSettings::ColorNever);
                        match color {
                            ColorChoice::Auto => cmd.global_setting(AppSettings::ColorAuto),
                            ColorChoice::Always => cmd.global_setting(AppSettings::ColorAlways),
                            ColorChoice::Never => cmd.global_setting(AppSettings::ColorNever),
                        }
                    }
                    /// Sets the [`Styles`] for terminal output
                    #[cfg(feature = "color")]
                    #[inline] #[must_use] pub fn styles(mut self, styles: Styles) -> Self {
                        self.app_ext.set(styles);
                        self
                    }
                    /// Sets the terminal width at which to wrap help messages.
                    #[inline]
                    #[must_use]
                    #[cfg(any(not(feature = "unstable-v5"), feature = "wrap_help"))]
                    pub fn term_width(mut self, width: usize) -> Self {
                        self.app_ext.set(TermWidth(width));
                        self
                    }
                    /// Limit the line length for wrapping help when using the current terminal's width.
                    #[inline]
                    #[must_use]
                    #[cfg(any(not(feature = "unstable-v5"), feature = "wrap_help"))]
                    pub fn max_term_width(mut self, width: usize) -> Self {
                        self.app_ext.set(MaxTermWidth(width));
                        self
                    }
                    /// Disables `-V` and `--version` flag.
                    #[inline] pub fn disable_version_flag(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::DisableVersionFlag)
                        } else {
                            self.unset_global_setting(AppSettings::DisableVersionFlag)
                        }
                    }
                    /// Specifies to use the version of the current command for all [`subcommands`].
                    #[inline] pub fn propagate_version(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::PropagateVersion)
                        } else {
                            self.unset_global_setting(AppSettings::PropagateVersion)
                        }
                    }
                    /// Places the help string for all arguments and subcommands on the line after them.
                    #[inline] pub fn next_line_help(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::NextLineHelp)
                        } else {
                            self.unset_global_setting(AppSettings::NextLineHelp)
                        }
                    }
                    /// Disables `-h` and `--help` flag.
                    #[inline] pub fn disable_help_flag(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::DisableHelpFlag)
                        } else {
                            self.unset_global_setting(AppSettings::DisableHelpFlag)
                        }
                    }
                    /// Disables the `help` [`subcommand`].
                    #[inline] pub fn disable_help_subcommand(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::DisableHelpSubcommand)
                        } else {
                            self.unset_global_setting(AppSettings::DisableHelpSubcommand)
                        }
                    }
                    /// Disables colorized help messages.
                    #[inline] pub fn disable_colored_help(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::DisableColoredHelp)
                        } else {
                            self.unset_global_setting(AppSettings::DisableColoredHelp)
                        }
                    }
                    /// Panic if help descriptions are omitted.
                    #[inline] pub fn help_expected(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::HelpExpected)
                        } else {
                            self.unset_global_setting(AppSettings::HelpExpected)
                        }
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "This is now the default")
                    )]
                    pub fn dont_collapse_args_in_usage(self, _yes: bool) -> Self {
                        self
                    }
                    /// Tells `clap` *not* to print possible values when displaying help information.
                    #[inline] pub fn hide_possible_values(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::HidePossibleValues)
                        } else {
                            self.unset_global_setting(AppSettings::HidePossibleValues)
                        }
                    }
                    /// Allow partial matches of long arguments or their [aliases].
                    #[inline] pub fn infer_long_args(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::InferLongArgs)
                        } else {
                            self.unset_global_setting(AppSettings::InferLongArgs)
                        }
                    }
                    /// Allow partial matches of [subcommand] names and their [aliases].
                    #[inline] pub fn infer_subcommands(self, yes: bool) -> Self {
                        if yes {
                            self.global_setting(AppSettings::InferSubcommands)
                        } else {
                            self.unset_global_setting(AppSettings::InferSubcommands)
                        }
                    }
                }
                /// # Command-specific Settings
                impl Command 
                {
                    /// (Re)Sets the program's name.
                    #[must_use] pub fn name(mut self, name: impl Into<Str>) -> Self {
                        self.name = name.into();
                        self
                    }
                    /// Overrides the runtime-determined name of the binary for help and error messages.
                    #[must_use] pub fn bin_name(mut self, name: impl IntoResettable<String>) -> Self {
                        self.bin_name = name.into_resettable().into_option();
                        self
                    }
                    /// Overrides the runtime-determined display name of the program for help and error messages.
                    #[must_use] pub fn display_name(mut self, name: impl IntoResettable<String>) -> Self {
                        self.display_name = name.into_resettable().into_option();
                        self
                    }
                    /// Sets the author(s) for the help message.
                    #[must_use] pub fn author(mut self, author: impl IntoResettable<Str>) -> Self {
                        self.author = author.into_resettable().into_option();
                        self
                    }
                    /// Sets the program's description for the short help (`-h`).
                    #[must_use] pub fn about(mut self, about: impl IntoResettable<StyledStr>) -> Self {
                        self.about = about.into_resettable().into_option();
                        self
                    }
                    /// Sets the program's description for the long help (`--help`).
                    #[must_use] pub fn long_about(mut self, long_about: impl IntoResettable<StyledStr>) -> Self {
                        self.long_about = long_about.into_resettable().into_option();
                        self
                    }
                    /// Free-form help text for after auto-generated short help (`-h`).
                    #[must_use] pub fn after_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
                        self.after_help = help.into_resettable().into_option();
                        self
                    }
                    /// Free-form help text for after auto-generated long help (`--help`).
                    #[must_use] pub fn after_long_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
                        self.after_long_help = help.into_resettable().into_option();
                        self
                    }
                    /// Free-form help text for before auto-generated short help (`-h`).
                    #[must_use] pub fn before_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
                        self.before_help = help.into_resettable().into_option();
                        self
                    }
                    /// Free-form help text for before auto-generated long help (`--help`).
                    #[must_use] pub fn before_long_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
                        self.before_long_help = help.into_resettable().into_option();
                        self
                    }
                    /// Sets the version for the short version (`-V`) and help messages.
                    #[must_use] pub fn version(mut self, ver: impl IntoResettable<Str>) -> Self {
                        self.version = ver.into_resettable().into_option();
                        self
                    }
                    /// Sets the version for the long version (`--version`) and help messages.
                    #[must_use] pub fn long_version(mut self, ver: impl IntoResettable<Str>) -> Self {
                        self.long_version = ver.into_resettable().into_option();
                        self
                    }
                    /// Overrides the `clap` generated usage string for help and error messages.
                    #[must_use] pub fn override_usage(mut self, usage: impl IntoResettable<StyledStr>) -> Self {
                        self.usage_str = usage.into_resettable().into_option();
                        self
                    }
                    /// Overrides the `clap` generated help message (both `-h` and `--help`).
                    #[must_use] pub fn override_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
                        self.help_str = help.into_resettable().into_option();
                        self
                    }
                    /// Sets the help template to be used, overriding the default format.
                    #[must_use]
                    #[cfg(feature = "help")]
                    pub fn help_template(mut self, s: impl IntoResettable<StyledStr>) -> Self {
                        self.template = s.into_resettable().into_option();
                        self
                    }

                    #[inline] #[must_use] pub fn setting(mut self, setting: AppSettings) -> Self {
                        self.settings.set(setting);
                        self
                    }

                    #[inline] #[must_use] pub fn unset_setting(mut self, setting: AppSettings) -> Self {
                        self.settings.unset(setting);
                        self
                    }

                    #[inline] #[must_use] pub fn global_setting(mut self, setting: AppSettings) -> Self {
                        self.settings.set(setting);
                        self.g_settings.set(setting);
                        self
                    }

                    #[inline] #[must_use] pub fn unset_global_setting(mut self, setting: AppSettings) -> Self {
                        self.settings.unset(setting);
                        self.g_settings.unset(setting);
                        self
                    }
                    /// Flatten subcommand help into the current command's help.
                    #[inline] #[must_use] pub fn flatten_help(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::FlattenHelp)
                        } else {
                            self.unset_setting(AppSettings::FlattenHelp)
                        }
                    }
                    /// Set the default section heading for future args.
                    #[inline] #[must_use] pub fn next_help_heading(mut self, heading: impl IntoResettable<Str>) -> Self {
                        self.current_help_heading = heading.into_resettable().into_option();
                        self
                    }
                    /// Change the starting value for assigning future display orders for args.
                    #[inline] #[must_use] pub fn next_display_order(mut self, disp_ord: impl IntoResettable<usize>) -> Self {
                        self.current_disp_ord = disp_ord.into_resettable().into_option();
                        self
                    }
                    /// Exit gracefully if no arguments are present (e.g. `$ myprog`).
                    #[inline] pub fn arg_required_else_help(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::ArgRequiredElseHelp)
                        } else {
                            self.unset_setting(AppSettings::ArgRequiredElseHelp)
                        }
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::allow_hyphen_values`")
                    )]
                    pub fn allow_hyphen_values(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::AllowHyphenValues)
                        } else {
                            self.unset_setting(AppSettings::AllowHyphenValues)
                        }
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::allow_negative_numbers`")
                    )]
                    pub fn allow_negative_numbers(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::AllowNegativeNumbers)
                        } else {
                            self.unset_setting(AppSettings::AllowNegativeNumbers)
                        }
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::trailing_var_arg`")
                    )]
                    pub fn trailing_var_arg(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::TrailingVarArg)
                        } else {
                            self.unset_setting(AppSettings::TrailingVarArg)
                        }
                    }
                    /// Allows one to implement two styles of CLIs where positionals can be used out of order.
                    #[inline] pub fn allow_missing_positional(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::AllowMissingPositional)
                        } else {
                            self.unset_setting(AppSettings::AllowMissingPositional)
                        }
                    }
                }
                /// # Subcommand-specific Settings
                impl Command 
                {
                    /// Sets the short version of the subcommand flag without the preceding `-`.
                    #[must_use] pub fn short_flag(mut self, short: impl IntoResettable<char>) -> Self {
                        self.short_flag = short.into_resettable().into_option();
                        self
                    }
                    /// Sets the long version of the subcommand flag without the preceding `--`.
                    #[must_use] pub fn long_flag(mut self, long: impl Into<Str>) -> Self {
                        self.long_flag = Some(long.into());
                        self
                    }
                    /// Sets a hidden alias to this subcommand.
                    #[must_use] pub fn alias(mut self, name: impl IntoResettable<Str>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            self.aliases.push((name, false));
                        } else {
                            self.aliases.clear();
                        }
                        self
                    }
                    /// Add an alias, which functions as  "hidden" short flag subcommand.
                    #[must_use] pub fn short_flag_alias(mut self, name: impl IntoResettable<char>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            debug_assert!(name != '-', "short alias name cannot be `-`");
                            self.short_flag_aliases.push((name, false));
                        } else {
                            self.short_flag_aliases.clear();
                        }
                        self
                    }
                    /// Add an alias, which functions as a "hidden" long flag subcommand.
                    #[must_use] pub fn long_flag_alias(mut self, name: impl IntoResettable<Str>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            self.long_flag_aliases.push((name, false));
                        } else {
                            self.long_flag_aliases.clear();
                        }
                        self
                    }
                    /// Sets multiple hidden aliases to this subcommand.
                    #[must_use] pub fn aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
                        self.aliases
                            .extend(names.into_iter().map(|n| (n.into(), false)));
                        self
                    }
                    /// Add aliases, which function as "hidden" short flag subcommands.
                    #[must_use] pub fn short_flag_aliases(mut self, names: impl IntoIterator<Item = char>) -> Self {
                        for s in names {
                            debug_assert!(s != '-', "short alias name cannot be `-`");
                            self.short_flag_aliases.push((s, false));
                        }
                        self
                    }
                    /// Add aliases, which function as "hidden" long flag subcommands.
                    #[must_use] pub fn long_flag_aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
                        for s in names {
                            self = self.long_flag_alias(s);
                        }
                        self
                    }
                    /// Sets a visible alias to this subcommand.
                    #[must_use] pub fn visible_alias(mut self, name: impl IntoResettable<Str>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            self.aliases.push((name, true));
                        } else {
                            self.aliases.clear();
                        }
                        self
                    }
                    /// Add an alias, which functions as  "visible" short flag subcommand.
                    #[must_use] pub fn visible_short_flag_alias(mut self, name: impl IntoResettable<char>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            debug_assert!(name != '-', "short alias name cannot be `-`");
                            self.short_flag_aliases.push((name, true));
                        } else {
                            self.short_flag_aliases.clear();
                        }
                        self
                    }
                    /// Add an alias, which functions as a "visible" long flag subcommand.
                    #[must_use] pub fn visible_long_flag_alias(mut self, name: impl IntoResettable<Str>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            self.long_flag_aliases.push((name, true));
                        } else {
                            self.long_flag_aliases.clear();
                        }
                        self
                    }
                    /// Sets multiple visible aliases to this subcommand.
                    #[must_use] pub fn visible_aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
                        self.aliases
                            .extend(names.into_iter().map(|n| (n.into(), true)));
                        self
                    }
                    /// Add aliases, which function as *visible* short flag subcommands.
                    #[must_use] pub fn visible_short_flag_aliases(mut self, names: impl IntoIterator<Item = char>) -> Self {
                        for s in names {
                            debug_assert!(s != '-', "short alias name cannot be `-`");
                            self.short_flag_aliases.push((s, true));
                        }
                        self
                    }
                    /// Add aliases, which function as *visible* long flag subcommands.
                    #[must_use] pub fn visible_long_flag_aliases(
                        mut self,
                        names: impl IntoIterator<Item = impl Into<Str>>,
                    ) -> Self {
                        for s in names {
                            self = self.visible_long_flag_alias(s);
                        }
                        self
                    }
                    /// Set the placement of this subcommand within the help.
                    #[inline] #[must_use] pub fn display_order(mut self, ord: impl IntoResettable<usize>) -> Self {
                        self.disp_ord = ord.into_resettable().into_option();
                        self
                    }
                    /// Specifies that this [`subcommand`] should be hidden from help messages.
                    #[inline] pub fn hide(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::Hidden)
                        } else {
                            self.unset_setting(AppSettings::Hidden)
                        }
                    }
                    /// If no [`subcommand`] is present at runtime, error and exit gracefully.
                    pub fn subcommand_required(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::SubcommandRequired)
                        } else {
                            self.unset_setting(AppSettings::SubcommandRequired)
                        }
                    }
                    /// Assume unexpected positional arguments are a [`subcommand`].
                    pub fn allow_external_subcommands(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::AllowExternalSubcommands)
                        } else {
                            self.unset_setting(AppSettings::AllowExternalSubcommands)
                        }
                    }
                    /// Specifies how to parse external subcommand arguments.
                    pub fn external_subcommand_value_parser(
                        mut self,
                        parser: impl IntoResettable<super::ValueParser>,
                    ) -> Self {
                        self.external_value_parser = parser.into_resettable().into_option();
                        self
                    }
                    /// Specifies that use of an argument prevents the use of [`subcommands`].
                    pub fn args_conflicts_with_subcommands(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::ArgsNegateSubcommands)
                        } else {
                            self.unset_setting(AppSettings::ArgsNegateSubcommands)
                        }
                    }
                    /// Prevent subcommands from being consumed as an arguments value.
                    pub fn subcommand_precedence_over_arg(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::SubcommandPrecedenceOverArg)
                        } else {
                            self.unset_setting(AppSettings::SubcommandPrecedenceOverArg)
                        }
                    }
                    /// Allows [`subcommands`] to override all requirements of the parent command.
                    pub fn subcommand_negates_reqs(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::SubcommandsNegateReqs)
                        } else {
                            self.unset_setting(AppSettings::SubcommandsNegateReqs)
                        }
                    }
                    /// Multiple-personality program dispatched on the binary name (`argv[0]`)
                    #[inline] pub fn multicall(self, yes: bool) -> Self {
                        if yes {
                            self.setting(AppSettings::Multicall)
                        } else {
                            self.unset_setting(AppSettings::Multicall)
                        }
                    }
                    /// Sets the value name used for subcommands when printing usage and help.
                    #[must_use] pub fn subcommand_value_name(mut self, value_name: impl IntoResettable<Str>) -> Self {
                        self.subcommand_value_name = value_name.into_resettable().into_option();
                        self
                    }
                    /// Sets the help heading used for subcommands when printing usage and help.
                    #[must_use] pub fn subcommand_help_heading(mut self, heading: impl IntoResettable<Str>) -> Self {
                        self.subcommand_heading = heading.into_resettable().into_option();
                        self
                    }
                }
                /// # Reflection
                impl Command 
                {
                    #[inline]
                    #[cfg(feature = "usage")]
                    pub fn get_usage_name(&self) -> Option<&str> {
                        self.usage_name.as_deref()
                    }

                    #[inline]
                    #[cfg(feature = "usage")]
                    pub fn get_usage_name_fallback(&self) -> &str {
                        self.get_usage_name()
                            .unwrap_or_else(|| self.get_bin_name_fallback())
                    }

                    #[inline]
                    #[cfg(not(feature = "usage"))]
                    
                    pub fn get_usage_name_fallback(&self) -> &str {
                        self.get_bin_name_fallback()
                    }
                    /// Get the name of the binary.
                    #[inline] pub fn get_display_name(&self) -> Option<&str> {
                        self.display_name.as_deref()
                    }
                    /// Get the name of the binary.
                    #[inline] pub fn get_bin_name(&self) -> Option<&str> {
                        self.bin_name.as_deref()
                    }
                    /// Get the name of the binary.
                    #[inline] pub fn get_bin_name_fallback(&self) -> &str {
                        self.bin_name.as_deref().unwrap_or_else(|| self.get_name())
                    }
                    /// Set binary name. Uses `&mut self` instead of `self`.
                    pub fn set_bin_name(&mut self, name: impl Into<String>) {
                        self.bin_name = Some(name.into());
                    }
                    /// Get the name of the cmd.
                    #[inline] pub fn get_name(&self) -> &str {
                        self.name.as_str()
                    }

                    #[inline]
                    #[cfg(debug_assertions)]
                    pub fn get_name_str(&self) -> &Str {
                        &self.name
                    }
                    /// Get all known names of the cmd (i.e. primary name and visible aliases).
                    pub fn get_name_and_visible_aliases(&self) -> Vec<&str> {
                        let mut names = vec![self.name.as_str()];
                        names.extend(self.get_visible_aliases());
                        names
                    }
                    /// Get the version of the cmd.
                    #[inline] pub fn get_version(&self) -> Option<&str> {
                        self.version.as_deref()
                    }
                    /// Get the long version of the cmd.
                    #[inline] pub fn get_long_version(&self) -> Option<&str> {
                        self.long_version.as_deref()
                    }
                    /// Get the placement within help
                    #[inline] pub fn get_display_order(&self) -> usize {
                        self.disp_ord.unwrap_or(999)
                    }
                    /// Get the authors of the cmd.
                    #[inline] pub fn get_author(&self) -> Option<&str> {
                        self.author.as_deref()
                    }
                    /// Get the short flag of the subcommand.
                    #[inline] pub fn get_short_flag(&self) -> Option<char> {
                        self.short_flag
                    }
                    /// Get the long flag of the subcommand.
                    #[inline] pub fn get_long_flag(&self) -> Option<&str> {
                        self.long_flag.as_deref()
                    }
                    /// Get the help message specified via [`Command::about`].
                    ///
                    /// [`Command::about`]: Command::about()
                    #[inline] pub fn get_about(&self) -> Option<&StyledStr> {
                        self.about.as_ref()
                    }
                    /// Get the help message specified via [`Command::long_about`].
                    ///
                    /// [`Command::long_about`]: Command::long_about()
                    #[inline] pub fn get_long_about(&self) -> Option<&StyledStr> {
                        self.long_about.as_ref()
                    }
                    /// Get the custom section heading specified via [`Command::flatten_help`].
                    #[inline] pub fn is_flatten_help_set(&self) -> bool {
                        self.is_set(AppSettings::FlattenHelp)
                    }
                    /// Get the custom section heading specified via [`Command::next_help_heading`].
                    ///
                    /// [`Command::help_heading`]: Command::help_heading()
                    #[inline] pub fn get_next_help_heading(&self) -> Option<&str> {
                        self.current_help_heading.as_deref()
                    }
                    /// Iterate through the *visible* aliases for this subcommand.
                    #[inline] pub fn get_visible_aliases(&self) -> impl Iterator<Item = &str> + '_ {
                        self.aliases
                            .iter()
                            .filter(|(_, vis)| *vis)
                            .map(|a| a.0.as_str())
                    }
                    /// Iterate through the *visible* short aliases for this subcommand.
                    #[inline] pub fn get_visible_short_flag_aliases(&self) -> impl Iterator<Item = char> + '_ {
                        self.short_flag_aliases
                            .iter()
                            .filter(|(_, vis)| *vis)
                            .map(|a| a.0)
                    }
                    /// Iterate through the *visible* long aliases for this subcommand.
                    #[inline] pub fn get_visible_long_flag_aliases(&self) -> impl Iterator<Item = &str> + '_ {
                        self.long_flag_aliases
                            .iter()
                            .filter(|(_, vis)| *vis)
                            .map(|a| a.0.as_str())
                    }
                    /// Iterate through the set of *all* the aliases for this subcommand, both visible and hidden.
                    #[inline] pub fn get_all_aliases(&self) -> impl Iterator<Item = &str> + '_ {
                        self.aliases.iter().map(|a| a.0.as_str())
                    }
                    /// Iterate through the set of *all* the short aliases for this subcommand, both visible and hidden.
                    #[inline] pub fn get_all_short_flag_aliases(&self) -> impl Iterator<Item = char> + '_ {
                        self.short_flag_aliases.iter().map(|a| a.0)
                    }
                    /// Iterate through the set of *all* the long aliases for this subcommand, both visible and hidden.
                    #[inline] pub fn get_all_long_flag_aliases(&self) -> impl Iterator<Item = &str> + '_ {
                        self.long_flag_aliases.iter().map(|a| a.0.as_str())
                    }
                    /// Iterate through the *hidden* aliases for this subcommand.
                    #[inline] pub fn get_aliases(&self) -> impl Iterator<Item = &str> + '_ {
                        self.aliases
                            .iter()
                            .filter(|(_, vis)| !*vis)
                            .map(|a| a.0.as_str())
                    }

                    #[inline] pub fn is_set(&self, s: AppSettings) -> bool {
                        self.settings.is_set(s) || self.g_settings.is_set(s)
                    }
                    /// Should we color the output?
                    pub fn get_color(&self) -> ColorChoice {
                        debug!("Command::color: Color setting...");

                        if cfg!(feature = "color") {
                            if self.is_set(AppSettings::ColorNever) {
                                debug!("Never");
                                ColorChoice::Never
                            } else if self.is_set(AppSettings::ColorAlways) {
                                debug!("Always");
                                ColorChoice::Always
                            } else {
                                debug!("Auto");
                                ColorChoice::Auto
                            }
                        } else {
                            ColorChoice::Never
                        }
                    }
                    /// Return the current `Styles` for the `Command`
                    #[inline] pub fn get_styles(&self) -> &Styles {
                        self.app_ext.get().unwrap_or_default()
                    }
                    /// Iterate through the set of subcommands, getting a reference to each.
                    #[inline] pub fn get_subcommands(&self) -> impl Iterator<Item = &Command> {
                        self.subcommands.iter()
                    }
                    /// Iterate through the set of subcommands, getting a mutable reference to each.
                    #[inline] pub fn get_subcommands_mut(&mut self) -> impl Iterator<Item = &mut Command> {
                        self.subcommands.iter_mut()
                    }
                    /// Returns `true` if this `Command` has subcommands.
                    #[inline] pub fn has_subcommands(&self) -> bool {
                        !self.subcommands.is_empty()
                    }
                    /// Returns the help heading for listing subcommands.
                    #[inline] pub fn get_subcommand_help_heading(&self) -> Option<&str> {
                        self.subcommand_heading.as_deref()
                    }
                    /// Returns the subcommand value name.
                    #[inline] pub fn get_subcommand_value_name(&self) -> Option<&str> {
                        self.subcommand_value_name.as_deref()
                    }
                    /// Returns the help heading for listing subcommands.
                    #[inline] pub fn get_before_help(&self) -> Option<&StyledStr> {
                        self.before_help.as_ref()
                    }
                    /// Returns the help heading for listing subcommands.
                    #[inline] pub fn get_before_long_help(&self) -> Option<&StyledStr> {
                        self.before_long_help.as_ref()
                    }
                    /// Returns the help heading for listing subcommands.
                    #[inline] pub fn get_after_help(&self) -> Option<&StyledStr> {
                        self.after_help.as_ref()
                    }
                    /// Returns the help heading for listing subcommands.
                    #[inline] pub fn get_after_long_help(&self) -> Option<&StyledStr> {
                        self.after_long_help.as_ref()
                    }
                    /// Find subcommand such that its name or one of aliases equals `name`.
                    #[inline] pub fn find_subcommand(&self, name: impl AsRef<std::ffi::OsStr>) -> Option<&Command> {
                        let name = name.as_ref();
                        self.get_subcommands().find(|s| s.aliases_to(name))
                    }
                    /// Find subcommand such that its name or one of aliases equals `name`, returning a mutable reference to the subcommand.
                    #[inline] pub fn find_subcommand_mut(
                        &mut self,
                        name: impl AsRef<std::ffi::OsStr>,
                    ) -> Option<&mut Command> {
                        let name = name.as_ref();
                        self.get_subcommands_mut().find(|s| s.aliases_to(name))
                    }
                    /// Iterate through the set of groups.
                    #[inline] pub fn get_groups(&self) -> impl Iterator<Item = &ArgGroup> {
                        self.groups.iter()
                    }
                    /// Iterate through the set of arguments.
                    #[inline] pub fn get_arguments(&self) -> impl Iterator<Item = &Arg> {
                        self.args.args()
                    }
                    /// Iterate through the *positionals* arguments.
                    #[inline] pub fn get_positionals(&self) -> impl Iterator<Item = &Arg> {
                        self.get_arguments().filter(|a| a.is_positional())
                    }
                    /// Iterate through the *options*.
                    pub fn get_opts(&self) -> impl Iterator<Item = &Arg> {
                        self.get_arguments()
                            .filter(|a| a.is_takes_value_set() && !a.is_positional())
                    }
                    /// Get a list of all arguments the given argument conflicts with.
                    pub fn get_arg_conflicts_with(&self, arg: &Arg) -> Vec<&Arg> // FIXME: This could probably have been an iterator
                    {
                        if arg.is_global_set() {
                            self.get_global_arg_conflicts_with(arg)
                        } else {
                            let mut result = Vec::new();
                            for id in arg.blacklist.iter() {
                                if let Some(arg) = self.find(id) {
                                    result.push(arg);
                                } else if let Some(group) = self.find_group(id) {
                                    result.extend(
                                        self.unroll_args_in_group(&group.id)
                                            .iter()
                                            .map(|id| self.find(id).expect(INTERNAL_ERROR_MSG)),
                                    );
                                } else {
                                    panic!("Command::get_arg_conflicts_with: The passed arg conflicts with an arg unknown to the cmd");
                                }
                            }
                            result
                        }
                    }
                    /// Get a unique list of all arguments of all commands and continuous subcommands the given argument conflicts with.
                    fn get_global_arg_conflicts_with(&self, arg: &Arg) -> Vec<&Arg> // FIXME: This could probably have been an iterator
                    {
                        arg.blacklist
                            .iter()
                            .map(|id| {
                                self.args
                                    .args()
                                    .chain(
                                        self.get_subcommands_containing(arg)
                                            .iter()
                                            .flat_map(|x| x.args.args()),
                                    )
                                    .find(|arg| arg.get_id() == id)
                                    .expect(
                                        "Command::get_arg_conflicts_with: \
                                    The passed arg conflicts with an arg unknown to the cmd",
                                    )
                            })
                            .collect()
                    }
                    /// Get a list of subcommands which contain the provided Argument
                    fn get_subcommands_containing(&self, arg: &Arg) -> Vec<&Self> {
                        let mut vec = Vec::new();
                        for idx in 0..self.subcommands.len() {
                            if self.subcommands[idx]
                                .args
                                .args()
                                .any(|ar| ar.get_id() == arg.get_id())
                            {
                                vec.push(&self.subcommands[idx]);
                                vec.append(&mut self.subcommands[idx].get_subcommands_containing(arg));
                            }
                        }
                        vec
                    }
                    /// Report whether [`Command::no_binary_name`] is set
                    pub fn is_no_binary_name_set(&self) -> bool {
                        self.is_set(AppSettings::NoBinaryName)
                    }
                    /// Report whether [`Command::ignore_errors`] is set
                    pub fn is_ignore_errors_set(&self) -> bool {
                        self.is_set(AppSettings::IgnoreErrors)
                    }
                    /// Report whether [`Command::dont_delimit_trailing_values`] is set
                    pub fn is_dont_delimit_trailing_values_set(&self) -> bool {
                        self.is_set(AppSettings::DontDelimitTrailingValues)
                    }
                    /// Report whether [`Command::disable_version_flag`] is set
                    pub fn is_disable_version_flag_set(&self) -> bool {
                        self.is_set(AppSettings::DisableVersionFlag)
                            || (self.version.is_none() && self.long_version.is_none())
                    }
                    /// Report whether [`Command::propagate_version`] is set
                    pub fn is_propagate_version_set(&self) -> bool {
                        self.is_set(AppSettings::PropagateVersion)
                    }
                    /// Report whether [`Command::next_line_help`] is set
                    pub fn is_next_line_help_set(&self) -> bool {
                        self.is_set(AppSettings::NextLineHelp)
                    }
                    /// Report whether [`Command::disable_help_flag`] is set
                    pub fn is_disable_help_flag_set(&self) -> bool {
                        self.is_set(AppSettings::DisableHelpFlag)
                    }
                    /// Report whether [`Command::disable_help_subcommand`] is set
                    pub fn is_disable_help_subcommand_set(&self) -> bool {
                        self.is_set(AppSettings::DisableHelpSubcommand)
                    }
                    /// Report whether [`Command::disable_colored_help`] is set
                    pub fn is_disable_colored_help_set(&self) -> bool {
                        self.is_set(AppSettings::DisableColoredHelp)
                    }
                    /// Report whether [`Command::help_expected`] is set
                    #[cfg(debug_assertions)]
                    pub fn is_help_expected_set(&self) -> bool {
                        self.is_set(AppSettings::HelpExpected)
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "This is now the default")
                    )]
                    pub fn is_dont_collapse_args_in_usage_set(&self) -> bool {
                        true
                    }
                    /// Report whether [`Command::infer_long_args`] is set
                    pub fn is_infer_long_args_set(&self) -> bool {
                        self.is_set(AppSettings::InferLongArgs)
                    }
                    /// Report whether [`Command::infer_subcommands`] is set
                    pub fn is_infer_subcommands_set(&self) -> bool {
                        self.is_set(AppSettings::InferSubcommands)
                    }
                    /// Report whether [`Command::arg_required_else_help`] is set
                    pub fn is_arg_required_else_help_set(&self) -> bool {
                        self.is_set(AppSettings::ArgRequiredElseHelp)
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(
                            since = "4.0.0",
                            note = "Replaced with `Arg::is_allow_hyphen_values_set`"
                        )
                    )]
                    pub fn is_allow_hyphen_values_set(&self) -> bool {
                        self.is_set(AppSettings::AllowHyphenValues)
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(
                            since = "4.0.0",
                            note = "Replaced with `Arg::is_allow_negative_numbers_set`"
                        )
                    )]
                    pub fn is_allow_negative_numbers_set(&self) -> bool {
                        self.is_set(AppSettings::AllowNegativeNumbers)
                    }

                    #[doc(hidden)]
                    #[cfg_attr(
                        feature = "deprecated",
                        deprecated(since = "4.0.0", note = "Replaced with `Arg::is_trailing_var_arg_set`")
                    )]
                    pub fn is_trailing_var_arg_set(&self) -> bool {
                        self.is_set(AppSettings::TrailingVarArg)
                    }
                    /// Report whether [`Command::allow_missing_positional`] is set
                    pub fn is_allow_missing_positional_set(&self) -> bool {
                        self.is_set(AppSettings::AllowMissingPositional)
                    }
                    /// Report whether [`Command::hide`] is set
                    pub fn is_hide_set(&self) -> bool {
                        self.is_set(AppSettings::Hidden)
                    }
                    /// Report whether [`Command::subcommand_required`] is set
                    pub fn is_subcommand_required_set(&self) -> bool {
                        self.is_set(AppSettings::SubcommandRequired)
                    }
                    /// Report whether [`Command::allow_external_subcommands`] is set
                    pub fn is_allow_external_subcommands_set(&self) -> bool {
                        self.is_set(AppSettings::AllowExternalSubcommands)
                    }
                    /// Configured parser for values passed to an external subcommand.
                    pub fn get_external_subcommand_value_parser(&self) -> Option<&super::ValueParser> {
                        if !self.is_allow_external_subcommands_set() {
                            None
                        } else {
                            static DEFAULT: super::ValueParser = super::ValueParser::os_string();
                            Some(self.external_value_parser.as_ref().unwrap_or(&DEFAULT))
                        }
                    }
                    /// Report whether [`Command::args_conflicts_with_subcommands`] is set
                    pub fn is_args_conflicts_with_subcommands_set(&self) -> bool {
                        self.is_set(AppSettings::ArgsNegateSubcommands)
                    }

                    #[doc(hidden)]
                    pub fn is_args_override_self(&self) -> bool {
                        self.is_set(AppSettings::AllArgsOverrideSelf)
                    }
                    /// Report whether [`Command::subcommand_precedence_over_arg`] is set
                    pub fn is_subcommand_precedence_over_arg_set(&self) -> bool {
                        self.is_set(AppSettings::SubcommandPrecedenceOverArg)
                    }
                    /// Report whether [`Command::subcommand_negates_reqs`] is set
                    pub fn is_subcommand_negates_reqs_set(&self) -> bool {
                        self.is_set(AppSettings::SubcommandsNegateReqs)
                    }
                    /// Report whether [`Command::multicall`] is set
                    pub fn is_multicall_set(&self) -> bool {
                        self.is_set(AppSettings::Multicall)
                    }
                    /// Access an [`CommandExt`]
                    
                    pub fn get<T: CommandExt + Extension>(&self) -> Option<&T> {
                        self.ext.get::<T>()
                    }
                    /// Remove an [`CommandExt`]
                    
                    pub fn remove<T: CommandExt + Extension>(mut self) -> Option<T> {
                        self.ext.remove::<T>()
                    }
                }
                
                impl Command 
                {
                    pub fn get_override_usage(&self) -> Option<&StyledStr> {
                        self.usage_str.as_ref()
                    }

                    pub fn get_override_help(&self) -> Option<&StyledStr> {
                        self.help_str.as_ref()
                    }

                    #[cfg(feature = "help")]
                    pub fn get_help_template(&self) -> Option<&StyledStr> {
                        self.template.as_ref()
                    }

                    #[cfg(feature = "help")]
                    pub fn get_term_width(&self) -> Option<usize> {
                        self.app_ext.get::<TermWidth>().map(|e| e.0)
                    }

                    #[cfg(feature = "help")]
                    pub fn get_max_term_width(&self) -> Option<usize> {
                        self.app_ext.get::<MaxTermWidth>().map(|e| e.0)
                    }

                    pub fn get_keymap(&self) -> &MKeyMap {
                        &self.args
                    }

                    fn get_used_global_args(&self, matches: &ArgMatches, global_arg_vec: &mut Vec<Id>) {
                        global_arg_vec.extend(
                            self.args
                                .args()
                                .filter(|a| a.is_global_set())
                                .map(|ga| ga.id.clone()),
                        );
                        if let Some((id, matches)) = matches.subcommand() {
                            if let Some(used_sub) = self.find_subcommand(id) {
                                used_sub.get_used_global_args(matches, global_arg_vec);
                            }
                        }
                    }

                    fn _do_parse(
                        &mut self,
                        raw_args: &mut clap_lex::RawArgs,
                        args_cursor: clap_lex::ArgCursor,
                    ) -> ClapResult<ArgMatches> {
                        debug!("Command::_do_parse");

                        // If there are global arguments, or settings we need to propagate them down to subcommands
                        // before parsing in case we run into a subcommand
                        self._build_self(false);

                        let mut matcher = ArgMatcher::new(self);

                        // do the real parsing
                        let mut parser = Parser::new(self);
                        if let Err(error) = parser.get_matches_with(&mut matcher, raw_args, args_cursor) {
                            if self.is_set(AppSettings::IgnoreErrors) && error.use_stderr() {
                                debug!("Command::_do_parse: ignoring error: {error}");
                            } else {
                                return Err(error);
                            }
                        }

                        let mut global_arg_vec = Default::default();
                        self.get_used_global_args(&matcher, &mut global_arg_vec);

                        matcher.propagate_globals(&global_arg_vec);

                        Ok(matcher.into_inner())
                    }
                    /// Prepare for introspecting on all included [`Command`]s
                    ///
                    /// Call this on the top-level [`Command`] when done building and before reading state for
                    /// cases like completions, custom help output, etc.
                    pub fn build(&mut self) {
                        self._build_recursive(true);
                        self._build_bin_names_internal();
                    }

                    pub fn _build_recursive(&mut self, expand_help_tree: bool) {
                        self._build_self(expand_help_tree);
                        for subcmd in self.get_subcommands_mut() {
                            subcmd._build_recursive(expand_help_tree);
                        }
                    }

                    pub fn _build_self(&mut self, expand_help_tree: bool) {
                        debug!("Command::_build: name={:?}", self.get_name());
                        if !self.settings.is_set(AppSettings::Built) {
                            if let Some(deferred) = self.deferred.take() {
                                *self = (deferred)(std::mem::take(self));
                            }

                            // Make sure all the globally set flags apply to us as well
                            self.settings = self.settings | self.g_settings;

                            if self.is_multicall_set() {
                                self.settings.set(AppSettings::SubcommandRequired);
                                self.settings.set(AppSettings::DisableHelpFlag);
                                self.settings.set(AppSettings::DisableVersionFlag);
                            }
                            if !cfg!(feature = "help") && self.get_override_help().is_none() {
                                self.settings.set(AppSettings::DisableHelpFlag);
                                self.settings.set(AppSettings::DisableHelpSubcommand);
                            }
                            if self.is_set(AppSettings::ArgsNegateSubcommands) {
                                self.settings.set(AppSettings::SubcommandsNegateReqs);
                            }
                            if self.external_value_parser.is_some() {
                                self.settings.set(AppSettings::AllowExternalSubcommands);
                            }
                            if !self.has_subcommands() {
                                self.settings.set(AppSettings::DisableHelpSubcommand);
                            }

                            self._propagate();
                            self._check_help_and_version(expand_help_tree);
                            self._propagate_global_args();

                            let mut pos_counter = 1;
                            let hide_pv = self.is_set(AppSettings::HidePossibleValues);
                            for a in self.args.args_mut() {
                                // Fill in the groups
                                for g in &a.groups {
                                    if let Some(ag) = self.groups.iter_mut().find(|grp| grp.id == *g) {
                                        ag.args.push(a.get_id().clone());
                                    } else {
                                        let mut ag = ArgGroup::new(g);
                                        ag.args.push(a.get_id().clone());
                                        self.groups.push(ag);
                                    }
                                }

                                // Figure out implied settings
                                a._build();
                                if hide_pv && a.is_takes_value_set() {
                                    a.settings.set(ArgSettings::HidePossibleValues);
                                }
                                if a.is_positional() && a.index.is_none() {
                                    a.index = Some(pos_counter);
                                    pos_counter += 1;
                                }
                            }

                            self.args._build();

                            #[allow(deprecated)]
                            {
                                let highest_idx = self
                                    .get_keymap()
                                    .keys()
                                    .filter_map(|x| {
                                        if let crate::mkeymap::KeyType::Position(n) = x {
                                            Some(*n)
                                        } else {
                                            None
                                        }
                                    })
                                    .max()
                                    .unwrap_or(0);
                                let is_trailing_var_arg_set = self.is_trailing_var_arg_set();
                                let is_allow_hyphen_values_set = self.is_allow_hyphen_values_set();
                                let is_allow_negative_numbers_set = self.is_allow_negative_numbers_set();
                                for arg in self.args.args_mut() {
                                    if is_allow_hyphen_values_set && arg.is_takes_value_set() {
                                        arg.settings.set(ArgSettings::AllowHyphenValues);
                                    }
                                    if is_allow_negative_numbers_set && arg.is_takes_value_set() {
                                        arg.settings.set(ArgSettings::AllowNegativeNumbers);
                                    }
                                    if is_trailing_var_arg_set && arg.get_index() == Some(highest_idx) {
                                        arg.settings.set(ArgSettings::TrailingVarArg);
                                    }
                                }
                            }

                            #[cfg(debug_assertions)]
                            assert_app(self);
                            self.settings.set(AppSettings::Built);
                        } else {
                            debug!("Command::_build: already built");
                        }
                    }

                    pub fn _build_subcommand(&mut self, name: &str) -> Option<&mut Self> {
                        use std::fmt::Write;

                        let mut mid_string = String::from(" ");
                        #[cfg(feature = "usage")]
                        if !self.is_subcommand_negates_reqs_set() && !self.is_args_conflicts_with_subcommands_set()
                        {
                            let reqs = Usage::new(self).get_required_usage_from(&[], None, true); // maybe Some(m)

                            for s in &reqs {
                                mid_string.push_str(&s.to_string());
                                mid_string.push(' ');
                            }
                        }
                        let is_multicall_set = self.is_multicall_set();

                        let sc = some!(self.subcommands.iter_mut().find(|s| s.name == name));

                        // Display subcommand name, short and long in usage
                        let mut sc_names = String::new();
                        sc_names.push_str(sc.name.as_str());
                        let mut flag_subcmd = false;
                        if let Some(l) = sc.get_long_flag() {
                            write!(sc_names, "|--{l}").unwrap();
                            flag_subcmd = true;
                        }
                        if let Some(s) = sc.get_short_flag() {
                            write!(sc_names, "|-{s}").unwrap();
                            flag_subcmd = true;
                        }

                        if flag_subcmd {
                            sc_names = format!("{{{sc_names}}}");
                        }

                        let usage_name = self
                            .bin_name
                            .as_ref()
                            .map(|bin_name| format!("{bin_name}{mid_string}{sc_names}"))
                            .unwrap_or(sc_names);
                        sc.usage_name = Some(usage_name);

                        // bin_name should be parent's bin_name + [<reqs>] + the sc's name separated by
                        // a space
                        let bin_name = format!(
                            "{}{}{}",
                            self.bin_name.as_deref().unwrap_or_default(),
                            if self.bin_name.is_some() { " " } else { "" },
                            &*sc.name
                        );
                        debug!(
                            "Command::_build_subcommand Setting bin_name of {} to {:?}",
                            sc.name, bin_name
                        );
                        sc.bin_name = Some(bin_name);

                        if sc.display_name.is_none() {
                            let self_display_name = if is_multicall_set {
                                self.display_name.as_deref().unwrap_or("")
                            } else {
                                self.display_name.as_deref().unwrap_or(&self.name)
                            };
                            let display_name = format!(
                                "{}{}{}",
                                self_display_name,
                                if !self_display_name.is_empty() {
                                    "-"
                                } else {
                                    ""
                                },
                                &*sc.name
                            );
                            debug!(
                                "Command::_build_subcommand Setting display_name of {} to {:?}",
                                sc.name, display_name
                            );
                            sc.display_name = Some(display_name);
                        }

                        // Ensure all args are built and ready to parse
                        sc._build_self(false);

                        Some(sc)
                    }

                    fn _build_bin_names_internal(&mut self) {
                        debug!("Command::_build_bin_names");

                        if !self.is_set(AppSettings::BinNameBuilt) {
                            let mut mid_string = String::from(" ");
                            #[cfg(feature = "usage")]
                            if !self.is_subcommand_negates_reqs_set()
                                && !self.is_args_conflicts_with_subcommands_set()
                            {
                                let reqs = Usage::new(self).get_required_usage_from(&[], None, true); // maybe Some(m)

                                for s in &reqs {
                                    mid_string.push_str(&s.to_string());
                                    mid_string.push(' ');
                                }
                            }
                            let is_multicall_set = self.is_multicall_set();

                            let self_bin_name = if is_multicall_set {
                                self.bin_name.as_deref().unwrap_or("")
                            } else {
                                self.bin_name.as_deref().unwrap_or(&self.name)
                            }
                            .to_owned();

                            for sc in &mut self.subcommands {
                                debug!("Command::_build_bin_names:iter: bin_name set...");

                                if sc.usage_name.is_none() {
                                    use std::fmt::Write;
                                    // Display subcommand name, short and long in usage
                                    let mut sc_names = String::new();
                                    sc_names.push_str(sc.name.as_str());
                                    let mut flag_subcmd = false;
                                    if let Some(l) = sc.get_long_flag() {
                                        write!(sc_names, "|--{l}").unwrap();
                                        flag_subcmd = true;
                                    }
                                    if let Some(s) = sc.get_short_flag() {
                                        write!(sc_names, "|-{s}").unwrap();
                                        flag_subcmd = true;
                                    }

                                    if flag_subcmd {
                                        sc_names = format!("{{{sc_names}}}");
                                    }

                                    let usage_name = format!("{self_bin_name}{mid_string}{sc_names}");
                                    debug!(
                                        "Command::_build_bin_names:iter: Setting usage_name of {} to {:?}",
                                        sc.name, usage_name
                                    );
                                    sc.usage_name = Some(usage_name);
                                } else {
                                    debug!(
                                        "Command::_build_bin_names::iter: Using existing usage_name of {} ({:?})",
                                        sc.name, sc.usage_name
                                    );
                                }

                                if sc.bin_name.is_none() {
                                    let bin_name = format!(
                                        "{}{}{}",
                                        self_bin_name,
                                        if !self_bin_name.is_empty() { " " } else { "" },
                                        &*sc.name
                                    );
                                    debug!(
                                        "Command::_build_bin_names:iter: Setting bin_name of {} to {:?}",
                                        sc.name, bin_name
                                    );
                                    sc.bin_name = Some(bin_name);
                                } else {
                                    debug!(
                                        "Command::_build_bin_names::iter: Using existing bin_name of {} ({:?})",
                                        sc.name, sc.bin_name
                                    );
                                }

                                if sc.display_name.is_none() {
                                    let self_display_name = if is_multicall_set {
                                        self.display_name.as_deref().unwrap_or("")
                                    } else {
                                        self.display_name.as_deref().unwrap_or(&self.name)
                                    };
                                    let display_name = format!(
                                        "{}{}{}",
                                        self_display_name,
                                        if !self_display_name.is_empty() {
                                            "-"
                                        } else {
                                            ""
                                        },
                                        &*sc.name
                                    );
                                    debug!(
                                        "Command::_build_bin_names:iter: Setting display_name of {} to {:?}",
                                        sc.name, display_name
                                    );
                                    sc.display_name = Some(display_name);
                                } else {
                                    debug!(
                                        "Command::_build_bin_names::iter: Using existing display_name of {} ({:?})",
                                        sc.name, sc.display_name
                                    );
                                }

                                sc._build_bin_names_internal();
                            }
                            self.set(AppSettings::BinNameBuilt);
                        } else {
                            debug!("Command::_build_bin_names: already built");
                        }
                    }

                    pub fn _panic_on_missing_help(&self, help_required_globally: bool) {
                        if self.is_set(AppSettings::HelpExpected) || help_required_globally {
                            let args_missing_help: Vec<Id> = self
                                .args
                                .args()
                                .filter(|arg| arg.get_help().is_none() && arg.get_long_help().is_none())
                                .map(|arg| arg.get_id().clone())
                                .collect();

                            debug_assert!(args_missing_help.is_empty(),
                                    "Command::help_expected is enabled for the Command {}, but at least one of its arguments does not have either `help` or `long_help` set. List of such arguments: {}",
                                    self.name,
                                    args_missing_help.join(", ")
                                );
                        }

                        for sub_app in &self.subcommands {
                            sub_app._panic_on_missing_help(help_required_globally);
                        }
                    }

                    #[cfg(debug_assertions)]
                    pub fn two_args_of<F>(&self, condition: F) -> Option<(&Arg, &Arg)>
                    where
                        F: Fn(&Arg) -> bool,
                    {
                        two_elements_of(self.args.args().filter(|a: &&Arg| condition(a)))
                    }

                    // just in case
                    #[allow(unused)]
                    fn two_groups_of<F>(&self, condition: F) -> Option<(&ArgGroup, &ArgGroup)>
                    where
                        F: Fn(&ArgGroup) -> bool,
                    {
                        two_elements_of(self.groups.iter().filter(|a| condition(a)))
                    }
                    /// Propagate global args
                    pub fn _propagate_global_args(&mut self) {
                        debug!("Command::_propagate_global_args:{}", self.name);

                        let autogenerated_help_subcommand = !self.is_disable_help_subcommand_set();

                        for sc in &mut self.subcommands {
                            if sc.get_name() == "help" && autogenerated_help_subcommand {
                                // Avoid propagating args to the autogenerated help subtrees used in completion.
                                // This prevents args from showing up during help completions like
                                // `myapp help subcmd <TAB>`, which should only suggest subcommands and not args,
                                // while still allowing args to show up properly on the generated help message.
                                continue;
                            }

                            for a in self.args.args().filter(|a| a.is_global_set()) {
                                if sc.find(&a.id).is_some() {
                                    debug!(
                                        "Command::_propagate skipping {:?} to {}, already exists",
                                        a.id,
                                        sc.get_name(),
                                    );
                                    continue;
                                }

                                debug!(
                                    "Command::_propagate pushing {:?} to {}",
                                    a.id,
                                    sc.get_name(),
                                );
                                sc.args.push(a.clone());
                            }
                        }
                    }
                    /// Propagate settings
                    pub fn _propagate(&mut self) {
                        debug!("Command::_propagate:{}", self.name);
                        let mut subcommands = std::mem::take(&mut self.subcommands);
                        for sc in &mut subcommands {
                            self._propagate_subcommand(sc);
                        }
                        self.subcommands = subcommands;
                    }

                    fn _propagate_subcommand(&self, sc: &mut Self) {
                        // We have to create a new scope in order to tell rustc the borrow of `sc` is
                        // done and to recursively call this method
                        {
                            if self.settings.is_set(AppSettings::PropagateVersion) {
                                if let Some(version) = self.version.as_ref() {
                                    sc.version.get_or_insert_with(|| version.clone());
                                }
                                if let Some(long_version) = self.long_version.as_ref() {
                                    sc.long_version.get_or_insert_with(|| long_version.clone());
                                }
                            }

                            sc.settings = sc.settings | self.g_settings;
                            sc.g_settings = sc.g_settings | self.g_settings;
                            sc.app_ext.update(&self.app_ext);
                        }
                    }

                    pub fn _check_help_and_version(&mut self, expand_help_tree: bool) {
                        debug!(
                            "Command::_check_help_and_version:{} expand_help_tree={}",
                            self.name, expand_help_tree
                        );

                        self.long_help_exists = self.long_help_exists_();

                        if !self.is_disable_help_flag_set() {
                            debug!("Command::_check_help_and_version: Building default --help");
                            let mut arg = Arg::new(Id::HELP)
                                .short('h')
                                .long("help")
                                .action(ArgAction::Help);
                            if self.long_help_exists {
                                arg = arg
                                    .help("Print help (see more with '--help')")
                                    .long_help("Print help (see a summary with '-h')");
                            } else {
                                arg = arg.help("Print help");
                            }
                            // Avoiding `arg_internal` to not be sensitive to `next_help_heading` /
                            // `next_display_order`
                            self.args.push(arg);
                        }
                        if !self.is_disable_version_flag_set() {
                            debug!("Command::_check_help_and_version: Building default --version");
                            let arg = Arg::new(Id::VERSION)
                                .short('V')
                                .long("version")
                                .action(ArgAction::Version)
                                .help("Print version");
                            // Avoiding `arg_internal` to not be sensitive to `next_help_heading` /
                            // `next_display_order`
                            self.args.push(arg);
                        }

                        if !self.is_set(AppSettings::DisableHelpSubcommand) {
                            debug!("Command::_check_help_and_version: Building help subcommand");
                            let help_about = "Print this message or the help of the given subcommand(s)";

                            let mut help_subcmd = if expand_help_tree {
                                // Slow code path to recursively clone all other subcommand subtrees under help
                                let help_subcmd = Command::new("help")
                                    .about(help_about)
                                    .global_setting(AppSettings::DisableHelpSubcommand)
                                    .subcommands(self.get_subcommands().map(Command::_copy_subtree_for_help));

                                let mut help_help_subcmd = Command::new("help").about(help_about);
                                help_help_subcmd.version = None;
                                help_help_subcmd.long_version = None;
                                help_help_subcmd = help_help_subcmd
                                    .setting(AppSettings::DisableHelpFlag)
                                    .setting(AppSettings::DisableVersionFlag);

                                help_subcmd.subcommand(help_help_subcmd)
                            } else {
                                Command::new("help").about(help_about).arg(
                                    Arg::new("subcommand")
                                        .action(ArgAction::Append)
                                        .num_args(..)
                                        .value_name("COMMAND")
                                        .help("Print help for the subcommand(s)"),
                                )
                            };
                            self._propagate_subcommand(&mut help_subcmd);

                            // The parser acts like this is set, so let's set it so we don't falsely
                            // advertise it to the user
                            help_subcmd.version = None;
                            help_subcmd.long_version = None;
                            help_subcmd = help_subcmd
                                .setting(AppSettings::DisableHelpFlag)
                                .setting(AppSettings::DisableVersionFlag)
                                .unset_global_setting(AppSettings::PropagateVersion);

                            self.subcommands.push(help_subcmd);
                        }
                    }

                    fn _copy_subtree_for_help(&self) -> Command {
                        let mut cmd = Command::new(self.name.clone())
                            .hide(self.is_hide_set())
                            .global_setting(AppSettings::DisableHelpFlag)
                            .global_setting(AppSettings::DisableVersionFlag)
                            .subcommands(self.get_subcommands().map(Command::_copy_subtree_for_help));
                        if self.get_about().is_some() {
                            cmd = cmd.about(self.get_about().unwrap().clone());
                        }
                        cmd
                    }

                    pub fn _render_version(&self, use_long: bool) -> String {
                        debug!("Command::_render_version");

                        let ver = if use_long {
                            self.long_version
                                .as_deref()
                                .or(self.version.as_deref())
                                .unwrap_or_default()
                        } else {
                            self.version
                                .as_deref()
                                .or(self.long_version.as_deref())
                                .unwrap_or_default()
                        };
                        let display_name = self.get_display_name().unwrap_or_else(|| self.get_name());
                        format!("{display_name} {ver}\n")
                    }

                    pub fn format_group(&self, g: &Id) -> StyledStr {
                        use std::fmt::Write as _;

                        let g_string = self
                            .unroll_args_in_group(g)
                            .iter()
                            .filter_map(|x| self.find(x))
                            .map(|x| {
                                if x.is_positional() {
                                    // Print val_name for positional arguments. e.g. <file_name>
                                    x.name_no_brackets()
                                } else {
                                    // Print usage string for flags arguments, e.g. <--help>
                                    x.to_string()
                                }
                            })
                            .collect::<Vec<_>>()
                            .join("|");
                        let placeholder = self.get_styles().get_placeholder();
                        let mut styled = StyledStr::new();
                        write!(&mut styled, "{placeholder}<{g_string}>{placeholder:#}").unwrap();
                        styled
                    }
                }
                /// A workaround:
                /// <https://github.com/rust-lang/rust/issues/34511#issuecomment-373423999>
                pub trait Captures<'a> {}
                impl<T> Captures<'_> for T {}

                // Internal Query Methods
                impl Command 
                {
                    /// Iterate through the *flags* & *options* arguments.
                    #[cfg(any(feature = "usage", feature = "help"))]
                    pub fn get_non_positionals(&self) -> impl Iterator<Item = &Arg> {
                        self.get_arguments().filter(|a| !a.is_positional())
                    }

                    pub fn find(&self, arg_id: &Id) -> Option<&Arg> {
                        self.args.args().find(|a| a.get_id() == arg_id)
                    }

                    #[inline] pub fn contains_short(&self, s: char) -> bool {
                        debug_assert!(
                            self.is_set(AppSettings::Built),
                            "If Command::_build hasn't been called, manually search through Arg shorts"
                        );

                        self.args.contains(s)
                    }

                    #[inline] pub fn set(&mut self, s: AppSettings) {
                        self.settings.set(s);
                    }

                    #[inline] pub fn has_positionals(&self) -> bool {
                        self.get_positionals().next().is_some()
                    }

                    #[cfg(any(feature = "usage", feature = "help"))]
                    pub fn has_visible_subcommands(&self) -> bool {
                        self.subcommands
                            .iter()
                            .any(|sc| sc.name != "help" && !sc.is_set(AppSettings::Hidden))
                    }
                    /// Check if this subcommand can be referred to as `name`. In other words,
                    /// check if `name` is the name of this subcommand or is one of its aliases.
                    #[inline] pub fn aliases_to(&self, name: impl AsRef<std::ffi::OsStr>) -> bool {
                        let name = name.as_ref();
                        self.get_name() == name || self.get_all_aliases().any(|alias| alias == name)
                    }
                    /// Check if this subcommand can be referred to as `name`. In other words,
                    /// check if `name` is the name of this short flag subcommand or is one of its short flag aliases.
                    #[inline] pub fn short_flag_aliases_to(&self, flag: char) -> bool {
                        Some(flag) == self.short_flag
                            || self.get_all_short_flag_aliases().any(|alias| flag == alias)
                    }
                    /// Check if this subcommand can be referred to as `name`. In other words,
                    /// check if `name` is the name of this long flag subcommand or is one of its long flag aliases.
                    #[inline] pub fn long_flag_aliases_to(&self, flag: &str) -> bool {
                        match self.long_flag.as_ref() {
                            Some(long_flag) => {
                                long_flag == flag || self.get_all_long_flag_aliases().any(|alias| alias == flag)
                            }
                            None => self.get_all_long_flag_aliases().any(|alias| alias == flag),
                        }
                    }

                    #[cfg(debug_assertions)]
                    pub fn id_exists(&self, id: &Id) -> bool {
                        self.args.args().any(|x| x.get_id() == id) || self.groups.iter().any(|x| x.id == *id)
                    }
                    /// Iterate through the groups this arg is member of.
                    pub fn groups_for_arg<'a>(&'a self, arg: &Id) -> impl Iterator<Item = Id> + 'a {
                        debug!("Command::groups_for_arg: id={arg:?}");
                        let arg = arg.clone();
                        self.groups
                            .iter()
                            .filter(move |grp| grp.args.iter().any(|a| a == &arg))
                            .map(|grp| grp.id.clone())
                    }

                    pub fn find_group(&self, group_id: &Id) -> Option<&ArgGroup> {
                        self.groups.iter().find(|g| g.id == *group_id)
                    }
                    /// Iterate through all the names of all subcommands (not recursively), including aliases.
                    /// Used for suggestions.
                    pub fn all_subcommand_names(&self) -> impl Iterator<Item = &str> + Captures<'_> {
                        self.get_subcommands().flat_map(|sc| {
                            let name = sc.get_name();
                            let aliases = sc.get_all_aliases();
                            std::iter::once(name).chain(aliases)
                        })
                    }

                    pub fn required_graph(&self) -> ChildGraph<Id> {
                        let mut reqs = ChildGraph::with_capacity(5);
                        for a in self.args.args().filter(|a| a.is_required_set()) {
                            reqs.insert(a.get_id().clone());
                        }
                        for group in &self.groups {
                            if group.required {
                                let idx = reqs.insert(group.id.clone());
                                for a in &group.requires {
                                    reqs.insert_child(idx, a.clone());
                                }
                            }
                        }

                        reqs
                    }

                    pub fn unroll_args_in_group(&self, group: &Id) -> Vec<Id> {
                        debug!("Command::unroll_args_in_group: group={group:?}");
                        let mut g_vec = vec![group];
                        let mut args = vec![];

                        while let Some(g) = g_vec.pop() {
                            for n in self
                                .groups
                                .iter()
                                .find(|grp| grp.id == *g)
                                .expect(INTERNAL_ERROR_MSG)
                                .args
                                .iter()
                            {
                                debug!("Command::unroll_args_in_group:iter: entity={n:?}");
                                if !args.contains(n) {
                                    if self.find(n).is_some() {
                                        debug!("Command::unroll_args_in_group:iter: this is an arg");
                                        args.push(n.clone());
                                    } else {
                                        debug!("Command::unroll_args_in_group:iter: this is a group");
                                        g_vec.push(n);
                                    }
                                }
                            }
                        }

                        args
                    }

                    pub fn unroll_arg_requires<F>(&self, func: F, arg: &Id) -> Vec<Id>
                    where
                        F: Fn(&(ArgPredicate, Id)) -> Option<Id>,
                    {
                        let mut processed = vec![];
                        let mut r_vec = vec![arg];
                        let mut args = vec![];

                        while let Some(a) = r_vec.pop() {
                            if processed.contains(&a) {
                                continue;
                            }

                            processed.push(a);

                            if let Some(arg) = self.find(a) {
                                for r in arg.requires.iter().filter_map(&func) {
                                    if let Some(req) = self.find(&r) {
                                        if !req.requires.is_empty() {
                                            r_vec.push(req.get_id());
                                        }
                                    }
                                    args.push(r);
                                }
                            }
                        }

                        args
                    }
                    /// Find a flag subcommand name by short flag or an alias
                    pub fn find_short_subcmd(&self, c: char) -> Option<&str> {
                        self.get_subcommands()
                            .find(|sc| sc.short_flag_aliases_to(c))
                            .map(|sc| sc.get_name())
                    }
                    /// Find a flag subcommand name by long flag or an alias
                    pub fn find_long_subcmd(&self, long: &str) -> Option<&str> {
                        self.get_subcommands()
                            .find(|sc| sc.long_flag_aliases_to(long))
                            .map(|sc| sc.get_name())
                    }

                    pub fn write_help_err(&self, mut use_long: bool) -> StyledStr {
                        debug!(
                            "Command::write_help_err: {}, use_long={:?}",
                            self.get_display_name().unwrap_or_else(|| self.get_name()),
                            use_long && self.long_help_exists(),
                        );

                        use_long = use_long && self.long_help_exists();
                        let usage = Usage::new(self);

                        let mut styled = StyledStr::new();
                        write_help(&mut styled, self, &usage, use_long);

                        styled
                    }

                    pub fn write_version_err(&self, use_long: bool) -> StyledStr {
                        let msg = self._render_version(use_long);
                        StyledStr::from(msg)
                    }

                    pub fn long_help_exists(&self) -> bool {
                        debug!("Command::long_help_exists: {}", self.long_help_exists);
                        self.long_help_exists
                    }

                    fn long_help_exists_(&self) -> bool {
                        debug!("Command::long_help_exists");
                        // In this case, both must be checked. This allows the retention of
                        // original formatting, but also ensures that the actual -h or --help
                        // specified by the user is sent through. If hide_short_help is not included,
                        // then items specified with hidden_short_help will also be hidden.
                        let should_long = |v: &Arg| {
                            !v.is_hide_set()
                                && (v.get_long_help().is_some()
                                    || v.is_hide_long_help_set()
                                    || v.is_hide_short_help_set()
                                    || (!v.is_hide_possible_values_set()
                                        && v.get_possible_values()
                                            .iter()
                                            .any(PossibleValue::should_show_help)))
                        };

                        // Subcommands aren't checked because we prefer short help for them, deferring to
                        // `cmd subcmd --help` for more.
                        self.get_long_about().is_some()
                            || self.get_before_long_help().is_some()
                            || self.get_after_long_help().is_some()
                            || self.get_arguments().any(should_long)
                    }

                    // Should we color the help?
                    pub fn color_help(&self) -> ColorChoice {
                        #[cfg(feature = "color")]
                        if self.is_disable_colored_help_set() {
                            return ColorChoice::Never;
                        }

                        self.get_color()
                    }
                }

                impl Default for Command 
                {
                    fn default() -> Self {
                        Self {
                            name: Default::default(),
                            long_flag: Default::default(),
                            short_flag: Default::default(),
                            display_name: Default::default(),
                            bin_name: Default::default(),
                            author: Default::default(),
                            version: Default::default(),
                            long_version: Default::default(),
                            about: Default::default(),
                            long_about: Default::default(),
                            before_help: Default::default(),
                            before_long_help: Default::default(),
                            after_help: Default::default(),
                            after_long_help: Default::default(),
                            aliases: Default::default(),
                            short_flag_aliases: Default::default(),
                            long_flag_aliases: Default::default(),
                            usage_str: Default::default(),
                            usage_name: Default::default(),
                            help_str: Default::default(),
                            disp_ord: Default::default(),
                            #[cfg(feature = "help")]
                            template: Default::default(),
                            settings: Default::default(),
                            g_settings: Default::default(),
                            args: Default::default(),
                            subcommands: Default::default(),
                            groups: Default::default(),
                            current_help_heading: Default::default(),
                            current_disp_ord: Some(0),
                            subcommand_value_name: Default::default(),
                            subcommand_heading: Default::default(),
                            external_value_parser: Default::default(),
                            long_help_exists: false,
                            deferred: None,
                            
                            ext: Default::default(),
                            app_ext: Default::default(),
                        }
                    }
                }

                impl Index<&'_ Id> for Command 
                {
                    type Output = Arg;

                    fn index(&self, key: &Id) -> &Self::Output {
                        self.find(key).expect(INTERNAL_ERROR_MSG)
                    }
                }

                impl From<&'_ Command> for Command 
                {
                    fn from(cmd: &'_ Command) -> Self {
                        cmd.clone()
                    }
                }

                impl fmt::Display for Command 
                {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        write!(f, "{}", self.name)
                    }
                }
                /// User-provided data that can be attached to an [`Arg`]                
                pub trait CommandExt: Extension {}
                
                pub trait AppExt: Extension {}
                
                #[derive(Default, Copy, Clone, Debug)]
                struct TermWidth(usize);

                impl AppExt for TermWidth {}
                
                #[derive(Default, Copy, Clone, Debug)]
                struct MaxTermWidth(usize);

                impl AppExt for MaxTermWidth {}

                fn two_elements_of<I, T>(mut iter: I) -> Option<(T, T)> where
                    I: Iterator<Item = T>,
                {
                    let first = iter.next();
                    let second = iter.next();

                    match (first, second) {
                        (Some(first), Some(second)) => Some((first, second)),
                        _ => None,
                    }
                }
            }

            pub mod ext
            {
                use ::
                {
                    *,
                };
                /*
                use crate::util::AnyValue;
                use crate::util::AnyValueId;
                use crate::util::FlatMap;
                */

                #[derive(Default, Clone, Debug)]
                pub struct Extensions
                 {
                    extensions: FlatMap<AnyValueId, AnyValue>,
                }

                impl Extensions 
                {
                    
                    pub fn get<T: Extension>(&self) -> Option<&T> {
                        let id = AnyValueId::of::<T>();
                        self.extensions.get(&id).map(|e| {
                            e.downcast_ref::<T>()
                                .expect("`Extensions` tracks values by type")
                        })
                    }

                    
                    pub fn set<T: Extension>(&mut self, tagged: T) -> bool {
                        let value = AnyValue::new(tagged);
                        let id = value.type_id();
                        self.extensions.insert(id, value).is_some()
                    }

                    
                    pub fn remove<T: Extension>(&mut self) -> Option<T> {
                        let id = AnyValueId::of::<T>();
                        self.extensions.remove(&id).map(|e| {
                            e.downcast_into::<T>()
                                .expect("`Extensions` tracks values by type")
                        })
                    }

                    pub fn update(&mut self, other: &Self) {
                        for (key, value) in other.extensions.iter() {
                            self.extensions.insert(*key, value.clone());
                        }
                    }
                }
                
                pub trait Extension: std::fmt::Debug + Clone + std::any::Any + Send + Sync + 'static {}

                impl<T> Extension for T where T: std::fmt::Debug + Clone + std::any::Any + Send + Sync + 'static {}
            }

            pub mod os_str
            {
                use ::
                {
                    *,
                };
                use crate::builder::Str;

                /// A UTF-8-encoded fixed string.
                #[derive(Default, Clone, Eq, PartialEq, PartialOrd, Ord, Hash)]
                pub struct OsStr 
                {
                    name: Inner,
                }

                impl OsStr 
                {
                    #[cfg(feature = "string")]
                    pub fn from_string(name: std::ffi::OsString) -> Self {
                        Self {
                            name: Inner::from_string(name),
                        }
                    }

                    #[cfg(feature = "string")]
                    pub fn from_ref(name: &std::ffi::OsStr) -> Self {
                        Self {
                            name: Inner::from_ref(name),
                        }
                    }

                    pub fn from_static_ref(name: &'static std::ffi::OsStr) -> Self {
                        Self {
                            name: Inner::from_static_ref(name),
                        }
                    }
                    /// Get the raw string as an `std::ffi::OsStr`
                    pub fn as_os_str(&self) -> &std::ffi::OsStr {
                        self.name.as_os_str()
                    }
                    /// Get the raw string as an `OsString`
                    pub fn to_os_string(&self) -> std::ffi::OsString {
                        self.as_os_str().to_owned()
                    }
                }

                impl From<&'_ OsStr> for OsStr 
                {
                    fn from(id: &'_ OsStr) -> Self {
                        id.clone()
                    }
                }
                
                impl From<Str> for OsStr 
                {
                    fn from(id: Str) -> Self {
                        match id.into_inner() {
                            crate::builder::StrInner::Static(s) => Self::from_static_ref(std::ffi::OsStr::new(s)),
                            crate::builder::StrInner::Owned(s) => Self::from_ref(std::ffi::OsStr::new(s.as_ref())),
                        }
                    }
                }
                
                impl From<&'_ Str> for OsStr 
                {
                    fn from(id: &'_ Str) -> Self {
                        id.clone().into()
                    }
                }
                
                impl From<std::ffi::OsString> for OsStr 
                {
                    fn from(name: std::ffi::OsString) -> Self {
                        Self::from_string(name)
                    }
                }
                
                impl From<&'_ std::ffi::OsString> for OsStr 
                {
                    fn from(name: &'_ std::ffi::OsString) -> Self {
                        Self::from_ref(name.as_os_str())
                    }
                }
                
                impl From<String> for OsStr 
                {
                    fn from(name: String) -> Self {
                        Self::from_string(name.into())
                    }
                }
                
                impl From<&'_ String> for OsStr 
                {
                    fn from(name: &'_ String) -> Self {
                        Self::from_ref(name.as_str().as_ref())
                    }
                }

                impl From<&'static std::ffi::OsStr> for OsStr 
                {
                    fn from(name: &'static std::ffi::OsStr) -> Self {
                        Self::from_static_ref(name)
                    }
                }

                impl From<&'_ &'static std::ffi::OsStr> for OsStr 
                {
                    fn from(name: &'_ &'static std::ffi::OsStr) -> Self {
                        Self::from_static_ref(name)
                    }
                }

                impl From<&'static str> for OsStr 
                {
                    fn from(name: &'static str) -> Self {
                        Self::from_static_ref(name.as_ref())
                    }
                }

                impl From<&'_ &'static str> for OsStr 
                {
                    fn from(name: &'_ &'static str) -> Self {
                        Self::from_static_ref((*name).as_ref())
                    }
                }

                impl From<OsStr> for std::ffi::OsString 
                {
                    fn from(name: OsStr) -> Self {
                        name.name.into_os_string()
                    }
                }

                impl From<OsStr> for std::path::PathBuf 
                {
                    fn from(name: OsStr) -> Self {
                        std::ffi::OsString::from(name).into()
                    }
                }

                impl std::fmt::Debug for OsStr 
                {
                    #[inline]
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        std::fmt::Debug::fmt(self.as_os_str(), f)
                    }
                }

                impl std::ops::Deref for OsStr 
                {
                    type Target = std::ffi::OsStr;

                    #[inline]
                    fn deref(&self) -> &std::ffi::OsStr {
                        self.as_os_str()
                    }
                }

                impl AsRef<std::ffi::OsStr> for OsStr 
                {
                    #[inline]
                    fn as_ref(&self) -> &std::ffi::OsStr {
                        self.as_os_str()
                    }
                }

                impl AsRef<std::path::Path> for OsStr 
                {
                    #[inline]
                    fn as_ref(&self) -> &std::path::Path {
                        std::path::Path::new(self)
                    }
                }

                impl std::borrow::Borrow<std::ffi::OsStr> for OsStr 
                {
                    #[inline]
                    fn borrow(&self) -> &std::ffi::OsStr {
                        self.as_os_str()
                    }
                }

                impl PartialEq<str> for OsStr 
                {
                    #[inline]
                    fn eq(&self, other: &str) -> bool {
                        PartialEq::eq(self.as_os_str(), other)
                    }
                }
                impl PartialEq<OsStr> for str 
                {
                    #[inline]
                    fn eq(&self, other: &OsStr) -> bool {
                        PartialEq::eq(self, other.as_os_str())
                    }
                }

                impl PartialEq<&'_ str> for OsStr 
                {
                    #[inline]
                    fn eq(&self, other: &&str) -> bool {
                        PartialEq::eq(self.as_os_str(), *other)
                    }
                }
                impl PartialEq<OsStr> for &'_ str 
                {
                    #[inline]
                    fn eq(&self, other: &OsStr) -> bool {
                        PartialEq::eq(*self, other.as_os_str())
                    }
                }

                impl PartialEq<&'_ std::ffi::OsStr> for OsStr 
                {
                    #[inline]
                    fn eq(&self, other: &&std::ffi::OsStr) -> bool {
                        PartialEq::eq(self.as_os_str(), *other)
                    }
                }
                impl PartialEq<OsStr> for &'_ std::ffi::OsStr 
                {
                    #[inline]
                    fn eq(&self, other: &OsStr) -> bool {
                        PartialEq::eq(*self, other.as_os_str())
                    }
                }

                impl PartialEq<String> for OsStr 
                {
                    #[inline]
                    fn eq(&self, other: &String) -> bool {
                        PartialEq::eq(self.as_os_str(), other.as_str())
                    }
                }
                impl PartialEq<OsStr> for String 
                {
                    #[inline]
                    fn eq(&self, other: &OsStr) -> bool {
                        PartialEq::eq(self.as_str(), other.as_os_str())
                    }
                }

                impl PartialEq<std::ffi::OsString> for OsStr 
                {
                    #[inline]
                    fn eq(&self, other: &std::ffi::OsString) -> bool {
                        PartialEq::eq(self.as_os_str(), other.as_os_str())
                    }
                }
                impl PartialEq<OsStr> for std::ffi::OsString 
                {
                    #[inline]
                    fn eq(&self, other: &OsStr) -> bool {
                        PartialEq::eq(self.as_os_str(), other.as_os_str())
                    }
                }
                
                pub mod inner 
                {
                    #[derive(Clone)]
                    pub enum Inner {
                        Static(&'static std::ffi::OsStr),
                        Owned(Box<std::ffi::OsStr>),
                    }

                    impl Inner {
                        pub fn from_string(name: std::ffi::OsString) -> Self {
                            Self::Owned(name.into_boxed_os_str())
                        }

                        pub fn from_ref(name: &std::ffi::OsStr) -> Self {
                            Self::Owned(Box::from(name))
                        }

                        pub fn from_static_ref(name: &'static std::ffi::OsStr) -> Self {
                            Self::Static(name)
                        }

                        pub fn as_os_str(&self) -> &std::ffi::OsStr {
                            match self {
                                Self::Static(s) => s,
                                Self::Owned(s) => s.as_ref(),
                            }
                        }

                        pub fn into_os_string(self) -> std::ffi::OsString {
                            self.as_os_str().to_owned()
                        }
                    }
                }

                pub use inner::Inner;

                impl Default for Inner 
                {
                    fn default() -> Self {
                        Self::from_static_ref(std::ffi::OsStr::new(""))
                    }
                }

                impl PartialEq for Inner 
                {
                    fn eq(&self, other: &Inner) -> bool {
                        self.as_os_str() == other.as_os_str()
                    }
                }

                impl PartialOrd for Inner 
                {
                    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                        Some(self.cmp(other))
                    }
                }

                impl Ord for Inner 
                {
                    fn cmp(&self, other: &Inner) -> std::cmp::Ordering {
                        self.as_os_str().cmp(other.as_os_str())
                    }
                }

                impl Eq for Inner {}

                impl std::hash::Hash for Inner 
                {
                    #[inline]
                    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
                        self.as_os_str().hash(state);
                    }
                }
            }

            pub mod possible_value
            {
                use ::
                {
                    *,
                };
                /*
                use crate::builder::IntoResettable;
                use crate::builder::Str;
                use crate::builder::StyledStr;
                use crate::util::eq_ignore_case;
                */
                /// A possible value of an argument.
                #[derive(Debug, Default, Clone, PartialEq, Eq)]
                pub struct PossibleValue 
                {
                    name: Str,
                    help: Option<StyledStr>,
                    aliases: Vec<Str>, // (name, visible)
                    hide: bool,
                }

                impl PossibleValue 
                {
                    /// Create a [`PossibleValue`] with its name.
                    pub fn new(name: impl Into<Str>) -> Self {
                        PossibleValue {
                            name: name.into(),
                            ..Default::default()
                        }
                    }
                    /// Sets the help description of the value.
                    #[inline] #[must_use] pub fn help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
                        self.help = help.into_resettable().into_option();
                        self
                    }
                    /// Hides this value from help and shell completions.
                    #[inline] #[must_use] pub fn hide(mut self, yes: bool) -> Self {
                        self.hide = yes;
                        self
                    }
                    /// Sets a *hidden* alias for this argument value.
                    #[must_use] pub fn alias(mut self, name: impl IntoResettable<Str>) -> Self {
                        if let Some(name) = name.into_resettable().into_option() {
                            self.aliases.push(name);
                        } else {
                            self.aliases.clear();
                        }
                        self
                    }
                    /// Sets multiple *hidden* aliases for this argument value.
                    #[must_use] pub fn aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
                        self.aliases.extend(names.into_iter().map(|a| a.into()));
                        self
                    }
                }
                /// Reflection
                impl PossibleValue 
                {
                    /// Get the name of the argument value
                    #[inline] pub fn get_name(&self) -> &str {
                        self.name.as_str()
                    }
                    /// Get the help specified for this argument, if any
                    #[inline] pub fn get_help(&self) -> Option<&StyledStr> {
                        self.help.as_ref()
                    }
                    /// Report if [`PossibleValue::hide`] is set
                    #[inline] pub fn is_hide_set(&self) -> bool {
                        self.hide
                    }
                    /// Report if `PossibleValue` is not hidden and has a help message
                    pub fn should_show_help(&self) -> bool {
                        !self.hide && self.help.is_some()
                    }
                    /// Get the name if argument value is not hidden, `None` otherwise, but wrapped in quotes if it contains whitespace.
                    pub fn get_visible_quoted_name(&self) -> Option<std::borrow::Cow<'_, str>> {
                        if !self.hide {
                            Some(if self.name.contains(char::is_whitespace) {
                                format!("{:?}", self.name).into()
                            } else {
                                self.name.as_str().into()
                            })
                        } else {
                            None
                        }
                    }
                    /// Returns all valid values of the argument value.
                    pub fn get_name_and_aliases(&self) -> impl Iterator<Item = &str> + '_ {
                        std::iter::once(self.get_name()).chain(self.aliases.iter().map(|s| s.as_str()))
                    }
                    /// Tests if the value is valid for this argument value
                    pub fn matches(&self, value: &str, ignore_case: bool) -> bool {
                        if ignore_case {
                            self.get_name_and_aliases()
                                .any(|name| eq_ignore_case(name, value))
                        } else {
                            self.get_name_and_aliases().any(|name| name == value)
                        }
                    }
                }

                impl<S: Into<Str>> From<S> for PossibleValue 
                {
                    fn from(s: S) -> Self
                    {
                        Self::new(s)
                    }
                }
            }

            pub mod range
            {
                use ::
                {
                    *,
                };
                /// Values per occurrence for an argument
                #[derive(Copy, Clone, PartialEq, Eq, Hash)]
                pub struct ValueRange 
                {
                    start_inclusive: usize,
                    end_inclusive: usize,
                }

                impl ValueRange 
                {
                    /// Nor argument values, or a flag
                    pub const EMPTY: Self = Self 
                    {
                        start_inclusive: 0,
                        end_inclusive: 0,
                    };
                    /// A single argument value, the most common case for options
                    pub const SINGLE: Self = Self 
                    {
                        start_inclusive: 1,
                        end_inclusive: 1,
                    };

                    pub const FULL: Self = Self 
                    {
                        start_inclusive: 0,
                        end_inclusive: usize::MAX,
                    };
                    /// Create a range.
                    pub fn new(range: impl Into<Self>) -> Self 
                    {
                        range.into()
                    }

                    pub fn raw(start_inclusive: usize, end_inclusive: usize) -> Self 
                    {
                        debug_assert!(start_inclusive <= end_inclusive);
                        Self {
                            start_inclusive,
                            end_inclusive,
                        }
                    }
                    /// Fewest number of values the argument accepts
                    pub fn min_values(&self) -> usize 
                    {
                        self.start_inclusive
                    }
                    /// Most number of values the argument accepts
                    pub fn max_values(&self) -> usize 
                    {
                        self.end_inclusive
                    }
                    /// Report whether the argument takes any values (ie is a flag).
                    pub fn takes_values(&self) -> bool 
                    {
                        self.end_inclusive != 0
                    }

                    pub fn is_unbounded(&self) -> bool 
                    {
                        self.end_inclusive == usize::MAX
                    }

                    pub fn is_fixed(&self) -> bool 
                    {
                        self.start_inclusive == self.end_inclusive
                    }

                    pub fn is_multiple(&self) -> bool 
                    {
                        self.start_inclusive != self.end_inclusive || 1 < self.start_inclusive
                    }

                    pub fn num_values(&self) -> Option<usize> 
                    {
                        self.is_fixed().then_some(self.start_inclusive)
                    }

                    pub fn accepts_more(&self, current: usize) -> bool 
                    {
                        current < self.end_inclusive
                    }
                }

                impl std::ops::RangeBounds<usize> for ValueRange 
                {
                    fn start_bound(&self) -> std::ops::Bound<&usize> {
                        std::ops::Bound::Included(&self.start_inclusive)
                    }

                    fn end_bound(&self) -> std::ops::Bound<&usize> {
                        std::ops::Bound::Included(&self.end_inclusive)
                    }
                }

                impl Default for ValueRange 
                {
                    fn default() -> Self {
                        Self::SINGLE
                    }
                }

                impl From<usize> for ValueRange 
                {
                    fn from(fixed: usize) -> Self {
                        (fixed..=fixed).into()
                    }
                }

                impl From<std::ops::Range<usize>> for ValueRange 
                {
                    fn from(range: std::ops::Range<usize>) -> Self {
                        let start_inclusive = range.start;
                        let end_inclusive = range.end.saturating_sub(1);
                        Self::raw(start_inclusive, end_inclusive)
                    }
                }

                impl From<std::ops::RangeFull> for ValueRange 
                {
                    fn from(_: std::ops::RangeFull) -> Self {
                        Self::FULL
                    }
                }

                impl From<std::ops::RangeFrom<usize>> for ValueRange 
                {
                    fn from(range: std::ops::RangeFrom<usize>) -> Self {
                        let start_inclusive = range.start;
                        let end_inclusive = usize::MAX;
                        Self::raw(start_inclusive, end_inclusive)
                    }
                }

                impl From<std::ops::RangeTo<usize>> for ValueRange 
                {
                    fn from(range: std::ops::RangeTo<usize>) -> Self {
                        let start_inclusive = 0;
                        let end_inclusive = range.end.saturating_sub(1);
                        Self::raw(start_inclusive, end_inclusive)
                    }
                }

                impl From<std::ops::RangeInclusive<usize>> for ValueRange 
                {
                    fn from(range: std::ops::RangeInclusive<usize>) -> Self {
                        let start_inclusive = *range.start();
                        let end_inclusive = *range.end();
                        Self::raw(start_inclusive, end_inclusive)
                    }
                }

                impl From<std::ops::RangeToInclusive<usize>> for ValueRange 
                {
                    fn from(range: std::ops::RangeToInclusive<usize>) -> Self {
                        let start_inclusive = 0;
                        let end_inclusive = range.end;
                        Self::raw(start_inclusive, end_inclusive)
                    }
                }

                impl std::fmt::Display for ValueRange 
                {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        ok!(self.start_inclusive.fmt(f));
                        if self.is_fixed() {
                        } else if self.end_inclusive == usize::MAX {
                            ok!("..".fmt(f));
                        } else {
                            ok!("..=".fmt(f));
                            ok!(self.end_inclusive.fmt(f));
                        }
                        Ok(())
                    }
                }

                impl std::fmt::Debug for ValueRange 
                {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(f, "{self}")
                    }
                }
            }

            pub mod resettable
            {
                use ::
                {
                    *,
                };
                /*
                use crate::builder::ArgAction;
                use crate::builder::OsStr;
                use crate::builder::Str;
                use crate::builder::StyledStr;
                use crate::builder::ValueHint;
                use crate::builder::ValueParser;
                use crate::builder::ValueRange;*/

                /// Clearable builder value.
                #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
                pub enum Resettable<T> 
                {
                    /// Overwrite builder value
                    Value(T),
                    /// Reset builder value
                    Reset,
                }

                impl<T> Resettable<T> 
                {
                    pub fn into_option(self) -> Option<T> {
                        match self {
                            Self::Value(t) => Some(t),
                            Self::Reset => None,
                        }
                    }
                }

                impl<T> From<T> for Resettable<T> 
                {
                    fn from(other: T) -> Self {
                        Self::Value(other)
                    }
                }

                impl<T> From<Option<T>> for Resettable<T> 
                {
                    fn from(other: Option<T>) -> Self {
                        match other {
                            Some(inner) => Self::Value(inner),
                            None => Self::Reset,
                        }
                    }
                }
                /// Convert to the intended resettable type
                pub trait IntoResettable<T> 
                {
                    /// Convert to the intended resettable type
                    fn into_resettable(self) -> Resettable<T>;
                }

                impl IntoResettable<char> for Option<char> 
                {
                    fn into_resettable(self) -> Resettable<char> {
                        match self {
                            Some(s) => Resettable::Value(s),
                            None => Resettable::Reset,
                        }
                    }
                }

                impl IntoResettable<usize> for Option<usize> 
                {
                    fn into_resettable(self) -> Resettable<usize> {
                        match self {
                            Some(s) => Resettable::Value(s),
                            None => Resettable::Reset,
                        }
                    }
                }

                impl IntoResettable<ArgAction> for Option<ArgAction> 
                {
                    fn into_resettable(self) -> Resettable<ArgAction> {
                        match self {
                            Some(s) => Resettable::Value(s),
                            None => Resettable::Reset,
                        }
                    }
                }

                impl IntoResettable<ValueHint> for Option<ValueHint> 
                {
                    fn into_resettable(self) -> Resettable<ValueHint> {
                        match self {
                            Some(s) => Resettable::Value(s),
                            None => Resettable::Reset,
                        }
                    }
                }

                impl IntoResettable<ValueParser> for Option<ValueParser> 
                {
                    fn into_resettable(self) -> Resettable<ValueParser> {
                        match self {
                            Some(s) => Resettable::Value(s),
                            None => Resettable::Reset,
                        }
                    }
                }

                impl IntoResettable<StyledStr> for Option<&'static str> 
                {
                    fn into_resettable(self) -> Resettable<StyledStr> {
                        match self {
                            Some(s) => Resettable::Value(s.into()),
                            None => Resettable::Reset,
                        }
                    }
                }

                impl IntoResettable<OsStr> for Option<&'static str> 
                {
                    fn into_resettable(self) -> Resettable<OsStr> {
                        match self {
                            Some(s) => Resettable::Value(s.into()),
                            None => Resettable::Reset,
                        }
                    }
                }

                impl IntoResettable<Str> for Option<&'static str> 
                {
                    fn into_resettable(self) -> Resettable<Str> {
                        match self {
                            Some(s) => Resettable::Value(s.into()),
                            None => Resettable::Reset,
                        }
                    }
                }

                impl<T> IntoResettable<T> for Resettable<T> 
                {
                    fn into_resettable(self) -> Resettable<T> {
                        self
                    }
                }

                impl IntoResettable<char> for char 
                {
                    fn into_resettable(self) -> Resettable<char> {
                        Resettable::Value(self)
                    }
                }

                impl IntoResettable<usize> for usize 
                {
                    fn into_resettable(self) -> Resettable<usize> {
                        Resettable::Value(self)
                    }
                }

                impl IntoResettable<ArgAction> for ArgAction 
                {
                    fn into_resettable(self) -> Resettable<ArgAction> {
                        Resettable::Value(self)
                    }
                }

                impl IntoResettable<ValueHint> for ValueHint 
                {
                    fn into_resettable(self) -> Resettable<ValueHint> {
                        Resettable::Value(self)
                    }
                }

                impl<I: Into<ValueRange>> IntoResettable<ValueRange> for I 
                {
                    fn into_resettable(self) -> Resettable<ValueRange> {
                        Resettable::Value(self.into())
                    }
                }

                impl<I: Into<ValueParser>> IntoResettable<ValueParser> for I 
                {
                    fn into_resettable(self) -> Resettable<ValueParser> {
                        Resettable::Value(self.into())
                    }
                }

                impl<I: Into<String>> IntoResettable<String> for I 
                {
                    fn into_resettable(self) -> Resettable<String> {
                        Resettable::Value(self.into())
                    }
                }

                impl<I: Into<StyledStr>> IntoResettable<StyledStr> for I 
                {
                    fn into_resettable(self) -> Resettable<StyledStr> {
                        Resettable::Value(self.into())
                    }
                }

                impl<I: Into<OsStr>> IntoResettable<OsStr> for I 
                {
                    fn into_resettable(self) -> Resettable<OsStr> {
                        Resettable::Value(self.into())
                    }
                }

                impl<I: Into<Str>> IntoResettable<Str> for I 
                {
                    fn into_resettable(self) -> Resettable<Str> {
                        Resettable::Value(self.into())
                    }
                }

                impl<I: Into<crate::Id>> IntoResettable<crate::Id> for I 
                {
                    fn into_resettable(self) -> Resettable<crate::Id> {
                        Resettable::Value(self.into())
                    }
                }
            }

            pub mod str
            {
                use ::
                {
                    *,
                };
                /// A UTF-8-encoded fixed string
                ///
                /// <div class="warning">
                ///
                /// **NOTE:** To support dynamic values (i.e. `String`), enable the `string`
                /// feature
                ///
                /// </div>
                #[derive(Default, Clone, Eq, PartialEq, PartialOrd, Ord, Hash)]
                pub struct Str {
                    name: Inner,
                }

                impl Str {
                    #[cfg(feature = "string")]
                    pub fn from_string(name: String) -> Self {
                        Self {
                            name: Inner::from_string(name),
                        }
                    }

                    #[cfg(feature = "string")]
                    pub fn from_ref(name: &str) -> Self {
                        Self {
                            name: Inner::from_ref(name),
                        }
                    }

                    pub fn from_static_ref(name: &'static str) -> Self {
                        Self {
                            name: Inner::from_static_ref(name),
                        }
                    }

                    pub fn into_inner(self) -> Inner {
                        self.name
                    }
                    /// Get the raw string of the `Str`
                    pub fn as_str(&self) -> &str {
                        self.name.as_str()
                    }
                }

                impl From<&'_ Str> for Str {
                    fn from(id: &'_ Str) -> Self {
                        id.clone()
                    }
                }
                
                impl From<String> for Str {
                    fn from(name: String) -> Self {
                        Self::from_string(name)
                    }
                }
                
                impl From<&'_ String> for Str {
                    fn from(name: &'_ String) -> Self {
                        Self::from_ref(name.as_str())
                    }
                }

                impl From<&'static str> for Str {
                    fn from(name: &'static str) -> Self {
                        Self::from_static_ref(name)
                    }
                }

                impl From<&'_ &'static str> for Str {
                    fn from(name: &'_ &'static str) -> Self {
                        Self::from_static_ref(name)
                    }
                }

                impl From<Str> for String {
                    fn from(name: Str) -> Self {
                        name.name.into_string()
                    }
                }

                impl From<Str> for Vec<u8> {
                    fn from(name: Str) -> Self {
                        String::from(name).into()
                    }
                }

                impl From<Str> for std::ffi::OsString {
                    fn from(name: Str) -> Self {
                        String::from(name).into()
                    }
                }

                impl From<Str> for std::path::PathBuf {
                    fn from(name: Str) -> Self {
                        String::from(name).into()
                    }
                }

                impl std::fmt::Display for Str {
                    #[inline]
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        std::fmt::Display::fmt(self.as_str(), f)
                    }
                }

                impl std::fmt::Debug for Str {
                    #[inline]
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        std::fmt::Debug::fmt(self.as_str(), f)
                    }
                }

                impl std::ops::Deref for Str {
                    type Target = str;

                    #[inline]
                    fn deref(&self) -> &str {
                        self.as_str()
                    }
                }

                impl AsRef<str> for Str {
                    #[inline]
                    fn as_ref(&self) -> &str {
                        self.as_str()
                    }
                }

                impl AsRef<[u8]> for Str {
                    #[inline]
                    fn as_ref(&self) -> &[u8] {
                        self.as_bytes()
                    }
                }

                impl AsRef<std::ffi::OsStr> for Str {
                    #[inline]
                    fn as_ref(&self) -> &std::ffi::OsStr {
                        (**self).as_ref()
                    }
                }

                impl AsRef<std::path::Path> for Str {
                    #[inline]
                    fn as_ref(&self) -> &std::path::Path {
                        std::path::Path::new(self)
                    }
                }

                impl std::borrow::Borrow<str> for Str {
                    #[inline]
                    fn borrow(&self) -> &str {
                        self.as_str()
                    }
                }

                impl PartialEq<str> for Str {
                    #[inline]
                    fn eq(&self, other: &str) -> bool {
                        PartialEq::eq(self.as_str(), other)
                    }
                }
                impl PartialEq<Str> for str {
                    #[inline]
                    fn eq(&self, other: &Str) -> bool {
                        PartialEq::eq(self, other.as_str())
                    }
                }

                impl PartialEq<&'_ str> for Str {
                    #[inline]
                    fn eq(&self, other: &&str) -> bool {
                        PartialEq::eq(self.as_str(), *other)
                    }
                }
                impl PartialEq<Str> for &'_ str {
                    #[inline]
                    fn eq(&self, other: &Str) -> bool {
                        PartialEq::eq(*self, other.as_str())
                    }
                }

                impl PartialEq<std::ffi::OsStr> for Str {
                    #[inline]
                    fn eq(&self, other: &std::ffi::OsStr) -> bool {
                        PartialEq::eq(self.as_str(), other)
                    }
                }
                impl PartialEq<Str> for std::ffi::OsStr {
                    #[inline]
                    fn eq(&self, other: &Str) -> bool {
                        PartialEq::eq(self, other.as_str())
                    }
                }

                impl PartialEq<&'_ std::ffi::OsStr> for Str {
                    #[inline]
                    fn eq(&self, other: &&std::ffi::OsStr) -> bool {
                        PartialEq::eq(self.as_str(), *other)
                    }
                }
                impl PartialEq<Str> for &'_ std::ffi::OsStr {
                    #[inline]
                    fn eq(&self, other: &Str) -> bool {
                        PartialEq::eq(*self, other.as_str())
                    }
                }

                impl PartialEq<String> for Str {
                    #[inline]
                    fn eq(&self, other: &String) -> bool {
                        PartialEq::eq(self.as_str(), other.as_str())
                    }
                }
                impl PartialEq<Str> for String {
                    #[inline]
                    fn eq(&self, other: &Str) -> bool {
                        PartialEq::eq(self.as_str(), other.as_str())
                    }
                }
                
                pub mod inner {
                    #[derive(Clone)]
                    pub enum Inner {
                        Static(&'static str),
                        Owned(Box<str>),
                    }

                    impl Inner {
                        pub fn from_string(name: String) -> Self {
                            Self::Owned(name.into_boxed_str())
                        }

                        pub fn from_ref(name: &str) -> Self {
                            Self::Owned(Box::from(name))
                        }

                        pub fn from_static_ref(name: &'static str) -> Self {
                            Self::Static(name)
                        }

                        pub fn as_str(&self) -> &str {
                            match self {
                                Self::Static(s) => s,
                                Self::Owned(s) => s.as_ref(),
                            }
                        }

                        pub fn into_string(self) -> String {
                            match self {
                                Self::Static(s) => s.to_owned(),
                                Self::Owned(s) => s.into(),
                            }
                        }
                    }
                }

                #[cfg(not(feature = "string"))]
                pub mod inner {
                    #[derive(Clone)]
                    pub struct Inner(pub &'static str);

                    impl Inner {
                        pub fn from_static_ref(name: &'static str) -> Self {
                            Self(name)
                        }

                        pub fn as_str(&self) -> &str {
                            self.0
                        }

                        pub fn into_string(self) -> String {
                            self.as_str().to_owned()
                        }
                    }
                }

                pub use inner::Inner;

                impl Default for Inner {
                    fn default() -> Self {
                        Self::from_static_ref("")
                    }
                }

                impl PartialEq for Inner {
                    fn eq(&self, other: &Inner) -> bool {
                        self.as_str() == other.as_str()
                    }
                }

                impl PartialOrd for Inner {
                    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                        Some(self.cmp(other))
                    }
                }

                impl Ord for Inner {
                    fn cmp(&self, other: &Inner) -> std::cmp::Ordering {
                        self.as_str().cmp(other.as_str())
                    }
                }

                impl Eq for Inner {}

                impl std::hash::Hash for Inner {
                    #[inline]
                    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
                        self.as_str().hash(state);
                    }
                }
            }

            pub mod styled_str
            {
                use ::
                {
                    *,
                };

                /// Terminal-styling container.
                #[derive(Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord)]
                pub struct StyledStr(String);

                impl StyledStr 
                {
                    /// Create an empty buffer
                    pub const fn new() -> Self {
                        Self(String::new())
                    }
                    /// Display using [ANSI Escape Code](https://en.wikipedia.org/wiki/ANSI_escape_code) styling
                    #[cfg(feature = "color")]
                    pub fn ansi(&self) -> impl std::fmt::Display + '_ {
                        self.0.as_str()
                    }
                    /// May allow the compiler to consolidate the `Drop`s for `msg`, reducing code size compared to
                    /// `styled.push_str(&msg)`
                    pub fn push_string(&mut self, msg: String) {
                        self.0.push_str(&msg);
                    }

                    pub fn push_str(&mut self, msg: &str) {
                        self.0.push_str(msg);
                    }

                    pub fn trim_start_lines(&mut self) {
                        if let Some(pos) = self.0.find('\n') {
                            let (leading, help) = self.0.split_at(pos + 1);
                            if leading.trim().is_empty() {
                                self.0 = help.to_owned();
                            }
                        }
                    }

                    pub fn trim_end(&mut self) {
                        self.0 = self.0.trim_end().to_owned();
                    }

                    #[cfg(feature = "help")]
                    pub fn replace_newline_var(&mut self) {
                        self.0 = self.0.replace("{n}", "\n");
                    }

                    #[cfg(feature = "help")]
                    pub fn indent(&mut self, initial: &str, trailing: &str) {
                        self.0.insert_str(0, initial);

                        let mut line_sep = "\n".to_owned();
                        line_sep.push_str(trailing);
                        self.0 = self.0.replace('\n', &line_sep);
                    }

                    #[cfg(all(not(feature = "wrap_help"), feature = "help"))]
                    pub fn wrap(&mut self, _hard_width: usize) {}

                    #[cfg(feature = "wrap_help")]
                    pub fn wrap(&mut self, hard_width: usize) {
                        let mut new = String::with_capacity(self.0.len());

                        let mut last = 0;
                        let mut wrapper = crate::output::textwrap::wrap_algorithms::LineWrapper::new(hard_width);
                        for content in self.iter_text() {
                            // Preserve styling
                            let current = content.as_ptr() as usize - self.0.as_str().as_ptr() as usize;
                            if last != current {
                                new.push_str(&self.0.as_str()[last..current]);
                            }
                            last = current + content.len();

                            for (i, line) in content.split_inclusive('\n').enumerate() {
                                if 0 < i {
                                    // reset char count on newline, skipping the start as we might have carried
                                    // over from a prior block of styled text
                                    wrapper.reset();
                                }
                                let line = crate::output::textwrap::word_separators::find_words_ascii_space(line)
                                    .collect::<Vec<_>>();
                                new.extend(wrapper.wrap(line));
                            }
                        }
                        if last != self.0.len() {
                            new.push_str(&self.0.as_str()[last..]);
                        }
                        new = new.trim_end().to_owned();

                        self.0 = new;
                    }

                    #[inline(never)]
                    #[cfg(feature = "help")]
                    pub fn display_width(&self) -> usize {
                        let mut width = 0;
                        for c in self.iter_text() {
                            width += crate::output::display_width(c);
                        }
                        width
                    }

                    #[cfg(feature = "help")]
                    pub fn is_empty(&self) -> bool {
                        self.0.is_empty()
                    }

                    #[cfg(feature = "help")]
                    pub fn as_styled_str(&self) -> &str {
                        &self.0
                    }

                    #[cfg(feature = "color")]
                    pub fn iter_text(&self) -> impl Iterator<Item = &str> {
                        anstream::adapter::strip_str(&self.0)
                    }

                    #[cfg(not(feature = "color"))]
                    pub fn iter_text(&self) -> impl Iterator<Item = &str> {
                        [self.0.as_str()].into_iter()
                    }

                    pub fn push_styled(&mut self, other: &Self) {
                        self.0.push_str(&other.0);
                    }

                    pub fn write_to(&self, buffer: &mut dyn std::io::Write) -> std::io::Result<()> {
                        ok!(buffer.write_all(self.0.as_bytes()));

                        Ok(())
                    }
                }

                impl Default for &'_ StyledStr 
                {
                    fn default() -> Self {
                        static DEFAULT: StyledStr = StyledStr::new();
                        &DEFAULT
                    }
                }

                impl From<String> for StyledStr 
                {
                    fn from(name: String) -> Self {
                        StyledStr(name)
                    }
                }

                impl From<&'_ String> for StyledStr 
                {
                    fn from(name: &'_ String) -> Self {
                        let mut styled = StyledStr::new();
                        styled.push_str(name);
                        styled
                    }
                }

                impl From<&'static str> for StyledStr 
                {
                    fn from(name: &'static str) -> Self {
                        let mut styled = StyledStr::new();
                        styled.push_str(name);
                        styled
                    }
                }

                impl From<&'_ &'static str> for StyledStr 
                {
                    fn from(name: &'_ &'static str) -> Self {
                        StyledStr::from(*name)
                    }
                }

                impl std::fmt::Write for StyledStr 
                {
                    #[inline]
                    fn write_str(&mut self, s: &str) -> Result<(), std::fmt::Error> {
                        self.0.push_str(s);
                        Ok(())
                    }

                    #[inline]
                    fn write_char(&mut self, c: char) -> Result<(), std::fmt::Error> {
                        self.0.push(c);
                        Ok(())
                    }
                }
                /// Color-unaware printing. Never uses coloring.
                impl std::fmt::Display for StyledStr 
                {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        for part in self.iter_text() {
                            part.fmt(f)?;
                        }

                        Ok(())
                    }
                }
            }
            
            pub mod styling
            {
                //! Terminal [`Styles`] for help and error output
                use ::
                {
                    *,
                };
                
                pub use anstyle::*;

                /// Terminal styling definitions.
                #[derive(Clone, Debug)]
                #[allow(missing_copy_implementations)] // Large enough type that I want an explicit `clone()` for now
                pub struct Styles {
                    header: Style,
                    error: Style,
                    usage: Style,
                    literal: Style,
                    placeholder: Style,
                    valid: Style,
                    invalid: Style,
                }

                impl Styles {
                    /// No terminal styling
                    pub const fn plain() -> Self {
                        Self {
                            header: Style::new(),
                            error: Style::new(),
                            usage: Style::new(),
                            literal: Style::new(),
                            placeholder: Style::new(),
                            valid: Style::new(),
                            invalid: Style::new(),
                        }
                    }
                    /// Default terminal styling
                    pub const fn styled() -> Self {
                        #[cfg(feature = "color")]
                        {
                            Self {
                                header: Style::new().bold().underline(),
                                error: Style::new()
                                    .fg_color(Some(Color::Ansi(AnsiColor::Red)))
                                    .bold(),
                                usage: Style::new().bold().underline(),
                                literal: Style::new().bold(),
                                placeholder: Style::new(),
                                valid: Style::new().fg_color(Some(Color::Ansi(AnsiColor::Green))),
                                invalid: Style::new().fg_color(Some(Color::Ansi(AnsiColor::Yellow))),
                            }
                        }
                        #[cfg(not(feature = "color"))]
                        {
                            Self::plain()
                        }
                    }
                    /// General Heading style, e.g. [`help_heading`][crate::Arg::help_heading]
                    #[inline]
                    pub const fn header(mut self, style: Style) -> Self {
                        self.header = style;
                        self
                    }
                    /// Error heading
                    #[inline]
                    pub const fn error(mut self, style: Style) -> Self {
                        self.error = style;
                        self
                    }
                    /// Usage heading
                    #[inline]
                    pub const fn usage(mut self, style: Style) -> Self {
                        self.usage = style;
                        self
                    }
                    /// Literal command-line syntax, e.g. `--help`
                    #[inline]
                    pub const fn literal(mut self, style: Style) -> Self {
                        self.literal = style;
                        self
                    }
                    /// Descriptions within command-line syntax, e.g. [`value_name`][crate::Arg::value_name]
                    #[inline]
                    pub const fn placeholder(mut self, style: Style) -> Self {
                        self.placeholder = style;
                        self
                    }
                    /// Highlight suggested usage
                    #[inline]
                    pub const fn valid(mut self, style: Style) -> Self {
                        self.valid = style;
                        self
                    }
                    /// Highlight invalid usage
                    #[inline]
                    pub const fn invalid(mut self, style: Style) -> Self {
                        self.invalid = style;
                        self
                    }
                }
                /// Reflection
                impl Styles {
                    /// General Heading style, e.g. [`help_heading`][crate::Arg::help_heading]
                    #[inline(always)]
                    pub const fn get_header(&self) -> &Style {
                        &self.header
                    }
                    /// Error heading
                    #[inline(always)]
                    pub const fn get_error(&self) -> &Style {
                        &self.error
                    }
                    /// Usage heading
                    #[inline(always)]
                    pub const fn get_usage(&self) -> &Style {
                        &self.usage
                    }
                    /// Literal command-line syntax, e.g. `--help`
                    #[inline(always)]
                    pub const fn get_literal(&self) -> &Style {
                        &self.literal
                    }
                    /// Descriptions within command-line syntax, e.g. [`value_name`][crate::Arg::value_name]
                    #[inline(always)]
                    pub const fn get_placeholder(&self) -> &Style {
                        &self.placeholder
                    }
                    /// Highlight suggested usage
                    #[inline(always)]
                    pub const fn get_valid(&self) -> &Style {
                        &self.valid
                    }
                    /// Highlight invalid usage
                    #[inline(always)]
                    pub const fn get_invalid(&self) -> &Style {
                        &self.invalid
                    }
                }

                impl super::AppExt for Styles {}

                impl Default for Styles {
                    fn default() -> Self {
                        Self::styled()
                    }
                }

                impl Default for &'_ Styles {
                    fn default() -> Self {
                        const STYLES: Styles = Styles::styled();
                        &STYLES
                    }
                }
            }

            pub mod value_hint
            {
                use ::
                {
                    *,
                };

                use std::str::FromStr;

                /// Provide shell with hint on how to complete an argument.
                ///
                /// See [`Arg::value_hint`][crate::Arg::value_hint] to set this on an argument.
                ///
                /// See the `clap_complete` crate for completion script generation.
                ///
                /// Overview of which hints are supported by which shell:
                ///
                /// | Hint                   | zsh | fish[^1] | dynamic |
                /// | ---------------------- | --- | ---------|---------|
                /// | `AnyPath`              | Yes | Yes      | Yes     |
                /// | `FilePath`             | Yes | Yes      | Yes     |
                /// | `DirPath`              | Yes | Yes      | Yes     |
                /// | `ExecutablePath`       | Yes | Partial  | Yes     |
                /// | `CommandName`          | Yes | Yes      | No      |
                /// | `CommandString`        | Yes | Partial  | No      |
                /// | `CommandWithArguments` | Yes |          | No      |
                /// | `Username`             | Yes | Yes      | No      |
                /// | `Hostname`             | Yes | Yes      | No      |
                /// | `Url`                  | Yes |          | No      |
                /// | `EmailAddress`         | Yes |          | No      |
                ///
                /// [^1]: fish completions currently only support named arguments (e.g. -o or --opt), not
                ///       positional arguments.
                #[derive(Debug, Default, PartialEq, Eq, Hash, Copy, Clone)]
                #[non_exhaustive]
                pub enum ValueHint {
                    /// Default value if hint is not specified. Follows shell default behavior, which is usually
                    /// auto-completing filenames.
                    #[default]
                    Unknown,
                    /// None of the hints below apply. Disables shell completion for this argument.
                    Other,
                    /// Any existing path.
                    AnyPath,
                    /// Path to a file.
                    FilePath,
                    /// Path to a directory.
                    DirPath,
                    /// Path to an executable file.
                    ExecutablePath,
                    /// Name of a command, without arguments. May be relative to PATH, or full path to executable.
                    CommandName,
                    /// A single string containing a command and its arguments.
                    CommandString,
                    /// Capture the remaining arguments as a command name and arguments for that command. This is
                    /// common when writing shell wrappers that execute anther command, for example `sudo` or `env`.
                    ///
                    /// This hint is special, the argument must be a positional argument and have
                    /// [`.num_args(1..)`] and Command must use [`Command::trailing_var_arg(true)`]. The result is that the
                    /// command line `my_app ls -la /` will be parsed as `["ls", "-la", "/"]` and clap won't try to
                    /// parse the `-la` argument itself.
                    ///
                    /// [`Command::trailing_var_arg(true)`]: crate::Command::trailing_var_arg
                    /// [`.num_args(1..)`]: crate::Arg::num_args()
                    CommandWithArguments,
                    /// Name of a local operating system user.
                    Username,
                    /// Host name of a computer.
                    /// Shells usually parse `/etc/hosts` and `.ssh/known_hosts` to complete hostnames.
                    Hostname,
                    /// Complete web address.
                    Url,
                    /// Email address.
                    EmailAddress,
                }

                
                impl crate::builder::ArgExt for ValueHint {}

                impl FromStr for ValueHint {
                    type Err = String;
                    fn from_str(s: &str) -> Result<Self, <Self as FromStr>::Err> {
                        Ok(match &*s.to_ascii_lowercase() {
                            "unknown" => ValueHint::Unknown,
                            "other" => ValueHint::Other,
                            "anypath" => ValueHint::AnyPath,
                            "filepath" => ValueHint::FilePath,
                            "dirpath" => ValueHint::DirPath,
                            "executablepath" => ValueHint::ExecutablePath,
                            "commandname" => ValueHint::CommandName,
                            "commandstring" => ValueHint::CommandString,
                            "commandwitharguments" => ValueHint::CommandWithArguments,
                            "username" => ValueHint::Username,
                            "hostname" => ValueHint::Hostname,
                            "url" => ValueHint::Url,
                            "emailaddress" => ValueHint::EmailAddress,
                            _ => return Err(format!("unknown ValueHint: `{s}`")),
                        })
                    }
                }
            }

            pub mod value_parser
            {
                use ::
                {
                    *,
                };

                use std::convert::TryInto;
                use std::ops::RangeBounds;

                use crate::builder::Str;
                use crate::builder::StyledStr;
                use crate::parser::ValueSource;
                use crate::util::AnyValue;
                use crate::util::AnyValueId;

                /// Parse/validate argument values.
                pub struct ValueParser(ValueParserInner);

                enum ValueParserInner {
                    // Common enough to optimize and for possible values
                    Bool,
                    // Common enough to optimize
                    String,
                    // Common enough to optimize
                    OsString,
                    // Common enough to optimize
                    PathBuf,
                    Other(Box<dyn AnyValueParser>),
                }

                impl ValueParser {
                    /// Custom parser for argument values.
                    pub fn new<P>(other: P) -> Self
                    where
                        P: TypedValueParser,
                    {
                        Self(ValueParserInner::Other(Box::new(other)))
                    }
                    /// [`bool`] parser for argument values.
                    pub const fn bool() -> Self {
                        Self(ValueParserInner::Bool)
                    }
                    /// [`String`] parser for argument values.
                    pub const fn string() -> Self {
                        Self(ValueParserInner::String)
                    }
                    /// [`OsString`][std::ffi::OsString] parser for argument values.
                    pub const fn os_string() -> Self {
                        Self(ValueParserInner::OsString)
                    }
                    /// [`PathBuf`][std::path::PathBuf] parser for argument values.
                    pub const fn path_buf() -> Self {
                        Self(ValueParserInner::PathBuf)
                    }
                }

                impl ValueParser {
                    /// Parse into a `AnyValue`
                    ///
                    /// When `arg` is `None`, an external subcommand value is being parsed.
                    pub fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                        source: ValueSource,
                    ) -> Result<AnyValue, crate::Error> {
                        self.any_value_parser().parse_ref_(cmd, arg, value, source)
                    }
                    /// Describes the content of `AnyValue`
                    pub fn type_id(&self) -> AnyValueId {
                        self.any_value_parser().type_id()
                    }
                    /// Reflect on enumerated value properties
                    ///
                    /// Error checking should not be done with this; it is mostly targeted at user-facing
                    /// applications like errors and completion.
                    pub fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        self.any_value_parser().possible_values()
                    }

                    fn any_value_parser(&self) -> &dyn AnyValueParser {
                        match &self.0 {
                            ValueParserInner::Bool => &BoolValueParser {},
                            ValueParserInner::String => &StringValueParser {},
                            ValueParserInner::OsString => &OsStringValueParser {},
                            ValueParserInner::PathBuf => &PathBufValueParser {},
                            ValueParserInner::Other(o) => o.as_ref(),
                        }
                    }
                }
                /// Convert a [`TypedValueParser`] to [`ValueParser`].
                impl<P> From<P> for ValueParser
                where
                    P: TypedValueParser + Send + Sync + 'static,
                {
                    fn from(p: P) -> Self {
                        Self::new(p)
                    }
                }

                impl From<_AnonymousValueParser> for ValueParser {
                    fn from(p: _AnonymousValueParser) -> Self {
                        p.0
                    }
                }
                /// Create an `i64` [`ValueParser`] from a `N..M` range.
                impl From<std::ops::Range<i64>> for ValueParser {
                    fn from(value: std::ops::Range<i64>) -> Self {
                        let inner = RangedI64ValueParser::<i64>::new().range(value.start..value.end);
                        Self::from(inner)
                    }
                }
                /// Create an `i64` [`ValueParser`] from a `N..=M` range.
                impl From<std::ops::RangeInclusive<i64>> for ValueParser {
                    fn from(value: std::ops::RangeInclusive<i64>) -> Self {
                        let inner = RangedI64ValueParser::<i64>::new().range(value.start()..=value.end());
                        Self::from(inner)
                    }
                }
                /// Create an `i64` [`ValueParser`] from a `N..` range.
                impl From<std::ops::RangeFrom<i64>> for ValueParser {
                    fn from(value: std::ops::RangeFrom<i64>) -> Self {
                        let inner = RangedI64ValueParser::<i64>::new().range(value.start..);
                        Self::from(inner)
                    }
                }
                /// Create an `i64` [`ValueParser`] from a `..M` range.
                impl From<std::ops::RangeTo<i64>> for ValueParser {
                    fn from(value: std::ops::RangeTo<i64>) -> Self {
                        let inner = RangedI64ValueParser::<i64>::new().range(..value.end);
                        Self::from(inner)
                    }
                }
                /// Create an `i64` [`ValueParser`] from a `..=M` range.
                impl From<std::ops::RangeToInclusive<i64>> for ValueParser {
                    fn from(value: std::ops::RangeToInclusive<i64>) -> Self {
                        let inner = RangedI64ValueParser::<i64>::new().range(..=value.end);
                        Self::from(inner)
                    }
                }
                /// Create an `i64` [`ValueParser`] from a `..` range.
                impl From<std::ops::RangeFull> for ValueParser {
                    fn from(value: std::ops::RangeFull) -> Self {
                        let inner = RangedI64ValueParser::<i64>::new().range(value);
                        Self::from(inner)
                    }
                }
                /// Create a [`ValueParser`] with [`PossibleValuesParser`].
                impl<P, const C: usize> From<[P; C]> for ValueParser
                where
                    P: Into<super::PossibleValue>,
                {
                    fn from(values: [P; C]) -> Self {
                        let inner = PossibleValuesParser::from(values);
                        Self::from(inner)
                    }
                }
                /// Create a [`ValueParser`] with [`PossibleValuesParser`].
                impl<P> From<Vec<P>> for ValueParser
                where
                    P: Into<super::PossibleValue>,
                {
                    fn from(values: Vec<P>) -> Self {
                        let inner = PossibleValuesParser::from(values);
                        Self::from(inner)
                    }
                }

                impl std::fmt::Debug for ValueParser {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                        match &self.0 {
                            ValueParserInner::Bool => f.debug_struct("ValueParser::bool").finish(),
                            ValueParserInner::String => f.debug_struct("ValueParser::string").finish(),
                            ValueParserInner::OsString => f.debug_struct("ValueParser::os_string").finish(),
                            ValueParserInner::PathBuf => f.debug_struct("ValueParser::path_buf").finish(),
                            ValueParserInner::Other(o) => write!(f, "ValueParser::other({:?})", o.type_id()),
                        }
                    }
                }

                impl Clone for ValueParser {
                    fn clone(&self) -> Self {
                        Self(match &self.0 {
                            ValueParserInner::Bool => ValueParserInner::Bool,
                            ValueParserInner::String => ValueParserInner::String,
                            ValueParserInner::OsString => ValueParserInner::OsString,
                            ValueParserInner::PathBuf => ValueParserInner::PathBuf,
                            ValueParserInner::Other(o) => ValueParserInner::Other(o.clone_any()),
                        })
                    }
                }
                /// A type-erased wrapper for [`TypedValueParser`].
                trait AnyValueParser: Send + Sync + 'static {
                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<AnyValue, crate::Error>;

                    fn parse_ref_(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                        _source: ValueSource,
                    ) -> Result<AnyValue, crate::Error> {
                        self.parse_ref(cmd, arg, value)
                    }
                    /// Describes the content of `AnyValue`
                    fn type_id(&self) -> AnyValueId;

                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>>;

                    fn clone_any(&self) -> Box<dyn AnyValueParser>;
                }

                impl<T, P> AnyValueParser for P
                where
                    T: std::any::Any + Clone + Send + Sync + 'static,
                    P: TypedValueParser<Value = T>,
                {
                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<AnyValue, crate::Error> {
                        let value = ok!(TypedValueParser::parse_ref(self, cmd, arg, value));
                        Ok(AnyValue::new(value))
                    }

                    fn parse_ref_(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                        source: ValueSource,
                    ) -> Result<AnyValue, crate::Error> {
                        let value = ok!(TypedValueParser::parse_ref_(self, cmd, arg, value, source));
                        Ok(AnyValue::new(value))
                    }

                    fn type_id(&self) -> AnyValueId {
                        AnyValueId::of::<T>()
                    }

                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        P::possible_values(self)
                    }

                    fn clone_any(&self) -> Box<dyn AnyValueParser> {
                        Box::new(self.clone())
                    }
                }
                /// Parse/validate argument values.
                pub trait TypedValueParser: Clone + Send + Sync + 'static {
                    /// Argument's value type
                    type Value: Send + Sync + Clone;

                    /// Parse the argument value.
                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error>;

                    /// Parse the argument value.
                    fn parse_ref_(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                        _source: ValueSource,
                    ) -> Result<Self::Value, crate::Error> {
                        self.parse_ref(cmd, arg, value)
                    }
                    /// Parse the argument value.
                    fn parse(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: std::ffi::OsString,
                    ) -> Result<Self::Value, crate::Error> {
                        self.parse_ref(cmd, arg, &value)
                    }
                    /// Parse the argument value.
                    fn parse_(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: std::ffi::OsString,
                        _source: ValueSource,
                    ) -> Result<Self::Value, crate::Error> {
                        self.parse(cmd, arg, value)
                    }
                    /// Reflect on enumerated value properties.
                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        None
                    }
                    /// Adapt a `TypedValueParser` from one value to another.
                    fn map<T, F>(self, func: F) -> MapValueParser<Self, F>
                    where
                        T: Send + Sync + Clone,
                        F: Fn(Self::Value) -> T + Clone,
                    {
                        MapValueParser::new(self, func)
                    }
                    /// Adapt a `TypedValueParser` from one value to another.
                    fn try_map<T, E, F>(self, func: F) -> TryMapValueParser<Self, F>
                    where
                        F: Fn(Self::Value) -> Result<T, E> + Clone + Send + Sync + 'static,
                        T: Send + Sync + Clone,
                        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
                    {
                        TryMapValueParser::new(self, func)
                    }
                }

                impl<F, T, E> TypedValueParser for F
                where
                    F: Fn(&str) -> Result<T, E> + Clone + Send + Sync + 'static,
                    E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
                    T: Send + Sync + Clone,
                {
                    type Value = T;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        let value = ok!(value.to_str().ok_or_else(|| {
                            crate::Error::invalid_utf8(
                                cmd,
                                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                            )
                        }));
                        let value = ok!((self)(value).map_err(|e| {
                            let arg = arg
                                .map(|a| a.to_string())
                                .unwrap_or_else(|| "...".to_owned());
                            crate::Error::value_validation(arg, value.to_owned(), e.into()).with_cmd(cmd)
                        }));
                        Ok(value)
                    }
                }
                /// Implementation for [`ValueParser::string`]
                #[derive(Copy, Clone, Debug)]
                #[non_exhaustive]
                pub struct StringValueParser {}

                impl StringValueParser {
                    /// Implementation for [`ValueParser::string`]
                    pub fn new() -> Self {
                        Self {}
                    }
                }

                impl TypedValueParser for StringValueParser {
                    type Value = String;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        TypedValueParser::parse(self, cmd, arg, value.to_owned())
                    }

                    fn parse(
                        &self,
                        cmd: &crate::Command,
                        _arg: Option<&crate::Arg>,
                        value: std::ffi::OsString,
                    ) -> Result<Self::Value, crate::Error> {
                        let value = ok!(value.into_string().map_err(|_| {
                            crate::Error::invalid_utf8(
                                cmd,
                                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                            )
                        }));
                        Ok(value)
                    }
                }

                impl Default for StringValueParser {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Implementation for [`ValueParser::os_string`]
                #[derive(Copy, Clone, Debug)]
                #[non_exhaustive]
                pub struct OsStringValueParser {}

                impl OsStringValueParser {
                    /// Implementation for [`ValueParser::os_string`]
                    pub fn new() -> Self {
                        Self {}
                    }
                }

                impl TypedValueParser for OsStringValueParser {
                    type Value = std::ffi::OsString;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        TypedValueParser::parse(self, cmd, arg, value.to_owned())
                    }

                    fn parse(
                        &self,
                        _cmd: &crate::Command,
                        _arg: Option<&crate::Arg>,
                        value: std::ffi::OsString,
                    ) -> Result<Self::Value, crate::Error> {
                        Ok(value)
                    }
                }

                impl Default for OsStringValueParser {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Implementation for [`ValueParser::path_buf`]
                #[derive(Copy, Clone, Debug)]
                #[non_exhaustive]
                pub struct PathBufValueParser {}

                impl PathBufValueParser {
                    /// Implementation for [`ValueParser::path_buf`]
                    pub fn new() -> Self {
                        Self {}
                    }
                }

                impl TypedValueParser for PathBufValueParser {
                    type Value = std::path::PathBuf;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        TypedValueParser::parse(self, cmd, arg, value.to_owned())
                    }

                    fn parse(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: std::ffi::OsString,
                    ) -> Result<Self::Value, crate::Error> {
                        if value.is_empty() {
                            return Err(crate::Error::empty_value(
                                cmd,
                                &[],
                                arg.map(ToString::to_string)
                                    .unwrap_or_else(|| "...".to_owned()),
                            ));
                        }
                        Ok(Self::Value::from(value))
                    }
                }

                impl Default for PathBufValueParser {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Parse an [`ValueEnum`][crate::ValueEnum] value.
                #[derive(Clone, Debug)]
                pub struct EnumValueParser<E: crate::ValueEnum + Clone + Send + Sync + 'static>(
                    std::marker::PhantomData<E>,
                );

                impl<E: crate::ValueEnum + Clone + Send + Sync + 'static> EnumValueParser<E> {
                    /// Parse an [`ValueEnum`][crate::ValueEnum]
                    pub fn new() -> Self {
                        let phantom: std::marker::PhantomData<E> = Default::default();
                        Self(phantom)
                    }
                }

                impl<E: crate::ValueEnum + Clone + Send + Sync + 'static> TypedValueParser for EnumValueParser<E> {
                    type Value = E;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        let ignore_case = arg.map(|a| a.is_ignore_case_set()).unwrap_or(false);
                        let possible_vals = || {
                            E::value_variants()
                                .iter()
                                .filter_map(|v| v.to_possible_value())
                                .filter(|v| !v.is_hide_set())
                                .map(|v| v.get_name().to_owned())
                                .collect::<Vec<_>>()
                        };

                        let value = ok!(value.to_str().ok_or_else(|| {
                            crate::Error::invalid_value(
                                cmd,
                                value.to_string_lossy().into_owned(),
                                &possible_vals(),
                                arg.map(ToString::to_string)
                                    .unwrap_or_else(|| "...".to_owned()),
                            )
                        }));
                        let value = ok!(E::value_variants()
                            .iter()
                            .find(|v| {
                                v.to_possible_value()
                                    .expect("ValueEnum::value_variants contains only values with a corresponding ValueEnum::to_possible_value")
                                    .matches(value, ignore_case)
                            })
                            .ok_or_else(|| {
                            crate::Error::invalid_value(
                                cmd,
                                value.to_owned(),
                                &possible_vals(),
                                arg.map(ToString::to_string)
                                    .unwrap_or_else(|| "...".to_owned()),
                            )
                            }))
                            .clone();
                        Ok(value)
                    }

                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        Some(Box::new(
                            E::value_variants()
                                .iter()
                                .filter_map(|v| v.to_possible_value()),
                        ))
                    }
                }

                impl<E: crate::ValueEnum + Clone + Send + Sync + 'static> Default for EnumValueParser<E> {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Verify the value is from an enumerated set of [`PossibleValue`][crate::builder::PossibleValue].
                #[derive(Clone, Debug)]
                pub struct PossibleValuesParser(Vec<super::PossibleValue>);

                impl PossibleValuesParser {
                    /// Verify the value is from an enumerated set of [`PossibleValue`][crate::builder::PossibleValue].
                    pub fn new(values: impl Into<PossibleValuesParser>) -> Self {
                        values.into()
                    }
                }

                impl TypedValueParser for PossibleValuesParser {
                    type Value = String;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        TypedValueParser::parse(self, cmd, arg, value.to_owned())
                    }

                    fn parse(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: std::ffi::OsString,
                    ) -> Result<String, crate::Error> {
                        let value = ok!(value.into_string().map_err(|_| {
                            crate::Error::invalid_utf8(
                                cmd,
                                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                            )
                        }));

                        let ignore_case = arg.map(|a| a.is_ignore_case_set()).unwrap_or(false);
                        if self.0.iter().any(|v| v.matches(&value, ignore_case)) {
                            Ok(value)
                        } else {
                            let possible_vals = self
                                .0
                                .iter()
                                .filter(|v| !v.is_hide_set())
                                .map(|v| v.get_name().to_owned())
                                .collect::<Vec<_>>();

                            Err(crate::Error::invalid_value(
                                cmd,
                                value,
                                &possible_vals,
                                arg.map(ToString::to_string)
                                    .unwrap_or_else(|| "...".to_owned()),
                            ))
                        }
                    }

                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        Some(Box::new(self.0.iter().cloned()))
                    }
                }

                impl<I, T> From<I> for PossibleValuesParser
                where
                    I: IntoIterator<Item = T>,
                    T: Into<super::PossibleValue>,
                {
                    fn from(values: I) -> Self {
                        Self(values.into_iter().map(|t| t.into()).collect())
                    }
                }
                /// Parse number that fall within a range of values.
                #[derive(Copy, Clone, Debug)]
                pub struct RangedI64ValueParser<T: TryFrom<i64> + Clone + Send + Sync = i64> {
                    bounds: (std::ops::Bound<i64>, std::ops::Bound<i64>),
                    target: std::marker::PhantomData<T>,
                }

                impl<T: TryFrom<i64> + Clone + Send + Sync> RangedI64ValueParser<T> {
                    /// Select full range of `i64`
                    pub fn new() -> Self {
                        Self::from(..)
                    }
                    /// Narrow the supported range
                    pub fn range<B: RangeBounds<i64>>(mut self, range: B) -> Self {
                        // Consideration: when the user does `value_parser!(u8).range()`
                        // - Avoid programming mistakes by accidentally expanding the range
                        // - Make it convenient to limit the range like with `..10`
                        let start = match range.start_bound() {
                            l @ std::ops::Bound::Included(i) => {
                                debug_assert!(
                                    self.bounds.contains(i),
                                    "{} must be in {:?}",
                                    i,
                                    self.bounds
                                );
                                l.cloned()
                            }
                            l @ std::ops::Bound::Excluded(i) => {
                                debug_assert!(
                                    self.bounds.contains(&i.saturating_add(1)),
                                    "{} must be in {:?}",
                                    i,
                                    self.bounds
                                );
                                l.cloned()
                            }
                            std::ops::Bound::Unbounded => self.bounds.start_bound().cloned(),
                        };
                        let end = match range.end_bound() {
                            l @ std::ops::Bound::Included(i) => {
                                debug_assert!(
                                    self.bounds.contains(i),
                                    "{} must be in {:?}",
                                    i,
                                    self.bounds
                                );
                                l.cloned()
                            }
                            l @ std::ops::Bound::Excluded(i) => {
                                debug_assert!(
                                    self.bounds.contains(&i.saturating_sub(1)),
                                    "{} must be in {:?}",
                                    i,
                                    self.bounds
                                );
                                l.cloned()
                            }
                            std::ops::Bound::Unbounded => self.bounds.end_bound().cloned(),
                        };
                        self.bounds = (start, end);
                        self
                    }

                    fn format_bounds(&self) -> String {
                        let mut result = match self.bounds.0 {
                            std::ops::Bound::Included(i) => i.to_string(),
                            std::ops::Bound::Excluded(i) => i.saturating_add(1).to_string(),
                            std::ops::Bound::Unbounded => i64::MIN.to_string(),
                        };
                        result.push_str("..");
                        match self.bounds.1 {
                            std::ops::Bound::Included(i) => {
                                result.push('=');
                                result.push_str(&i.to_string());
                            }
                            std::ops::Bound::Excluded(i) => {
                                result.push_str(&i.to_string());
                            }
                            std::ops::Bound::Unbounded => {
                                result.push_str(&i64::MAX.to_string());
                            }
                        }
                        result
                    }
                }

                impl<T: TryFrom<i64> + Clone + Send + Sync + 'static> TypedValueParser for RangedI64ValueParser<T> where
                    <T as TryFrom<i64>>::Error: Send + Sync + 'static + std::error::Error + ToString,
                {
                    type Value = T;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        raw_value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        let value = ok!(raw_value.to_str().ok_or_else(|| {
                            crate::Error::invalid_utf8(
                                cmd,
                                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                            )
                        }));
                        let value = ok!(value.parse::<i64>().map_err(|err| {
                            let arg = arg
                                .map(|a| a.to_string())
                                .unwrap_or_else(|| "...".to_owned());
                            crate::Error::value_validation(
                                arg,
                                raw_value.to_string_lossy().into_owned(),
                                err.into(),
                            )
                            .with_cmd(cmd)
                        }));
                        if !self.bounds.contains(&value) {
                            let arg = arg
                                .map(|a| a.to_string())
                                .unwrap_or_else(|| "...".to_owned());
                            return Err(crate::Error::value_validation(
                                arg,
                                raw_value.to_string_lossy().into_owned(),
                                format!("{} is not in {}", value, self.format_bounds()).into(),
                            )
                            .with_cmd(cmd));
                        }

                        let value: Result<Self::Value, _> = value.try_into();
                        let value = ok!(value.map_err(|err| {
                            let arg = arg
                                .map(|a| a.to_string())
                                .unwrap_or_else(|| "...".to_owned());
                            crate::Error::value_validation(
                                arg,
                                raw_value.to_string_lossy().into_owned(),
                                err.into(),
                            )
                            .with_cmd(cmd)
                        }));

                        Ok(value)
                    }
                }

                impl<T: TryFrom<i64> + Clone + Send + Sync, B: RangeBounds<i64>> From<B>
                    for RangedI64ValueParser<T>
                {
                    fn from(range: B) -> Self {
                        Self {
                            bounds: (range.start_bound().cloned(), range.end_bound().cloned()),
                            target: Default::default(),
                        }
                    }
                }

                impl<T: TryFrom<i64> + Clone + Send + Sync> Default for RangedI64ValueParser<T> {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Parse number that fall within a range of values.
                #[derive(Copy, Clone, Debug)]
                pub struct RangedU64ValueParser<T: TryFrom<u64> = u64> {
                    bounds: (std::ops::Bound<u64>, std::ops::Bound<u64>),
                    target: std::marker::PhantomData<T>,
                }

                impl<T: TryFrom<u64>> RangedU64ValueParser<T> {
                    /// Select full range of `u64`
                    pub fn new() -> Self {
                        Self::from(..)
                    }
                    /// Narrow the supported range
                    pub fn range<B: RangeBounds<u64>>(mut self, range: B) -> Self {
                        // Consideration: when the user does `value_parser!(u8).range()`
                        // - Avoid programming mistakes by accidentally expanding the range
                        // - Make it convenient to limit the range like with `..10`
                        let start = match range.start_bound() {
                            l @ std::ops::Bound::Included(i) => {
                                debug_assert!(
                                    self.bounds.contains(i),
                                    "{} must be in {:?}",
                                    i,
                                    self.bounds
                                );
                                l.cloned()
                            }
                            l @ std::ops::Bound::Excluded(i) => {
                                debug_assert!(
                                    self.bounds.contains(&i.saturating_add(1)),
                                    "{} must be in {:?}",
                                    i,
                                    self.bounds
                                );
                                l.cloned()
                            }
                            std::ops::Bound::Unbounded => self.bounds.start_bound().cloned(),
                        };
                        let end = match range.end_bound() {
                            l @ std::ops::Bound::Included(i) => {
                                debug_assert!(
                                    self.bounds.contains(i),
                                    "{} must be in {:?}",
                                    i,
                                    self.bounds
                                );
                                l.cloned()
                            }
                            l @ std::ops::Bound::Excluded(i) => {
                                debug_assert!(
                                    self.bounds.contains(&i.saturating_sub(1)),
                                    "{} must be in {:?}",
                                    i,
                                    self.bounds
                                );
                                l.cloned()
                            }
                            std::ops::Bound::Unbounded => self.bounds.end_bound().cloned(),
                        };
                        self.bounds = (start, end);
                        self
                    }

                    fn format_bounds(&self) -> String {
                        let mut result = match self.bounds.0 {
                            std::ops::Bound::Included(i) => i.to_string(),
                            std::ops::Bound::Excluded(i) => i.saturating_add(1).to_string(),
                            std::ops::Bound::Unbounded => u64::MIN.to_string(),
                        };
                        result.push_str("..");
                        match self.bounds.1 {
                            std::ops::Bound::Included(i) => {
                                result.push('=');
                                result.push_str(&i.to_string());
                            }
                            std::ops::Bound::Excluded(i) => {
                                result.push_str(&i.to_string());
                            }
                            std::ops::Bound::Unbounded => {
                                result.push_str(&u64::MAX.to_string());
                            }
                        }
                        result
                    }
                }

                impl<T: TryFrom<u64> + Clone + Send + Sync + 'static> TypedValueParser for RangedU64ValueParser<T> where
                    <T as TryFrom<u64>>::Error: Send + Sync + 'static + std::error::Error + ToString,
                {
                    type Value = T;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        raw_value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        let value = ok!(raw_value.to_str().ok_or_else(|| {
                            crate::Error::invalid_utf8(
                                cmd,
                                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                            )
                        }));
                        let value = ok!(value.parse::<u64>().map_err(|err| {
                            let arg = arg
                                .map(|a| a.to_string())
                                .unwrap_or_else(|| "...".to_owned());
                            crate::Error::value_validation(
                                arg,
                                raw_value.to_string_lossy().into_owned(),
                                err.into(),
                            )
                            .with_cmd(cmd)
                        }));
                        if !self.bounds.contains(&value) {
                            let arg = arg
                                .map(|a| a.to_string())
                                .unwrap_or_else(|| "...".to_owned());
                            return Err(crate::Error::value_validation(
                                arg,
                                raw_value.to_string_lossy().into_owned(),
                                format!("{} is not in {}", value, self.format_bounds()).into(),
                            )
                            .with_cmd(cmd));
                        }

                        let value: Result<Self::Value, _> = value.try_into();
                        let value = ok!(value.map_err(|err| {
                            let arg = arg
                                .map(|a| a.to_string())
                                .unwrap_or_else(|| "...".to_owned());
                            crate::Error::value_validation(
                                arg,
                                raw_value.to_string_lossy().into_owned(),
                                err.into(),
                            )
                            .with_cmd(cmd)
                        }));

                        Ok(value)
                    }
                }

                impl<T: TryFrom<u64>, B: RangeBounds<u64>> From<B> for RangedU64ValueParser<T> {
                    fn from(range: B) -> Self {
                        Self {
                            bounds: (range.start_bound().cloned(), range.end_bound().cloned()),
                            target: Default::default(),
                        }
                    }
                }

                impl<T: TryFrom<u64>> Default for RangedU64ValueParser<T> {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Implementation for [`ValueParser::bool`].
                #[derive(Copy, Clone, Debug)]
                #[non_exhaustive]
                pub struct BoolValueParser {}

                impl BoolValueParser {
                    /// Implementation for [`ValueParser::bool`]
                    pub fn new() -> Self {
                        Self {}
                    }

                    fn possible_values() -> impl Iterator<Item = crate::builder::PossibleValue> {
                        ["true", "false"]
                            .iter()
                            .copied()
                            .map(crate::builder::PossibleValue::new)
                    }
                }

                impl TypedValueParser for BoolValueParser {
                    type Value = bool;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        let value = if value == std::ffi::OsStr::new("true") {
                            true
                        } else if value == std::ffi::OsStr::new("false") {
                            false
                        } else {
                            // Intentionally showing hidden as we hide all of them
                            let possible_vals = Self::possible_values()
                                .map(|v| v.get_name().to_owned())
                                .collect::<Vec<_>>();

                            return Err(crate::Error::invalid_value(
                                cmd,
                                value.to_string_lossy().into_owned(),
                                &possible_vals,
                                arg.map(ToString::to_string)
                                    .unwrap_or_else(|| "...".to_owned()),
                            ));
                        };
                        Ok(value)
                    }

                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        Some(Box::new(Self::possible_values()))
                    }
                }

                impl Default for BoolValueParser {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Parse false-like string values, everything else is `true`.
                #[derive(Copy, Clone, Debug)]
                #[non_exhaustive]
                pub struct FalseyValueParser {}

                impl FalseyValueParser {
                    /// Parse false-like string values, everything else is `true`
                    pub fn new() -> Self {
                        Self {}
                    }

                    fn possible_values() -> impl Iterator<Item = crate::builder::PossibleValue> {
                        crate::util::TRUE_LITERALS
                            .iter()
                            .chain(crate::util::FALSE_LITERALS.iter())
                            .copied()
                            .map(|l| crate::builder::PossibleValue::new(l).hide(l != "true" && l != "false"))
                    }
                }

                impl TypedValueParser for FalseyValueParser {
                    type Value = bool;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        _arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        let value = ok!(value.to_str().ok_or_else(|| {
                            crate::Error::invalid_utf8(
                                cmd,
                                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                            )
                        }));
                        let value = if value.is_empty() {
                            false
                        } else {
                            crate::util::str_to_bool(value).unwrap_or(true)
                        };
                        Ok(value)
                    }

                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        Some(Box::new(Self::possible_values()))
                    }
                }

                impl Default for FalseyValueParser {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Parse bool-like string values.
                #[derive(Copy, Clone, Debug)]
                #[non_exhaustive]
                pub struct BoolishValueParser {}

                impl BoolishValueParser {
                    /// Parse bool-like string values
                    pub fn new() -> Self {
                        Self {}
                    }

                    fn possible_values() -> impl Iterator<Item = crate::builder::PossibleValue> {
                        crate::util::TRUE_LITERALS
                            .iter()
                            .chain(crate::util::FALSE_LITERALS.iter())
                            .copied()
                            .map(|l| crate::builder::PossibleValue::new(l).hide(l != "true" && l != "false"))
                    }
                }

                impl TypedValueParser for BoolishValueParser {
                    type Value = bool;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        let value = ok!(value.to_str().ok_or_else(|| {
                            crate::Error::invalid_utf8(
                                cmd,
                                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                            )
                        }));
                        let value = ok!(crate::util::str_to_bool(value).ok_or_else(|| {
                            let arg = arg
                                .map(|a| a.to_string())
                                .unwrap_or_else(|| "...".to_owned());
                            crate::Error::value_validation(arg, value.to_owned(), "value was not a boolean".into())
                                .with_cmd(cmd)
                        }));
                        Ok(value)
                    }

                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        Some(Box::new(Self::possible_values()))
                    }
                }

                impl Default for BoolishValueParser {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Parse non-empty string values.
                #[derive(Copy, Clone, Debug)]
                #[non_exhaustive]
                pub struct NonEmptyStringValueParser {}

                impl NonEmptyStringValueParser {
                    /// Parse non-empty string values
                    pub fn new() -> Self {
                        Self {}
                    }
                }

                impl TypedValueParser for NonEmptyStringValueParser {
                    type Value = String;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        if value.is_empty() {
                            return Err(crate::Error::empty_value(
                                cmd,
                                &[],
                                arg.map(ToString::to_string)
                                    .unwrap_or_else(|| "...".to_owned()),
                            ));
                        }
                        let value = ok!(value.to_str().ok_or_else(|| {
                            crate::Error::invalid_utf8(
                                cmd,
                                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                            )
                        }));
                        Ok(value.to_owned())
                    }
                }

                impl Default for NonEmptyStringValueParser {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                /// Adapt a `TypedValueParser` from one value to another.
                #[derive(Clone, Debug)]
                pub struct MapValueParser<P, F> {
                    parser: P,
                    func: F,
                }

                impl<P, F, T> MapValueParser<P, F> where
                    P: TypedValueParser,
                    P::Value: Send + Sync + Clone,
                    F: Fn(P::Value) -> T + Clone,
                    T: Send + Sync + Clone,
                {
                    fn new(parser: P, func: F) -> Self {
                        Self { parser, func }
                    }
                }

                impl<P, F, T> TypedValueParser for MapValueParser<P, F> where
                    P: TypedValueParser,
                    P::Value: Send + Sync + Clone,
                    F: Fn(P::Value) -> T + Clone + Send + Sync + 'static,
                    T: Send + Sync + Clone,
                {
                    type Value = T;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        let value = ok!(self.parser.parse_ref(cmd, arg, value));
                        let value = (self.func)(value);
                        Ok(value)
                    }

                    fn parse(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: std::ffi::OsString,
                    ) -> Result<Self::Value, crate::Error> {
                        let value = ok!(self.parser.parse(cmd, arg, value));
                        let value = (self.func)(value);
                        Ok(value)
                    }

                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        self.parser.possible_values()
                    }
                }
                /// Adapt a `TypedValueParser` from one value to another.
                #[derive(Clone, Debug)]
                pub struct TryMapValueParser<P, F> {
                    parser: P,
                    func: F,
                }

                impl<P, F, T, E> TryMapValueParser<P, F> where
                    P: TypedValueParser,
                    P::Value: Send + Sync + Clone,
                    F: Fn(P::Value) -> Result<T, E> + Clone + Send + Sync + 'static,
                    T: Send + Sync + Clone,
                    E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
                {
                    fn new(parser: P, func: F) -> Self {
                        Self { parser, func }
                    }
                }

                impl<P, F, T, E> TypedValueParser for TryMapValueParser<P, F> where
                    P: TypedValueParser,
                    P::Value: Send + Sync + Clone,
                    F: Fn(P::Value) -> Result<T, E> + Clone + Send + Sync + 'static,
                    T: Send + Sync + Clone,
                    E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
                {
                    type Value = T;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        let mid_value = ok!(self.parser.parse_ref(cmd, arg, value));
                        let value = ok!((self.func)(mid_value).map_err(|e| {
                            let arg = arg
                                .map(|a| a.to_string())
                                .unwrap_or_else(|| "...".to_owned());
                            crate::Error::value_validation(arg, value.to_string_lossy().into_owned(), e.into())
                                .with_cmd(cmd)
                        }));
                        Ok(value)
                    }

                    fn possible_values(
                        &self,
                    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
                        self.parser.possible_values()
                    }
                }
                /// When encountered, report [`ErrorKind::UnknownArgument`][crate::error::ErrorKind::UnknownArgument].
                #[derive(Clone, Debug)]
                pub struct UnknownArgumentValueParser {
                    arg: Option<Str>,
                    suggestions: Vec<StyledStr>,
                }

                impl UnknownArgumentValueParser {
                    /// Suggest an alternative argument
                    pub fn suggest_arg(arg: impl Into<Str>) -> Self {
                        Self {
                            arg: Some(arg.into()),
                            suggestions: Default::default(),
                        }
                    }
                    /// Provide a general suggestion
                    pub fn suggest(text: impl Into<StyledStr>) -> Self {
                        Self {
                            arg: Default::default(),
                            suggestions: vec![text.into()],
                        }
                    }
                    /// Extend the suggestions
                    pub fn and_suggest(mut self, text: impl Into<StyledStr>) -> Self {
                        self.suggestions.push(text.into());
                        self
                    }
                }

                impl TypedValueParser for UnknownArgumentValueParser {
                    type Value = String;

                    fn parse_ref(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        value: &std::ffi::OsStr,
                    ) -> Result<Self::Value, crate::Error> {
                        TypedValueParser::parse_ref_(self, cmd, arg, value, ValueSource::CommandLine)
                    }

                    fn parse_ref_(
                        &self,
                        cmd: &crate::Command,
                        arg: Option<&crate::Arg>,
                        _value: &std::ffi::OsStr,
                        source: ValueSource,
                    ) -> Result<Self::Value, crate::Error> {
                        match source {
                            ValueSource::DefaultValue => {
                                TypedValueParser::parse_ref_(&StringValueParser::new(), cmd, arg, _value, source)
                            }
                            ValueSource::EnvVariable | ValueSource::CommandLine => {
                                let arg = match arg {
                                    Some(arg) => arg.to_string(),
                                    None => "..".to_owned(),
                                };
                                let err = crate::Error::unknown_argument(
                                    cmd,
                                    arg,
                                    self.arg.as_ref().map(|s| (s.as_str().to_owned(), None)),
                                    false,
                                    crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                                );
                                
                                let err = {
                                    debug_assert_eq!(
                                        err.get(crate::error::ContextKind::Suggested),
                                        None,
                                        "Assuming `Error::unknown_argument` doesn't apply any `Suggested` so we can without caution"
                                    );
                                    err.insert_context_unchecked(
                                        crate::error::ContextKind::Suggested,
                                        crate::error::ContextValue::StyledStrs(self.suggestions.clone()),
                                    )
                                };
                                Err(err)
                            }
                        }
                    }
                }
                /// Register a type with [`value_parser!`][crate::value_parser!].
                pub trait ValueParserFactory {
                    /// Generated parser, usually [`ValueParser`].
                    ///
                    /// It should at least be a type that supports `Into<ValueParser>`.  A non-`ValueParser` type
                    /// allows the caller to do further initialization on the parser.
                    type Parser;

                    /// Create the specified [`Self::Parser`]
                    fn value_parser() -> Self::Parser;
                }
                impl ValueParserFactory for String {
                    type Parser = ValueParser;
                    fn value_parser() -> Self::Parser {
                        ValueParser::string() // Default `clap_derive` to optimized implementation
                    }
                }
                impl ValueParserFactory for Box<str> {
                    type Parser = MapValueParser<StringValueParser, fn(String) -> Box<str>>;
                    fn value_parser() -> Self::Parser {
                        StringValueParser::new().map(String::into_boxed_str)
                    }
                }
                impl ValueParserFactory for std::ffi::OsString {
                    type Parser = ValueParser;
                    fn value_parser() -> Self::Parser {
                        ValueParser::os_string() // Default `clap_derive` to optimized implementation
                    }
                }
                impl ValueParserFactory for Box<std::ffi::OsStr> {
                    type Parser =
                        MapValueParser<OsStringValueParser, fn(std::ffi::OsString) -> Box<std::ffi::OsStr>>;
                    fn value_parser() -> Self::Parser {
                        OsStringValueParser::new().map(std::ffi::OsString::into_boxed_os_str)
                    }
                }
                impl ValueParserFactory for std::path::PathBuf {
                    type Parser = ValueParser;
                    fn value_parser() -> Self::Parser {
                        ValueParser::path_buf() // Default `clap_derive` to optimized implementation
                    }
                }
                impl ValueParserFactory for Box<std::path::Path> {
                    type Parser =
                        MapValueParser<PathBufValueParser, fn(std::path::PathBuf) -> Box<std::path::Path>>;
                    fn value_parser() -> Self::Parser {
                        PathBufValueParser::new().map(std::path::PathBuf::into_boxed_path)
                    }
                }
                impl ValueParserFactory for bool {
                    type Parser = ValueParser;
                    fn value_parser() -> Self::Parser {
                        ValueParser::bool() // Default `clap_derive` to optimized implementation
                    }
                }
                impl ValueParserFactory for u8 {
                    type Parser = RangedI64ValueParser<u8>;
                    fn value_parser() -> Self::Parser {
                        let start: i64 = u8::MIN.into();
                        let end: i64 = u8::MAX.into();
                        RangedI64ValueParser::new().range(start..=end)
                    }
                }
                impl ValueParserFactory for i8 {
                    type Parser = RangedI64ValueParser<i8>;
                    fn value_parser() -> Self::Parser {
                        let start: i64 = i8::MIN.into();
                        let end: i64 = i8::MAX.into();
                        RangedI64ValueParser::new().range(start..=end)
                    }
                }
                impl ValueParserFactory for u16 {
                    type Parser = RangedI64ValueParser<u16>;
                    fn value_parser() -> Self::Parser {
                        let start: i64 = u16::MIN.into();
                        let end: i64 = u16::MAX.into();
                        RangedI64ValueParser::new().range(start..=end)
                    }
                }
                impl ValueParserFactory for i16 {
                    type Parser = RangedI64ValueParser<i16>;
                    fn value_parser() -> Self::Parser {
                        let start: i64 = i16::MIN.into();
                        let end: i64 = i16::MAX.into();
                        RangedI64ValueParser::new().range(start..=end)
                    }
                }
                impl ValueParserFactory for u32 {
                    type Parser = RangedI64ValueParser<u32>;
                    fn value_parser() -> Self::Parser {
                        let start: i64 = u32::MIN.into();
                        let end: i64 = u32::MAX.into();
                        RangedI64ValueParser::new().range(start..=end)
                    }
                }
                impl ValueParserFactory for i32 {
                    type Parser = RangedI64ValueParser<i32>;
                    fn value_parser() -> Self::Parser {
                        let start: i64 = i32::MIN.into();
                        let end: i64 = i32::MAX.into();
                        RangedI64ValueParser::new().range(start..=end)
                    }
                }
                impl ValueParserFactory for u64 {
                    type Parser = RangedU64ValueParser<u64>;
                    fn value_parser() -> Self::Parser {
                        RangedU64ValueParser::new()
                    }
                }
                impl ValueParserFactory for i64 {
                    type Parser = RangedI64ValueParser<i64>;
                    fn value_parser() -> Self::Parser {
                        RangedI64ValueParser::new()
                    }
                }
                impl<T> ValueParserFactory for std::num::Saturating<T> where
                    T: ValueParserFactory,
                    <T as ValueParserFactory>::Parser: TypedValueParser<Value = T>,
                    T: Send + Sync + Clone,
                {
                    type Parser =
                        MapValueParser<<T as ValueParserFactory>::Parser, fn(T) -> std::num::Saturating<T>>;
                    fn value_parser() -> Self::Parser {
                        T::value_parser().map(std::num::Saturating)
                    }
                }
                impl<T> ValueParserFactory for std::num::Wrapping<T> where
                    T: ValueParserFactory,
                    <T as ValueParserFactory>::Parser: TypedValueParser<Value = T>,
                    T: Send + Sync + Clone,
                {
                    type Parser = MapValueParser<<T as ValueParserFactory>::Parser, fn(T) -> std::num::Wrapping<T>>;
                    fn value_parser() -> Self::Parser {
                        T::value_parser().map(std::num::Wrapping)
                    }
                }
                impl<T> ValueParserFactory for Box<T> where
                    T: ValueParserFactory,
                    <T as ValueParserFactory>::Parser: TypedValueParser<Value = T>,
                    T: Send + Sync + Clone,
                {
                    type Parser = MapValueParser<<T as ValueParserFactory>::Parser, fn(T) -> Box<T>>;
                    fn value_parser() -> Self::Parser {
                        T::value_parser().map(Box::new)
                    }
                }
                impl<T> ValueParserFactory for std::sync::Arc<T> where
                    T: ValueParserFactory,
                    <T as ValueParserFactory>::Parser: TypedValueParser<Value = T>,
                    T: Send + Sync + Clone,
                {
                    type Parser = MapValueParser<<T as ValueParserFactory>::Parser, fn(T) -> std::sync::Arc<T>>;
                    fn value_parser() -> Self::Parser {
                        T::value_parser().map(std::sync::Arc::new)
                    }
                }

                #[doc(hidden)]
                #[derive(Debug)]
                #[allow(non_camel_case_types)]
                pub struct _infer_ValueParser_for<T>(std::marker::PhantomData<T>);

                impl<T> _infer_ValueParser_for<T> {
                    #[doc(hidden)]
                    #[allow(clippy::new_without_default)]
                    pub fn new() -> Self {
                        Self(Default::default())
                    }
                }
                /// Unstable [`ValueParser`]
                ///
                /// Implementation may change to more specific instance in the future
                #[doc(hidden)]
                #[derive(Debug)]
                pub struct _AnonymousValueParser(ValueParser);

                #[doc(hidden)]
                pub mod impl_prelude {
                    use super::*;

                    #[doc(hidden)]
                    #[allow(non_camel_case_types)]
                    pub trait _impls_ValueParserFactory: private::_impls_ValueParserFactorySealed {
                        type Parser;
                        fn value_parser(&self) -> Self::Parser;
                    }
                    impl<P: ValueParserFactory> _impls_ValueParserFactory for &&&&&&_infer_ValueParser_for<P> {
                        type Parser = P::Parser;
                        fn value_parser(&self) -> Self::Parser {
                            P::value_parser()
                        }
                    }

                    #[doc(hidden)]
                    #[allow(non_camel_case_types)]
                    pub trait _impls_ValueEnum: private::_impls_ValueEnumSealed {
                        type Output;

                        fn value_parser(&self) -> Self::Output;
                    }
                    impl<E: crate::ValueEnum + Clone + Send + Sync + 'static> _impls_ValueEnum
                        for &&&&&_infer_ValueParser_for<E>
                    {
                        type Output = EnumValueParser<E>;

                        fn value_parser(&self) -> Self::Output {
                            EnumValueParser::<E>::new()
                        }
                    }

                    #[doc(hidden)]
                    #[allow(non_camel_case_types)]
                    pub trait _impls_From_OsString: private::_impls_From_OsStringSealed {
                        fn value_parser(&self) -> _AnonymousValueParser;
                    }
                    impl<FromOsString> _impls_From_OsString for &&&&_infer_ValueParser_for<FromOsString>
                    where
                        FromOsString: From<std::ffi::OsString> + std::any::Any + Clone + Send + Sync + 'static,
                    {
                        fn value_parser(&self) -> _AnonymousValueParser {
                            _AnonymousValueParser(
                                OsStringValueParser::new()
                                    .map(|s| FromOsString::from(s))
                                    .into(),
                            )
                        }
                    }

                    #[doc(hidden)]
                    #[allow(non_camel_case_types)]
                    pub trait _impls_From_OsStr: private::_impls_From_OsStrSealed {
                        fn value_parser(&self) -> _AnonymousValueParser;
                    }
                    impl<FromOsStr> _impls_From_OsStr for &&&_infer_ValueParser_for<FromOsStr>
                    where
                        FromOsStr:
                            for<'s> From<&'s std::ffi::OsStr> + std::any::Any + Clone + Send + Sync + 'static,
                    {
                        fn value_parser(&self) -> _AnonymousValueParser {
                            _AnonymousValueParser(
                                OsStringValueParser::new()
                                    .map(|s| FromOsStr::from(&s))
                                    .into(),
                            )
                        }
                    }

                    #[doc(hidden)]
                    #[allow(non_camel_case_types)]
                    pub trait _impls_From_String: private::_impls_From_StringSealed {
                        fn value_parser(&self) -> _AnonymousValueParser;
                    }
                    impl<FromString> _impls_From_String for &&_infer_ValueParser_for<FromString>
                    where
                        FromString: From<String> + std::any::Any + Clone + Send + Sync + 'static,
                    {
                        fn value_parser(&self) -> _AnonymousValueParser {
                            _AnonymousValueParser(StringValueParser::new().map(|s| FromString::from(s)).into())
                        }
                    }

                    #[doc(hidden)]
                    #[allow(non_camel_case_types)]
                    pub trait _impls_From_str: private::_impls_From_strSealed {
                        fn value_parser(&self) -> _AnonymousValueParser;
                    }
                    impl<FromStr> _impls_From_str for &_infer_ValueParser_for<FromStr>
                    where
                        FromStr: for<'s> From<&'s str> + std::any::Any + Clone + Send + Sync + 'static,
                    {
                        fn value_parser(&self) -> _AnonymousValueParser {
                            _AnonymousValueParser(StringValueParser::new().map(|s| FromStr::from(&s)).into())
                        }
                    }

                    #[doc(hidden)]
                    #[allow(non_camel_case_types)]
                    pub trait _impls_FromStr: private::_impls_FromStrSealed {
                        fn value_parser(&self) -> _AnonymousValueParser;
                    }
                    impl<Parse> _impls_FromStr for _infer_ValueParser_for<Parse>
                    where
                        Parse: std::str::FromStr + std::any::Any + Clone + Send + Sync + 'static,
                        <Parse as std::str::FromStr>::Err: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
                    {
                        fn value_parser(&self) -> _AnonymousValueParser {
                            let func: fn(&str) -> Result<Parse, <Parse as std::str::FromStr>::Err> =
                                Parse::from_str;
                            _AnonymousValueParser(ValueParser::new(func))
                        }
                    }
                }
                /// Select a [`ValueParser`] implementation from the intended type.
                #[macro_export]
                macro_rules! value_parser {
                    ($name:ty) => {{
                        use $crate::builder::impl_prelude::*;
                        let auto = $crate::builder::_infer_ValueParser_for::<$name>::new();
                        (&&&&&&auto).value_parser()
                    }};
                }

                mod private {
                    use super::*;

                    #[allow(non_camel_case_types)]
                    pub trait _impls_ValueParserFactorySealed {}
                    impl<P: ValueParserFactory> _impls_ValueParserFactorySealed for &&&&&&_infer_ValueParser_for<P> {}

                    #[allow(non_camel_case_types)]
                    pub trait _impls_ValueEnumSealed {}
                    impl<E: crate::ValueEnum> _impls_ValueEnumSealed for &&&&&_infer_ValueParser_for<E> {}

                    #[allow(non_camel_case_types)]
                    pub trait _impls_From_OsStringSealed {}
                    impl<FromOsString> _impls_From_OsStringSealed for &&&&_infer_ValueParser_for<FromOsString> where
                        FromOsString: From<std::ffi::OsString> + std::any::Any + Send + Sync + 'static
                    {
                    }

                    #[allow(non_camel_case_types)]
                    pub trait _impls_From_OsStrSealed {}
                    impl<FromOsStr> _impls_From_OsStrSealed for &&&_infer_ValueParser_for<FromOsStr> where
                        FromOsStr: for<'s> From<&'s std::ffi::OsStr> + std::any::Any + Send + Sync + 'static
                    {
                    }

                    #[allow(non_camel_case_types)]
                    pub trait _impls_From_StringSealed {}
                    impl<FromString> _impls_From_StringSealed for &&_infer_ValueParser_for<FromString> where
                        FromString: From<String> + std::any::Any + Send + Sync + 'static
                    {
                    }

                    #[allow(non_camel_case_types)]
                    pub trait _impls_From_strSealed {}
                    impl<FromStr> _impls_From_strSealed for &_infer_ValueParser_for<FromStr> where
                        FromStr: for<'s> From<&'s str> + std::any::Any + Send + Sync + 'static
                    {
                    }

                    #[allow(non_camel_case_types)]
                    pub trait _impls_FromStrSealed {}
                    impl<Parse> _impls_FromStrSealed for _infer_ValueParser_for<Parse>
                    where
                        Parse: std::str::FromStr + std::any::Any + Send + Sync + 'static,
                        <Parse as std::str::FromStr>::Err: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
                    {
                    }
                }
            }

            pub use self::str::Str;
            pub use action::ArgAction;
            pub use arg::Arg;
            
            pub use arg::ArgExt;
            pub use arg_group::ArgGroup;
            pub use arg_predicate::ArgPredicate;
            pub use command::Command;
            
            pub use command::CommandExt;
            pub use os_str::OsStr;
            pub use possible_value::PossibleValue;
            pub use range::ValueRange;
            pub use resettable::IntoResettable;
            pub use resettable::Resettable;
            pub use styled_str::StyledStr;
            pub use styling::Styles;
            pub use value_hint::ValueHint;
            pub use value_parser::BoolValueParser;
            pub use value_parser::_infer_ValueParser_for;
            pub use value_parser::impl_prelude;
            pub use value_parser::BoolishValueParser;
            pub use value_parser::EnumValueParser;
            pub use value_parser::FalseyValueParser;
            pub use value_parser::MapValueParser;
            pub use value_parser::NonEmptyStringValueParser;
            pub use value_parser::OsStringValueParser;
            pub use value_parser::PathBufValueParser;
            pub use value_parser::PossibleValuesParser;
            pub use value_parser::RangedI64ValueParser;
            pub use value_parser::RangedU64ValueParser;
            pub use value_parser::StringValueParser;
            pub use value_parser::TryMapValueParser;
            pub use value_parser::TypedValueParser;
            pub use value_parser::UnknownArgumentValueParser;
            pub use value_parser::ValueParser;
            pub use value_parser::ValueParserFactory;
            pub use value_parser::_AnonymousValueParser;

            #[allow(unused_imports)]
            pub use self::str::Inner as StrInner;
            pub use action::CountType;
            pub use arg_settings::{ArgFlags, ArgSettings};
            pub use command::AppExt;
        }

        pub mod error
        {   
            //! Error reporting 
            use ::
            {
                *,
            };
            /*
            // Std
            use std::{
                borrow::Cow,
                convert::From,
                error,
                fmt::{self, Debug, Display, Formatter},
                io,
                result::Result as StdResult,
            };

            // Internal
            use crate::builder::StyledStr;
            use crate::builder::Styles;
            use crate::output::fmt::Colorizer;
            use crate::output::fmt::Stream;
            use crate::parser::features::suggestions;
            use crate::util::FlatMap;
            use crate::util::{color::ColorChoice, SUCCESS_CODE, USAGE_CODE};
            use crate::Command;
            */
            
            pub mod context
            {
                use ::
                {
                    *,
                };
                /// Semantics for a piece of error information
                #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
                #[non_exhaustive]
                
                pub enum ContextKind {
                    /// The cause of the error
                    InvalidSubcommand,
                    /// The cause of the error
                    InvalidArg,
                    /// Existing arguments
                    PriorArg,
                    /// Accepted subcommands
                    ValidSubcommand,
                    /// Accepted values
                    ValidValue,
                    /// Rejected values
                    InvalidValue,
                    /// Number of values present
                    ActualNumValues,
                    /// Number of allowed values
                    ExpectedNumValues,
                    /// Minimum number of allowed values
                    MinValues,
                    /// Potential fix for the user
                    SuggestedCommand,
                    /// Potential fix for the user
                    SuggestedSubcommand,
                    /// Potential fix for the user
                    SuggestedArg,
                    /// Potential fix for the user
                    SuggestedValue,
                    /// Trailing argument
                    TrailingArg,
                    /// Potential fix for the user
                    Suggested,
                    /// A usage string
                    Usage,
                    /// An opaque message to the user
                    Custom,
                }

                impl ContextKind {
                    /// End-user description of the error case, where relevant
                    pub fn as_str(self) -> Option<&'static str> {
                        match self {
                            Self::InvalidSubcommand => Some("Invalid Subcommand"),
                            Self::InvalidArg => Some("Invalid Argument"),
                            Self::PriorArg => Some("Prior Argument"),
                            Self::ValidSubcommand => Some("Valid Subcommand"),
                            Self::ValidValue => Some("Valid Value"),
                            Self::InvalidValue => Some("Invalid Value"),
                            Self::ActualNumValues => Some("Actual Number of Values"),
                            Self::ExpectedNumValues => Some("Expected Number of Values"),
                            Self::MinValues => Some("Minimum Number of Values"),
                            Self::SuggestedCommand => Some("Suggested Command"),
                            Self::SuggestedSubcommand => Some("Suggested Subcommand"),
                            Self::SuggestedArg => Some("Suggested Argument"),
                            Self::SuggestedValue => Some("Suggested Value"),
                            Self::TrailingArg => Some("Trailing Argument"),
                            Self::Suggested => Some("Suggested"),
                            Self::Usage => None,
                            Self::Custom => None,
                        }
                    }
                }

                impl std::fmt::Display for ContextKind {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        self.as_str().unwrap_or_default().fmt(f)
                    }
                }
                /// A piece of error information
                #[derive(Clone, Debug, PartialEq, Eq)]
                #[non_exhaustive]
                
                pub enum ContextValue {
                    /// [`ContextKind`] is self-sufficient, no additional information needed
                    None,
                    /// A single value
                    Bool(bool),
                    /// A single value
                    String(String),
                    /// Many values
                    Strings(Vec<String>),
                    /// A single value
                    StyledStr(crate::builder::StyledStr),
                    /// many value
                    StyledStrs(Vec<crate::builder::StyledStr>),
                    /// A single value
                    Number(isize),
                }

                impl std::fmt::Display for ContextValue {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        match self {
                            Self::None => "".fmt(f),
                            Self::Bool(v) => v.fmt(f),
                            Self::String(v) => v.fmt(f),
                            Self::Strings(v) => v.join(", ").fmt(f),
                            Self::StyledStr(v) => v.fmt(f),
                            Self::StyledStrs(v) => {
                                for (i, v) in v.iter().enumerate() {
                                    if i != 0 {
                                        ", ".fmt(f)?;
                                    }
                                    v.fmt(f)?;
                                }
                                Ok(())
                            }
                            Self::Number(v) => v.fmt(f),
                        }
                    }
                }
            }

            pub mod format
            {
                use ::
                {
                    *,
                };
                
                use std::borrow::Cow;

                use crate::builder::Command;
                use crate::builder::StyledStr;
                use crate::builder::Styles;
                
                use crate::error::ContextKind;
                
                use crate::error::ContextValue;
                use crate::error::ErrorKind;
                use crate::output::TAB;
                use crate::ArgAction;

                /// Defines how to format an error for displaying to the user
                pub trait ErrorFormatter: Sized {
                    /// Stylize the error for the terminal
                    fn format_error(error: &crate::error::Error<Self>) -> StyledStr;
                }
                /// Report [`ErrorKind`]
                ///
                /// No context is included.
                ///
                /// <div class="warning">
                ///
                /// **NOTE:** Consider removing the `error-context` default feature if using this to remove all
                /// overhead for [`RichFormatter`].
                ///
                /// </div>
                #[non_exhaustive]
                pub struct KindFormatter;

                impl ErrorFormatter for KindFormatter {
                    fn format_error(error: &crate::error::Error<Self>) -> StyledStr {
                        use std::fmt::Write as _;
                        let styles = &error.inner.styles;

                        let mut styled = StyledStr::new();
                        start_error(&mut styled, styles);
                        if let Some(msg) = error.kind().as_str() {
                            styled.push_str(msg);
                        } else if let Some(source) = error.inner.source.as_ref() {
                            let _ = write!(styled, "{source}");
                        } else {
                            styled.push_str("unknown cause");
                        }
                        styled.push_str("\n");
                        styled
                    }
                }
                /// Richly formatted error context
                ///
                /// This follows the [rustc diagnostic style guide](https://rustc-dev-guide.rust-lang.org/diagnostics.html#suggestion-style-guide).
                #[non_exhaustive]
                
                pub struct RichFormatter;

                
                impl ErrorFormatter for RichFormatter {
                    fn format_error(error: &crate::error::Error<Self>) -> StyledStr {
                        use std::fmt::Write as _;
                        let styles = &error.inner.styles;
                        let valid = &styles.get_valid();

                        let mut styled = StyledStr::new();
                        start_error(&mut styled, styles);

                        if !write_dynamic_context(error, &mut styled, styles) {
                            if let Some(msg) = error.kind().as_str() {
                                styled.push_str(msg);
                            } else if let Some(source) = error.inner.source.as_ref() {
                                let _ = write!(styled, "{source}");
                            } else {
                                styled.push_str("unknown cause");
                            }
                        }

                        let mut suggested = false;
                        if let Some(valid) = error.get(ContextKind::SuggestedSubcommand) {
                            styled.push_str("\n");
                            if !suggested {
                                styled.push_str("\n");
                                suggested = true;
                            }
                            did_you_mean(&mut styled, styles, "subcommand", valid);
                        }
                        if let Some(valid) = error.get(ContextKind::SuggestedArg) {
                            styled.push_str("\n");
                            if !suggested {
                                styled.push_str("\n");
                                suggested = true;
                            }
                            did_you_mean(&mut styled, styles, "argument", valid);
                        }
                        if let Some(valid) = error.get(ContextKind::SuggestedValue) {
                            styled.push_str("\n");
                            if !suggested {
                                styled.push_str("\n");
                                suggested = true;
                            }
                            did_you_mean(&mut styled, styles, "value", valid);
                        }
                        let suggestions = error.get(ContextKind::Suggested);
                        if let Some(ContextValue::StyledStrs(suggestions)) = suggestions {
                            if !suggested {
                                styled.push_str("\n");
                            }
                            for suggestion in suggestions {
                                let _ = write!(styled, "\n{TAB}{valid}tip:{valid:#} ",);
                                styled.push_styled(suggestion);
                            }
                        }

                        let usage = error.get(ContextKind::Usage);
                        if let Some(ContextValue::StyledStr(usage)) = usage {
                            put_usage(&mut styled, usage);
                        }

                        try_help(&mut styled, styles, error.inner.help_flag.as_deref());

                        styled
                    }
                }

                fn start_error(styled: &mut StyledStr, styles: &Styles) {
                    use std::fmt::Write as _;
                    let error = &styles.get_error();
                    let _ = write!(styled, "{error}error:{error:#} ");
                }

                #[must_use]
                
                fn write_dynamic_context(
                    error: &crate::error::Error,
                    styled: &mut StyledStr,
                    styles: &Styles,
                ) -> bool {
                    use std::fmt::Write as _;
                    let valid = styles.get_valid();
                    let invalid = styles.get_invalid();
                    let literal = styles.get_literal();

                    match error.kind() {
                        ErrorKind::ArgumentConflict => {
                            let mut prior_arg = error.get(ContextKind::PriorArg);
                            if let Some(ContextValue::String(invalid_arg)) = error.get(ContextKind::InvalidArg) {
                                if Some(&ContextValue::String(invalid_arg.clone())) == prior_arg {
                                    prior_arg = None;
                                    let _ = write!(
                                        styled,
                                        "the argument '{invalid}{invalid_arg}{invalid:#}' cannot be used multiple times",
                                    );
                                } else {
                                    let _ = write!(
                                        styled,
                                        "the argument '{invalid}{invalid_arg}{invalid:#}' cannot be used with",
                                    );
                                }
                            } else if let Some(ContextValue::String(invalid_arg)) =
                                error.get(ContextKind::InvalidSubcommand)
                            {
                                let _ = write!(
                                    styled,
                                    "the subcommand '{invalid}{invalid_arg}{invalid:#}' cannot be used with",
                                );
                            } else {
                                styled.push_str(error.kind().as_str().unwrap());
                            }

                            if let Some(prior_arg) = prior_arg {
                                match prior_arg {
                                    ContextValue::Strings(values) => {
                                        styled.push_str(":");
                                        for v in values {
                                            let _ = write!(styled, "\n{TAB}{invalid}{v}{invalid:#}",);
                                        }
                                    }
                                    ContextValue::String(value) => {
                                        let _ = write!(styled, " '{invalid}{value}{invalid:#}'",);
                                    }
                                    _ => {
                                        styled.push_str(" one or more of the other specified arguments");
                                    }
                                }
                            }

                            true
                        }
                        ErrorKind::NoEquals => {
                            let invalid_arg = error.get(ContextKind::InvalidArg);
                            if let Some(ContextValue::String(invalid_arg)) = invalid_arg {
                                let _ = write!(
                                    styled,
                                    "equal sign is needed when assigning values to '{invalid}{invalid_arg}{invalid:#}'",
                                );
                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::InvalidValue => {
                            let invalid_arg = error.get(ContextKind::InvalidArg);
                            let invalid_value = error.get(ContextKind::InvalidValue);
                            if let (
                                Some(ContextValue::String(invalid_arg)),
                                Some(ContextValue::String(invalid_value)),
                            ) = (invalid_arg, invalid_value)
                            {
                                if invalid_value.is_empty() {
                                    let _ = write!(
                                        styled,
                                        "a value is required for '{invalid}{invalid_arg}{invalid:#}' but none was supplied",
                                    );
                                } else {
                                    let _ = write!(
                                        styled,
                                        "invalid value '{invalid}{invalid_value}{invalid:#}' for '{literal}{invalid_arg}{literal:#}'",
                                    );
                                }

                                let values = error.get(ContextKind::ValidValue);
                                write_values_list("possible values", styled, valid, values);

                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::InvalidSubcommand => {
                            let invalid_sub = error.get(ContextKind::InvalidSubcommand);
                            if let Some(ContextValue::String(invalid_sub)) = invalid_sub {
                                let _ = write!(
                                    styled,
                                    "unrecognized subcommand '{invalid}{invalid_sub}{invalid:#}'",
                                );
                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::MissingRequiredArgument => {
                            let invalid_arg = error.get(ContextKind::InvalidArg);
                            if let Some(ContextValue::Strings(invalid_arg)) = invalid_arg {
                                styled.push_str("the following required arguments were not provided:");
                                for v in invalid_arg {
                                    let _ = write!(styled, "\n{TAB}{valid}{v}{valid:#}",);
                                }
                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::MissingSubcommand => {
                            let invalid_sub = error.get(ContextKind::InvalidSubcommand);
                            if let Some(ContextValue::String(invalid_sub)) = invalid_sub {
                                let _ = write!(
                                    styled,
                                    "'{invalid}{invalid_sub}{invalid:#}' requires a subcommand but one was not provided",
                                );
                                let values = error.get(ContextKind::ValidSubcommand);
                                write_values_list("subcommands", styled, valid, values);

                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::InvalidUtf8 => false,
                        ErrorKind::TooManyValues => {
                            let invalid_arg = error.get(ContextKind::InvalidArg);
                            let invalid_value = error.get(ContextKind::InvalidValue);
                            if let (
                                Some(ContextValue::String(invalid_arg)),
                                Some(ContextValue::String(invalid_value)),
                            ) = (invalid_arg, invalid_value)
                            {
                                let _ = write!(
                                    styled,
                                    "unexpected value '{invalid}{invalid_value}{invalid:#}' for '{literal}{invalid_arg}{literal:#}' found; no more were expected",
                                );
                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::TooFewValues => {
                            let invalid_arg = error.get(ContextKind::InvalidArg);
                            let actual_num_values = error.get(ContextKind::ActualNumValues);
                            let min_values = error.get(ContextKind::MinValues);
                            if let (
                                Some(ContextValue::String(invalid_arg)),
                                Some(ContextValue::Number(actual_num_values)),
                                Some(ContextValue::Number(min_values)),
                            ) = (invalid_arg, actual_num_values, min_values)
                            {
                                let were_provided = singular_or_plural(*actual_num_values as usize);
                                let _ = write!(
                                    styled,
                                    "{valid}{min_values}{valid:#} values required by '{literal}{invalid_arg}{literal:#}'; only {invalid}{actual_num_values}{invalid:#}{were_provided}",
                                );
                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::ValueValidation => {
                            let invalid_arg = error.get(ContextKind::InvalidArg);
                            let invalid_value = error.get(ContextKind::InvalidValue);
                            if let (
                                Some(ContextValue::String(invalid_arg)),
                                Some(ContextValue::String(invalid_value)),
                            ) = (invalid_arg, invalid_value)
                            {
                                let _ = write!(
                                    styled,
                                    "invalid value '{invalid}{invalid_value}{invalid:#}' for '{literal}{invalid_arg}{literal:#}'",
                                );
                                if let Some(source) = error.inner.source.as_deref() {
                                    let _ = write!(styled, ": {source}");
                                }
                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::WrongNumberOfValues => {
                            let invalid_arg = error.get(ContextKind::InvalidArg);
                            let actual_num_values = error.get(ContextKind::ActualNumValues);
                            let num_values = error.get(ContextKind::ExpectedNumValues);
                            if let (
                                Some(ContextValue::String(invalid_arg)),
                                Some(ContextValue::Number(actual_num_values)),
                                Some(ContextValue::Number(num_values)),
                            ) = (invalid_arg, actual_num_values, num_values)
                            {
                                let were_provided = singular_or_plural(*actual_num_values as usize);
                                let _ = write!(
                                    styled,
                                    "{valid}{num_values}{valid:#} values required for '{literal}{invalid_arg}{literal:#}' but {invalid}{actual_num_values}{invalid:#}{were_provided}",
                                );
                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::UnknownArgument => {
                            let invalid_arg = error.get(ContextKind::InvalidArg);
                            if let Some(ContextValue::String(invalid_arg)) = invalid_arg {
                                let _ = write!(
                                    styled,
                                    "unexpected argument '{invalid}{invalid_arg}{invalid:#}' found",
                                );
                                true
                            } else {
                                false
                            }
                        }
                        ErrorKind::DisplayHelp
                        | ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand
                        | ErrorKind::DisplayVersion
                        | ErrorKind::Io
                        | ErrorKind::Format => false,
                    }
                }

                
                fn write_values_list(
                    list_name: &'static str,
                    styled: &mut StyledStr,
                    valid: &anstyle::Style,
                    possible_values: Option<&ContextValue>,
                ) {
                    use std::fmt::Write as _;
                    if let Some(ContextValue::Strings(possible_values)) = possible_values {
                        if !possible_values.is_empty() {
                            let _ = write!(styled, "\n{TAB}[{list_name}: ");

                            for (idx, val) in possible_values.iter().enumerate() {
                                if idx > 0 {
                                    styled.push_str(", ");
                                }
                                let _ = write!(styled, "{valid}{}{valid:#}", Escape(val));
                            }

                            styled.push_str("]");
                        }
                    }
                }

                pub fn format_error_message(
                    message: &str,
                    styles: &Styles,
                    cmd: Option<&Command>,
                    usage: Option<&StyledStr>,
                ) -> StyledStr {
                    let mut styled = StyledStr::new();
                    start_error(&mut styled, styles);
                    styled.push_str(message);
                    if let Some(usage) = usage {
                        put_usage(&mut styled, usage);
                    }
                    if let Some(cmd) = cmd {
                        try_help(&mut styled, styles, get_help_flag(cmd).as_deref());
                    }
                    styled
                }
                /// Returns the singular or plural form on the verb to be based on the argument's value.
                fn singular_or_plural(n: usize) -> &'static str {
                    if n > 1 {
                        " were provided"
                    } else {
                        " was provided"
                    }
                }

                fn put_usage(styled: &mut StyledStr, usage: &StyledStr) {
                    styled.push_str("\n\n");
                    styled.push_styled(usage);
                }

                pub fn get_help_flag(cmd: &Command) -> Option<Cow<'static, str>> {
                    if !cmd.is_disable_help_flag_set() {
                        Some(Cow::Borrowed("--help"))
                    } else if let Some(flag) = get_user_help_flag(cmd) {
                        Some(Cow::Owned(flag))
                    } else if cmd.has_subcommands() && !cmd.is_disable_help_subcommand_set() {
                        Some(Cow::Borrowed("help"))
                    } else {
                        None
                    }
                }

                fn get_user_help_flag(cmd: &Command) -> Option<String> {
                    let arg = cmd.get_arguments().find(|arg| match arg.get_action() {
                        ArgAction::Help | ArgAction::HelpShort | ArgAction::HelpLong => true,
                        ArgAction::Append
                        | ArgAction::Count
                        | ArgAction::SetTrue
                        | ArgAction::SetFalse
                        | ArgAction::Set
                        | ArgAction::Version => false,
                    })?;

                    arg.get_long()
                        .map(|long| format!("--{long}"))
                        .or_else(|| arg.get_short().map(|short| format!("-{short}")))
                }

                fn try_help(styled: &mut StyledStr, styles: &Styles, help: Option<&str>) {
                    if let Some(help) = help {
                        use std::fmt::Write as _;
                        let literal = &styles.get_literal();
                        let _ = write!(
                            styled,
                            "\n\nFor more information, try '{literal}{help}{literal:#}'.\n",
                        );
                    } else {
                        styled.push_str("\n");
                    }
                }

                
                fn did_you_mean(styled: &mut StyledStr, styles: &Styles, context: &str, possibles: &ContextValue) {
                    use std::fmt::Write as _;

                    let valid = &styles.get_valid();
                    let _ = write!(styled, "{TAB}{valid}tip:{valid:#}",);
                    if let ContextValue::String(possible) = possibles {
                        let _ = write!(
                            styled,
                            " a similar {context} exists: '{valid}{possible}{valid:#}'",
                        );
                    } else if let ContextValue::Strings(possibles) = possibles {
                        if possibles.len() == 1 {
                            let _ = write!(styled, " a similar {context} exists: ",);
                        } else {
                            let _ = write!(styled, " some similar {context}s exist: ",);
                        }
                        for (i, possible) in possibles.iter().enumerate() {
                            if i != 0 {
                                styled.push_str(", ");
                            }
                            let _ = write!(styled, "'{valid}{possible}{valid:#}'",);
                        }
                    }
                }

                struct Escape<'s>(&'s str);

                impl std::fmt::Display for Escape<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        if self.0.contains(char::is_whitespace) {
                            std::fmt::Debug::fmt(self.0, f)
                        } else {
                            self.0.fmt(f)
                        }
                    }
                }
            }

            pub mod kind
            {
                use ::
                {
                    *,
                };
                /// Command line argument parser kind of error
                #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
                #[non_exhaustive]
                pub enum ErrorKind {
                    /// Occurs when an [`Arg`] has a set of possible values, and the user provides a value which isn't in that set.
                    InvalidValue,

                    /// Occurs when a user provides a flag, option, argument or subcommand which isn't defined.
                    UnknownArgument,

                    /// Occurs when the user provides an unrecognized [`Subcommand`] which meets the threshold for
                    /// being similar enough to an existing subcommand.
                    InvalidSubcommand,

                    /// Occurs when the user doesn't use equals for an option that requires equal
                    /// sign to provide values.
                    NoEquals,

                    /// Occurs when the user provides a value for an argument with a custom validation and the value fails that validation.
                    ValueValidation,

                    /// Occurs when a user provides more values for an argument than were defined by setting [`Arg::num_args`].
                    TooManyValues,

                    /// Occurs when the user provides fewer values for an argument than were defined by setting [`Arg::num_args`].
                    TooFewValues,

                    /// Occurs when the user provides a different number of values for an argument than what's
                    /// been defined by setting [`Arg::num_args`] or than was implicitly set by
                    /// [`Arg::value_names`].
                    WrongNumberOfValues,

                    /// Occurs when the user provides two values which conflict with each other and can't be used together.
                    ArgumentConflict,

                    /// Occurs when the user does not provide one or more required arguments.
                    MissingRequiredArgument,

                    /// Occurs when a subcommand is required (as defined by [`Command::subcommand_required`]), but the user does not provide one.
                    MissingSubcommand,

                    /// Occurs when the user provides a value containing invalid UTF-8.
                    InvalidUtf8,

                    /// Not a true "error" as it means `--help` or similar was used.
                    DisplayHelp,

                    /// Occurs when either an argument or a [`Subcommand`] is required,
                    /// as defined by [`Command::arg_required_else_help`] , but the user did not provide one.
                    DisplayHelpOnMissingArgumentOrSubcommand,

                    /// Not a true "error" as it means `--version` or similar was used.
                    DisplayVersion,

                    /// Represents an [I/O error].
                    Io,

                    /// Represents a [Format error] (which is a part of [`Display`]).
                    Format,
                }

                impl ErrorKind {
                    /// End-user description of the error case, where relevant
                    pub fn as_str(self) -> Option<&'static str> {
                        match self {
                            Self::InvalidValue => Some("one of the values isn't valid for an argument"),
                            Self::UnknownArgument => Some("unexpected argument found"),
                            Self::InvalidSubcommand => Some("unrecognized subcommand"),
                            Self::NoEquals => Some("equal is needed when assigning values to one of the arguments"),
                            Self::ValueValidation => Some("invalid value for one of the arguments"),
                            Self::TooManyValues => Some("unexpected value for an argument found"),
                            Self::TooFewValues => Some("more values required for an argument"),
                            Self::WrongNumberOfValues => Some("too many or too few values for an argument"),
                            Self::ArgumentConflict => {
                                Some("an argument cannot be used with one or more of the other specified arguments")
                            }
                            Self::MissingRequiredArgument => {
                                Some("one or more required arguments were not provided")
                            }
                            Self::MissingSubcommand => Some("a subcommand is required but one was not provided"),
                            Self::InvalidUtf8 => Some("invalid UTF-8 was detected in one or more arguments"),
                            Self::DisplayHelp => None,
                            Self::DisplayHelpOnMissingArgumentOrSubcommand => None,
                            Self::DisplayVersion => None,
                            Self::Io => None,
                            Self::Format => None,
                        }
                    }
                }

                impl std::fmt::Display for ErrorKind {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        self.as_str().unwrap_or_default().fmt(f)
                    }
                }
            }

            pub use format::ErrorFormatter;
            pub use format::KindFormatter;
            pub use kind::ErrorKind;
            pub use context::ContextKind;
            pub use context::ContextValue;
            pub use format::RichFormatter; 
            pub use RichFormatter as DefaultFormatter;
            /// Short hand for [`Result`] type
            pub type Result<T, E = Error> = StdResult<T, E>;
            /// Command Line Argument Parser Error.
            pub struct Error<F: ErrorFormatter = DefaultFormatter> 
            {
                inner: Box<ErrorInner>,
                phantom: std::marker::PhantomData<F>,
            }

            #[derive(Debug)]
            struct ErrorInner 
            {
                kind: ErrorKind,
                
                context: FlatMap<ContextKind, ContextValue>,
                message: Option<Message>,
                source: Option<Box<dyn error::Error + Send + Sync>>,
                help_flag: Option<Cow<'static, str>>,
                styles: Styles,
                color_when: ColorChoice,
                color_help_when: ColorChoice,
                backtrace: Option<Backtrace>,
            }

            impl<F: ErrorFormatter> Error<F> 
            {
                /// Create an unformatted error.
                pub fn raw(kind: ErrorKind, message: impl Display) -> Self {
                    Self::new(kind).set_message(message.to_string())
                }
                /// Format the existing message with the Command's context
                #[must_use]
                pub fn format(mut self, cmd: &mut Command) -> Self {
                    cmd._build_self(false);
                    let usage = cmd.render_usage_();
                    if let Some(message) = self.inner.message.as_mut() {
                        message.format(cmd, usage);
                    }
                    self.with_cmd(cmd)
                }
                /// Create an error with a pre-defined message.
                pub fn new(kind: ErrorKind) -> Self {
                    Self {
                        inner: Box::new(ErrorInner {
                            kind,
                            
                            context: FlatMap::new(),
                            message: None,
                            source: None,
                            help_flag: None,
                            styles: Styles::plain(),
                            color_when: ColorChoice::Never,
                            color_help_when: ColorChoice::Never,
                            backtrace: Backtrace::new(),
                        }),
                        phantom: Default::default(),
                    }
                }
                /// Apply [`Command`]'s formatting to the error.
                pub fn with_cmd(self, cmd: &Command) -> Self {
                    self.set_styles(cmd.get_styles().clone())
                        .set_color(cmd.get_color())
                        .set_colored_help(cmd.color_help())
                        .set_help_flag(format::get_help_flag(cmd))
                }
                /// Apply an alternative formatter to the error.
                pub fn apply<EF: ErrorFormatter>(self) -> Error<EF> {
                    Error {
                        inner: self.inner,
                        phantom: Default::default(),
                    }
                }
                /// Type of error for programmatic processing
                pub fn kind(&self) -> ErrorKind {
                    self.inner.kind
                }
                /// Additional information to further qualify the error
                
                pub fn context(&self) -> impl Iterator<Item = (ContextKind, &ContextValue)> {
                    self.inner.context.iter().map(|(k, v)| (*k, v))
                }
                /// Lookup a piece of context
                #[inline(never)]
                
                pub fn get(&self, kind: ContextKind) -> Option<&ContextValue> {
                    self.inner.context.get(&kind)
                }
                /// Insert a piece of context.
                #[inline(never)]
                
                pub fn insert(&mut self, kind: ContextKind, value: ContextValue) -> Option<ContextValue> {
                    self.inner.context.insert(kind, value)
                }
                /// Remove a piece of context, return the old value if any.
                #[inline(never)]
                
                pub fn remove(&mut self, kind: ContextKind) -> Option<ContextValue> {
                    self.inner.context.remove(&kind)
                }
                /// Should the message be written to `stdout` or not?
                #[inline]
                pub fn use_stderr(&self) -> bool {
                    self.stream() == Stream::Stderr
                }

                pub fn stream(&self) -> Stream {
                    match self.kind() {
                        ErrorKind::DisplayHelp | ErrorKind::DisplayVersion => Stream::Stdout,
                        _ => Stream::Stderr,
                    }
                }
                /// Returns the exit code that `.exit` will exit the process with..
                pub fn exit_code(&self) -> i32 {
                    if self.use_stderr() {
                        USAGE_CODE
                    } else {
                        SUCCESS_CODE
                    }
                }
                /// Prints the error and exits..
                pub fn exit(&self) -> ! {
                    // Swallow broken pipe errors
                    let _ = self.print();
                    std::process::exit(self.exit_code());
                }
                /// Prints formatted and colored error to `stdout` or `stderr` according to its error kind.
                pub fn print(&self) -> io::Result<()> {
                    let style = self.formatted();
                    let color_when = if matches!(
                        self.kind(),
                        ErrorKind::DisplayHelp | ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand,
                    ) {
                        self.inner.color_help_when
                    } else {
                        self.inner.color_when
                    };
                    let c = Colorizer::new(self.stream(), color_when).with_content(style.into_owned());
                    c.print()
                }
                /// Render the error message to a [`StyledStr`].
                pub fn render(&self) -> StyledStr {
                    self.formatted().into_owned()
                }

                #[inline(never)]
                fn for_app(kind: ErrorKind, cmd: &Command, styled: StyledStr) -> Self {
                    Self::new(kind).set_message(styled).with_cmd(cmd)
                }

                pub fn set_message(mut self, message: impl Into<Message>) -> Self {
                    self.inner.message = Some(message.into());
                    self
                }

                pub fn set_source(mut self, source: Box<dyn error::Error + Send + Sync>) -> Self {
                    self.inner.source = Some(source);
                    self
                }

                pub fn set_styles(mut self, styles: Styles) -> Self {
                    self.inner.styles = styles;
                    self
                }

                pub fn set_color(mut self, color_when: ColorChoice) -> Self {
                    self.inner.color_when = color_when;
                    self
                }

                pub fn set_colored_help(mut self, color_help_when: ColorChoice) -> Self {
                    self.inner.color_help_when = color_help_when;
                    self
                }

                pub fn set_help_flag(mut self, help_flag: Option<Cow<'static, str>>) -> Self {
                    self.inner.help_flag = help_flag;
                    self
                }
                /// Does not verify if `ContextKind` is already present
                #[inline(never)]
                
                pub fn insert_context_unchecked(
                    mut self,
                    kind: ContextKind,
                    value: ContextValue,
                ) -> Self {
                    self.inner.context.insert_unchecked(kind, value);
                    self
                }
                /// Does not verify if `ContextKind` is already present
                #[inline(never)]
                
                pub fn extend_context_unchecked<const N: usize>(
                    mut self,
                    context: [(ContextKind, ContextValue); N],
                ) -> Self {
                    self.inner.context.extend_unchecked(context);
                    self
                }

                pub fn display_help(cmd: &Command, styled: StyledStr) -> Self {
                    Self::for_app(ErrorKind::DisplayHelp, cmd, styled)
                }

                pub fn display_help_error(cmd: &Command, styled: StyledStr) -> Self {
                    Self::for_app(
                        ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand,
                        cmd,
                        styled,
                    )
                }

                pub fn display_version(cmd: &Command, styled: StyledStr) -> Self {
                    Self::for_app(ErrorKind::DisplayVersion, cmd, styled)
                }

                pub fn argument_conflict(
                    cmd: &Command,
                    arg: String,
                    mut others: Vec<String>,
                    usage: Option<StyledStr>,
                ) -> Self {
                    let mut err = Self::new(ErrorKind::ArgumentConflict).with_cmd(cmd);

                    
                    {
                        let others = match others.len() {
                            0 => ContextValue::None,
                            1 => ContextValue::String(others.pop().unwrap()),
                            _ => ContextValue::Strings(others),
                        };
                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidArg, ContextValue::String(arg)),
                            (ContextKind::PriorArg, others),
                        ]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn subcommand_conflict(
                    cmd: &Command,
                    sub: String,
                    mut others: Vec<String>,
                    usage: Option<StyledStr>,
                ) -> Self {
                    let mut err = Self::new(ErrorKind::ArgumentConflict).with_cmd(cmd);

                    
                    {
                        let others = match others.len() {
                            0 => ContextValue::None,
                            1 => ContextValue::String(others.pop().unwrap()),
                            _ => ContextValue::Strings(others),
                        };
                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidSubcommand, ContextValue::String(sub)),
                            (ContextKind::PriorArg, others),
                        ]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn empty_value(cmd: &Command, good_vals: &[String], arg: String) -> Self {
                    Self::invalid_value(cmd, "".to_owned(), good_vals, arg)
                }

                pub fn no_equals(cmd: &Command, arg: String, usage: Option<StyledStr>) -> Self {
                    let mut err = Self::new(ErrorKind::NoEquals).with_cmd(cmd);

                    
                    {
                        err = err
                            .extend_context_unchecked([(ContextKind::InvalidArg, ContextValue::String(arg))]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn invalid_value(
                    cmd: &Command,
                    bad_val: String,
                    good_vals: &[String],
                    arg: String,
                ) -> Self {
                    let suggestion = suggestions::did_you_mean(&bad_val, good_vals.iter()).pop();
                    let mut err = Self::new(ErrorKind::InvalidValue).with_cmd(cmd);

                    
                    {
                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidArg, ContextValue::String(arg)),
                            (ContextKind::InvalidValue, ContextValue::String(bad_val)),
                            (
                                ContextKind::ValidValue,
                                ContextValue::Strings(good_vals.iter().map(|s| (*s).clone()).collect()),
                            ),
                        ]);
                        if let Some(suggestion) = suggestion {
                            err = err.insert_context_unchecked(
                                ContextKind::SuggestedValue,
                                ContextValue::String(suggestion),
                            );
                        }
                    }

                    err
                }

                pub fn invalid_subcommand(
                    cmd: &Command,
                    subcmd: String,
                    did_you_mean: Vec<String>,
                    name: String,
                    suggested_trailing_arg: bool,
                    usage: Option<StyledStr>,
                ) -> Self {
                    use std::fmt::Write as _;
                    let styles = cmd.get_styles();
                    let invalid = &styles.get_invalid();
                    let valid = &styles.get_valid();
                    let mut err = Self::new(ErrorKind::InvalidSubcommand).with_cmd(cmd);

                    
                    {
                        let mut suggestions = vec![];
                        if suggested_trailing_arg {
                            let mut styled_suggestion = StyledStr::new();
                            let _ = write!(
                                styled_suggestion,
                                "to pass '{invalid}{subcmd}{invalid:#}' as a value, use '{valid}{name} -- {subcmd}{valid:#}'",
                            );
                            suggestions.push(styled_suggestion);
                        }

                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidSubcommand, ContextValue::String(subcmd)),
                            (
                                ContextKind::SuggestedSubcommand,
                                ContextValue::Strings(did_you_mean),
                            ),
                            (
                                ContextKind::Suggested,
                                ContextValue::StyledStrs(suggestions),
                            ),
                        ]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn unrecognized_subcommand(
                    cmd: &Command,
                    subcmd: String,
                    usage: Option<StyledStr>,
                ) -> Self {
                    let mut err = Self::new(ErrorKind::InvalidSubcommand).with_cmd(cmd);

                    
                    {
                        err = err.extend_context_unchecked([(
                            ContextKind::InvalidSubcommand,
                            ContextValue::String(subcmd),
                        )]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn missing_required_argument(
                    cmd: &Command,
                    required: Vec<String>,
                    usage: Option<StyledStr>,
                ) -> Self {
                    let mut err = Self::new(ErrorKind::MissingRequiredArgument).with_cmd(cmd);

                    
                    {
                        err = err.extend_context_unchecked([(
                            ContextKind::InvalidArg,
                            ContextValue::Strings(required),
                        )]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn missing_subcommand(
                    cmd: &Command,
                    parent: String,
                    available: Vec<String>,
                    usage: Option<StyledStr>,
                ) -> Self {
                    let mut err = Self::new(ErrorKind::MissingSubcommand).with_cmd(cmd);

                    
                    {
                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidSubcommand, ContextValue::String(parent)),
                            (
                                ContextKind::ValidSubcommand,
                                ContextValue::Strings(available),
                            ),
                        ]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn invalid_utf8(cmd: &Command, usage: Option<StyledStr>) -> Self {
                    let mut err = Self::new(ErrorKind::InvalidUtf8).with_cmd(cmd);

                    
                    {
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn too_many_values(
                    cmd: &Command,
                    val: String,
                    arg: String,
                    usage: Option<StyledStr>,
                ) -> Self {
                    let mut err = Self::new(ErrorKind::TooManyValues).with_cmd(cmd);

                    
                    {
                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidArg, ContextValue::String(arg)),
                            (ContextKind::InvalidValue, ContextValue::String(val)),
                        ]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn too_few_values(
                    cmd: &Command,
                    arg: String,
                    min_vals: usize,
                    curr_vals: usize,
                    usage: Option<StyledStr>,
                ) -> Self {
                    let mut err = Self::new(ErrorKind::TooFewValues).with_cmd(cmd);

                    
                    {
                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidArg, ContextValue::String(arg)),
                            (
                                ContextKind::MinValues,
                                ContextValue::Number(min_vals as isize),
                            ),
                            (
                                ContextKind::ActualNumValues,
                                ContextValue::Number(curr_vals as isize),
                            ),
                        ]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn value_validation(
                    arg: String,
                    val: String,
                    err: Box<dyn error::Error + Send + Sync>,
                ) -> Self {
                    let mut err = Self::new(ErrorKind::ValueValidation).set_source(err);

                    
                    {
                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidArg, ContextValue::String(arg)),
                            (ContextKind::InvalidValue, ContextValue::String(val)),
                        ]);
                    }

                    err
                }

                pub fn wrong_number_of_values(
                    cmd: &Command,
                    arg: String,
                    num_vals: usize,
                    curr_vals: usize,
                    usage: Option<StyledStr>,
                ) -> Self {
                    let mut err = Self::new(ErrorKind::WrongNumberOfValues).with_cmd(cmd);

                    
                    {
                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidArg, ContextValue::String(arg)),
                            (
                                ContextKind::ExpectedNumValues,
                                ContextValue::Number(num_vals as isize),
                            ),
                            (
                                ContextKind::ActualNumValues,
                                ContextValue::Number(curr_vals as isize),
                            ),
                        ]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                pub fn unknown_argument(
                    cmd: &Command,
                    arg: String,
                    did_you_mean: Option<(String, Option<String>)>,
                    suggested_trailing_arg: bool,
                    usage: Option<StyledStr>,
                ) -> Self {
                    use std::fmt::Write as _;
                    let styles = cmd.get_styles();
                    let invalid = &styles.get_invalid();
                    let valid = &styles.get_valid();
                    let mut err = Self::new(ErrorKind::UnknownArgument).with_cmd(cmd);

                    
                    {
                        let mut suggestions = vec![];
                        if suggested_trailing_arg {
                            let mut styled_suggestion = StyledStr::new();
                            let _ = write!(
                                styled_suggestion,
                                "to pass '{invalid}{arg}{invalid:#}' as a value, use '{valid}-- {arg}{valid:#}'",
                            );
                            suggestions.push(styled_suggestion);
                        }

                        err = err
                            .extend_context_unchecked([(ContextKind::InvalidArg, ContextValue::String(arg))]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                        match did_you_mean {
                            Some((flag, Some(sub))) => {
                                let mut styled_suggestion = StyledStr::new();
                                let _ = write!(styled_suggestion, "'{valid}{sub} {flag}{valid:#}' exists",);
                                suggestions.push(styled_suggestion);
                            }
                            Some((flag, None)) => {
                                err = err.insert_context_unchecked(
                                    ContextKind::SuggestedArg,
                                    ContextValue::String(flag),
                                );
                            }
                            None => {}
                        }
                        if !suggestions.is_empty() {
                            err = err.insert_context_unchecked(
                                ContextKind::Suggested,
                                ContextValue::StyledStrs(suggestions),
                            );
                        }
                    }

                    err
                }

                pub fn unnecessary_double_dash(
                    cmd: &Command,
                    arg: String,
                    usage: Option<StyledStr>,
                ) -> Self {
                    use std::fmt::Write as _;
                    let styles = cmd.get_styles();
                    let invalid = &styles.get_invalid();
                    let valid = &styles.get_valid();
                    let mut err = Self::new(ErrorKind::UnknownArgument).with_cmd(cmd);

                    
                    {
                        let mut styled_suggestion = StyledStr::new();
                        let _ = write!(
                            styled_suggestion,
                            "subcommand '{valid}{arg}{valid:#}' exists; to use it, remove the '{invalid}--{invalid:#}' before it",
                        );

                        err = err.extend_context_unchecked([
                            (ContextKind::InvalidArg, ContextValue::String(arg)),
                            (
                                ContextKind::Suggested,
                                ContextValue::StyledStrs(vec![styled_suggestion]),
                            ),
                        ]);
                        if let Some(usage) = usage {
                            err = err
                                .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
                        }
                    }

                    err
                }

                fn formatted(&self) -> Cow<'_, StyledStr> {
                    if let Some(message) = self.inner.message.as_ref() {
                        message.formatted(&self.inner.styles)
                    } else {
                        let styled = F::format_error(self);
                        Cow::Owned(styled)
                    }
                }
            }

            impl<F: ErrorFormatter> From<io::Error> for Error<F> 
            {
                fn from(e: io::Error) -> Self {
                    Error::raw(ErrorKind::Io, e)
                }
            }

            impl<F: ErrorFormatter> From<fmt::Error> for Error<F> 
            {
                fn from(e: fmt::Error) -> Self {
                    Error::raw(ErrorKind::Format, e)
                }
            }

            impl<F: ErrorFormatter> Debug for Error<F> 
            {
                fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
                    self.inner.fmt(f)
                }
            }

            impl<F: ErrorFormatter> error::Error for Error<F> 
            {
                #[allow(trivial_casts)]
                fn source(&self) -> Option<&(dyn error::Error + 'static)> {
                    self.inner.source.as_ref().map(|e| e.as_ref() as _)
                }
            }

            impl<F: ErrorFormatter> Display for Error<F> 
            {
                fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                    // Assuming `self.message` already has a trailing newline, from `try_help` or similar
                    ok!(write!(f, "{}", self.formatted()));
                    if let Some(backtrace) = self.inner.backtrace.as_ref() {
                        ok!(writeln!(f));
                        ok!(writeln!(f, "Backtrace:"));
                        ok!(writeln!(f, "{backtrace}"));
                    }
                    Ok(())
                }
            }

            #[derive(Clone, Debug)]
            pub enum Message 
            {
                Raw(String),
                Formatted(StyledStr),
            }

            impl Message 
            {
                fn format(&mut self, cmd: &Command, usage: Option<StyledStr>) {
                    match self {
                        Message::Raw(s) => {
                            let mut message = String::new();
                            std::mem::swap(s, &mut message);

                            let styled = format::format_error_message(
                                &message,
                                cmd.get_styles(),
                                Some(cmd),
                                usage.as_ref(),
                            );

                            *self = Self::Formatted(styled);
                        }
                        Message::Formatted(_) => {}
                    }
                }

                fn formatted(&self, styles: &Styles) -> Cow<'_, StyledStr> {
                    match self {
                        Message::Raw(s) => {
                            let styled = format::format_error_message(s, styles, None, None);

                            Cow::Owned(styled)
                        }
                        Message::Formatted(s) => Cow::Borrowed(s),
                    }
                }
            }

            impl From<String> for Message 
            {
                fn from(inner: String) -> Self {
                    Self::Raw(inner)
                }
            }

            impl From<StyledStr> for Message 
            {
                fn from(inner: StyledStr) -> Self {
                    Self::Formatted(inner)
                }
            }
        }

        pub mod parser
        {   
            //! [`Command`][crate::Command] line argument parser 
            use ::
            {
                *,
            };
            
            pub mod arg_matcher
            {
                use ::
                {
                    *,
                };
                //
                // Std
                use std::ffi::OsString;
                use std::mem;
                use std::ops::Deref;

                // Internal
                use crate::builder::{Arg, ArgPredicate, Command};
                use crate::parser::Identifier;
                use crate::parser::PendingArg;
                use crate::parser::{ArgMatches, MatchedArg, SubCommand, ValueSource};
                use crate::util::AnyValue;
                use crate::util::FlatMap;
                use crate::util::Id;
                use crate::INTERNAL_ERROR_MSG;

                #[derive(Debug, Default)]
                pub struct ArgMatcher {
                    matches: ArgMatches,
                    pending: Option<PendingArg>,
                }

                impl ArgMatcher {
                    pub fn new(_cmd: &Command) -> Self {
                        ArgMatcher {
                            matches: ArgMatches {
                                #[cfg(debug_assertions)]
                                valid_args: {
                                    let args = _cmd.get_arguments().map(|a| a.get_id().clone());
                                    let groups = _cmd.get_groups().map(|g| g.get_id().clone());
                                    args.chain(groups).collect()
                                },
                                #[cfg(debug_assertions)]
                                valid_subcommands: _cmd
                                    .get_subcommands()
                                    .map(|sc| sc.get_name_str().clone())
                                    .collect(),
                                ..Default::default()
                            },
                            pending: None,
                        }
                    }

                    pub fn into_inner(self) -> ArgMatches {
                        self.matches
                    }

                    pub fn propagate_globals(&mut self, global_arg_vec: &[Id]) {
                        debug!("ArgMatcher::get_global_values: global_arg_vec={global_arg_vec:?}");
                        let mut vals_map = FlatMap::new();
                        self.fill_in_global_values(global_arg_vec, &mut vals_map);
                    }

                    fn fill_in_global_values(
                        &mut self,
                        global_arg_vec: &[Id],
                        vals_map: &mut FlatMap<Id, MatchedArg>,
                    ) {
                        for global_arg in global_arg_vec {
                            if let Some(ma) = self.get(global_arg) {
                                // We have to check if the parent's global arg wasn't used but still exists
                                // such as from a default value.
                                //
                                // For example, `myprog subcommand --global-arg=value` where `--global-arg` defines
                                // a default value of `other` myprog would have an existing MatchedArg for
                                // `--global-arg` where the value is `other`
                                let to_update = if let Some(parent_ma) = vals_map.get(global_arg) {
                                    if parent_ma.source() > ma.source() {
                                        parent_ma
                                    } else {
                                        ma
                                    }
                                } else {
                                    ma
                                }
                                .clone();
                                vals_map.insert(global_arg.clone(), to_update);
                            }
                        }
                        if let Some(ref mut sc) = self.matches.subcommand {
                            let mut am = ArgMatcher {
                                matches: mem::take(&mut sc.matches),
                                pending: None,
                            };
                            am.fill_in_global_values(global_arg_vec, vals_map);
                            mem::swap(&mut am.matches, &mut sc.matches);
                        }

                        for (name, matched_arg) in vals_map.iter_mut() {
                            self.matches.args.insert(name.clone(), matched_arg.clone());
                        }
                    }

                    pub fn get(&self, arg: &Id) -> Option<&MatchedArg> {
                        self.matches.args.get(arg)
                    }

                    pub fn get_mut(&mut self, arg: &Id) -> Option<&mut MatchedArg> {
                        self.matches.args.get_mut(arg)
                    }

                    pub fn remove(&mut self, arg: &Id) -> bool {
                        self.matches.args.remove(arg).is_some()
                    }

                    pub fn contains(&self, arg: &Id) -> bool {
                        self.matches.args.contains_key(arg)
                    }

                    pub fn arg_ids(&self) -> std::slice::Iter<'_, Id> {
                        self.matches.args.keys()
                    }

                    pub fn args(&self) -> crate::util::flat_map::Iter<'_, Id, MatchedArg> {
                        self.matches.args.iter()
                    }

                    pub fn entry(&mut self, arg: Id) -> crate::util::Entry<'_, Id, MatchedArg> {
                        self.matches.args.entry(arg)
                    }

                    pub fn subcommand(&mut self, sc: SubCommand) {
                        self.matches.subcommand = Some(Box::new(sc));
                    }

                    pub fn subcommand_name(&self) -> Option<&str> {
                        self.matches.subcommand_name()
                    }

                    pub fn check_explicit(&self, arg: &Id, predicate: &ArgPredicate) -> bool {
                        self.get(arg)
                            .map(|a| a.check_explicit(predicate))
                            .unwrap_or_default()
                    }

                    pub fn start_custom_arg(&mut self, arg: &Arg, source: ValueSource) {
                        let id = arg.get_id().clone();
                        debug!("ArgMatcher::start_custom_arg: id={id:?}, source={source:?}");
                        let ma = self.entry(id).or_insert(MatchedArg::new_arg(arg));
                        debug_assert_eq!(ma.type_id(), Some(arg.get_value_parser().type_id()));
                        ma.set_source(source);
                        ma.new_val_group();
                    }

                    pub fn start_custom_group(&mut self, id: Id, source: ValueSource) {
                        debug!("ArgMatcher::start_custom_arg: id={id:?}, source={source:?}");
                        let ma = self.entry(id).or_insert(MatchedArg::new_group());
                        debug_assert_eq!(ma.type_id(), None);
                        ma.set_source(source);
                        ma.new_val_group();
                    }

                    pub fn start_occurrence_of_external(&mut self, cmd: &Command) {
                        let id = Id::from_static_ref(Id::EXTERNAL);
                        debug!("ArgMatcher::start_occurrence_of_external: id={id:?}");
                        let ma = self.entry(id).or_insert(MatchedArg::new_external(cmd));
                        debug_assert_eq!(
                            ma.type_id(),
                            Some(
                                cmd.get_external_subcommand_value_parser()
                                    .expect(INTERNAL_ERROR_MSG)
                                    .type_id()
                            )
                        );
                        ma.set_source(ValueSource::CommandLine);
                        ma.new_val_group();
                    }

                    pub fn add_val_to(&mut self, arg: &Id, val: AnyValue, raw_val: OsString) {
                        let ma = self.get_mut(arg).expect(INTERNAL_ERROR_MSG);
                        ma.append_val(val, raw_val);
                    }

                    pub fn add_index_to(&mut self, arg: &Id, idx: usize) {
                        let ma = self.get_mut(arg).expect(INTERNAL_ERROR_MSG);
                        ma.push_index(idx);
                    }

                    pub fn needs_more_vals(&self, o: &Arg) -> bool {
                        let num_pending = self
                            .pending
                            .as_ref()
                            .and_then(|p| (p.id == *o.get_id()).then_some(p.raw_vals.len()))
                            .unwrap_or(0);
                        debug!(
                            "ArgMatcher::needs_more_vals: o={}, pending={}",
                            o.get_id(),
                            num_pending
                        );
                        let expected = o.get_num_args().expect(INTERNAL_ERROR_MSG);
                        debug!("ArgMatcher::needs_more_vals: expected={expected}, actual={num_pending}");
                        expected.accepts_more(num_pending)
                    }

                    pub fn pending_arg_id(&self) -> Option<&Id> {
                        self.pending.as_ref().map(|p| &p.id)
                    }

                    pub fn pending_values_mut(
                        &mut self,
                        id: &Id,
                        ident: Option<Identifier>,
                        trailing_values: bool,
                    ) -> &mut Vec<OsString> {
                        let pending = self.pending.get_or_insert_with(|| PendingArg {
                            id: id.clone(),
                            ident,
                            raw_vals: Default::default(),
                            trailing_idx: None,
                        });
                        debug_assert_eq!(pending.id, *id, "{INTERNAL_ERROR_MSG}");
                        if ident.is_some() {
                            debug_assert_eq!(pending.ident, ident, "{INTERNAL_ERROR_MSG}");
                        }
                        if trailing_values {
                            pending.trailing_idx.get_or_insert(pending.raw_vals.len());
                        }
                        &mut pending.raw_vals
                    }

                    pub fn start_trailing(&mut self) {
                        if let Some(pending) = &mut self.pending {
                            // Allow asserting its started on subsequent calls
                            pending.trailing_idx.get_or_insert(pending.raw_vals.len());
                        }
                    }

                    pub fn take_pending(&mut self) -> Option<PendingArg> {
                        self.pending.take()
                    }
                }

                impl Deref for ArgMatcher {
                    type Target = ArgMatches;

                    fn deref(&self) -> &Self::Target {
                        &self.matches
                    }
                }
            }

            pub mod error
            {
                use ::
                {
                    *,
                };
                //
                use crate::util::AnyValueId;
                
                /// Violation of [`ArgMatches`][crate::ArgMatches] assumptions
                #[derive(Clone, Debug)]
                #[allow(missing_copy_implementations)] // We might add non-Copy types in the future
                #[non_exhaustive]
                pub enum MatchesError {
                    /// Failed to downcast `AnyValue` to the specified type
                    #[non_exhaustive]
                    Downcast {
                        /// Type for value stored in [`ArgMatches`][crate::ArgMatches]
                        actual: AnyValueId,
                        /// The target type to downcast to
                        expected: AnyValueId,
                    },
                    /// Argument not defined in [`Command`][crate::Command]
                    #[non_exhaustive]
                    UnknownArgument {
                        // Missing `id` but blocked on a public id type which will hopefully come with `unstable-v4`
                    },
                }

                impl MatchesError {
                    #[cfg_attr(debug_assertions, track_caller)]
                    pub fn unwrap<T>(id: &str, r: Result<T, MatchesError>) -> T {
                        let err = match r {
                            Ok(t) => {
                                return t;
                            }
                            Err(err) => err,
                        };
                        panic!("Mismatch between definition and access of `{id}`. {err}",)
                    }
                }

                impl std::error::Error for MatchesError {}

                impl std::fmt::Display for MatchesError {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        match self {
                            Self::Downcast { actual, expected } => {
                                writeln!(
                                    f,
                                    "Could not downcast to {expected:?}, need to downcast to {actual:?}"
                                )
                            }
                            Self::UnknownArgument {} => {
                                writeln!(f, "Unknown argument or group id.  Make sure you are using the argument id and not the short or long flags")
                            }
                        }
                    }
                }
            }

            pub mod matches
            {
                use ::
                {
                    *,
                };
                //
                pub mod arg_matches
                {
                    use ::
                    {
                        *,
                    };
                    //
                    // Std
                    use std::any::Any;
                    use std::ffi::{OsStr, OsString};
                    use std::fmt::Debug;
                    use std::iter::{Cloned, Flatten, Map};
                    use std::slice::Iter;

                    // Internal
                    #[cfg(debug_assertions)]
                    use crate::builder::Str;
                    use crate::parser::MatchedArg;
                    use crate::parser::MatchesError;
                    use crate::parser::ValueSource;
                    use crate::util::AnyValue;
                    use crate::util::AnyValueId;
                    use crate::util::FlatMap;
                    use crate::util::Id;
                    use crate::INTERNAL_ERROR_MSG;

                    /// Container for parse results.
                    #[derive(Debug, Clone, Default, PartialEq, Eq)]
                    pub struct ArgMatches {
                        #[cfg(debug_assertions)]
                        pub valid_args: Vec<Id>,
                        #[cfg(debug_assertions)]
                        pub valid_subcommands: Vec<Str>,
                        pub args: FlatMap<Id, MatchedArg>,
                        pub subcommand: Option<Box<SubCommand>>,
                    }
                    /// # Arguments
                    impl ArgMatches {
                        /// Gets the value of a specific option or positional argument.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn get_one<T: Any + Clone + Send + Sync + 'static>(&self, id: &str) -> Option<&T> {
                            MatchesError::unwrap(id, self.try_get_one(id))
                        }

                        /// Gets the value of a specific [`ArgAction::Count`][crate::ArgAction::Count] flag.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn get_count(&self, id: &str) -> u8 {
                            *self.get_one::<u8>(id).unwrap_or_else(|| {
                                panic!("arg `{id}`'s `ArgAction` should be `Count` which should provide a default")
                            })
                        }

                        /// Gets the value of a specific [`ArgAction::SetTrue`][crate::ArgAction::SetTrue] 
                        /// or [`ArgAction::SetFalse`][crate::ArgAction::SetFalse] flag.
                        pub fn get_flag(&self, id: &str) -> bool {
                            *self
                                .get_one::<bool>(id)
                                .unwrap_or_else(|| {
                                    panic!(
                                        "arg `{id}`'s `ArgAction` should be one of `SetTrue`, `SetFalse` which should provide a default"
                                    )
                                })
                        }

                        /// Iterate over values of a specific option or positional argument.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn get_many<T: Any + Clone + Send + Sync + 'static>(
                            &self,
                            id: &str,
                        ) -> Option<ValuesRef<'_, T>> {
                            MatchesError::unwrap(id, self.try_get_many(id))
                        }

                        /// Iterate over the values passed to each occurrence of an option.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn get_occurrences<T: Any + Clone + Send + Sync + 'static>(
                            &self,
                            id: &str,
                        ) -> Option<OccurrencesRef<'_, T>> {
                            MatchesError::unwrap(id, self.try_get_occurrences(id))
                        }

                        /// Iterate over the original argument values.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn get_raw(&self, id: &str) -> Option<RawValues<'_>> {
                            MatchesError::unwrap(id, self.try_get_raw(id))
                        }

                        /// Iterate over the original values for each occurrence of an option.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn get_raw_occurrences(&self, id: &str) -> Option<RawOccurrences<'_>> {
                            MatchesError::unwrap(id, self.try_get_raw_occurrences(id))
                        }

                        /// Returns the value of a specific option or positional argument.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn remove_one<T: Any + Clone + Send + Sync + 'static>(&mut self, id: &str) -> Option<T> {
                            MatchesError::unwrap(id, self.try_remove_one(id))
                        }

                        /// Return values of a specific option or positional argument.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn remove_many<T: Any + Clone + Send + Sync + 'static>(
                            &mut self,
                            id: &str,
                        ) -> Option<Values<T>> {
                            MatchesError::unwrap(id, self.try_remove_many(id))
                        }

                        /// Return values for each occurrence of an option.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn remove_occurrences<T: Any + Clone + Send + Sync + 'static>(
                            &mut self,
                            id: &str,
                        ) -> Option<Occurrences<T>> {
                            MatchesError::unwrap(id, self.try_remove_occurrences(id))
                        }

                        /// Check if values are present for the argument or group id.
                        pub fn contains_id(&self, id: &str) -> bool {
                            MatchesError::unwrap(id, self.try_contains_id(id))
                        }

                        /// Iterate over [`Arg`][crate::Arg] and [`ArgGroup`][crate::ArgGroup] [`Id`]s via [`ArgMatches::ids`].
                        pub fn ids(&self) -> IdsRef<'_> {
                            IdsRef {
                                iter: self.args.keys(),
                            }
                        }

                        /// Check if any [`Arg`][crate::Arg]s were present on the command line.
                        pub fn args_present(&self) -> bool {
                            self.args
                                .values()
                                .any(|v| v.source().map(|s| s.is_explicit()).unwrap_or(false))
                        }

                        /// Report where argument value came from.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn value_source(&self, id: &str) -> Option<ValueSource> {
                            let value = self.get_arg(id);

                            value.and_then(MatchedArg::source)
                        }

                        /// The first index of that an argument showed up.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn index_of(&self, id: &str) -> Option<usize> {
                            let arg = some!(self.get_arg(id));
                            let i = some!(arg.get_index(0));
                            Some(i)
                        }

                        /// All indices an argument appeared at when parsing.
                        #[cfg_attr(debug_assertions, track_caller)]
                        pub fn indices_of(&self, id: &str) -> Option<Indices<'_>> {
                            let arg = some!(self.get_arg(id));
                            let i = Indices {
                                iter: arg.indices(),
                                len: arg.num_vals(),
                            };
                            Some(i)
                        }
                    }
                    /// # Subcommands
                    impl ArgMatches {
                        /// The name and `ArgMatches` of the current [subcommand].
                        #[inline]
                        pub fn subcommand(&self) -> Option<(&str, &ArgMatches)> {
                            self.subcommand.as_ref().map(|sc| (&*sc.name, &sc.matches))
                        }

                        /// Return the name and `ArgMatches` of the current [subcommand].
                        pub fn remove_subcommand(&mut self) -> Option<(String, ArgMatches)> {
                            self.subcommand.take().map(|sc| (sc.name, sc.matches))
                        }

                        /// The `ArgMatches` for the current [subcommand].
                        pub fn subcommand_matches(&self, name: &str) -> Option<&ArgMatches> {
                            self.get_subcommand(name).map(|sc| &sc.matches)
                        }

                        /// The name of the current [subcommand].
                        #[inline]
                        pub fn subcommand_name(&self) -> Option<&str> {
                            self.subcommand.as_ref().map(|sc| &*sc.name)
                        }

                        /// Check if a subcommand can be queried
                        #[inline]
                        #[doc(hidden)]
                        pub fn is_valid_subcommand(&self, _name: &str) -> bool {
                            #[cfg(debug_assertions)]
                            {
                                _name.is_empty() || self.valid_subcommands.iter().any(|s| *s == _name)
                            }
                            #[cfg(not(debug_assertions))]
                            {
                                true
                            }
                        }
                    }
                    /// # Advanced
                    impl ArgMatches {
                        /// Non-panicking version of [`ArgMatches::get_one`]
                        pub fn try_get_one<T: Any + Clone + Send + Sync + 'static>(
                            &self,
                            id: &str,
                        ) -> Result<Option<&T>, MatchesError> {
                            let arg = ok!(self.try_get_arg_t::<T>(id));
                            let value = match arg.and_then(|a| a.first()) {
                                Some(value) => value,
                                None => {
                                    return Ok(None);
                                }
                            };
                            Ok(value
                                .downcast_ref::<T>()
                                .map(Some)
                                .expect(INTERNAL_ERROR_MSG)) // enforced by `try_get_arg_t`
                        }

                        /// Non-panicking version of [`ArgMatches::get_many`]
                        pub fn try_get_many<T: Any + Clone + Send + Sync + 'static>(
                            &self,
                            id: &str,
                        ) -> Result<Option<ValuesRef<'_, T>>, MatchesError> {
                            let arg = match ok!(self.try_get_arg_t::<T>(id)) {
                                Some(arg) => arg,
                                None => return Ok(None),
                            };
                            let len = arg.num_vals();
                            let values = arg.vals_flatten();
                            let values = ValuesRef {
                                // enforced by `try_get_arg_t`
                                iter: values.map(unwrap_downcast_ref),
                                len,
                            };
                            Ok(Some(values))
                        }

                        /// Non-panicking version of [`ArgMatches::get_occurrences`]
                        pub fn try_get_occurrences<T: Any + Clone + Send + Sync + 'static>(
                            &self,
                            id: &str,
                        ) -> Result<Option<OccurrencesRef<'_, T>>, MatchesError> {
                            let arg = match ok!(self.try_get_arg_t::<T>(id)) {
                                Some(arg) => arg,
                                None => return Ok(None),
                            };
                            let values = arg.vals();
                            Ok(Some(OccurrencesRef {
                                iter: values.map(|g| OccurrenceValuesRef {
                                    iter: g.iter().map(unwrap_downcast_ref),
                                }),
                            }))
                        }

                        /// Non-panicking version of [`ArgMatches::get_raw`]
                        pub fn try_get_raw(&self, id: &str) -> Result<Option<RawValues<'_>>, MatchesError> {
                            let arg = match ok!(self.try_get_arg(id)) {
                                Some(arg) => arg,
                                None => return Ok(None),
                            };
                            let len = arg.num_vals();
                            let values = arg.raw_vals_flatten();
                            let values = RawValues {
                                iter: values.map(OsString::as_os_str),
                                len,
                            };
                            Ok(Some(values))
                        }

                        /// Non-panicking version of [`ArgMatches::get_raw_occurrences`]
                        pub fn try_get_raw_occurrences(
                            &self,
                            id: &str,
                        ) -> Result<Option<RawOccurrences<'_>>, MatchesError> {
                            let arg = match ok!(self.try_get_arg(id)) {
                                Some(arg) => arg,
                                None => return Ok(None),
                            };
                            let values = arg.raw_vals();
                            let occurrences = RawOccurrences {
                                iter: values.map(|g| RawOccurrenceValues {
                                    iter: g.iter().map(OsString::as_os_str),
                                }),
                            };
                            Ok(Some(occurrences))
                        }

                        /// Non-panicking version of [`ArgMatches::remove_one`]
                        pub fn try_remove_one<T: Any + Clone + Send + Sync + 'static>(
                            &mut self,
                            id: &str,
                        ) -> Result<Option<T>, MatchesError> {
                            match ok!(self.try_remove_arg_t::<T>(id)) {
                                Some(values) => Ok(values
                                    .into_vals_flatten()
                                    // enforced by `try_get_arg_t`
                                    .map(unwrap_downcast_into)
                                    .next()),
                                None => Ok(None),
                            }
                        }

                        /// Non-panicking version of [`ArgMatches::remove_many`]
                        pub fn try_remove_many<T: Any + Clone + Send + Sync + 'static>(
                            &mut self,
                            id: &str,
                        ) -> Result<Option<Values<T>>, MatchesError> {
                            let arg = match ok!(self.try_remove_arg_t::<T>(id)) {
                                Some(arg) => arg,
                                None => return Ok(None),
                            };
                            let len = arg.num_vals();
                            let values = arg.into_vals_flatten();
                            let values = Values {
                                // enforced by `try_get_arg_t`
                                iter: values.map(unwrap_downcast_into),
                                len,
                            };
                            Ok(Some(values))
                        }

                        /// Non-panicking version of [`ArgMatches::remove_occurrences`]
                        pub fn try_remove_occurrences<T: Any + Clone + Send + Sync + 'static>(
                            &mut self,
                            id: &str,
                        ) -> Result<Option<Occurrences<T>>, MatchesError> {
                            let arg = match ok!(self.try_remove_arg_t::<T>(id)) {
                                Some(arg) => arg,
                                None => return Ok(None),
                            };
                            let values = arg.into_vals();
                            let occurrences = Occurrences {
                                iter: values.into_iter().map(|g| OccurrenceValues {
                                    iter: g.into_iter().map(unwrap_downcast_into),
                                }),
                            };
                            Ok(Some(occurrences))
                        }

                        /// Non-panicking version of [`ArgMatches::contains_id`]
                        pub fn try_contains_id(&self, id: &str) -> Result<bool, MatchesError> {
                            ok!(self.verify_arg(id));

                            let presence = self.args.contains_key(id);
                            Ok(presence)
                        }

                        /// Clears the values for the given `id`
                        ///
                        /// Alternative to [`try_remove_*`][ArgMatches::try_remove_one] when the type is not known.
                        ///
                        /// Returns `Err([``MatchesError``])` if the given `id` isn't valid for current `ArgMatches` instance.
                        ///
                        /// Returns `Ok(true)` if there were any matches with the given `id`, `Ok(false)` otherwise.
                        pub fn try_clear_id(&mut self, id: &str) -> Result<bool, MatchesError> {
                            ok!(self.verify_arg(id));
                            Ok(self.args.remove_entry(id).is_some())
                        }
                    }

                    // Private methods
                    impl ArgMatches {
                        #[inline]
                        fn try_get_arg(&self, arg: &str) -> Result<Option<&MatchedArg>, MatchesError> {
                            ok!(self.verify_arg(arg));
                            Ok(self.args.get(arg))
                        }

                        #[inline]
                        fn try_get_arg_t<T: Any + Send + Sync + 'static>(
                            &self,
                            arg: &str,
                        ) -> Result<Option<&MatchedArg>, MatchesError> {
                            let arg = match ok!(self.try_get_arg(arg)) {
                                Some(arg) => arg,
                                None => {
                                    return Ok(None);
                                }
                            };
                            ok!(self.verify_arg_t::<T>(arg));
                            Ok(Some(arg))
                        }

                        #[inline]
                        fn try_remove_arg_t<T: Any + Send + Sync + 'static>(
                            &mut self,
                            arg: &str,
                        ) -> Result<Option<MatchedArg>, MatchesError> {
                            ok!(self.verify_arg(arg));
                            let (id, matched) = match self.args.remove_entry(arg) {
                                Some((id, matched)) => (id, matched),
                                None => {
                                    return Ok(None);
                                }
                            };

                            let expected = AnyValueId::of::<T>();
                            let actual = matched.infer_type_id(expected);
                            if actual == expected {
                                Ok(Some(matched))
                            } else {
                                self.args.insert(id, matched);
                                Err(MatchesError::Downcast { actual, expected })
                            }
                        }

                        fn verify_arg_t<T: Any + Send + Sync + 'static>(
                            &self,
                            arg: &MatchedArg,
                        ) -> Result<(), MatchesError> {
                            let expected = AnyValueId::of::<T>();
                            let actual = arg.infer_type_id(expected);
                            if expected == actual {
                                Ok(())
                            } else {
                                Err(MatchesError::Downcast { actual, expected })
                            }
                        }

                        #[inline]
                        fn verify_arg(&self, _arg: &str) -> Result<(), MatchesError> {
                            #[cfg(debug_assertions)]
                            {
                                if _arg == Id::EXTERNAL || self.valid_args.iter().any(|s| *s == _arg) {
                                } else {
                                    debug!(
                                        "`{:?}` is not an id of an argument or a group.\n\
                                        Make sure you're using the name of the argument itself \
                                        and not the name of short or long flags.",
                                        _arg
                                    );
                                    return Err(MatchesError::UnknownArgument {});
                                }
                            }
                            Ok(())
                        }

                        #[inline]
                        #[cfg_attr(debug_assertions, track_caller)]
                        fn get_arg<'s>(&'s self, arg: &str) -> Option<&'s MatchedArg> {
                            #[cfg(debug_assertions)]
                            {
                                if arg == Id::EXTERNAL || self.valid_args.iter().any(|s| *s == arg) {
                                } else {
                                    panic!(
                                        "`{arg:?}` is not an id of an argument or a group.\n\
                                        Make sure you're using the name of the argument itself \
                                        and not the name of short or long flags."
                                    );
                                }
                            }

                            self.args.get(arg)
                        }

                        #[inline]
                        #[cfg_attr(debug_assertions, track_caller)]
                        fn get_subcommand(&self, name: &str) -> Option<&SubCommand> {
                            #[cfg(debug_assertions)]
                            {
                                if name.is_empty() || self.valid_subcommands.iter().any(|s| *s == name) {
                                } else {
                                    panic!("`{name}` is not a name of a subcommand.");
                                }
                            }

                            if let Some(ref sc) = self.subcommand {
                                if sc.name == name {
                                    return Some(sc);
                                }
                            }

                            None
                        }
                    }

                    #[derive(Debug, Clone, PartialEq, Eq)]
                    pub struct SubCommand {
                        pub name: String,
                        pub matches: ArgMatches,
                    }
                    /// Iterate over [`Arg`][crate::Arg] and [`ArgGroup`][crate::ArgGroup] [`Id`]s via [`ArgMatches::ids`].
                    #[derive(Clone, Debug)]
                    pub struct IdsRef<'a> {
                        iter: Iter<'a, Id>,
                    }

                    impl<'a> Iterator for IdsRef<'a> {
                        type Item = &'a Id;

                        fn next(&mut self) -> Option<&'a Id> {
                            self.iter.next()
                        }
                        fn size_hint(&self) -> (usize, Option<usize>) {
                            self.iter.size_hint()
                        }
                    }

                    impl<'a> DoubleEndedIterator for IdsRef<'a> {
                        fn next_back(&mut self) -> Option<&'a Id> {
                            self.iter.next_back()
                        }
                    }

                    impl ExactSizeIterator for IdsRef<'_> {}
                    /// Iterate over multiple values for an argument via [`ArgMatches::remove_many`].
                    #[derive(Clone, Debug)]
                    pub struct Values<T> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<Flatten<std::vec::IntoIter<Vec<AnyValue>>>, fn(AnyValue) -> T>,
                        len: usize,
                    }

                    impl<T> Iterator for Values<T> {
                        type Item = T;

                        fn next(&mut self) -> Option<Self::Item> {
                            if let Some(next) = self.iter.next() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                        fn size_hint(&self) -> (usize, Option<usize>) {
                            (self.len, Some(self.len))
                        }
                    }

                    impl<T> DoubleEndedIterator for Values<T> {
                        fn next_back(&mut self) -> Option<Self::Item> {
                            if let Some(next) = self.iter.next_back() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                    }

                    impl<T> ExactSizeIterator for Values<T> {}
                    /// Creates an empty iterator.
                    impl<T> Default for Values<T> {
                        fn default() -> Self {
                            let empty: Vec<Vec<AnyValue>> = Default::default();
                            Values {
                                iter: empty.into_iter().flatten().map(|_| unreachable!()),
                                len: 0,
                            }
                        }
                    }
                    /// Iterate over multiple values for an argument via [`ArgMatches::get_many`].
                    #[derive(Clone, Debug)]
                    pub struct ValuesRef<'a, T> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<Flatten<Iter<'a, Vec<AnyValue>>>, fn(&AnyValue) -> &T>,
                        len: usize,
                    }

                    impl<'a, T: 'a> Iterator for ValuesRef<'a, T> {
                        type Item = &'a T;

                        fn next(&mut self) -> Option<Self::Item> {
                            if let Some(next) = self.iter.next() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                        fn size_hint(&self) -> (usize, Option<usize>) {
                            (self.len, Some(self.len))
                        }
                    }

                    impl<'a, T: 'a> DoubleEndedIterator for ValuesRef<'a, T> {
                        fn next_back(&mut self) -> Option<Self::Item> {
                            if let Some(next) = self.iter.next_back() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                    }

                    impl<'a, T: 'a> ExactSizeIterator for ValuesRef<'a, T> {}
                    /// Creates an empty iterator.
                    impl<'a, T: 'a> Default for ValuesRef<'a, T> {
                        fn default() -> Self {
                            static EMPTY: [Vec<AnyValue>; 0] = [];
                            ValuesRef {
                                iter: EMPTY[..].iter().flatten().map(|_| unreachable!()),
                                len: 0,
                            }
                        }
                    }
                    /// Iterate over raw argument values via [`ArgMatches::get_raw`].
                    #[derive(Clone, Debug)]
                    pub struct RawValues<'a> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<Flatten<Iter<'a, Vec<OsString>>>, fn(&OsString) -> &OsStr>,
                        len: usize,
                    }

                    impl<'a> Iterator for RawValues<'a> {
                        type Item = &'a OsStr;

                        fn next(&mut self) -> Option<&'a OsStr> {
                            if let Some(next) = self.iter.next() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                        fn size_hint(&self) -> (usize, Option<usize>) {
                            (self.len, Some(self.len))
                        }
                    }

                    impl<'a> DoubleEndedIterator for RawValues<'a> {
                        fn next_back(&mut self) -> Option<&'a OsStr> {
                            if let Some(next) = self.iter.next_back() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                    }

                    impl ExactSizeIterator for RawValues<'_> {}
                    /// Creates an empty iterator.
                    impl Default for RawValues<'_> {
                        fn default() -> Self {
                            static EMPTY: [Vec<OsString>; 0] = [];
                            RawValues {
                                iter: EMPTY[..].iter().flatten().map(|_| unreachable!()),
                                len: 0,
                            }
                        }
                    }
                    
                    #[derive(Clone, Debug)]
                    #[deprecated(since = "4.1.0", note = "Use Occurrences instead")]
                    pub struct GroupedValues<'a> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<Iter<'a, Vec<AnyValue>>, fn(&Vec<AnyValue>) -> Vec<&str>>,
                        len: usize,
                    }

                    #[allow(deprecated)]
                    impl<'a> Iterator for GroupedValues<'a> {
                        type Item = Vec<&'a str>;

                        fn next(&mut self) -> Option<Self::Item> {
                            if let Some(next) = self.iter.next() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                        fn size_hint(&self) -> (usize, Option<usize>) {
                            (self.len, Some(self.len))
                        }
                    }

                    #[allow(deprecated)]
                    impl DoubleEndedIterator for GroupedValues<'_> {
                        fn next_back(&mut self) -> Option<Self::Item> {
                            if let Some(next) = self.iter.next_back() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                    }

                    #[allow(deprecated)]
                    impl ExactSizeIterator for GroupedValues<'_> {}
                    /// Creates an empty iterator. Used for `unwrap_or_default()`.
                    #[allow(deprecated)]
                    impl Default for GroupedValues<'_> {
                        fn default() -> Self {
                            static EMPTY: [Vec<AnyValue>; 0] = [];
                            GroupedValues {
                                iter: EMPTY[..].iter().map(|_| unreachable!()),
                                len: 0,
                            }
                        }
                    }

                    #[derive(Clone, Debug)]
                    pub struct Occurrences<T> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<std::vec::IntoIter<Vec<AnyValue>>, fn(Vec<AnyValue>) -> OccurrenceValues<T>>,
                    }

                    impl<T> Iterator for Occurrences<T> {
                        type Item = OccurrenceValues<T>;

                        fn next(&mut self) -> Option<Self::Item> {
                            self.iter.next()
                        }

                        fn size_hint(&self) -> (usize, Option<usize>) {
                            self.iter.size_hint()
                        }
                    }

                    impl<T> DoubleEndedIterator for Occurrences<T> {
                        fn next_back(&mut self) -> Option<Self::Item> {
                            self.iter.next_back()
                        }
                    }

                    impl<T> ExactSizeIterator for Occurrences<T> {}

                    impl<T> Default for Occurrences<T> {
                        fn default() -> Self {
                            let empty: Vec<Vec<AnyValue>> = Default::default();
                            Occurrences {
                                iter: empty.into_iter().map(|_| unreachable!()),
                            }
                        }
                    }

                    #[derive(Clone, Debug)]
                    pub struct OccurrenceValues<T> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<std::vec::IntoIter<AnyValue>, fn(AnyValue) -> T>,
                    }

                    impl<T> Iterator for OccurrenceValues<T> {
                        type Item = T;

                        fn next(&mut self) -> Option<Self::Item> {
                            self.iter.next()
                        }

                        fn size_hint(&self) -> (usize, Option<usize>) {
                            self.iter.size_hint()
                        }
                    }

                    impl<T> DoubleEndedIterator for OccurrenceValues<T> {
                        fn next_back(&mut self) -> Option<Self::Item> {
                            self.iter.next_back()
                        }
                    }

                    impl<T> ExactSizeIterator for OccurrenceValues<T> {}

                    #[derive(Clone, Debug)]
                    pub struct OccurrencesRef<'a, T> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<Iter<'a, Vec<AnyValue>>, fn(&Vec<AnyValue>) -> OccurrenceValuesRef<'_, T>>,
                    }

                    impl<'a, T> Iterator for OccurrencesRef<'a, T>
                    where
                        Self: 'a,
                    {
                        type Item = OccurrenceValuesRef<'a, T>;

                        fn next(&mut self) -> Option<Self::Item> {
                            self.iter.next()
                        }

                        fn size_hint(&self) -> (usize, Option<usize>) {
                            self.iter.size_hint()
                        }
                    }

                    impl<'a, T> DoubleEndedIterator for OccurrencesRef<'a, T>
                    where
                        Self: 'a,
                    {
                        fn next_back(&mut self) -> Option<Self::Item> {
                            self.iter.next_back()
                        }
                    }

                    impl<'a, T> ExactSizeIterator for OccurrencesRef<'a, T> where Self: 'a {}
                    impl<T> Default for OccurrencesRef<'_, T> {
                        fn default() -> Self {
                            static EMPTY: [Vec<AnyValue>; 0] = [];
                            OccurrencesRef {
                                iter: EMPTY[..].iter().map(|_| unreachable!()),
                            }
                        }
                    }

                    #[derive(Clone, Debug)]
                    pub struct OccurrenceValuesRef<'a, T> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<Iter<'a, AnyValue>, fn(&AnyValue) -> &T>,
                    }

                    impl<'a, T> Iterator for OccurrenceValuesRef<'a, T>
                    where
                        Self: 'a,
                    {
                        type Item = &'a T;

                        fn next(&mut self) -> Option<Self::Item> {
                            self.iter.next()
                        }

                        fn size_hint(&self) -> (usize, Option<usize>) {
                            self.iter.size_hint()
                        }
                    }

                    impl<'a, T> DoubleEndedIterator for OccurrenceValuesRef<'a, T>
                    where
                        Self: 'a,
                    {
                        fn next_back(&mut self) -> Option<Self::Item> {
                            self.iter.next_back()
                        }
                    }

                    impl<'a, T> ExactSizeIterator for OccurrenceValuesRef<'a, T> where Self: 'a {}

                    #[derive(Clone, Debug)]
                    pub struct RawOccurrences<'a> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<Iter<'a, Vec<OsString>>, fn(&Vec<OsString>) -> RawOccurrenceValues<'_>>,
                    }

                    impl<'a> Iterator for RawOccurrences<'a> {
                        type Item = RawOccurrenceValues<'a>;

                        fn next(&mut self) -> Option<Self::Item> {
                            self.iter.next()
                        }

                        fn size_hint(&self) -> (usize, Option<usize>) {
                            self.iter.size_hint()
                        }
                    }

                    impl DoubleEndedIterator for RawOccurrences<'_> {
                        fn next_back(&mut self) -> Option<Self::Item> {
                            self.iter.next_back()
                        }
                    }

                    impl ExactSizeIterator for RawOccurrences<'_> {}

                    impl Default for RawOccurrences<'_> {
                        fn default() -> Self {
                            static EMPTY: [Vec<OsString>; 0] = [];
                            RawOccurrences {
                                iter: EMPTY[..].iter().map(|_| unreachable!()),
                            }
                        }
                    }

                    #[derive(Clone, Debug)]
                    pub struct RawOccurrenceValues<'a> {
                        #[allow(clippy::type_complexity)]
                        iter: Map<Iter<'a, OsString>, fn(&OsString) -> &OsStr>,
                    }

                    impl<'a> Iterator for RawOccurrenceValues<'a>
                    where
                        Self: 'a,
                    {
                        type Item = &'a OsStr;

                        fn next(&mut self) -> Option<Self::Item> {
                            self.iter.next()
                        }

                        fn size_hint(&self) -> (usize, Option<usize>) {
                            self.iter.size_hint()
                        }
                    }

                    impl<'a> DoubleEndedIterator for RawOccurrenceValues<'a>
                    where
                        Self: 'a,
                    {
                        fn next_back(&mut self) -> Option<Self::Item> {
                            self.iter.next_back()
                        }
                    }

                    impl ExactSizeIterator for RawOccurrenceValues<'_> {}
                    /// Iterate over indices for where an argument appeared when parsing, via [`ArgMatches::indices_of`]
                    #[derive(Clone, Debug)]
                    pub struct Indices<'a> {
                        iter: Cloned<Iter<'a, usize>>,
                        len: usize,
                    }

                    impl Iterator for Indices<'_> {
                        type Item = usize;

                        fn next(&mut self) -> Option<usize> {
                            if let Some(next) = self.iter.next() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                        fn size_hint(&self) -> (usize, Option<usize>) {
                            (self.len, Some(self.len))
                        }
                    }

                    impl DoubleEndedIterator for Indices<'_> {
                        fn next_back(&mut self) -> Option<usize> {
                            if let Some(next) = self.iter.next_back() {
                                self.len -= 1;
                                Some(next)
                            } else {
                                None
                            }
                        }
                    }

                    impl ExactSizeIterator for Indices<'_> {}
                    /// Creates an empty iterator.
                    impl Default for Indices<'_> {
                        fn default() -> Self {
                            static EMPTY: [usize; 0] = [];
                            // This is never called because the iterator is empty:
                            Indices {
                                iter: EMPTY[..].iter().cloned(),
                                len: 0,
                            }
                        }
                    }

                    #[track_caller]
                    fn unwrap_downcast_ref<T: Any + Clone + Send + Sync + 'static>(value: &AnyValue) -> &T {
                        value.downcast_ref().expect(INTERNAL_ERROR_MSG)
                    }

                    #[track_caller]
                    fn unwrap_downcast_into<T: Any + Clone + Send + Sync + 'static>(value: AnyValue) -> T {
                        value.downcast_into().expect(INTERNAL_ERROR_MSG)
                    }
                }

                pub mod matched_arg
                {
                    use ::
                    {
                        *,
                    };
                    //
                    // Std
                    use std::{
                        ffi::{OsStr, OsString},
                        iter::{Cloned, Flatten},
                        slice::Iter,
                    };

                    use crate::builder::ArgPredicate;
                    use crate::parser::ValueSource;
                    use crate::util::eq_ignore_case;
                    use crate::util::AnyValue;
                    use crate::util::AnyValueId;
                    use crate::INTERNAL_ERROR_MSG;

                    #[derive(Debug, Clone)]
                    pub struct MatchedArg {
                        source: Option<ValueSource>,
                        indices: Vec<usize>,
                        type_id: Option<AnyValueId>,
                        vals: Vec<Vec<AnyValue>>,
                        raw_vals: Vec<Vec<OsString>>,
                        ignore_case: bool,
                    }

                    impl MatchedArg {
                        pub fn new_arg(arg: &crate::Arg) -> Self {
                            let ignore_case = arg.is_ignore_case_set();
                            Self {
                                source: None,
                                indices: Vec::new(),
                                type_id: Some(arg.get_value_parser().type_id()),
                                vals: Vec::new(),
                                raw_vals: Vec::new(),
                                ignore_case,
                            }
                        }

                        pub fn new_group() -> Self {
                            let ignore_case = false;
                            Self {
                                source: None,
                                indices: Vec::new(),
                                type_id: None,
                                vals: Vec::new(),
                                raw_vals: Vec::new(),
                                ignore_case,
                            }
                        }

                        pub fn new_external(cmd: &crate::Command) -> Self {
                            let ignore_case = false;
                            Self {
                                source: None,
                                indices: Vec::new(),
                                type_id: Some(
                                    cmd.get_external_subcommand_value_parser()
                                        .expect(INTERNAL_ERROR_MSG)
                                        .type_id(),
                                ),
                                vals: Vec::new(),
                                raw_vals: Vec::new(),
                                ignore_case,
                            }
                        }

                        pub fn indices(&self) -> Cloned<Iter<'_, usize>> {
                            self.indices.iter().cloned()
                        }

                        pub fn get_index(&self, index: usize) -> Option<usize> {
                            self.indices.get(index).cloned()
                        }

                        pub fn push_index(&mut self, index: usize) {
                            self.indices.push(index);
                        }

                        pub fn vals(&self) -> Iter<'_, Vec<AnyValue>> {
                            self.vals.iter()
                        }

                        pub fn into_vals(self) -> Vec<Vec<AnyValue>> {
                            self.vals
                        }

                        pub fn vals_flatten(&self) -> Flatten<Iter<'_, Vec<AnyValue>>> {
                            self.vals.iter().flatten()
                        }

                        pub fn into_vals_flatten(self) -> Flatten<std::vec::IntoIter<Vec<AnyValue>>> {
                            self.vals.into_iter().flatten()
                        }

                        pub fn raw_vals(&self) -> Iter<'_, Vec<OsString>> {
                            self.raw_vals.iter()
                        }

                        pub fn raw_vals_flatten(&self) -> Flatten<Iter<'_, Vec<OsString>>> {
                            self.raw_vals.iter().flatten()
                        }

                        pub fn first(&self) -> Option<&AnyValue> {
                            self.vals_flatten().next()
                        }

                        #[cfg(test)]
                        pub fn first_raw(&self) -> Option<&OsString> {
                            self.raw_vals_flatten().next()
                        }

                        pub fn new_val_group(&mut self) {
                            self.vals.push(vec![]);
                            self.raw_vals.push(vec![]);
                        }

                        pub fn append_val(&mut self, val: AnyValue, raw_val: OsString) {
                            // We assume there is always a group created before.
                            self.vals.last_mut().expect(INTERNAL_ERROR_MSG).push(val);
                            self.raw_vals
                                .last_mut()
                                .expect(INTERNAL_ERROR_MSG)
                                .push(raw_val);
                        }

                        pub fn num_vals(&self) -> usize {
                            self.vals.iter().map(|v| v.len()).sum()
                        }

                        // Will be used later
                        
                        pub fn num_vals_last_group(&self) -> usize {
                            self.vals.last().map(|x| x.len()).unwrap_or(0)
                        }

                        pub fn check_explicit(&self, predicate: &ArgPredicate) -> bool {
                            if self.source.map(|s| !s.is_explicit()).unwrap_or(false) {
                                return false;
                            }

                            match predicate {
                                ArgPredicate::Equals(val) => self.raw_vals_flatten().any(|v| {
                                    if self.ignore_case {
                                        // If `v` isn't utf8, it can't match `val`, so `OsStr::to_str` should be fine
                                        eq_ignore_case(&v.to_string_lossy(), &val.to_string_lossy())
                                    } else {
                                        OsString::as_os_str(v) == OsStr::new(val)
                                    }
                                }),
                                ArgPredicate::IsPresent => true,
                            }
                        }

                        pub fn source(&self) -> Option<ValueSource> {
                            self.source
                        }

                        pub fn set_source(&mut self, source: ValueSource) {
                            if let Some(existing) = self.source {
                                self.source = Some(existing.max(source));
                            } else {
                                self.source = Some(source);
                            }
                        }

                        pub fn type_id(&self) -> Option<AnyValueId> {
                            self.type_id
                        }

                        pub fn infer_type_id(&self, expected: AnyValueId) -> AnyValueId {
                            self.type_id()
                                .or_else(|| {
                                    self.vals_flatten()
                                        .map(|v| v.type_id())
                                        .find(|actual| *actual != expected)
                                })
                                .unwrap_or(expected)
                        }
                    }

                    impl PartialEq for MatchedArg {
                        fn eq(&self, other: &MatchedArg) -> bool {
                            let MatchedArg {
                                source: self_source,
                                indices: self_indices,
                                type_id: self_type_id,
                                vals: _,
                                raw_vals: self_raw_vals,
                                ignore_case: self_ignore_case,
                            } = self;
                            let MatchedArg {
                                source: other_source,
                                indices: other_indices,
                                type_id: other_type_id,
                                vals: _,
                                raw_vals: other_raw_vals,
                                ignore_case: other_ignore_case,
                            } = other;
                            self_source == other_source
                                && self_indices == other_indices
                                && self_type_id == other_type_id
                                && self_raw_vals == other_raw_vals
                                && self_ignore_case == other_ignore_case
                        }
                    }

                    impl Eq for MatchedArg {}
                }

                pub mod value_source
                {
                    use ::
                    {
                        *,
                    };
                    //
                    /// Origin of the argument's value
                    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
                    #[non_exhaustive]
                    pub enum ValueSource {
                        /// Value came [`Arg::default_value`][crate::Arg::default_value]
                        DefaultValue,
                        /// Value came [`Arg::env`][crate::Arg::env]
                        EnvVariable,
                        /// Value was passed in on the command-line
                        CommandLine,
                    }

                    impl ValueSource {
                        pub fn is_explicit(self) -> bool {
                            self != Self::DefaultValue
                        }
                    }
                }
                
                pub use arg_matches::IdsRef;
                pub use arg_matches::RawValues;
                pub use arg_matches::Values;
                pub use arg_matches::ValuesRef;
                pub use arg_matches::{ArgMatches, Indices};
                pub use value_source::ValueSource;

                pub use arg_matches::SubCommand;
                pub use matched_arg::MatchedArg;
            }

            pub mod parser
            {
                use ::
                {
                    *,
                };
                //
                // Std
                use std::{
                    cell::Cell,
                    ffi::{OsStr, OsString},
                };

                use clap_lex::OsStrExt as _;

                // Internal
                use crate::builder::{Arg, Command};
                use crate::error::Error as ClapError;
                use crate::error::Result as ClapResult;
                use crate::mkeymap::KeyType;
                use crate::output::Usage;
                use crate::parser::features::suggestions;
                use crate::parser::{ArgMatcher, SubCommand};
                use crate::parser::{Validator, ValueSource};
                use crate::util::AnyValue;
                use crate::util::Id;
                use crate::ArgAction;
                use crate::INTERNAL_ERROR_MSG;

                pub struct Parser<'cmd> {
                    cmd: &'cmd mut Command,
                    cur_idx: Cell<usize>,
                    /// Index of the previous flag subcommand in a group of flags.
                    flag_subcmd_at: Option<usize>,
                    /// Counter indicating the number of items to skip
                    /// when revisiting the group of flags which includes the flag subcommand.
                    flag_subcmd_skip: usize,
                }

                // Initializing Methods
                impl<'cmd> Parser<'cmd> {
                    pub fn new(cmd: &'cmd mut Command) -> Self {
                        Parser {
                            cmd,
                            cur_idx: Cell::new(0),
                            flag_subcmd_at: None,
                            flag_subcmd_skip: 0,
                        }
                    }
                }

                // Parsing Methods
                impl<'cmd> Parser<'cmd> {
                    // The actual parsing function
                    #[allow(clippy::cognitive_complexity)]
                    pub fn get_matches_with(
                        &mut self,
                        matcher: &mut ArgMatcher,
                        raw_args: &mut clap_lex::RawArgs,
                        args_cursor: clap_lex::ArgCursor,
                    ) -> ClapResult<()> {
                        debug!("Parser::get_matches_with");

                        ok!(self.parse(matcher, raw_args, args_cursor).map_err(|err| {
                            if self.cmd.is_ignore_errors_set() {
                                #[cfg(feature = "env")]
                                let _ = self.add_env(matcher);
                                let _ = self.add_defaults(matcher);
                            }
                            err
                        }));
                        ok!(self.resolve_pending(matcher));

                        #[cfg(feature = "env")]
                        ok!(self.add_env(matcher));
                        ok!(self.add_defaults(matcher));

                        Validator::new(self.cmd).validate(matcher)
                    }

                    // The actual parsing function
                    #[allow(clippy::cognitive_complexity)]
                    pub fn parse(
                        &mut self,
                        matcher: &mut ArgMatcher,
                        raw_args: &mut clap_lex::RawArgs,
                        mut args_cursor: clap_lex::ArgCursor,
                    ) -> ClapResult<()> {
                        debug!("Parser::parse");
                        // Verify all positional assertions pass

                        let mut subcmd_name: Option<String> = None;
                        let mut keep_state = false;
                        let mut parse_state = ParseState::ValuesDone;
                        let mut pos_counter = 1;

                        // Already met any valid arg(then we shouldn't expect subcommands after it).
                        let mut valid_arg_found = false;
                        // If the user already passed '--'. Meaning only positional args follow.
                        let mut trailing_values = false;

                        // Count of positional args
                        let positional_count = self
                            .cmd
                            .get_keymap()
                            .keys()
                            .filter(|x| x.is_position())
                            .count();
                        // If any arg sets .last(true)
                        let contains_last = self.cmd.get_arguments().any(|x| x.is_last_set());

                        while let Some(arg_os) = raw_args.next(&mut args_cursor) {
                            debug!(
                                "Parser::get_matches_with: Begin parsing '{:?}'",
                                arg_os.to_value_os(),
                            );

                            // Has the user already passed '--'? Meaning only positional args follow
                            if !trailing_values {
                                if self.cmd.is_subcommand_precedence_over_arg_set()
                                    || !matches!(parse_state, ParseState::Opt(_) | ParseState::Pos(_))
                                {
                                    // Does the arg match a subcommand name, or any of its aliases (if defined)
                                    let sc_name = self.possible_subcommand(arg_os.to_value(), valid_arg_found);
                                    debug!("Parser::get_matches_with: sc={sc_name:?}");
                                    if let Some(sc_name) = sc_name {
                                        if sc_name == "help" && !self.cmd.is_disable_help_subcommand_set() {
                                            ok!(self.parse_help_subcommand(raw_args.remaining(&mut args_cursor)));
                                            unreachable!("`parse_help_subcommand` always errors");
                                        } else {
                                            subcmd_name = Some(sc_name.to_owned());
                                        }
                                        break;
                                    }
                                }

                                if arg_os.is_escape() {
                                    if matches!(&parse_state, ParseState::Opt(opt) | ParseState::Pos(opt) if
                                        self.cmd[opt].is_allow_hyphen_values_set())
                                    {
                                        // ParseResult::MaybeHyphenValue, do nothing
                                    } else {
                                        debug!("Parser::get_matches_with: setting TrailingVals=true");
                                        trailing_values = true;
                                        matcher.start_trailing();
                                        continue;
                                    }
                                } else if let Some((long_arg, long_value)) = arg_os.to_long() {
                                    let parse_result = ok!(self.parse_long_arg(
                                        matcher,
                                        long_arg,
                                        long_value,
                                        &parse_state,
                                        pos_counter,
                                        &mut valid_arg_found,
                                    ));
                                    debug!("Parser::get_matches_with: After parse_long_arg {parse_result:?}");
                                    match parse_result {
                                        ParseResult::NoArg => {
                                            unreachable!("`to_long` always has the flag specified")
                                        }
                                        ParseResult::ValuesDone => {
                                            parse_state = ParseState::ValuesDone;
                                            continue;
                                        }
                                        ParseResult::Opt(id) => {
                                            parse_state = ParseState::Opt(id);
                                            continue;
                                        }
                                        ParseResult::FlagSubCommand(name) => {
                                            debug!(
                                                "Parser::get_matches_with: FlagSubCommand found in long arg {:?}",
                                                &name
                                            );
                                            subcmd_name = Some(name);
                                            break;
                                        }
                                        ParseResult::EqualsNotProvided { arg } => {
                                            let _ = self.resolve_pending(matcher);
                                            return Err(ClapError::no_equals(
                                                self.cmd,
                                                arg,
                                                Usage::new(self.cmd).create_usage_with_title(&[]),
                                            ));
                                        }
                                        ParseResult::NoMatchingArg { arg } => {
                                            let _ = self.resolve_pending(matcher);
                                            let remaining_args: Vec<_> =
                                                raw_args.remaining(&mut args_cursor).collect();
                                            return Err(self.did_you_mean_error(
                                                &arg,
                                                matcher,
                                                &remaining_args,
                                                trailing_values,
                                            ));
                                        }
                                        ParseResult::UnneededAttachedValue { rest, used, arg } => {
                                            let _ = self.resolve_pending(matcher);
                                            return Err(ClapError::too_many_values(
                                                self.cmd,
                                                rest,
                                                arg,
                                                Usage::new(self.cmd).create_usage_with_title(&used),
                                            ));
                                        }
                                        ParseResult::MaybeHyphenValue => {
                                            // Maybe a hyphen value, do nothing.
                                        }
                                        ParseResult::AttachedValueNotConsumed => {
                                            unreachable!()
                                        }
                                    }
                                } else if let Some(short_arg) = arg_os.to_short() {
                                    // Arg looks like a short flag, and not a possible number

                                    // Try to parse short args like normal, if allow_hyphen_values or
                                    // AllowNegativeNumbers is set, parse_short_arg will *not* throw
                                    // an error, and instead return Ok(None)
                                    let parse_result = ok!(self.parse_short_arg(
                                        matcher,
                                        short_arg,
                                        &parse_state,
                                        pos_counter,
                                        &mut valid_arg_found,
                                    ));
                                    // If it's None, we then check if one of those two AppSettings was set
                                    debug!("Parser::get_matches_with: After parse_short_arg {parse_result:?}");
                                    match parse_result {
                                        ParseResult::NoArg => {
                                            // Is a single dash `-`, try positional.
                                        }
                                        ParseResult::ValuesDone => {
                                            parse_state = ParseState::ValuesDone;
                                            continue;
                                        }
                                        ParseResult::Opt(id) => {
                                            parse_state = ParseState::Opt(id);
                                            continue;
                                        }
                                        ParseResult::FlagSubCommand(name) => {
                                            // If there are more short flags to be processed, we should keep the state, and later
                                            // revisit the current group of short flags skipping the subcommand.
                                            keep_state = self
                                                .flag_subcmd_at
                                                .map(|at| {
                                                    raw_args
                                                        .seek(&mut args_cursor, clap_lex::SeekFrom::Current(-1));
                                                    // Since we are now saving the current state, the number of flags to skip during state recovery should
                                                    // be the current index (`cur_idx`) minus ONE UNIT TO THE LEFT of the starting position.
                                                    self.flag_subcmd_skip = self.cur_idx.get() - at + 1;
                                                })
                                                .is_some();

                                            debug!(
                                                "Parser::get_matches_with:FlagSubCommandShort: subcmd_name={}, keep_state={}, flag_subcmd_skip={}",
                                                name,
                                                keep_state,
                                                self.flag_subcmd_skip
                                            );

                                            subcmd_name = Some(name);
                                            break;
                                        }
                                        ParseResult::EqualsNotProvided { arg } => {
                                            let _ = self.resolve_pending(matcher);
                                            return Err(ClapError::no_equals(
                                                self.cmd,
                                                arg,
                                                Usage::new(self.cmd).create_usage_with_title(&[]),
                                            ));
                                        }
                                        ParseResult::NoMatchingArg { arg } => {
                                            let _ = self.resolve_pending(matcher);
                                            // We already know it looks like a flag
                                            let suggested_trailing_arg =
                                                !trailing_values && self.cmd.has_positionals();
                                            return Err(ClapError::unknown_argument(
                                                self.cmd,
                                                arg,
                                                None,
                                                suggested_trailing_arg,
                                                Usage::new(self.cmd).create_usage_with_title(&[]),
                                            ));
                                        }
                                        ParseResult::MaybeHyphenValue => {
                                            // Maybe a hyphen value, do nothing.
                                        }
                                        ParseResult::UnneededAttachedValue { .. }
                                        | ParseResult::AttachedValueNotConsumed => unreachable!(),
                                    }
                                }

                                if let ParseState::Opt(id) = &parse_state {
                                    // Assume this is a value of a previous arg.

                                    // get the option so we can check the settings
                                    let arg = &self.cmd[id];
                                    let parse_result = if let Some(parse_result) =
                                        self.check_terminator(arg, arg_os.to_value_os())
                                    {
                                        parse_result
                                    } else {
                                        let trailing_values = false;
                                        let arg_values = matcher.pending_values_mut(id, None, trailing_values);
                                        arg_values.push(arg_os.to_value_os().to_owned());
                                        if matcher.needs_more_vals(arg) {
                                            ParseResult::Opt(arg.get_id().clone())
                                        } else {
                                            ParseResult::ValuesDone
                                        }
                                    };
                                    parse_state = match parse_result {
                                        ParseResult::Opt(id) => ParseState::Opt(id),
                                        ParseResult::ValuesDone => ParseState::ValuesDone,
                                        _ => unreachable!(),
                                    };
                                    // get the next value from the iterator
                                    continue;
                                }
                            }

                            // Correct pos_counter.
                            pos_counter = {
                                let is_second_to_last = pos_counter + 1 == positional_count;

                                // The last positional argument, or second to last positional
                                // argument may be set to .multiple_values(true) or `.multiple_occurrences(true)`
                                let low_index_mults = is_second_to_last
                                    && self.cmd.get_positionals().any(|a| {
                                        a.is_multiple() && (positional_count != a.get_index().unwrap_or(0))
                                    })
                                    && self
                                        .cmd
                                        .get_positionals()
                                        .last()
                                        .map(|p_name| !p_name.is_last_set())
                                        .unwrap_or_default();

                                let is_terminated = self
                                    .cmd
                                    .get_keymap()
                                    .get(&pos_counter)
                                    .map(|a| a.get_value_terminator().is_some())
                                    .unwrap_or_default();

                                let missing_pos = self.cmd.is_allow_missing_positional_set()
                                    && is_second_to_last
                                    && !trailing_values;

                                debug!("Parser::get_matches_with: Positional counter...{pos_counter}");
                                debug!("Parser::get_matches_with: Low index multiples...{low_index_mults:?}");

                                if (low_index_mults || missing_pos) && !is_terminated {
                                    let skip_current = if let Some(n) = raw_args.peek(&args_cursor) {
                                        if let Some(arg) = self
                                            .cmd
                                            .get_positionals()
                                            .find(|a| a.get_index() == Some(pos_counter))
                                        {
                                            // If next value looks like a new_arg or it's a
                                            // subcommand, skip positional argument under current
                                            // pos_counter(which means current value cannot be a
                                            // positional argument with a value next to it), assume
                                            // current value matches the next arg.
                                            self.is_new_arg(&n, arg)
                                                || self
                                                    .possible_subcommand(n.to_value(), valid_arg_found)
                                                    .is_some()
                                        } else {
                                            true
                                        }
                                    } else {
                                        true
                                    };

                                    if skip_current {
                                        debug!("Parser::get_matches_with: Bumping the positional counter...");
                                        pos_counter + 1
                                    } else {
                                        pos_counter
                                    }
                                } else if trailing_values
                                    && (self.cmd.is_allow_missing_positional_set() || contains_last)
                                {
                                    // Came to -- and one positional has .last(true) set, so we go immediately
                                    // to the last (highest index) positional
                                    debug!("Parser::get_matches_with: .last(true) and --, setting last pos");
                                    positional_count
                                } else {
                                    pos_counter
                                }
                            };

                            if let Some(arg) = self.cmd.get_keymap().get(&pos_counter) {
                                if arg.is_last_set() && !trailing_values {
                                    let _ = self.resolve_pending(matcher);
                                    // Its already considered a positional, we don't need to suggest turning it
                                    // into one
                                    let suggested_trailing_arg = false;
                                    return Err(ClapError::unknown_argument(
                                        self.cmd,
                                        arg_os.display().to_string(),
                                        None,
                                        suggested_trailing_arg,
                                        Usage::new(self.cmd).create_usage_with_title(&[]),
                                    ));
                                }

                                if arg.is_trailing_var_arg_set() {
                                    trailing_values = true;
                                }

                                if matcher.pending_arg_id() != Some(arg.get_id()) || !arg.is_multiple_values_set() {
                                    ok!(self.resolve_pending(matcher));
                                }
                                parse_state =
                                    if let Some(parse_result) = self.check_terminator(arg, arg_os.to_value_os()) {
                                        debug_assert_eq!(parse_result, ParseResult::ValuesDone);
                                        pos_counter += 1;
                                        ParseState::ValuesDone
                                    } else {
                                        let arg_values = matcher.pending_values_mut(
                                            arg.get_id(),
                                            Some(Identifier::Index),
                                            trailing_values,
                                        );
                                        arg_values.push(arg_os.to_value_os().to_owned());

                                        // Only increment the positional counter if it doesn't allow multiples
                                        if !arg.is_multiple() {
                                            pos_counter += 1;
                                            ParseState::ValuesDone
                                        } else {
                                            ParseState::Pos(arg.get_id().clone())
                                        }
                                    };
                                valid_arg_found = true;
                            } else if let Some(external_parser) =
                                self.cmd.get_external_subcommand_value_parser().cloned()
                            {
                                // Get external subcommand name
                                let sc_name = match arg_os.to_value() {
                                    Ok(s) => s.to_owned(),
                                    Err(_) => {
                                        let _ = self.resolve_pending(matcher);
                                        return Err(ClapError::invalid_utf8(
                                            self.cmd,
                                            Usage::new(self.cmd).create_usage_with_title(&[]),
                                        ));
                                    }
                                };

                                // Collect the external subcommand args
                                let mut sc_m = ArgMatcher::new(self.cmd);
                                sc_m.start_occurrence_of_external(self.cmd);

                                for raw_val in raw_args.remaining(&mut args_cursor) {
                                    let val = ok!(external_parser.parse_ref(
                                        self.cmd,
                                        None,
                                        raw_val,
                                        ValueSource::CommandLine
                                    ));
                                    let external_id = Id::from_static_ref(Id::EXTERNAL);
                                    sc_m.add_val_to(&external_id, val, raw_val.to_os_string());
                                }

                                matcher.subcommand(SubCommand {
                                    name: sc_name,
                                    matches: sc_m.into_inner(),
                                });

                                return Ok(());
                            } else {
                                // Start error processing
                                let _ = self.resolve_pending(matcher);
                                return Err(self.match_arg_error(
                                    &arg_os,
                                    valid_arg_found,
                                    trailing_values,
                                    matcher,
                                ));
                            }
                        }

                        if let Some(ref pos_sc_name) = subcmd_name {
                            if self.cmd.is_args_conflicts_with_subcommands_set() && valid_arg_found {
                                return Err(ClapError::subcommand_conflict(
                                    self.cmd,
                                    pos_sc_name.clone(),
                                    matcher
                                        .arg_ids()
                                        .map(|id| self.cmd.find(id).unwrap().to_string())
                                        .collect(),
                                    Usage::new(self.cmd).create_usage_with_title(&[]),
                                ));
                            }
                            let sc_name = self
                                .cmd
                                .find_subcommand(pos_sc_name)
                                .expect(INTERNAL_ERROR_MSG)
                                .get_name()
                                .to_owned();
                            ok!(self.parse_subcommand(&sc_name, matcher, raw_args, args_cursor, keep_state));
                        }

                        Ok(())
                    }

                    fn match_arg_error(
                        &self,
                        arg_os: &clap_lex::ParsedArg<'_>,
                        valid_arg_found: bool,
                        trailing_values: bool,
                        matcher: &ArgMatcher,
                    ) -> ClapError {
                        // If argument follows a `--`
                        if trailing_values {
                            // If the arg matches a subcommand name, or any of its aliases (if defined)
                            if self
                                .possible_subcommand(arg_os.to_value(), valid_arg_found)
                                .is_some()
                            {
                                return ClapError::unnecessary_double_dash(
                                    self.cmd,
                                    arg_os.display().to_string(),
                                    Usage::new(self.cmd).create_usage_with_title(&[]),
                                );
                            }
                        }

                        let suggested_trailing_arg = !trailing_values
                            && self.cmd.has_positionals()
                            && (arg_os.is_long() || arg_os.is_short());

                        if self.cmd.has_subcommands() {
                            if self.cmd.is_args_conflicts_with_subcommands_set() && valid_arg_found {
                                return ClapError::subcommand_conflict(
                                    self.cmd,
                                    arg_os.display().to_string(),
                                    matcher
                                        .arg_ids()
                                        .filter_map(|id| self.cmd.find(id).map(|a| a.to_string()))
                                        .collect(),
                                    Usage::new(self.cmd).create_usage_with_title(&[]),
                                );
                            }

                            let candidates = suggestions::did_you_mean(
                                &arg_os.display().to_string(),
                                self.cmd.all_subcommand_names(),
                            );
                            // If the argument looks like a subcommand.
                            if !candidates.is_empty() {
                                return ClapError::invalid_subcommand(
                                    self.cmd,
                                    arg_os.display().to_string(),
                                    candidates,
                                    self.cmd.get_bin_name_fallback().to_owned(),
                                    suggested_trailing_arg,
                                    Usage::new(self.cmd).create_usage_with_title(&[]),
                                );
                            }

                            // If the argument must be a subcommand.
                            if !self.cmd.has_positionals() || self.cmd.is_infer_subcommands_set() {
                                return ClapError::unrecognized_subcommand(
                                    self.cmd,
                                    arg_os.display().to_string(),
                                    Usage::new(self.cmd).create_usage_with_title(&[]),
                                );
                            }
                        }

                        ClapError::unknown_argument(
                            self.cmd,
                            arg_os.display().to_string(),
                            None,
                            suggested_trailing_arg,
                            Usage::new(self.cmd).create_usage_with_title(&[]),
                        )
                    }

                    // Checks if the arg matches a subcommand name, or any of its aliases (if defined)
                    fn possible_subcommand(
                        &self,
                        arg: Result<&str, &OsStr>,
                        valid_arg_found: bool,
                    ) -> Option<&str> {
                        debug!("Parser::possible_subcommand: arg={arg:?}");
                        let arg = some!(arg.ok());

                        if !(self.cmd.is_args_conflicts_with_subcommands_set() && valid_arg_found) {
                            if self.cmd.is_infer_subcommands_set() {
                                // For subcommand `test`, we accepts it's prefix: `t`, `te`,
                                // `tes` and `test`.
                                let mut iter = self.cmd.get_subcommands().filter_map(|s| {
                                    if s.get_name().starts_with(arg) {
                                        return Some(s.get_name());
                                    }

                                    // Use find here instead of chaining the iterator because we want to accept
                                    // conflicts in aliases.
                                    s.get_all_aliases().find(|s| s.starts_with(arg))
                                });

                                if let name @ Some(_) = iter.next() {
                                    if iter.next().is_none() {
                                        return name;
                                    }
                                }
                            }
                            // Don't use an else here because we want inference to support exact matching even if
                            // there are conflicts.
                            if let Some(sc) = self.cmd.find_subcommand(arg) {
                                return Some(sc.get_name());
                            }
                        }
                        None
                    }

                    // Checks if the arg matches a long flag subcommand name, or any of its aliases (if defined)
                    fn possible_long_flag_subcommand(&self, arg: &str) -> Option<&str> {
                        debug!("Parser::possible_long_flag_subcommand: arg={arg:?}");
                        if self.cmd.is_infer_subcommands_set() {
                            let mut iter = self.cmd.get_subcommands().filter_map(|sc| {
                                sc.get_long_flag().and_then(|long| {
                                    if long.starts_with(arg) {
                                        Some(sc.get_name())
                                    } else {
                                        sc.get_all_long_flag_aliases().find_map(|alias| {
                                            if alias.starts_with(arg) {
                                                Some(sc.get_name())
                                            } else {
                                                None
                                            }
                                        })
                                    }
                                })
                            });

                            if let name @ Some(_) = iter.next() {
                                if iter.next().is_none() {
                                    return name;
                                }
                            }
                        }
                        if let Some(sc_name) = self.cmd.find_long_subcmd(arg) {
                            return Some(sc_name);
                        }
                        None
                    }

                    fn parse_help_subcommand(
                        &self,
                        cmds: impl Iterator<Item = &'cmd OsStr>,
                    ) -> ClapResult<std::convert::Infallible> {
                        debug!("Parser::parse_help_subcommand");

                        let mut cmd = self.cmd.clone();
                        let sc = {
                            let mut sc = &mut cmd;

                            for cmd in cmds {
                                sc = if let Some(sc_name) =
                                    sc.find_subcommand(cmd).map(|sc| sc.get_name().to_owned())
                                {
                                    sc._build_subcommand(&sc_name).unwrap()
                                } else {
                                    return Err(ClapError::unrecognized_subcommand(
                                        sc,
                                        cmd.to_string_lossy().into_owned(),
                                        Usage::new(sc).create_usage_with_title(&[]),
                                    ));
                                };
                            }

                            sc
                        };
                        let parser = Parser::new(sc);

                        Err(parser.help_err(true))
                    }

                    fn is_new_arg(&self, next: &clap_lex::ParsedArg<'_>, current_positional: &Arg) -> bool {
                        #![allow(clippy::needless_bool)] // Prefer consistent if/else-if ladder

                        debug!(
                            "Parser::is_new_arg: {:?}:{}",
                            next.to_value_os(),
                            current_positional.get_id()
                        );

                        if self.cmd[current_positional.get_id()].is_allow_hyphen_values_set()
                            || (self.cmd[current_positional.get_id()].is_allow_negative_numbers_set()
                                && next.is_negative_number())
                        {
                            // If allow hyphen, this isn't a new arg.
                            debug!("Parser::is_new_arg: Allow hyphen");
                            false
                        } else if next.is_long() {
                            // If this is a long flag, this is a new arg.
                            debug!("Parser::is_new_arg: --<something> found");
                            true
                        } else if next.is_short() {
                            // If this is a short flag, this is a new arg. But a single '-' by
                            // itself is a value and typically means "stdin" on unix systems.
                            debug!("Parser::is_new_arg: -<something> found");
                            true
                        } else {
                            // Nothing special, this is a value.
                            debug!("Parser::is_new_arg: value");
                            false
                        }
                    }

                    fn parse_subcommand(
                        &mut self,
                        sc_name: &str,
                        matcher: &mut ArgMatcher,
                        raw_args: &mut clap_lex::RawArgs,
                        args_cursor: clap_lex::ArgCursor,
                        keep_state: bool,
                    ) -> ClapResult<()> {
                        debug!("Parser::parse_subcommand");

                        let partial_parsing_enabled = self.cmd.is_ignore_errors_set();

                        if let Some(sc) = self.cmd._build_subcommand(sc_name) {
                            let mut sc_matcher = ArgMatcher::new(sc);

                            debug!(
                                "Parser::parse_subcommand: About to parse sc={}",
                                sc.get_name()
                            );

                            {
                                let mut p = Parser::new(sc);
                                // HACK: maintain indexes between parsers
                                // FlagSubCommand short arg needs to revisit the current short args, but skip the subcommand itself
                                if keep_state {
                                    p.cur_idx.set(self.cur_idx.get());
                                    p.flag_subcmd_at = self.flag_subcmd_at;
                                    p.flag_subcmd_skip = self.flag_subcmd_skip;
                                }
                                if let Err(error) = p.get_matches_with(&mut sc_matcher, raw_args, args_cursor) {
                                    if partial_parsing_enabled {
                                        debug!("Parser::parse_subcommand: ignored error in subcommand {sc_name}: {error:?}");
                                    } else {
                                        return Err(error);
                                    }
                                }
                            }
                            matcher.subcommand(SubCommand {
                                name: sc.get_name().to_owned(),
                                matches: sc_matcher.into_inner(),
                            });
                        }
                        Ok(())
                    }

                    fn parse_long_arg(
                        &mut self,
                        matcher: &mut ArgMatcher,
                        long_arg: Result<&str, &OsStr>,
                        long_value: Option<&OsStr>,
                        parse_state: &ParseState,
                        pos_counter: usize,
                        valid_arg_found: &mut bool,
                    ) -> ClapResult<ParseResult> {
                        // maybe here lifetime should be 'a
                        debug!("Parser::parse_long_arg");

                        #[allow(clippy::blocks_in_conditions)]
                        if matches!(parse_state, ParseState::Opt(opt) | ParseState::Pos(opt) if
                            self.cmd[opt].is_allow_hyphen_values_set())
                        {
                            debug!("Parser::parse_long_arg: prior arg accepts hyphenated values",);
                            return Ok(ParseResult::MaybeHyphenValue);
                        }

                        debug!("Parser::parse_long_arg: Does it contain '='...");
                        let long_arg = match long_arg {
                            Ok(long_arg) => long_arg,
                            Err(long_arg_os) => {
                                return Ok(ParseResult::NoMatchingArg {
                                    arg: long_arg_os.to_string_lossy().into_owned(),
                                })
                            }
                        };
                        if long_arg.is_empty() {
                            debug_assert!(
                                long_value.is_some(),
                                "`--` should be filtered out before this point"
                            );
                        }

                        let arg = if let Some(arg) = self.cmd.get_keymap().get(long_arg) {
                            debug!("Parser::parse_long_arg: Found valid arg or flag '{arg}'");
                            Some((long_arg, arg))
                        } else if self.cmd.is_infer_long_args_set() {
                            let mut iter = self.cmd.get_arguments().filter_map(|a| {
                                if let Some(long) = a.get_long() {
                                    if long.starts_with(long_arg) {
                                        return Some((long, a));
                                    }
                                }
                                a.aliases
                                    .iter()
                                    .find_map(|(alias, _)| alias.starts_with(long_arg).then(|| (alias.as_str(), a)))
                            });

                            iter.next().filter(|_| iter.next().is_none())
                        } else {
                            None
                        };

                        if let Some((_long_arg, arg)) = arg {
                            let ident = Identifier::Long;
                            *valid_arg_found = true;
                            if arg.is_takes_value_set() {
                                debug!(
                                    "Parser::parse_long_arg({:?}): Found an arg with value '{:?}'",
                                    long_arg, &long_value
                                );
                                let has_eq = long_value.is_some();
                                self.parse_opt_value(ident, long_value, arg, matcher, has_eq)
                            } else if let Some(rest) = long_value {
                                let required = self.cmd.required_graph();
                                debug!("Parser::parse_long_arg({long_arg:?}): Got invalid literal `{rest:?}`");
                                let mut used: Vec<Id> = matcher
                                    .arg_ids()
                                    .filter(|arg_id| {
                                        matcher.check_explicit(arg_id, &crate::builder::ArgPredicate::IsPresent)
                                    })
                                    .filter(|&n| {
                                        self.cmd
                                            .find(n)
                                            .map(|a| !(a.is_hide_set() || required.contains(a.get_id())))
                                            .unwrap_or(true)
                                    })
                                    .cloned()
                                    .collect();
                                used.push(arg.get_id().clone());

                                Ok(ParseResult::UnneededAttachedValue {
                                    rest: rest.to_string_lossy().into_owned(),
                                    used,
                                    arg: arg.to_string(),
                                })
                            } else {
                                debug!("Parser::parse_long_arg({long_arg:?}): Presence validated");
                                let trailing_idx = None;
                                self.react(
                                    Some(ident),
                                    ValueSource::CommandLine,
                                    arg,
                                    vec![],
                                    trailing_idx,
                                    matcher,
                                )
                            }
                        } else if let Some(sc_name) = self.possible_long_flag_subcommand(long_arg) {
                            Ok(ParseResult::FlagSubCommand(sc_name.to_string()))
                        } else if self
                            .cmd
                            .get_keymap()
                            .get(&pos_counter)
                            .map(|arg| arg.is_allow_hyphen_values_set() && !arg.is_last_set())
                            .unwrap_or_default()
                        {
                            debug!("Parser::parse_long_args: positional at {pos_counter} allows hyphens");
                            Ok(ParseResult::MaybeHyphenValue)
                        } else {
                            Ok(ParseResult::NoMatchingArg {
                                arg: long_arg.to_owned(),
                            })
                        }
                    }

                    fn parse_short_arg(
                        &mut self,
                        matcher: &mut ArgMatcher,
                        mut short_arg: clap_lex::ShortFlags<'_>,
                        parse_state: &ParseState,
                        // change this to possible pos_arg when removing the usage of &mut Parser.
                        pos_counter: usize,
                        valid_arg_found: &mut bool,
                    ) -> ClapResult<ParseResult> {
                        debug!("Parser::parse_short_arg: short_arg={short_arg:?}");

                        #[allow(clippy::blocks_in_conditions)]
                        if matches!(parse_state, ParseState::Opt(opt) | ParseState::Pos(opt)
                                if self.cmd[opt].is_allow_hyphen_values_set() || (self.cmd[opt].is_allow_negative_numbers_set() && short_arg.is_negative_number()))
                        {
                            debug!("Parser::parse_short_args: prior arg accepts hyphenated values",);
                            return Ok(ParseResult::MaybeHyphenValue);
                        } else if self
                            .cmd
                            .get_keymap()
                            .get(&pos_counter)
                            .map(|arg| arg.is_allow_negative_numbers_set())
                            .unwrap_or_default()
                            && short_arg.is_negative_number()
                        {
                            debug!("Parser::parse_short_arg: negative number");
                            return Ok(ParseResult::MaybeHyphenValue);
                        } else if self
                            .cmd
                            .get_keymap()
                            .get(&pos_counter)
                            .map(|arg| arg.is_allow_hyphen_values_set() && !arg.is_last_set())
                            .unwrap_or_default()
                            && short_arg
                                .clone()
                                .any(|c| !c.map(|c| self.cmd.contains_short(c)).unwrap_or_default())
                        {
                            debug!("Parser::parse_short_args: positional at {pos_counter} allows hyphens");
                            return Ok(ParseResult::MaybeHyphenValue);
                        }

                        let mut ret = ParseResult::NoArg;

                        let skip = self.flag_subcmd_skip;
                        self.flag_subcmd_skip = 0;
                        let res = short_arg.advance_by(skip);
                        debug_assert_eq!(
                            res,
                            Ok(()),
                            "tracking of `flag_subcmd_skip` is off for `{short_arg:?}`"
                        );
                        while let Some(c) = short_arg.next_flag() {
                            let c = match c {
                                Ok(c) => c,
                                Err(rest) => {
                                    return Ok(ParseResult::NoMatchingArg {
                                        arg: format!("-{}", rest.to_string_lossy()),
                                    });
                                }
                            };
                            debug!("Parser::parse_short_arg:iter:{c}");

                            // Check for matching short options, and return the name if there is no trailing
                            // concatenated value: -oval
                            // Option: -o
                            // Value: val
                            if let Some(arg) = self.cmd.get_keymap().get(&c) {
                                let ident = Identifier::Short;
                                debug!("Parser::parse_short_arg:iter:{c}: Found valid opt or flag");
                                *valid_arg_found = true;
                                if !arg.is_takes_value_set() {
                                    let arg_values = Vec::new();
                                    let trailing_idx = None;
                                    ret = ok!(self.react(
                                        Some(ident),
                                        ValueSource::CommandLine,
                                        arg,
                                        arg_values,
                                        trailing_idx,
                                        matcher,
                                    ));
                                    continue;
                                }

                                // Check for trailing concatenated value
                                //
                                // Cloning the iterator, so we rollback if it isn't there.
                                let val = short_arg.clone().next_value_os().unwrap_or_default();
                                debug!("Parser::parse_short_arg:iter:{c}: val={val:?}, short_arg={short_arg:?}");
                                let val = Some(val).filter(|v| !v.is_empty());

                                // Default to "we're expecting a value later".
                                //
                                // If attached value is not consumed, we may have more short
                                // flags to parse, continue.
                                //
                                // e.g. `-xvf`, when require_equals && x.min_vals == 0, we don't
                                // consume the `vf`, even if it's provided as value.
                                let (val, has_eq) = if let Some(val) = val.and_then(|v| v.strip_prefix("=")) {
                                    (Some(val), true)
                                } else {
                                    (val, false)
                                };
                                match ok!(self.parse_opt_value(ident, val, arg, matcher, has_eq)) {
                                    ParseResult::AttachedValueNotConsumed => continue,
                                    x => return Ok(x),
                                }
                            }

                            return if let Some(sc_name) = self.cmd.find_short_subcmd(c) {
                                debug!("Parser::parse_short_arg:iter:{c}: subcommand={sc_name}");
                                // Make sure indices get updated before reading `self.cur_idx`
                                ok!(self.resolve_pending(matcher));
                                self.cur_idx.set(self.cur_idx.get() + 1);
                                debug!("Parser::parse_short_arg: cur_idx:={}", self.cur_idx.get());

                                let name = sc_name.to_string();
                                // Get the index of the previously saved flag subcommand in the group of flags (if exists).
                                // If it is a new flag subcommand, then the formentioned index should be the current one
                                // (ie. `cur_idx`), and should be registered.
                                let cur_idx = self.cur_idx.get();
                                self.flag_subcmd_at.get_or_insert(cur_idx);
                                let done_short_args = short_arg.is_empty();
                                if done_short_args {
                                    self.flag_subcmd_at = None;
                                }
                                Ok(ParseResult::FlagSubCommand(name))
                            } else {
                                Ok(ParseResult::NoMatchingArg {
                                    arg: format!("-{c}"),
                                })
                            };
                        }
                        Ok(ret)
                    }

                    fn parse_opt_value(
                        &self,
                        ident: Identifier,
                        attached_value: Option<&OsStr>,
                        arg: &Arg,
                        matcher: &mut ArgMatcher,
                        has_eq: bool,
                    ) -> ClapResult<ParseResult> {
                        debug!(
                            "Parser::parse_opt_value; arg={}, val={:?}, has_eq={:?}",
                            arg.get_id(),
                            attached_value,
                            has_eq
                        );
                        debug!("Parser::parse_opt_value; arg.settings={:?}", arg.settings);

                        debug!("Parser::parse_opt_value; Checking for val...");
                        // require_equals is set, but no '=' is provided, try throwing error.
                        if arg.is_require_equals_set() && !has_eq {
                            if arg.get_min_vals() == 0 {
                                debug!("Requires equals, but min_vals == 0");
                                let arg_values = Vec::new();
                                let trailing_idx = None;
                                let react_result = ok!(self.react(
                                    Some(ident),
                                    ValueSource::CommandLine,
                                    arg,
                                    arg_values,
                                    trailing_idx,
                                    matcher,
                                ));
                                debug_assert_eq!(react_result, ParseResult::ValuesDone);
                                if attached_value.is_some() {
                                    Ok(ParseResult::AttachedValueNotConsumed)
                                } else {
                                    Ok(ParseResult::ValuesDone)
                                }
                            } else {
                                debug!("Requires equals but not provided. Error.");
                                Ok(ParseResult::EqualsNotProvided {
                                    arg: arg.to_string(),
                                })
                            }
                        } else if let Some(v) = attached_value {
                            let arg_values = vec![v.to_owned()];
                            let trailing_idx = None;
                            let react_result = ok!(self.react(
                                Some(ident),
                                ValueSource::CommandLine,
                                arg,
                                arg_values,
                                trailing_idx,
                                matcher,
                            ));
                            debug_assert_eq!(react_result, ParseResult::ValuesDone);
                            // Attached are always done
                            Ok(ParseResult::ValuesDone)
                        } else {
                            debug!("Parser::parse_opt_value: More arg vals required...");
                            ok!(self.resolve_pending(matcher));
                            let trailing_values = false;
                            matcher.pending_values_mut(arg.get_id(), Some(ident), trailing_values);
                            Ok(ParseResult::Opt(arg.get_id().clone()))
                        }
                    }

                    fn check_terminator(&self, arg: &Arg, val: &OsStr) -> Option<ParseResult> {
                        if Some(val) == arg.terminator.as_ref().map(|s| OsStr::new(s.as_str())) {
                            debug!("Parser::check_terminator: terminator={:?}", arg.terminator);
                            Some(ParseResult::ValuesDone)
                        } else {
                            None
                        }
                    }

                    fn push_arg_values(
                        &self,
                        arg: &Arg,
                        raw_vals: Vec<OsString>,
                        source: ValueSource,
                        matcher: &mut ArgMatcher,
                    ) -> ClapResult<()> {
                        debug!("Parser::push_arg_values: {raw_vals:?}");

                        for raw_val in raw_vals {
                            // update the current index because each value is a distinct index to clap
                            self.cur_idx.set(self.cur_idx.get() + 1);
                            debug!(
                                "Parser::add_single_val_to_arg: cur_idx:={}",
                                self.cur_idx.get()
                            );
                            let value_parser = arg.get_value_parser();
                            let val = ok!(value_parser.parse_ref(self.cmd, Some(arg), &raw_val, source));

                            matcher.add_val_to(arg.get_id(), val, raw_val);
                            matcher.add_index_to(arg.get_id(), self.cur_idx.get());
                        }

                        Ok(())
                    }

                    fn resolve_pending(&self, matcher: &mut ArgMatcher) -> ClapResult<()> {
                        let pending = match matcher.take_pending() {
                            Some(pending) => pending,
                            None => {
                                return Ok(());
                            }
                        };

                        debug!("Parser::resolve_pending: id={:?}", pending.id);
                        let arg = self.cmd.find(&pending.id).expect(INTERNAL_ERROR_MSG);
                        let _ = ok!(self.react(
                            pending.ident,
                            ValueSource::CommandLine,
                            arg,
                            pending.raw_vals,
                            pending.trailing_idx,
                            matcher,
                        ));

                        Ok(())
                    }

                    fn react(
                        &self,
                        ident: Option<Identifier>,
                        source: ValueSource,
                        arg: &Arg,
                        mut raw_vals: Vec<OsString>,
                        mut trailing_idx: Option<usize>,
                        matcher: &mut ArgMatcher,
                    ) -> ClapResult<ParseResult> {
                        ok!(self.resolve_pending(matcher));

                        debug!(
                            "Parser::react action={:?}, identifier={:?}, source={:?}",
                            arg.get_action(),
                            ident,
                            source
                        );

                        // Process before `default_missing_values` to avoid it counting as values from the command
                        // line
                        if source == ValueSource::CommandLine {
                            ok!(self.verify_num_args(arg, &raw_vals));
                        }

                        if raw_vals.is_empty() {
                            // We assume this case is valid: require equals, but min_vals == 0.
                            if !arg.default_missing_vals.is_empty() {
                                debug!("Parser::react: has default_missing_vals");
                                trailing_idx = None;
                                raw_vals.extend(
                                    arg.default_missing_vals
                                        .iter()
                                        .map(|s| s.as_os_str().to_owned()),
                                );
                            }
                        }

                        if let Some(val_delim) = arg.get_value_delimiter() {
                            if self.cmd.is_dont_delimit_trailing_values_set() && trailing_idx == Some(0) {
                                // Nothing to do
                            } else {
                                let mut val_delim_buffer = [0; 4];
                                let val_delim = val_delim.encode_utf8(&mut val_delim_buffer);
                                let mut split_raw_vals = Vec::with_capacity(raw_vals.len());
                                for (i, raw_val) in raw_vals.into_iter().enumerate() {
                                    if !raw_val.contains(val_delim)
                                        || (self.cmd.is_dont_delimit_trailing_values_set()
                                            && trailing_idx == Some(i))
                                    {
                                        split_raw_vals.push(raw_val);
                                    } else {
                                        split_raw_vals.extend(raw_val.split(val_delim).map(|x| x.to_owned()));
                                    }
                                }
                                raw_vals = split_raw_vals;
                            }
                        }

                        match arg.get_action() {
                            ArgAction::Set => {
                                if source == ValueSource::CommandLine
                                    && matches!(ident, Some(Identifier::Short) | Some(Identifier::Long))
                                {
                                    // Record flag's index
                                    self.cur_idx.set(self.cur_idx.get() + 1);
                                    debug!("Parser::react: cur_idx:={}", self.cur_idx.get());
                                }
                                if matcher.remove(arg.get_id())
                                    && !(self.cmd.is_args_override_self() || arg.overrides.contains(arg.get_id()))
                                {
                                    return Err(ClapError::argument_conflict(
                                        self.cmd,
                                        arg.to_string(),
                                        vec![arg.to_string()],
                                        Usage::new(self.cmd).create_usage_with_title(&[]),
                                    ));
                                }
                                self.start_custom_arg(matcher, arg, source);
                                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                                if cfg!(debug_assertions) && matcher.needs_more_vals(arg) {
                                    debug!(
                                        "Parser::react not enough values passed in, leaving it to the validator to complain",
                                    );
                                }
                                Ok(ParseResult::ValuesDone)
                            }
                            ArgAction::Append => {
                                if source == ValueSource::CommandLine
                                    && matches!(ident, Some(Identifier::Short) | Some(Identifier::Long))
                                {
                                    // Record flag's index
                                    self.cur_idx.set(self.cur_idx.get() + 1);
                                    debug!("Parser::react: cur_idx:={}", self.cur_idx.get());
                                }
                                self.start_custom_arg(matcher, arg, source);
                                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                                if cfg!(debug_assertions) && matcher.needs_more_vals(arg) {
                                    debug!(
                                        "Parser::react not enough values passed in, leaving it to the validator to complain",
                                    );
                                }
                                Ok(ParseResult::ValuesDone)
                            }
                            ArgAction::SetTrue => {
                                let raw_vals = if raw_vals.is_empty() {
                                    vec![OsString::from("true")]
                                } else {
                                    raw_vals
                                };

                                if matcher.remove(arg.get_id())
                                    && !(self.cmd.is_args_override_self() || arg.overrides.contains(arg.get_id()))
                                {
                                    return Err(ClapError::argument_conflict(
                                        self.cmd,
                                        arg.to_string(),
                                        vec![arg.to_string()],
                                        Usage::new(self.cmd).create_usage_with_title(&[]),
                                    ));
                                }
                                self.start_custom_arg(matcher, arg, source);
                                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                                Ok(ParseResult::ValuesDone)
                            }
                            ArgAction::SetFalse => {
                                let raw_vals = if raw_vals.is_empty() {
                                    vec![OsString::from("false")]
                                } else {
                                    raw_vals
                                };

                                if matcher.remove(arg.get_id())
                                    && !(self.cmd.is_args_override_self() || arg.overrides.contains(arg.get_id()))
                                {
                                    return Err(ClapError::argument_conflict(
                                        self.cmd,
                                        arg.to_string(),
                                        vec![arg.to_string()],
                                        Usage::new(self.cmd).create_usage_with_title(&[]),
                                    ));
                                }
                                self.start_custom_arg(matcher, arg, source);
                                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                                Ok(ParseResult::ValuesDone)
                            }
                            ArgAction::Count => {
                                let raw_vals = if raw_vals.is_empty() {
                                    let existing_value = *matcher
                                        .get_one::<crate::builder::CountType>(arg.get_id().as_str())
                                        .unwrap_or(&0);
                                    let next_value = existing_value.saturating_add(1);
                                    vec![OsString::from(next_value.to_string())]
                                } else {
                                    raw_vals
                                };

                                matcher.remove(arg.get_id());
                                self.start_custom_arg(matcher, arg, source);
                                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                                Ok(ParseResult::ValuesDone)
                            }
                            ArgAction::Help => {
                                let use_long = match ident {
                                    Some(Identifier::Long) => true,
                                    Some(Identifier::Short) => false,
                                    Some(Identifier::Index) => true,
                                    None => true,
                                };
                                debug!("Help: use_long={use_long}");
                                Err(self.help_err(use_long))
                            }
                            ArgAction::HelpShort => {
                                let use_long = false;
                                debug!("Help: use_long={use_long}");
                                Err(self.help_err(use_long))
                            }
                            ArgAction::HelpLong => {
                                let use_long = true;
                                debug!("Help: use_long={use_long}");
                                Err(self.help_err(use_long))
                            }
                            ArgAction::Version => {
                                let use_long = match ident {
                                    Some(Identifier::Long) => true,
                                    Some(Identifier::Short) => false,
                                    Some(Identifier::Index) => true,
                                    None => true,
                                };
                                debug!("Version: use_long={use_long}");
                                Err(self.version_err(use_long))
                            }
                        }
                    }

                    fn verify_num_args(&self, arg: &Arg, raw_vals: &[OsString]) -> ClapResult<()> {
                        if self.cmd.is_ignore_errors_set() {
                            return Ok(());
                        }

                        let actual = raw_vals.len();
                        let expected = arg.get_num_args().expect(INTERNAL_ERROR_MSG);

                        if 0 < expected.min_values() && actual == 0 {
                            // Issue 665 (https://github.com/clap-rs/clap/issues/665)
                            // Issue 1105 (https://github.com/clap-rs/clap/issues/1105)
                            return Err(ClapError::empty_value(
                                self.cmd,
                                &super::get_possible_values_cli(arg)
                                    .iter()
                                    .filter(|pv| !pv.is_hide_set())
                                    .map(|n| n.get_name().to_owned())
                                    .collect::<Vec<_>>(),
                                arg.to_string(),
                            ));
                        } else if let Some(expected) = expected.num_values() {
                            if expected != actual {
                                debug!("Validator::validate_arg_num_vals: Sending error WrongNumberOfValues");
                                return Err(ClapError::wrong_number_of_values(
                                    self.cmd,
                                    arg.to_string(),
                                    expected,
                                    actual,
                                    Usage::new(self.cmd).create_usage_with_title(&[]),
                                ));
                            }
                        } else if actual < expected.min_values() {
                            return Err(ClapError::too_few_values(
                                self.cmd,
                                arg.to_string(),
                                expected.min_values(),
                                actual,
                                Usage::new(self.cmd).create_usage_with_title(&[]),
                            ));
                        } else if expected.max_values() < actual {
                            debug!("Validator::validate_arg_num_vals: Sending error TooManyValues");
                            return Err(ClapError::too_many_values(
                                self.cmd,
                                raw_vals
                                    .last()
                                    .expect(INTERNAL_ERROR_MSG)
                                    .to_string_lossy()
                                    .into_owned(),
                                arg.to_string(),
                                Usage::new(self.cmd).create_usage_with_title(&[]),
                            ));
                        }

                        Ok(())
                    }

                    fn remove_overrides(&self, arg: &Arg, matcher: &mut ArgMatcher) {
                        debug!("Parser::remove_overrides: id={:?}", arg.id);
                        for override_id in &arg.overrides {
                            debug!("Parser::remove_overrides:iter:{override_id:?}: removing");
                            matcher.remove(override_id);
                        }

                        // Override anything that can override us
                        let mut transitive = Vec::new();
                        for arg_id in matcher.arg_ids() {
                            if let Some(overrider) = self.cmd.find(arg_id) {
                                if overrider.overrides.contains(arg.get_id()) {
                                    transitive.push(overrider.get_id());
                                }
                            }
                        }
                        for overrider_id in transitive {
                            debug!("Parser::remove_overrides:iter:{overrider_id:?}: removing");
                            matcher.remove(overrider_id);
                        }
                    }

                    #[cfg(feature = "env")]
                    fn add_env(&mut self, matcher: &mut ArgMatcher) -> ClapResult<()> {
                        debug!("Parser::add_env");

                        for arg in self.cmd.get_arguments() {
                            // Use env only if the arg was absent among command line args,
                            // early return if this is not the case.
                            if matcher.contains(&arg.id) {
                                debug!("Parser::add_env: Skipping existing arg `{arg}`");
                                continue;
                            }

                            debug!("Parser::add_env: Checking arg `{arg}`");
                            if let Some((_, Some(ref val))) = arg.env {
                                debug!("Parser::add_env: Found an opt with value={val:?}");
                                let arg_values = vec![val.to_owned()];
                                let trailing_idx = None;
                                let _ = ok!(self.react(
                                    None,
                                    ValueSource::EnvVariable,
                                    arg,
                                    arg_values,
                                    trailing_idx,
                                    matcher,
                                ));
                            }
                        }

                        Ok(())
                    }

                    fn add_defaults(&self, matcher: &mut ArgMatcher) -> ClapResult<()> {
                        debug!("Parser::add_defaults");

                        for arg in self.cmd.get_arguments() {
                            debug!("Parser::add_defaults:iter:{}:", arg.get_id());
                            ok!(self.add_default_value(arg, matcher));
                        }

                        Ok(())
                    }

                    fn add_default_value(&self, arg: &Arg, matcher: &mut ArgMatcher) -> ClapResult<()> {
                        if !arg.default_vals_ifs.is_empty() {
                            debug!("Parser::add_default_value: has conditional defaults");
                            if !matcher.contains(arg.get_id()) {
                                for (id, val, default) in arg.default_vals_ifs.iter() {
                                    let add = if let Some(a) = matcher.get(id) {
                                        match val {
                                            crate::builder::ArgPredicate::Equals(v) => {
                                                a.raw_vals_flatten().any(|value| v == value)
                                            }
                                            crate::builder::ArgPredicate::IsPresent => true,
                                        }
                                    } else {
                                        false
                                    };

                                    if add {
                                        if let Some(default) = default {
                                            let arg_values = vec![default.to_os_string()];
                                            let trailing_idx = None;
                                            let _ = ok!(self.react(
                                                None,
                                                ValueSource::DefaultValue,
                                                arg,
                                                arg_values,
                                                trailing_idx,
                                                matcher,
                                            ));
                                        }
                                        return Ok(());
                                    }
                                }
                            }
                        } else {
                            debug!("Parser::add_default_value: doesn't have conditional defaults");
                        }

                        if !arg.default_vals.is_empty() {
                            debug!(
                                "Parser::add_default_value:iter:{}: has default vals",
                                arg.get_id()
                            );
                            if matcher.contains(arg.get_id()) {
                                debug!("Parser::add_default_value:iter:{}: was used", arg.get_id());
                            // do nothing
                            } else {
                                debug!(
                                    "Parser::add_default_value:iter:{}: wasn't used",
                                    arg.get_id()
                                );
                                let arg_values: Vec<_> = arg
                                    .default_vals
                                    .iter()
                                    .map(crate::builder::OsStr::to_os_string)
                                    .collect();
                                let trailing_idx = None;
                                let _ = ok!(self.react(
                                    None,
                                    ValueSource::DefaultValue,
                                    arg,
                                    arg_values,
                                    trailing_idx,
                                    matcher,
                                ));
                            }
                        } else {
                            debug!(
                                "Parser::add_default_value:iter:{}: doesn't have default vals",
                                arg.get_id()
                            );

                            // do nothing
                        }

                        Ok(())
                    }

                    fn start_custom_arg(&self, matcher: &mut ArgMatcher, arg: &Arg, source: ValueSource) {
                        if source == ValueSource::CommandLine {
                            // With each new occurrence, remove overrides from prior occurrences
                            self.remove_overrides(arg, matcher);
                        }
                        matcher.start_custom_arg(arg, source);
                        if source.is_explicit() {
                            for group in self.cmd.groups_for_arg(arg.get_id()) {
                                matcher.start_custom_group(group.clone(), source);
                                matcher.add_val_to(
                                    &group,
                                    AnyValue::new(arg.get_id().clone()),
                                    OsString::from(arg.get_id().as_str()),
                                );
                            }
                        }
                    }
                }

                // Error, Help, and Version Methods
                impl Parser<'_> {
                    /// Is only used for the long flag(which is the only one needs fuzzy searching)
                    fn did_you_mean_error(
                        &mut self,
                        arg: &str,
                        matcher: &mut ArgMatcher,
                        remaining_args: &[&OsStr],
                        trailing_values: bool,
                    ) -> ClapError {
                        debug!("Parser::did_you_mean_error: arg={arg}");
                        // Didn't match a flag or option
                        let longs = self
                            .cmd
                            .get_keymap()
                            .keys()
                            .filter_map(|x| match x {
                                KeyType::Long(l) => Some(l.to_string_lossy().into_owned()),
                                _ => None,
                            })
                            .collect::<Vec<_>>();
                        debug!("Parser::did_you_mean_error: longs={longs:?}");

                        let did_you_mean = suggestions::did_you_mean_flag(
                            arg,
                            remaining_args,
                            longs.iter().map(|x| &x[..]),
                            self.cmd.get_subcommands_mut(),
                        );

                        // Add the arg to the matches to build a proper usage string
                        if !self.cmd.is_ignore_errors_set() {
                            if let Some((name, _)) = did_you_mean.as_ref() {
                                if let Some(arg) = self.cmd.get_keymap().get(&name.as_ref()) {
                                    self.start_custom_arg(matcher, arg, ValueSource::CommandLine);
                                }
                            }
                        }
                        let did_you_mean = did_you_mean.map(|(arg, cmd)| (format!("--{arg}"), cmd));

                        let required = self.cmd.required_graph();
                        let used: Vec<Id> = matcher
                            .arg_ids()
                            .filter(|arg_id| {
                                matcher.check_explicit(arg_id, &crate::builder::ArgPredicate::IsPresent)
                            })
                            .filter(|n| self.cmd.find(n).map(|a| !a.is_hide_set()).unwrap_or(false))
                            .cloned()
                            .collect();

                        // `did_you_mean` is a lot more likely and should cause us to skip the `--` suggestion
                        // with the one exception being that the CLI is trying to capture arguments
                        //
                        // In theory, this is only called for `--long`s, so we don't need to check
                        let suggested_trailing_arg = (did_you_mean.is_none()
                            || self
                                .cmd
                                .get_positionals()
                                .any(|arg| arg.is_last_set() || arg.is_trailing_var_arg_set()))
                            && !trailing_values
                            && self.cmd.has_positionals();
                        ClapError::unknown_argument(
                            self.cmd,
                            format!("--{arg}"),
                            did_you_mean,
                            suggested_trailing_arg,
                            Usage::new(self.cmd)
                                .required(&required)
                                .create_usage_with_title(&used),
                        )
                    }

                    fn help_err(&self, use_long: bool) -> ClapError {
                        let styled = self.cmd.write_help_err(use_long);
                        ClapError::display_help(self.cmd, styled)
                    }

                    fn version_err(&self, use_long: bool) -> ClapError {
                        let styled = self.cmd.write_version_err(use_long);
                        ClapError::display_version(self.cmd, styled)
                    }
                }

                #[derive(Debug, PartialEq, Eq)]
                pub enum ParseState {
                    ValuesDone,
                    Opt(Id),
                    Pos(Id),
                }
                /// Recoverable Parsing results.
                #[derive(Debug, PartialEq, Clone)]
                #[must_use]
                enum ParseResult {
                    FlagSubCommand(String),
                    Opt(Id),
                    ValuesDone,
                    /// Value attached to the short flag is not consumed(e.g. 'u' for `-cu` is
                    /// not consumed).
                    AttachedValueNotConsumed,
                    /// This long flag doesn't need a value but is provided one.
                    UnneededAttachedValue {
                        rest: String,
                        used: Vec<Id>,
                        arg: String,
                    },
                    /// This flag might be an hyphen Value.
                    MaybeHyphenValue,
                    /// Equals required but not provided.
                    EqualsNotProvided {
                        arg: String,
                    },
                    /// Failed to match a Arg.
                    NoMatchingArg {
                        arg: String,
                    },
                    /// No argument found e.g. parser is given `-` when parsing a flag.
                    NoArg,
                }

                #[derive(Clone, Debug, PartialEq, Eq)]
                pub struct PendingArg {
                    pub id: Id,
                    pub ident: Option<Identifier>,
                    pub raw_vals: Vec<OsString>,
                    pub trailing_idx: Option<usize>,
                }

                #[derive(Copy, Clone, Debug, PartialEq, Eq)]
                pub enum Identifier {
                    Short,
                    Long,
                    Index,
                }
            }

            pub mod validator
            {
                use ::
                {
                    *,
                };
                //
                // Internal
                use crate::builder::StyledStr;
                use crate::builder::{Arg, ArgGroup, ArgPredicate, Command, PossibleValue};
                use crate::error::{Error, Result as ClapResult};
                use crate::output::Usage;
                use crate::parser::ArgMatcher;
                use crate::util::ChildGraph;
                use crate::util::FlatMap;
                use crate::util::FlatSet;
                use crate::util::Id;
                use crate::INTERNAL_ERROR_MSG;

                pub struct Validator<'cmd> {
                    cmd: &'cmd Command,
                    required: ChildGraph<Id>,
                }

                impl<'cmd> Validator<'cmd> {
                    pub fn new(cmd: &'cmd Command) -> Self {
                        let required = cmd.required_graph();
                        Validator { cmd, required }
                    }

                    pub fn validate(&mut self, matcher: &mut ArgMatcher) -> ClapResult<()> {
                        debug!("Validator::validate");
                        let conflicts = Conflicts::with_args(self.cmd, matcher);
                        let has_subcmd = matcher.subcommand_name().is_some();

                        if !has_subcmd && self.cmd.is_arg_required_else_help_set() {
                            let num_user_values = matcher
                                .args()
                                .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                                .count();
                            if num_user_values == 0 {
                                let message = self.cmd.write_help_err(false);
                                return Err(Error::display_help_error(self.cmd, message));
                            }
                        }
                        if !has_subcmd && self.cmd.is_subcommand_required_set() {
                            let bn = self.cmd.get_bin_name_fallback();
                            return Err(Error::missing_subcommand(
                                self.cmd,
                                bn.to_string(),
                                self.cmd
                                    .all_subcommand_names()
                                    .map(|s| s.to_owned())
                                    .collect::<Vec<_>>(),
                                Usage::new(self.cmd)
                                    .required(&self.required)
                                    .create_usage_with_title(&[]),
                            ));
                        }

                        ok!(self.validate_conflicts(matcher, &conflicts));
                        if !(self.cmd.is_subcommand_negates_reqs_set() && has_subcmd) {
                            ok!(self.validate_required(matcher, &conflicts));
                        }

                        Ok(())
                    }

                    fn validate_conflicts(
                        &mut self,
                        matcher: &ArgMatcher,
                        conflicts: &Conflicts,
                    ) -> ClapResult<()> {
                        debug!("Validator::validate_conflicts");

                        ok!(self.validate_exclusive(matcher));

                        for (arg_id, _) in matcher
                            .args()
                            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                            .filter(|(arg_id, _)| self.cmd.find(arg_id).is_some())
                        {
                            debug!("Validator::validate_conflicts::iter: id={arg_id:?}");
                            let conflicts = conflicts.gather_conflicts(self.cmd, arg_id);
                            ok!(self.build_conflict_err(arg_id, &conflicts, matcher));
                        }

                        Ok(())
                    }

                    fn validate_exclusive(&self, matcher: &ArgMatcher) -> ClapResult<()> {
                        debug!("Validator::validate_exclusive");
                        let args_count = matcher
                            .args()
                            .filter(|(arg_id, matched)| {
                                matched.check_explicit(&ArgPredicate::IsPresent)
                                    // Avoid including our own groups by checking none of them.  If a group is present, the
                                    // args for the group will be.
                                    && self.cmd.find(arg_id).is_some()
                            })
                            .count();
                        if args_count <= 1 {
                            // Nothing present to conflict with
                            return Ok(());
                        }

                        matcher
                            .args()
                            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                            .find_map(|(id, _)| {
                                debug!("Validator::validate_exclusive:iter:{id:?}");
                                self.cmd
                                    .find(id)
                                    // Find `arg`s which are exclusive but also appear with other args.
                                    .filter(|&arg| arg.is_exclusive_set() && args_count > 1)
                            })
                            .map(|arg| {
                                // Throw an error for the first conflict found.
                                Err(Error::argument_conflict(
                                    self.cmd,
                                    arg.to_string(),
                                    Vec::new(),
                                    Usage::new(self.cmd)
                                        .required(&self.required)
                                        .create_usage_with_title(&[]),
                                ))
                            })
                            .unwrap_or(Ok(()))
                    }

                    fn build_conflict_err(
                        &self,
                        name: &Id,
                        conflict_ids: &[Id],
                        matcher: &ArgMatcher,
                    ) -> ClapResult<()> {
                        if conflict_ids.is_empty() {
                            return Ok(());
                        }

                        debug!("Validator::build_conflict_err: name={name:?}");
                        let mut seen = FlatSet::new();
                        let conflicts = conflict_ids
                            .iter()
                            .flat_map(|c_id| {
                                if self.cmd.find_group(c_id).is_some() {
                                    self.cmd.unroll_args_in_group(c_id)
                                } else {
                                    vec![c_id.clone()]
                                }
                            })
                            .filter_map(|c_id| {
                                seen.insert(c_id.clone()).then(|| {
                                    let c_arg = self.cmd.find(&c_id).expect(INTERNAL_ERROR_MSG);
                                    c_arg.to_string()
                                })
                            })
                            .collect();

                        let former_arg = self.cmd.find(name).expect(INTERNAL_ERROR_MSG);
                        let usg = self.build_conflict_err_usage(matcher, conflict_ids);
                        Err(Error::argument_conflict(
                            self.cmd,
                            former_arg.to_string(),
                            conflicts,
                            usg,
                        ))
                    }

                    fn build_conflict_err_usage(
                        &self,
                        matcher: &ArgMatcher,
                        conflicting_keys: &[Id],
                    ) -> Option<StyledStr> {
                        let used_filtered: Vec<Id> = matcher
                            .args()
                            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                            .map(|(n, _)| n)
                            .filter(|n| {
                                // Filter out the args we don't want to specify.
                                self.cmd
                                    .find(n)
                                    .map(|a| !a.is_hide_set())
                                    .unwrap_or_default()
                            })
                            .filter(|key| !conflicting_keys.contains(key))
                            .cloned()
                            .collect();
                        let required: Vec<Id> = used_filtered
                            .iter()
                            .filter_map(|key| self.cmd.find(key))
                            .flat_map(|arg| arg.requires.iter().map(|item| &item.1))
                            .filter(|key| !used_filtered.contains(key) && !conflicting_keys.contains(key))
                            .chain(used_filtered.iter())
                            .cloned()
                            .collect();
                        Usage::new(self.cmd)
                            .required(&self.required)
                            .create_usage_with_title(&required)
                    }

                    fn gather_requires(&mut self, matcher: &ArgMatcher) {
                        debug!("Validator::gather_requires");
                        for (name, matched) in matcher
                            .args()
                            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                        {
                            debug!("Validator::gather_requires:iter:{name:?}");
                            if let Some(arg) = self.cmd.find(name) {
                                let is_relevant = |(val, req_arg): &(ArgPredicate, Id)| -> Option<Id> {
                                    let required = matched.check_explicit(val);
                                    required.then(|| req_arg.clone())
                                };

                                for req in self.cmd.unroll_arg_requires(is_relevant, arg.get_id()) {
                                    self.required.insert(req);
                                }
                            } else if let Some(g) = self.cmd.find_group(name) {
                                debug!("Validator::gather_requires:iter:{name:?}:group");
                                for r in &g.requires {
                                    self.required.insert(r.clone());
                                }
                            }
                        }
                    }

                    fn validate_required(&mut self, matcher: &ArgMatcher, conflicts: &Conflicts) -> ClapResult<()> {
                        debug!("Validator::validate_required: required={:?}", self.required);
                        self.gather_requires(matcher);

                        let mut missing_required = Vec::new();
                        let mut highest_index = 0;

                        let is_exclusive_present = matcher
                            .args()
                            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                            .any(|(id, _)| {
                                self.cmd
                                    .find(id)
                                    .map(|arg| arg.is_exclusive_set())
                                    .unwrap_or_default()
                            });
                        debug!("Validator::validate_required: is_exclusive_present={is_exclusive_present}");

                        for arg_or_group in self
                            .required
                            .iter()
                            .filter(|r| !matcher.check_explicit(r, &ArgPredicate::IsPresent))
                        {
                            debug!("Validator::validate_required:iter:aog={arg_or_group:?}");
                            if let Some(arg) = self.cmd.find(arg_or_group) {
                                debug!("Validator::validate_required:iter: This is an arg");
                                if !is_exclusive_present && !self.is_missing_required_ok(arg, conflicts) {
                                    debug!(
                                        "Validator::validate_required:iter: Missing {:?}",
                                        arg.get_id()
                                    );
                                    missing_required.push(arg.get_id().clone());
                                    if !arg.is_last_set() {
                                        highest_index = highest_index.max(arg.get_index().unwrap_or(0));
                                    }
                                }
                            } else if let Some(group) = self.cmd.find_group(arg_or_group) {
                                debug!("Validator::validate_required:iter: This is a group");
                                if !self
                                    .cmd
                                    .unroll_args_in_group(&group.id)
                                    .iter()
                                    .any(|a| matcher.check_explicit(a, &ArgPredicate::IsPresent))
                                {
                                    debug!(
                                        "Validator::validate_required:iter: Missing {:?}",
                                        group.get_id()
                                    );
                                    missing_required.push(group.get_id().clone());
                                }
                            }
                        }

                        // Validate the conditionally required args
                        for a in self
                            .cmd
                            .get_arguments()
                            .filter(|a| !matcher.check_explicit(a.get_id(), &ArgPredicate::IsPresent))
                        {
                            let mut required = false;

                            for (other, val) in &a.r_ifs {
                                if matcher.check_explicit(other, &ArgPredicate::Equals(val.into())) {
                                    debug!(
                                        "Validator::validate_required:iter: Missing {:?}",
                                        a.get_id()
                                    );
                                    required = true;
                                }
                            }

                            let match_all = a.r_ifs_all.iter().all(|(other, val)| {
                                matcher.check_explicit(other, &ArgPredicate::Equals(val.into()))
                            });
                            if match_all && !a.r_ifs_all.is_empty() {
                                debug!(
                                    "Validator::validate_required:iter: Missing {:?}",
                                    a.get_id()
                                );
                                required = true;
                            }

                            if (!a.r_unless.is_empty() || !a.r_unless_all.is_empty())
                                && self.fails_arg_required_unless(a, matcher)
                            {
                                debug!(
                                    "Validator::validate_required:iter: Missing {:?}",
                                    a.get_id()
                                );
                                required = true;
                            }

                            if !is_exclusive_present && required {
                                missing_required.push(a.get_id().clone());
                                if !a.is_last_set() {
                                    highest_index = highest_index.max(a.get_index().unwrap_or(0));
                                }
                            }
                        }

                        // For display purposes, include all of the preceding positional arguments
                        if !self.cmd.is_allow_missing_positional_set() {
                            for pos in self
                                .cmd
                                .get_positionals()
                                .filter(|a| !matcher.check_explicit(a.get_id(), &ArgPredicate::IsPresent))
                            {
                                if pos.get_index() < Some(highest_index) {
                                    debug!(
                                        "Validator::validate_required:iter: Missing {:?}",
                                        pos.get_id()
                                    );
                                    missing_required.push(pos.get_id().clone());
                                }
                            }
                        }

                        if !missing_required.is_empty() {
                            ok!(self.missing_required_error(matcher, missing_required));
                        }

                        Ok(())
                    }

                    fn is_missing_required_ok(&self, a: &Arg, conflicts: &Conflicts) -> bool {
                        debug!("Validator::is_missing_required_ok: {}", a.get_id());
                        if !conflicts.gather_conflicts(self.cmd, a.get_id()).is_empty() {
                            debug!("Validator::is_missing_required_ok: true (self)");
                            return true;
                        }
                        for group_id in self.cmd.groups_for_arg(a.get_id()) {
                            if !conflicts.gather_conflicts(self.cmd, &group_id).is_empty() {
                                debug!("Validator::is_missing_required_ok: true ({group_id})");
                                return true;
                            }
                        }
                        false
                    }

                    // Failing a required unless means, the arg's "unless" wasn't present, and neither were they
                    fn fails_arg_required_unless(&self, a: &Arg, matcher: &ArgMatcher) -> bool {
                        debug!("Validator::fails_arg_required_unless: a={:?}", a.get_id());
                        let exists = |id| matcher.check_explicit(id, &ArgPredicate::IsPresent);

                        (a.r_unless_all.is_empty() || !a.r_unless_all.iter().all(exists))
                            && !a.r_unless.iter().any(exists)
                    }

                    // `req_args`: an arg to include in the error even if not used
                    fn missing_required_error(
                        &self,
                        matcher: &ArgMatcher,
                        raw_req_args: Vec<Id>,
                    ) -> ClapResult<()> {
                        debug!("Validator::missing_required_error; incl={raw_req_args:?}");
                        debug!(
                            "Validator::missing_required_error: reqs={:?}",
                            self.required
                        );

                        let usg = Usage::new(self.cmd).required(&self.required);

                        let req_args = {
                            #[cfg(feature = "usage")]
                            {
                                usg.get_required_usage_from(&raw_req_args, Some(matcher), true)
                                    .into_iter()
                                    .map(|s| s.to_string())
                                    .collect::<Vec<_>>()
                            }

                            #[cfg(not(feature = "usage"))]
                            {
                                raw_req_args
                                    .iter()
                                    .map(|id| {
                                        if let Some(arg) = self.cmd.find(id) {
                                            arg.to_string()
                                        } else if let Some(_group) = self.cmd.find_group(id) {
                                            self.cmd.format_group(id).to_string()
                                        } else {
                                            debug_assert!(false, "id={id:?} is unknown");
                                            "".to_owned()
                                        }
                                    })
                                    .collect::<FlatSet<_>>()
                                    .into_iter()
                                    .collect::<Vec<_>>()
                            }
                        };

                        debug!("Validator::missing_required_error: req_args={req_args:#?}");

                        let used: Vec<Id> = matcher
                            .args()
                            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                            .map(|(n, _)| n)
                            .filter(|n| {
                                // Filter out the args we don't want to specify.
                                self.cmd
                                    .find(n)
                                    .map(|a| !a.is_hide_set())
                                    .unwrap_or_default()
                            })
                            .cloned()
                            .chain(raw_req_args)
                            .collect();

                        Err(Error::missing_required_argument(
                            self.cmd,
                            req_args,
                            usg.create_usage_with_title(&used),
                        ))
                    }
                }

                #[derive(Default, Clone, Debug)]
                struct Conflicts {
                    potential: FlatMap<Id, Vec<Id>>,
                }

                impl Conflicts {
                    fn with_args(cmd: &Command, matcher: &ArgMatcher) -> Self {
                        let mut potential = FlatMap::new();
                        potential.extend_unchecked(
                            matcher
                                .args()
                                .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                                .map(|(id, _)| {
                                    let conf = gather_direct_conflicts(cmd, id);
                                    (id.clone(), conf)
                                }),
                        );
                        Self { potential }
                    }

                    fn gather_conflicts(&self, cmd: &Command, arg_id: &Id) -> Vec<Id> {
                        debug!("Conflicts::gather_conflicts: arg={arg_id:?}");
                        let mut conflicts = Vec::new();

                        let arg_id_conflicts_storage;
                        let arg_id_conflicts = if let Some(arg_id_conflicts) = self.get_direct_conflicts(arg_id) {
                            arg_id_conflicts
                        } else {
                            // `is_missing_required_ok` is a case where we check not-present args for conflicts
                            arg_id_conflicts_storage = gather_direct_conflicts(cmd, arg_id);
                            &arg_id_conflicts_storage
                        };
                        for (other_arg_id, other_arg_id_conflicts) in self.potential.iter() {
                            if arg_id == other_arg_id {
                                continue;
                            }

                            if arg_id_conflicts.contains(other_arg_id) {
                                conflicts.push(other_arg_id.clone());
                            }
                            if other_arg_id_conflicts.contains(arg_id) {
                                conflicts.push(other_arg_id.clone());
                            }
                        }

                        debug!("Conflicts::gather_conflicts: conflicts={conflicts:?}");
                        conflicts
                    }

                    fn get_direct_conflicts(&self, arg_id: &Id) -> Option<&[Id]> {
                        self.potential.get(arg_id).map(Vec::as_slice)
                    }
                }

                fn gather_direct_conflicts(cmd: &Command, id: &Id) -> Vec<Id> {
                    let conf = if let Some(arg) = cmd.find(id) {
                        gather_arg_direct_conflicts(cmd, arg)
                    } else if let Some(group) = cmd.find_group(id) {
                        gather_group_direct_conflicts(group)
                    } else {
                        debug_assert!(false, "id={id:?} is unknown");
                        Vec::new()
                    };
                    debug!("Conflicts::gather_direct_conflicts id={id:?}, conflicts={conf:?}",);
                    conf
                }

                fn gather_arg_direct_conflicts(cmd: &Command, arg: &Arg) -> Vec<Id> {
                    let mut conf = arg.blacklist.clone();
                    for group_id in cmd.groups_for_arg(arg.get_id()) {
                        let group = cmd.find_group(&group_id).expect(INTERNAL_ERROR_MSG);
                        conf.extend(group.conflicts.iter().cloned());
                        if !group.multiple {
                            for member_id in &group.args {
                                if member_id != arg.get_id() {
                                    conf.push(member_id.clone());
                                }
                            }
                        }
                    }

                    // Overrides are implicitly conflicts
                    conf.extend(arg.overrides.iter().cloned());

                    conf
                }

                fn gather_group_direct_conflicts(group: &ArgGroup) -> Vec<Id> {
                    group.conflicts.clone()
                }

                pub fn get_possible_values_cli(a: &Arg) -> Vec<PossibleValue> {
                    if !a.is_takes_value_set() {
                        vec![]
                    } else {
                        a.get_value_parser()
                            .possible_values()
                            .map(|pvs| pvs.collect())
                            .unwrap_or_default()
                    }
                }
            }
            
            pub mod features
            {
                pub mod suggestions
                {
                    // Internal
                    use crate::builder::Command;

                    /// Find strings from an iterable of `possible_values` similar to a given value `v`
                    /// Returns a Vec of all possible values that exceed a similarity threshold
                    /// sorted by ascending similarity, most similar comes last
                    #[cfg(feature = "suggestions")]
                    pub fn did_you_mean<T, I>(v: &str, possible_values: I) -> Vec<String>
                    where
                        T: AsRef<str>,
                        I: IntoIterator<Item = T>,
                    {
                        use std::cmp::Ordering;

                        let mut candidates: Vec<(f64, String)> = Vec::new();
                        for pv in possible_values {
                            // GH #4660: using `jaro` because `jaro_winkler` implementation in `strsim-rs` is wrong
                            // causing strings with common prefix >=10 to be considered perfectly similar
                            let confidence = strsim::jaro(v, pv.as_ref());

                            if confidence > 0.7 {
                                let new_elem = (confidence, pv.as_ref().to_owned());
                                let pos = candidates
                                    .binary_search_by(|probe| {
                                        if probe.0 > confidence {
                                            Ordering::Greater
                                        } else {
                                            Ordering::Less
                                        }
                                    })
                                    .unwrap_or_else(|e| e);
                                candidates.insert(pos, new_elem);
                            }
                        }

                        candidates.into_iter().map(|(_, pv)| pv).collect()
                    }

                    #[cfg(not(feature = "suggestions"))]
                    pub fn did_you_mean<T, I>(_: &str, _: I) -> Vec<String>
                    where
                        T: AsRef<str>,
                        I: IntoIterator<Item = T>,
                    {
                        Vec::new()
                    }
                    /// Returns a suffix that can be empty, or is the standard 'did you mean' phrase
                    pub fn did_you_mean_flag<'a, 'help, I, T>(
                        arg: &str,
                        remaining_args: &[&std::ffi::OsStr],
                        longs: I,
                        subcommands: impl IntoIterator<Item = &'a mut Command>,
                    ) -> Option<(String, Option<String>)>
                    where
                        'help: 'a,
                        T: AsRef<str>,
                        I: IntoIterator<Item = T>,
                    {
                        use crate::mkeymap::KeyType;

                        match did_you_mean(arg, longs).pop() {
                            Some(candidate) => Some((candidate, None)),
                            None => subcommands
                                .into_iter()
                                .filter_map(|subcommand| {
                                    subcommand._build_self(false);

                                    let longs = subcommand.get_keymap().keys().filter_map(|a| {
                                        if let KeyType::Long(v) = a {
                                            Some(v.to_string_lossy().into_owned())
                                        } else {
                                            None
                                        }
                                    });

                                    let subcommand_name = subcommand.get_name();

                                    let candidate = some!(did_you_mean(arg, longs).pop());
                                    let score = some!(remaining_args.iter().position(|x| subcommand_name == *x));
                                    Some((score, (candidate, Some(subcommand_name.to_string()))))
                                })
                                .min_by_key(|(x, _)| *x)
                                .map(|(_, suggestion)| suggestion),
                        }
                    }
                }
            }

            pub use self::arg_matcher::ArgMatcher;
            pub use self::matches::{MatchedArg, SubCommand};
            pub use self::parser::Identifier;
            pub use self::parser::Parser;
            pub use self::parser::PendingArg;
            pub use self::validator::get_possible_values_cli;
            pub use self::validator::Validator;

            pub use self::matches::IdsRef;
            pub use self::matches::RawValues;
            pub use self::matches::Values;
            pub use self::matches::ValuesRef;
            pub use self::matches::{ArgMatches, Indices, ValueSource};
            pub use error::MatchesError;
        }

        pub mod mkeymap
        {    
            use ::
            {
                *,
            };   
        }

        pub mod output
        {    
            use ::
            {
                *,
            };   
        }

        pub mod util
        {    
            use ::
            {
                *,
            };   
        }
        
        pub use crate::builder::ArgAction;
        pub use crate::builder::Command;
        pub use crate::builder::ValueHint;
        pub use crate::builder::{Arg, ArgGroup};
        pub use crate::parser::ArgMatches;
        pub use crate::util::color::ColorChoice;
        pub use crate::util::Id;

        /// Command Line Argument Parser Error.
        pub type Error = error::Error<error::DefaultFormatter>;

        pub use crate::derive::{Args, CommandFactory, FromArgMatches, Parser, Subcommand, ValueEnum};

        const INTERNAL_ERROR_MSG: &str = "Fatal internal error. Please consider filing a bug \
                                        report at https://github.com/clap-rs/clap/issues";
    }

    pub mod clap_complete
    {
        use ::
        {
            *,
        };

        const INTERNAL_ERROR_MSG: &str = "Fatal internal error. Please consider filing a bug \
                                        report at https://github.com/clap-rs/clap/issues";

        #[macro_use]
        #[allow(missing_docs)]
        pub mod macros
        {
            use ::
            {
                *,
            };
            #[cfg(feature = "debug")]
            macro_rules! debug {
                ($($arg:tt)*) => {
                    eprint!("[{:>w$}] \t", module_path!(), w = 28);
                    eprintln!($($arg)*)
                }
            }

            #[cfg(not(feature = "debug"))]
            macro_rules! debug {
                ($($arg:tt)*) => {};
            }
        }

        pub mod aot
        {
            //! Prebuilt completions
            use ::
            {
                *,
            };
            pub mod generator
            {
                //! Shell completion machinery
                use ::
                {
                    *,
                };
                

                pub mod utils
                {
                    //! Helpers for writing generators
                    use ::
                    {
                        *,
                    };
                    
                    use clap::{Arg, Command};
                    /// Gets all subcommands including child subcommands in the form of `("name", "bin_name")`.
                    ///
                    /// Subcommand `rustup toolchain install` would be converted to
                    /// `("install", "rustup toolchain install")`.
                    pub fn all_subcommands(cmd: &Command) -> Vec<(String, String)> {
                        let mut subcmds: Vec<_> = subcommands(cmd);

                        for sc_v in cmd.get_subcommands().map(all_subcommands) {
                            subcmds.extend(sc_v);
                        }

                        subcmds
                    }
                    /// Finds the subcommand [`clap::Command`] from the given [`clap::Command`] with the given path.
                    ///
                    /// <div class="warning">
                    ///
                    /// **NOTE:** `path` should not contain the root `bin_name`.
                    ///
                    /// </div>
                    pub fn find_subcommand_with_path<'cmd>(p: &'cmd Command, path: Vec<&str>) -> &'cmd Command {
                        let mut cmd = p;

                        for sc in path {
                            cmd = cmd.find_subcommand(sc).unwrap();
                        }

                        cmd
                    }
                    /// Gets subcommands of [`clap::Command`] in the form of `("name", "bin_name")`.
                    ///
                    /// Subcommand `rustup toolchain install` would be converted to
                    /// `("install", "rustup toolchain install")`.
                    pub fn subcommands(p: &Command) -> Vec<(String, String)> {
                        debug!("subcommands: name={}", p.get_name());
                        debug!("subcommands: Has subcommands...{:?}", p.has_subcommands());

                        let mut subcmds = vec![];

                        for sc in p.get_subcommands() {
                            let sc_bin_name = sc.get_bin_name().unwrap();

                            debug!(
                                "subcommands:iter: name={}, bin_name={}",
                                sc.get_name(),
                                sc_bin_name
                            );
                            subcmds.push((sc.get_name().to_string(), sc_bin_name.to_string()));

                            for alias in sc.get_visible_aliases() {
                                debug!(
                                    "subcommands:iter: alias={}, bin_name={}",
                                    alias, sc_bin_name
                                );
                                subcmds.push((alias.to_string(), sc_bin_name.to_string()));
                            }
                        }

                        subcmds
                    }
                    /// Gets all the short options, their visible aliases and flags of a [`clap::Command`].
                    /// Includes `h` and `V` depending on the [`clap::Command`] settings.
                    pub fn shorts_and_visible_aliases(p: &Command) -> Vec<char> {
                        debug!("shorts: name={}", p.get_name());

                        p.get_arguments()
                            .filter_map(|a| {
                                if !a.is_positional() {
                                    if a.get_visible_short_aliases().is_some() && a.get_short().is_some() {
                                        let mut shorts_and_visible_aliases = a.get_visible_short_aliases().unwrap();
                                        shorts_and_visible_aliases.push(a.get_short().unwrap());
                                        Some(shorts_and_visible_aliases)
                                    } else if a.get_visible_short_aliases().is_none() && a.get_short().is_some() {
                                        Some(vec![a.get_short().unwrap()])
                                    } else {
                                        None
                                    }
                                } else {
                                    None
                                }
                            })
                            .flatten()
                            .collect()
                    }
                    /// Gets all the long options, their visible aliases and flags of a [`clap::Command`].
                    /// Includes `help` and `version` depending on the [`clap::Command`] settings.
                    pub fn longs_and_visible_aliases(p: &Command) -> Vec<String> {
                        debug!("longs: name={}", p.get_name());

                        p.get_arguments()
                            .filter_map(|a| {
                                if !a.is_positional() {
                                    if a.get_visible_aliases().is_some() && a.get_long().is_some() {
                                        let mut visible_aliases: Vec<_> = a
                                            .get_visible_aliases()
                                            .unwrap()
                                            .into_iter()
                                            .map(|s| s.to_string())
                                            .collect();
                                        visible_aliases.push(a.get_long().unwrap().to_string());
                                        Some(visible_aliases)
                                    } else if a.get_visible_aliases().is_none() && a.get_long().is_some() {
                                        Some(vec![a.get_long().unwrap().to_string()])
                                    } else {
                                        None
                                    }
                                } else {
                                    None
                                }
                            })
                            .flatten()
                            .collect()
                    }
                    /// Gets all the flags of a [`clap::Command`].
                    /// Includes `help` and `version` depending on the [`clap::Command`] settings.
                    pub fn flags(p: &Command) -> Vec<Arg> {
                        debug!("flags: name={}", p.get_name());
                        p.get_arguments()
                            .filter(|a| !a.get_num_args().expect("built").takes_values() && !a.is_positional())
                            .cloned()
                            .collect()
                    }
                    /// Get the possible values for completion
                    pub fn possible_values(a: &Arg) -> Option<Vec<clap::builder::PossibleValue>> {
                        if !a.get_num_args().expect("built").takes_values() {
                            None
                        } else {
                            a.get_value_parser()
                                .possible_values()
                                .map(|pvs| pvs.collect())
                        }
                    }
                }

                use std::ffi::OsString;
                use std::fs::File;
                use std::io::Error;
                use std::io::Write;
                use std::path::PathBuf;

                use clap::Command;

                /// Generator trait which can be used to write generators
                pub trait Generator {
                    /// Returns the file name that is created when this generator is called during compile time.
                    fn file_name(&self, name: &str) -> String;

                    /// Generates output out of [`clap::Command`].
                    fn generate(&self, cmd: &Command, buf: &mut dyn Write);
                }
                /// Generate a completions file for a specified shell at compile-time.
                pub fn generate_to<G, S, T>(
                    generator: G,
                    cmd: &mut Command,
                    bin_name: S,
                    out_dir: T,
                ) -> Result<PathBuf, Error> where
                    G: Generator,
                    S: Into<String>,
                    T: Into<OsString>,
                {
                    cmd.set_bin_name(bin_name);

                    let out_dir = PathBuf::from(out_dir.into());
                    let file_name = generator.file_name(cmd.get_bin_name().unwrap());

                    let path = out_dir.join(file_name);
                    let mut file = File::create(&path)?;

                    _generate::<G>(generator, cmd, &mut file);
                    Ok(path)
                }
                /// Generate a completions file for a specified shell at runtime.
                pub fn generate<G, S>(generator: G, cmd: &mut Command, bin_name: S, buf: &mut dyn Write)  where
                    G: Generator,
                    S: Into<String>,
                {
                    cmd.set_bin_name(bin_name);
                    _generate::<G>(generator, cmd, buf);
                }

                fn _generate<G: Generator>(generator: G, cmd: &mut Command, buf: &mut dyn Write) {
                    cmd.build();
                    generator.generate(cmd, buf);
                }
            }

            pub mod shells
            {
                //! Shell-specific generators
                use ::
                {
                    *,
                };
                

                pub mod bash
                {
                    use ::
                    {
                        *,
                    };
                    use std::{fmt::Write as _, io::Write};

                    use clap::{Arg, Command, ValueHint};

                    use crate::generator::{utils, Generator};
                    /// Generate bash completion file
                    #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                    pub struct Bash;

                    impl Generator for Bash {
                        fn file_name(&self, name: &str) -> String {
                            format!("{name}.bash")
                        }

                        fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
                            let bin_name = cmd
                                .get_bin_name()
                                .expect("crate::generate should have set the bin_name");

                            let fn_name = bin_name.replace('-', "__");

                            write!(
                                buf,
                                "_{name}() {{
                        local i cur prev opts cmd
                        COMPREPLY=()
                        cur=\"${{COMP_WORDS[COMP_CWORD]}}\"
                        prev=\"${{COMP_WORDS[COMP_CWORD-1]}}\"
                        cmd=\"\"
                        opts=\"\"

                        for i in ${{COMP_WORDS[@]}}
                        do
                            case \"${{cmd}},${{i}}\" in
                                \",$1\")
                                    cmd=\"{cmd}\"
                                    ;;{subcmds}
                                *)
                                    ;;
                            esac
                        done

                        case \"${{cmd}}\" in
                            {cmd})
                                opts=\"{name_opts}\"
                                if [[ ${{cur}} == -* || ${{COMP_CWORD}} -eq 1 ]] ; then
                                    COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )
                                    return 0
                                fi
                                case \"${{prev}}\" in{name_opts_details}
                                    *)
                                        COMPREPLY=()
                                        ;;
                                esac
                                COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )
                                return 0
                                ;;{subcmd_details}
                        esac
                    }}

                    if [[ \"${{BASH_VERSINFO[0]}}\" -eq 4 && \"${{BASH_VERSINFO[1]}}\" -ge 4 || \"${{BASH_VERSINFO[0]}}\" -gt 4 ]]; then
                        complete -F _{name} -o nosort -o bashdefault -o default {name}
                    else
                        complete -F _{name} -o bashdefault -o default {name}
                    fi
                    ",
                                name = bin_name,
                                cmd = fn_name,
                                name_opts = all_options_for_path(cmd, bin_name),
                                name_opts_details = option_details_for_path(cmd, bin_name),
                                subcmds = all_subcommands(cmd, &fn_name),
                                subcmd_details = subcommand_details(cmd)
                            ).expect("failed to write completion file");
                        }
                    }

                    fn all_subcommands(cmd: &Command, parent_fn_name: &str) -> String {
                        debug!("all_subcommands");

                        fn add_command(
                            parent_fn_name: &str,
                            cmd: &Command,
                            subcmds: &mut Vec<(String, String, String)>,
                        ) {
                            let fn_name = format!(
                                "{parent_fn_name}__{cmd_name}",
                                parent_fn_name = parent_fn_name,
                                cmd_name = cmd.get_name().to_string().replace('-', "__")
                            );
                            subcmds.push((
                                parent_fn_name.to_string(),
                                cmd.get_name().to_string(),
                                fn_name.clone(),
                            ));
                            for alias in cmd.get_visible_aliases() {
                                subcmds.push((
                                    parent_fn_name.to_string(),
                                    alias.to_string(),
                                    fn_name.clone(),
                                ));
                            }
                            for subcmd in cmd.get_subcommands() {
                                add_command(&fn_name, subcmd, subcmds);
                            }
                        }
                        let mut subcmds = vec![];
                        for subcmd in cmd.get_subcommands() {
                            add_command(parent_fn_name, subcmd, &mut subcmds);
                        }
                        subcmds.sort();

                        let mut cases = vec![String::new()];
                        for (parent_fn_name, name, fn_name) in subcmds {
                            cases.push(format!(
                                "{parent_fn_name},{name})
                                    cmd=\"{fn_name}\"
                                    ;;",
                            ));
                        }

                        cases.join("\n            ")
                    }

                    fn subcommand_details(cmd: &Command) -> String {
                        debug!("subcommand_details");

                        let mut subcmd_dets = vec![String::new()];
                        let mut scs = utils::all_subcommands(cmd)
                            .iter()
                            .map(|x| x.1.replace(' ', "__"))
                            .collect::<Vec<_>>();

                        scs.sort();
                        scs.dedup();

                        subcmd_dets.extend(scs.iter().map(|sc| {
                            format!(
                                "{subcmd})
                                opts=\"{sc_opts}\"
                                if [[ ${{cur}} == -* || ${{COMP_CWORD}} -eq {level} ]] ; then
                                    COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )
                                    return 0
                                fi
                                case \"${{prev}}\" in{opts_details}
                                    *)
                                        COMPREPLY=()
                                        ;;
                                esac
                                COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )
                                return 0
                                ;;",
                                subcmd = sc.replace('-', "__"),
                                sc_opts = all_options_for_path(cmd, sc),
                                level = sc.split("__").map(|_| 1).sum::<u64>(),
                                opts_details = option_details_for_path(cmd, sc)
                            )
                        }));

                        subcmd_dets.join("\n        ")
                    }

                    fn option_details_for_path(cmd: &Command, path: &str) -> String {
                        debug!("option_details_for_path: path={path}");

                        let p = utils::find_subcommand_with_path(cmd, path.split("__").skip(1).collect());
                        let mut opts = vec![String::new()];

                        for o in p.get_opts() {
                            let compopt = match o.get_value_hint() {
                                ValueHint::FilePath => Some("compopt -o filenames"),
                                ValueHint::DirPath => Some("compopt -o plusdirs"),
                                ValueHint::Other => Some("compopt -o nospace"),
                                _ => None,
                            };

                            if let Some(longs) = o.get_long_and_visible_aliases() {
                                opts.extend(longs.iter().map(|long| {
                                    let mut v = vec![format!("--{})", long)];

                                    if o.get_value_hint() == ValueHint::FilePath {
                                        v.extend([
                                            "local oldifs".to_string(),
                                            r#"if [ -n "${IFS+x}" ]; then"#.to_string(),
                                            r#"    oldifs="$IFS""#.to_string(),
                                            "fi".to_string(),
                                            r#"IFS=$'\n'"#.to_string(),
                                            format!("COMPREPLY=({})", vals_for(o)),
                                            r#"if [ -n "${oldifs+x}" ]; then"#.to_string(),
                                            r#"    IFS="$oldifs""#.to_string(),
                                            "fi".to_string(),
                                        ]);
                                    } else {
                                        v.push(format!("COMPREPLY=({})", vals_for(o)));
                                    }

                                    if let Some(copt) = compopt {
                                        v.extend([
                                            r#"if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then"#.to_string(),
                                            format!("    {copt}"),
                                            "fi".to_string(),
                                        ]);
                                    }

                                    v.extend(["return 0", ";;"].iter().map(|s| (*s).to_string()));
                                    v.join("\n                    ")
                                }));
                            }

                            if let Some(shorts) = o.get_short_and_visible_aliases() {
                                opts.extend(shorts.iter().map(|short| {
                                    let mut v = vec![format!("-{})", short)];

                                    if o.get_value_hint() == ValueHint::FilePath {
                                        v.extend([
                                            "local oldifs".to_string(),
                                            r#"if [ -n "${IFS+x}" ]; then"#.to_string(),
                                            r#"    oldifs="$IFS""#.to_string(),
                                            "fi".to_string(),
                                            r#"IFS=$'\n'"#.to_string(),
                                            format!("COMPREPLY=({})", vals_for(o)),
                                            r#"if [ -n "${oldifs+x}" ]; then"#.to_string(),
                                            r#"    IFS="$oldifs""#.to_string(),
                                            "fi".to_string(),
                                        ]);
                                    } else {
                                        v.push(format!("COMPREPLY=({})", vals_for(o)));
                                    }

                                    if let Some(copt) = compopt {
                                        v.extend([
                                            r#"if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then"#.to_string(),
                                            format!("    {copt}"),
                                            "fi".to_string(),
                                        ]);
                                    }

                                    v.extend(["return 0", ";;"].iter().map(|s| (*s).to_string()));
                                    v.join("\n                    ")
                                }));
                            }
                        }

                        opts.join("\n                ")
                    }

                    fn vals_for(o: &Arg) -> String {
                        debug!("vals_for: o={}", o.get_id());

                        if let Some(vals) = utils::possible_values(o) {
                            format!(
                                "$(compgen -W \"{}\" -- \"${{cur}}\")",
                                vals.iter()
                                    .filter(|pv| !pv.is_hide_set())
                                    .map(|n| n.get_name())
                                    .collect::<Vec<_>>()
                                    .join(" ")
                            )
                        } else if o.get_value_hint() == ValueHint::DirPath {
                            String::from("") // should be empty to avoid duplicate candidates
                        } else if o.get_value_hint() == ValueHint::Other {
                            String::from("\"${cur}\"")
                        } else {
                            String::from("$(compgen -f \"${cur}\")")
                        }
                    }

                    fn all_options_for_path(cmd: &Command, path: &str) -> String {
                        debug!("all_options_for_path: path={path}");

                        let p = utils::find_subcommand_with_path(cmd, path.split("__").skip(1).collect());

                        let mut opts = String::new();
                        for short in utils::shorts_and_visible_aliases(p) {
                            write!(&mut opts, "-{short} ").expect("writing to String is infallible");
                        }
                        for long in utils::longs_and_visible_aliases(p) {
                            write!(&mut opts, "--{long} ").expect("writing to String is infallible");
                        }
                        for pos in p.get_positionals() {
                            if let Some(vals) = utils::possible_values(pos) {
                                for value in vals {
                                    write!(&mut opts, "{} ", value.get_name())
                                        .expect("writing to String is infallible");
                                }
                            } else {
                                write!(&mut opts, "{pos} ").expect("writing to String is infallible");
                            }
                        }
                        for (sc, _) in utils::subcommands(p) {
                            write!(&mut opts, "{sc} ").expect("writing to String is infallible");
                        }
                        opts.pop();

                        opts
                    }
                }

                pub mod elvish
                {
                    use ::
                    {
                        *,
                    };
                    use std::io::Write;

                    use clap::builder::StyledStr;
                    use clap::Command;

                    use crate::generator::{utils, Generator};
                    use crate::INTERNAL_ERROR_MSG;

                    /// Generate elvish completion file
                    #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                    pub struct Elvish;

                    impl Generator for Elvish {
                        fn file_name(&self, name: &str) -> String {
                            format!("{name}.elv")
                        }

                        fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
                            let bin_name = cmd
                                .get_bin_name()
                                .expect("crate::generate should have set the bin_name");

                            let subcommands_cases = generate_inner(cmd, "");

                            write!(
                                buf,
                                r#"
                    use builtin;
                    use str;

                    set edit:completion:arg-completer[{bin_name}] = {{|@words|
                        fn spaces {{|n|
                            builtin:repeat $n ' ' | str:join ''
                        }}
                        fn cand {{|text desc|
                            edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
                        }}
                        var command = '{bin_name}'
                        for word $words[1..-1] {{
                            if (str:has-prefix $word '-') {{
                                break
                            }}
                            set command = $command';'$word
                        }}
                        var completions = [{subcommands_cases}
                        ]
                        $completions[$command]
                    }}
                    "#,
                            )
                            .expect("failed to write completion file");
                        }
                    }

                    // Escape string inside single quotes
                    fn escape_string(string: &str) -> String {
                        string.replace('\'', "''")
                    }

                    fn escape_help<T: ToString>(help: Option<&StyledStr>, data: T) -> String {
                        match help {
                            Some(help) => escape_string(&help.to_string().replace('\n', " ")),
                            _ => data.to_string(),
                        }
                    }

                    fn generate_inner(p: &Command, previous_command_name: &str) -> String {
                        debug!("generate_inner");

                        let command_names = if previous_command_name.is_empty() {
                            vec![p.get_bin_name().expect(INTERNAL_ERROR_MSG).to_string()]
                        } else {
                            p.get_name_and_visible_aliases()
                                .into_iter()
                                .map(|name| format!("{previous_command_name};{name}"))
                                .collect()
                        };

                        let mut completions = String::new();
                        let preamble = String::from("\n            cand ");

                        for option in p.get_opts() {
                            if let Some(shorts) = option.get_short_and_visible_aliases() {
                                let tooltip = escape_help(option.get_help(), shorts[0]);
                                for short in shorts {
                                    completions.push_str(&preamble);
                                    completions.push_str(format!("-{short} '{tooltip}'").as_str());
                                }
                            }

                            if let Some(longs) = option.get_long_and_visible_aliases() {
                                let tooltip = escape_help(option.get_help(), longs[0]);
                                for long in longs {
                                    completions.push_str(&preamble);
                                    completions.push_str(format!("--{long} '{tooltip}'").as_str());
                                }
                            }
                        }

                        for flag in utils::flags(p) {
                            if let Some(shorts) = flag.get_short_and_visible_aliases() {
                                let tooltip = escape_help(flag.get_help(), shorts[0]);
                                for short in shorts {
                                    completions.push_str(&preamble);
                                    completions.push_str(format!("-{short} '{tooltip}'").as_str());
                                }
                            }

                            if let Some(longs) = flag.get_long_and_visible_aliases() {
                                let tooltip = escape_help(flag.get_help(), longs[0]);
                                for long in longs {
                                    completions.push_str(&preamble);
                                    completions.push_str(format!("--{long} '{tooltip}'").as_str());
                                }
                            }
                        }

                        for subcommand in p.get_subcommands() {
                            for name in subcommand.get_name_and_visible_aliases() {
                                let tooltip = escape_help(subcommand.get_about(), name);

                                completions.push_str(&preamble);
                                completions.push_str(format!("{name} '{tooltip}'").as_str());
                            }
                        }

                        let mut subcommands_cases = String::new();
                        for command_name in &command_names {
                            subcommands_cases.push_str(&format!(
                                r"
                            &'{}'= {{{}
                            }}",
                                &command_name, completions
                            ));
                        }

                        for subcommand in p.get_subcommands() {
                            for command_name in &command_names {
                                let subcommand_subcommands_cases = generate_inner(subcommand, command_name);
                                subcommands_cases.push_str(&subcommand_subcommands_cases);
                            }
                        }

                        subcommands_cases
                    }
                }

                pub mod fish
                {
                    use ::
                    {
                        *,
                    };
                    use std::io::Write;

                    use clap::{builder, Arg, Command, ValueHint};

                    use crate::generator::{utils, Generator};
                    /// Generate fish completion file
                    ///
                    /// Note: The fish generator currently only supports named options (-o/--option), not positional arguments.
                    #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                    pub struct Fish;

                    impl Generator for Fish {
                        fn file_name(&self, name: &str) -> String {
                            format!("{name}.fish")
                        }

                        fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
                            let bin_name = cmd
                                .get_bin_name()
                                .expect("crate::generate should have set the bin_name");

                            let name = escape_name(bin_name);
                            let mut needs_fn_name = &format!("__fish_{name}_needs_command")[..];
                            let mut using_fn_name = &format!("__fish_{name}_using_subcommand")[..];
                            // Given `git --git-dir somedir status`, using `__fish_seen_subcommand_from` won't help us
                            // find out `status` is the real subcommand, and not `somedir`. However, when there are no subcommands,
                            // there is no need to use our custom stubs.
                            if cmd.has_subcommands() {
                                gen_subcommand_helpers(&name, cmd, buf, needs_fn_name, using_fn_name);
                            } else {
                                needs_fn_name = "__fish_use_subcommand";
                                using_fn_name = "__fish_seen_subcommand_from";
                            }

                            let mut buffer = String::new();
                            gen_fish_inner(
                                bin_name,
                                &[],
                                cmd,
                                &mut buffer,
                                needs_fn_name,
                                using_fn_name,
                            );
                            write!(buf, "{buffer}").expect("failed to write completion file");
                        }
                    }

                    // Escape string inside single quotes
                    fn escape_string(string: &str, escape_comma: bool) -> String {
                        let string = string.replace('\\', "\\\\").replace('\'', "\\'");
                        if escape_comma {
                            string.replace(',', "\\,")
                        } else {
                            string
                        }
                    }

                    fn escape_help(help: &builder::StyledStr) -> String {
                        escape_string(&help.to_string().replace('\n', " "), false)
                    }

                    fn escape_name(name: &str) -> String {
                        name.replace('-', "_")
                    }

                    fn gen_fish_inner(
                        root_command: &str,
                        parent_commands: &[&str],
                        cmd: &Command,
                        buffer: &mut String,
                        needs_fn_name: &str,
                        using_fn_name: &str,
                    ) {
                        debug!("gen_fish_inner");
                        // example :
                        //
                        // complete
                        //      -c {command}
                        //      -d "{description}"
                        //      -s {short}
                        //      -l {long}
                        //      -a "{possible_arguments}"
                        //      -r # if require parameter
                        //      -f # don't use file completion
                        //      -n "{needs_fn_name}"            # complete for command "myprog"
                        //      -n "{using_fn_name} subcmd1"    # complete for command "myprog subcmd1"

                        let mut basic_template = format!("complete -c {root_command}");

                        if parent_commands.is_empty() {
                            if cmd.has_subcommands() {
                                basic_template.push_str(&format!(" -n \"{needs_fn_name}\""));
                            }
                        } else {
                            let mut out = String::from(using_fn_name);
                            match parent_commands {
                                [] => unreachable!(),
                                [command] => {
                                    out.push_str(&format!(" {command}"));
                                    if cmd.has_subcommands() {
                                        out.push_str("; and not __fish_seen_subcommand_from");
                                    }
                                    let subcommands = cmd
                                        .get_subcommands()
                                        .flat_map(Command::get_name_and_visible_aliases);
                                    for name in subcommands {
                                        out.push_str(&format!(" {name}"));
                                    }
                                }
                                [command, subcommand] => out.push_str(&format!(
                                    " {command}; and __fish_seen_subcommand_from {subcommand}"
                                )),
                                // HACK: Assuming subcommands are only nested less than 3 levels as more than that is
                                // unwieldy and takes more effort to support.
                                // For example, `rustup toolchain help install` is the longest valid command line of `rustup`
                                // that uses nested subcommands, and it cannot receive any flags to it.
                                _ => return,
                            }
                            basic_template.push_str(format!(" -n \"{out}\"").as_str());
                        }

                        debug!("gen_fish_inner: parent_commands={parent_commands:?}");

                        for option in cmd.get_opts() {
                            let mut template = basic_template.clone();

                            if let Some(shorts) = option.get_short_and_visible_aliases() {
                                for short in shorts {
                                    template.push_str(format!(" -s {short}").as_str());
                                }
                            }

                            if let Some(longs) = option.get_long_and_visible_aliases() {
                                for long in longs {
                                    template.push_str(format!(" -l {}", escape_string(long, false)).as_str());
                                }
                            }

                            if let Some(data) = option.get_help() {
                                template.push_str(&format!(" -d '{}'", escape_help(data)));
                            }

                            template.push_str(value_completion(option).as_str());

                            buffer.push_str(template.as_str());
                            buffer.push('\n');
                        }

                        for flag in utils::flags(cmd) {
                            let mut template = basic_template.clone();

                            if let Some(shorts) = flag.get_short_and_visible_aliases() {
                                for short in shorts {
                                    template.push_str(format!(" -s {short}").as_str());
                                }
                            }

                            if let Some(longs) = flag.get_long_and_visible_aliases() {
                                for long in longs {
                                    template.push_str(format!(" -l {}", escape_string(long, false)).as_str());
                                }
                            }

                            if let Some(data) = flag.get_help() {
                                template.push_str(&format!(" -d '{}'", escape_help(data)));
                            }

                            buffer.push_str(template.as_str());
                            buffer.push('\n');
                        }

                        let has_positionals = cmd.get_positionals().next().is_some();
                        if !has_positionals {
                            basic_template.push_str(" -f");
                        }
                        for subcommand in cmd.get_subcommands() {
                            for subcommand_name in subcommand.get_name_and_visible_aliases() {
                                let mut template = basic_template.clone();

                                template.push_str(format!(" -a \"{subcommand_name}\"").as_str());

                                if let Some(data) = subcommand.get_about() {
                                    template.push_str(format!(" -d '{}'", escape_help(data)).as_str());
                                }

                                buffer.push_str(template.as_str());
                                buffer.push('\n');
                            }
                        }

                        // generate options of subcommands
                        for subcommand in cmd.get_subcommands() {
                            for subcommand_name in subcommand.get_name_and_visible_aliases() {
                                let mut parent_commands: Vec<_> = parent_commands.into();
                                parent_commands.push(subcommand_name);
                                gen_fish_inner(
                                    root_command,
                                    &parent_commands,
                                    subcommand,
                                    buffer,
                                    needs_fn_name,
                                    using_fn_name,
                                );
                            }
                        }
                    }
                    /// Print fish's helpers for easy handling subcommands.
                    fn gen_subcommand_helpers(
                        bin_name: &str,
                        cmd: &Command,
                        buf: &mut dyn Write,
                        needs_fn_name: &str,
                        using_fn_name: &str,
                    ) {
                        let mut optspecs = String::new();
                        let cmd_opts = cmd.get_arguments().filter(|a| !a.is_positional());
                        for option in cmd_opts {
                            optspecs.push(' ');
                            let mut has_short = false;
                            if let Some(short) = option.get_short() {
                                has_short = true;
                                optspecs.push(short);
                            }

                            if let Some(long) = option.get_long() {
                                if has_short {
                                    optspecs.push('/');
                                }
                                optspecs.push_str(&escape_string(long, false));
                            }

                            let is_an_option = option
                                .get_num_args()
                                .map(|r| r.takes_values())
                                .unwrap_or(true);
                            if is_an_option {
                                optspecs.push('=');
                            }
                        }
                        let optspecs_fn_name = format!("__fish_{bin_name}_global_optspecs");
                        write!(
                            buf,
                            "\
                            # Print an optspec for argparse to handle cmd's options that are independent of any subcommand.\n\
                            function {optspecs_fn_name}\n\
                            \tstring join \\n{optspecs}\n\
                            end\n\n\
                            function {needs_fn_name}\n\
                            \t# Figure out if the current invocation already has a command.\n\
                            \tset -l cmd (commandline -opc)\n\
                            \tset -e cmd[1]\n\
                            \targparse -s ({optspecs_fn_name}) -- $cmd 2>/dev/null\n\
                            \tor return\n\
                            \tif set -q argv[1]\n\
                            \t\t# Also print the command, so this can be used to figure out what it is.\n\
                            \t\techo $argv[1]\n\
                            \t\treturn 1\n\
                            \tend\n\
                            \treturn 0\n\
                            end\n\n\
                            function {using_fn_name}\n\
                            \tset -l cmd ({needs_fn_name})\n\
                            \ttest -z \"$cmd\"\n\
                            \tand return 1\n\
                            \tcontains -- $cmd[1] $argv\n\
                            end\n\n\
                        ").expect("failed to write completion file");
                    }

                    fn value_completion(option: &Arg) -> String {
                        if !option.get_num_args().expect("built").takes_values() {
                            return "".to_string();
                        }

                        if let Some(data) = utils::possible_values(option) {
                            // We return the possible values with their own empty description e.g. "a\t''\nb\t''"
                            // this makes sure that a and b don't get the description of the option or argument
                            format!(
                                " -r -f -a \"{}\"",
                                data.iter()
                                    .filter_map(|value| if value.is_hide_set() {
                                        None
                                    } else {
                                        // The help text after \t is wrapped in '' to make sure that the it is taken literally
                                        // and there is no command substitution or variable expansion resulting in unexpected errors
                                        Some(format!(
                                            "{}\\t'{}'",
                                            escape_string(value.get_name(), true).as_str(),
                                            escape_help(value.get_help().unwrap_or_default())
                                        ))
                                    })
                                    .collect::<Vec<_>>()
                                    .join("\n")
                            )
                        } else {
                            // NB! If you change this, please also update the table in `ValueHint` documentation.
                            match option.get_value_hint() {
                                ValueHint::Unknown => " -r",
                                // fish has no built-in support to distinguish these
                                ValueHint::AnyPath | ValueHint::FilePath | ValueHint::ExecutablePath => " -r -F",
                                ValueHint::DirPath => " -r -f -a \"(__fish_complete_directories)\"",
                                // It seems fish has no built-in support for completing command + arguments as
                                // single string (CommandString). Complete just the command name.
                                ValueHint::CommandString | ValueHint::CommandName => {
                                    " -r -f -a \"(__fish_complete_command)\""
                                }
                                ValueHint::Username => " -r -f -a \"(__fish_complete_users)\"",
                                ValueHint::Hostname => " -r -f -a \"(__fish_print_hostnames)\"",
                                // Disable completion for others
                                _ => " -r -f",
                            }
                            .to_string()
                        }
                    }
                }

                pub mod powershell
                {
                    use ::
                    {
                        *,
                    };
                    use std::io::Write;

                    use clap::builder::StyledStr;
                    use clap::{Arg, Command};

                    use crate::generator::{utils, Generator};
                    use crate::INTERNAL_ERROR_MSG;

                    /// Generate powershell completion file
                    #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                    pub struct PowerShell;

                    impl Generator for PowerShell {
                        fn file_name(&self, name: &str) -> String {
                            format!("_{name}.ps1")
                        }

                        fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
                            let bin_name = cmd
                                .get_bin_name()
                                .expect("crate::generate should have set the bin_name");

                            let subcommands_cases = generate_inner(cmd, "");

                            write!(
                                buf,
                                r#"
                    using namespace System.Management.Automation
                    using namespace System.Management.Automation.Language

                    Register-ArgumentCompleter -Native -CommandName '{bin_name}' -ScriptBlock {{
                        param($wordToComplete, $commandAst, $cursorPosition)

                        $commandElements = $commandAst.CommandElements
                        $command = @(
                            '{bin_name}'
                            for ($i = 1; $i -lt $commandElements.Count; $i++) {{
                                $element = $commandElements[$i]
                                if ($element -isnot [StringConstantExpressionAst] -or
                                    $element.StringConstantType -ne [StringConstantType]::BareWord -or
                                    $element.Value.StartsWith('-') -or
                                    $element.Value -eq $wordToComplete) {{
                                    break
                            }}
                            $element.Value
                        }}) -join ';'

                        $completions = @(switch ($command) {{{subcommands_cases}
                        }})

                        $completions.Where{{ $_.CompletionText -like "$wordToComplete*" }} |
                            Sort-Object -Property ListItemText
                    }}
                    "#
                            )
                            .expect("failed to write completion file");
                        }
                    }

                    // Escape string inside single quotes
                    fn escape_string(string: &str) -> String {
                        string.replace('\'', "''").replace('', "'")
                    }

                    fn escape_help<T: ToString>(help: Option<&StyledStr>, data: T) -> String {
                        if let Some(help) = help {
                            let help_str = help.to_string();
                            if !help_str.is_empty() {
                                return escape_string(&help_str.replace('\n', " "));
                            }
                        }
                        data.to_string()
                    }

                    fn generate_inner(p: &Command, previous_command_name: &str) -> String {
                        debug!("generate_inner");

                        let command_names = if previous_command_name.is_empty() {
                            vec![p.get_bin_name().expect(INTERNAL_ERROR_MSG).to_string()]
                        } else {
                            p.get_name_and_visible_aliases()
                                .into_iter()
                                .map(|name| format!("{previous_command_name};{name}"))
                                .collect()
                        };

                        let mut completions = String::new();
                        let preamble = String::from("\n            [CompletionResult]::new(");

                        for option in p.get_opts() {
                            generate_aliases(&mut completions, &preamble, option);
                        }

                        for flag in utils::flags(p) {
                            generate_aliases(&mut completions, &preamble, &flag);
                        }

                        for subcommand in p.get_subcommands() {
                            for name in subcommand.get_name_and_visible_aliases() {
                                let tooltip = escape_help(subcommand.get_about(), name);
                                completions.push_str(&preamble);
                                completions.push_str(&format!(
                                    "'{name}', '{name}', [CompletionResultType]::ParameterValue, '{tooltip}')"
                                ));
                            }
                        }

                        let mut subcommands_cases = String::new();
                        for command_name in &command_names {
                            subcommands_cases.push_str(&format!(
                                r"
                            '{command_name}' {{{completions}
                                break
                            }}"
                            ));
                        }

                        for subcommand in p.get_subcommands() {
                            for command_name in &command_names {
                                let subcommand_subcommands_cases = generate_inner(subcommand, command_name);
                                subcommands_cases.push_str(&subcommand_subcommands_cases);
                            }
                        }

                        subcommands_cases
                    }

                    fn generate_aliases(completions: &mut String, preamble: &String, arg: &Arg) {
                        use std::fmt::Write as _;

                        if let Some(aliases) = arg.get_short_and_visible_aliases() {
                            let tooltip = escape_help(arg.get_help(), aliases[0]);
                            for alias in aliases {
                                let _ = write!(
                                    completions,
                                    "{preamble}'-{alias}', '-{alias}{}', [CompletionResultType]::ParameterName, '{tooltip}')",
                                    // make PowerShell realize there is a difference between `-s` and `-S`
                                    if alias.is_uppercase() { " " } else { "" },
                                );
                            }
                        }
                        if let Some(aliases) = arg.get_long_and_visible_aliases() {
                            let tooltip = escape_help(arg.get_help(), aliases[0]);
                            for alias in aliases {
                                let _ = write!(
                                    completions,
                                    "{preamble}'--{alias}', '--{alias}', [CompletionResultType]::ParameterName, '{tooltip}')"
                                );
                            }
                        }
                    }
                }

                pub mod shell
                {
                    use ::
                    {
                        *,
                    };
                    use std::fmt::Display;
                    use std::path::Path;
                    use std::str::FromStr;

                    use clap::builder::PossibleValue;
                    use clap::ValueEnum;

                    use crate::shells;
                    use crate::Generator;

                    /// Shell with auto-generated completion script available.
                    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
                    #[non_exhaustive]
                    pub enum Shell {
                        /// Bourne Again `SHell` (bash)
                        Bash,
                        /// Elvish shell
                        Elvish,
                        /// Friendly Interactive `SHell` (fish)
                        Fish,
                        /// `PowerShell`
                        PowerShell,
                        /// Z `SHell` (zsh)
                        Zsh,
                    }

                    impl Display for Shell {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            self.to_possible_value()
                                .expect("no values are skipped")
                                .get_name()
                                .fmt(f)
                        }
                    }

                    impl FromStr for Shell {
                        type Err = String;

                        fn from_str(s: &str) -> Result<Self, Self::Err> {
                            for variant in Self::value_variants() {
                                if variant.to_possible_value().unwrap().matches(s, false) {
                                    return Ok(*variant);
                                }
                            }
                            Err(format!("invalid variant: {s}"))
                        }
                    }

                    // Hand-rolled so it can work even when `derive` feature is disabled
                    impl ValueEnum for Shell {
                        fn value_variants<'a>() -> &'a [Self] {
                            &[
                                Shell::Bash,
                                Shell::Elvish,
                                Shell::Fish,
                                Shell::PowerShell,
                                Shell::Zsh,
                            ]
                        }

                        fn to_possible_value(&self) -> Option<PossibleValue> {
                            Some(match self {
                                Shell::Bash => PossibleValue::new("bash"),
                                Shell::Elvish => PossibleValue::new("elvish"),
                                Shell::Fish => PossibleValue::new("fish"),
                                Shell::PowerShell => PossibleValue::new("powershell"),
                                Shell::Zsh => PossibleValue::new("zsh"),
                            })
                        }
                    }

                    impl Generator for Shell {
                        fn file_name(&self, name: &str) -> String {
                            match self {
                                Shell::Bash => shells::Bash.file_name(name),
                                Shell::Elvish => shells::Elvish.file_name(name),
                                Shell::Fish => shells::Fish.file_name(name),
                                Shell::PowerShell => shells::PowerShell.file_name(name),
                                Shell::Zsh => shells::Zsh.file_name(name),
                            }
                        }

                        fn generate(&self, cmd: &clap::Command, buf: &mut dyn std::io::Write) {
                            match self {
                                Shell::Bash => shells::Bash.generate(cmd, buf),
                                Shell::Elvish => shells::Elvish.generate(cmd, buf),
                                Shell::Fish => shells::Fish.generate(cmd, buf),
                                Shell::PowerShell => shells::PowerShell.generate(cmd, buf),
                                Shell::Zsh => shells::Zsh.generate(cmd, buf),
                            }
                        }
                    }

                    impl Shell {
                        /// Parse a shell from a path to the executable for the shell.
                        pub fn from_shell_path<P: AsRef<Path>>(path: P) -> Option<Shell> {
                            parse_shell_from_path(path.as_ref())
                        }

                        /// Determine the user's current shell from the environment.
                        pub fn from_env() -> Option<Shell> {
                            if let Some(env_shell) = std::env::var_os("SHELL") {
                                Shell::from_shell_path(env_shell)
                            } else if cfg!(windows) {
                                Some(Shell::PowerShell)
                            } else {
                                None
                            }
                        }
                    }
                    
                    fn parse_shell_from_path(path: &Path) -> Option<Shell> {
                        let name = path.file_stem()?.to_str()?;
                        match name {
                            "bash" => Some(Shell::Bash),
                            "zsh" => Some(Shell::Zsh),
                            "fish" => Some(Shell::Fish),
                            "elvish" => Some(Shell::Elvish),
                            "powershell" | "powershell_ise" => Some(Shell::PowerShell),
                            _ => None,
                        }
                    }
                }

                pub mod zsh
                {
                    use ::
                    {
                        *,
                    };
                    use std::io::Write;

                    use clap::{Arg, ArgAction, Command, ValueHint};

                    use crate::generator::{utils, Generator};
                    use crate::INTERNAL_ERROR_MSG;

                    /// Generate zsh completion file
                    #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                    pub struct Zsh;

                    impl Generator for Zsh {
                        fn file_name(&self, name: &str) -> String {
                            format!("_{name}")
                        }

                        fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
                            let bin_name = cmd
                                .get_bin_name()
                                .expect("crate::generate should have set the bin_name");

                            write!(
                                buf,
                                "#compdef {name}

                    autoload -U is-at-least

                    _{name}() {{
                        typeset -A opt_args
                        typeset -a _arguments_options
                        local ret=1

                        if is-at-least 5.2; then
                            _arguments_options=(-s -S -C)
                        else
                            _arguments_options=(-s -C)
                        fi

                        local context curcontext=\"$curcontext\" state line
                        {initial_args}{subcommands}
                    }}

                    {subcommand_details}

                    if [ \"$funcstack[1]\" = \"_{name}\" ]; then
                        _{name} \"$@\"
                    else
                        compdef _{name} {name}
                    fi
                    ",
                                name = bin_name,
                                initial_args = get_args_of(cmd, None),
                                subcommands = get_subcommands_of(cmd),
                                subcommand_details = subcommand_details(cmd)
                            )
                            .expect("failed to write completion file");
                        }
                    }

                    // Displays the commands of a subcommand
                    // (( $+functions[_[bin_name_underscore]_commands] )) ||
                    // _[bin_name_underscore]_commands() {
                    //     local commands; commands=(
                    //         '[arg_name]:[arg_help]'
                    //     )
                    //     _describe -t commands '[bin_name] commands' commands "$@"
                    //
                    // Where the following variables are present:
                    //    [bin_name_underscore]: The full space delineated bin_name, where spaces have been replaced by
                    //                           underscore characters
                    //    [arg_name]: The name of the subcommand
                    //    [arg_help]: The help message of the subcommand
                    //    [bin_name]: The full space delineated bin_name
                    //
                    // Here's a snippet from rustup:
                    //
                    // (( $+functions[_rustup_commands] )) ||
                    // _rustup_commands() {
                    //     local commands; commands=(
                    //      'show:Show the active and installed toolchains'
                    //      'update:Update Rust toolchains'
                    //      # ... snip for brevity
                    //      'help:Print this message or the help of the given subcommand(s)'
                    //     )
                    //     _describe -t commands 'rustup commands' commands "$@"
                    //
                    fn subcommand_details(p: &Command) -> String {
                        debug!("subcommand_details");

                        let bin_name = p
                            .get_bin_name()
                            .expect("crate::generate should have set the bin_name");

                        let mut ret = vec![];

                        // First we do ourself
                        let parent_text = format!(
                            "\
                    (( $+functions[_{bin_name_underscore}_commands] )) ||
                    _{bin_name_underscore}_commands() {{
                        local commands; commands=({subcommands_and_args})
                        _describe -t commands '{bin_name} commands' commands \"$@\"
                    }}",
                            bin_name_underscore = bin_name.replace(' ', "__"),
                            bin_name = bin_name,
                            subcommands_and_args = subcommands_of(p)
                        );
                        ret.push(parent_text);

                        // Next we start looping through all the children, grandchildren, etc.
                        let mut all_subcommand_bins: Vec<_> = utils::all_subcommands(p)
                            .into_iter()
                            .map(|(_sc_name, bin_name)| bin_name)
                            .collect();

                        all_subcommand_bins.sort();
                        all_subcommand_bins.dedup();

                        for bin_name in &all_subcommand_bins {
                            debug!("subcommand_details:iter: bin_name={bin_name}");

                            ret.push(format!(
                                "\
                    (( $+functions[_{bin_name_underscore}_commands] )) ||
                    _{bin_name_underscore}_commands() {{
                        local commands; commands=({subcommands_and_args})
                        _describe -t commands '{bin_name} commands' commands \"$@\"
                    }}",
                                bin_name_underscore = bin_name.replace(' ', "__"),
                                bin_name = bin_name,
                                subcommands_and_args =
                                    subcommands_of(parser_of(p, bin_name).expect(INTERNAL_ERROR_MSG))
                            ));
                        }

                        ret.join("\n")
                    }

                    // Generates subcommand completions in form of
                    //
                    //         '[arg_name]:[arg_help]'
                    //
                    // Where:
                    //    [arg_name]: the subcommand's name
                    //    [arg_help]: the help message of the subcommand
                    //
                    // A snippet from rustup:
                    //         'show:Show the active and installed toolchains'
                    //      'update:Update Rust toolchains'
                    fn subcommands_of(p: &Command) -> String {
                        debug!("subcommands_of");

                        let mut segments = vec![];

                        fn add_subcommands(subcommand: &Command, name: &str, ret: &mut Vec<String>) {
                            debug!("add_subcommands");

                            let text = format!(
                                "'{name}:{help}' \\",
                                name = name,
                                help = escape_help(&subcommand.get_about().unwrap_or_default().to_string())
                            );

                            ret.push(text);
                        }

                        // The subcommands
                        for command in p.get_subcommands() {
                            debug!("subcommands_of:iter: subcommand={}", command.get_name());

                            add_subcommands(command, command.get_name(), &mut segments);

                            for alias in command.get_visible_aliases() {
                                add_subcommands(command, alias, &mut segments);
                            }
                        }

                        // Surround the text with newlines for proper formatting.
                        // We need this to prevent weirdly formatted `command=(\n        \n)` sections.
                        // When there are no (sub-)commands.
                        if !segments.is_empty() {
                            segments.insert(0, "".to_string());
                            segments.push("    ".to_string());
                        }

                        segments.join("\n")
                    }

                    // Get's the subcommand section of a completion file
                    // This looks roughly like:
                    //
                    // case $state in
                    // ([bin_name]_args)
                    //     curcontext=\"${curcontext%:*:*}:[name_hyphen]-command-$words[1]:\"
                    //     case $line[1] in
                    //
                    //         ([name])
                    //         _arguments -C -s -S \
                    //             [subcommand_args]
                    //         && ret=0
                    //
                    //         [RECURSIVE_CALLS]
                    //
                    //         ;;",
                    //
                    //         [repeat]
                    //
                    //     esac
                    // ;;
                    // esac",
                    //
                    // Where the following variables are present:
                    //    [name] = The subcommand name in the form of "install" for "rustup toolchain install"
                    //    [bin_name] = The full space delineated bin_name such as "rustup toolchain install"
                    //    [name_hyphen] = The full space delineated bin_name, but replace spaces with hyphens
                    //    [repeat] = From the same recursive calls, but for all subcommands
                    //    [subcommand_args] = The same as zsh::get_args_of
                    fn get_subcommands_of(parent: &Command) -> String {
                        debug!(
                            "get_subcommands_of: Has subcommands...{:?}",
                            parent.has_subcommands()
                        );

                        if !parent.has_subcommands() {
                            return String::new();
                        }

                        let subcommand_names = utils::subcommands(parent);
                        let mut all_subcommands = vec![];

                        for (ref name, ref bin_name) in &subcommand_names {
                            debug!(
                                "get_subcommands_of:iter: parent={}, name={name}, bin_name={bin_name}",
                                parent.get_name(),
                            );
                            let mut segments = vec![format!("({name})")];
                            let subcommand_args = get_args_of(
                                parser_of(parent, bin_name).expect(INTERNAL_ERROR_MSG),
                                Some(parent),
                            );

                            if !subcommand_args.is_empty() {
                                segments.push(subcommand_args);
                            }

                            // Get the help text of all child subcommands.
                            let children = get_subcommands_of(parser_of(parent, bin_name).expect(INTERNAL_ERROR_MSG));

                            if !children.is_empty() {
                                segments.push(children);
                            }

                            segments.push(String::from(";;"));
                            all_subcommands.push(segments.join("\n"));
                        }

                        let parent_bin_name = parent
                            .get_bin_name()
                            .expect("crate::generate should have set the bin_name");

                        format!(
                            "
                        case $state in
                        ({name})
                            words=($line[{pos}] \"${{words[@]}}\")
                            (( CURRENT += 1 ))
                            curcontext=\"${{curcontext%:*:*}}:{name_hyphen}-command-$line[{pos}]:\"
                            case $line[{pos}] in
                                {subcommands}
                            esac
                        ;;
                    esac",
                            name = parent.get_name(),
                            name_hyphen = parent_bin_name.replace(' ', "-"),
                            subcommands = all_subcommands.join("\n"),
                            pos = parent.get_positionals().count() + 1
                        )
                    }

                    // Get the Command for a given subcommand tree.
                    //
                    // Given the bin_name "a b c" and the Command for "a" this returns the "c" Command.
                    // Given the bin_name "a b c" and the Command for "b" this returns the "c" Command.
                    fn parser_of<'cmd>(parent: &'cmd Command, bin_name: &str) -> Option<&'cmd Command> {
                        debug!("parser_of: p={}, bin_name={}", parent.get_name(), bin_name);

                        if bin_name == parent.get_bin_name().unwrap_or_default() {
                            return Some(parent);
                        }

                        for subcommand in parent.get_subcommands() {
                            if let Some(ret) = parser_of(subcommand, bin_name) {
                                return Some(ret);
                            }
                        }

                        None
                    }

                    // Writes out the args section, which ends up being the flags, opts and positionals, and a jump to
                    // another ZSH function if there are subcommands.
                    // The structure works like this:
                    //    ([conflicting_args]) [multiple] arg [takes_value] [[help]] [: :(possible_values)]
                    //       ^-- list '-v -h'    ^--'*'          ^--'+'                   ^-- list 'one two three'
                    //
                    // An example from the rustup command:
                    //
                    // _arguments -C -s -S \
                    //         '(-h --help --verbose)-v[Enable verbose output]' \
                    //         '(-V -v --version --verbose --help)-h[Print help information]' \
                    //      # ... snip for brevity
                    //         ':: :_rustup_commands' \    # <-- displays subcommands
                    //         '*::: :->rustup' \          # <-- displays subcommand args and child subcommands
                    //     && ret=0
                    //
                    // The args used for _arguments are as follows:
                    //    -C: modify the $context internal variable
                    //    -s: Allow stacking of short args (i.e. -a -b -c => -abc)
                    //    -S: Do not complete anything after '--' and treat those as argument values
                    fn get_args_of(parent: &Command, p_global: Option<&Command>) -> String {
                        debug!("get_args_of");

                        let mut segments = vec![String::from("_arguments \"${_arguments_options[@]}\" : \\")];
                        let opts = write_opts_of(parent, p_global);
                        let flags = write_flags_of(parent, p_global);
                        let positionals = write_positionals_of(parent);

                        if !opts.is_empty() {
                            segments.push(opts);
                        }

                        if !flags.is_empty() {
                            segments.push(flags);
                        }

                        if !positionals.is_empty() {
                            segments.push(positionals);
                        }

                        if parent.has_subcommands() {
                            let parent_bin_name = parent
                                .get_bin_name()
                                .expect("crate::generate should have set the bin_name");
                            let subcommand_bin_name = format!(
                                "\":: :_{name}_commands\" \\",
                                name = parent_bin_name.replace(' ', "__")
                            );
                            segments.push(subcommand_bin_name);

                            let subcommand_text = format!("\"*::: :->{name}\" \\", name = parent.get_name());
                            segments.push(subcommand_text);
                        };

                        segments.push(String::from("&& ret=0"));
                        segments.join("\n")
                    }

                    // Uses either `possible_vals` or `value_hint` to give hints about possible argument values
                    fn value_completion(arg: &Arg) -> Option<String> {
                        if let Some(values) = utils::possible_values(arg) {
                            if values
                                .iter()
                                .any(|value| !value.is_hide_set() && value.get_help().is_some())
                            {
                                Some(format!(
                                    "(({}))",
                                    values
                                        .iter()
                                        .filter_map(|value| {
                                            if value.is_hide_set() {
                                                None
                                            } else {
                                                Some(format!(
                                                    r#"{name}\:"{tooltip}""#,
                                                    name = escape_value(value.get_name()),
                                                    tooltip =
                                                        escape_help(&value.get_help().unwrap_or_default().to_string()),
                                                ))
                                            }
                                        })
                                        .collect::<Vec<_>>()
                                        .join("\n")
                                ))
                            } else {
                                Some(format!(
                                    "({})",
                                    values
                                        .iter()
                                        .filter(|pv| !pv.is_hide_set())
                                        .map(|n| n.get_name())
                                        .collect::<Vec<_>>()
                                        .join(" ")
                                ))
                            }
                        } else {
                            // NB! If you change this, please also update the table in `ValueHint` documentation.
                            Some(
                                match arg.get_value_hint() {
                                    ValueHint::Unknown => "_default",
                                    ValueHint::Other => "",
                                    ValueHint::AnyPath => "_files",
                                    ValueHint::FilePath => "_files",
                                    ValueHint::DirPath => "_files -/",
                                    ValueHint::ExecutablePath => "_absolute_command_paths",
                                    ValueHint::CommandName => "_command_names -e",
                                    ValueHint::CommandString => "_cmdstring",
                                    ValueHint::CommandWithArguments => "_cmdambivalent",
                                    ValueHint::Username => "_users",
                                    ValueHint::Hostname => "_hosts",
                                    ValueHint::Url => "_urls",
                                    ValueHint::EmailAddress => "_email_addresses",
                                    _ => {
                                        return None;
                                    }
                                }
                                .to_string(),
                            )
                        }
                    }
                    /// Escape help string inside single quotes and brackets
                    fn escape_help(string: &str) -> String {
                        string
                            .replace('\\', "\\\\")
                            .replace('\'', "'\\''")
                            .replace('[', "\\[")
                            .replace(']', "\\]")
                            .replace(':', "\\:")
                            .replace('$', "\\$")
                            .replace('`', "\\`")
                            .replace('\n', " ")
                    }
                    /// Escape value string inside single quotes and parentheses
                    fn escape_value(string: &str) -> String {
                        string
                            .replace('\\', "\\\\")
                            .replace('\'', "'\\''")
                            .replace('[', "\\[")
                            .replace(']', "\\]")
                            .replace(':', "\\:")
                            .replace('$', "\\$")
                            .replace('`', "\\`")
                            .replace('(', "\\(")
                            .replace(')', "\\)")
                            .replace(' ', "\\ ")
                    }

                    fn write_opts_of(p: &Command, p_global: Option<&Command>) -> String {
                        debug!("write_opts_of");

                        let mut ret = vec![];

                        for o in p.get_opts() {
                            debug!("write_opts_of:iter: o={}", o.get_id());

                            let help = escape_help(&o.get_help().unwrap_or_default().to_string());
                            let conflicts = arg_conflicts(p, o, p_global);

                            let multiple = if let ArgAction::Count | ArgAction::Append = o.get_action() {
                                "*"
                            } else {
                                ""
                            };

                            let vn = match o.get_value_names() {
                                None => " ".to_string(),
                                Some(val) => val[0].to_string(),
                            };
                            let vc = match value_completion(o) {
                                Some(val) => format!(":{vn}:{val}"),
                                None => format!(":{vn}: "),
                            };
                            let vc = vc.repeat(o.get_num_args().expect("built").min_values());

                            if let Some(shorts) = o.get_short_and_visible_aliases() {
                                for short in shorts {
                                    let s = format!("'{conflicts}{multiple}-{short}+[{help}]{vc}' \\");

                                    debug!("write_opts_of:iter: Wrote...{}", &*s);
                                    ret.push(s);
                                }
                            }
                            if let Some(longs) = o.get_long_and_visible_aliases() {
                                for long in longs {
                                    let l = format!("'{conflicts}{multiple}--{long}=[{help}]{vc}' \\");

                                    debug!("write_opts_of:iter: Wrote...{}", &*l);
                                    ret.push(l);
                                }
                            }
                        }

                        ret.join("\n")
                    }

                    fn arg_conflicts(cmd: &Command, arg: &Arg, app_global: Option<&Command>) -> String {
                        fn push_conflicts(conflicts: &[&Arg], res: &mut Vec<String>) {
                            for conflict in conflicts {
                                if let Some(s) = conflict.get_short() {
                                    res.push(format!("-{s}"));
                                }

                                if let Some(l) = conflict.get_long() {
                                    res.push(format!("--{l}"));
                                }
                            }
                        }

                        let mut res = vec![];
                        match (app_global, arg.is_global_set()) {
                            (Some(x), true) => {
                                let conflicts = x.get_arg_conflicts_with(arg);

                                if conflicts.is_empty() {
                                    return String::new();
                                }

                                push_conflicts(&conflicts, &mut res);
                            }
                            (_, _) => {
                                let conflicts = cmd.get_arg_conflicts_with(arg);

                                if conflicts.is_empty() {
                                    return String::new();
                                }

                                push_conflicts(&conflicts, &mut res);
                            }
                        };

                        format!("({})", res.join(" "))
                    }

                    fn write_flags_of(p: &Command, p_global: Option<&Command>) -> String {
                        debug!("write_flags_of;");

                        let mut ret = vec![];

                        for f in utils::flags(p) {
                            debug!("write_flags_of:iter: f={}", f.get_id());

                            let help = escape_help(&f.get_help().unwrap_or_default().to_string());
                            let conflicts = arg_conflicts(p, &f, p_global);

                            let multiple = if let ArgAction::Count | ArgAction::Append = f.get_action() {
                                "*"
                            } else {
                                ""
                            };

                            if let Some(short) = f.get_short() {
                                let s = format!("'{conflicts}{multiple}-{short}[{help}]' \\");

                                debug!("write_flags_of:iter: Wrote...{}", &*s);

                                ret.push(s);

                                if let Some(short_aliases) = f.get_visible_short_aliases() {
                                    for alias in short_aliases {
                                        let s = format!("'{conflicts}{multiple}-{alias}[{help}]' \\",);

                                        debug!("write_flags_of:iter: Wrote...{}", &*s);

                                        ret.push(s);
                                    }
                                }
                            }

                            if let Some(long) = f.get_long() {
                                let l = format!("'{conflicts}{multiple}--{long}[{help}]' \\");

                                debug!("write_flags_of:iter: Wrote...{}", &*l);

                                ret.push(l);

                                if let Some(aliases) = f.get_visible_aliases() {
                                    for alias in aliases {
                                        let l = format!("'{conflicts}{multiple}--{alias}[{help}]' \\");

                                        debug!("write_flags_of:iter: Wrote...{}", &*l);

                                        ret.push(l);
                                    }
                                }
                            }
                        }

                        ret.join("\n")
                    }

                    fn write_positionals_of(p: &Command) -> String {
                        debug!("write_positionals_of;");

                        let mut ret = vec![];

                        // Completions for commands that end with two Vec arguments require special care.
                        // - You can have two Vec args separated with a custom value terminator.
                        // - You can have two Vec args with the second one set to last (raw sets last)
                        //   which will require a '--' separator to be used before the second argument
                        //   on the command-line.
                        //
                        // We use the '-S' _arguments option to disable completion after '--'. Thus, the
                        // completion for the second argument in scenario (B) does not need to be emitted
                        // because it is implicitly handled by the '-S' option.
                        // We only need to emit the first catch-all.
                        //
                        // Have we already emitted a catch-all multi-valued positional argument
                        // without a custom value terminator?
                        let mut catch_all_emitted = false;

                        for arg in p.get_positionals() {
                            debug!("write_positionals_of:iter: arg={}", arg.get_id());

                            let num_args = arg.get_num_args().expect("built");
                            let is_multi_valued = num_args.max_values() > 1;

                            if catch_all_emitted && (arg.is_last_set() || is_multi_valued) {
                                // This is the final argument and it also takes multiple arguments.
                                // We've already emitted a catch-all positional argument so we don't need
                                // to emit anything for this argument because it is implicitly handled by
                                // the use of the '-S' _arguments option.
                                continue;
                            }

                            let cardinality_value;
                            // If we have any subcommands, we'll emit a catch-all argument, so we shouldn't
                            // emit one here.
                            let cardinality = if is_multi_valued && !p.has_subcommands() {
                                match arg.get_value_terminator() {
                                    Some(terminator) => {
                                        cardinality_value = format!("*{}:", escape_value(terminator));
                                        cardinality_value.as_str()
                                    }
                                    None => {
                                        catch_all_emitted = true;
                                        "*:"
                                    }
                                }
                            } else if !arg.is_required_set() {
                                ":"
                            } else {
                                ""
                            };

                            let a = format!(
                                "'{cardinality}:{name}{help}:{value_completion}' \\",
                                cardinality = cardinality,
                                name = arg.get_id(),
                                help = arg
                                    .get_help()
                                    .map(|s| s.to_string())
                                    .map(|v| " -- ".to_owned() + &v)
                                    .unwrap_or_else(|| "".to_owned())
                                    .replace('[', "\\[")
                                    .replace(']', "\\]")
                                    .replace('\'', "'\\''")
                                    .replace(':', "\\:"),
                                value_completion = value_completion(arg).unwrap_or_default()
                            );

                            debug!("write_positionals_of:iter: Wrote...{a}");

                            ret.push(a);
                        }

                        ret.join("\n")
                    }
                }
                
                pub use bash::Bash;
                pub use elvish::Elvish;
                pub use fish::Fish;
                pub use powershell::PowerShell;
                pub use shell::Shell;
                pub use zsh::Zsh;
            }


            pub use clap::ValueHint;
            pub use generator::*;
            pub use shells::*;
        }
        #[cfg(feature = "unstable-dynamic")]
        pub mod engine
        {
            //! `clap`-native completion system
            use ::
            {
                *,
            };

            pub mod candidate
            {
                use ::
                {
                    *,
                };
                use std::ffi::OsStr;
                use std::ffi::OsString;

                use clap::builder::StyledStr;

                /// A shell-agnostic completion candidate
                #[derive(Default, Debug, PartialEq, Eq, PartialOrd, Ord)]
                pub struct CompletionCandidate {
                    value: OsString,
                    help: Option<StyledStr>,
                    id: Option<String>,
                    tag: Option<StyledStr>,
                    display_order: Option<usize>,
                    hidden: bool,
                }

                impl CompletionCandidate {
                    /// Create a new completion candidate
                    pub fn new(value: impl Into<OsString>) -> Self {
                        let value = value.into();
                        Self {
                            value,
                            ..Default::default()
                        }
                    }
                    /// Set the help message of the completion candidate
                    pub fn help(mut self, help: Option<StyledStr>) -> Self {
                        self.help = help;
                        self
                    }
                    /// Only first for a given Id is shown
                    ///
                    /// To reduce the risk of conflicts, this should likely contain a namespace.
                    pub fn id(mut self, id: Option<String>) -> Self {
                        self.id = id;
                        self
                    }
                    /// Group candidates by tag
                    ///
                    /// Future: these may become user-visible
                    pub fn tag(mut self, tag: Option<StyledStr>) -> Self {
                        self.tag = tag;
                        self
                    }
                    /// Sort weight within a [`CompletionCandidate::tag`]
                    pub fn display_order(mut self, order: Option<usize>) -> Self {
                        self.display_order = order;
                        self
                    }
                    /// Set the visibility of the completion candidate
                    ///
                    /// Only shown when there is no visible candidate for completing the current argument.
                    pub fn hide(mut self, hidden: bool) -> Self {
                        self.hidden = hidden;
                        self
                    }
                    /// Add a prefix to the value of completion candidate
                    ///
                    /// This is generally used for post-process by [`complete`][crate::engine::complete()] for
                    /// things like pre-pending flags, merging delimiter-separated values, etc.
                    pub fn add_prefix(mut self, prefix: impl Into<OsString>) -> Self {
                        let suffix = self.value;
                        let mut value = prefix.into();
                        value.push(&suffix);
                        self.value = value;
                        self
                    }
                }
                /// Reflection API
                impl CompletionCandidate {
                    /// Get the literal value being proposed for completion
                    pub fn get_value(&self) -> &OsStr {
                        &self.value
                    }
                    /// Get the help message of the completion candidate
                    pub fn get_help(&self) -> Option<&StyledStr> {
                        self.help.as_ref()
                    }
                    /// Get the id used for de-duplicating
                    pub fn get_id(&self) -> Option<&String> {
                        self.id.as_ref()
                    }
                    /// Get the grouping tag
                    pub fn get_tag(&self) -> Option<&StyledStr> {
                        self.tag.as_ref()
                    }
                    /// Get the grouping tag
                    pub fn get_display_order(&self) -> Option<usize> {
                        self.display_order
                    }
                    /// Get the visibility of the completion candidate
                    pub fn is_hide_set(&self) -> bool {
                        self.hidden
                    }
                }

                impl<S: Into<OsString>> From<S> for CompletionCandidate {
                    fn from(s: S) -> Self {
                        CompletionCandidate::new(s.into())
                    }
                }
            }

            pub mod complete
            {
                use ::
                {
                    *,
                };
                use std::ffi::OsStr;
                use std::ffi::OsString;

                use clap_lex::OsStrExt as _;

                use super::custom::complete_path;
                use super::ArgValueCandidates;
                use super::ArgValueCompleter;
                use super::CompletionCandidate;
                use super::SubcommandCandidates;

                /// Complete the given command, shell-agnostic
                pub fn complete(
                    cmd: &mut clap::Command,
                    args: Vec<OsString>,
                    arg_index: usize,
                    current_dir: Option<&std::path::Path>,
                ) -> Result<Vec<CompletionCandidate>, std::io::Error> {
                    debug!("complete: args={args:?}, arg_index={arg_index:?}, current_dir={current_dir:?}");
                    cmd.build();

                    let raw_args = clap_lex::RawArgs::new(args);
                    let mut cursor = raw_args.cursor();
                    let mut target_cursor = raw_args.cursor();
                    raw_args.seek(
                        &mut target_cursor,
                        clap_lex::SeekFrom::Start(arg_index as u64),
                    );
                    // As we loop, `cursor` will always be pointing to the next item
                    raw_args.next_os(&mut target_cursor);
                    debug!("complete: target_cursor={target_cursor:?}");

                    // TODO: Multicall support
                    if !cmd.is_no_binary_name_set() {
                        raw_args.next_os(&mut cursor);
                    }

                    let mut current_cmd = &*cmd;
                    let mut pos_index = 1;
                    let mut is_escaped = false;
                    let mut next_state = ParseState::ValueDone;
                    while let Some(arg) = raw_args.next(&mut cursor) {
                        let current_state = next_state;
                        next_state = ParseState::ValueDone;
                        debug!(
                            "complete::next: arg={:?}, current_state={current_state:?}, cursor={cursor:?}",
                            arg.to_value_os(),
                        );
                        if cursor == target_cursor {
                            return complete_arg(&arg, current_cmd, current_dir, pos_index, current_state);
                        }

                        if let Ok(value) = arg.to_value() {
                            if let Some(next_cmd) = current_cmd.find_subcommand(value) {
                                current_cmd = next_cmd;
                                pos_index = 1;
                                continue;
                            }
                        }

                        if is_escaped {
                            (next_state, pos_index) =
                                parse_positional(current_cmd, pos_index, is_escaped, current_state);
                        } else if arg.is_escape() {
                            is_escaped = true;
                        } else if opt_allows_hyphen(&current_state, &arg) {
                            match current_state {
                                ParseState::Opt((opt, count)) => next_state = parse_opt_value(opt, count),
                                _ => unreachable!("else branch is only reachable in Opt state"),
                            }
                        } else if let Some((flag, value)) = arg.to_long() {
                            if let Ok(flag) = flag {
                                let opt = current_cmd.get_arguments().find(|a| {
                                    let longs = a.get_long_and_visible_aliases();
                                    let is_find = longs.map(|v| {
                                        let mut iter = v.into_iter();
                                        let s = iter.find(|s| *s == flag);
                                        s.is_some()
                                    });
                                    is_find.unwrap_or(false)
                                });

                                if let Some(opt) = opt {
                                    if opt.get_num_args().expect("built").takes_values() && value.is_none() {
                                        next_state = ParseState::Opt((opt, 1));
                                    };
                                } else if pos_allows_hyphen(current_cmd, pos_index) {
                                    (next_state, pos_index) =
                                        parse_positional(current_cmd, pos_index, is_escaped, current_state);
                                }
                            }
                        } else if let Some(short) = arg.to_short() {
                            let (_, takes_value_opt, mut short) = parse_shortflags(current_cmd, short);
                            if let Some(opt) = takes_value_opt {
                                if short.next_value_os().is_none() {
                                    next_state = ParseState::Opt((opt, 1));
                                }
                            } else if pos_allows_hyphen(current_cmd, pos_index) {
                                (next_state, pos_index) =
                                    parse_positional(current_cmd, pos_index, is_escaped, current_state);
                            }
                        } else {
                            match current_state {
                                ParseState::ValueDone | ParseState::Pos(..) => {
                                    (next_state, pos_index) =
                                        parse_positional(current_cmd, pos_index, is_escaped, current_state);
                                }
                                ParseState::Opt((opt, count)) => next_state = parse_opt_value(opt, count),
                            }
                        }
                    }

                    Err(std::io::Error::new(
                        std::io::ErrorKind::Other,
                        "no completion generated",
                    ))
                }

                #[derive(Debug, PartialEq, Eq, Clone)]
                enum ParseState<'a> {
                    /// Parsing a value done, there is no state to record.
                    ValueDone,

                    /// Parsing a positional argument after `--`. `Pos(pos_index`, `takes_num_args`)
                    Pos((usize, usize)),

                    /// Parsing a optional flag argument
                    Opt((&'a clap::Arg, usize)),
                }

                fn complete_arg(
                    arg: &clap_lex::ParsedArg<'_>,
                    cmd: &clap::Command,
                    current_dir: Option<&std::path::Path>,
                    pos_index: usize,
                    state: ParseState<'_>,
                ) -> Result<Vec<CompletionCandidate>, std::io::Error> {
                    debug!(
                        "complete_arg: arg={:?}, cmd={:?}, current_dir={:?}, pos_index={:?}, state={:?}",
                        arg,
                        cmd.get_name(),
                        current_dir,
                        pos_index,
                        state
                    );
                    let mut completions = Vec::<CompletionCandidate>::new();

                    match state {
                        ParseState::ValueDone => {
                            if let Ok(value) = arg.to_value() {
                                completions.extend(complete_subcommand(value, cmd));
                            }

                            if let Some(positional) = cmd
                                .get_positionals()
                                .find(|p| p.get_index() == Some(pos_index))
                            {
                                completions.extend(complete_arg_value(arg.to_value(), positional, current_dir));
                            }
                            completions.extend(complete_option(arg, cmd, current_dir));
                        }
                        ParseState::Pos((_, num_arg)) => {
                            if let Some(positional) = cmd
                                .get_positionals()
                                .find(|p| p.get_index() == Some(pos_index))
                            {
                                completions.extend(complete_arg_value(arg.to_value(), positional, current_dir));
                                if positional
                                    .get_num_args()
                                    .is_some_and(|num_args| num_arg >= num_args.min_values())
                                {
                                    completions.extend(complete_option(arg, cmd, current_dir));
                                }
                            }
                        }
                        ParseState::Opt((opt, count)) => {
                            completions.extend(complete_arg_value(arg.to_value(), opt, current_dir));
                            let min = opt.get_num_args().map(|r| r.min_values()).unwrap_or(0);
                            if count > min {
                                // Also complete this raw_arg as a positional argument, flags, options and subcommand.
                                completions.extend(complete_arg(
                                    arg,
                                    cmd,
                                    current_dir,
                                    pos_index,
                                    ParseState::ValueDone,
                                )?);
                            }
                        }
                    }
                    if completions.iter().any(|a| !a.is_hide_set()) {
                        completions.retain(|a| !a.is_hide_set());
                    }
                    let mut seen_ids = std::collections::HashSet::new();
                    completions.retain(move |a| {
                        if let Some(id) = a.get_id().cloned() {
                            seen_ids.insert(id)
                        } else {
                            true
                        }
                    });

                    let mut tags = Vec::new();
                    for candidate in &completions {
                        let tag = candidate.get_tag().cloned();
                        if !tags.contains(&tag) {
                            tags.push(tag);
                        }
                    }
                    completions.sort_by_key(|c| {
                        (
                            tags.iter().position(|t| c.get_tag() == t.as_ref()),
                            c.get_display_order(),
                        )
                    });

                    Ok(completions)
                }

                fn complete_option(
                    arg: &clap_lex::ParsedArg<'_>,
                    cmd: &clap::Command,
                    current_dir: Option<&std::path::Path>,
                ) -> Vec<CompletionCandidate> {
                    let mut completions = Vec::<CompletionCandidate>::new();
                    if arg.is_empty() {
                        completions.extend(longs_and_visible_aliases(cmd));
                        completions.extend(hidden_longs_aliases(cmd));

                        let dash_or_arg = if arg.is_empty() {
                            "-".into()
                        } else {
                            arg.to_value_os().to_string_lossy()
                        };
                        completions.extend(
                            shorts_and_visible_aliases(cmd)
                                .into_iter()
                                .map(|comp| comp.add_prefix(dash_or_arg.to_string())),
                        );
                    } else if arg.is_stdio() {
                        // HACK: Assuming knowledge of is_stdio
                        let dash_or_arg = if arg.is_empty() {
                            "-".into()
                        } else {
                            arg.to_value_os().to_string_lossy()
                        };
                        completions.extend(
                            shorts_and_visible_aliases(cmd)
                                .into_iter()
                                .map(|comp| comp.add_prefix(dash_or_arg.to_string())),
                        );

                        completions.extend(longs_and_visible_aliases(cmd));
                        completions.extend(hidden_longs_aliases(cmd));
                    } else if arg.is_escape() {
                        // HACK: Assuming knowledge of is_escape
                        completions.extend(longs_and_visible_aliases(cmd));
                        completions.extend(hidden_longs_aliases(cmd));
                    } else if let Some((flag, value)) = arg.to_long() {
                        if let Ok(flag) = flag {
                            if let Some(value) = value {
                                if let Some(arg) = cmd.get_arguments().find(|a| a.get_long() == Some(flag)) {
                                    completions.extend(
                                        complete_arg_value(value.to_str().ok_or(value), arg, current_dir)
                                            .into_iter()
                                            .map(|comp| comp.add_prefix(format!("--{flag}="))),
                                    );
                                }
                            } else {
                                completions.extend(
                                    longs_and_visible_aliases(cmd)
                                        .into_iter()
                                        .filter(|comp| comp.get_value().starts_with(format!("--{flag}").as_str())),
                                );
                                completions.extend(
                                    hidden_longs_aliases(cmd)
                                        .into_iter()
                                        .filter(|comp| comp.get_value().starts_with(format!("--{flag}").as_str())),
                                );
                            }
                        }
                    } else if let Some(short) = arg.to_short() {
                        if !short.is_negative_number() {
                            // Find the first takes_values option.
                            let (leading_flags, takes_value_opt, mut short) = parse_shortflags(cmd, short);

                            // Clone `short` to `peek_short` to peek whether the next flag is a `=`.
                            if let Some(opt) = takes_value_opt {
                                let mut peek_short = short.clone();
                                let has_equal = if let Some(Ok('=')) = peek_short.next_flag() {
                                    short.next_flag();
                                    true
                                } else {
                                    false
                                };

                                let value = short.next_value_os().unwrap_or(OsStr::new(""));
                                completions.extend(
                                    complete_arg_value(value.to_str().ok_or(value), opt, current_dir)
                                        .into_iter()
                                        .map(|comp| {
                                            let sep = if has_equal { "=" } else { "" };
                                            comp.add_prefix(format!("-{leading_flags}{sep}"))
                                        }),
                                );
                            } else {
                                completions.extend(
                                    shorts_and_visible_aliases(cmd)
                                        .into_iter()
                                        .map(|comp| comp.add_prefix(format!("-{leading_flags}"))),
                                );
                            }
                        }
                    }
                    completions
                }

                fn complete_arg_value(
                    value: Result<&str, &OsStr>,
                    arg: &clap::Arg,
                    current_dir: Option<&std::path::Path>,
                ) -> Vec<CompletionCandidate> {
                    let mut values = Vec::new();
                    debug!("complete_arg_value: arg={arg:?}, value={value:?}");

                    let (prefix, value) =
                        rsplit_delimiter(value, arg.get_value_delimiter()).unwrap_or((None, value));

                    let value_os = match value {
                        Ok(value) => OsStr::new(value),
                        Err(value_os) => value_os,
                    };

                    if let Some(completer) = arg.get::<ArgValueCompleter>() {
                        values.extend(completer.complete(value_os));
                    } else if let Some(completer) = arg.get::<ArgValueCandidates>() {
                        values.extend(complete_custom_arg_value(value_os, completer));
                    } else if let Some(possible_values) = possible_values(arg) {
                        if let Ok(value) = value {
                            values.extend(possible_values.into_iter().filter_map(|p| {
                                let name = p.get_name();
                                name.starts_with(value).then(|| {
                                    CompletionCandidate::new(OsString::from(name))
                                        .help(p.get_help().cloned())
                                        .hide(p.is_hide_set())
                                })
                            }));
                        }
                    } else {
                        match arg.get_value_hint() {
                            clap::ValueHint::Unknown | clap::ValueHint::Other => {
                                // Should not complete
                            }
                            clap::ValueHint::AnyPath => {
                                values.extend(complete_path(value_os, current_dir, &|_| true));
                            }
                            clap::ValueHint::FilePath => {
                                values.extend(complete_path(value_os, current_dir, &|p| p.is_file()));
                            }
                            clap::ValueHint::DirPath => {
                                values.extend(complete_path(value_os, current_dir, &|p| p.is_dir()));
                            }
                            clap::ValueHint::ExecutablePath => {
                                use is_executable::IsExecutable;
                                values.extend(complete_path(value_os, current_dir, &|p| p.is_executable()));
                            }
                            clap::ValueHint::CommandName
                            | clap::ValueHint::CommandString
                            | clap::ValueHint::CommandWithArguments
                            | clap::ValueHint::Username
                            | clap::ValueHint::Hostname
                            | clap::ValueHint::Url
                            | clap::ValueHint::EmailAddress => {
                                // No completion implementation
                            }
                            _ => {
                                // Safe-ish fallback
                                values.extend(complete_path(value_os, current_dir, &|_| true));
                            }
                        }

                        values.sort();
                    }

                    if let Some(prefix) = prefix {
                        values = values
                            .into_iter()
                            .map(|comp| comp.add_prefix(prefix))
                            .collect();
                    }
                    values = values
                        .into_iter()
                        .map(|comp| {
                            if comp.get_tag().is_some() {
                                comp
                            } else {
                                comp.tag(Some(arg.to_string().into()))
                            }
                        })
                        .collect();

                    values
                }

                fn rsplit_delimiter<'s, 'o>(
                    value: Result<&'s str, &'o OsStr>,
                    delimiter: Option<char>,
                ) -> Option<(Option<&'s str>, Result<&'s str, &'o OsStr>)> {
                    let delimiter = delimiter?;
                    let value = value.ok()?;
                    let pos = value.rfind(delimiter)?;
                    let (prefix, value) = value.split_at(pos + delimiter.len_utf8());
                    Some((Some(prefix), Ok(value)))
                }

                fn complete_custom_arg_value(
                    value: &OsStr,
                    completer: &ArgValueCandidates,
                ) -> Vec<CompletionCandidate> {
                    debug!("complete_custom_arg_value: completer={completer:?}, value={value:?}");

                    let mut values = completer.candidates();
                    values.retain(|comp| comp.get_value().starts_with(&value.to_string_lossy()));
                    values
                }

                fn complete_subcommand(value: &str, cmd: &clap::Command) -> Vec<CompletionCandidate> {
                    debug!(
                        "complete_subcommand: cmd={:?}, value={:?}",
                        cmd.get_name(),
                        value
                    );

                    let mut scs: Vec<CompletionCandidate> = subcommands(cmd)
                        .into_iter()
                        .filter(|x| x.get_value().starts_with(value))
                        .collect();
                    if cmd.is_allow_external_subcommands_set() {
                        let external_completer = cmd.get::<SubcommandCandidates>();
                        if let Some(completer) = external_completer {
                            scs.extend(complete_external_subcommand(value, completer));
                        }
                    }

                    scs.sort();
                    scs.dedup();
                    scs
                }

                fn complete_external_subcommand(
                    value: &str,
                    completer: &SubcommandCandidates,
                ) -> Vec<CompletionCandidate> {
                    debug!("complete_custom_arg_value: completer={completer:?}, value={value:?}");

                    let mut values = Vec::new();
                    let custom_arg_values = completer.candidates();
                    values.extend(custom_arg_values);

                    values.retain(|comp| comp.get_value().starts_with(value));

                    values
                }
                /// Gets all the long options, their visible aliases and flags of a [`clap::Command`] with formatted `--` prefix.
                /// Includes `help` and `version` depending on the [`clap::Command`] settings.
                fn longs_and_visible_aliases(p: &clap::Command) -> Vec<CompletionCandidate> {
                    debug!("longs: name={}", p.get_name());

                    p.get_arguments()
                        .filter_map(|a| {
                            a.get_long_and_visible_aliases().map(|longs| {
                                longs
                                    .into_iter()
                                    .map(|s| populate_arg_candidate(CompletionCandidate::new(format!("--{s}")), a))
                            })
                        })
                        .flatten()
                        .collect()
                }
                /// Gets all the long hidden aliases and flags of a [`clap::Command`].
                fn hidden_longs_aliases(p: &clap::Command) -> Vec<CompletionCandidate> {
                    debug!("longs: name={}", p.get_name());

                    p.get_arguments()
                        .filter_map(|a| {
                            a.get_aliases().map(|longs| {
                                longs.into_iter().map(|s| {
                                    populate_arg_candidate(CompletionCandidate::new(format!("--{s}")), a).hide(true)
                                })
                            })
                        })
                        .flatten()
                        .collect()
                }
                /// Gets all the short options, their visible aliases and flags of a [`clap::Command`].
                /// Includes `h` and `V` depending on the [`clap::Command`] settings.
                fn shorts_and_visible_aliases(p: &clap::Command) -> Vec<CompletionCandidate> {
                    debug!("shorts: name={}", p.get_name());

                    p.get_arguments()
                        .filter_map(|a| {
                            a.get_short_and_visible_aliases().map(|shorts| {
                                shorts.into_iter().map(|s| {
                                    populate_arg_candidate(CompletionCandidate::new(s.to_string()), a).help(
                                        a.get_help()
                                            .cloned()
                                            .or_else(|| a.get_long().map(|long| format!("--{long}").into())),
                                    )
                                })
                            })
                        })
                        .flatten()
                        .collect()
                }

                fn populate_arg_candidate(candidate: CompletionCandidate, arg: &clap::Arg) -> CompletionCandidate {
                    candidate
                        .help(arg.get_help().cloned())
                        .id(Some(format!("arg::{}", arg.get_id())))
                        .tag(Some(
                            arg.get_help_heading()
                                .unwrap_or("Options")
                                .to_owned()
                                .into(),
                        ))
                        .display_order(Some(arg.get_display_order()))
                        .hide(arg.is_hide_set())
                }
                /// Get the possible values for completion
                fn possible_values(a: &clap::Arg) -> Option<Vec<clap::builder::PossibleValue>> {
                    if !a.get_num_args().expect("built").takes_values() {
                        None
                    } else {
                        a.get_value_parser()
                            .possible_values()
                            .map(|pvs| pvs.collect())
                    }
                }
                /// Gets subcommands of [`clap::Command`] in the form of `("name", "bin_name")`.
                ///
                /// Subcommand `rustup toolchain install` would be converted to
                /// `("install", "rustup toolchain install")`.
                fn subcommands(p: &clap::Command) -> Vec<CompletionCandidate> {
                    debug!("subcommands: name={}", p.get_name());
                    debug!("subcommands: Has subcommands...{:?}", p.has_subcommands());
                    p.get_subcommands()
                        .flat_map(|sc| {
                            sc.get_name_and_visible_aliases()
                                .into_iter()
                                .map(|s| populate_command_candidate(CompletionCandidate::new(s.to_string()), p, sc))
                                .chain(sc.get_aliases().map(|s| {
                                    populate_command_candidate(CompletionCandidate::new(s.to_string()), p, sc)
                                        .hide(true)
                                }))
                        })
                        .collect()
                }

                fn populate_command_candidate(
                    candidate: CompletionCandidate,
                    cmd: &clap::Command,
                    subcommand: &clap::Command,
                ) -> CompletionCandidate {
                    candidate
                        .help(subcommand.get_about().cloned())
                        .id(Some(format!("command::{}", subcommand.get_name())))
                        .tag(Some(
                            cmd.get_subcommand_help_heading()
                                .unwrap_or("Commands")
                                .to_owned()
                                .into(),
                        ))
                        .display_order(Some(subcommand.get_display_order()))
                        .hide(subcommand.is_hide_set())
                }
                /// Parse the short flags and find the first `takes_values` option.
                fn parse_shortflags<'c, 's>(
                    cmd: &'c clap::Command,
                    mut short: clap_lex::ShortFlags<'s>,
                ) -> (String, Option<&'c clap::Arg>, clap_lex::ShortFlags<'s>) {
                    let takes_value_opt;
                    let mut leading_flags = String::new();
                    // Find the first takes_values option.
                    loop {
                        match short.next_flag() {
                            Some(Ok(opt)) => {
                                leading_flags.push(opt);
                                let opt = cmd.get_arguments().find(|a| {
                                    let shorts = a.get_short_and_visible_aliases();
                                    let is_find = shorts.map(|v| {
                                        let mut iter = v.into_iter();
                                        let c = iter.find(|c| *c == opt);
                                        c.is_some()
                                    });
                                    is_find.unwrap_or(false)
                                });
                                if opt
                                    .map(|o| o.get_num_args().expect("built").takes_values())
                                    .unwrap_or(false)
                                {
                                    takes_value_opt = opt;
                                    break;
                                }
                            }
                            Some(Err(_)) | None => {
                                takes_value_opt = None;
                                break;
                            }
                        }
                    }

                    (leading_flags, takes_value_opt, short)
                }
                /// Parse the positional arguments. Return the new state and the new positional index.
                fn parse_positional<'a>(
                    cmd: &clap::Command,
                    pos_index: usize,
                    is_escaped: bool,
                    state: ParseState<'a>,
                ) -> (ParseState<'a>, usize) {
                    let pos_arg = cmd
                        .get_positionals()
                        .find(|p| p.get_index() == Some(pos_index));
                    let num_args = pos_arg
                        .and_then(|a| a.get_num_args().map(|r| r.max_values()))
                        .unwrap_or(1);

                    let update_state_with_new_positional = |pos_index| -> (ParseState<'a>, usize) {
                        if num_args > 1 {
                            (ParseState::Pos((pos_index, 1)), pos_index)
                        } else {
                            if is_escaped {
                                (ParseState::Pos((pos_index, 1)), pos_index + 1)
                            } else {
                                (ParseState::ValueDone, pos_index + 1)
                            }
                        }
                    };
                    match state {
                        ParseState::ValueDone => {
                            update_state_with_new_positional(pos_index)
                        },
                        ParseState::Pos((prev_pos_index, num_arg)) => {
                            if prev_pos_index == pos_index {
                                if num_arg + 1 < num_args {
                                    (ParseState::Pos((pos_index, num_arg + 1)), pos_index)
                                } else {
                                    if is_escaped {
                                        (ParseState::Pos((pos_index, 1)), pos_index + 1)
                                    } else {
                                        (ParseState::ValueDone, pos_index + 1)
                                    }
                                }
                            } else {
                                update_state_with_new_positional(pos_index)
                            }
                        }
                        ParseState::Opt(..) => unreachable!(
                            "This branch won't be hit,
                            because ParseState::Opt should not be seen as a positional argument and passed to this function."
                        ),
                    }
                }
                /// Parse optional flag argument. Return new state
                fn parse_opt_value(opt: &clap::Arg, count: usize) -> ParseState<'_> {
                    let range = opt.get_num_args().expect("built");
                    let max = range.max_values();
                    if count < max {
                        ParseState::Opt((opt, count + 1))
                    } else {
                        ParseState::ValueDone
                    }
                }

                fn pos_allows_hyphen(cmd: &clap::Command, pos_index: usize) -> bool {
                    cmd.get_positionals()
                        .find(|a| a.get_index() == Some(pos_index))
                        .map(|p| p.is_allow_hyphen_values_set())
                        .unwrap_or(false)
                }

                fn opt_allows_hyphen(state: &ParseState<'_>, arg: &clap_lex::ParsedArg<'_>) -> bool {
                    let val = arg.to_value_os();
                    if val.starts_with("-") {
                        if let ParseState::Opt((opt, _)) = state {
                            return opt.is_allow_hyphen_values_set();
                        }
                    }

                    false
                }
            }

            pub mod custom
            {
                use ::
                {
                    *,
                };
                use std::any::type_name;
                use std::ffi::OsStr;
                use std::sync::Arc;

                use clap::builder::ArgExt;
                use clap::builder::CommandExt;
                use clap_lex::OsStrExt as _;

                use super::CompletionCandidate;

                /// Extend [`Arg`][clap::Arg] with a completer.
                #[derive(Clone)]
                pub struct ArgValueCompleter(Arc<dyn ValueCompleter>);

                impl ArgValueCompleter {
                    /// Create a new `ArgValueCompleter` with a custom completer
                    pub fn new<C>(completer: C) -> Self
                    where
                        C: ValueCompleter + 'static,
                    {
                        Self(Arc::new(completer))
                    }
                    /// Candidates that match `current`
                    ///
                    /// See [`CompletionCandidate`] for more information.
                    pub fn complete(&self, current: &OsStr) -> Vec<CompletionCandidate> {
                        self.0.complete(current)
                    }
                }

                impl std::fmt::Debug for ArgValueCompleter {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        f.write_str(type_name::<Self>())
                    }
                }

                impl ArgExt for ArgValueCompleter {}
                /// User-provided completion candidates for an [`Arg`][clap::Arg], see [`ArgValueCompleter`].
                pub trait ValueCompleter: Send + Sync {
                    /// All potential candidates for an argument.
                    ///
                    /// See [`CompletionCandidate`] for more information.
                    fn complete(&self, current: &OsStr) -> Vec<CompletionCandidate>;
                }

                impl<F> ValueCompleter for F
                where
                    F: Fn(&OsStr) -> Vec<CompletionCandidate> + Send + Sync,
                {
                    fn complete(&self, current: &OsStr) -> Vec<CompletionCandidate> {
                        self(current)
                    }
                }
                /// Extend [`Arg`][clap::Arg] with a [`ValueCandidates`].
                #[derive(Clone)]
                pub struct ArgValueCandidates(Arc<dyn ValueCandidates>);

                impl ArgValueCandidates {
                    /// Create a new `ArgValueCandidates` with a custom completer
                    pub fn new<C>(completer: C) -> Self
                    where
                        C: ValueCandidates + 'static,
                    {
                        Self(Arc::new(completer))
                    }
                    /// All potential candidates for an argument.
                    ///
                    /// See [`CompletionCandidate`] for more information.
                    pub fn candidates(&self) -> Vec<CompletionCandidate> {
                        self.0.candidates()
                    }
                }

                impl std::fmt::Debug for ArgValueCandidates {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        f.write_str(type_name::<Self>())
                    }
                }

                impl ArgExt for ArgValueCandidates {}
                /// Extend [`Command`][clap::Command] with a [`ValueCandidates`].
                #[derive(Clone)]
                pub struct SubcommandCandidates(Arc<dyn ValueCandidates>);

                impl SubcommandCandidates {
                    /// Create a new `SubcommandCandidates` with a custom completer
                    pub fn new<C>(completer: C) -> Self
                    where
                        C: ValueCandidates + 'static,
                    {
                        Self(Arc::new(completer))
                    }
                    /// All potential candidates for an external subcommand.
                    ///
                    /// See [`CompletionCandidate`] for more information.
                    pub fn candidates(&self) -> Vec<CompletionCandidate> {
                        self.0.candidates()
                    }
                }

                impl std::fmt::Debug for SubcommandCandidates {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        f.write_str(type_name::<Self>())
                    }
                }

                impl CommandExt for SubcommandCandidates {}
                /// User-provided completion candidates for an [`Arg`][clap::Arg], see [`ArgValueCandidates`].
                pub trait ValueCandidates: Send + Sync {
                    /// All potential candidates for an argument.
                    ///
                    /// See [`CompletionCandidate`] for more information.
                    fn candidates(&self) -> Vec<CompletionCandidate>;
                }

                impl<F> ValueCandidates for F
                where
                    F: Fn() -> Vec<CompletionCandidate> + Send + Sync,
                {
                    fn candidates(&self) -> Vec<CompletionCandidate> {
                        self()
                    }
                }
                /// Complete a value as a [`std::path::Path`].
                pub struct PathCompleter {
                    current_dir: Option<std::path::PathBuf>,
                    #[allow(clippy::type_complexity)]
                    filter: Option<Box<dyn Fn(&std::path::Path) -> bool + Send + Sync>>,
                    stdio: bool,
                }

                impl PathCompleter {
                    /// Any path is allowed
                    pub fn any() -> Self {
                        Self {
                            filter: None,
                            current_dir: None,
                            stdio: false,
                        }
                    }
                    /// Complete only files
                    pub fn file() -> Self {
                        Self::any().filter(|p| p.is_file())
                    }
                    /// Complete only directories
                    pub fn dir() -> Self {
                        Self::any().filter(|p| p.is_dir())
                    }
                    /// Include stdio (`-`)
                    pub fn stdio(mut self) -> Self {
                        self.stdio = true;
                        self
                    }
                    /// Select which paths should be completed
                    pub fn filter(
                        mut self,
                        filter: impl Fn(&std::path::Path) -> bool + Send + Sync + 'static,
                    ) -> Self {
                        self.filter = Some(Box::new(filter));
                        self
                    }
                    /// Override [`std::env::current_dir`]
                    pub fn current_dir(mut self, path: impl Into<std::path::PathBuf>) -> Self {
                        self.current_dir = Some(path.into());
                        self
                    }
                }

                impl Default for PathCompleter {
                    fn default() -> Self {
                        Self::any()
                    }
                }

                impl ValueCompleter for PathCompleter {
                    fn complete(&self, current: &OsStr) -> Vec<CompletionCandidate> {
                        let filter = self.filter.as_deref().unwrap_or(&|_| true);
                        let mut current_dir_actual = None;
                        let current_dir = self.current_dir.as_deref().or_else(|| {
                            current_dir_actual = std::env::current_dir().ok();
                            current_dir_actual.as_deref()
                        });
                        let mut candidates = complete_path(current, current_dir, filter);
                        if self.stdio && current.is_empty() {
                            candidates.push(CompletionCandidate::new("-").help(Some("stdio".into())));
                        }
                        candidates
                    }
                }

                pub fn complete_path(
                    value_os: &OsStr,
                    current_dir: Option<&std::path::Path>,
                    is_wanted: &dyn Fn(&std::path::Path) -> bool,
                ) -> Vec<CompletionCandidate> {
                    let mut completions = Vec::new();
                    let mut potential = Vec::new();

                    let value_path = std::path::Path::new(value_os);
                    let (prefix, current) = split_file_name(value_path);
                    let current = current.to_string_lossy();
                    let search_root = if prefix.is_absolute() {
                        prefix.to_owned()
                    } else {
                        let current_dir = match current_dir {
                            Some(current_dir) => current_dir,
                            None => {
                                // Can't complete without a `current_dir`
                                return completions;
                            }
                        };
                        current_dir.join(prefix)
                    };
                    debug!("complete_path: search_root={search_root:?}, prefix={prefix:?}");

                    if value_os.is_empty() && is_wanted(&search_root) {
                        completions.push(".".into());
                    }

                    for entry in std::fs::read_dir(&search_root)
                        .ok()
                        .into_iter()
                        .flatten()
                        .filter_map(Result::ok)
                    {
                        let raw_file_name = entry.file_name();
                        if !raw_file_name.starts_with(&current) {
                            continue;
                        }

                        if entry.metadata().map(|m| m.is_dir()).unwrap_or(false) {
                            let mut suggestion = prefix.join(raw_file_name);
                            suggestion.push(""); // Ensure trailing `/`
                            let candidate = CompletionCandidate::new(suggestion.as_os_str().to_owned());

                            if is_wanted(&entry.path()) {
                                completions.push(candidate);
                            } else {
                                potential.push(candidate);
                            }
                        } else {
                            if is_wanted(&entry.path()) {
                                let suggestion = prefix.join(raw_file_name);
                                let candidate = CompletionCandidate::new(suggestion.as_os_str().to_owned());
                                completions.push(candidate);
                            }
                        }
                    }
                    completions.sort();
                    potential.sort();
                    completions.extend(potential);

                    completions
                }

                fn split_file_name(path: &std::path::Path) -> (&std::path::Path, &OsStr) {
                    // Workaround that `Path::new("name/").file_name()` reports `"name"`
                    if path_has_name(path) {
                        (
                            path.parent().unwrap_or_else(|| std::path::Path::new("")),
                            path.file_name().expect("not called with `..`"),
                        )
                    } else {
                        (path, Default::default())
                    }
                }

                fn path_has_name(path: &std::path::Path) -> bool {
                    let path_bytes = path.as_os_str().as_encoded_bytes();
                    let Some(trailing) = path_bytes.last() else {
                        return false;
                    };
                    let trailing = *trailing as char;
                    !std::path::is_separator(trailing) && path.file_name().is_some()
                }
            }
            
            pub use candidate::CompletionCandidate;
            pub use complete::complete;
            pub use custom::ArgValueCandidates;
            pub use custom::ArgValueCompleter;
            pub use custom::PathCompleter;
            pub use custom::SubcommandCandidates;
            pub use custom::ValueCandidates;
            pub use custom::ValueCompleter;
        }
        #[cfg(feature = "unstable-dynamic")]
        pub mod env
        {
            //! [`COMPLETE=$SHELL <bin>`][CompleteEnv] completion integration
            use ::
            {
                *,
            };
            
            pub mod shells
            {
                use ::
                {
                    *,
                };

                use std::ffi::OsString;
                use std::str::FromStr;

                use super::EnvCompleter;

                /// Bash completion adapter
                #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                pub struct Bash;

                impl EnvCompleter for Bash {
                    fn name(&self) -> &'static str {
                        "bash"
                    }
                    fn is(&self, name: &str) -> bool {
                        name == "bash"
                    }
                    fn write_registration(
                        &self,
                        var: &str,
                        name: &str,
                        bin: &str,
                        completer: &str,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let escaped_name = name.replace('-', "_");

                        let completer =
                            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

                        let script = r#"
                _clap_complete_NAME() {
                    local IFS=$'\013'
                    local _CLAP_COMPLETE_INDEX=${COMP_CWORD}
                    local _CLAP_COMPLETE_COMP_TYPE=${COMP_TYPE}
                    if compopt +o nospace 2> /dev/null; then
                        local _CLAP_COMPLETE_SPACE=false
                    else
                        local _CLAP_COMPLETE_SPACE=true
                    fi
                    COMPREPLY=( $( \
                        _CLAP_IFS="$IFS" \
                        _CLAP_COMPLETE_INDEX="$_CLAP_COMPLETE_INDEX" \
                        _CLAP_COMPLETE_COMP_TYPE="$_CLAP_COMPLETE_COMP_TYPE" \
                        _CLAP_COMPLETE_SPACE="$_CLAP_COMPLETE_SPACE" \
                        VAR="bash" \
                        "COMPLETER" -- "${COMP_WORDS[@]}" \
                    ) )
                    if [[ $? != 0 ]]; then
                        unset COMPREPLY
                    elif [[ $_CLAP_COMPLETE_SPACE == false ]] && [[ "${COMPREPLY-}" =~ [=/:]$ ]]; then
                        compopt -o nospace
                    fi
                }
                if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
                    complete -o nospace -o bashdefault -o nosort -F _clap_complete_NAME BIN
                else
                    complete -o nospace -o bashdefault -F _clap_complete_NAME BIN
                fi
                "#
                        .replace("NAME", &escaped_name)
                        .replace("BIN", bin)
                        .replace("COMPLETER", &completer)
                        .replace("VAR", var);

                        writeln!(buf, "{script}")?;
                        Ok(())
                    }
                    fn write_complete(
                        &self,
                        cmd: &mut clap::Command,
                        args: Vec<OsString>,
                        current_dir: Option<&std::path::Path>,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let index: usize = std::env::var("_CLAP_COMPLETE_INDEX")
                            .ok()
                            .and_then(|i| i.parse().ok())
                            .unwrap_or_default();
                        let _comp_type: CompType = std::env::var("_CLAP_COMPLETE_COMP_TYPE")
                            .ok()
                            .and_then(|i| i.parse().ok())
                            .unwrap_or_default();
                        let _space: Option<bool> = std::env::var("_CLAP_COMPLETE_SPACE")
                            .ok()
                            .and_then(|i| i.parse().ok());
                        let ifs: Option<String> = std::env::var("_CLAP_IFS").ok().and_then(|i| i.parse().ok());
                        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

                        for (i, candidate) in completions.iter().enumerate() {
                            if i != 0 {
                                write!(buf, "{}", ifs.as_deref().unwrap_or("\n"))?;
                            }
                            write!(buf, "{}", candidate.get_value().to_string_lossy())?;
                        }
                        Ok(())
                    }
                }
                /// Type of completion attempted that caused a completion function to be called
                #[derive(Copy, Clone, Debug, PartialEq, Eq)]
                #[non_exhaustive]
                enum CompType {
                    /// Normal completion
                    Normal,
                    /// List completions after successive tabs
                    Successive,
                    /// List alternatives on partial word completion
                    Alternatives,
                    /// List completions if the word is not unmodified
                    Unmodified,
                    /// Menu completion
                    Menu,
                }

                impl FromStr for CompType {
                    type Err = String;

                    fn from_str(s: &str) -> Result<Self, Self::Err> {
                        match s {
                            "9" => Ok(Self::Normal),
                            "63" => Ok(Self::Successive),
                            "33" => Ok(Self::Alternatives),
                            "64" => Ok(Self::Unmodified),
                            "37" => Ok(Self::Menu),
                            _ => Err(format!("unsupported COMP_TYPE `{s}`")),
                        }
                    }
                }

                impl Default for CompType {
                    fn default() -> Self {
                        Self::Normal
                    }
                }
                /// Elvish completion adapter
                #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                pub struct Elvish;

                impl EnvCompleter for Elvish {
                    fn name(&self) -> &'static str {
                        "elvish"
                    }
                    fn is(&self, name: &str) -> bool {
                        name == "elvish"
                    }
                    fn write_registration(
                        &self,
                        var: &str,
                        _name: &str,
                        bin: &str,
                        completer: &str,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let bin = shlex::try_quote(bin).unwrap_or(std::borrow::Cow::Borrowed(bin));
                        let completer =
                            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

                        let script = r#"
                set edit:completion:arg-completer[BIN] = { |@words|
                    var index = (count $words)
                    set index = (- $index 1)

                    put (env _CLAP_IFS="\n" _CLAP_COMPLETE_INDEX=(to-string $index) VAR="elvish" COMPLETER -- $@words) | to-lines
                }
                "#
                        .replace("COMPLETER", &completer)
                        .replace("BIN", &bin)
                        .replace("VAR", var);

                        writeln!(buf, "{script}")?;
                        Ok(())
                    }
                    fn write_complete(
                        &self,
                        cmd: &mut clap::Command,
                        args: Vec<OsString>,
                        current_dir: Option<&std::path::Path>,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let index: usize = std::env::var("_CLAP_COMPLETE_INDEX")
                            .ok()
                            .and_then(|i| i.parse().ok())
                            .unwrap_or_default();
                        let ifs: Option<String> = std::env::var("_CLAP_IFS").ok().and_then(|i| i.parse().ok());
                        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

                        for (i, candidate) in completions.iter().enumerate() {
                            if i != 0 {
                                write!(buf, "{}", ifs.as_deref().unwrap_or("\n"))?;
                            }
                            write!(buf, "{}", candidate.get_value().to_string_lossy())?;
                        }
                        Ok(())
                    }
                }
                /// Fish completion adapter
                #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                pub struct Fish;

                impl EnvCompleter for Fish {
                    fn name(&self) -> &'static str {
                        "fish"
                    }
                    fn is(&self, name: &str) -> bool {
                        name == "fish"
                    }
                    fn write_registration(
                        &self,
                        var: &str,
                        _name: &str,
                        bin: &str,
                        completer: &str,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let bin = shlex::try_quote(bin).unwrap_or(std::borrow::Cow::Borrowed(bin));
                        let completer =
                            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

                        writeln!(
                            buf,
                            r#"complete --keep-order --exclusive --command {bin} --arguments "({var}=fish "'{completer}'" -- (commandline --current-process --tokenize --cut-at-cursor) (commandline --current-token))""#
                        )
                    }
                    fn write_complete(
                        &self,
                        cmd: &mut clap::Command,
                        args: Vec<OsString>,
                        current_dir: Option<&std::path::Path>,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let index = args.len() - 1;
                        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

                        for candidate in completions {
                            write!(buf, "{}", candidate.get_value().to_string_lossy())?;
                            if let Some(help) = candidate.get_help() {
                                write!(
                                    buf,
                                    "\t{}",
                                    help.to_string().lines().next().unwrap_or_default()
                                )?;
                            }
                            writeln!(buf)?;
                        }
                        Ok(())
                    }
                }
                /// Powershell completion adapter
                #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                pub struct Powershell;

                impl EnvCompleter for Powershell {
                    fn name(&self) -> &'static str {
                        "powershell"
                    }
                    fn is(&self, name: &str) -> bool {
                        name == "powershell" || name == "powershell_ise"
                    }
                    fn write_registration(
                        &self,
                        var: &str,
                        _name: &str,
                        bin: &str,
                        completer: &str,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let bin = shlex::try_quote(bin).unwrap_or(std::borrow::Cow::Borrowed(bin));
                        let completer =
                            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

                        // `completer` may or may not be surrounded by double quotes, enclosing
                        // the expression in a here-string ensures the whole thing is
                        // interpreted as the first argument to the call operator
                        writeln!(
                            buf,
                            r#"
                Register-ArgumentCompleter -Native -CommandName {bin} -ScriptBlock {{
                    param($wordToComplete, $commandAst, $cursorPosition)

                    $prev = $env:{var};
                    $env:{var} = "powershell";
                    $results = Invoke-Expression @"
                & {completer} -- $commandAst
                "@;
                    if ($null -eq $prev) {{
                        Remove-Item Env:\{var};
                    }} else {{
                        $env:{var} = $prev;
                    }}
                    $results | ForEach-Object {{
                        $split = $_.Split("`t");
                        $cmd = $split[0];

                        if ($split.Length -eq 2) {{
                            $help = $split[1];
                        }}
                        else {{
                            $help = $split[0];
                        }}

                        [System.Management.Automation.CompletionResult]::new($cmd, $cmd, 'ParameterValue', $help)
                    }}
                }};
                        "#
                        )
                    }

                    fn write_complete(
                        &self,
                        cmd: &mut clap::Command,
                        args: Vec<OsString>,
                        current_dir: Option<&std::path::Path>,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let index = args.len() - 1;
                        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

                        for candidate in completions {
                            write!(buf, "{}", candidate.get_value().to_string_lossy())?;
                            if let Some(help) = candidate.get_help() {
                                write!(
                                    buf,
                                    "\t{}",
                                    help.to_string().lines().next().unwrap_or_default()
                                )?;
                            }
                            writeln!(buf)?;
                        }
                        Ok(())
                    }
                }
                /// Zsh completion adapter
                #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                pub struct Zsh;

                impl EnvCompleter for Zsh {
                    fn name(&self) -> &'static str {
                        "zsh"
                    }
                    fn is(&self, name: &str) -> bool {
                        name == "zsh"
                    }
                    fn write_registration(
                        &self,
                        var: &str,
                        name: &str,
                        bin: &str,
                        completer: &str,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let escaped_name = name.replace('-', "_");
                        let bin = shlex::try_quote(bin).unwrap_or(std::borrow::Cow::Borrowed(bin));
                        let completer =
                            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

                        let script = r#"#compdef BIN
                function _clap_dynamic_completer_NAME() {
                    local _CLAP_COMPLETE_INDEX=$(expr $CURRENT - 1)
                    local _CLAP_IFS=$'\n'

                    local completions=("${(@f)$( \
                        _CLAP_IFS="$_CLAP_IFS" \
                        _CLAP_COMPLETE_INDEX="$_CLAP_COMPLETE_INDEX" \
                        VAR="zsh" \
                        COMPLETER -- ${words} 2>/dev/null \
                    )}")

                    if [[ -n $completions ]]; then
                        _describe 'values' completions
                    fi
                }

                compdef _clap_dynamic_completer_NAME BIN"#
                            .replace("NAME", &escaped_name)
                            .replace("COMPLETER", &completer)
                            .replace("BIN", &bin)
                            .replace("VAR", var);

                        writeln!(buf, "{script}")?;
                        Ok(())
                    }
                    fn write_complete(
                        &self,
                        cmd: &mut clap::Command,
                        args: Vec<OsString>,
                        current_dir: Option<&std::path::Path>,
                        buf: &mut dyn std::io::Write,
                    ) -> Result<(), std::io::Error> {
                        let index: usize = std::env::var("_CLAP_COMPLETE_INDEX")
                            .ok()
                            .and_then(|i| i.parse().ok())
                            .unwrap_or_default();
                        let ifs: Option<String> = std::env::var("_CLAP_IFS").ok().and_then(|i| i.parse().ok());

                        // If the current word is empty, add an empty string to the args
                        let mut args = args.clone();
                        if args.len() == index {
                            args.push("".into());
                        }
                        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

                        for (i, candidate) in completions.iter().enumerate() {
                            if i != 0 {
                                write!(buf, "{}", ifs.as_deref().unwrap_or("\n"))?;
                            }
                            write!(
                                buf,
                                "{}",
                                Self::escape_value(&candidate.get_value().to_string_lossy())
                            )?;
                            if let Some(help) = candidate.get_help() {
                                write!(
                                    buf,
                                    ":{}",
                                    Self::escape_help(help.to_string().lines().next().unwrap_or_default())
                                )?;
                            }
                        }
                        Ok(())
                    }
                }

                impl Zsh {
                    /// Escape value string
                    fn escape_value(string: &str) -> String {
                        string.replace('\\', "\\\\").replace(':', "\\:")
                    }
                    /// Escape help string
                    fn escape_help(string: &str) -> String {
                        string.replace('\\', "\\\\")
                    }
                }
            }

            use std::ffi::OsString;
            use std::io::Write as _;

            pub use shells::*;

            /// Environment-activated completions for your CLI.
            pub struct CompleteEnv<'s, F> {
                factory: F,
                var: &'static str,
                bin: Option<String>,
                completer: Option<String>,
                shells: Shells<'s>,
            }

            impl<'s, F: Fn() -> clap::Command> CompleteEnv<'s, F> {
                /// Complete a [`clap::Command`].
                pub fn with_factory(factory: F) -> Self {
                    Self {
                        factory,
                        var: "COMPLETE",
                        bin: None,
                        completer: None,
                        shells: Shells::builtins(),
                    }
                }
                /// Override the environment variable used for enabling completions
                pub fn var(mut self, var: &'static str) -> Self {
                    self.var = var;
                    self
                }
                /// Override the name of the binary to complete.
                pub fn bin(mut self, bin: impl Into<String>) -> Self {
                    self.bin = Some(bin.into());
                    self
                }
                /// Override the binary to call to get completions.
                pub fn completer(mut self, completer: impl Into<String>) -> Self {
                    self.completer = Some(completer.into());
                    self
                }
                /// Override the shells supported for completions
                pub fn shells(mut self, shells: Shells<'s>) -> Self {
                    self.shells = shells;
                    self
                }
            }

            impl<'s, F: Fn() -> clap::Command> CompleteEnv<'s, F> {
                /// Process the completion request and exit
                ///
                /// **Warning:** `stdout` should not be written to before this has had a
                /// chance to run.
                pub fn complete(self) {
                    let args = std::env::args_os();
                    let current_dir = std::env::current_dir().ok();
                    if self
                        .try_complete(args, current_dir.as_deref())
                        .unwrap_or_else(|e| e.exit())
                    {
                        std::process::exit(0)
                    }
                }
                /// Process the completion request
                ///
                /// **Warning:** `stdout` should not be written to before or after this has run.
                ///
                /// Returns `true` if a command was completed and `false` if this is a regular run of your
                /// application
                pub fn try_complete(
                    self,
                    args: impl IntoIterator<Item = impl Into<OsString>>,
                    current_dir: Option<&std::path::Path>,
                ) -> clap::error::Result<bool> {
                    self.try_complete_(args.into_iter().map(|a| a.into()).collect(), current_dir)
                }

                fn try_complete_(
                    self,
                    mut args: Vec<OsString>,
                    current_dir: Option<&std::path::Path>,
                ) -> clap::error::Result<bool> {
                    let Some(name) = std::env::var_os(self.var) else {
                        return Ok(false);
                    };
                    if name.is_empty() || name == "0" {
                        return Ok(false);
                    }

                    // Ensure any child processes called for custom completers don't activate their own
                    // completion logic.
                    std::env::remove_var(self.var);

                    let shell = self.shell(std::path::Path::new(&name))?;

                    let mut cmd = (self.factory)();
                    cmd.build();

                    let completer = args.remove(0);
                    let escape_index = args
                        .iter()
                        .position(|a| *a == "--")
                        .map(|i| i + 1)
                        .unwrap_or(args.len());
                    args.drain(0..escape_index);
                    if args.is_empty() {
                        let mut buf = Vec::new();
                        self.write_registration(&cmd, current_dir, shell, completer, &mut buf)?;
                        std::io::stdout().write_all(&buf)?;
                    } else {
                        let mut buf = Vec::new();
                        shell.write_complete(&mut cmd, args, current_dir, &mut buf)?;
                        std::io::stdout().write_all(&buf)?;
                    }

                    Ok(true)
                }

                fn shell(&self, name: &std::path::Path) -> Result<&dyn EnvCompleter, std::io::Error> {
                    // Strip off the parent dir in case `$SHELL` was used
                    let name = name.file_stem().unwrap_or(name.as_os_str());
                    // lossy won't match but this will delegate to unknown
                    // error
                    let name = name.to_string_lossy();

                    let shell = self.shells.completer(&name).ok_or_else(|| {
                        let shells =
                            self.shells
                                .names()
                                .enumerate()
                                .fold(String::new(), |mut seed, (i, name)| {
                                    use std::fmt::Write as _;
                                    let prefix = if i == 0 { "" } else { ", " };
                                    let _ = write!(&mut seed, "{prefix}`{name}`");
                                    seed
                                });
                        std::io::Error::new(
                            std::io::ErrorKind::Other,
                            format!("unknown shell `{name}`, expected one of {shells}"),
                        )
                    })?;
                    Ok(shell)
                }

                fn write_registration(
                    &self,
                    cmd: &clap::Command,
                    current_dir: Option<&std::path::Path>,
                    shell: &dyn EnvCompleter,
                    completer: OsString,
                    buf: &mut dyn std::io::Write,
                ) -> Result<(), std::io::Error> {
                    let name = cmd.get_name();
                    let bin = self
                        .bin
                        .as_deref()
                        .or_else(|| cmd.get_bin_name())
                        .unwrap_or_else(|| cmd.get_name());
                    let completer = if let Some(completer) = self.completer.as_deref() {
                        completer.to_owned()
                    } else {
                        let mut completer = std::path::PathBuf::from(completer);
                        if let Some(current_dir) = current_dir {
                            if 1 < completer.components().count() {
                                completer = current_dir.join(completer);
                            }
                        }
                        completer.to_string_lossy().into_owned()
                    };

                    shell.write_registration(self.var, name, bin, &completer, buf)?;

                    Ok(())
                }
            }
            /// Collection of shell-specific completers
            pub struct Shells<'s>(pub &'s [&'s dyn EnvCompleter]);

            impl<'s> Shells<'s> {
                /// Select all of the built-in shells
                pub const fn builtins() -> Self {
                    Self(&[&Bash, &Elvish, &Fish, &Powershell, &Zsh])
                }
                /// Find the specified [`EnvCompleter`]
                pub fn completer(&self, name: &str) -> Option<&dyn EnvCompleter> {
                    self.0.iter().copied().find(|c| c.is(name))
                }
                /// Collect all [`EnvCompleter::name`]s
                pub fn names(&self) -> impl Iterator<Item = &'static str> + 's {
                    self.0.iter().map(|c| c.name())
                }
                /// Iterate over [`EnvCompleter`]s
                pub fn iter(&self) -> impl Iterator<Item = &dyn EnvCompleter> {
                    self.0.iter().copied()
                }
            }
            /// Shell-integration for completions.
            pub trait EnvCompleter {
                /// Canonical name for this shell.
                fn name(&self) -> &'static str;
                /// Whether the name matches this shell.
                fn is(&self, name: &str) -> bool;
                /// Register for completions.
                fn write_registration(
                    &self,
                    var: &str,
                    name: &str,
                    bin: &str,
                    completer: &str,
                    buf: &mut dyn std::io::Write,
                ) -> Result<(), std::io::Error>;
                /// Complete the given command.
                fn write_complete(
                    &self,
                    cmd: &mut clap::Command,
                    args: Vec<OsString>,
                    current_dir: Option<&std::path::Path>,
                    buf: &mut dyn std::io::Write,
                ) -> Result<(), std::io::Error>;
            }
        }

        pub use clap::ValueHint;
        #[doc(inline)]
        #[cfg(feature = "unstable-dynamic")]
        pub use engine::ArgValueCandidates;
        #[cfg(feature = "unstable-dynamic")]
        pub use engine::ArgValueCompleter;
        #[doc(inline)]
        #[cfg(feature = "unstable-dynamic")]
        pub use engine::CompletionCandidate;
        #[cfg(feature = "unstable-dynamic")]
        pub use engine::PathCompleter;
        #[cfg(feature = "unstable-dynamic")]
        pub use env::CompleteEnv;

        /// Deprecated, see [`aot`]
        pub mod generator {
            pub use crate::aot::generate;
            pub use crate::aot::generate_to;
            pub use crate::aot::utils;
            pub use crate::aot::Generator;
        }
        /// Deprecated, see [`aot`]
        pub mod shells {
            pub use crate::aot::Bash;
            pub use crate::aot::Elvish;
            pub use crate::aot::Fish;
            pub use crate::aot::PowerShell;
            pub use crate::aot::Shell;
            pub use crate::aot::Zsh;
        }
        /// Deprecated, see [`aot::generate`]
        pub use aot::generate;
        /// Deprecated, see [`aot::generate_to`]
        pub use aot::generate_to;
        /// Deprecated, see [`aot::Generator`]
        pub use aot::Generator;
        /// Deprecated, see [`aot::Shell`]
        pub use aot::Shell;
    }

    pub mod clap_derive
    {
        use ::
        {
            *,
        };

        use proc_macro::TokenStream;
        use syn::{parse_macro_input, DeriveInput};
        use syn::{Data, DataStruct, Fields};

        #[macro_use] pub mod macros
        {
            use ::
            { 
                *,
            };
            macro_rules! format_err {
                ($obj:expr, $($format:tt)+) => {{
                    #[allow(unused_imports)]
                    use $crate::utils::error::*;
                    let msg = format!($($format)+);
                    $obj.EXPECTED_Span_OR_ToTokens(msg)
                }};
            }

            macro_rules! abort {
                ($obj:expr, $($format:tt)+) => {{
                    return Err(format_err!($obj, $($format)+));
                }};
            }

            macro_rules! abort_call_site {
                ($($format:tt)+) => {{
                    let span = proc_macro2::Span::call_site();
                    abort!(span, $($format)+)
                }};
            }
        }

        pub mod attr
        {
            use ::
            { 
                *,
            };

            use std::iter::FromIterator;
            use proc_macro2::TokenStream;
            use quote::quote;
            use quote::ToTokens;
            use syn::spanned::Spanned;
            use syn::{
                parenthesized,
                parse::{Parse, ParseStream},
                punctuated::Punctuated,
                Attribute, Expr, Ident, LitStr, Token,
            };

            use crate::utils::Sp;

            #[derive(Clone)]
            pub struct ClapAttr {
                pub kind: Sp<AttrKind>,
                pub name: Ident,
                pub magic: Option<MagicAttrName>,
                pub value: Option<AttrValue>,
            }

            impl ClapAttr {
                pub fn parse_all(all_attrs: &[Attribute]) -> Result<Vec<Self>, syn::Error> {
                    let mut parsed = Vec::new();
                    for attr in all_attrs {
                        let kind = if attr.path().is_ident("clap") {
                            Sp::new(AttrKind::Clap, attr.path().span())
                        } else if attr.path().is_ident("structopt") {
                            Sp::new(AttrKind::StructOpt, attr.path().span())
                        } else if attr.path().is_ident("command") {
                            Sp::new(AttrKind::Command, attr.path().span())
                        } else if attr.path().is_ident("group") {
                            Sp::new(AttrKind::Group, attr.path().span())
                        } else if attr.path().is_ident("arg") {
                            Sp::new(AttrKind::Arg, attr.path().span())
                        } else if attr.path().is_ident("value") {
                            Sp::new(AttrKind::Value, attr.path().span())
                        } else {
                            continue;
                        };
                        for mut attr in
                            attr.parse_args_with(Punctuated::<ClapAttr, Token![,]>::parse_terminated)?
                        {
                            attr.kind = kind;
                            parsed.push(attr);
                        }
                    }
                    Ok(parsed)
                }

                pub fn value_or_abort(&self) -> Result<&AttrValue, syn::Error> {
                    self.value
                        .as_ref()
                        .ok_or_else(|| format_err!(self.name, "attribute `{}` requires a value", self.name))
                }

                pub fn lit_str_or_abort(&self) -> Result<&LitStr, syn::Error> {
                    let value = self.value_or_abort()?;
                    match value {
                        AttrValue::LitStr(tokens) => Ok(tokens),
                        AttrValue::Expr(_) | AttrValue::Call(_) => {
                            abort!(
                                self.name,
                                "attribute `{}` can only accept string literals",
                                self.name
                            )
                        }
                    }
                }
            }

            impl Parse for ClapAttr {
                fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
                    let name: Ident = input.parse()?;
                    let name_str = name.to_string();

                    let magic = match name_str.as_str() {
                        "rename_all" => Some(MagicAttrName::RenameAll),
                        "rename_all_env" => Some(MagicAttrName::RenameAllEnv),
                        "skip" => Some(MagicAttrName::Skip),
                        "next_display_order" => Some(MagicAttrName::NextDisplayOrder),
                        "next_help_heading" => Some(MagicAttrName::NextHelpHeading),
                        "default_value_t" => Some(MagicAttrName::DefaultValueT),
                        "default_values_t" => Some(MagicAttrName::DefaultValuesT),
                        "default_value_os_t" => Some(MagicAttrName::DefaultValueOsT),
                        "default_values_os_t" => Some(MagicAttrName::DefaultValuesOsT),
                        "long" => Some(MagicAttrName::Long),
                        "short" => Some(MagicAttrName::Short),
                        "value_parser" => Some(MagicAttrName::ValueParser),
                        "action" => Some(MagicAttrName::Action),
                        "env" => Some(MagicAttrName::Env),
                        "flatten" => Some(MagicAttrName::Flatten),
                        "value_enum" => Some(MagicAttrName::ValueEnum),
                        "from_global" => Some(MagicAttrName::FromGlobal),
                        "subcommand" => Some(MagicAttrName::Subcommand),
                        "external_subcommand" => Some(MagicAttrName::ExternalSubcommand),
                        "verbatim_doc_comment" => Some(MagicAttrName::VerbatimDocComment),
                        "about" => Some(MagicAttrName::About),
                        "long_about" => Some(MagicAttrName::LongAbout),
                        "long_help" => Some(MagicAttrName::LongHelp),
                        "author" => Some(MagicAttrName::Author),
                        "version" => Some(MagicAttrName::Version),
                        _ => None,
                    };

                    let value = if input.peek(Token![=]) {
                        // `name = value` attributes.
                        let assign_token = input.parse::<Token![=]>()?; // skip '='
                        if input.peek(LitStr) {
                            let lit: LitStr = input.parse()?;
                            Some(AttrValue::LitStr(lit))
                        } else {
                            match input.parse::<Expr>() {
                                Ok(expr) => Some(AttrValue::Expr(expr)),

                                Err(_) => abort! {
                                    assign_token,
                                    "expected `string literal` or `expression` after `=`"
                                },
                            }
                        }
                    } else if input.peek(syn::token::Paren) {
                        // `name(...)` attributes.
                        let nested;
                        parenthesized!(nested in input);

                        let method_args: Punctuated<_, _> = nested.parse_terminated(Expr::parse, Token![,])?;
                        Some(AttrValue::Call(Vec::from_iter(method_args)))
                    } else {
                        None
                    };

                    Ok(Self {
                        kind: Sp::new(AttrKind::Clap, name.span()),
                        name,
                        magic,
                        value,
                    })
                }
            }

            #[derive(Copy, Clone, PartialEq, Eq)]
            pub enum MagicAttrName {
                Short,
                Long,
                ValueParser,
                Action,
                Env,
                Flatten,
                ValueEnum,
                FromGlobal,
                Subcommand,
                VerbatimDocComment,
                ExternalSubcommand,
                About,
                LongAbout,
                LongHelp,
                Author,
                Version,
                RenameAllEnv,
                RenameAll,
                Skip,
                DefaultValueT,
                DefaultValuesT,
                DefaultValueOsT,
                DefaultValuesOsT,
                NextDisplayOrder,
                NextHelpHeading,
            }

            #[derive(Clone)]
            #[allow(clippy::large_enum_variant)]
            pub enum AttrValue {
                LitStr(LitStr),
                Expr(Expr),
                Call(Vec<Expr>),
            }

            impl ToTokens for AttrValue {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    match self {
                        Self::LitStr(t) => t.to_tokens(tokens),
                        Self::Expr(t) => t.to_tokens(tokens),
                        Self::Call(t) => {
                            let t = quote!(#(#t),*);
                            t.to_tokens(tokens);
                        }
                    }
                }
            }

            #[derive(Copy, Clone, PartialEq, Eq)]
            pub enum AttrKind {
                Clap,
                StructOpt,
                Command,
                Group,
                Arg,
                Value,
            }

            impl AttrKind {
                pub fn as_str(&self) -> &'static str {
                    match self {
                        Self::Clap => "clap",
                        Self::StructOpt => "structopt",
                        Self::Command => "command",
                        Self::Group => "group",
                        Self::Arg => "arg",
                        Self::Value => "value",
                    }
                }
            }
        }

        pub mod derives
        {
            use ::
            { 
                *,
            };
            // Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
            // Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
            // Ana Hobden (@hoverbear) <operator@hoverbear.org>
            //
            // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
            // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
            // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. This file may not be copied, modified, or distributed
            // except according to those terms.
            //
            // This work was derived from Structopt (https://github.com/TeXitoi/structopt)
            // commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
            // MIT/Apache 2.0 license.
            pub mod args
            {
                use ::
                {
                    *,
                };
                // Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
                // Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
                // Ana Hobden (@hoverbear) <operator@hoverbear.org>
                //
                // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
                // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
                // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
                // option. This file may not be copied, modified, or distributed
                // except according to those terms.
                //
                // This work was derived from Structopt (https://github.com/TeXitoi/structopt)
                // commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
                // MIT/Apache 2.0 license.

                use proc_macro2::{Ident, Span, TokenStream};
                use quote::{format_ident, quote, quote_spanned};
                use syn::{
                    punctuated::Punctuated, spanned::Spanned, token::Comma, Data, DataStruct, DeriveInput, Field,
                    Fields, FieldsNamed, Generics,
                };

                use crate::item::{Item, Kind, Name};
                use crate::utils::{inner_type, sub_type, Sp, Ty};

                pub fn derive_args(input: &DeriveInput) -> Result<TokenStream, syn::Error> {
                    let ident = &input.ident;

                    match input.data {
                        Data::Struct(DataStruct {
                            fields: Fields::Named(ref fields),
                            ..
                        }) => {
                            let name = Name::Derived(ident.clone());
                            let item = Item::from_args_struct(input, name)?;
                            let fields = collect_args_fields(&item, fields)?;
                            gen_for_struct(&item, ident, &input.generics, &fields)
                        }
                        Data::Struct(DataStruct {
                            fields: Fields::Unit,
                            ..
                        }) => {
                            let name = Name::Derived(ident.clone());
                            let item = Item::from_args_struct(input, name)?;
                            let fields = Punctuated::<Field, Comma>::new();
                            let fields = fields
                                .iter()
                                .map(|field| {
                                    let item = Item::from_args_field(field, item.casing(), item.env_casing())?;
                                    Ok((field, item))
                                })
                                .collect::<Result<Vec<_>, syn::Error>>()?;
                            gen_for_struct(&item, ident, &input.generics, &fields)
                        }
                        _ => abort_call_site!("`#[derive(Args)]` only supports non-tuple structs"),
                    }
                }

                pub fn gen_for_struct(
                    item: &Item,
                    item_name: &Ident,
                    generics: &Generics,
                    fields: &[(&Field, Item)],
                ) -> Result<TokenStream, syn::Error> {
                    if !matches!(&*item.kind(), Kind::Command(_)) {
                        abort! { item.kind().span(),
                            "`{}` cannot be used with `command`",
                            item.kind().name(),
                        }
                    }

                    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

                    let constructor = gen_constructor(fields)?;
                    let updater = gen_updater(fields, true)?;
                    let raw_deprecated = raw_deprecated();

                    let app_var = Ident::new("__clap_app", Span::call_site());
                    let augmentation = gen_augment(fields, &app_var, item, false)?;
                    let augmentation_update = gen_augment(fields, &app_var, item, true)?;

                    let group_id = if item.skip_group() {
                        quote!(None)
                    } else {
                        let group_id = item.group_id();
                        quote!(Some(clap::Id::from(#group_id)))
                    };

                    Ok(quote! {
                        #[allow(
                            dead_code,
                            unreachable_code,
                            unused_variables,
                            unused_braces,
                            unused_qualifications,
                        )]
                        #[allow(
                            clippy::style,
                            clippy::complexity,
                            clippy::pedantic,
                            clippy::restriction,
                            clippy::perf,
                            clippy::deprecated,
                            clippy::nursery,
                            clippy::cargo,
                            clippy::suspicious_else_formatting,
                            clippy::almost_swapped,
                            clippy::redundant_locals,
                        )]
                        #[automatically_derived]
                        impl #impl_generics clap::FromArgMatches for #item_name #ty_generics #where_clause {
                            fn from_arg_matches(__clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
                                Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
                            }

                            fn from_arg_matches_mut(__clap_arg_matches: &mut clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
                                #raw_deprecated
                                let v = #item_name #constructor;
                                ::std::result::Result::Ok(v)
                            }

                            fn update_from_arg_matches(&mut self, __clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<(), clap::Error> {
                                self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
                            }

                            fn update_from_arg_matches_mut(&mut self, __clap_arg_matches: &mut clap::ArgMatches) -> ::std::result::Result<(), clap::Error> {
                                #raw_deprecated
                                #updater
                                ::std::result::Result::Ok(())
                            }
                        }

                        #[allow(
                            dead_code,
                            unreachable_code,
                            unused_variables,
                            unused_braces,
                            unused_qualifications,
                        )]
                        #[allow(
                            clippy::style,
                            clippy::complexity,
                            clippy::pedantic,
                            clippy::restriction,
                            clippy::perf,
                            clippy::deprecated,
                            clippy::nursery,
                            clippy::cargo,
                            clippy::suspicious_else_formatting,
                            clippy::almost_swapped,
                            clippy::redundant_locals,
                        )]
                        #[automatically_derived]
                        impl #impl_generics clap::Args for #item_name #ty_generics #where_clause {
                            fn group_id() -> Option<clap::Id> {
                                #group_id
                            }
                            fn augment_args<'b>(#app_var: clap::Command) -> clap::Command {
                                #augmentation
                            }
                            fn augment_args_for_update<'b>(#app_var: clap::Command) -> clap::Command {
                                #augmentation_update
                            }
                        }
                    })
                }
                /// Generate a block of code to add arguments/subcommands corresponding to
                /// the `fields` to an cmd.
                pub fn gen_augment(
                    fields: &[(&Field, Item)],
                    app_var: &Ident,
                    parent_item: &Item,
                    override_required: bool,
                ) -> Result<TokenStream, syn::Error> {
                    let mut subcommand_specified = false;
                    let mut args = Vec::new();
                    for (field, item) in fields {
                        let kind = item.kind();
                        let genned = match &*kind {
                            Kind::Command(_)
                            | Kind::Value
                            | Kind::Skip(_, _)
                            | Kind::FromGlobal(_)
                            | Kind::ExternalSubcommand => None,
                            Kind::Subcommand(ty) => {
                                if subcommand_specified {
                                    abort!(
                                        field.span(),
                                        "`#[command(subcommand)]` can only be used once per container"
                                    );
                                }
                                subcommand_specified = true;

                                let subcmd_type = match (**ty, sub_type(&field.ty)) {
                                    (Ty::Option, Some(sub_type)) => sub_type,
                                    _ => &field.ty,
                                };
                                let implicit_methods = if **ty == Ty::Option {
                                    quote!()
                                } else {
                                    quote_spanned! { kind.span()=>
                                        .subcommand_required(true)
                                        .arg_required_else_help(true)
                                    }
                                };

                                let override_methods = if override_required {
                                    quote_spanned! { kind.span()=>
                                        .subcommand_required(false)
                                        .arg_required_else_help(false)
                                    }
                                } else {
                                    quote!()
                                };

                                Some(quote! {
                                    let #app_var = <#subcmd_type as clap::Subcommand>::augment_subcommands( #app_var );
                                    let #app_var = #app_var
                                        #implicit_methods
                                        #override_methods;
                                })
                            }
                            Kind::Flatten(ty) => {
                                let inner_type = match (**ty, sub_type(&field.ty)) {
                                    (Ty::Option, Some(sub_type)) => sub_type,
                                    _ => &field.ty,
                                };

                                let next_help_heading = item.next_help_heading();
                                let next_display_order = item.next_display_order();
                                let flatten_group_assert = if matches!(**ty, Ty::Option) {
                                    quote_spanned! { kind.span()=>
                                        <#inner_type as clap::Args>::group_id().expect("cannot `#[flatten]` an `Option<Args>` with `#[group(skip)]`");
                                    }
                                } else {
                                    quote! {}
                                };
                                if override_required {
                                    Some(quote_spanned! { kind.span()=>
                                        #flatten_group_assert
                                        let #app_var = #app_var
                                            #next_help_heading
                                            #next_display_order;
                                        let #app_var = <#inner_type as clap::Args>::augment_args_for_update(#app_var);
                                    })
                                } else {
                                    Some(quote_spanned! { kind.span()=>
                                        #flatten_group_assert
                                        let #app_var = #app_var
                                            #next_help_heading
                                            #next_display_order;
                                        let #app_var = <#inner_type as clap::Args>::augment_args(#app_var);
                                    })
                                }
                            }
                            Kind::Arg(ty) => {
                                let value_parser = item.value_parser(&field.ty);
                                let action = item.action(&field.ty);
                                let value_name = item.value_name();

                                let implicit_methods = match **ty {
                                    Ty::Unit => {
                                        // Leaving out `value_parser` as it will always fail
                                        quote_spanned! { ty.span()=>
                                            .value_name(#value_name)
                                            #action
                                        }
                                    }
                                    Ty::Option => {
                                        quote_spanned! { ty.span()=>
                                            .value_name(#value_name)
                                            #value_parser
                                            #action
                                        }
                                    }

                                    Ty::OptionOption => quote_spanned! { ty.span()=>
                                        .value_name(#value_name)
                                        .num_args(0..=1)
                                        #value_parser
                                        #action
                                    },

                                    Ty::OptionVec => {
                                        if item.is_positional() {
                                            quote_spanned! { ty.span()=>
                                                .value_name(#value_name)
                                                .num_args(1..)  // action won't be sufficient for getting multiple
                                                #value_parser
                                                #action
                                            }
                                        } else {
                                            quote_spanned! { ty.span()=>
                                                .value_name(#value_name)
                                                #value_parser
                                                #action
                                            }
                                        }
                                    }

                                    Ty::Vec => {
                                        if item.is_positional() {
                                            quote_spanned! { ty.span()=>
                                                .value_name(#value_name)
                                                .num_args(1..)  // action won't be sufficient for getting multiple
                                                #value_parser
                                                #action
                                            }
                                        } else {
                                            quote_spanned! { ty.span()=>
                                                .value_name(#value_name)
                                                #value_parser
                                                #action
                                            }
                                        }
                                    }

                                    Ty::VecVec | Ty::OptionVecVec => {
                                        quote_spanned! { ty.span() =>
                                            .value_name(#value_name)
                                            #value_parser
                                            #action
                                        }
                                    }

                                    Ty::Other => {
                                        let required = item.find_default_method().is_none();
                                        // `ArgAction::takes_values` is assuming `ArgAction::default_value` will be
                                        // set though that won't always be true but this should be good enough,
                                        // otherwise we'll report an "arg required" error when unwrapping.
                                        let action_value = action.args();
                                        quote_spanned! { ty.span()=>
                                            .value_name(#value_name)
                                            .required(#required && #action_value.takes_values())
                                            #value_parser
                                            #action
                                        }
                                    }
                                };

                                let id = item.id();
                                let explicit_methods = item.field_methods();
                                let deprecations = if !override_required {
                                    item.deprecations()
                                } else {
                                    quote!()
                                };
                                let override_methods = if override_required {
                                    quote_spanned! { kind.span()=>
                                        .required(false)
                                    }
                                } else {
                                    quote!()
                                };

                                Some(quote_spanned! { field.span()=>
                                    let #app_var = #app_var.arg({
                                        #deprecations

                                        #[allow(deprecated)]
                                        let arg = clap::Arg::new(#id)
                                            #implicit_methods;

                                        let arg = arg
                                            #explicit_methods;

                                        let arg = arg
                                            #override_methods;

                                        arg
                                    });
                                })
                            }
                        };
                        args.push(genned);
                    }

                    let deprecations = if !override_required {
                        parent_item.deprecations()
                    } else {
                        quote!()
                    };
                    let initial_app_methods = parent_item.initial_top_level_methods();
                    let final_app_methods = parent_item.final_top_level_methods();
                    let group_app_methods = if parent_item.skip_group() {
                        quote!()
                    } else {
                        let group_id = parent_item.group_id();
                        let literal_group_members = fields
                            .iter()
                            .filter_map(|(_field, item)| {
                                let kind = item.kind();
                                if matches!(*kind, Kind::Arg(_)) {
                                    Some(item.id())
                                } else {
                                    None
                                }
                            })
                            .collect::<Vec<_>>();
                        let literal_group_members_len = literal_group_members.len();
                        let mut literal_group_members = quote! {{
                            let members: [clap::Id; #literal_group_members_len] = [#( clap::Id::from(#literal_group_members) ),* ];
                            members
                        }};
                        // HACK: Validation isn't ready yet for nested arg groups, so just don't populate the group in
                        // that situation
                        let possible_group_members_len = fields
                            .iter()
                            .filter(|(_field, item)| {
                                let kind = item.kind();
                                matches!(*kind, Kind::Flatten(_))
                            })
                            .count();
                        if 0 < possible_group_members_len {
                            literal_group_members = quote! {{
                                let members: [clap::Id; 0] = [];
                                members
                            }};
                        }

                        let group_methods = parent_item.group_methods();

                        quote!(
                            .group(
                                clap::ArgGroup::new(#group_id)
                                    .multiple(true)
                                    #group_methods
                                    .args(#literal_group_members)
                            )
                        )
                    };
                    Ok(quote! {{
                        #deprecations
                        let #app_var = #app_var
                            #initial_app_methods
                            #group_app_methods
                            ;
                        #( #args )*
                        #app_var #final_app_methods
                    }})
                }

                pub fn gen_constructor(fields: &[(&Field, Item)]) -> Result<TokenStream, syn::Error> {
                    let fields = fields.iter().map(|(field, item)| {
                        let field_name = field.ident.as_ref().unwrap();
                        let kind = item.kind();
                        let arg_matches = format_ident!("__clap_arg_matches");
                        let genned = match &*kind {
                            Kind::Command(_)
                            | Kind::Value
                            | Kind::ExternalSubcommand => {
                                abort! { kind.span(),
                                    "`{}` cannot be used with `arg`",
                                    kind.name(),
                                }
                            }
                            Kind::Subcommand(ty) => {
                                let subcmd_type = match (**ty, sub_type(&field.ty)) {
                                    (Ty::Option, Some(sub_type)) => sub_type,
                                    _ => &field.ty,
                                };
                                match **ty {
                                    Ty::Option => {
                                        quote_spanned! { kind.span()=>
                                            #field_name: {
                                                if #arg_matches.subcommand_name().map(<#subcmd_type as clap::Subcommand>::has_subcommand).unwrap_or(false) {
                                                    Some(<#subcmd_type as clap::FromArgMatches>::from_arg_matches_mut(#arg_matches)?)
                                                } else {
                                                    None
                                                }
                                            }
                                        }
                                    },
                                    Ty::Other => {
                                        quote_spanned! { kind.span()=>
                                            #field_name: {
                                                <#subcmd_type as clap::FromArgMatches>::from_arg_matches_mut(#arg_matches)?
                                            }
                                        }
                                    },
                                    Ty::Unit |
                                    Ty::Vec |
                                    Ty::OptionOption |
                                    Ty::OptionVec |
                                    Ty::VecVec |
                                    Ty::OptionVecVec => {
                                        abort!(
                                            ty.span(),
                                            "{} types are not supported for subcommand",
                                            ty.as_str()
                                        );
                                    }
                                }
                            }

                            Kind::Flatten(ty) => {
                                let inner_type = match (**ty, sub_type(&field.ty)) {
                                    (Ty::Option, Some(sub_type)) => sub_type,
                                    _ => &field.ty,
                                };
                                match **ty {
                                    Ty::Other => {
                                        quote_spanned! { kind.span()=>
                                            #field_name: <#inner_type as clap::FromArgMatches>::from_arg_matches_mut(#arg_matches)?
                                        }
                                    },
                                    Ty::Option => {
                                        quote_spanned! { kind.span()=>
                                            #field_name: {
                                                let group_id = <#inner_type as clap::Args>::group_id()
                                                    .expect("asserted during `Arg` creation");
                                                if #arg_matches.contains_id(group_id.as_str()) {
                                                    Some(
                                                        <#inner_type as clap::FromArgMatches>::from_arg_matches_mut(#arg_matches)?
                                                    )
                                                } else {
                                                    None
                                                }
                                            }
                                        }
                                    },
                                    Ty::Unit |
                                    Ty::Vec |
                                    Ty::OptionOption |
                                    Ty::OptionVec |
                                    Ty::VecVec |
                                    Ty::OptionVecVec => {
                                        abort!(
                                            ty.span(),
                                            "{} types are not supported for flatten",
                                            ty.as_str()
                                        );
                                    }
                                }
                            },

                            Kind::Skip(val, _) => match val {
                                None => quote_spanned!(kind.span()=> #field_name: Default::default()),
                                Some(val) => quote_spanned!(kind.span()=> #field_name: (#val).into()),
                            },

                            Kind::Arg(ty) | Kind::FromGlobal(ty) => {
                                gen_parsers(item, ty, field_name, field, None)?
                            }
                        };
                        Ok(genned)
                    }).collect::<Result<Vec<_>, syn::Error>>()?;

                    Ok(quote! {{
                        #( #fields ),*
                    }})
                }

                pub fn gen_updater(
                    fields: &[(&Field, Item)],
                    use_self: bool,
                ) -> Result<TokenStream, syn::Error> {
                    let mut genned_fields = Vec::new();
                    for (field, item) in fields {
                        let field_name = field.ident.as_ref().unwrap();
                        let kind = item.kind();

                        let access = if use_self {
                            quote! {
                                #[allow(non_snake_case)]
                                let #field_name = &mut self.#field_name;
                            }
                        } else {
                            quote!()
                        };
                        let arg_matches = format_ident!("__clap_arg_matches");

                        let genned = match &*kind {
                            Kind::Command(_) | Kind::Value | Kind::ExternalSubcommand => {
                                abort! { kind.span(),
                                    "`{}` cannot be used with `arg`",
                                    kind.name(),
                                }
                            }
                            Kind::Subcommand(ty) => {
                                let subcmd_type = match (**ty, sub_type(&field.ty)) {
                                    (Ty::Option, Some(sub_type)) => sub_type,
                                    _ => &field.ty,
                                };

                                let updater = quote_spanned! { ty.span()=>
                                    <#subcmd_type as clap::FromArgMatches>::update_from_arg_matches_mut(#field_name, #arg_matches)?;
                                };

                                let updater = match **ty {
                                    Ty::Option => quote_spanned! { kind.span()=>
                                        if let Some(#field_name) = #field_name.as_mut() {
                                            #updater
                                        } else {
                                            *#field_name = Some(<#subcmd_type as clap::FromArgMatches>::from_arg_matches_mut(
                                                #arg_matches
                                            )?);
                                        }
                                    },
                                    _ => quote_spanned! { kind.span()=>
                                        #updater
                                    },
                                };

                                quote_spanned! { kind.span()=>
                                    {
                                        #access
                                        #updater
                                    }
                                }
                            }

                            Kind::Flatten(ty) => {
                                let inner_type = match (**ty, sub_type(&field.ty)) {
                                    (Ty::Option, Some(sub_type)) => sub_type,
                                    _ => &field.ty,
                                };

                                let updater = quote_spanned! { ty.span()=>
                                    <#inner_type as clap::FromArgMatches>::update_from_arg_matches_mut(#field_name, #arg_matches)?;
                                };

                                let updater = match **ty {
                                    Ty::Option => quote_spanned! { kind.span()=>
                                        if let Some(#field_name) = #field_name.as_mut() {
                                            #updater
                                        } else {
                                            *#field_name = Some(<#inner_type as clap::FromArgMatches>::from_arg_matches_mut(
                                                #arg_matches
                                            )?);
                                        }
                                    },
                                    _ => quote_spanned! { kind.span()=>
                                        #updater
                                    },
                                };

                                quote_spanned! { kind.span()=>
                                    {
                                        #access
                                        #updater
                                    }
                                }
                            }

                            Kind::Skip(_, _) => quote!(),

                            Kind::Arg(ty) | Kind::FromGlobal(ty) => {
                                gen_parsers(item, ty, field_name, field, Some(&access))?
                            }
                        };
                        genned_fields.push(genned);
                    }

                    Ok(quote! {
                        #( #genned_fields )*
                    })
                }

                fn gen_parsers(
                    item: &Item,
                    ty: &Sp<Ty>,
                    field_name: &Ident,
                    field: &Field,
                    update: Option<&TokenStream>,
                ) -> Result<TokenStream, syn::Error> {
                    let span = ty.span();
                    let convert_type = inner_type(&field.ty);
                    let id = item.id();
                    let get_one = quote_spanned!(span=> remove_one::<#convert_type>);
                    let get_many = quote_spanned!(span=> remove_many::<#convert_type>);
                    let get_occurrences = quote_spanned!(span=> remove_occurrences::<#convert_type>);

                    // Give this identifier the same hygiene
                    // as the `arg_matches` parameter definition. This
                    // allows us to refer to `arg_matches` within a `quote_spanned` block
                    let arg_matches = format_ident!("__clap_arg_matches");

                    let field_value = match **ty {
                        Ty::Unit => {
                            quote_spanned! { ty.span()=>
                                ()
                            }
                        }

                        Ty::Option => {
                            quote_spanned! { ty.span()=>
                                #arg_matches.#get_one(#id)
                            }
                        }

                        Ty::OptionOption => quote_spanned! { ty.span()=>
                            if #arg_matches.contains_id(#id) {
                                Some(
                                    #arg_matches.#get_one(#id)
                                )
                            } else {
                                None
                            }
                        },

                        Ty::OptionVec => quote_spanned! { ty.span()=>
                            if #arg_matches.contains_id(#id) {
                                Some(#arg_matches.#get_many(#id)
                                    .map(|v| v.collect::<Vec<_>>())
                                    .unwrap_or_else(Vec::new))
                            } else {
                                None
                            }
                        },

                        Ty::Vec => {
                            quote_spanned! { ty.span()=>
                                #arg_matches.#get_many(#id)
                                    .map(|v| v.collect::<Vec<_>>())
                                    .unwrap_or_else(Vec::new)
                            }
                        }

                        Ty::VecVec => quote_spanned! { ty.span()=>
                            #arg_matches.#get_occurrences(#id)
                                .map(|g| g.map(::std::iter::Iterator::collect).collect::<Vec<Vec<_>>>())
                                .unwrap_or_else(Vec::new)
                        },

                        Ty::OptionVecVec => quote_spanned! { ty.span()=>
                            #arg_matches.#get_occurrences(#id)
                                .map(|g| g.map(::std::iter::Iterator::collect).collect::<Vec<Vec<_>>>())
                        },

                        Ty::Other => {
                            // Prefer `concat` where possible for reduced code size but fallback to `format!` to
                            // allow non-literal `id`s
                            match id {
                                Name::Assigned(_) => {
                                    quote_spanned! { ty.span()=>
                                        #arg_matches.#get_one(#id)
                                            .ok_or_else(|| clap::Error::raw(clap::error::ErrorKind::MissingRequiredArgument, format!("The following required argument was not provided: {}", #id)))?
                                    }
                                }
                                Name::Derived(_) => {
                                    quote_spanned! { ty.span()=>
                                        #arg_matches.#get_one(#id)
                                            .ok_or_else(|| clap::Error::raw(clap::error::ErrorKind::MissingRequiredArgument, concat!("The following required argument was not provided: ", #id)))?
                                    }
                                }
                            }
                        }
                    };

                    let genned = if let Some(access) = update {
                        quote_spanned! { field.span()=>
                            if #arg_matches.contains_id(#id) {
                                #access
                                *#field_name = #field_value
                            }
                        }
                    } else {
                        quote_spanned!(field.span()=> #field_name: #field_value )
                    };
                    Ok(genned)
                }

                #[cfg(feature = "raw-deprecated")]
                pub fn raw_deprecated() -> TokenStream {
                    quote! {}
                }

                #[cfg(not(feature = "raw-deprecated"))]
                pub fn raw_deprecated() -> TokenStream {
                    quote! {
                        #![allow(deprecated)]  // Assuming any deprecation in here will be related to a deprecation in `Args`

                    }
                }

                pub fn collect_args_fields<'a>(
                    item: &'a Item,
                    fields: &'a FieldsNamed,
                ) -> Result<Vec<(&'a Field, Item)>, syn::Error> {
                    fields
                        .named
                        .iter()
                        .map(|field| {
                            let item = Item::from_args_field(field, item.casing(), item.env_casing())?;
                            Ok((field, item))
                        })
                        .collect()
                }
            }
            
            pub mod into_app
            {
                use ::
                {
                    *,
                };
                // Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
                // Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
                // Ana Hobden (@hoverbear) <operator@hoverbear.org>
                //
                // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
                // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
                // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
                // option. This file may not be copied, modified, or distributed
                // except according to those terms.
                //
                // This work was derived from Structopt (https://github.com/TeXitoi/structopt)
                // commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
                // MIT/Apache 2.0 license.

                use proc_macro2::{Span, TokenStream};
                use quote::quote;
                use syn::{Generics, Ident};

                use crate::item::Item;

                pub fn gen_for_struct(
                    item: &Item,
                    item_name: &Ident,
                    generics: &Generics,
                ) -> Result<TokenStream, syn::Error> {
                    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

                    let name = item.cased_name();
                    let app_var = Ident::new("__clap_app", Span::call_site());

                    let tokens = quote! {
                        #[allow(
                            dead_code,
                            unreachable_code,
                            unused_variables,
                            unused_braces,
                            unused_qualifications,
                        )]
                        #[allow(
                            clippy::style,
                            clippy::complexity,
                            clippy::pedantic,
                            clippy::restriction,
                            clippy::perf,
                            clippy::deprecated,
                            clippy::nursery,
                            clippy::cargo,
                            clippy::suspicious_else_formatting,
                            clippy::almost_swapped,
                            clippy::redundant_locals,
                        )]
                        #[automatically_derived]
                        impl #impl_generics clap::CommandFactory for #item_name #ty_generics #where_clause {
                            fn command<'b>() -> clap::Command {
                                let #app_var = clap::Command::new(#name);
                                <Self as clap::Args>::augment_args(#app_var)
                            }

                            fn command_for_update<'b>() -> clap::Command {
                                let #app_var = clap::Command::new(#name);
                                <Self as clap::Args>::augment_args_for_update(#app_var)
                            }
                        }
                    };

                    Ok(tokens)
                }

                pub fn gen_for_enum(
                    item: &Item,
                    item_name: &Ident,
                    generics: &Generics,
                ) -> Result<TokenStream, syn::Error> {
                    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

                    let name = item.cased_name();
                    let app_var = Ident::new("__clap_app", Span::call_site());

                    Ok(quote! {
                        #[allow(
                            dead_code,
                            unreachable_code,
                            unused_variables,
                            unused_braces,
                            unused_qualifications,
                        )]
                        #[allow(
                            clippy::style,
                            clippy::complexity,
                            clippy::pedantic,
                            clippy::restriction,
                            clippy::perf,
                            clippy::deprecated,
                            clippy::nursery,
                            clippy::cargo,
                            clippy::suspicious_else_formatting,
                            clippy::almost_swapped,
                            clippy::redundant_locals,
                        )]
                        #[automatically_derived]
                        impl #impl_generics clap::CommandFactory for #item_name #ty_generics #where_clause {
                            fn command<'b>() -> clap::Command {
                                let #app_var = clap::Command::new(#name)
                                    .subcommand_required(true)
                                    .arg_required_else_help(true);
                                <Self as clap::Subcommand>::augment_subcommands(#app_var)
                            }

                            fn command_for_update<'b>() -> clap::Command {
                                let #app_var = clap::Command::new(#name);
                                <Self as clap::Subcommand>::augment_subcommands_for_update(#app_var)
                                    .subcommand_required(false)
                                    .arg_required_else_help(false)
                            }
                        }
                    })
                }
            }
            
            pub mod parser
            {
                use ::
                {
                    *,
                };
                // Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
                // Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
                // Ana Hobden (@hoverbear) <operator@hoverbear.org>
                //
                // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
                // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
                // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
                // option. This file may not be copied, modified, or distributed
                // except according to those terms.
                //
                // This work was derived from Structopt (https://github.com/TeXitoi/structopt)
                // commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
                // MIT/Apache 2.0 license.

                use proc_macro2::TokenStream;
                use quote::quote;
                use syn::Ident;
                use syn::Variant;
                use syn::{
                    self, punctuated::Punctuated, token::Comma, Data, DataStruct, DeriveInput, Field, Fields,
                    Generics,
                };

                use crate::derives::args::collect_args_fields;
                use crate::derives::{args, into_app, subcommand};
                use crate::item::Item;
                use crate::item::Name;

                pub fn derive_parser(input: &DeriveInput) -> Result<TokenStream, syn::Error> {
                    let ident = &input.ident;
                    let pkg_name = std::env::var("CARGO_PKG_NAME").ok().unwrap_or_default();

                    match input.data {
                        Data::Struct(DataStruct {
                            fields: Fields::Named(ref fields),
                            ..
                        }) => {
                            let name = Name::Assigned(quote!(#pkg_name));
                            let item = Item::from_args_struct(input, name)?;
                            let fields = collect_args_fields(&item, fields)?;
                            gen_for_struct(&item, ident, &input.generics, &fields)
                        }
                        Data::Struct(DataStruct {
                            fields: Fields::Unit,
                            ..
                        }) => {
                            let name = Name::Assigned(quote!(#pkg_name));
                            let item = Item::from_args_struct(input, name)?;
                            let fields = Punctuated::<Field, Comma>::new();
                            let fields = fields
                                .iter()
                                .map(|field| {
                                    let item = Item::from_args_field(field, item.casing(), item.env_casing())?;
                                    Ok((field, item))
                                })
                                .collect::<Result<Vec<_>, syn::Error>>()?;
                            gen_for_struct(&item, ident, &input.generics, &fields)
                        }
                        Data::Enum(ref e) => {
                            let name = Name::Assigned(quote!(#pkg_name));
                            let item = Item::from_subcommand_enum(input, name)?;
                            let variants = e
                                .variants
                                .iter()
                                .map(|variant| {
                                    let item =
                                        Item::from_subcommand_variant(variant, item.casing(), item.env_casing())?;
                                    Ok((variant, item))
                                })
                                .collect::<Result<Vec<_>, syn::Error>>()?;
                            gen_for_enum(&item, ident, &input.generics, &variants)
                        }
                        _ => abort_call_site!("`#[derive(Parser)]` only supports non-tuple structs and enums"),
                    }
                }

                fn gen_for_struct(
                    item: &Item,
                    item_name: &Ident,
                    generics: &Generics,
                    fields: &[(&Field, Item)],
                ) -> Result<TokenStream, syn::Error> {
                    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

                    let into_app = into_app::gen_for_struct(item, item_name, generics)?;
                    let args = args::gen_for_struct(item, item_name, generics, fields)?;

                    Ok(quote! {
                        #[automatically_derived]
                        #[allow(
                            unused_qualifications,
                            clippy::redundant_locals,
                        )]
                        impl #impl_generics clap::Parser for #item_name #ty_generics #where_clause {}

                        #into_app
                        #args
                    })
                }

                fn gen_for_enum(
                    item: &Item,
                    item_name: &Ident,
                    generics: &Generics,
                    variants: &[(&Variant, Item)],
                ) -> Result<TokenStream, syn::Error> {
                    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

                    let into_app = into_app::gen_for_enum(item, item_name, generics)?;
                    let subcommand = subcommand::gen_for_enum(item, item_name, generics, variants)?;

                    Ok(quote! {
                        #[automatically_derived]
                        impl #impl_generics clap::Parser for #item_name #ty_generics #where_clause {}

                        #into_app
                        #subcommand
                    })
                }
            }
            
            pub mod subcommand
            {
                use ::
                {
                    *,
                };
                // Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
                // Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
                // Ana Hobden (@hoverbear) <operator@hoverbear.org>
                //
                // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
                // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
                // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
                // option. This file may not be copied, modified, or distributed
                // except according to those terms.
                //
                // This work was derived from Structopt (https://github.com/TeXitoi/structopt)
                // commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
                // MIT/Apache 2.0 license.

                use proc_macro2::{Ident, Span, TokenStream};
                use quote::{format_ident, quote, quote_spanned};
                use syn::{spanned::Spanned, Data, DeriveInput, FieldsUnnamed, Generics, Variant};

                use crate::derives::args;
                use crate::derives::args::collect_args_fields;
                use crate::item::{Item, Kind, Name};
                use crate::utils::{is_simple_ty, subty_if_name};

                pub fn derive_subcommand(input: &DeriveInput) -> Result<TokenStream, syn::Error> {
                    let ident = &input.ident;

                    match input.data {
                        Data::Enum(ref e) => {
                            let name = Name::Derived(ident.clone());
                            let item = Item::from_subcommand_enum(input, name)?;
                            let variants = e
                                .variants
                                .iter()
                                .map(|variant| {
                                    let item =
                                        Item::from_subcommand_variant(variant, item.casing(), item.env_casing())?;
                                    Ok((variant, item))
                                })
                                .collect::<Result<Vec<_>, syn::Error>>()?;
                            gen_for_enum(&item, ident, &input.generics, &variants)
                        }
                        _ => abort_call_site!("`#[derive(Subcommand)]` only supports enums"),
                    }
                }

                pub fn gen_for_enum(
                    item: &Item,
                    item_name: &Ident,
                    generics: &Generics,
                    variants: &[(&Variant, Item)],
                ) -> Result<TokenStream, syn::Error> {
                    if !matches!(&*item.kind(), Kind::Command(_)) {
                        abort! { item.kind().span(),
                            "`{}` cannot be used with `command`",
                            item.kind().name(),
                        }
                    }

                    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

                    let from_arg_matches = gen_from_arg_matches(variants)?;
                    let update_from_arg_matches = gen_update_from_arg_matches(variants)?;

                    let augmentation = gen_augment(variants, item, false)?;
                    let augmentation_update = gen_augment(variants, item, true)?;
                    let has_subcommand = gen_has_subcommand(variants)?;

                    Ok(quote! {
                        #[allow(
                            dead_code,
                            unreachable_code,
                            unused_variables,
                            unused_braces,
                            unused_qualifications,
                        )]
                        #[allow(
                            clippy::style,
                            clippy::complexity,
                            clippy::pedantic,
                            clippy::restriction,
                            clippy::perf,
                            clippy::deprecated,
                            clippy::nursery,
                            clippy::cargo,
                            clippy::suspicious_else_formatting,
                            clippy::almost_swapped,
                            clippy::redundant_locals,
                        )]
                        #[automatically_derived]
                        impl #impl_generics clap::FromArgMatches for #item_name #ty_generics #where_clause {
                            fn from_arg_matches(__clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
                                Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
                            }

                            #from_arg_matches

                            fn update_from_arg_matches(&mut self, __clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<(), clap::Error> {
                                self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
                            }
                            #update_from_arg_matches
                        }

                        #[allow(
                            dead_code,
                            unreachable_code,
                            unused_variables,
                            unused_braces,
                            unused_qualifications,
                        )]
                        #[allow(
                            clippy::style,
                            clippy::complexity,
                            clippy::pedantic,
                            clippy::restriction,
                            clippy::perf,
                            clippy::deprecated,
                            clippy::nursery,
                            clippy::cargo,
                            clippy::suspicious_else_formatting,
                            clippy::almost_swapped,
                            clippy::redundant_locals,
                        )]
                        #[automatically_derived]
                        impl #impl_generics clap::Subcommand for #item_name #ty_generics #where_clause {
                            fn augment_subcommands <'b>(__clap_app: clap::Command) -> clap::Command {
                                #augmentation
                            }
                            fn augment_subcommands_for_update <'b>(__clap_app: clap::Command) -> clap::Command {
                                #augmentation_update
                            }
                            fn has_subcommand(__clap_name: &str) -> bool {
                                #has_subcommand
                            }
                        }
                    })
                }

                fn gen_augment(
                    variants: &[(&Variant, Item)],
                    parent_item: &Item,
                    override_required: bool,
                ) -> Result<TokenStream, syn::Error> {
                    use syn::Fields::{Named, Unit, Unnamed};

                    let app_var = Ident::new("__clap_app", Span::call_site());

                    let mut subcommands = Vec::new();
                    for (variant, item) in variants {
                        let kind = item.kind();

                        let genned = match &*kind {
                            Kind::Skip(_, _) | Kind::Arg(_) | Kind::FromGlobal(_) | Kind::Value => None,

                            Kind::ExternalSubcommand => {
                                let ty = match variant.fields {
                                    Unnamed(ref fields) if fields.unnamed.len() == 1 => &fields.unnamed[0].ty,

                                    _ => abort!(
                                        variant,
                                        "The enum variant marked with `external_subcommand` must be \
                                            a single-typed tuple, and the type must be either `Vec<String>` \
                                            or `Vec<OsString>`."
                                    ),
                                };
                                let deprecations = if !override_required {
                                    item.deprecations()
                                } else {
                                    quote!()
                                };
                                let subty = subty_if_name(ty, "Vec").ok_or_else(|| {
                                    format_err!(
                                        ty.span(),
                                        "The type must be `Vec<_>` \
                                            to be used with `external_subcommand`."
                                    )
                                })?;
                                let subcommand = quote_spanned! { kind.span()=>
                                    #deprecations
                                    let #app_var = #app_var
                                        .external_subcommand_value_parser(clap::value_parser!(#subty));
                                };
                                Some(subcommand)
                            }

                            Kind::Flatten(_) => match variant.fields {
                                Unnamed(FieldsUnnamed { ref unnamed, .. }) if unnamed.len() == 1 => {
                                    let ty = &unnamed[0].ty;
                                    let deprecations = if !override_required {
                                        item.deprecations()
                                    } else {
                                        quote!()
                                    };
                                    let next_help_heading = item.next_help_heading();
                                    let next_display_order = item.next_display_order();
                                    let subcommand = if override_required {
                                        quote! {
                                            #deprecations
                                            let #app_var = #app_var
                                                #next_help_heading
                                                #next_display_order;
                                            let #app_var = <#ty as clap::Subcommand>::augment_subcommands_for_update(#app_var);
                                        }
                                    } else {
                                        quote! {
                                            #deprecations
                                            let #app_var = #app_var
                                                #next_help_heading
                                                #next_display_order;
                                            let #app_var = <#ty as clap::Subcommand>::augment_subcommands(#app_var);
                                        }
                                    };
                                    Some(subcommand)
                                }
                                _ => abort!(
                                    variant,
                                    "`flatten` is usable only with single-typed tuple variants"
                                ),
                            },

                            Kind::Subcommand(_) => {
                                let subcommand_var = Ident::new("__clap_subcommand", Span::call_site());
                                let arg_block = match variant.fields {
                                    Named(_) => {
                                        abort!(variant, "non single-typed tuple enums are not supported")
                                    }
                                    Unit => quote!( #subcommand_var ),
                                    Unnamed(FieldsUnnamed { ref unnamed, .. }) if unnamed.len() == 1 => {
                                        let ty = &unnamed[0].ty;
                                        if override_required {
                                            quote_spanned! { ty.span()=>
                                                {
                                                    <#ty as clap::Subcommand>::augment_subcommands_for_update(#subcommand_var)
                                                }
                                            }
                                        } else {
                                            quote_spanned! { ty.span()=>
                                                {
                                                    <#ty as clap::Subcommand>::augment_subcommands(#subcommand_var)
                                                }
                                            }
                                        }
                                    }
                                    Unnamed(..) => {
                                        abort!(variant, "non single-typed tuple enums are not supported")
                                    }
                                };

                                let name = item.cased_name();
                                let deprecations = if !override_required {
                                    item.deprecations()
                                } else {
                                    quote!()
                                };
                                let initial_app_methods = item.initial_top_level_methods();
                                let final_from_attrs = item.final_top_level_methods();
                                let override_methods = if override_required {
                                    quote_spanned! { kind.span()=>
                                        .subcommand_required(false)
                                        .arg_required_else_help(false)
                                    }
                                } else {
                                    quote!()
                                };
                                let subcommand = quote! {
                                    let #app_var = #app_var.subcommand({
                                        #deprecations;
                                        let #subcommand_var = clap::Command::new(#name);
                                        let #subcommand_var = #subcommand_var
                                            .subcommand_required(true)
                                            .arg_required_else_help(true);
                                        let #subcommand_var = #subcommand_var #initial_app_methods;
                                        let #subcommand_var = #arg_block;
                                        #subcommand_var #final_from_attrs #override_methods
                                    });
                                };
                                Some(subcommand)
                            }

                            Kind::Command(_) => {
                                let subcommand_var = Ident::new("__clap_subcommand", Span::call_site());
                                let sub_augment = match variant.fields {
                                    Named(ref fields) => {
                                        // Defer to `gen_augment` for adding cmd methods
                                        let fields = collect_args_fields(item, fields)?;
                                        args::gen_augment(&fields, &subcommand_var, item, override_required)?
                                    }
                                    Unit => {
                                        let arg_block = quote!( #subcommand_var );
                                        let initial_app_methods = item.initial_top_level_methods();
                                        let final_from_attrs = item.final_top_level_methods();
                                        quote! {
                                            let #subcommand_var = #subcommand_var #initial_app_methods;
                                            let #subcommand_var = #arg_block;
                                            #subcommand_var #final_from_attrs
                                        }
                                    }
                                    Unnamed(FieldsUnnamed { ref unnamed, .. }) if unnamed.len() == 1 => {
                                        let ty = &unnamed[0].ty;
                                        let arg_block = if override_required {
                                            quote_spanned! { ty.span()=>
                                                {
                                                    <#ty as clap::Args>::augment_args_for_update(#subcommand_var)
                                                }
                                            }
                                        } else {
                                            quote_spanned! { ty.span()=>
                                                {
                                                    <#ty as clap::Args>::augment_args(#subcommand_var)
                                                }
                                            }
                                        };
                                        let initial_app_methods = item.initial_top_level_methods();
                                        let final_from_attrs = item.final_top_level_methods();
                                        quote! {
                                            let #subcommand_var = #subcommand_var #initial_app_methods;
                                            let #subcommand_var = #arg_block;
                                            #subcommand_var #final_from_attrs
                                        }
                                    }
                                    Unnamed(..) => {
                                        abort!(variant, "non single-typed tuple enums are not supported")
                                    }
                                };

                                let deprecations = if !override_required {
                                    item.deprecations()
                                } else {
                                    quote!()
                                };
                                let name = item.cased_name();
                                let subcommand = quote! {
                                    let #app_var = #app_var.subcommand({
                                        #deprecations
                                        let #subcommand_var = clap::Command::new(#name);
                                        #sub_augment
                                    });
                                };
                                Some(subcommand)
                            }
                        };
                        subcommands.push(genned);
                    }

                    let deprecations = if !override_required {
                        parent_item.deprecations()
                    } else {
                        quote!()
                    };
                    let initial_app_methods = parent_item.initial_top_level_methods();
                    let final_app_methods = parent_item.final_top_level_methods();
                    Ok(quote! {
                        #deprecations;
                        let #app_var = #app_var #initial_app_methods;
                        #( #subcommands )*;
                        #app_var #final_app_methods
                    })
                }

                fn gen_has_subcommand(variants: &[(&Variant, Item)]) -> Result<TokenStream, syn::Error> {
                    use syn::Fields::Unnamed;

                    let mut ext_subcmd = false;

                    let (flatten_variants, variants): (Vec<_>, Vec<_>) = variants
                        .iter()
                        .filter_map(|(variant, item)| {
                            let kind = item.kind();
                            match &*kind {
                                Kind::Skip(_, _) | Kind::Arg(_) | Kind::FromGlobal(_) | Kind::Value => None,

                                Kind::ExternalSubcommand => {
                                    ext_subcmd = true;
                                    None
                                }
                                Kind::Flatten(_) | Kind::Subcommand(_) | Kind::Command(_) => Some((variant, item)),
                            }
                        })
                        .partition(|(_, item)| {
                            let kind = item.kind();
                            matches!(&*kind, Kind::Flatten(_))
                        });

                    let subcommands = variants.iter().map(|(_variant, item)| {
                        let sub_name = item.cased_name();
                        quote! {
                            if #sub_name == __clap_name {
                                return true
                            }
                        }
                    });
                    let child_subcommands = flatten_variants
                        .iter()
                        .map(|(variant, _attrs)| match variant.fields {
                            Unnamed(ref fields) if fields.unnamed.len() == 1 => {
                                let ty = &fields.unnamed[0].ty;
                                Ok(quote! {
                                    if <#ty as clap::Subcommand>::has_subcommand(__clap_name) {
                                        return true;
                                    }
                                })
                            }
                            _ => abort!(
                                variant,
                                "`flatten` is usable only with single-typed tuple variants"
                            ),
                        })
                        .collect::<Result<Vec<_>, syn::Error>>()?;

                    let genned = if ext_subcmd {
                        quote! { true }
                    } else {
                        quote! {
                            #( #subcommands )*

                            #( #child_subcommands )else*

                            false
                        }
                    };
                    Ok(genned)
                }

                fn gen_from_arg_matches(variants: &[(&Variant, Item)]) -> Result<TokenStream, syn::Error> {
                    use syn::Fields::{Named, Unit, Unnamed};

                    let subcommand_name_var = format_ident!("__clap_name");
                    let sub_arg_matches_var = format_ident!("__clap_arg_matches");

                    let mut ext_subcmd = None;
                    let mut flatten_variants = Vec::new();
                    let mut unflatten_variants = Vec::new();
                    for (variant, item) in variants {
                        let kind = item.kind();
                        match &*kind {
                            Kind::Skip(_, _) | Kind::Arg(_) | Kind::FromGlobal(_) | Kind::Value => {}

                            Kind::ExternalSubcommand => {
                                if ext_subcmd.is_some() {
                                    abort!(
                                        item.kind().span(),
                                        "Only one variant can be marked with `external_subcommand`, \
                                        this is the second"
                                    );
                                }

                                let ty = match variant.fields {
                                    Unnamed(ref fields) if fields.unnamed.len() == 1 => &fields.unnamed[0].ty,

                                    _ => abort!(
                                        variant,
                                        "The enum variant marked with `external_subcommand` must be \
                                        a single-typed tuple, and the type must be either `Vec<String>` \
                                        or `Vec<OsString>`."
                                    ),
                                };

                                let (span, str_ty) = match subty_if_name(ty, "Vec") {
                                    Some(subty) => {
                                        if is_simple_ty(subty, "String") {
                                            (subty.span(), quote!(::std::string::String))
                                        } else if is_simple_ty(subty, "OsString") {
                                            (subty.span(), quote!(::std::ffi::OsString))
                                        } else {
                                            abort!(
                                                ty.span(),
                                                "The type must be either `Vec<String>` or `Vec<OsString>` \
                                                to be used with `external_subcommand`."
                                            );
                                        }
                                    }

                                    None => abort!(
                                        ty.span(),
                                        "The type must be either `Vec<String>` or `Vec<OsString>` \
                                        to be used with `external_subcommand`."
                                    ),
                                };

                                ext_subcmd = Some((span, &variant.ident, str_ty));
                            }
                            Kind::Flatten(_) | Kind::Subcommand(_) | Kind::Command(_) => {
                                if matches!(&*item.kind(), Kind::Flatten(_)) {
                                    flatten_variants.push((variant, item));
                                } else {
                                    unflatten_variants.push((variant, item));
                                }
                            }
                        }
                    }

                    let subcommands = unflatten_variants.iter().map(|(variant, item)| {
                        let sub_name = item.cased_name();
                        let variant_name = &variant.ident;
                        let constructor_block = match variant.fields {
                            Named(ref fields) => {
                                let fields = collect_args_fields(item, fields)?;
                                args::gen_constructor(&fields)?
                            },
                            Unit => quote!(),
                            Unnamed(ref fields) if fields.unnamed.len() == 1 => {
                                let ty = &fields.unnamed[0].ty;
                                quote!( ( <#ty as clap::FromArgMatches>::from_arg_matches_mut(__clap_arg_matches)? ) )
                            }
                            Unnamed(..) => abort_call_site!("{}: tuple enums are not supported", variant.ident),
                        };

                        Ok(quote! {
                            if #subcommand_name_var == #sub_name && !#sub_arg_matches_var.contains_id("") {
                                return ::std::result::Result::Ok(Self :: #variant_name #constructor_block)
                            }
                        })
                    }).collect::<Result<Vec<_>, syn::Error>>()?;
                    let child_subcommands = flatten_variants.iter().map(|(variant, _attrs)| {
                        let variant_name = &variant.ident;
                        match variant.fields {
                            Unnamed(ref fields) if fields.unnamed.len() == 1 => {
                                let ty = &fields.unnamed[0].ty;
                                Ok(quote! {
                                    if __clap_arg_matches
                                        .subcommand_name()
                                        .map(|__clap_name| <#ty as clap::Subcommand>::has_subcommand(__clap_name))
                                        .unwrap_or_default()
                                    {
                                        let __clap_res = <#ty as clap::FromArgMatches>::from_arg_matches_mut(__clap_arg_matches)?;
                                        return ::std::result::Result::Ok(Self :: #variant_name (__clap_res));
                                    }
                                })
                            }
                            _ => abort!(
                                variant,
                                "`flatten` is usable only with single-typed tuple variants"
                            ),
                        }
                    }).collect::<Result<Vec<_>, syn::Error>>()?;

                    let wildcard = match ext_subcmd {
                        Some((span, var_name, str_ty)) => quote_spanned! { span=>
                                ::std::result::Result::Ok(Self::#var_name(
                                    ::std::iter::once(#str_ty::from(#subcommand_name_var))
                                    .chain(
                                        #sub_arg_matches_var
                                            .remove_many::<#str_ty>("")
                                            .unwrap()
                                            .map(#str_ty::from)
                                    )
                                    .collect::<::std::vec::Vec<_>>()
                                ))
                        },

                        None => quote! {
                            ::std::result::Result::Err(clap::Error::raw(clap::error::ErrorKind::InvalidSubcommand, format!("The subcommand '{}' wasn't recognized", #subcommand_name_var)))
                        },
                    };

                    let raw_deprecated = args::raw_deprecated();
                    Ok(quote! {
                        fn from_arg_matches_mut(__clap_arg_matches: &mut clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
                            #raw_deprecated

                            #( #child_subcommands )else*

                            if let Some((#subcommand_name_var, mut __clap_arg_sub_matches)) = __clap_arg_matches.remove_subcommand() {
                                let #sub_arg_matches_var = &mut __clap_arg_sub_matches;
                                #( #subcommands )*

                                #wildcard
                            } else {
                                ::std::result::Result::Err(clap::Error::raw(clap::error::ErrorKind::MissingSubcommand, "A subcommand is required but one was not provided."))
                            }
                        }
                    })
                }

                fn gen_update_from_arg_matches(variants: &[(&Variant, Item)]) -> Result<TokenStream, syn::Error> {
                    use syn::Fields::{Named, Unit, Unnamed};

                    let (flatten, variants): (Vec<_>, Vec<_>) = variants
                        .iter()
                        .filter_map(|(variant, item)| {
                            let kind = item.kind();
                            match &*kind {
                                // Fallback to `from_arg_matches_mut`
                                Kind::Skip(_, _)
                                | Kind::Arg(_)
                                | Kind::FromGlobal(_)
                                | Kind::Value
                                | Kind::ExternalSubcommand => None,
                                Kind::Flatten(_) | Kind::Subcommand(_) | Kind::Command(_) => Some((variant, item)),
                            }
                        })
                        .partition(|(_, item)| {
                            let kind = item.kind();
                            matches!(&*kind, Kind::Flatten(_))
                        });

                    let subcommands = variants.iter().map(|(variant, item)| {
                        let sub_name = item.cased_name();
                        let variant_name = &variant.ident;
                        let (pattern, updater) = match variant.fields {
                            Named(ref fields) => {
                                let field_names = fields.named.iter().map(|field| {
                                    field.ident.as_ref().unwrap()
                                }).collect::<Vec<_>>();
                                let fields = collect_args_fields(item, fields)?;
                                let update = args::gen_updater(&fields, false)?;
                                (quote!( { #( #field_names, )* }), quote!( { #update } ))
                            }
                            Unit => (quote!(), quote!({})),
                            Unnamed(ref fields) => {
                                if fields.unnamed.len() == 1 {
                                    (
                                        quote!((ref mut __clap_arg)),
                                        quote!(clap::FromArgMatches::update_from_arg_matches_mut(
                                            __clap_arg,
                                            __clap_arg_matches
                                        )?),
                                    )
                                } else {
                                    abort_call_site!("{}: tuple enums are not supported", variant.ident)
                                }
                            }
                        };

                        Ok(quote! {
                            Self :: #variant_name #pattern if #sub_name == __clap_name => {
                                let (_, mut __clap_arg_sub_matches) = __clap_arg_matches.remove_subcommand().unwrap();
                                let __clap_arg_matches = &mut __clap_arg_sub_matches;
                                #updater
                            }
                        })
                    }).collect::<Result<Vec<_>, _>>()?;

                    let child_subcommands = flatten.iter().map(|(variant, _attrs)| {
                        let variant_name = &variant.ident;
                        match variant.fields {
                            Unnamed(ref fields) if fields.unnamed.len() == 1 => {
                                let ty = &fields.unnamed[0].ty;
                                Ok(quote! {
                                    if <#ty as clap::Subcommand>::has_subcommand(__clap_name) {
                                        if let Self :: #variant_name (child) = s {
                                            <#ty as clap::FromArgMatches>::update_from_arg_matches_mut(child, __clap_arg_matches)?;
                                            return ::std::result::Result::Ok(());
                                        }
                                    }
                                })
                            }
                            _ => abort!(
                                variant,
                                "`flatten` is usable only with single-typed tuple variants"
                            ),
                        }
                    }).collect::<Result<Vec<_>, _>>()?;

                    let raw_deprecated = args::raw_deprecated();
                    Ok(quote! {
                        fn update_from_arg_matches_mut<'b>(
                            &mut self,
                            __clap_arg_matches: &mut clap::ArgMatches,
                        ) -> ::std::result::Result<(), clap::Error> {
                            #raw_deprecated

                            if let Some(__clap_name) = __clap_arg_matches.subcommand_name() {
                                match self {
                                    #( #subcommands ),*
                                    s => {
                                        #( #child_subcommands )*
                                        *s = <Self as clap::FromArgMatches>::from_arg_matches_mut(__clap_arg_matches)?;
                                    }
                                }
                            }
                            ::std::result::Result::Ok(())
                        }
                    })
                }
            }
            
            pub mod value_enum
            {
                use ::
                {
                    *,
                };
                // Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
                // Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
                // Ana Hobden (@hoverbear) <operator@hoverbear.org>
                //
                // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
                // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
                // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
                // option. This file may not be copied, modified, or distributed
                // except according to those terms.

                use proc_macro2::TokenStream;
                use quote::quote;
                use quote::quote_spanned;
                use syn::{spanned::Spanned, Data, DeriveInput, Fields, Ident, Variant};

                use crate::item::{Item, Kind, Name};

                pub fn derive_value_enum(input: &DeriveInput) -> Result<TokenStream, syn::Error> {
                    let ident = &input.ident;

                    match input.data {
                        Data::Enum(ref e) => {
                            let name = Name::Derived(ident.clone());
                            let item = Item::from_value_enum(input, name)?;
                            let mut variants = Vec::new();
                            for variant in &e.variants {
                                let item =
                                    Item::from_value_enum_variant(variant, item.casing(), item.env_casing())?;
                                variants.push((variant, item));
                            }
                            gen_for_enum(&item, ident, &variants)
                        }
                        _ => abort_call_site!("`#[derive(ValueEnum)]` only supports enums"),
                    }
                }

                pub fn gen_for_enum(
                    item: &Item,
                    item_name: &Ident,
                    variants: &[(&Variant, Item)],
                ) -> Result<TokenStream, syn::Error> {
                    if !matches!(&*item.kind(), Kind::Value) {
                        abort! { item.kind().span(),
                            "`{}` cannot be used with `value`",
                            item.kind().name(),
                        }
                    }

                    let lits = lits(variants)?;
                    let value_variants = gen_value_variants(&lits);
                    let to_possible_value = gen_to_possible_value(item, &lits);

                    Ok(quote! {
                        #[allow(
                            dead_code,
                            unreachable_code,
                            unused_variables,
                            unused_braces,
                            unused_qualifications,
                        )]
                        #[allow(
                            clippy::style,
                            clippy::complexity,
                            clippy::pedantic,
                            clippy::restriction,
                            clippy::perf,
                            clippy::deprecated,
                            clippy::nursery,
                            clippy::cargo,
                            clippy::suspicious_else_formatting,
                            clippy::almost_swapped,
                            clippy::redundant_locals,
                        )]
                        #[automatically_derived]
                        impl clap::ValueEnum for #item_name {
                            #value_variants
                            #to_possible_value
                        }
                    })
                }

                fn lits(variants: &[(&Variant, Item)]) -> Result<Vec<(TokenStream, Ident)>, syn::Error> {
                    let mut genned = Vec::new();
                    for (variant, item) in variants {
                        if let Kind::Skip(_, _) = &*item.kind() {
                            continue;
                        }
                        if !matches!(variant.fields, Fields::Unit) {
                            abort!(variant.span(), "`#[derive(ValueEnum)]` only supports unit variants. Non-unit variants must be skipped");
                        }
                        let fields = item.field_methods();
                        let deprecations = item.deprecations();
                        let name = item.cased_name();
                        genned.push((
                            quote_spanned! { variant.span()=> {
                                #deprecations
                                clap::builder::PossibleValue::new(#name)
                                #fields
                            }},
                            variant.ident.clone(),
                        ));
                    }
                    Ok(genned)
                }

                fn gen_value_variants(lits: &[(TokenStream, Ident)]) -> TokenStream {
                    let lit = lits.iter().map(|l| &l.1).collect::<Vec<_>>();

                    quote! {
                        fn value_variants<'a>() -> &'a [Self]{
                            &[#(Self::#lit),*]
                        }
                    }
                }

                fn gen_to_possible_value(item: &Item, lits: &[(TokenStream, Ident)]) -> TokenStream {
                    let (lit, variant): (Vec<TokenStream>, Vec<Ident>) = lits.iter().cloned().unzip();

                    let deprecations = item.deprecations();

                    quote! {
                        fn to_possible_value<'a>(&self) -> ::std::option::Option<clap::builder::PossibleValue> {
                            #deprecations
                            match self {
                                #(Self::#variant => Some(#lit),)*
                                _ => None
                            }
                        }
                    }
                }
            }
            
            pub use self::parser::derive_parser;
            pub use args::derive_args;
            pub use subcommand::derive_subcommand;
            pub use value_enum::derive_value_enum;
        }

        pub mod dummies
        {
            //! Dummy implementations that we emit along with an error.
            use ::
            { 
                *,
            };
            
            use proc_macro2::Ident;
            use quote::quote;

            #[must_use]
            pub fn parser(name: &Ident) -> proc_macro2::TokenStream {
                let into_app = into_app(name);
                quote!(
                    #[automatically_derived]
                    impl clap::Parser for #name {}
                    #into_app
                )
            }

            #[must_use]
            pub fn into_app(name: &Ident) -> proc_macro2::TokenStream {
                quote! {
                    #[automatically_derived]
                    impl clap::CommandFactory for #name {
                        fn command<'b>() -> clap::Command {
                            unimplemented!()
                        }
                        fn command_for_update<'b>() -> clap::Command {
                            unimplemented!()
                        }
                    }
                }
            }

            #[must_use]
            pub fn from_arg_matches(name: &Ident) -> proc_macro2::TokenStream {
                quote! {
                    #[automatically_derived]
                    impl clap::FromArgMatches for #name {
                        fn from_arg_matches(_m: &clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
                            unimplemented!()
                        }
                        fn update_from_arg_matches(&mut self, matches: &clap::ArgMatches) -> ::std::result::Result<(), clap::Error>{
                            unimplemented!()
                        }
                    }
                }
            }

            #[must_use]
            pub fn subcommand(name: &Ident) -> proc_macro2::TokenStream {
                let from_arg_matches = from_arg_matches(name);
                quote! {
                    #[automatically_derived]
                    impl clap::Subcommand for #name {
                        fn augment_subcommands(_cmd: clap::Command) -> clap::Command {
                            unimplemented!()
                        }
                        fn augment_subcommands_for_update(_cmd: clap::Command) -> clap::Command {
                            unimplemented!()
                        }
                        fn has_subcommand(name: &str) -> bool {
                            unimplemented!()
                        }
                    }
                    #from_arg_matches
                }
            }

            #[must_use]
            pub fn args(name: &Ident) -> proc_macro2::TokenStream {
                let from_arg_matches = from_arg_matches(name);
                quote! {
                    #[automatically_derived]
                    impl clap::Args for #name {
                        fn augment_args(_cmd: clap::Command) -> clap::Command {
                            unimplemented!()
                        }
                        fn augment_args_for_update(_cmd: clap::Command) -> clap::Command {
                            unimplemented!()
                        }
                    }
                    #from_arg_matches
                }
            }

            #[must_use]
            pub fn value_enum(name: &Ident) -> proc_macro2::TokenStream {
                quote! {
                    #[automatically_derived]
                    impl clap::ValueEnum for #name {
                        fn value_variants<'a>() -> &'a [Self]{
                            unimplemented!()
                        }
                        fn from_str(_input: &str, _ignore_case: bool) -> ::std::result::Result<Self, String> {
                            unimplemented!()
                        }
                        fn to_possible_value<'a>(&self) -> ::std::option::Option<clap::builder::PossibleValue>{
                            unimplemented!()
                        }
                    }
                }
            }
        }

        pub mod item
        {
            use ::
            { 
                *,
            };
            // Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
            // Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
            // Ana Hobden (@hoverbear) <operator@hoverbear.org>
            //
            // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
            // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
            // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. This file may not be copied, modified, or distributed
            // except according to those terms.
            //
            // This work was derived from Structopt (https://github.com/TeXitoi/structopt)
            // commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
            // MIT/Apache 2.0 license.

            use std::env;

            use heck::{ToKebabCase, ToLowerCamelCase, ToShoutySnakeCase, ToSnakeCase, ToUpperCamelCase};
            use proc_macro2::{self, Span, TokenStream};
            use quote::{format_ident, quote, quote_spanned, ToTokens};
            use syn::DeriveInput;
            use syn::{self, ext::IdentExt, spanned::Spanned, Attribute, Field, Ident, LitStr, Type, Variant};

            use crate::attr::{AttrKind, AttrValue, ClapAttr, MagicAttrName};
            use crate::utils::{extract_doc_comment, format_doc_comment, inner_type, is_simple_ty, Sp, Ty};

            /// Default casing style for generated arguments.
            pub const DEFAULT_CASING: CasingStyle = CasingStyle::Kebab;

            /// Default casing style for environment variables
            pub const DEFAULT_ENV_CASING: CasingStyle = CasingStyle::ScreamingSnake;

            #[derive(Clone)]
            pub struct Item {
                name: Name,
                casing: Sp<CasingStyle>,
                env_casing: Sp<CasingStyle>,
                ty: Option<Type>,
                doc_comment: Vec<Method>,
                methods: Vec<Method>,
                deprecations: Vec<Deprecation>,
                value_parser: Option<ValueParser>,
                action: Option<Action>,
                verbatim_doc_comment: bool,
                force_long_help: bool,
                next_display_order: Option<Method>,
                next_help_heading: Option<Method>,
                is_enum: bool,
                is_positional: bool,
                skip_group: bool,
                group_id: Name,
                group_methods: Vec<Method>,
                kind: Sp<Kind>,
            }

            impl Item {
                pub fn from_args_struct(input: &DeriveInput, name: Name) -> Result<Self, syn::Error> {
                    let ident = input.ident.clone();
                    let span = input.ident.span();
                    let attrs = &input.attrs;
                    let argument_casing = Sp::new(DEFAULT_CASING, span);
                    let env_casing = Sp::new(DEFAULT_ENV_CASING, span);
                    let kind = Sp::new(Kind::Command(Sp::new(Ty::Other, span)), span);

                    let mut res = Self::new(name, ident, None, argument_casing, env_casing, kind);
                    let parsed_attrs = ClapAttr::parse_all(attrs)?;
                    res.infer_kind(&parsed_attrs)?;
                    res.push_attrs(&parsed_attrs)?;
                    res.push_doc_comment(attrs, "about", Some("long_about"));

                    Ok(res)
                }

                pub fn from_subcommand_enum(
                    input: &DeriveInput,
                    name: Name,
                ) -> Result<Self, syn::Error> {
                    let ident = input.ident.clone();
                    let span = input.ident.span();
                    let attrs = &input.attrs;
                    let argument_casing = Sp::new(DEFAULT_CASING, span);
                    let env_casing = Sp::new(DEFAULT_ENV_CASING, span);
                    let kind = Sp::new(Kind::Command(Sp::new(Ty::Other, span)), span);

                    let mut res = Self::new(name, ident, None, argument_casing, env_casing, kind);
                    let parsed_attrs = ClapAttr::parse_all(attrs)?;
                    res.infer_kind(&parsed_attrs)?;
                    res.push_attrs(&parsed_attrs)?;
                    res.push_doc_comment(attrs, "about", Some("long_about"));

                    Ok(res)
                }

                pub fn from_value_enum(input: &DeriveInput, name: Name) -> Result<Self, syn::Error> {
                    let ident = input.ident.clone();
                    let span = input.ident.span();
                    let attrs = &input.attrs;
                    let argument_casing = Sp::new(DEFAULT_CASING, span);
                    let env_casing = Sp::new(DEFAULT_ENV_CASING, span);
                    let kind = Sp::new(Kind::Value, span);

                    let mut res = Self::new(name, ident, None, argument_casing, env_casing, kind);
                    let parsed_attrs = ClapAttr::parse_all(attrs)?;
                    res.infer_kind(&parsed_attrs)?;
                    res.push_attrs(&parsed_attrs)?;
                    // Ignoring `push_doc_comment` as there is no top-level clap builder to add documentation
                    // to

                    if res.has_explicit_methods() {
                        abort!(
                            res.methods[0].name.span(),
                            "{} doesn't exist for `ValueEnum` enums",
                            res.methods[0].name
                        );
                    }

                    Ok(res)
                }

                pub fn from_subcommand_variant(
                    variant: &Variant,
                    struct_casing: Sp<CasingStyle>,
                    env_casing: Sp<CasingStyle>,
                ) -> Result<Self, syn::Error> {
                    let name = variant.ident.clone();
                    let ident = variant.ident.clone();
                    let span = variant.span();
                    let ty = match variant.fields {
                        syn::Fields::Unnamed(syn::FieldsUnnamed { ref unnamed, .. }) if unnamed.len() == 1 => {
                            Ty::from_syn_ty(&unnamed[0].ty)
                        }
                        syn::Fields::Named(_) | syn::Fields::Unnamed(..) | syn::Fields::Unit => {
                            Sp::new(Ty::Other, span)
                        }
                    };
                    let kind = Sp::new(Kind::Command(ty), span);
                    let mut res = Self::new(
                        Name::Derived(name),
                        ident,
                        None,
                        struct_casing,
                        env_casing,
                        kind,
                    );
                    let parsed_attrs = ClapAttr::parse_all(&variant.attrs)?;
                    res.infer_kind(&parsed_attrs)?;
                    res.push_attrs(&parsed_attrs)?;
                    if matches!(&*res.kind, Kind::Command(_) | Kind::Subcommand(_)) {
                        res.push_doc_comment(&variant.attrs, "about", Some("long_about"));
                    }

                    match &*res.kind {
                        Kind::Flatten(_) => {
                            if res.has_explicit_methods() {
                                abort!(
                                    res.kind.span(),
                                    "methods are not allowed for flattened entry"
                                );
                            }
                        }

                        Kind::Subcommand(_)
                        | Kind::ExternalSubcommand
                        | Kind::FromGlobal(_)
                        | Kind::Skip(_, _)
                        | Kind::Command(_)
                        | Kind::Value
                        | Kind::Arg(_) => (),
                    }

                    Ok(res)
                }

                pub fn from_value_enum_variant(
                    variant: &Variant,
                    argument_casing: Sp<CasingStyle>,
                    env_casing: Sp<CasingStyle>,
                ) -> Result<Self, syn::Error> {
                    let ident = variant.ident.clone();
                    let span = variant.span();
                    let kind = Sp::new(Kind::Value, span);
                    let mut res = Self::new(
                        Name::Derived(variant.ident.clone()),
                        ident,
                        None,
                        argument_casing,
                        env_casing,
                        kind,
                    );
                    let parsed_attrs = ClapAttr::parse_all(&variant.attrs)?;
                    res.infer_kind(&parsed_attrs)?;
                    res.push_attrs(&parsed_attrs)?;
                    if matches!(&*res.kind, Kind::Value) {
                        res.push_doc_comment(&variant.attrs, "help", None);
                    }

                    Ok(res)
                }

                pub fn from_args_field(
                    field: &Field,
                    struct_casing: Sp<CasingStyle>,
                    env_casing: Sp<CasingStyle>,
                ) -> Result<Self, syn::Error> {
                    let name = field.ident.clone().unwrap();
                    let ident = field.ident.clone().unwrap();
                    let span = field.span();
                    let ty = Ty::from_syn_ty(&field.ty);
                    let kind = Sp::new(Kind::Arg(ty), span);
                    let mut res = Self::new(
                        Name::Derived(name),
                        ident,
                        Some(field.ty.clone()),
                        struct_casing,
                        env_casing,
                        kind,
                    );
                    let parsed_attrs = ClapAttr::parse_all(&field.attrs)?;
                    res.infer_kind(&parsed_attrs)?;
                    res.push_attrs(&parsed_attrs)?;
                    if matches!(&*res.kind, Kind::Arg(_)) {
                        res.push_doc_comment(&field.attrs, "help", Some("long_help"));
                    }

                    match &*res.kind {
                        Kind::Flatten(_) => {
                            if res.has_explicit_methods() {
                                abort!(
                                    res.kind.span(),
                                    "methods are not allowed for flattened entry"
                                );
                            }
                        }

                        Kind::Subcommand(_) => {
                            if res.has_explicit_methods() {
                                abort!(
                                    res.kind.span(),
                                    "methods in attributes are not allowed for subcommand"
                                );
                            }
                        }
                        Kind::Skip(_, _)
                        | Kind::FromGlobal(_)
                        | Kind::Arg(_)
                        | Kind::Command(_)
                        | Kind::Value
                        | Kind::ExternalSubcommand => {}
                    }

                    Ok(res)
                }

                fn new(
                    name: Name,
                    ident: Ident,
                    ty: Option<Type>,
                    casing: Sp<CasingStyle>,
                    env_casing: Sp<CasingStyle>,
                    kind: Sp<Kind>,
                ) -> Self {
                    let group_id = Name::Derived(ident);
                    Self {
                        name,
                        ty,
                        casing,
                        env_casing,
                        doc_comment: vec![],
                        methods: vec![],
                        deprecations: vec![],
                        value_parser: None,
                        action: None,
                        verbatim_doc_comment: false,
                        force_long_help: false,
                        next_display_order: None,
                        next_help_heading: None,
                        is_enum: false,
                        is_positional: true,
                        skip_group: false,
                        group_id,
                        group_methods: vec![],
                        kind,
                    }
                }

                fn push_method(&mut self, kind: AttrKind, name: Ident, arg: impl ToTokens) {
                    self.push_method_(kind, name, arg.to_token_stream());
                }

                fn push_method_(&mut self, kind: AttrKind, name: Ident, arg: TokenStream) {
                    if name == "id" {
                        match kind {
                            AttrKind::Command | AttrKind::Value => {
                                self.deprecations.push(Deprecation {
                                    span: name.span(),
                                    id: "id_is_only_for_arg",
                                    version: "4.0.0",
                                    description: format!(
                                        "`#[{}(id)] was allowed by mistake, instead use `#[{}(name)]`",
                                        kind.as_str(),
                                        kind.as_str()
                                    ),
                                });
                                self.name = Name::Assigned(arg);
                            }
                            AttrKind::Group => {
                                self.group_id = Name::Assigned(arg);
                            }
                            AttrKind::Arg | AttrKind::Clap | AttrKind::StructOpt => {
                                self.name = Name::Assigned(arg);
                            }
                        }
                    } else if name == "name" {
                        match kind {
                            AttrKind::Arg => {
                                self.deprecations.push(Deprecation {
                                    span: name.span(),
                                    id: "id_is_only_for_arg",
                                    version: "4.0.0",
                                    description: format!(
                                        "`#[{}(name)] was allowed by mistake, instead use `#[{}(id)]` or `#[{}(value_name)]`",
                                        kind.as_str(),
                                        kind.as_str(),
                                        kind.as_str()
                                    ),
                                });
                                self.name = Name::Assigned(arg);
                            }
                            AttrKind::Group => self.group_methods.push(Method::new(name, arg)),
                            AttrKind::Command | AttrKind::Value | AttrKind::Clap | AttrKind::StructOpt => {
                                self.name = Name::Assigned(arg);
                            }
                        }
                    } else if name == "value_parser" {
                        self.value_parser = Some(ValueParser::Explicit(Method::new(name, arg)));
                    } else if name == "action" {
                        self.action = Some(Action::Explicit(Method::new(name, arg)));
                    } else {
                        if name == "short" || name == "long" {
                            self.is_positional = false;
                        }
                        match kind {
                            AttrKind::Group => self.group_methods.push(Method::new(name, arg)),
                            _ => self.methods.push(Method::new(name, arg)),
                        };
                    }
                }

                fn infer_kind(&mut self, attrs: &[ClapAttr]) -> Result<(), syn::Error> {
                    for attr in attrs {
                        if let Some(AttrValue::Call(_)) = &attr.value {
                            continue;
                        }

                        let actual_attr_kind = *attr.kind.get();
                        let kind = match &attr.magic {
                            Some(MagicAttrName::FromGlobal) => {
                                if attr.value.is_some() {
                                    let expr = attr.value_or_abort()?;
                                    abort!(expr, "attribute `{}` does not accept a value", attr.name);
                                }
                                let ty = self
                                    .kind()
                                    .ty()
                                    .cloned()
                                    .unwrap_or_else(|| Sp::new(Ty::Other, self.kind.span()));
                                let kind = Sp::new(Kind::FromGlobal(ty), attr.name.span());
                                Some(kind)
                            }
                            Some(MagicAttrName::Subcommand) if attr.value.is_none() => {
                                if attr.value.is_some() {
                                    let expr = attr.value_or_abort()?;
                                    abort!(expr, "attribute `{}` does not accept a value", attr.name);
                                }
                                let ty = self
                                    .kind()
                                    .ty()
                                    .cloned()
                                    .unwrap_or_else(|| Sp::new(Ty::Other, self.kind.span()));
                                let kind = Sp::new(Kind::Subcommand(ty), attr.name.span());
                                Some(kind)
                            }
                            Some(MagicAttrName::ExternalSubcommand) if attr.value.is_none() => {
                                if attr.value.is_some() {
                                    let expr = attr.value_or_abort()?;
                                    abort!(expr, "attribute `{}` does not accept a value", attr.name);
                                }
                                let kind = Sp::new(Kind::ExternalSubcommand, attr.name.span());
                                Some(kind)
                            }
                            Some(MagicAttrName::Flatten) if attr.value.is_none() => {
                                if attr.value.is_some() {
                                    let expr = attr.value_or_abort()?;
                                    abort!(expr, "attribute `{}` does not accept a value", attr.name);
                                }
                                let ty = self
                                    .kind()
                                    .ty()
                                    .cloned()
                                    .unwrap_or_else(|| Sp::new(Ty::Other, self.kind.span()));
                                let kind = Sp::new(Kind::Flatten(ty), attr.name.span());
                                Some(kind)
                            }
                            Some(MagicAttrName::Skip) if actual_attr_kind != AttrKind::Group => {
                                let expr = attr.value.clone();
                                let kind = Sp::new(Kind::Skip(expr, self.kind.attr_kind()), attr.name.span());
                                Some(kind)
                            }
                            _ => None,
                        };

                        if let Some(kind) = kind {
                            self.set_kind(kind)?;
                        }
                    }

                    Ok(())
                }

                fn push_attrs(&mut self, attrs: &[ClapAttr]) -> Result<(), syn::Error> {
                    for attr in attrs {
                        let actual_attr_kind = *attr.kind.get();
                        let expected_attr_kind = self.kind.attr_kind();
                        match (actual_attr_kind, expected_attr_kind) {
                            (AttrKind::Clap, _) | (AttrKind::StructOpt, _) => {
                                self.deprecations.push(Deprecation::attribute(
                                    "4.0.0",
                                    actual_attr_kind,
                                    expected_attr_kind,
                                    attr.kind.span(),
                                ));
                            }

                            (AttrKind::Group, AttrKind::Command) => {}

                            _ if attr.kind != expected_attr_kind => {
                                abort!(
                                    attr.kind.span(),
                                    "Expected `{}` attribute instead of `{}`",
                                    expected_attr_kind.as_str(),
                                    actual_attr_kind.as_str()
                                );
                            }

                            _ => {}
                        }

                        if let Some(AttrValue::Call(tokens)) = &attr.value {
                            // Force raw mode with method call syntax
                            self.push_method(*attr.kind.get(), attr.name.clone(), quote!(#(#tokens),*));
                            continue;
                        }

                        match &attr.magic {
                            Some(MagicAttrName::Short) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                self.push_method(
                                    *attr.kind.get(),
                                    attr.name.clone(),
                                    self.name.clone().translate_char(*self.casing),
                                );
                            }

                            Some(MagicAttrName::Long) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                self.push_method(*attr.kind.get(), attr.name.clone(), self.name.clone().translate(*self.casing));
                            }

                            Some(MagicAttrName::ValueParser) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                self.deprecations.push(Deprecation {
                                    span: attr.name.span(),
                                    id: "bare_value_parser",
                                    version: "4.0.0",
                                    description: "`#[arg(value_parser)]` is now the default and is no longer needed`".to_owned(),
                                });
                                self.value_parser = Some(ValueParser::Implicit(attr.name.clone()));
                            }

                            Some(MagicAttrName::Action) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                self.deprecations.push(Deprecation {
                                    span: attr.name.span(),
                                    id: "bare_action",
                                    version: "4.0.0",
                                    description: "`#[arg(action)]` is now the default and is no longer needed`".to_owned(),
                                });
                                self.action = Some(Action::Implicit(attr.name.clone()));
                            }

                            Some(MagicAttrName::Env) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                self.push_method(
                                    *attr.kind.get(),
                                    attr.name.clone(),
                                    self.name.clone().translate(*self.env_casing),
                                );
                            }

                            Some(MagicAttrName::ValueEnum) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                self.is_enum = true;
                            }

                            Some(MagicAttrName::VerbatimDocComment) if attr.value.is_none() => {
                                self.verbatim_doc_comment = true;
                            }

                            Some(MagicAttrName::About) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Command])?;

                                if let Some(method) =
                                    Method::from_env(attr.name.clone(), "CARGO_PKG_DESCRIPTION")?
                                {
                                    self.methods.push(method);
                                }
                            }

                            Some(MagicAttrName::LongAbout) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Command])?;

                                self.force_long_help = true;
                            }

                            Some(MagicAttrName::LongHelp) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                self.force_long_help = true;
                            }

                            Some(MagicAttrName::Author) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Command])?;

                                if let Some(method) = Method::from_env(attr.name.clone(), "CARGO_PKG_AUTHORS")? {
                                    self.methods.push(method);
                                }
                            }

                            Some(MagicAttrName::Version) if attr.value.is_none() => {
                                assert_attr_kind(attr, &[AttrKind::Command])?;

                                if let Some(method) = Method::from_env(attr.name.clone(), "CARGO_PKG_VERSION")? {
                                    self.methods.push(method);
                                }
                            }

                            Some(MagicAttrName::DefaultValueT) => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                let ty = if let Some(ty) = self.ty.as_ref() {
                                    ty
                                } else {
                                    abort!(
                                        attr.name.clone(),
                                        "#[arg(default_value_t)] (without an argument) can be used \
                                        only on field level\n\n= note: {note}\n\n",

                                        note = "see \
                                            https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                                };

                                let val = if let Some(expr) = &attr.value {
                                    quote!(#expr)
                                } else {
                                    quote!(<#ty as ::std::default::Default>::default())
                                };

                                let val = if attrs
                                    .iter()
                                    .any(|a| a.magic == Some(MagicAttrName::ValueEnum))
                                {
                                    quote_spanned!(attr.name.span()=> {
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE.get_or_init(|| {
                                            let val: #ty = #val;
                                            clap::ValueEnum::to_possible_value(&val).unwrap().get_name().to_owned()
                                        });
                                        let s: &'static str = &*s;
                                        s
                                    })
                                } else {
                                    quote_spanned!(attr.name.span()=> {
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE.get_or_init(|| {
                                            let val: #ty = #val;
                                            ::std::string::ToString::to_string(&val)
                                        });
                                        let s: &'static str = &*s;
                                        s
                                    })
                                };

                                let raw_ident = Ident::new("default_value", attr.name.span());
                                self.methods.push(Method::new(raw_ident, val));
                            }

                            Some(MagicAttrName::DefaultValuesT) => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                let ty = if let Some(ty) = self.ty.as_ref() {
                                    ty
                                } else {
                                    abort!(
                                        attr.name.clone(),
                                        "#[arg(default_values_t)] (without an argument) can be used \
                                        only on field level\n\n= note: {note}\n\n",

                                        note = "see \
                                            https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                                };
                                let expr = attr.value_or_abort()?;

                                let container_type = Ty::from_syn_ty(ty);
                                if *container_type != Ty::Vec {
                                    abort!(
                                        attr.name.clone(),
                                        "#[arg(default_values_t)] can be used only on Vec types\n\n= note: {note}\n\n",

                                        note = "see \
                                            https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                                }
                                let inner_type = inner_type(ty);

                                // Use `Borrow<#inner_type>` so we accept `&Vec<#inner_type>` and
                                // `Vec<#inner_type>`.
                                let val = if attrs
                                    .iter()
                                    .any(|a| a.magic == Some(MagicAttrName::ValueEnum))
                                {
                                    quote_spanned!(attr.name.span()=> {
                                        {
                                            fn iter_to_vals<T>(iterable: impl IntoIterator<Item = T>) -> impl Iterator<Item=String>
                                            where
                                                T: ::std::borrow::Borrow<#inner_type>
                                            {
                                                iterable
                                                    .into_iter()
                                                    .map(|val| {
                                                        clap::ValueEnum::to_possible_value(val.borrow()).unwrap().get_name().to_owned()
                                                    })
                                            }

                                            static DEFAULT_STRINGS: ::std::sync::OnceLock<Vec<String>> = ::std::sync::OnceLock::new();
                                            static DEFAULT_VALUES: ::std::sync::OnceLock<Vec<&str>> = ::std::sync::OnceLock::new();
                                            DEFAULT_VALUES.get_or_init(|| {
                                                DEFAULT_STRINGS.get_or_init(|| iter_to_vals(#expr).collect()).iter().map(::std::string::String::as_str).collect()
                                            }).iter().copied()
                                        }
                                    })
                                } else {
                                    quote_spanned!(attr.name.span()=> {
                                        {
                                            fn iter_to_vals<T>(iterable: impl IntoIterator<Item = T>) -> impl Iterator<Item=String>
                                            where
                                                T: ::std::borrow::Borrow<#inner_type>
                                            {
                                                iterable.into_iter().map(|val| val.borrow().to_string())
                                            }

                                            static DEFAULT_STRINGS: ::std::sync::OnceLock<Vec<String>> = ::std::sync::OnceLock::new();
                                            static DEFAULT_VALUES: ::std::sync::OnceLock<Vec<&str>> = ::std::sync::OnceLock::new();
                                            DEFAULT_VALUES.get_or_init(|| {
                                                DEFAULT_STRINGS.get_or_init(|| iter_to_vals(#expr).collect()).iter().map(::std::string::String::as_str).collect()
                                            }).iter().copied()
                                        }
                                    })
                                };

                                self.methods.push(Method::new(
                                    Ident::new("default_values", attr.name.span()),
                                    val,
                                ));
                            }

                            Some(MagicAttrName::DefaultValueOsT) => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                let ty = if let Some(ty) = self.ty.as_ref() {
                                    ty
                                } else {
                                    abort!(
                                        attr.name.clone(),
                                        "#[arg(default_value_os_t)] (without an argument) can be used \
                                        only on field level\n\n= note: {note}\n\n",

                                        note = "see \
                                            https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                                };

                                let val = if let Some(expr) = &attr.value {
                                    quote!(#expr)
                                } else {
                                    quote!(<#ty as ::std::default::Default>::default())
                                };

                                let val = if attrs
                                    .iter()
                                    .any(|a| a.magic == Some(MagicAttrName::ValueEnum))
                                {
                                    quote_spanned!(attr.name.span()=> {
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE.get_or_init(|| {
                                            let val: #ty = #val;
                                            clap::ValueEnum::to_possible_value(&val).unwrap().get_name().to_owned()
                                        });
                                        let s: &'static str = &*s;
                                        s
                                    })
                                } else {
                                    quote_spanned!(attr.name.span()=> {
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<::std::ffi::OsString> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE.get_or_init(|| {
                                            let val: #ty = #val;
                                            ::std::ffi::OsString::from(val)
                                        });
                                        let s: &'static ::std::ffi::OsStr = &*s;
                                        s
                                    })
                                };

                                let raw_ident = Ident::new("default_value", attr.name.span());
                                self.methods.push(Method::new(raw_ident, val));
                            }

                            Some(MagicAttrName::DefaultValuesOsT) => {
                                assert_attr_kind(attr, &[AttrKind::Arg])?;

                                let ty = if let Some(ty) = self.ty.as_ref() {
                                    ty
                                } else {
                                    abort!(
                                        attr.name.clone(),
                                        "#[arg(default_values_os_t)] (without an argument) can be used \
                                        only on field level\n\n= note: {note}\n\n",

                                        note = "see \
                                            https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                                };
                                let expr = attr.value_or_abort()?;

                                let container_type = Ty::from_syn_ty(ty);
                                if *container_type != Ty::Vec {
                                    abort!(
                                        attr.name.clone(),
                                        "#[arg(default_values_os_t)] can be used only on Vec types\n\n= note: {note}\n\n",

                                        note = "see \
                                            https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                                }
                                let inner_type = inner_type(ty);

                                // Use `Borrow<#inner_type>` so we accept `&Vec<#inner_type>` and
                                // `Vec<#inner_type>`.
                                let val = if attrs
                                    .iter()
                                    .any(|a| a.magic == Some(MagicAttrName::ValueEnum))
                                {
                                    quote_spanned!(attr.name.span()=> {
                                        {
                                            fn iter_to_vals<T>(iterable: impl IntoIterator<Item = T>) -> impl Iterator<Item=::std::ffi::OsString>
                                            where
                                                T: ::std::borrow::Borrow<#inner_type>
                                            {
                                                iterable
                                                    .into_iter()
                                                    .map(|val| {
                                                        clap::ValueEnum::to_possible_value(val.borrow()).unwrap().get_name().to_owned().into()
                                                    })
                                            }

                                            static DEFAULT_STRINGS: ::std::sync::OnceLock<Vec<::std::ffi::OsString>> = ::std::sync::OnceLock::new();
                                            static DEFAULT_VALUES: ::std::sync::OnceLock<Vec<&::std::ffi::OsStr>> = ::std::sync::OnceLock::new();
                                            DEFAULT_VALUES.get_or_init(|| {
                                                DEFAULT_STRINGS.get_or_init(|| iter_to_vals(#expr).collect()).iter().map(::std::ffi::OsString::as_os_str).collect()
                                            }).iter().copied()
                                        }
                                    })
                                } else {
                                    quote_spanned!(attr.name.span()=> {
                                        {
                                            fn iter_to_vals<T>(iterable: impl IntoIterator<Item = T>) -> impl Iterator<Item=::std::ffi::OsString>
                                            where
                                                T: ::std::borrow::Borrow<#inner_type>
                                            {
                                                iterable.into_iter().map(|val| val.borrow().into())
                                            }

                                            static DEFAULT_STRINGS: ::std::sync::OnceLock<Vec<::std::ffi::OsString>> = ::std::sync::OnceLock::new();
                                            static DEFAULT_VALUES: ::std::sync::OnceLock<Vec<&::std::ffi::OsStr>> = ::std::sync::OnceLock::new();
                                            DEFAULT_VALUES.get_or_init(|| {
                                                DEFAULT_STRINGS.get_or_init(|| iter_to_vals(#expr).collect()).iter().map(::std::ffi::OsString::as_os_str).collect()
                                            }).iter().copied()
                                        }
                                    })
                                };

                                self.methods.push(Method::new(
                                    Ident::new("default_values", attr.name.span()),
                                    val,
                                ));
                            }

                            Some(MagicAttrName::NextDisplayOrder) => {
                                assert_attr_kind(attr, &[AttrKind::Command])?;

                                let expr = attr.value_or_abort()?;
                                self.next_display_order = Some(Method::new(attr.name.clone(), quote!(#expr)));
                            }

                            Some(MagicAttrName::NextHelpHeading) => {
                                assert_attr_kind(attr, &[AttrKind::Command])?;

                                let expr = attr.value_or_abort()?;
                                self.next_help_heading = Some(Method::new(attr.name.clone(), quote!(#expr)));
                            }

                            Some(MagicAttrName::RenameAll) => {
                                let lit = attr.lit_str_or_abort()?;
                                self.casing = CasingStyle::from_lit(lit)?;
                            }

                            Some(MagicAttrName::RenameAllEnv) => {
                                assert_attr_kind(attr, &[AttrKind::Command, AttrKind::Arg])?;

                                let lit = attr.lit_str_or_abort()?;
                                self.env_casing = CasingStyle::from_lit(lit)?;
                            }

                            Some(MagicAttrName::Skip) if actual_attr_kind == AttrKind::Group => {
                                self.skip_group = true;
                            }

                            None
                            // Magic only for the default, otherwise just forward to the builder
                            | Some(MagicAttrName::Short)
                            | Some(MagicAttrName::Long)
                            | Some(MagicAttrName::Env)
                            | Some(MagicAttrName::About)
                            | Some(MagicAttrName::LongAbout)
                            | Some(MagicAttrName::LongHelp)
                            | Some(MagicAttrName::Author)
                            | Some(MagicAttrName::Version)
                            => {
                                let expr = attr.value_or_abort()?;
                                self.push_method(*attr.kind.get(), attr.name.clone(), expr);
                            }

                            // Magic only for the default, otherwise just forward to the builder
                            Some(MagicAttrName::ValueParser) | Some(MagicAttrName::Action) => {
                                let expr = attr.value_or_abort()?;
                                self.push_method(*attr.kind.get(), attr.name.clone(), expr);
                            }

                            // Directives that never receive a value
                            Some(MagicAttrName::ValueEnum)
                            | Some(MagicAttrName::VerbatimDocComment) => {
                                let expr = attr.value_or_abort()?;
                                abort!(expr, "attribute `{}` does not accept a value", attr.name);
                            }

                            // Kinds
                            Some(MagicAttrName::FromGlobal)
                            | Some(MagicAttrName::Subcommand)
                            | Some(MagicAttrName::ExternalSubcommand)
                            | Some(MagicAttrName::Flatten)
                            | Some(MagicAttrName::Skip) => {
                            }
                        }
                    }

                    if self.has_explicit_methods() {
                        if let Kind::Skip(_, attr) = &*self.kind {
                            abort!(
                                self.methods[0].name.span(),
                                "`{}` cannot be used with `#[{}(skip)]",
                                self.methods[0].name,
                                attr.as_str(),
                            );
                        }
                        if let Kind::FromGlobal(_) = &*self.kind {
                            abort!(
                                self.methods[0].name.span(),
                                "`{}` cannot be used with `#[arg(from_global)]",
                                self.methods[0].name,
                            );
                        }
                    }

                    Ok(())
                }

                fn push_doc_comment(&mut self, attrs: &[Attribute], short_name: &str, long_name: Option<&str>) {
                    let lines = extract_doc_comment(attrs);

                    if !lines.is_empty() {
                        let (short_help, long_help) =
                            format_doc_comment(&lines, !self.verbatim_doc_comment, self.force_long_help);
                        let short_name = format_ident!("{short_name}");
                        let short = Method::new(
                            short_name,
                            short_help
                                .map(|h| quote!(#h))
                                .unwrap_or_else(|| quote!(None)),
                        );
                        self.doc_comment.push(short);
                        if let Some(long_name) = long_name {
                            let long_name = format_ident!("{long_name}");
                            let long = Method::new(
                                long_name,
                                long_help
                                    .map(|h| quote!(#h))
                                    .unwrap_or_else(|| quote!(None)),
                            );
                            self.doc_comment.push(long);
                        }
                    }
                }

                fn set_kind(&mut self, kind: Sp<Kind>) -> Result<(), syn::Error> {
                    match (self.kind.get(), kind.get()) {
                        (Kind::Arg(_), Kind::FromGlobal(_))
                        | (Kind::Arg(_), Kind::Subcommand(_))
                        | (Kind::Arg(_), Kind::Flatten(_))
                        | (Kind::Arg(_), Kind::Skip(_, _))
                        | (Kind::Command(_), Kind::Subcommand(_))
                        | (Kind::Command(_), Kind::Flatten(_))
                        | (Kind::Command(_), Kind::Skip(_, _))
                        | (Kind::Command(_), Kind::ExternalSubcommand)
                        | (Kind::Value, Kind::Skip(_, _)) => {
                            self.kind = kind;
                        }

                        (_, _) => {
                            let old = self.kind.name();
                            let new = kind.name();
                            abort!(kind.span(), "`{new}` cannot be used with `{old}`");
                        }
                    }
                    Ok(())
                }

                pub fn find_default_method(&self) -> Option<&Method> {
                    self.methods
                        .iter()
                        .find(|m| m.name == "default_value" || m.name == "default_value_os")
                }
                /// generate methods from attributes on top of struct or enum
                pub fn initial_top_level_methods(&self) -> TokenStream {
                    let next_display_order = self.next_display_order.as_ref().into_iter();
                    let next_help_heading = self.next_help_heading.as_ref().into_iter();
                    quote!(
                        #(#next_display_order)*
                        #(#next_help_heading)*
                    )
                }

                pub fn final_top_level_methods(&self) -> TokenStream {
                    let methods = &self.methods;
                    let doc_comment = &self.doc_comment;

                    quote!( #(#doc_comment)* #(#methods)*)
                }
                /// generate methods on top of a field
                pub fn field_methods(&self) -> TokenStream {
                    let methods = &self.methods;
                    let doc_comment = &self.doc_comment;
                    quote!( #(#doc_comment)* #(#methods)* )
                }

                pub fn group_id(&self) -> &Name {
                    &self.group_id
                }

                pub fn group_methods(&self) -> TokenStream {
                    let group_methods = &self.group_methods;
                    quote!( #(#group_methods)* )
                }

                pub fn deprecations(&self) -> TokenStream {
                    let deprecations = &self.deprecations;
                    quote!( #(#deprecations)* )
                }

                pub fn next_display_order(&self) -> TokenStream {
                    let next_display_order = self.next_display_order.as_ref().into_iter();
                    quote!( #(#next_display_order)* )
                }

                pub fn next_help_heading(&self) -> TokenStream {
                    let next_help_heading = self.next_help_heading.as_ref().into_iter();
                    quote!( #(#next_help_heading)* )
                }

                pub fn id(&self) -> &Name {
                    &self.name
                }

                pub fn cased_name(&self) -> TokenStream {
                    self.name.clone().translate(*self.casing)
                }

                pub fn value_name(&self) -> TokenStream {
                    self.name.clone().translate(CasingStyle::ScreamingSnake)
                }

                pub fn value_parser(&self, field_type: &Type) -> Method {
                    self.value_parser
                        .clone()
                        .map(|p| {
                            let inner_type = inner_type(field_type);
                            p.resolve(inner_type)
                        })
                        .unwrap_or_else(|| {
                            let inner_type = inner_type(field_type);
                            if let Some(action) = self.action.as_ref() {
                                let span = action.span();
                                default_value_parser(inner_type, span)
                            } else {
                                let span = self
                                    .action
                                    .as_ref()
                                    .map(|a| a.span())
                                    .unwrap_or_else(|| self.kind.span());
                                default_value_parser(inner_type, span)
                            }
                        })
                }

                pub fn action(&self, field_type: &Type) -> Method {
                    self.action
                        .clone()
                        .map(|p| p.resolve(field_type))
                        .unwrap_or_else(|| {
                            if let Some(value_parser) = self.value_parser.as_ref() {
                                let span = value_parser.span();
                                default_action(field_type, span)
                            } else {
                                let span = self
                                    .value_parser
                                    .as_ref()
                                    .map(|a| a.span())
                                    .unwrap_or_else(|| self.kind.span());
                                default_action(field_type, span)
                            }
                        })
                }

                pub fn kind(&self) -> Sp<Kind> {
                    self.kind.clone()
                }

                pub fn is_positional(&self) -> bool {
                    self.is_positional
                }

                pub fn casing(&self) -> Sp<CasingStyle> {
                    self.casing
                }

                pub fn env_casing(&self) -> Sp<CasingStyle> {
                    self.env_casing
                }

                pub fn has_explicit_methods(&self) -> bool {
                    self.methods
                        .iter()
                        .any(|m| m.name != "help" && m.name != "long_help")
                }

                pub fn skip_group(&self) -> bool {
                    self.skip_group
                }
            }

            #[derive(Clone)]
            enum ValueParser {
                Explicit(Method),
                Implicit(Ident),
            }

            impl ValueParser {
                fn resolve(self, _inner_type: &Type) -> Method {
                    match self {
                        Self::Explicit(method) => method,
                        Self::Implicit(ident) => default_value_parser(_inner_type, ident.span()),
                    }
                }

                fn span(&self) -> Span {
                    match self {
                        Self::Explicit(method) => method.name.span(),
                        Self::Implicit(ident) => ident.span(),
                    }
                }
            }

            fn default_value_parser(inner_type: &Type, span: Span) -> Method {
                let func = Ident::new("value_parser", span);
                Method::new(
                    func,
                    quote_spanned! { span=>
                        clap::value_parser!(#inner_type)
                    },
                )
            }

            #[derive(Clone)]
            pub enum Action {
                Explicit(Method),
                Implicit(Ident),
            }

            impl Action {
                pub fn resolve(self, _field_type: &Type) -> Method {
                    match self {
                        Self::Explicit(method) => method,
                        Self::Implicit(ident) => default_action(_field_type, ident.span()),
                    }
                }

                pub fn span(&self) -> Span {
                    match self {
                        Self::Explicit(method) => method.name.span(),
                        Self::Implicit(ident) => ident.span(),
                    }
                }
            }

            fn default_action(field_type: &Type, span: Span) -> Method {
                let ty = Ty::from_syn_ty(field_type);
                let args = match *ty {
                    Ty::Vec | Ty::OptionVec | Ty::VecVec | Ty::OptionVecVec => {
                        quote_spanned! { span=>
                            clap::ArgAction::Append
                        }
                    }
                    Ty::Option | Ty::OptionOption => {
                        quote_spanned! { span=>
                            clap::ArgAction::Set
                        }
                    }
                    _ => {
                        if is_simple_ty(field_type, "bool") {
                            quote_spanned! { span=>
                                clap::ArgAction::SetTrue
                            }
                        } else {
                            quote_spanned! { span=>
                                clap::ArgAction::Set
                            }
                        }
                    }
                };

                let func = Ident::new("action", span);
                Method::new(func, args)
            }

            #[allow(clippy::large_enum_variant)]
            #[derive(Clone)]
            pub enum Kind {
                Arg(Sp<Ty>),
                Command(Sp<Ty>),
                Value,
                FromGlobal(Sp<Ty>),
                Subcommand(Sp<Ty>),
                Flatten(Sp<Ty>),
                Skip(Option<AttrValue>, AttrKind),
                ExternalSubcommand,
            }

            impl Kind {
                pub fn name(&self) -> &'static str {
                    match self {
                        Self::Arg(_) => "arg",
                        Self::Command(_) => "command",
                        Self::Value => "value",
                        Self::FromGlobal(_) => "from_global",
                        Self::Subcommand(_) => "subcommand",
                        Self::Flatten(_) => "flatten",
                        Self::Skip(_, _) => "skip",
                        Self::ExternalSubcommand => "external_subcommand",
                    }
                }

                pub fn attr_kind(&self) -> AttrKind {
                    match self {
                        Self::Arg(_) => AttrKind::Arg,
                        Self::Command(_) => AttrKind::Command,
                        Self::Value => AttrKind::Value,
                        Self::FromGlobal(_) => AttrKind::Arg,
                        Self::Subcommand(_) => AttrKind::Command,
                        Self::Flatten(_) => AttrKind::Command,
                        Self::Skip(_, kind) => *kind,
                        Self::ExternalSubcommand => AttrKind::Command,
                    }
                }

                pub fn ty(&self) -> Option<&Sp<Ty>> {
                    match self {
                        Self::Arg(ty)
                        | Self::Command(ty)
                        | Self::Flatten(ty)
                        | Self::FromGlobal(ty)
                        | Self::Subcommand(ty) => Some(ty),
                        Self::Value | Self::Skip(_, _) | Self::ExternalSubcommand => None,
                    }
                }
            }

            #[derive(Clone)]
            pub struct Method {
                name: Ident,
                args: TokenStream,
            }

            impl Method {
                pub fn new(name: Ident, args: TokenStream) -> Self {
                    Method { name, args }
                }

                fn from_env(ident: Ident, env_var: &str) -> Result<Option<Self>, syn::Error> {
                    let mut lit = match env::var(env_var) {
                        Ok(val) => {
                            if val.is_empty() {
                                return Ok(None);
                            }
                            LitStr::new(&val, ident.span())
                        }
                        Err(_) => {
                            abort!(
                                ident,
                                "cannot derive `{}` from Cargo.toml\n\n= note: {note}\n\n= help: {help}\n\n",
                                ident,
                                note = format_args!("`{env_var}` environment variable is not set"),
                                help = format_args!("use `{ident} = \"...\"` to set {ident} manually")
                            );
                        }
                    };

                    if ident == "author" {
                        let edited = process_author_str(&lit.value());
                        lit = LitStr::new(&edited, lit.span());
                    }

                    Ok(Some(Method::new(ident, quote!(#lit))))
                }

                pub fn args(&self) -> &TokenStream {
                    &self.args
                }
            }

            impl ToTokens for Method {
                fn to_tokens(&self, ts: &mut TokenStream) {
                    let Method { ref name, ref args } = self;

                    let tokens = quote!( .#name(#args) );

                    tokens.to_tokens(ts);
                }
            }

            #[derive(Clone)]
            pub struct Deprecation {
                pub span: Span,
                pub id: &'static str,
                pub version: &'static str,
                pub description: String,
            }

            impl Deprecation {
                fn attribute(version: &'static str, old: AttrKind, new: AttrKind, span: Span) -> Self {
                    Self {
                        span,
                        id: "old_attribute",
                        version,
                        description: format!(
                            "Attribute `#[{}(...)]` has been deprecated in favor of `#[{}(...)]`",
                            old.as_str(),
                            new.as_str()
                        ),
                    }
                }
            }

            impl ToTokens for Deprecation {
                fn to_tokens(&self, ts: &mut TokenStream) {
                    let tokens = if cfg!(feature = "deprecated") {
                        let Deprecation {
                            span,
                            id,
                            version,
                            description,
                        } = self;
                        let span = *span;
                        let id = Ident::new(id, span);

                        quote_spanned!(span=> {
                            #[deprecated(since = #version, note = #description)]
                            fn #id() {}
                            #id();
                        })
                    } else {
                        quote!()
                    };

                    tokens.to_tokens(ts);
                }
            }

            fn assert_attr_kind(attr: &ClapAttr, possible_kind: &[AttrKind]) -> Result<(), syn::Error> {
                if *attr.kind.get() == AttrKind::Clap || *attr.kind.get() == AttrKind::StructOpt {
                    // deprecated
                } else if !possible_kind.contains(attr.kind.get()) {
                    let options = possible_kind
                        .iter()
                        .map(|k| format!("`#[{}({})]`", k.as_str(), attr.name))
                        .collect::<Vec<_>>();
                    abort!(
                        attr.name,
                        "Unknown `#[{}({})]` attribute ({} exists)",
                        attr.kind.as_str(),
                        attr.name,
                        options.join(", ")
                    );
                }
                Ok(())
            }
            /// replace all `:` with `, ` when not inside the `<>`
            ///
            /// `"author1:author2:author3" => "author1, author2, author3"`
            /// `"author1 <http://website1.com>:author2" => "author1 <http://website1.com>, author2"`
            fn process_author_str(author: &str) -> String {
                let mut res = String::with_capacity(author.len());
                let mut inside_angle_braces = 0usize;

                for ch in author.chars() {
                    if inside_angle_braces > 0 && ch == '>' {
                        inside_angle_braces -= 1;
                        res.push(ch);
                    } else if ch == '<' {
                        inside_angle_braces += 1;
                        res.push(ch);
                    } else if inside_angle_braces == 0 && ch == ':' {
                        res.push_str(", ");
                    } else {
                        res.push(ch);
                    }
                }

                res
            }
            /// Defines the casing for the attributes long representation.
            #[derive(Copy, Clone, Debug, PartialEq, Eq)]
            pub enum CasingStyle {
                /// Indicate word boundaries with uppercase letter, excluding the first word.
                Camel,
                /// Keep all letters lowercase and indicate word boundaries with hyphens.
                Kebab,
                /// Indicate word boundaries with uppercase letter, including the first word.
                Pascal,
                /// Keep all letters uppercase and indicate word boundaries with underscores.
                ScreamingSnake,
                /// Keep all letters lowercase and indicate word boundaries with underscores.
                Snake,
                /// Keep all letters lowercase and remove word boundaries.
                Lower,
                /// Keep all letters uppercase and remove word boundaries.
                Upper,
                /// Use the original attribute name defined in the code.
                Verbatim,
            }

            impl CasingStyle {
                fn from_lit(name: &LitStr) -> Result<Sp<Self>, syn::Error> {
                    use self::CasingStyle::{
                        Camel, Kebab, Lower, Pascal, ScreamingSnake, Snake, Upper, Verbatim,
                    };

                    let normalized = name.value().to_upper_camel_case().to_lowercase();
                    let cs = |kind| Sp::new(kind, name.span());

                    let s = match normalized.as_ref() {
                        "camel" | "camelcase" => cs(Camel),
                        "kebab" | "kebabcase" => cs(Kebab),
                        "pascal" | "pascalcase" => cs(Pascal),
                        "screamingsnake" | "screamingsnakecase" => cs(ScreamingSnake),
                        "snake" | "snakecase" => cs(Snake),
                        "lower" | "lowercase" => cs(Lower),
                        "upper" | "uppercase" => cs(Upper),
                        "verbatim" | "verbatimcase" => cs(Verbatim),
                        s => abort!(name, "unsupported casing: `{s}`"),
                    };
                    Ok(s)
                }
            }

            #[derive(Clone)]
            pub enum Name {
                Derived(Ident),
                Assigned(TokenStream),
            }

            impl Name {
                pub fn translate(self, style: CasingStyle) -> TokenStream {
                    use CasingStyle::{Camel, Kebab, Lower, Pascal, ScreamingSnake, Snake, Upper, Verbatim};

                    match self {
                        Name::Assigned(tokens) => tokens,
                        Name::Derived(ident) => {
                            let s = ident.unraw().to_string();
                            let s = match style {
                                Pascal => s.to_upper_camel_case(),
                                Kebab => s.to_kebab_case(),
                                Camel => s.to_lower_camel_case(),
                                ScreamingSnake => s.to_shouty_snake_case(),
                                Snake => s.to_snake_case(),
                                Lower => s.to_snake_case().replace('_', ""),
                                Upper => s.to_shouty_snake_case().replace('_', ""),
                                Verbatim => s,
                            };
                            quote_spanned!(ident.span()=> #s)
                        }
                    }
                }

                pub fn translate_char(self, style: CasingStyle) -> TokenStream {
                    use CasingStyle::{Camel, Kebab, Lower, Pascal, ScreamingSnake, Snake, Upper, Verbatim};

                    match self {
                        Name::Assigned(tokens) => quote!( (#tokens).chars().next().unwrap() ),
                        Name::Derived(ident) => {
                            let s = ident.unraw().to_string();
                            let s = match style {
                                Pascal => s.to_upper_camel_case(),
                                Kebab => s.to_kebab_case(),
                                Camel => s.to_lower_camel_case(),
                                ScreamingSnake => s.to_shouty_snake_case(),
                                Snake => s.to_snake_case(),
                                Lower => s.to_snake_case(),
                                Upper => s.to_shouty_snake_case(),
                                Verbatim => s,
                            };

                            let s = s.chars().next().unwrap();
                            quote_spanned!(ident.span()=> #s)
                        }
                    }
                }
            }

            impl ToTokens for Name {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    match self {
                        Name::Assigned(t) => t.to_tokens(tokens),
                        Name::Derived(ident) => {
                            let s = ident.unraw().to_string();
                            quote_spanned!(ident.span()=> #s).to_tokens(tokens);
                        }
                    }
                }
            }
        }

        pub mod utils
        {
            use ::
            { 
                *,
            };

            pub mod error
            {
                use ::
                {
                    *,
                };
                pub trait SpanError {
                    #[allow(non_snake_case)]
                    fn EXPECTED_Span_OR_ToTokens<D: std::fmt::Display>(&self, msg: D) -> syn::Error;
                }

                pub trait ToTokensError {
                    #[allow(non_snake_case)]
                    fn EXPECTED_Span_OR_ToTokens<D: std::fmt::Display>(&self, msg: D) -> syn::Error;
                }

                impl<T: quote::ToTokens> ToTokensError for T {
                    fn EXPECTED_Span_OR_ToTokens<D: std::fmt::Display>(&self, msg: D) -> syn::Error {
                        // Curb monomorphization from generating too many identical `new_spanned`.
                        syn::Error::new_spanned(self.to_token_stream(), msg)
                    }
                }

                impl SpanError for proc_macro2::Span {
                    fn EXPECTED_Span_OR_ToTokens<D: std::fmt::Display>(&self, msg: D) -> syn::Error {
                        syn::Error::new(*self, msg)
                    }
                }
            }

            pub mod doc_comments
            {
                //! The preprocessing we apply to doc comments.
                use ::
                {
                    *,
                };
                
                #[cfg(feature = "unstable-markdown")]
                use markdown::parse_markdown;

                pub fn extract_doc_comment(attrs: &[syn::Attribute]) -> Vec<String> {
                    // multiline comments (`/** ... */`) may have LFs (`\n`) in them,
                    // we need to split so we could handle the lines correctly
                    //
                    // we also need to remove leading and trailing blank lines
                    let mut lines: Vec<_> = attrs
                        .iter()
                        .filter(|attr| attr.path().is_ident("doc"))
                        .filter_map(|attr| {
                            // non #[doc = "..."] attributes are not our concern
                            // we leave them for rustc to handle
                            match &attr.meta {
                                syn::Meta::NameValue(syn::MetaNameValue {
                                    value:
                                        syn::Expr::Lit(syn::ExprLit {
                                            lit: syn::Lit::Str(s),
                                            ..
                                        }),
                                    ..
                                }) => Some(s.value()),
                                _ => None,
                            }
                        })
                        .skip_while(|s| is_blank(s))
                        .flat_map(|s| {
                            let lines = s
                                .split('\n')
                                .map(|s| {
                                    // remove one leading space no matter what
                                    let s = s.strip_prefix(' ').unwrap_or(s);
                                    s.to_owned()
                                })
                                .collect::<Vec<_>>();
                            lines
                        })
                        .collect();

                    while let Some(true) = lines.last().map(|s| is_blank(s)) {
                        lines.pop();
                    }

                    lines
                }

                pub fn format_doc_comment(
                    lines: &[String],
                    preprocess: bool,
                    force_long: bool,
                ) -> (Option<String>, Option<String>) {
                    if preprocess {
                        let (short, long) = parse_markdown(lines);
                        let long = long.or_else(|| force_long.then(|| short.clone()));

                        (Some(remove_period(short)), long)
                    } else if let Some(first_blank) = lines.iter().position(|s| is_blank(s)) {
                        let short = lines[..first_blank].join("\n");
                        let long = lines.join("\n");

                        (Some(short), Some(long))
                    } else {
                        let short = lines.join("\n");
                        let long = force_long.then(|| short.clone());

                        (Some(short), long)
                    }
                }

                #[cfg(not(feature = "unstable-markdown"))]
                fn split_paragraphs(lines: &[String]) -> Vec<String> {
                    use std::iter;

                    let mut last_line = 0;
                    iter::from_fn(|| {
                        let slice = &lines[last_line..];
                        let start = slice.iter().position(|s| !is_blank(s)).unwrap_or(0);

                        let slice = &slice[start..];
                        let len = slice
                            .iter()
                            .position(|s| is_blank(s))
                            .unwrap_or(slice.len());

                        last_line += start + len;

                        if len != 0 {
                            Some(merge_lines(&slice[..len]))
                        } else {
                            None
                        }
                    })
                    .collect()
                }

                fn remove_period(mut s: String) -> String {
                    if s.ends_with('.') && !s.ends_with("..") {
                        s.pop();
                    }
                    s
                }

                fn is_blank(s: &str) -> bool {
                    s.trim().is_empty()
                }

                #[cfg(not(feature = "unstable-markdown"))]
                fn merge_lines(lines: impl IntoIterator<Item = impl AsRef<str>>) -> String {
                    lines
                        .into_iter()
                        .map(|s| s.as_ref().trim().to_owned())
                        .collect::<Vec<_>>()
                        .join(" ")
                }

                #[cfg(not(feature = "unstable-markdown"))]
                fn parse_markdown(lines: &[String]) -> (String, Option<String>) {
                    if lines.iter().any(|s| is_blank(s)) {
                        let paragraphs = split_paragraphs(lines);
                        let short = paragraphs[0].clone();
                        let long = paragraphs.join("\n\n");
                        (short, Some(long))
                    } else {
                        let short = merge_lines(lines);
                        (short, None)
                    }
                }

                #[cfg(feature = "unstable-markdown")]
                mod markdown {
                    use anstyle::{Reset, Style};
                    use pulldown_cmark::{Event, Options, Parser, Tag, TagEnd};
                    use std::fmt;
                    use std::fmt::Write;
                    use std::ops::AddAssign;

                    #[derive(Default)]
                    struct MarkdownWriter {
                        output: String,
                        /// Prefix inserted for each line.
                        prefix: String,
                        /// Should an empty line be inserted before the next anything.
                        hanging_paragraph: bool,
                        /// Are we in an empty line
                        dirty_line: bool,
                        styles: Vec<Style>,
                    }

                    impl MarkdownWriter {
                        fn newline(&mut self) {
                            self.reset();
                            self.output.push('\n');
                            self.dirty_line = false;
                        }
                        fn endline(&mut self) {
                            if self.dirty_line {
                                self.newline();
                            }
                        }
                        fn new_paragraph(&mut self) {
                            self.endline();
                            self.hanging_paragraph = true;
                        }

                        fn write_fmt(&mut self, arguments: fmt::Arguments<'_>) {
                            if self.hanging_paragraph {
                                self.hanging_paragraph = false;
                                self.newline();
                            }
                            if !self.dirty_line {
                                self.output.push_str(&self.prefix);
                                self.apply_styles();
                                self.dirty_line = true;
                            }
                            self.output.write_fmt(arguments).unwrap();
                        }

                        fn start_link(&mut self, dest_url: pulldown_cmark::CowStr<'_>) {
                            write!(self, "\x1B]8;;{dest_url}\x1B\\");
                        }
                        fn end_link(&mut self) {
                            write!(self, "\x1B]8;;\x1B\\");
                        }

                        fn start_style(&mut self, style: Style) {
                            self.styles.push(style);
                            write!(self, "{style}");
                        }
                        fn end_style(&mut self, style: Style) {
                            let last_style = self.styles.pop();
                            debug_assert_eq!(last_style.unwrap(), style);

                            write!(self, "{Reset}");
                            self.apply_styles();
                        }

                        fn reset(&mut self) {
                            write!(self, "{Reset}");
                        }

                        fn apply_styles(&mut self) {
                            // Reapplying all, because anstyle doesn't support merging styles
                            // (probably because the ambiguity around colors)
                            // TODO If we decide not to support any colors, we can replace this with
                            // anstyle::Effects and remove the need for applying them all individually.
                            for style in &self.styles {
                                write!(self.output, "{style}").unwrap();
                            }
                        }

                        fn remove_prefix(&mut self, quote_prefix: &str) {
                            debug_assert!(self.prefix.ends_with(quote_prefix));
                            let new_len = self.prefix.len() - quote_prefix.len();
                            self.prefix.truncate(new_len);
                        }

                        fn add_prefix(&mut self, quote_prefix: &str) {
                            if self.hanging_paragraph {
                                self.hanging_paragraph = false;
                                self.newline();
                            }
                            self.prefix += quote_prefix;
                        }
                    }

                    pub(super) fn parse_markdown(input: &[String]) -> (String, Option<String>) {
                        // Markdown Configuration
                        let parsing_options = Options::ENABLE_STRIKETHROUGH;
                        // Minimal Styling for now, because we cannot configure it
                        let style_heading = Style::new().bold().underline();
                        let style_emphasis = Style::new().italic();
                        let style_strong = Style::new().bold();
                        let style_strike_through = Style::new().strikethrough();
                        let style_link = Style::new().underline();
                        let style_code = Style::new().bold();
                        let list_symbol = '-';
                        let quote_prefix = "| ";
                        let indentation = "  ";

                        let input = input.join("\n");
                        let input = Parser::new_ext(&input, parsing_options);

                        let mut short = None;
                        let mut has_details = false;

                        let mut writer = MarkdownWriter::default();

                        let mut list_indices = Vec::new();

                        for event in input {
                            if short.is_some() {
                                has_details = true;
                            }
                            match event {
                                Event::Start(Tag::Paragraph) => { /* nothing to do */ }
                                Event::End(TagEnd::Paragraph) => {
                                    if short.is_none() {
                                        short = Some(writer.output.trim().to_owned());
                                    }
                                    writer.new_paragraph();
                                }

                                Event::Start(Tag::Heading { .. }) => writer.start_style(style_heading),
                                Event::End(TagEnd::Heading(..)) => {
                                    writer.end_style(style_heading);
                                    writer.new_paragraph();
                                }

                                Event::Start(Tag::Image { .. } | Tag::HtmlBlock) => { /* IGNORED */ }
                                Event::End(TagEnd::Image) => { /* IGNORED */ }
                                Event::End(TagEnd::HtmlBlock) => writer.new_paragraph(),

                                Event::Start(Tag::BlockQuote(_)) => writer.add_prefix(quote_prefix),
                                Event::End(TagEnd::BlockQuote(_)) => {
                                    writer.remove_prefix(quote_prefix);
                                    writer.new_paragraph();
                                }

                                Event::Start(Tag::CodeBlock(_)) => {
                                    writer.add_prefix(indentation);
                                    writer.start_style(style_code);
                                }
                                Event::End(TagEnd::CodeBlock) => {
                                    writer.remove_prefix(indentation);
                                    writer.end_style(style_code);
                                    writer.dirty_line = false;
                                    writer.hanging_paragraph = true;
                                }

                                Event::Start(Tag::List(list_start)) => {
                                    list_indices.push(list_start);
                                    writer.endline();
                                }
                                Event::End(TagEnd::List(_)) => {
                                    let list = list_indices.pop();
                                    debug_assert!(list.is_some());
                                    if list_indices.is_empty() {
                                        writer.new_paragraph();
                                    }
                                }
                                Event::Start(Tag::Item) => {
                                    if let Some(Some(index)) = list_indices.last_mut() {
                                        write!(writer, "{index}. ");
                                        index.add_assign(1);
                                    } else {
                                        write!(writer, "{list_symbol} ");
                                    }
                                    writer.add_prefix(indentation);
                                }
                                Event::End(TagEnd::Item) => {
                                    writer.remove_prefix(indentation);
                                    writer.endline();
                                }

                                Event::Start(Tag::Emphasis) => writer.start_style(style_emphasis),
                                Event::End(TagEnd::Emphasis) => writer.end_style(style_emphasis),
                                Event::Start(Tag::Strong) => writer.start_style(style_strong),
                                Event::End(TagEnd::Strong) => writer.end_style(style_strong),
                                Event::Start(Tag::Strikethrough) => writer.start_style(style_strike_through),
                                Event::End(TagEnd::Strikethrough) => writer.end_style(style_strike_through),

                                Event::Start(Tag::Link { dest_url, .. }) => {
                                    writer.start_link(dest_url);
                                    writer.start_style(style_link);
                                }
                                Event::End(TagEnd::Link) => {
                                    writer.end_link();
                                    writer.end_style(style_link);
                                }

                                Event::Text(segment) => {
                                    // split into lines to support code blocks
                                    let mut lines = segment.lines();
                                    // `.lines()`  always returns at least one
                                    write!(writer, "{}", lines.next().unwrap());
                                    for line in lines {
                                        writer.endline();
                                        write!(writer, "{line}");
                                    }
                                    if segment.ends_with('\n') {
                                        writer.endline();
                                    }
                                }

                                Event::Code(code) => {
                                    writer.start_style(style_code);
                                    write!(writer, "{code}");
                                    writer.end_style(style_code);
                                }

                                // There is not really anything useful to do with block level html.
                                Event::Html(html) => write!(writer, "{html}"),
                                // At some point we could support custom tags like `<red>`
                                Event::InlineHtml(html) => write!(writer, "{html}"),
                                Event::SoftBreak => write!(writer, " "),
                                Event::HardBreak => writer.endline(),

                                Event::Rule => {
                                    writer.new_paragraph();
                                    write!(writer, "---");
                                    writer.new_paragraph();
                                }

                                // Markdown features currently not supported
                                Event::Start(
                                    Tag::FootnoteDefinition(_)
                                    | Tag::DefinitionList
                                    | Tag::DefinitionListTitle
                                    | Tag::DefinitionListDefinition
                                    | Tag::Table(_)
                                    | Tag::TableHead
                                    | Tag::TableRow
                                    | Tag::TableCell
                                    | Tag::MetadataBlock(_)
                                    | Tag::Superscript
                                    | Tag::Subscript,
                                )
                                | Event::End(
                                    TagEnd::FootnoteDefinition
                                    | TagEnd::DefinitionList
                                    | TagEnd::DefinitionListTitle
                                    | TagEnd::DefinitionListDefinition
                                    | TagEnd::Table
                                    | TagEnd::TableHead
                                    | TagEnd::TableRow
                                    | TagEnd::TableCell
                                    | TagEnd::MetadataBlock(_)
                                    | TagEnd::Superscript
                                    | TagEnd::Subscript,
                                )
                                | Event::InlineMath(_)
                                | Event::DisplayMath(_)
                                | Event::FootnoteReference(_)
                                | Event::TaskListMarker(_) => {
                                    unimplemented!("feature not enabled {event:?}")
                                }
                            }
                        }
                        let short = short.unwrap_or_else(|| writer.output.trim_end().to_owned());
                        let long = writer.output.trim_end();
                        let long = has_details.then(|| long.to_owned());
                        (short, long)
                    }
                }
            }

            pub mod spanned
            {
                use ::
                {
                    *,
                };
                use proc_macro2::{Ident, Span, TokenStream};
                use quote::ToTokens;
                use syn::LitStr;

                use std::ops::{Deref, DerefMut};

                /// An entity with a span attached.
                #[derive(Debug, Copy, Clone)]
                pub struct Sp<T> {
                    val: T,
                    span: Span,
                }

                impl<T> Sp<T> {
                    pub fn new(val: T, span: Span) -> Self {
                        Sp { val, span }
                    }

                    pub fn get(&self) -> &T {
                        &self.val
                    }

                    pub fn span(&self) -> Span {
                        self.span
                    }
                }

                impl<T> Deref for Sp<T> {
                    type Target = T;

                    fn deref(&self) -> &T {
                        &self.val
                    }
                }

                impl<T> DerefMut for Sp<T> {
                    fn deref_mut(&mut self) -> &mut T {
                        &mut self.val
                    }
                }

                impl From<Ident> for Sp<String> {
                    fn from(ident: Ident) -> Self {
                        Sp {
                            val: ident.to_string(),
                            span: ident.span(),
                        }
                    }
                }

                impl From<LitStr> for Sp<String> {
                    fn from(lit: LitStr) -> Self {
                        Sp {
                            val: lit.value(),
                            span: lit.span(),
                        }
                    }
                }

                impl<'a> From<Sp<&'a str>> for Sp<String> {
                    fn from(sp: Sp<&'a str>) -> Self {
                        Sp::new(sp.val.into(), sp.span)
                    }
                }

                impl<U, T: PartialEq<U>> PartialEq<U> for Sp<T> {
                    fn eq(&self, other: &U) -> bool {
                        self.val == *other
                    }
                }

                impl<T: AsRef<str>> AsRef<str> for Sp<T> {
                    fn as_ref(&self) -> &str {
                        self.val.as_ref()
                    }
                }

                impl<T: ToTokens> ToTokens for Sp<T> {
                    fn to_tokens(&self, stream: &mut TokenStream) {
                        // this is the simplest way out of correct ones to change span on
                        // arbitrary token tree I could come up with
                        let tt = self.val.to_token_stream().into_iter().map(|mut tt| {
                            tt.set_span(self.span);
                            tt
                        });

                        stream.extend(tt);
                    }
                }
            }

            pub mod ty
            {
                //! Special types handling
                use ::
                {
                    *,
                };
                

                use super::spanned::Sp;

                use syn::{
                    spanned::Spanned, GenericArgument, Path, PathArguments, PathArguments::AngleBracketed,
                    PathSegment, Type, TypePath,
                };

                #[derive(Copy, Clone, PartialEq, Eq, Debug)]
                pub enum Ty {
                    Unit,
                    Vec,
                    VecVec,
                    Option,
                    OptionOption,
                    OptionVec,
                    OptionVecVec,
                    Other,
                }

                impl Ty {
                    pub fn from_syn_ty(ty: &Type) -> Sp<Self> {
                        use self::Ty::{Option, OptionOption, OptionVec, OptionVecVec, Other, Unit, Vec, VecVec};
                        let t = |kind| Sp::new(kind, ty.span());

                        if is_unit_ty(ty) {
                            t(Unit)
                        } else if let Some(vt) = get_vec_ty(ty, Vec, VecVec) {
                            t(vt)
                        } else if let Some(subty) = subty_if_name(ty, "Option") {
                            if is_generic_ty(subty, "Option") {
                                t(OptionOption)
                            } else if let Some(vt) = get_vec_ty(subty, OptionVec, OptionVecVec) {
                                t(vt)
                            } else {
                                t(Option)
                            }
                        } else {
                            t(Other)
                        }
                    }

                    pub fn as_str(&self) -> &'static str {
                        match self {
                            Self::Unit => "()",
                            Self::Vec => "Vec<T>",
                            Self::Option => "Option<T>",
                            Self::OptionOption => "Option<Option<T>>",
                            Self::OptionVec => "Option<Vec<T>>",
                            Self::VecVec => "Vec<Vec<T>>",
                            Self::OptionVecVec => "Option<Vec<Vec<T>>>",
                            Self::Other => "...other...",
                        }
                    }
                }

                pub fn inner_type(field_ty: &Type) -> &Type {
                    let ty = Ty::from_syn_ty(field_ty);
                    match *ty {
                        Ty::Vec | Ty::Option => sub_type(field_ty).unwrap_or(field_ty),
                        Ty::OptionOption | Ty::OptionVec | Ty::VecVec => {
                            sub_type(field_ty).and_then(sub_type).unwrap_or(field_ty)
                        }
                        Ty::OptionVecVec => sub_type(field_ty)
                            .and_then(sub_type)
                            .and_then(sub_type)
                            .unwrap_or(field_ty),
                        _ => field_ty,
                    }
                }

                pub fn sub_type(ty: &Type) -> Option<&Type> {
                    subty_if(ty, |_| true)
                }

                fn only_last_segment(mut ty: &Type) -> Option<&PathSegment> {
                    while let Type::Group(syn::TypeGroup { elem, .. }) = ty {
                        ty = elem;
                    }
                    match ty {
                        Type::Path(TypePath {
                            qself: None,
                            path:
                                Path {
                                    leading_colon: None,
                                    segments,
                                },
                        }) => only_one(segments.iter()),

                        _ => None,
                    }
                }

                fn subty_if<F>(ty: &Type, f: F) -> Option<&Type> where
                    F: FnOnce(&PathSegment) -> bool,
                {
                    only_last_segment(ty)
                        .filter(|segment| f(segment))
                        .and_then(|segment| {
                            if let AngleBracketed(args) = &segment.arguments {
                                only_one(args.args.iter()).and_then(|genneric| {
                                    if let GenericArgument::Type(ty) = genneric {
                                        Some(ty)
                                    } else {
                                        None
                                    }
                                })
                            } else {
                                None
                            }
                        })
                }

                pub fn subty_if_name<'a>(ty: &'a Type, name: &str) -> Option<&'a Type> {
                    subty_if(ty, |seg| seg.ident == name)
                }

                pub fn is_simple_ty(ty: &Type, name: &str) -> bool {
                    only_last_segment(ty)
                        .map(|segment| {
                            if let PathArguments::None = segment.arguments {
                                segment.ident == name
                            } else {
                                false
                            }
                        })
                        .unwrap_or(false)
                }

                fn is_generic_ty(ty: &Type, name: &str) -> bool {
                    subty_if_name(ty, name).is_some()
                }

                fn is_unit_ty(ty: &Type) -> bool {
                    if let Type::Tuple(tuple) = ty {
                        tuple.elems.is_empty()
                    } else {
                        false
                    }
                }

                fn only_one<I, T>(mut iter: I) -> Option<T> where
                    I: Iterator<Item = T>,
                {
                    iter.next().filter(|_| iter.next().is_none())
                }

                #[cfg(feature = "unstable-v5")]
                fn get_vec_ty(ty: &Type, vec_ty: Ty, vecvec_ty: Ty) -> Option<Ty> {
                    subty_if_name(ty, "Vec").map(|subty| {
                        if is_generic_ty(subty, "Vec") {
                            vecvec_ty
                        } else {
                            vec_ty
                        }
                    })
                }

                #[cfg(not(feature = "unstable-v5"))]
                fn get_vec_ty(ty: &Type, vec_ty: Ty, _vecvec_ty: Ty) -> Option<Ty> {
                    is_generic_ty(ty, "Vec").then_some(vec_ty)
                }
            }


            pub use doc_comments::extract_doc_comment;
            pub use doc_comments::format_doc_comment;

            pub use self::
            {
                spanned::Sp,
                ty::{inner_type, is_simple_ty, sub_type, subty_if_name, Ty},
            };
        }
        
        /// Generates the `ValueEnum` impl.
        #[proc_macro_derive(ValueEnum, attributes(clap, value))]
        pub fn value_enum(input: TokenStream) -> TokenStream {
            let input: DeriveInput = parse_macro_input!(input);
            derives::derive_value_enum(&input)
                .unwrap_or_else(|err| {
                    let dummy = dummies::value_enum(&input.ident);
                    to_compile_error(err, dummy)
                })
                .into()
        }
        /// Generates the `Parser` implementation.
        ///
        /// This is far less verbose than defining the `clap::Command` struct manually,
        /// receiving an instance of `clap::ArgMatches` from conducting parsing, and then
        /// implementing a conversion code to instantiate an instance of the user
        /// context struct.
        #[proc_macro_derive(Parser, attributes(clap, structopt, command, arg, group))]
        pub fn parser(input: TokenStream) -> TokenStream {
            let input: DeriveInput = parse_macro_input!(input);
            derives::derive_parser(&input)
                .unwrap_or_else(|err| {
                    let specific_dummy = match input.data {
                        Data::Struct(DataStruct {
                            fields: Fields::Named(ref _fields),
                            ..
                        }) => Some(dummies::args(&input.ident)),
                        Data::Struct(DataStruct {
                            fields: Fields::Unit,
                            ..
                        }) => Some(dummies::args(&input.ident)),
                        Data::Enum(_) => Some(dummies::subcommand(&input.ident)),
                        _ => None,
                    };
                    let dummy = specific_dummy
                        .map(|specific_dummy| {
                            let parser_dummy = dummies::parser(&input.ident);
                            quote::quote! {
                                #parser_dummy
                                #specific_dummy
                            }
                        })
                        .unwrap_or_else(|| quote::quote!());
                    to_compile_error(err, dummy)
                })
                .into()
        }
        /// Generates the `Subcommand` impl.
        #[proc_macro_derive(Subcommand, attributes(clap, command, arg, group))]
        pub fn subcommand(input: TokenStream) -> TokenStream {
            let input: DeriveInput = parse_macro_input!(input);
            derives::derive_subcommand(&input)
                .unwrap_or_else(|err| {
                    let dummy = dummies::subcommand(&input.ident);
                    to_compile_error(err, dummy)
                })
                .into()
        }
        /// Generates the `Args` impl.
        #[proc_macro_derive(Args, attributes(clap, command, arg, group))]
        pub fn args(input: TokenStream) -> TokenStream {
            let input: DeriveInput = parse_macro_input!(input);
            derives::derive_args(&input)
                .unwrap_or_else(|err| {
                    let dummy = dummies::args(&input.ident);
                    to_compile_error(err, dummy)
                })
                .into()
        }

        fn to_compile_error(
            error: syn::Error,
            dummy: proc_macro2::TokenStream,
        ) -> proc_macro2::TokenStream {
            let compile_errors = error.to_compile_error();
            quote::quote!(
                #dummy
                #compile_errors
            )
        }
    }

    pub mod clap_lex
    {
        //! Minimal, flexible command-line parser.
        use ::
        {
            *,
        };
        
        pub mod ext
        {
            use ::
            {
                *,
            };
            use std::ffi::OsStr;

            /// String-like methods for [`OsStr`]
            pub trait OsStrExt: private::Sealed {
                /// Converts to a string slice.
                ///
                /// The `Utf8Error` is guaranteed to have a valid UTF8 boundary
                /// in its `valid_up_to()`
                fn try_str(&self) -> Result<&str, std::str::Utf8Error>;
                /// Returns `true` if the given pattern matches a sub-slice of this string slice.
                fn contains(&self, needle: &str) -> bool;
                /// Returns the byte index of the first character of this string slice that matches the pattern.
                fn find(&self, needle: &str) -> Option<usize>;
                /// Returns a string slice with the prefix removed.in `Some`.
                fn strip_prefix(&self, prefix: &str) -> Option<&OsStr>;
                /// Returns `true` if the given pattern matches a prefix of this string slice.
                fn starts_with(&self, prefix: &str) -> bool;
                /// An iterator over substrings of this string slice, separated by characters matched by a pattern.
                fn split<'s, 'n>(&'s self, needle: &'n str) -> Split<'s, 'n>;
                /// Splits the string on the first occurrence of the delimiter and returns prefix before delimiter and suffix after delimiter.
                fn split_once(&self, needle: &'_ str) -> Option<(&OsStr, &OsStr)>;
            }

            impl OsStrExt for OsStr {
                fn try_str(&self) -> Result<&str, std::str::Utf8Error> {
                    let bytes = self.as_encoded_bytes();
                    std::str::from_utf8(bytes)
                }

                fn contains(&self, needle: &str) -> bool {
                    self.find(needle).is_some()
                }

                fn find(&self, needle: &str) -> Option<usize> {
                    let bytes = self.as_encoded_bytes();
                    (0..=self.len().checked_sub(needle.len())?)
                        .find(|&x| bytes[x..].starts_with(needle.as_bytes()))
                }

                fn strip_prefix(&self, prefix: &str) -> Option<&OsStr> {
                    let bytes = self.as_encoded_bytes();
                    bytes.strip_prefix(prefix.as_bytes()).map(|s| {
                        // SAFETY:
                        // - This came from `as_encoded_bytes`
                        // - Since `prefix` is `&str`, any split will be along UTF-8 boundary
                        unsafe { OsStr::from_encoded_bytes_unchecked(s) }
                    })
                }
                fn starts_with(&self, prefix: &str) -> bool {
                    let bytes = self.as_encoded_bytes();
                    bytes.starts_with(prefix.as_bytes())
                }

                fn split<'s, 'n>(&'s self, needle: &'n str) -> Split<'s, 'n> {
                    assert_ne!(needle, "");
                    Split {
                        haystack: Some(self),
                        needle,
                    }
                }

                fn split_once(&self, needle: &'_ str) -> Option<(&OsStr, &OsStr)> {
                    let start = self.find(needle)?;
                    let end = start + needle.len();
                    let haystack = self.as_encoded_bytes();
                    let first = &haystack[0..start];
                    let second = &haystack[end..];
                    // SAFETY:
                    // - This came from `as_encoded_bytes`
                    // - Since `needle` is `&str`, any split will be along UTF-8 boundary
                    unsafe {
                        Some((
                            OsStr::from_encoded_bytes_unchecked(first),
                            OsStr::from_encoded_bytes_unchecked(second),
                        ))
                    }
                }
            }

            mod private {
                pub trait Sealed {}

                impl Sealed for std::ffi::OsStr {}
            }

            pub struct Split<'s, 'n> {
                haystack: Option<&'s OsStr>,
                needle: &'n str,
            }

            impl<'s> Iterator for Split<'s, '_> {
                type Item = &'s OsStr;

                fn next(&mut self) -> Option<Self::Item> {
                    let haystack = self.haystack?;
                    if let Some((first, second)) = haystack.split_once(self.needle) {
                        if !haystack.is_empty() {
                            debug_assert_ne!(haystack, second);
                        }
                        self.haystack = Some(second);
                        Some(first)
                    } else {
                        self.haystack = None;
                        Some(haystack)
                    }
                }
            }
            /// Split an `OsStr`
            ///
            /// # Safety
            ///
            /// `index` must be at a valid UTF-8 boundary
            pub unsafe fn split_at(os: &OsStr, index: usize) -> (&OsStr, &OsStr) {
                unsafe {
                    let bytes = os.as_encoded_bytes();
                    let (first, second) = bytes.split_at(index);
                    (
                        OsStr::from_encoded_bytes_unchecked(first),
                        OsStr::from_encoded_bytes_unchecked(second),
                    )
                }
            }
        }

        use std::ffi::OsStr;
        use std::ffi::OsString;

        pub use std::io::SeekFrom;

        pub use ext::OsStrExt;

        /// Command-line arguments
        #[derive(Default, Clone, Debug, PartialEq, Eq)]
        pub struct RawArgs {
            items: Vec<OsString>,
        }

        impl RawArgs {
            //// Create an argument list to parse.
            pub fn from_args() -> Self {
                Self::new(std::env::args_os())
            }

            //// Create an argument list to parse.
            pub fn new(iter: impl IntoIterator<Item = impl Into<OsString>>) -> Self {
                let iter = iter.into_iter();
                Self::from(iter)
            }
            /// Create a cursor for walking the arguments.
            pub fn cursor(&self) -> ArgCursor {
                ArgCursor::new()
            }
            /// Advance the cursor, returning the next [`ParsedArg`]
            pub fn next(&self, cursor: &mut ArgCursor) -> Option<ParsedArg<'_>> {
                self.next_os(cursor).map(ParsedArg::new)
            }
            /// Advance the cursor, returning a raw argument value.
            pub fn next_os(&self, cursor: &mut ArgCursor) -> Option<&OsStr> {
                let next = self.items.get(cursor.cursor).map(|s| s.as_os_str());
                cursor.cursor = cursor.cursor.saturating_add(1);
                next
            }
            /// Return the next [`ParsedArg`]
            pub fn peek(&self, cursor: &ArgCursor) -> Option<ParsedArg<'_>> {
                self.peek_os(cursor).map(ParsedArg::new)
            }
            /// Return a raw argument value.
            pub fn peek_os(&self, cursor: &ArgCursor) -> Option<&OsStr> {
                self.items.get(cursor.cursor).map(|s| s.as_os_str())
            }
            /// Return all remaining raw arguments, advancing the cursor to the end.
            pub fn remaining(&self, cursor: &mut ArgCursor) -> impl Iterator<Item = &OsStr> {
                let remaining = self.items[cursor.cursor..].iter().map(|s| s.as_os_str());
                cursor.cursor = self.items.len();
                remaining
            }
            /// Adjust the cursor's position
            pub fn seek(&self, cursor: &mut ArgCursor, pos: SeekFrom) {
                let pos = match pos {
                    SeekFrom::Start(pos) => pos,
                    SeekFrom::End(pos) => (self.items.len() as i64).saturating_add(pos).max(0) as u64,
                    SeekFrom::Current(pos) => (cursor.cursor as i64).saturating_add(pos).max(0) as u64,
                };
                let pos = (pos as usize).min(self.items.len());
                cursor.cursor = pos;
            }
            /// Inject arguments before the [`RawArgs::next`]
            pub fn insert(
                &mut self,
                cursor: &ArgCursor,
                insert_items: impl IntoIterator<Item = impl Into<OsString>>,
            ) {
                self.items.splice(
                    cursor.cursor..cursor.cursor,
                    insert_items.into_iter().map(Into::into),
                );
            }
            /// Any remaining args?
            pub fn is_end(&self, cursor: &ArgCursor) -> bool {
                self.peek_os(cursor).is_none()
            }
        }

        impl<I, T> From<I> for RawArgs
        where
            I: Iterator<Item = T>,
            T: Into<OsString>,
        {
            fn from(val: I) -> Self {
                Self {
                    items: val.map(|x| x.into()).collect(),
                }
            }
        }
        /// Position within [`RawArgs`]
        #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
        pub struct ArgCursor {
            cursor: usize,
        }

        impl ArgCursor {
            fn new() -> Self {
                Self { cursor: 0 }
            }
        }
        /// Command-line Argument
        #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
        pub struct ParsedArg<'s> {
            inner: &'s OsStr,
        }

        impl<'s> ParsedArg<'s> {
            fn new(inner: &'s OsStr) -> Self {
                Self { inner }
            }
            /// Argument is length of 0
            pub fn is_empty(&self) -> bool {
                self.inner.is_empty()
            }
            /// Does the argument look like a stdio argument (`-`)
            pub fn is_stdio(&self) -> bool {
                self.inner == "-"
            }
            /// Does the argument look like an argument escape (`--`)
            pub fn is_escape(&self) -> bool {
                self.inner == "--"
            }
            /// Does the argument look like a negative number?
            ///
            /// This won't parse the number in full but attempts to see if this looks
            /// like something along the lines of `-3`, `-0.3`, or `-33.03`
            pub fn is_negative_number(&self) -> bool {
                self.to_value()
                    .ok()
                    .and_then(|s| Some(is_number(s.strip_prefix('-')?)))
                    .unwrap_or_default()
            }
            /// Treat as a long-flag
            pub fn to_long(&self) -> Option<(Result<&str, &OsStr>, Option<&OsStr>)> {
                let raw = self.inner;
                let remainder = raw.strip_prefix("--")?;
                if remainder.is_empty() {
                    debug_assert!(self.is_escape());
                    return None;
                }

                let (flag, value) = if let Some((p0, p1)) = remainder.split_once("=") {
                    (p0, Some(p1))
                } else {
                    (remainder, None)
                };
                let flag = flag.to_str().ok_or(flag);
                Some((flag, value))
            }
            /// Can treat as a long-flag
            pub fn is_long(&self) -> bool {
                self.inner.starts_with("--") && !self.is_escape()
            }
            /// Treat as a short-flag
            pub fn to_short(&self) -> Option<ShortFlags<'_>> {
                if let Some(remainder_os) = self.inner.strip_prefix("-") {
                    if remainder_os.starts_with("-") {
                        None
                    } else if remainder_os.is_empty() {
                        debug_assert!(self.is_stdio());
                        None
                    } else {
                        Some(ShortFlags::new(remainder_os))
                    }
                } else {
                    None
                }
            }
            /// Can treat as a short-flag
            pub fn is_short(&self) -> bool {
                self.inner.starts_with("-") && !self.is_stdio() && !self.inner.starts_with("--")
            }
            /// Treat as a value
            ///
            /// <div class="warning">
            ///
            /// **NOTE:** May return a flag or an escape.
            ///
            /// </div>
            pub fn to_value_os(&self) -> &OsStr {
                self.inner
            }
            /// Treat as a value
            ///
            /// <div class="warning">
            ///
            /// **NOTE:** May return a flag or an escape.
            ///
            /// </div>
            pub fn to_value(&self) -> Result<&str, &OsStr> {
                self.inner.to_str().ok_or(self.inner)
            }
            /// Safely print an argument that may contain non-UTF8 content
            ///
            /// This may perform lossy conversion, depending on the platform. If you would like an implementation which escapes the path please use Debug instead.
            pub fn display(&self) -> impl std::fmt::Display + '_ {
                self.inner.to_string_lossy()
            }
        }
        /// Walk through short flags within a [`ParsedArg`]
        #[derive(Clone, Debug)]
        pub struct ShortFlags<'s> {
            inner: &'s OsStr,
            utf8_prefix: std::str::CharIndices<'s>,
            invalid_suffix: Option<&'s OsStr>,
        }

        impl<'s> ShortFlags<'s> {
            fn new(inner: &'s OsStr) -> Self {
                let (utf8_prefix, invalid_suffix) = split_nonutf8_once(inner);
                let utf8_prefix = utf8_prefix.char_indices();
                Self {
                    inner,
                    utf8_prefix,
                    invalid_suffix,
                }
            }
            /// Move the iterator forward by `n` short flags
            pub fn advance_by(&mut self, n: usize) -> Result<(), usize> {
                for i in 0..n {
                    self.next().ok_or(i)?.map_err(|_| i)?;
                }
                Ok(())
            }
            /// No short flags left
            pub fn is_empty(&self) -> bool {
                self.invalid_suffix.is_none() && self.utf8_prefix.as_str().is_empty()
            }
            /// Does the short flag look like a number
            ///
            /// Ideally call this before doing any iterator
            pub fn is_negative_number(&self) -> bool {
                self.invalid_suffix.is_none() && is_number(self.utf8_prefix.as_str())
            }
            /// Advance the iterator, returning the next short flag on success
            ///
            /// On error, returns the invalid-UTF8 value
            pub fn next_flag(&mut self) -> Option<Result<char, &'s OsStr>> {
                if let Some((_, flag)) = self.utf8_prefix.next() {
                    return Some(Ok(flag));
                }

                if let Some(suffix) = self.invalid_suffix {
                    self.invalid_suffix = None;
                    return Some(Err(suffix));
                }

                None
            }
            /// Advance the iterator, returning everything left as a value
            pub fn next_value_os(&mut self) -> Option<&'s OsStr> {
                if let Some((index, _)) = self.utf8_prefix.next() {
                    self.utf8_prefix = "".char_indices();
                    self.invalid_suffix = None;
                    // SAFETY: `char_indices` ensures `index` is at a valid UTF-8 boundary
                    let remainder = unsafe { ext::split_at(self.inner, index).1 };
                    return Some(remainder);
                }

                if let Some(suffix) = self.invalid_suffix {
                    self.invalid_suffix = None;
                    return Some(suffix);
                }

                None
            }
        }

        impl<'s> Iterator for ShortFlags<'s> {
            type Item = Result<char, &'s OsStr>;

            fn next(&mut self) -> Option<Self::Item> {
                self.next_flag()
            }
        }

        fn split_nonutf8_once(b: &OsStr) -> (&str, Option<&OsStr>) {
            match b.try_str() {
                Ok(s) => (s, None),
                Err(err) => {
                    // SAFETY: `err.valid_up_to()`, which came from str::from_utf8(), is guaranteed
                    // to be a valid UTF8 boundary
                    let (valid, after_valid) = unsafe { ext::split_at(b, err.valid_up_to()) };
                    let valid = valid.try_str().unwrap();
                    (valid, Some(after_valid))
                }
            }
        }

        fn is_number(arg: &str) -> bool {
            // Return true if this looks like an integer or a float where it's all
            // digits plus an optional single dot after some digits.
            //
            // For floats allow forms such as `1.`, `1.2`, `1.2e10`, etc.
            let mut seen_dot = false;
            let mut position_of_e = None;
            for (i, c) in arg.as_bytes().iter().enumerate() {
                match c {
                    // Digits are always valid
                    b'0'..=b'9' => {}

                    // Allow a `.`, but only one, only if it comes before an
                    // optional exponent, and only if it's not the first character.
                    b'.' if !seen_dot && position_of_e.is_none() && i > 0 => seen_dot = true,

                    // Allow an exponent `e`/`E` but only at most one after the first
                    // character.
                    b'e' | b'E' if position_of_e.is_none() && i > 0 => position_of_e = Some(i),

                    _ => return false,
                }
            }

            // Disallow `-1e` which isn't a valid float since it doesn't actually have
            // an exponent.
            match position_of_e {
                Some(i) => i != arg.len() - 1,
                None => true,
            }
        }
    }
    
    pub use clap_builder::*;
    #[cfg(feature = "derive")]
    #[doc(hidden)]
    pub use clap_derive::{self, Args, Parser, Subcommand, ValueEnum};
}

pub mod errno
{
    //! Cross-platform interface to the `errno` variable.
    use ::
    {
        *,
    };
    
    mod sys
    {
        pub mod unix
        {
            //! Implementation of `errno` functionality for Unix systems.
            use ::
            {
                *,
            };
            use core::str;
            use libc::{self, c_int, size_t, strerror_r, strlen};

            use crate::Errno;

            fn from_utf8_lossy(input: &[u8]) -> &str {
                match str::from_utf8(input) {
                    Ok(valid) => valid,
                    Err(error) => unsafe { str::from_utf8_unchecked(&input[..error.valid_up_to()]) },
                }
            }

            pub fn with_description<F, T>(err: Errno, callback: F) -> T
            where
                F: FnOnce(Result<&str, Errno>) -> T,
            {
                let mut buf = [0u8; 1024];
                let c_str = unsafe {
                    let rc = strerror_r(err.0, buf.as_mut_ptr() as *mut _, buf.len() as size_t);
                    if rc != 0 {
                        // Handle negative return codes for compatibility with glibc < 2.13
                        let fm_err = match rc < 0 {
                            true => errno(),
                            false => Errno(rc),
                        };
                        if fm_err != Errno(libc::ERANGE) {
                            return callback(Err(fm_err));
                        }
                    }
                    let c_str_len = strlen(buf.as_ptr() as *const _);
                    &buf[..c_str_len]
                };
                callback(Ok(from_utf8_lossy(c_str)))
            }

            pub const STRERROR_NAME: &str = "strerror_r";

            pub fn errno() -> Errno {
                unsafe { Errno(*errno_location()) }
            }

            pub fn set_errno(Errno(errno): Errno) {
                unsafe {
                    *errno_location() = errno;
                }
            }

            extern "C" {
                #[cfg_attr(
                    any(
                        target_os = "macos",
                        target_os = "ios",
                        target_os = "tvos",
                        target_os = "watchos",
                        target_os = "visionos",
                        target_os = "freebsd"
                    ),
                    link_name = "__error"
                )]
                #[cfg_attr(
                    any(
                        target_os = "openbsd",
                        target_os = "netbsd",
                        target_os = "android",
                        target_os = "espidf",
                        target_os = "vxworks",
                        target_os = "cygwin",
                        target_env = "newlib"
                    ),
                    link_name = "__errno"
                )]
                #[cfg_attr(
                    any(target_os = "solaris", target_os = "illumos"),
                    link_name = "___errno"
                )]
                #[cfg_attr(target_os = "haiku", link_name = "_errnop")]
                #[cfg_attr(
                    any(
                        target_os = "linux",
                        target_os = "hurd",
                        target_os = "redox",
                        target_os = "dragonfly",
                        target_os = "emscripten",
                    ),
                    link_name = "__errno_location"
                )]
                #[cfg_attr(target_os = "aix", link_name = "_Errno")]
                #[cfg_attr(target_os = "nto", link_name = "__get_errno_ptr")]
                fn errno_location() -> *mut c_int;
            }
        }

        pub mod windows
        {
            //! Implementation of `errno` functionality for Windows.
            use ::
            {
                *,
            };
            
            use core::char::{self, REPLACEMENT_CHARACTER};
            use core::ptr;
            use core::str;
            use windows_sys::Win32::Foundation::{GetLastError, SetLastError, WIN32_ERROR};
            use windows_sys::Win32::System::Diagnostics::Debug::{
                FormatMessageW, FORMAT_MESSAGE_FROM_SYSTEM, FORMAT_MESSAGE_IGNORE_INSERTS,
            };

            use crate::Errno;

            fn from_utf16_lossy<'a>(input: &[u16], output: &'a mut [u8]) -> &'a str {
                let mut output_len = 0;
                for c in char::decode_utf16(input.iter().copied().take_while(|&x| x != 0))
                    .map(|x| x.unwrap_or(REPLACEMENT_CHARACTER))
                {
                    let c_len = c.len_utf8();
                    if c_len > output.len() - output_len {
                        break;
                    }
                    c.encode_utf8(&mut output[output_len..]);
                    output_len += c_len;
                }
                unsafe { str::from_utf8_unchecked(&output[..output_len]) }
            }

            pub fn with_description<F, T>(err: Errno, callback: F) -> T
            where
                F: FnOnce(Result<&str, Errno>) -> T,
            {
                // This value is calculated from the macro
                // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)
                let lang_id = 0x0800_u32;

                let mut buf = [0u16; 2048];

                unsafe {
                    let res = FormatMessageW(
                        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                        ptr::null_mut(),
                        err.0 as u32,
                        lang_id,
                        buf.as_mut_ptr(),
                        buf.len() as u32,
                        ptr::null_mut(),
                    );
                    if res == 0 {
                        // Sometimes FormatMessageW can fail e.g. system doesn't like lang_id
                        let fm_err = errno();
                        return callback(Err(fm_err));
                    }

                    let mut msg = [0u8; 2048];
                    let msg = from_utf16_lossy(&buf[..res as usize], &mut msg[..]);
                    // Trim trailing CRLF inserted by FormatMessageW
                    callback(Ok(msg.trim_end()))
                }
            }

            pub const STRERROR_NAME: &str = "FormatMessageW";

            pub fn errno() -> Errno {
                unsafe { Errno(GetLastError() as i32) }
            }

            pub fn set_errno(Errno(errno): Errno) {
                unsafe { SetLastError(errno as WIN32_ERROR) }
            }
        }
        #[cfg(unix)] pub use self::unix::{ * };
        #[cfg(windows)] pub use self::windows::{ * };
    }
    /*
    use core::fmt;
    #[cfg(feature = "std")]
    use std::error::Error;
    #[cfg(feature = "std")]
    use std::io;
    */
    /// Wraps a platform-specific error code.
    #[derive(Copy, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
    pub struct Errno(pub i32);

    impl fmt::Debug for Errno 
    {
        fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
            sys::with_description(*self, |desc| {
                fmt.debug_struct("Errno")
                    .field("code", &self.0)
                    .field("description", &desc.ok())
                    .finish()
            })
        }
    }

    impl fmt::Display for Errno 
    {
        fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
            sys::with_description(*self, |desc| match desc {
                Ok(desc) => fmt.write_str(desc),
                Err(fm_err) => write!(
                    fmt,
                    "OS error {} ({} returned error {})",
                    self.0,
                    sys::STRERROR_NAME,
                    fm_err.0
                ),
            })
        }
    }

    impl From<Errno> for i32 
    {
        fn from(e: Errno) -> Self {
            e.0
        }
    }

    impl Error for Errno 
    {
        // TODO: Remove when MSRV >= 1.27
        #[allow(deprecated)]
        fn description(&self) -> &str {
            "system error"
        }
    }

    impl From<Errno> for io::Error 
    {
        fn from(errno: Errno) -> Self {
            io::Error::from_raw_os_error(errno.0)
        }
    }
    /// Returns the platform-specific value of `errno`.
    pub fn errno() -> Errno 
    {
        sys::errno()
    }
    /// Sets the platform-specific value of `errno`.
    pub fn set_errno(err: Errno) 
    {
        sys::set_errno(err)
    }
}

pub mod exec
{
    //! A simple wrapper around the C library's `execvp` function.
    use ::
    {
        *,
    };
    

    extern crate errno;
    extern crate libc;

    use errno::{Errno, errno};
    use std::error;
    use std::error::Error as ErrorTrait; // Include for methods, not name.
    use std::ffi::{CString, NulError, OsStr, OsString};
    use std::iter::{IntoIterator, Iterator};
    use std::fmt;
    use std::ptr;
    use std::os::unix::ffi::OsStrExt;
    /// Represents an error calling `exec`.
    ///
    /// This is marked `#[must_use]`, which is unusual for error types.
    /// Normally, the fact that `Result` is marked in this fashion is
    /// sufficient, but in this case, this error is returned bare from
    /// functions that only return a result if they fail.
    #[derive(Debug)]
    #[must_use]
    pub enum Error {
        /// One of the strings passed to `execv` contained an internal null byte
        /// and can't be passed correctly to C.
        BadArgument(NulError),
        /// An error was returned by the system.
        Errno(Errno),
    }

    impl error::Error for Error {
        fn description(&self) -> &str {
            match self {
                &Error::BadArgument(_) => "bad argument to exec",
                &Error::Errno(_) => "couldn't exec process",
            }
        }
        fn cause(&self) -> Option<&error::Error> {
            match self {
                &Error::BadArgument(ref err) => Some(err),
                &Error::Errno(_) => None,
            }
        }
    }

    impl fmt::Display for Error {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                &Error::BadArgument(ref err) =>
                    write!(f, "{}: {}", self.description(), err),
                &Error::Errno(err) =>
                    write!(f, "{}: {}", self.description(), err),
            }
        }
    }

    impl From<NulError> for Error {
        /// Convert a `NulError` into an `ExecError`.
        fn from(err: NulError) -> Error {
            Error::BadArgument(err)
        }
    }
    /// Like `try!`, but it just returns the error directly without wrapping it
    /// in `Err`.  For functions that only return if something goes wrong.
    macro_rules! exec_try {
        ( $ expr : expr ) => {
            match $expr {
                Ok(val) => val,
                Err(err) => return From::from(err),
            }
        };
    }
    /// Run `program` with `args`, completely replacing the currently running program.
    pub fn execvp<S, I>(program: S, args: I) -> Error
        where S: AsRef<OsStr>, I: IntoIterator, I::Item: AsRef<OsStr>
    {
        // Add null terminations to our strings and our argument array,
        // converting them into a C-compatible format.
        let program_cstring =
            exec_try!(CString::new(program.as_ref().as_bytes()));
        let arg_cstrings = exec_try!(args.into_iter().map(|arg| {
            CString::new(arg.as_ref().as_bytes())
        }).collect::<Result<Vec<_>, _>>());
        let mut arg_charptrs: Vec<_> = arg_cstrings.iter().map(|arg| {
            arg.as_ptr()
        }).collect();
        arg_charptrs.push(ptr::null());

        // Use an `unsafe` block so that we can call directly into C.
        let res = unsafe {
            libc::execvp(program_cstring.as_ptr(), arg_charptrs.as_ptr())
        };

        // Handle our error result.
        if res < 0 {
            Error::Errno(errno())
        } else {
            // Should never happen.
            panic!("execvp returned unexpectedly")
        }
    }
    /// Build a command to execute.  This has an API which is deliberately similar to `std::process::Command`.
    pub struct Command {
        /// The program name and arguments, in typical C `argv` style.
        argv: Vec<OsString>,
    }

    impl Command {
        /// Create a new command builder, specifying the program to run.  The
        /// program will be searched for using the usual rules for `PATH`.
        pub fn new<S: AsRef<OsStr>>(program: S) -> Command {
            Command {
                argv: vec!(program.as_ref().to_owned()),
            }
        }
        /// Add an argument to the command builder.  This can be chained.
        pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {
            self.argv.push(arg.as_ref().to_owned());
            self
        }
        /// Add multiple arguments to the command builder.
        pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command {
            for arg in args {
                self.arg(arg.as_ref());
            }
            self
        }
        /// Execute the command we built.  If this function succeeds, it will never return.
        pub fn exec(&mut self) -> Error {
            execvp(&self.argv[0], &self.argv)
        }
    }
}

pub mod glob
{
    //! Support for matching file paths against Unix shell style patterns.
    use ::
    {
        *,
    };
    
    use std::cmp;
    use std::cmp::Ordering;
    use std::error::Error;
    use std::fmt;
    use std::fs;
    use std::fs::DirEntry;
    use std::io;
    use std::ops::Deref;
    use std::path::{self, Component, Path, PathBuf};
    use std::str::FromStr;

    use CharSpecifier::{CharRange, SingleChar};
    use MatchResult::{EntirePatternDoesntMatch, Match, SubPatternDoesntMatch};
    use PatternToken::AnyExcept;
    use PatternToken::{AnyChar, AnyRecursiveSequence, AnySequence, AnyWithin, Char};
    /// An iterator that yields `Path`s from the filesystem that match a particular pattern.
    #[derive(Debug)]
    pub struct Paths {
        dir_patterns: Vec<Pattern>,
        require_dir: bool,
        options: MatchOptions,
        todo: Vec<Result<(PathWrapper, usize), GlobError>>,
        scope: Option<PathWrapper>,
    }
    /// Return an iterator that produces all the `Path`s that match the given
    /// pattern using default match options, which may be absolute or relative to
    /// the current working directory.
    pub fn glob(pattern: &str) -> Result<Paths, PatternError> {
        glob_with(pattern, MatchOptions::new())
    }
    /// Return an iterator that produces all the `Path`s that match the given
    /// pattern using the specified match options, which may be absolute or relative
    /// to the current working directory.
    pub fn glob_with(pattern: &str, options: MatchOptions) -> Result<Paths, PatternError> {
        #[cfg(windows)]
        fn check_windows_verbatim(p: &Path) -> bool {
            match p.components().next() {
                Some(Component::Prefix(ref p)) => {
                    // Allow VerbatimDisk paths. std canonicalize() generates them, and they work fine
                    p.kind().is_verbatim()
                        && if let std::path::Prefix::VerbatimDisk(_) = p.kind() {
                            false
                        } else {
                            true
                        }
                }
                _ => false,
            }
        }
        #[cfg(not(windows))]
        fn check_windows_verbatim(_: &Path) -> bool {
            false
        }

        #[cfg(windows)]
        fn to_scope(p: &Path) -> PathBuf {
            // FIXME handle volume relative paths here
            p.to_path_buf()
        }
        #[cfg(not(windows))]
        fn to_scope(p: &Path) -> PathBuf {
            p.to_path_buf()
        }

        // make sure that the pattern is valid first, else early return with error
        let _ = Pattern::new(pattern)?;

        let mut components = Path::new(pattern).components().peekable();
        loop {
            match components.peek() {
                Some(&Component::Prefix(..)) | Some(&Component::RootDir) => {
                    components.next();
                }
                _ => break,
            }
        }
        let rest = components.map(|s| s.as_os_str()).collect::<PathBuf>();
        let normalized_pattern = Path::new(pattern).iter().collect::<PathBuf>();
        let root_len = normalized_pattern.to_str().unwrap().len() - rest.to_str().unwrap().len();
        let root = if root_len > 0 {
            Some(Path::new(&pattern[..root_len]))
        } else {
            None
        };

        if root_len > 0 && check_windows_verbatim(root.unwrap()) {
            // FIXME: How do we want to handle verbatim paths? I'm inclined to
            // return nothing, since we can't very well find all UNC shares with a
            // 1-letter server name.
            return Ok(Paths {
                dir_patterns: Vec::new(),
                require_dir: false,
                options,
                todo: Vec::new(),
                scope: None,
            });
        }

        let scope = root.map_or_else(|| PathBuf::from("."), to_scope);
        let scope = PathWrapper::from_path(scope);

        let mut dir_patterns = Vec::new();
        let components =
            pattern[cmp::min(root_len, pattern.len())..].split_terminator(path::is_separator);

        for component in components {
            dir_patterns.push(Pattern::new(component)?);
        }

        if root_len == pattern.len() {
            dir_patterns.push(Pattern {
                original: "".to_string(),
                tokens: Vec::new(),
                is_recursive: false,
            });
        }

        let last_is_separator = pattern.chars().next_back().map(path::is_separator);
        let require_dir = last_is_separator == Some(true);
        let todo = Vec::new();

        Ok(Paths {
            dir_patterns,
            require_dir,
            options,
            todo,
            scope: Some(scope),
        })
    }
    /// A glob iteration error.
    #[derive(Debug)]
    pub struct GlobError {
        path: PathBuf,
        error: io::Error,
    }

    impl GlobError {
        /// The Path that the error corresponds to.
        pub fn path(&self) -> &Path {
            &self.path
        }
        /// The error in question.
        pub fn error(&self) -> &io::Error {
            &self.error
        }
        /// Consumes self, returning the _raw_ underlying `io::Error`
        pub fn into_error(self) -> io::Error {
            self.error
        }
    }

    impl Error for GlobError {
        #[allow(deprecated)]
        fn description(&self) -> &str {
            self.error.description()
        }

        #[allow(unknown_lints, bare_trait_objects)]
        fn cause(&self) -> Option<&Error> {
            Some(&self.error)
        }
    }

    impl fmt::Display for GlobError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(
                f,
                "attempting to read `{}` resulted in an error: {}",
                self.path.display(),
                self.error
            )
        }
    }

    #[derive(Debug)]
    struct PathWrapper {
        path: PathBuf,
        is_directory: bool,
    }

    impl PathWrapper {
        fn from_dir_entry(path: PathBuf, e: DirEntry) -> Self {
            let is_directory = e
                .file_type()
                .ok()
                .and_then(|file_type| {
                    // We need to use fs::metadata to resolve the actual path
                    // if it's a symlink.
                    if file_type.is_symlink() {
                        None
                    } else {
                        Some(file_type.is_dir())
                    }
                })
                .or_else(|| fs::metadata(&path).map(|m| m.is_dir()).ok())
                .unwrap_or(false);
            Self { path, is_directory }
        }
        fn from_path(path: PathBuf) -> Self {
            let is_directory = fs::metadata(&path).map(|m| m.is_dir()).unwrap_or(false);
            Self { path, is_directory }
        }

        fn into_path(self) -> PathBuf {
            self.path
        }
    }

    impl Deref for PathWrapper {
        type Target = Path;

        fn deref(&self) -> &Self::Target {
            self.path.deref()
        }
    }

    impl AsRef<Path> for PathWrapper {
        fn as_ref(&self) -> &Path {
            self.path.as_ref()
        }
    }
    /// An alias for a glob iteration result.
    ///
    /// This represents either a matched path or a glob iteration error,
    /// such as failing to read a particular directory's contents.
    pub type GlobResult = Result<PathBuf, GlobError>;

    impl Iterator for Paths {
        type Item = GlobResult;

        fn next(&mut self) -> Option<GlobResult> {
            // the todo buffer hasn't been initialized yet, so it's done at this
            // point rather than in glob() so that the errors are unified that is,
            // failing to fill the buffer is an iteration error construction of the
            // iterator (i.e. glob()) only fails if it fails to compile the Pattern
            if let Some(scope) = self.scope.take() {
                if !self.dir_patterns.is_empty() {
                    // Shouldn't happen, but we're using -1 as a special index.
                    assert!(self.dir_patterns.len() < std::usize::MAX);

                    fill_todo(&mut self.todo, &self.dir_patterns, 0, &scope, self.options);
                }
            }

            loop {
                if self.dir_patterns.is_empty() || self.todo.is_empty() {
                    return None;
                }

                let (path, mut idx) = match self.todo.pop().unwrap() {
                    Ok(pair) => pair,
                    Err(e) => return Some(Err(e)),
                };

                // idx -1: was already checked by fill_todo, maybe path was '.' or
                // '..' that we can't match here because of normalization.
                if idx == std::usize::MAX {
                    if self.require_dir && !path.is_directory {
                        continue;
                    }
                    return Some(Ok(path.into_path()));
                }

                if self.dir_patterns[idx].is_recursive {
                    let mut next = idx;

                    // collapse consecutive recursive patterns
                    while (next + 1) < self.dir_patterns.len()
                        && self.dir_patterns[next + 1].is_recursive
                    {
                        next += 1;
                    }

                    if path.is_directory {
                        // the path is a directory, so it's a match

                        // push this directory's contents
                        fill_todo(
                            &mut self.todo,
                            &self.dir_patterns,
                            next,
                            &path,
                            self.options,
                        );

                        if next == self.dir_patterns.len() - 1 {
                            // pattern ends in recursive pattern, so return this
                            // directory as a result
                            return Some(Ok(path.into_path()));
                        } else {
                            // advanced to the next pattern for this path
                            idx = next + 1;
                        }
                    } else if next == self.dir_patterns.len() - 1 {
                        // not a directory and it's the last pattern, meaning no
                        // match
                        continue;
                    } else {
                        // advanced to the next pattern for this path
                        idx = next + 1;
                    }
                }

                // not recursive, so match normally
                if self.dir_patterns[idx].matches_with(
                    {
                        match path.file_name().and_then(|s| s.to_str()) {
                            // FIXME (#9639): How do we handle non-utf8 filenames?
                            // Ignore them for now; ideally we'd still match them
                            // against a *
                            None => continue,
                            Some(x) => x,
                        }
                    },
                    self.options,
                ) {
                    if idx == self.dir_patterns.len() - 1 {
                        // it is not possible for a pattern to match a directory
                        // *AND* its children so we don't need to check the
                        // children

                        if !self.require_dir || path.is_directory {
                            return Some(Ok(path.into_path()));
                        }
                    } else {
                        fill_todo(
                            &mut self.todo,
                            &self.dir_patterns,
                            idx + 1,
                            &path,
                            self.options,
                        );
                    }
                }
            }
        }
    }
    /// A pattern parsing error.
    #[derive(Debug)]
    #[allow(missing_copy_implementations)]
    pub struct PatternError {
        /// The approximate character index of where the error occurred.
        pub pos: usize,

        /// A message describing the error.
        pub msg: &'static str,
    }

    impl Error for PatternError {
        fn description(&self) -> &str {
            self.msg
        }
    }

    impl fmt::Display for PatternError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(
                f,
                "Pattern syntax error near position {}: {}",
                self.pos, self.msg
            )
        }
    }
    /// A compiled Unix shell style pattern.
    ///
    /// - `?` matches any single character.
    ///
    /// - `*` matches any (possibly empty) sequence of characters.
    ///
    /// - `**` matches the current directory and arbitrary
    ///   subdirectories. To match files in arbitrary subdiretories, use
    ///   `**/*`.
    ///
    ///   This sequence **must** form a single path component, so both
    ///   `**a` and `b**` are invalid and will result in an error.  A
    ///   sequence of more than two consecutive `*` characters is also
    ///   invalid.
    ///
    /// - `[...]` matches any character inside the brackets.  Character sequences
    ///   can also specify ranges of characters, as ordered by Unicode, so e.g.
    ///   `[0-9]` specifies any character between 0 and 9 inclusive. An unclosed
    ///   bracket is invalid.
    ///
    /// - `[!...]` is the negation of `[...]`, i.e. it matches any characters
    ///   **not** in the brackets.
    ///
    /// - The metacharacters `?`, `*`, `[`, `]` can be matched by using brackets
    ///   (e.g. `[?]`).  When a `]` occurs immediately following `[` or `[!` then it
    ///   is interpreted as being part of, rather then ending, the character set, so
    ///   `]` and NOT `]` can be matched by `[]]` and `[!]]` respectively.  The `-`
    ///   character can be specified inside a character sequence pattern by placing
    ///   it at the start or the end, e.g. `[abc-]`.
    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Debug)]
    pub struct Pattern {
        original: String,
        tokens: Vec<PatternToken>,
        is_recursive: bool,
    }
    /// Show the original glob pattern.
    impl fmt::Display for Pattern {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.original.fmt(f)
        }
    }

    impl FromStr for Pattern {
        type Err = PatternError;

        fn from_str(s: &str) -> Result<Self, PatternError> {
            Self::new(s)
        }
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    enum PatternToken {
        Char(char),
        AnyChar,
        AnySequence,
        AnyRecursiveSequence,
        AnyWithin(Vec<CharSpecifier>),
        AnyExcept(Vec<CharSpecifier>),
    }

    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    enum CharSpecifier {
        SingleChar(char),
        CharRange(char, char),
    }

    #[derive(Copy, Clone, PartialEq)]
    enum MatchResult {
        Match,
        SubPatternDoesntMatch,
        EntirePatternDoesntMatch,
    }

    const ERROR_WILDCARDS: &str = "wildcards are either regular `*` or recursive `**`";
    const ERROR_RECURSIVE_WILDCARDS: &str = "recursive wildcards must form a single path \
                                            component";
    const ERROR_INVALID_RANGE: &str = "invalid range pattern";

    impl Pattern {
        /// This function compiles Unix shell style patterns.
        pub fn new(pattern: &str) -> Result<Self, PatternError> {
            let chars = pattern.chars().collect::<Vec<_>>();
            let mut tokens = Vec::new();
            let mut is_recursive = false;
            let mut i = 0;

            while i < chars.len() {
                match chars[i] {
                    '?' => {
                        tokens.push(AnyChar);
                        i += 1;
                    }
                    '*' => {
                        let old = i;

                        while i < chars.len() && chars[i] == '*' {
                            i += 1;
                        }

                        let count = i - old;

                        match count.cmp(&2) {
                            Ordering::Greater => {
                                return Err(PatternError {
                                    pos: old + 2,
                                    msg: ERROR_WILDCARDS,
                                })
                            }
                            Ordering::Equal => {
                                // ** can only be an entire path component
                                // i.e. a/**/b is valid, but a**/b or a/**b is not
                                // invalid matches are treated literally
                                let is_valid = if i == 2 || path::is_separator(chars[i - count - 1]) {
                                    // it ends in a '/'
                                    if i < chars.len() && path::is_separator(chars[i]) {
                                        i += 1;
                                        true
                                    // or the pattern ends here
                                    // this enables the existing globbing mechanism
                                    } else if i == chars.len() {
                                        true
                                    // `**` ends in non-separator
                                    } else {
                                        return Err(PatternError {
                                            pos: i,
                                            msg: ERROR_RECURSIVE_WILDCARDS,
                                        });
                                    }
                                // `**` begins with non-separator
                                } else {
                                    return Err(PatternError {
                                        pos: old - 1,
                                        msg: ERROR_RECURSIVE_WILDCARDS,
                                    });
                                };

                                if is_valid {
                                    // collapse consecutive AnyRecursiveSequence to a
                                    // single one

                                    let tokens_len = tokens.len();

                                    if !(tokens_len > 1
                                        && tokens[tokens_len - 1] == AnyRecursiveSequence)
                                    {
                                        is_recursive = true;
                                        tokens.push(AnyRecursiveSequence);
                                    }
                                }
                            }
                            Ordering::Less => tokens.push(AnySequence),
                        }
                    }
                    '[' => {
                        if i + 4 <= chars.len() && chars[i + 1] == '!' {
                            match chars[i + 3..].iter().position(|x| *x == ']') {
                                None => (),
                                Some(j) => {
                                    let chars = &chars[i + 2..i + 3 + j];
                                    let cs = parse_char_specifiers(chars);
                                    tokens.push(AnyExcept(cs));
                                    i += j + 4;
                                    continue;
                                }
                            }
                        } else if i + 3 <= chars.len() && chars[i + 1] != '!' {
                            match chars[i + 2..].iter().position(|x| *x == ']') {
                                None => (),
                                Some(j) => {
                                    let cs = parse_char_specifiers(&chars[i + 1..i + 2 + j]);
                                    tokens.push(AnyWithin(cs));
                                    i += j + 3;
                                    continue;
                                }
                            }
                        }

                        // if we get here then this is not a valid range pattern
                        return Err(PatternError {
                            pos: i,
                            msg: ERROR_INVALID_RANGE,
                        });
                    }
                    c => {
                        tokens.push(Char(c));
                        i += 1;
                    }
                }
            }

            Ok(Self {
                tokens,
                original: pattern.to_string(),
                is_recursive,
            })
        }
        /// Escape metacharacters within the given string by surrounding them in
        /// brackets. The resulting string will, when compiled into a `Pattern`,
        /// match the input string and nothing else.
        pub fn escape(s: &str) -> String {
            let mut escaped = String::new();
            for c in s.chars() {
                match c {
                    // note that ! does not need escaping because it is only special
                    // inside brackets
                    '?' | '*' | '[' | ']' => {
                        escaped.push('[');
                        escaped.push(c);
                        escaped.push(']');
                    }
                    c => {
                        escaped.push(c);
                    }
                }
            }
            escaped
        }
        /// Return if the given `str` matches this `Pattern` using the default
        /// match options (i.e. `MatchOptions::new()`).
        pub fn matches(&self, str: &str) -> bool {
            self.matches_with(str, MatchOptions::new())
        }
        /// Return if the given `Path`, when converted to a `str`, matches this
        /// `Pattern` using the default match options (i.e. `MatchOptions::new()`).
        pub fn matches_path(&self, path: &Path) -> bool {
            // FIXME (#9639): This needs to handle non-utf8 paths
            path.to_str().map_or(false, |s| self.matches(s))
        }
        /// Return if the given `str` matches this `Pattern` using the specified
        /// match options.
        pub fn matches_with(&self, str: &str, options: MatchOptions) -> bool {
            self.matches_from(true, str.chars(), 0, options) == Match
        }
        /// Return if the given `Path`, when converted to a `str`, matches this
        /// `Pattern` using the specified match options.
        pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool {
            // FIXME (#9639): This needs to handle non-utf8 paths
            path.to_str()
                .map_or(false, |s| self.matches_with(s, options))
        }
        /// Access the original glob pattern.
        pub fn as_str(&self) -> &str {
            &self.original
        }

        fn matches_from(
            &self,
            mut follows_separator: bool,
            mut file: std::str::Chars,
            i: usize,
            options: MatchOptions,
        ) -> MatchResult {
            for (ti, token) in self.tokens[i..].iter().enumerate() {
                match *token {
                    AnySequence | AnyRecursiveSequence => {
                        // ** must be at the start.
                        debug_assert!(match *token {
                            AnyRecursiveSequence => follows_separator,
                            _ => true,
                        });

                        // Empty match
                        match self.matches_from(follows_separator, file.clone(), i + ti + 1, options) {
                            SubPatternDoesntMatch => (), // keep trying
                            m => return m,
                        };

                        while let Some(c) = file.next() {
                            if follows_separator && options.require_literal_leading_dot && c == '.' {
                                return SubPatternDoesntMatch;
                            }
                            follows_separator = path::is_separator(c);
                            match *token {
                                AnyRecursiveSequence if !follows_separator => continue,
                                AnySequence
                                    if options.require_literal_separator && follows_separator =>
                                {
                                    return SubPatternDoesntMatch
                                }
                                _ => (),
                            }
                            match self.matches_from(
                                follows_separator,
                                file.clone(),
                                i + ti + 1,
                                options,
                            ) {
                                SubPatternDoesntMatch => (), // keep trying
                                m => return m,
                            }
                        }
                    }
                    _ => {
                        let c = match file.next() {
                            Some(c) => c,
                            None => return EntirePatternDoesntMatch,
                        };

                        let is_sep = path::is_separator(c);

                        if !match *token {
                            AnyChar | AnyWithin(..) | AnyExcept(..)
                                if (options.require_literal_separator && is_sep)
                                    || (follows_separator
                                        && options.require_literal_leading_dot
                                        && c == '.') =>
                            {
                                false
                            }
                            AnyChar => true,
                            AnyWithin(ref specifiers) => in_char_specifiers(specifiers, c, options),
                            AnyExcept(ref specifiers) => !in_char_specifiers(specifiers, c, options),
                            Char(c2) => chars_eq(c, c2, options.case_sensitive),
                            AnySequence | AnyRecursiveSequence => unreachable!(),
                        } {
                            return SubPatternDoesntMatch;
                        }
                        follows_separator = is_sep;
                    }
                }
            }

            // Iter is fused.
            if file.next().is_none() {
                Match
            } else {
                SubPatternDoesntMatch
            }
        }
    }
    
    fn fill_todo(
        todo: &mut Vec<Result<(PathWrapper, usize), GlobError>>,
        patterns: &[Pattern],
        idx: usize,
        path: &PathWrapper,
        options: MatchOptions,
    ) {
        // convert a pattern that's just many Char(_) to a string
        fn pattern_as_str(pattern: &Pattern) -> Option<String> {
            let mut s = String::new();
            for token in &pattern.tokens {
                match *token {
                    Char(c) => s.push(c),
                    _ => return None,
                }
            }

            Some(s)
        }

        let add = |todo: &mut Vec<_>, next_path: PathWrapper| {
            if idx + 1 == patterns.len() {
                // We know it's good, so don't make the iterator match this path
                // against the pattern again. In particular, it can't match
                // . or .. globs since these never show up as path components.
                todo.push(Ok((next_path, std::usize::MAX)));
            } else {
                fill_todo(todo, patterns, idx + 1, &next_path, options);
            }
        };

        let pattern = &patterns[idx];
        let is_dir = path.is_directory;
        let curdir = path.as_ref() == Path::new(".");
        match pattern_as_str(pattern) {
            Some(s) => {
                // This pattern component doesn't have any metacharacters, so we
                // don't need to read the current directory to know where to
                // continue. So instead of passing control back to the iterator,
                // we can just check for that one entry and potentially recurse
                // right away.
                let special = "." == s || ".." == s;
                let next_path = if curdir {
                    PathBuf::from(s)
                } else {
                    path.join(&s)
                };
                let next_path = PathWrapper::from_path(next_path);
                if (special && is_dir)
                    || (!special
                        && (fs::metadata(&next_path).is_ok()
                            || fs::symlink_metadata(&next_path).is_ok()))
                {
                    add(todo, next_path);
                }
            }
            None if is_dir => {
                let dirs = fs::read_dir(path).and_then(|d| {
                    d.map(|e| {
                        e.map(|e| {
                            let path = if curdir {
                                PathBuf::from(e.path().file_name().unwrap())
                            } else {
                                e.path()
                            };
                            PathWrapper::from_dir_entry(path, e)
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()
                });
                match dirs {
                    Ok(mut children) => {
                        if options.require_literal_leading_dot {
                            children
                                .retain(|x| !x.file_name().unwrap().to_str().unwrap().starts_with('.'));
                        }
                        children.sort_by(|p1, p2| p2.file_name().cmp(&p1.file_name()));
                        todo.extend(children.into_iter().map(|x| Ok((x, idx))));

                        // Matching the special directory entries . and .. that
                        // refer to the current and parent directory respectively
                        // requires that the pattern has a leading dot, even if the
                        // `MatchOptions` field `require_literal_leading_dot` is not
                        // set.
                        if !pattern.tokens.is_empty() && pattern.tokens[0] == Char('.') {
                            for &special in &[".", ".."] {
                                if pattern.matches_with(special, options) {
                                    add(todo, PathWrapper::from_path(path.join(special)));
                                }
                            }
                        }
                    }
                    Err(e) => {
                        todo.push(Err(GlobError {
                            path: path.to_path_buf(),
                            error: e,
                        }));
                    }
                }
            }
            None => {
                // not a directory, nothing more to find
            }
        }
    }

    fn parse_char_specifiers(s: &[char]) -> Vec<CharSpecifier> {
        let mut cs = Vec::new();
        let mut i = 0;
        while i < s.len() {
            if i + 3 <= s.len() && s[i + 1] == '-' {
                cs.push(CharRange(s[i], s[i + 2]));
                i += 3;
            } else {
                cs.push(SingleChar(s[i]));
                i += 1;
            }
        }
        cs
    }

    fn in_char_specifiers(specifiers: &[CharSpecifier], c: char, options: MatchOptions) -> bool {
        for &specifier in specifiers.iter() {
            match specifier {
                SingleChar(sc) => {
                    if chars_eq(c, sc, options.case_sensitive) {
                        return true;
                    }
                }
                CharRange(start, end) => {
                    // FIXME: work with non-ascii chars properly (issue #1347)
                    if !options.case_sensitive && c.is_ascii() && start.is_ascii() && end.is_ascii() {
                        let start = start.to_ascii_lowercase();
                        let end = end.to_ascii_lowercase();

                        let start_up = start.to_uppercase().next().unwrap();
                        let end_up = end.to_uppercase().next().unwrap();

                        // only allow case insensitive matching when
                        // both start and end are within a-z or A-Z
                        if start != start_up && end != end_up {
                            let c = c.to_ascii_lowercase();
                            if c >= start && c <= end {
                                return true;
                            }
                        }
                    }

                    if c >= start && c <= end {
                        return true;
                    }
                }
            }
        }

        false
    }
    /// A helper function to determine if two chars are (possibly case-insensitively) equal.
    fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {
        if cfg!(windows) && path::is_separator(a) && path::is_separator(b) {
            true
        } else if !case_sensitive && a.is_ascii() && b.is_ascii() {
            // FIXME: work with non-ascii chars properly (issue #9084)
            a.eq_ignore_ascii_case(&b)
        } else {
            a == b
        }
    }
    /// Configuration options to modify the behaviour of `Pattern::matches_with(..)`.
    #[allow(missing_copy_implementations)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    pub struct MatchOptions {
        /// Whether or not patterns should be matched in a case-sensitive manner.
        /// This currently only considers upper/lower case relationships between
        /// ASCII characters, but in future this might be extended to work with
        /// Unicode.
        pub case_sensitive: bool,

        /// Whether or not path-component separator characters (e.g. `/` on
        /// Posix) must be matched by a literal `/`, rather than by `*` or `?` or
        /// `[...]`.
        pub require_literal_separator: bool,

        /// Whether or not paths that contain components that start with a `.`
        /// will require that `.` appears literally in the pattern; `*`, `?`, `**`,
        /// or `[...]` will not match. This is useful because such files are
        /// conventionally considered hidden on Unix systems and it might be
        /// desirable to skip them when listing files.
        pub require_literal_leading_dot: bool,
    }

    impl MatchOptions {
        /// Constructs a new `MatchOptions` with default field values.
        pub fn new() -> Self {
            Self {
                case_sensitive: true,
                require_literal_separator: false,
                require_literal_leading_dot: false,
            }
        }
    }
}

pub mod lineread
{
    //! Provides a configurable, concurrent, extensible, interactive input reader for Unix terminals and Windows console.
    use ::
    {
        *,
    };
    
    pub use crate::command::Command;
    pub use crate::complete::{Completer, Completion, Suffix};
    pub use crate::function::Function;
    pub use crate::interface::Interface;
    pub use crate::prompter::Prompter;
    pub use crate::reader::{Reader, ReadResult};
    pub use crate::terminal::{DefaultTerminal, Signal, Terminal};
    pub use crate::writer::Writer;

    pub mod chars
    {
        //! Provides utilities for manipulating character values
        use ::
        {
            *,
        };
        

        // This is technically configurable on Unix, but exposing that information
        // from the low-level terminal interface and storing it in Reader is a pain.
        // Does anyone even care?
        /// Character value indicating end-of-file
        pub const EOF: char = '\x04';

        /// Character value generated by the Escape key
        pub const ESCAPE: char = '\x1b';

        /// Character value generated by the Backspace key
        ///
        /// On Unix systems, this is equivalent to `RUBOUT`
        #[cfg(unix)]
        pub const DELETE: char = RUBOUT;

        /// Character value generated by the Backspace key
        ///
        /// On Windows systems, this character is Ctrl-H
        #[cfg(windows)]
        pub const DELETE: char = '\x08';

        /// Character value generated by the Backspace key on some systems
        pub const RUBOUT: char = '\x7f';

        /// Returns a character name as a key sequence, e.g. `Control-x` or `Meta-x`.
        ///
        /// Returns `None` if the name is invalid.
        pub fn parse_char_name(name: &str) -> Option<String> {
            let name_lc = name.to_lowercase();

            let is_ctrl = contains_any(&name_lc, &["c-", "ctrl-", "control-"]);
            let is_meta = contains_any(&name_lc, &["m-", "meta-"]);

            let name = match name_lc.rfind('-') {
                Some(pos) => &name_lc[pos + 1..],
                None => &name_lc[..]
            };

            let ch = match name {
                "del" | "rubout"  => DELETE,
                "esc" | "escape"  => ESCAPE,
                "lfd" | "newline" => '\n',
                "ret" | "return"  => '\r',
                "spc" | "space"   => ' ',
                "tab"             => '\t',
                s if !s.is_empty() => s.chars().next().unwrap(),
                _ => return None
            };

            let ch = match (is_ctrl, is_meta) {
                (true,  true)  => meta(ctrl(ch)),
                (true,  false) => ctrl(ch).to_string(),
                (false, true)  => meta(ch),
                (false, false) => ch.to_string(),
            };

            Some(ch)
        }
        /// Returns a character sequence escaped for user-facing display.
        ///
        /// Escape is formatted as `\e`.
        /// Control key combinations are prefixed with `\C-`.
        pub fn escape_sequence(s: &str) -> String {
            let mut res = String::with_capacity(s.len());

            for ch in s.chars() {
                match ch {
                    ESCAPE => res.push_str(r"\e"),
                    RUBOUT => res.push_str(r"\C-?"),
                    '\\' => res.push_str(r"\\"),
                    '\'' => res.push_str(r"\'"),
                    '"' => res.push_str(r#"\""#),
                    ch if is_ctrl(ch) => {
                        res.push_str(r"\C-");
                        res.push(unctrl_lower(ch));
                    }
                    ch => res.push(ch)
                }
            }

            res
        }
        /// Returns a meta sequence for the given character.
        pub fn meta(ch: char) -> String {
            let mut s = String::with_capacity(ch.len_utf8() + 1);
            s.push(ESCAPE);
            s.push(ch);
            s
        }

        fn contains_any(s: &str, strs: &[&str]) -> bool {
            strs.iter().any(|a| s.contains(a))
        }
        /// Returns whether the character is printable.
        ///
        /// That is, not NUL or a control character (other than Tab or Newline).
        pub fn is_printable(c: char) -> bool {
            c == '\t' || c == '\n' || !(c == '\0' || is_ctrl(c))
        }

        const CTRL_BIT: u8 = 0x40;
        const CTRL_MASK: u8 = 0x1f;

        /// Returns whether the given character is a control character.
        pub fn is_ctrl(c: char) -> bool {
            const CTRL_MAX: u32 = 0x1f;

            c != '\0' && c as u32 <= CTRL_MAX
        }
        /// Returns a control character for the given character.
        pub fn ctrl(c: char) -> char {
            ((c as u8) & CTRL_MASK) as char
        }
        /// Returns the printable character corresponding to the given control character.
        pub fn unctrl(c: char) -> char {
            ((c as u8) | CTRL_BIT) as char
        }
        /// Returns the lowercase character corresponding to the given control character.
        pub fn unctrl_lower(c: char) -> char {
            unctrl(c).to_ascii_lowercase()
        }
    }

    pub mod command
    {
        //! Defines the set of line editing commands
        use ::
        {
            *,
        };
        

        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::fmt;

        use crate::chars::escape_sequence;

        macro_rules! define_commands {
            ( $( #[$meta:meta] $name:ident => $str:expr , )+ ) => {
                /// Represents a command to modify `Reader` state
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub enum Command {
                    $( #[$meta] $name , )+
                    /// Custom application-defined command
                    Custom(Cow<'static, str>),
                    /// Execute a given key sequence
                    Macro(Cow<'static, str>),
                }
                /// List of all command names
                pub static COMMANDS: &[&str] = &[ $( $str ),+ ];

                impl fmt::Display for Command {
                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                        match *self {
                            $( Command::$name => f.write_str($str) , )+
                            Command::Custom(ref s) => f.write_str(s),
                            Command::Macro(ref s) => write!(f, "\"{}\"",
                                escape_sequence(s))
                        }
                    }
                }

                impl Command {
                    /// Constructs a command from a `'static str` reference.
                    ///
                    /// If the string does not refer to a built-in command, a value
                    /// of `Command::Custom(Borrowed(name))` will be returned.
                    pub fn from_str(name: &'static str) -> Command {
                        Command::opt_from_str(name)
                            .unwrap_or_else(|| Command::Custom(Borrowed(name)))
                    }
                    /// Constructs a command from a non-`'static` string-like type.
                    ///
                    /// If the string does not refer to a built-in command, a value
                    /// of `Command::Custom(Owned(name.into()))` will be returned.
                    pub fn from_string<T>(name: T) -> Command
                            where T: AsRef<str> + Into<String> {
                        Command::opt_from_str(name.as_ref())
                            .unwrap_or_else(|| Command::Custom(Owned(name.into())))
                    }

                    fn opt_from_str(s: &str) -> Option<Command> {
                        match s {
                            $( $str => Some(Command::$name), )+
                            _ => None
                        }
                    }
                }
            }
        }

        define_commands!{
            /// Abort history search
            Abort => "abort",
            /// Accepts the current input line
            AcceptLine => "accept-line",
            /// Perform completion
            Complete => "complete",
            /// Insert all completions into the input buffer
            InsertCompletions => "insert-completions",
            /// Show possible completions
            PossibleCompletions => "possible-completions",
            /// Insert the next possible completion
            MenuComplete => "menu-complete",
            /// Insert the previous possible completion
            MenuCompleteBackward => "menu-complete-backward",
            /// Begin numeric argument input
            DigitArgument => "digit-argument",
            /// Insert character or sequence at the cursor
            SelfInsert => "self-insert",
            /// Inserts a tab character
            TabInsert => "tab-insert",
            /// Toggles insert/overwrite mode
            OverwriteMode => "overwrite-mode",
            /// Insert a comment and accept input
            InsertComment => "insert-comment",
            /// Move the cursor backward one character
            BackwardChar => "backward-char",
            /// Move the cursor forward one character
            ForwardChar => "forward-char",
            /// Search for a given character
            CharacterSearch => "character-search",
            /// Search backward for a given character
            CharacterSearchBackward => "character-search-backward",
            /// Move the cursor backward one word
            BackwardWord => "backward-word",
            /// Move the cursor forward one word
            ForwardWord => "forward-word",
            /// Kill all characters before the cursor
            BackwardKillLine => "backward-kill-line",
            /// Kill all characters after the cursor
            KillLine => "kill-line",
            /// Kill a word before the cursor
            BackwardKillWord => "backward-kill-word",
            /// Kill a word after the cursor
            KillWord => "kill-word",
            /// Kill a word before the cursor, delimited by whitespace
            UnixWordRubout => "unix-word-rubout",
            /// Clear the screen
            ClearScreen => "clear-screen",
            /// Move the cursor to the beginning of the line
            BeginningOfLine => "beginning-of-line",
            /// Move the cursor to the end of the line
            EndOfLine => "end-of-line",
            /// Delete one character before the cursor
            BackwardDeleteChar => "backward-delete-char",
            /// Delete one character after the cursor
            DeleteChar => "delete-char",
            /// Drag the character before the cursor forward
            TransposeChars => "transpose-chars",
            /// Drag the word before the cursor forward
            TransposeWords => "transpose-words",
            /// Move to the first line of history
            BeginningOfHistory => "beginning-of-history",
            /// Move to the last line of history
            EndOfHistory => "end-of-history",
            /// Select next line in history
            NextHistory => "next-history",
            /// Select previous line in history
            PreviousHistory => "previous-history",
            /// Incremental search in history
            ForwardSearchHistory => "forward-search-history",
            /// Incremental reverse search in history
            ReverseSearchHistory => "reverse-search-history",
            /// Non-incremental forward history search using input up to the cursor
            HistorySearchForward => "history-search-forward",
            /// Non-incremental backward history search using input up to the cursor
            HistorySearchBackward => "history-search-backward",
            /// Insert literal character
            QuotedInsert => "quoted-insert",
            /// Insert text into buffer from the kill ring
            Yank => "yank",
            /// Rotate the kill ring and yank the new top
            YankPop => "yank-pop",
        }
        /// Describes the category of a command
        ///
        /// A command's category determines how particular operations behave
        /// in succession.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Category {
            /// Completion command
            Complete,
            /// Kill command
            Kill,
            /// Non-incremental search command
            Search,
            /// Incremental search command
            IncrementalSearch,
            /// Yank command
            Yank,
            /// Digit argument command
            Digit,
            /// Other command
            Other,
        }

        impl Command {
            /// Returns the category of the command
            pub fn category(&self) -> Category {
                use self::Command::*;

                match *self {
                    DigitArgument => Category::Digit,
                    Complete | InsertCompletions | PossibleCompletions |
                        MenuComplete | MenuCompleteBackward => Category::Complete,
                    BackwardKillLine | KillLine | BackwardKillWord | KillWord |
                        UnixWordRubout => Category::Kill,
                    ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                    HistorySearchForward | HistorySearchBackward => Category::Search,
                    Yank | YankPop => Category::Yank,
                    _ => Category::Other
                }
            }
        }

        impl Default for Command {
            fn default() -> Self {
                Command::Custom(Borrowed(""))
            }
        }
    }

    pub mod complete
    {
        //! Provides utilities for implementing word completion
        use ::
        {
            *,
        };
        

        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::fs::read_dir;
        use std::path::{is_separator, MAIN_SEPARATOR};

        use crate::prompter::Prompter;
        use crate::terminal::Terminal;

        /// Represents a single possible completion
        #[derive(Clone, Debug)]
        pub struct Completion {
            /// Whole completion text
            pub completion: String,
            /// Listing display string; `None` if matches completion
            pub display: Option<String>,
            /// Completion suffix; replaces append character
            pub suffix: Suffix,
        }
        /// Specifies an optional suffix to override the default value
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Suffix {
            /// Use the default suffix
            Default,
            /// Use no suffix
            None,
            /// Use the given suffix
            Some(char),
        }

        impl Completion {
            /// Returns a simple `Completion` value, with display string matching
            /// completion and using the default completion suffix.
            pub fn simple(s: String) -> Completion {
                Completion{
                    completion: s,
                    display: None,
                    suffix: Suffix::default(),
                }
            }
            /// Returns the full completion string, including suffix, using the given
            /// default suffix if one is not assigned to this completion.
            pub fn completion(&self, def_suffix: Option<char>) -> Cow<str> {
                let mut s = Borrowed(&self.completion[..]);

                if let Some(suffix) = self.suffix.with_default(def_suffix) {
                    s.to_mut().push(suffix);
                }

                s
            }
            /// Returns the display string, including suffix
            pub fn display(&self) -> Cow<str> {
                let mut s = Borrowed(self.display_str());

                if let Suffix::Some(suffix) = self.suffix {
                    s.to_mut().push(suffix);
                }

                s
            }
            /// Returns the number of characters displayed
            pub fn display_chars(&self) -> usize {
                let n = self.display_str().chars().count();
                n + if self.suffix.is_some() { 1 } else { 0 }
            }

            fn display_str(&self) -> &str {
                match self.display {
                    Some(ref dis) => dis,
                    None => &self.completion
                }
            }
        }

        impl Suffix {
            /// Returns whether the `Suffix` value is the `Default` variant.
            pub fn is_default(&self) -> bool {
                match *self {
                    Suffix::Default => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `Some(_)` variant.
            pub fn is_some(&self) -> bool {
                match *self {
                    Suffix::Some(_) => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `None` variant.
            pub fn is_none(&self) -> bool {
                match *self {
                    Suffix::None => true,
                    _ => false
                }
            }
            /// Returns an `Option<char>`, using the given value in place of `Default`.
            pub fn with_default(self, default: Option<char>) -> Option<char> {
                match self {
                    Suffix::None => None,
                    Suffix::Some(ch) => Some(ch),
                    Suffix::Default => default
                }
            }
        }

        impl Default for Suffix {
            fn default() -> Suffix {
                Suffix::Default
            }
        }
        /// Performs completion for `Prompter` when triggered by a user input sequence
        pub trait Completer<Term: Terminal>: Send + Sync {
            /// Returns the set of possible completions for the prefix `word`.
            fn complete(&self, word: &str, prompter: &Prompter<Term>,
                start: usize, end: usize) -> Option<Vec<Completion>>;

            /// Returns the starting position of the word under the cursor.
            ///
            /// The default implementation uses `Prompter::word_break_chars()` to
            /// detect the start of a word.
            fn word_start(&self, line: &str, end: usize, prompter: &Prompter<Term>) -> usize {
                word_break_start(&line[..end], prompter.word_break_chars())
            }
            /// Quotes a possible completion for insertion into input.
            ///
            /// The default implementation returns the word, as is.
            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
            /// Unquotes a piece of user input before searching for completions.
            ///
            /// The default implementation returns the word, as is.
            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
        }
        /// `Completer` type that performs no completion
        ///
        /// This is the default `Completer` for a new `Prompter` instance.
        pub struct DummyCompleter;

        impl<Term: Terminal> Completer<Term> for DummyCompleter {
            fn complete(&self, _word: &str, _reader: &Prompter<Term>,
                    _start: usize, _end: usize) -> Option<Vec<Completion>> { None }
        }
        /// Performs completion by searching for filenames matching the word prefix.
        pub struct PathCompleter;

        impl<Term: Terminal> Completer<Term> for PathCompleter {
            fn complete(&self, word: &str, _reader: &Prompter<Term>, _start: usize, _end: usize)
                    -> Option<Vec<Completion>> {
                Some(complete_path(word))
            }

            fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
                escaped_word_start(&line[..end])
            }

            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                escape(word)
            }

            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                unescape(word)
            }
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path(path: &str) -> Vec<Completion> {
            let (base_dir, fname) = split_path(path);
            let mut res = Vec::new();

            let lookup_dir = base_dir.unwrap_or(".");

            if let Ok(list) = read_dir(lookup_dir) {
                for ent in list {
                    if let Ok(ent) = ent {
                        let ent_name = ent.file_name();

                        // TODO: Deal with non-UTF8 paths in some way
                        if let Ok(path) = ent_name.into_string() {
                            if path.starts_with(fname) {
                                let (name, display) = if let Some(dir) = base_dir {
                                    (format!("{}{}{}", dir, MAIN_SEPARATOR, path),
                                        Some(path))
                                } else {
                                    (path, None)
                                };

                                let is_dir = ent.metadata().ok()
                                    .map_or(false, |m| m.is_dir());

                                let suffix = if is_dir {
                                    Suffix::Some(MAIN_SEPARATOR)
                                } else {
                                    Suffix::Default
                                };

                                res.push(Completion{
                                    completion: name,
                                    display: display,
                                    suffix: suffix,
                                });
                            }
                        }
                    }
                }
            }

            res.sort_by(|a, b| a.display_str().cmp(b.display_str()));
            res
        }
        /// Returns the start position of the word that ends at the end of the string.
        pub fn word_break_start(s: &str, word_break: &str) -> usize {
            let mut start = s.len();

            for (idx, ch) in s.char_indices().rev() {
                if word_break.contains(ch) {
                    break;
                }
                start = idx;
            }

            start
        }
        /// Returns the start position of a word with non-word characters escaped by
        /// backslash (`\\`).
        pub fn escaped_word_start(s: &str) -> usize {
            let mut chars = s.char_indices().rev();
            let mut start = s.len();

            while let Some((idx, ch)) = chars.next() {
                if needs_escape(ch) {
                    let n = {
                        let mut n = 0;

                        loop {
                            let mut clone = chars.clone();

                            let ch = match clone.next() {
                                Some((_, ch)) => ch,
                                None => break
                            };

                            if ch == '\\' {
                                chars = clone;
                                n += 1;
                            } else {
                                break;
                            }
                        }

                        n
                    };

                    if n % 2 == 0 {
                        break;
                    }
                }

                start = idx;
            }

            start
        }
        /// Escapes a word by prefixing a backslash (`\\`) to non-word characters.
        pub fn escape(s: &str) -> Cow<str> {
            let n = s.chars().filter(|&ch| needs_escape(ch)).count();

            if n == 0 {
                Borrowed(s)
            } else {
                let mut res = String::with_capacity(s.len() + n);

                for ch in s.chars() {
                    if needs_escape(ch) {
                        res.push('\\');
                    }
                    res.push(ch);
                }

                Owned(res)
            }
        }
        /// Unescapes a word by removing the backslash (`\\`) from escaped characters.
        pub fn unescape(s: &str) -> Cow<str> {
            if s.contains('\\') {
                let mut res = String::with_capacity(s.len());
                let mut chars = s.chars();

                while let Some(ch) = chars.next() {
                    if ch == '\\' {
                        if let Some(ch) = chars.next() {
                            res.push(ch);
                        }
                    } else {
                        res.push(ch);
                    }
                }

                Owned(res)
            } else {
                Borrowed(s)
            }
        }

        fn needs_escape(ch: char) -> bool {
            match ch {
                ' ' | '\t' | '\n' | '\\' => true,
                _ => false
            }
        }

        fn split_path(path: &str) -> (Option<&str>, &str) {
            match path.rfind(is_separator) {
                Some(pos) => (Some(&path[..pos]), &path[pos + 1..]),
                None => (None, path)
            }
        }
    }

    pub mod function
    {
        //! Provides the `Function` trait for implementing custom `Prompter` commands
        use ::
        {
            *,
        };
        

        use std::io;

        use crate::command::Category;
        use crate::prompter::Prompter;
        use crate::terminal::Terminal;

        /// Implements custom functionality for a `Prompter` command
        pub trait Function<Term: Terminal>: Send + Sync {
            /// Executes the function.
            ///
            /// `count` is the numerical argument supplied by the user; `1` by default.
            /// `prompter.explicit_arg()` may be called to determine whether this value
            /// was explicitly supplied by the user.
            ///
            /// `ch` is the final character of the sequence that triggered the command.
            /// `prompter.sequence()` may be called to determine the full sequence that
            /// triggered the command.
            fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()>;

            /// Returns the command category.
            fn category(&self) -> Category { Category::Other }
        }

        impl<F, Term: Terminal> Function<Term> for F where
                F: Send + Sync,
                F: Fn(&mut Prompter<Term>, i32, char) -> io::Result<()> {
            fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()> {
                self(prompter, count, ch)
            }
        }
    }

    pub mod highlighting
    {
        //! Syntax highlighting functionality for the terminal interface
        use ::
        {
            *,
        };
        

        use std::ops::Range;

        /// Represents a style to be applied to a text range.
        #[derive(Debug, Clone, PartialEq, Eq)]
        pub enum Style {
            /// A style using raw ANSI color codes
            AnsiColor(String),
            /// The default terminal style
            Default,
        }
        /// A trait for providing style information for a line of text.
        pub trait Highlighter {
            /// Takes the current line buffer and returns a list of styled ranges.
            fn highlight(&self, line: &str) -> Vec<(Range<usize>, Style)>;
        }
        /// Style reset sequence
        pub const RESET_STYLE: &str = "\x1b[0m";
    }

    pub mod inputrc
    {
        //! Parses configuration files in the format of GNU Readline `inputrc`
        use ::
        {
            *,
        };

        

        use std::char::from_u32;
        use std::fs::File;
        use std::io::{stderr, Read, Write};
        use std::path::Path;
        use std::str::{Chars, Lines};

        use crate::chars::{ctrl, meta, parse_char_name};
        use crate::command::Command;

        /// Parsed configuration directive
        #[derive(Clone, Debug)]
        pub enum Directive {
            /// Bind construct; `"input-sequence": command-or-macro`
            Bind(String, Command),
            /// Conditional construct;
            /// (`$if name=value` or `$if value`) *directives*
            /// (optional `$else` *directives*) `$endif`
            Conditional{
                /// Value name; if `None`, value refers to application name
                name: Option<String>,
                /// Value to compare
                value: String,
                /// Group of directives evaluated when condition is true
                then_group: Vec<Directive>,
                /// Group of directives evaluated when condition is false
                else_group: Vec<Directive>,
            },
            /// Set variable; `set name value`
            SetVariable(String, String),
        }
        /// Parses the named file and returns contained directives.
        ///
        /// If the file cannot be opened, `None` is returned and an error is printed
        /// to `stderr`. If any errors are encountered during parsing, they are printed
        /// to `stderr`.
        pub fn parse_file<P: ?Sized>(filename: &P) -> Option<Vec<Directive>> where P: AsRef<Path> {
            let filename = filename.as_ref();

            let mut f = match File::open(filename) {
                Ok(f) => f,
                Err(e) => {
                    let _ = writeln!(stderr(), "lineread: {}: {}", filename.display(), e);
                    return None;
                }
            };

            let mut buf = String::new();

            if let Err(e) = f.read_to_string(&mut buf) {
                let _ = writeln!(stderr(), "{}: {}", filename.display(), e);
                return None;
            }

            Some(parse_text(filename, &buf))
        }
        /// Parses some text and returns contained directives.
        ///
        /// If any errors are encountered during parsing, they are printed to `stderr`.
        pub fn parse_text<P: ?Sized>(name: &P, line: &str) -> Vec<Directive> where P: AsRef<Path> {
            let mut p = Parser::new(name.as_ref(), line);
            p.parse()
        }

        struct Parser<'a> {
            lines: Lines<'a>,
            filename: &'a Path,
            line_num: usize,
        }

        enum Token<'a> {
            /// Colon; `:`
            Colon,
            /// Equal; `=`
            Equal,
            /// Conditional or other special directive; `$word`
            SpecialWord(&'a str),
            /// Double-quoted string; `"foo"`
            String(String),
            /// Bare word; `foo`
            Word(&'a str),
            /// Invalid token
            Invalid,
        }

        impl<'a> Parser<'a> {
            pub fn new(filename: &'a Path, text: &'a str) -> Parser<'a> {
                Parser{
                    lines: text.lines(),
                    filename: filename,
                    line_num: 0,
                }
            }

            fn next_line(&mut self) -> Option<&'a str> {
                self.lines.next().map(|line| {
                    self.line_num += 1;
                    line.trim()
                })
            }

            fn parse(&mut self) -> Vec<Directive> {
                let mut dirs = Vec::new();

                while let Some(line) = self.next_line() {
                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    if let Some(Token::SpecialWord("include")) = tokens.next() {
                        let path = tokens.line;

                        if let Some(d) = parse_file(Path::new(path)) {
                            dirs.extend(d);
                        }

                        continue;
                    }

                    if let Some(dir) = self.parse_line(line) {
                        dirs.push(dir);
                    }
                }

                dirs
            }

            fn parse_conditional(&mut self) -> (Vec<Directive>, Vec<Directive>) {
                let mut then_group = Vec::new();
                let mut else_group = Vec::new();
                let mut parse_else = false;

                loop {
                    let line = match self.next_line() {
                        Some(line) => line,
                        None => {
                            self.error("missing $endif directive");
                            break;
                        }
                    };

                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    let start = match tokens.next() {
                        Some(tok) => tok,
                        None => continue
                    };

                    match start {
                        Token::SpecialWord("else") => {
                            if parse_else {
                                self.error("duplicate $else directive");
                            } else {
                                parse_else = true;
                            }
                        }
                        Token::SpecialWord("endif") => {
                            break;
                        }
                        _ => {
                            if let Some(dir) = self.parse_line(line) {
                                if parse_else {
                                    else_group.push(dir);
                                } else {
                                    then_group.push(dir);
                                }
                            }
                        }
                    }
                }

                (then_group, else_group)
            }

            fn parse_line(&mut self, line: &str) -> Option<Directive> {
                let mut tokens = Tokens::new(line);

                let start = tokens.next()?;

                let dir = match start {
                    Token::SpecialWord("if") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (name, value) = match tokens.next() {
                            Some(Token::Equal) => {
                                let value = match tokens.next() {
                                    Some(Token::Word(w)) => w,
                                    None => "",
                                    _ => {
                                        self.invalid();
                                        return None;
                                    }
                                };

                                (Some(name), value)
                            }
                            None => (None, name),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (then_group, else_group) = self.parse_conditional();

                        Directive::Conditional{
                            name: name.map(|s| s.to_owned()),
                            value: value.to_owned(),
                            then_group: then_group,
                            else_group: else_group,
                        }
                    }
                    Token::SpecialWord("else") => {
                        self.error("$else without matching $if directive");
                        return None;
                    }
                    Token::SpecialWord("endif") => {
                        self.error("$endif without matching $if directive");
                        return None;
                    }
                    Token::String(seq) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(out)) =>
                                Directive::Bind(seq, Command::Macro(out.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    Token::Word("set") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let rest = tokens.line;

                        let value = match tokens.next() {
                            Some(Token::String(s)) => s,
                            Some(Token::Word(_)) => rest.to_owned(),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        Directive::SetVariable(name.to_owned(), value)
                    }
                    Token::Word(name) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        let seq = match parse_char_name(name) {
                            Some(seq) => seq,
                            None => {
                                self.invalid();
                                return None;
                            }
                        };

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(macro_seq)) =>
                                Directive::Bind(seq, Command::Macro(macro_seq.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    _ => {
                        self.invalid();
                        return None;
                    }
                };

                Some(dir)
            }

            fn error(&self, msg: &str) {
                let _ = writeln!(stderr(),
                    "lineread: {} line {}: {}", self.filename.display(), self.line_num, msg);
            }

            fn invalid(&self) {
                self.error("invalid directive");
            }
        }

        struct Tokens<'a> {
            line: &'a str,
        }

        impl<'a> Tokens<'a> {
            fn new(line: &str) -> Tokens {
                Tokens{
                    line: line,
                }
            }
        }

        impl<'a> Iterator for Tokens<'a> {
            type Item = Token<'a>;

            fn next(&mut self) -> Option<Token<'a>> {
                let ch = self.line.chars().next()?;

                let tok = match ch {
                    ':' => {
                        self.line = self.line[1..].trim_start();
                        Token::Colon
                    }
                    '=' => {
                        self.line = self.line[1..].trim_start();
                        Token::Equal
                    }
                    '$' => {
                        let (word, rest) = parse_word(&self.line[1..]);
                        self.line = rest.trim_start();
                        Token::SpecialWord(word)
                    }
                    '"' => {
                        let (tok, rest) = parse_string(self.line);
                        self.line = rest.trim_start();
                        tok
                    }
                    _ => {
                        let (word, rest) = parse_word(self.line);
                        self.line = rest.trim_start();
                        Token::Word(word)
                    }
                };

                Some(tok)
            }
        }

        fn parse_escape(chars: &mut Chars) -> Option<String> {
            let ch = chars.next()?;

            let esc = match ch {
                'C'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    ctrl(chars.next()?)
                }
                'M'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    return Some(meta(chars.next()?));
                }
                'e'  => '\x1b',
                '\\' => '\\',
                '"'  => '"',
                '\'' => '\'',
                'a'  => '\x07',
                'b'  => '\x08',
                'd'  => '\x7f',
                'f'  => '\x0c',
                'n'  => '\n',
                'r'  => '\r',
                't'  => '\t',
                'u'  => {
                    match chars.next() {
                        Some('{') => (),
                        _ => return None
                    }

                    let mut n = 0;

                    for _ in 0..6 {
                        match chars.clone().next().and_then(|ch| ch.to_digit(16)) {
                            Some(digit) => {
                                chars.next();
                                n *= 16;
                                n += digit;
                            }
                            None => break
                        }
                    }

                    match chars.next() {
                        Some('}') => (),
                        _ => return None
                    }

                    from_u32(n)?
                }
                'v'  => '\x0b',
                'x'  => {
                    let mut n = 0;

                    for _ in 0..2 {
                        // Peek the next character
                        let digit = chars.clone().next()?.to_digit(16)? as u8;

                        // Consume if valid
                        chars.next();

                        n <<= 4;
                        n |= digit;
                    }

                    n as char
                }
                '0' ..= '3' => {
                    let mut n = ch as u8 - b'0';

                    for _ in 0..2 {
                        // Peek the next character
                        let digit = chars.clone().next()?.to_digit(8)? as u8;

                        // Consume if valid
                        chars.next();

                        n <<= 3;
                        n |= digit;
                    }

                    n as char
                }
                _ => return None
            };

            Some(esc.to_string())
        }

        fn parse_string(s: &str) -> (Token, &str) {
            let mut chars = s.chars();
            let mut res = String::new();

            // Skip open quote
            chars.next();

            while let Some(ch) = chars.next() {
                match ch {
                    '"' => return (Token::String(res), chars.as_str()),
                    '\\' => {
                        match parse_escape(&mut chars) {
                            Some(esc) => {
                                res.push_str(&esc);
                            }
                            None => break
                        }
                    }
                    ch => res.push(ch)
                }
            }

            (Token::Invalid, "")
        }

        fn parse_word(s: &str) -> (&str, &str) {
            let mut chars = s.char_indices();

            loop {
                let mut clone = chars.clone();

                match clone.next() {
                    Some((ind, ch)) if ch == ':' || ch == '"' || ch == '=' ||
                            ch.is_whitespace() => {
                        return (&s[..ind], &s[ind..]);
                    }
                    None => {
                        return (s, "");
                    }
                    _ => ()
                }

                chars = clone;
            }
        }
    }

    pub mod interface
    {
        //! Provides the main interface to interactive input reader
        use ::
        {
            *,
        };
        

        use std::borrow::Cow;
        use std::fmt;
        use std::fs::{File, OpenOptions};
        use std::io::{
            self, BufRead, BufReader, BufWriter,
            Read as _, Seek, SeekFrom, Write as _,
        };
        use std::path::Path;
        use std::sync::{Arc, Mutex, MutexGuard};
        use std::time::Duration;

        use crate::command::Command;
        use crate::complete::Completer;
        use crate::function::Function;
        use crate::highlighting::Highlighter;
        use crate::inputrc::Directive;
        use crate::reader::{Read, Reader, ReadLock, ReadResult};
        use crate::terminal::{DefaultTerminal, Signal, Terminal};
        use crate::variables::Variable;
        use crate::writer::{Write, Writer, WriteLock};

        /// The main interface to input reading and other terminal operations
        ///
        /// # Concurrency
        ///
        /// Each `Interface` contains two internal locks to allow concurrent read and write
        /// operations. The following types are used to hold a lock and to provide
        /// access to a set of operations:
        ///
        /// * [`Reader`] holds the read lock; it provides access to variables and bindings
        ///   and can initiate a [`read_line`] call. When `read_line` begins, the read
        ///   lock is acquired and it is held until the function returns. During the
        ///   `read_line` loop, the `Reader` waits for user input, reads input from the
        ///   terminal device, then acquires the write lock to process input and run
        ///   commands which may alter the prompt and the input buffer.
        /// * [`Writer`] holds the write lock; it provides an interface to write
        ///   line-by-line output to the terminal device without interfering with the
        ///   prompt when a `read_line` may be in progress.
        /// * [`Prompter`] holds both the read and write locks; it is created by the
        ///   `Reader` during the `read_line` loop and destroyed when the write lock is
        ///   released. It provides access to the current state of user input.
        ///
        /// [`Reader`]: ../reader/struct.Reader.html
        /// [`Writer`]: ../writer/struct.Writer.html
        /// [`Prompter`]: ../prompter/struct.Prompter.html
        /// [`read_line`]: #method.read_line
        pub struct Interface<Term: Terminal> {
            term: Term,
            write: Mutex<Write>,
            read: Mutex<Read<Term>>,
            highlighter: Option<Arc<dyn Highlighter + Send + Sync>>,
        }

        impl Interface<DefaultTerminal> {
            /// Creates a new `Interface` with the given application name.
            ///
            /// `application` is a string containing the name of the application.
            /// This can be used in user configurations to specify behavior for
            /// particular applications.
            ///
            /// The default terminal interface is used.
            pub fn new<T>(application: T) -> io::Result<Interface<DefaultTerminal>>
                    where T: Into<Cow<'static, str>> {
                let term = DefaultTerminal::new()?;
                Interface::with_term(application, term)
            }
        }

        impl<Term: Terminal> Interface<Term> {
            /// Creates a new `Interface` instance with a particular terminal implementation.
            ///
            /// To use the default terminal interface, call `Interface::new` instead.
            pub fn with_term<T>(application: T, term: Term) -> io::Result<Interface<Term>>
                    where T: Into<Cow<'static, str>> {
                let size = term.lock_write().size()?;
                let read = Read::new(&term, application.into());

                Ok(Interface{
                    term: term,
                    write: Mutex::new(Write::new(size)),
                    read: Mutex::new(read),
                    highlighter: None,
                })
            }
            /// Acquires the read lock and returns a `Reader` instance.
            ///
            /// The `Reader` instance allows exclusive access to variables, bindings,
            /// and command implementations.
            pub fn lock_reader(&self) -> Reader<Term> {
                Reader::new(self, self.lock_read())
            }
            /// Acquires the write lock and returns a `Writer` instance.
            ///
            /// If a `read_line` call is in progress, this method will move the cursor
            /// to a new line after the prompt, allowing output to be written without
            /// corrupting the prompt text. The prompt will be redrawn when the `Writer`
            /// instance is dropped.
            ///
            /// To instead erase the prompt and write text, use [`lock_writer_erase`].
            ///
            /// [`lock_writer_erase`]: #method.lock_writer_erase
            pub fn lock_writer_append(&self) -> io::Result<Writer<Term>> {
                Writer::with_lock(self.lock_write(), false)
            }
            /// Acquires the write lock and returns a `Writer` instance.
            ///
            /// If a `read_line` call is in progress, this method will erase the prompt,
            /// allowing output to be written without corrupting the prompt text.
            /// The prompt will be redrawn when the `Writer` instance is dropped.
            ///
            /// To instead write text after the prompt, use [`lock_writer_append`].
            ///
            /// [`lock_writer_append`]: #method.lock_writer_append
            pub fn lock_writer_erase(&self) -> io::Result<Writer<Term>> {
                Writer::with_lock(self.lock_write(), true)
            }

            fn lock_read(&self) -> ReadLock<Term> {
                ReadLock::new(
                    self.term.lock_read(),
                    self.read.lock().expect("Interface::lock_read"))
            }

            pub fn lock_write(&self) -> WriteLock<Term> {
                WriteLock::new(
                    self.term.lock_write(),
                    self.write.lock().expect("Interface::lock_write"),
                    self.highlighter.clone(),
                )
            }

            pub fn lock_write_data(&self) -> MutexGuard<Write> {
                self.write.lock().expect("Interface::lock_write_data")
            }
        }
        /// ## Locking
        ///
        /// The following methods internally acquire the read lock.
        ///
        /// The lock is released before the method returns.
        ///
        /// If the read lock is already held, e.g. because a `read_line` call is in
        /// progress, the method will block until the lock is released.
        impl<Term: Terminal> Interface<Term> {
            /// Interactively reads a line from the terminal device.
            ///
            /// User input is collected until one of the following conditions is met:
            ///
            /// * If the user issues an end-of-file, `ReadResult::Eof` is returned.
            /// * When the user inputs a newline (`'\n'`), the resulting input
            ///   (not containing a trailing newline character) is returned as
            ///   `ReadResult::Input(_)`.
            /// * When a reported signal (see [`set_report_signal`]) is received,
            ///   it is returned as `ReadResult::Signal(_)`. The `read_line` operation may
            ///   then be either resumed with another call to `read_line` or ended by
            ///   calling [`cancel_read_line`].
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`set_report_signal`]: #method.set_report_signal
            pub fn read_line(&self) -> io::Result<ReadResult> {
                self.lock_reader().read_line()
            }
            /// Performs one step of the interactive `read_line` loop.
            ///
            /// This method can be used to drive the `read_line` process asynchronously.
            /// It will wait for input only up to the specified duration, then process
            /// any available input from the terminal.
            ///
            /// If the user completes the input process, `Ok(Some(result))` is returned.
            /// Otherwise, `Ok(None)` is returned to indicate that the interactive loop
            /// may continue.
            ///
            /// The interactive prompt may be cancelled prematurely using the
            /// [`cancel_read_line`] method.
            ///
            /// See [`read_line`] for details on the return value.
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`read_line`]: #method.read_line
            pub fn read_line_step(&self, timeout: Option<Duration>)
                    -> io::Result<Option<ReadResult>> {
                self.lock_reader().read_line_step(timeout)
            }
            /// Cancels an in-progress `read_line` operation.
            ///
            /// This method will reset internal data structures to their original state
            /// and move the terminal cursor to a new, empty line.
            ///
            /// This method is called to prematurely end the interactive loop when
            /// using the [`read_line_step`] method.
            ///
            /// It is not necessary to call this method if using the [`read_line`] method.
            ///
            /// [`read_line`]: #method.read_line
            /// [`read_line_step`]: #method.read_line_step
            pub fn cancel_read_line(&self) -> io::Result<()> {
                self.lock_reader().cancel_read_line()
            }
            /// Returns a clone of the current completer instance.
            pub fn completer(&self) -> Arc<dyn Completer<Term>> {
                self.lock_reader().completer().clone()
            }
            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer(&self, completer: Arc<dyn Completer<Term>>)
                    -> Arc<dyn Completer<Term>> {
                self.lock_reader().set_completer(completer)
            }
            /// Returns the value of the named variable or `None`
            /// if no such variable exists.
            pub fn get_variable(&self, name: &str) -> Option<Variable> {
                self.lock_reader().get_variable(name)
            }
            /// Sets the value of the named variable and returns the previous
            /// value.
            ///
            /// If `name` does not refer to a variable or the `value` is not
            /// a valid value for the variable, `None` is returned.
            pub fn set_variable(&self, name: &str, value: &str) -> Option<Variable> {
                self.lock_reader().set_variable(name, value)
            }
            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal(&self, signal: Signal) -> bool {
                self.lock_reader().ignore_signal(signal)
            }
            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal(&self, signal: Signal, set: bool) {
                self.lock_reader().set_ignore_signal(signal, set)
            }
            /// Returns whether the given `Signal` is reported.
            pub fn report_signal(&self, signal: Signal) -> bool {
                self.lock_reader().report_signal(signal)
            }
            /// Sets whether the given `Signal` is reported.
            pub fn set_report_signal(&self, signal: Signal, set: bool) {
                self.lock_reader().set_report_signal(signal, set)
            }
            /// Binds a sequence to a command.
            ///
            /// Returns the previously bound command.
            pub fn bind_sequence<T>(&self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.lock_reader().bind_sequence(seq, cmd)
            }
            /// Binds a sequence to a command, if and only if the given sequence
            /// is not already bound to a command.
            ///
            /// Returns `true` if a new binding was created.
            pub fn bind_sequence_if_unbound<T>(&self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                self.lock_reader().bind_sequence_if_unbound(seq, cmd)
            }
            /// Removes a binding for the given sequence.
            ///
            /// Returns the previously bound command.
            pub fn unbind_sequence(&self, seq: &str) -> Option<Command> {
                self.lock_reader().unbind_sequence(seq)
            }
            /// Defines a named function to which sequences may be bound.
            ///
            /// The name should consist of lowercase ASCII letters and numbers,
            /// containing no spaces, with words separated by hyphens. However,
            /// this is not a requirement.
            ///
            /// Returns the function previously defined with the same name.
            pub fn define_function<T>(&self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.lock_reader().define_function(name, cmd)
            }
            /// Removes a function defined with the given name.
            ///
            /// Returns the defined function.
            pub fn remove_function(&self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.lock_reader().remove_function(name)
            }
            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives(&self, dirs: Vec<Directive>) {
                self.lock_reader().evaluate_directives(&self.term, dirs)
            }
            /// Evaluates a single configuration directive.
            pub fn evaluate_directive(&self, dir: Directive) {
                self.lock_reader().evaluate_directive(&self.term, dir)
            }
        }
        /// ## Locking
        ///
        /// The following methods internally acquire the write lock.
        ///
        /// The lock is released before the method returns.
        ///
        /// If the write lock is already held, the method will block until it is released.
        impl<Term: Terminal> Interface<Term> {
            /// Returns the current input buffer.
            pub fn buffer(&self) -> String {
                self.lock_write().buffer.to_owned()
            }
            /// Returns the current number of history entries.
            pub fn history_len(&self) -> usize {
                self.lock_write().history_len()
            }
            /// Returns the maximum number of history entries.
            ///
            /// Not to be confused with [`history_len`], which returns the *current*
            /// number of history entries.
            ///
            /// [`history_len`]: #method.history_len
            pub fn history_size(&self) -> usize {
                self.lock_write().history_size()
            }
            /// Save history entries to the specified file.
            ///
            /// If the file does not exist, it is created and all history entries are
            /// written to the new file.
            ///
            /// If the file does exist, entries added since the last call to `save_history`
            /// (or since the start of the application) are appended to the named file.
            ///
            /// If the file would contain more than `self.history_size()` entries,
            /// it is first truncated, discarding the oldest entries.
            pub fn save_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
                let path = path.as_ref();
                let mut w = self.lock_write();

                if !path.exists() || w.history_size() == !0 {
                    self.append_history(path, &w)?;
                } else {
                    self.rewrite_history(path, &w)?;
                }

                w.reset_new_history();
                Ok(())
            }

            fn append_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>)
                    -> io::Result<()> {
                let file = OpenOptions::new()
                    .append(true)
                    .create(true)
                    .open(path.as_ref())?;

                self.append_history_to(&file, w)
            }

            fn append_history_to(&self, file: &File, w: &WriteLock<Term>) -> io::Result<()> {
                let mut wtr = BufWriter::new(file);

                for entry in w.new_history() {
                    wtr.write_all(entry.as_bytes())?;
                    wtr.write_all(b"\n")?;
                }

                wtr.flush()
            }

            fn rewrite_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>)
                    -> io::Result<()> {
                fn nth_line(s: &str, n: usize) -> Option<usize> {
                    let start = s.as_ptr() as usize;

                    s.lines().nth(n)
                        .map(|s| s.as_ptr() as usize - start)
                }

                let mut file = OpenOptions::new()
                    .create(true)
                    .read(true)
                    .write(true)
                    .open(path.as_ref())?;

                let mut hist = String::new();

                file.read_to_string(&mut hist)?;

                let n_lines = hist.lines().count();
                let n = n_lines.saturating_sub(
                    w.history_size() - w.new_history_entries());

                if n != 0 {
                    if let Some(pos) = nth_line(&hist, n) {
                        file.seek(SeekFrom::Start(0))?;
                        file.write_all(hist[pos..].as_bytes())?;

                        let n = file.seek(SeekFrom::Current(0))?;
                        file.set_len(n)?;
                    }
                }

                self.append_history_to(&file, w)
            }
            /// Load history entries from the specified file.
            pub fn load_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
                let mut writer = self.lock_write();

                let file = File::open(&path)?;
                let rdr = BufReader::new(file);

                for line in rdr.lines() {
                    writer.add_history(line?);
                }

                writer.reset_new_history();

                Ok(())
            }
            /// Writes formatted text to the terminal display.
            ///
            /// This method enables `Interface` to be used as the receiver to
            /// the [`writeln!`] macro.
            ///
            /// If the text contains any unprintable characters (e.g. escape sequences),
            /// those characters will be escaped before printing.
            ///
            /// # Notes
            ///
            /// If this method is called during a [`read_line`] call, the prompt will
            /// first be erased, then restored after the given string is printed.
            /// Therefore, the written text should end with a newline. If the `writeln!`
            /// macro is used, a newline is automatically added to the end of the text.
            ///
            /// To instead write text after the prompt, use [`lock_writer_append`].
            ///
            /// [`read_line`]: #method.read_line
            /// [`writeln!`]: https://doc.rust-lang.org/std/macro.writeln.html
            /// [`lock_writer_append`]: #method.lock_writer_append
            pub fn write_fmt(&self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }

            fn write_str(&self, line: &str) -> io::Result<()> {
                self.lock_writer_erase()?.write_str(line)
            }
        }
        /// ## Locking
        ///
        /// The following methods internally acquire both the read and write locks.
        ///
        /// The locks are released before the method returns.
        ///
        /// If either lock is already held, the method will block until it is released.
        impl<Term: Terminal> Interface<Term> {
            /// Sets the prompt that will be displayed when `read_line` is called.
            ///
            /// # Notes
            ///
            /// If `prompt` contains any terminal escape sequences (e.g. color codes),
            /// such escape sequences should be immediately preceded by the character
            /// `'\x01'` and immediately followed by the character `'\x02'`.
            pub fn set_prompt(&self, prompt: &str) -> io::Result<()> {
                self.lock_reader().set_prompt(prompt)
            }
            /// Sets the input buffer to the given string.
            ///
            /// # Notes
            ///
            /// To prevent invalidating the cursor, this method sets the cursor
            /// position to the end of the new buffer.
            pub fn set_buffer(&self, buf: &str) -> io::Result<()> {
                self.lock_reader().set_buffer(buf)
            }
            /// Sets the cursor position in the input buffer.
            ///
            /// # Panics
            ///
            /// If the given position is out of bounds or not on a `char` boundary.
            pub fn set_cursor(&self, pos: usize) -> io::Result<()> {
                self.lock_reader().set_cursor(pos)
            }

            // History methods don't appear to require a read lock, but do acquire
            // it nonetheless because any operation that truncates history may interefere
            // with an ongoing `read_line` call. Therefore, the read lock is acquired
            // to check whether a `read_line` call is in progress.

            /// Adds a line to history.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn add_history(&self, line: String) {
                self.lock_reader().add_history(line);
            }
            /// Adds a line to history, unless it is identical to the most recent entry.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn add_history_unique(&self, line: String) {
                self.lock_reader().add_history_unique(line);
            }
            /// Removes all history entries.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn clear_history(&self) {
                self.lock_reader().clear_history();
            }
            /// Removes the history entry at the given index.
            ///
            /// If the index is out of bounds, this method has no effect.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn remove_history(&self, idx: usize) {
                self.lock_reader().remove_history(idx);
            }
            /// Sets the maximum number of history entries.
            ///
            /// If `n` is less than the current number of history entries,
            /// the oldest entries are truncated to meet the given requirement.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn set_history_size(&self, n: usize) {
                self.lock_reader().set_history_size(n);
            }
            /// Truncates history to the only the most recent `n` entries.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn truncate_history(&self, n: usize) {
                self.lock_reader().truncate_history(n);
            }
            /// Sets the syntax highlighter for the input line.
            pub fn set_highlighter(&mut self, highlighter: Arc<dyn Highlighter + Send + Sync>) {
                self.highlighter = Some(highlighter);
            }
        }
    }

    pub mod memory
    {
        //! Implements an in-memory `Terminal` interface.
        use ::
        {
            *,
        };
        

        use std::cmp::min;
        use std::iter::repeat;
        use std::io;
        use std::sync::{Arc, Mutex, MutexGuard};
        use std::time::Duration;

        use crate::terminal::{
            CursorMode, RawRead, SignalSet, Size,
            Terminal, TerminalReader, TerminalWriter,
        };

        /// Default size of a `MemoryTerminal` buffer
        pub const DEFAULT_SIZE: Size = Size{
            columns: 80,
            lines: 24,
        };

        /// Implements an in-memory `Terminal` interface
        ///
        /// The contents of a `MemoryTerminal` are shared. That is, cloning
        /// a `MemoryTerminal` value will share the contained terminal buffer.
        #[derive(Clone, Debug)]
        pub struct MemoryTerminal {
            write: Arc<Mutex<Writer>>,
            read: Arc<Mutex<Reader>>,
        }

        #[derive(Debug)]
        struct Writer {
            memory: Vec<char>,
            col: usize,
            line: usize,
            cursor_mode: CursorMode,
            size: Size,
        }

        #[derive(Debug)]
        struct Reader {
            input: Vec<u8>,
            resize: Option<Size>,
        }
        /// Holds the lock on read operations of a `MemoryTerminal`.
        pub struct MemoryReadGuard<'a>(MutexGuard<'a, Reader>);

        /// Holds the lock on write operations of a `MemoryTerminal`.
        pub struct MemoryWriteGuard<'a>(MutexGuard<'a, Writer>);

        impl MemoryTerminal {
            /// Returns a new `MemoryTerminal` with the default buffer size.
            pub fn new() -> MemoryTerminal {
                MemoryTerminal::default()
            }
            /// Returns a new `MemoryTerminal` with the given buffer size.
            ///
            /// # Panics
            ///
            /// If either of the `lines` or `columns` fields are `0`.
            pub fn with_size(size: Size) -> MemoryTerminal {
                MemoryTerminal{
                    read: Arc::new(Mutex::new(Reader::new())),
                    write: Arc::new(Mutex::new(Writer::new(size))),
                }
            }
            /// Clears the terminal buffer and places the cursor at `(0, 0)`.
            pub fn clear_all(&self) {
                self.lock_writer().clear_all();
            }
            /// Clears all characters beginning at the cursor and ending at buffer end.
            pub fn clear_to_end(&self) {
                self.lock_writer().clear_to_end();
            }
            /// Clears the input buffer.
            pub fn clear_input(&self) {
                self.lock_reader().clear_input();
            }
            /// Returns whether any input remains to be read.
            pub fn has_input(&self) -> bool {
                self.lock_reader().has_input()
            }
            /// Returns an iterator over lines in the buffer.
            ///
            /// # Notes
            ///
            /// The returned iterator immutably borrows the contents of the
            /// `MemoryTerminal`. Attempting to perform a mutating operation on the
            /// parent `MemoryTerminal` while the `Lines` iterator lives will cause
            /// a panic.
            pub fn lines(&self) -> Lines {
                Lines{
                    writer: self.lock_writer(),
                    line: 0,
                }
            }
            /// Moves the cursor up `n` cells.
            pub fn move_up(&self, n: usize) {
                self.lock_writer().move_up(n);
            }
            /// Moves the cursor down `n` cells.
            pub fn move_down(&self, n: usize) {
                self.lock_writer().move_down(n);
            }
            /// Moves the cursor left `n` cells.
            pub fn move_left(&self, n: usize) {
                self.lock_writer().move_left(n);
            }
            /// Moves the cursor right `n` cells.
            pub fn move_right(&self, n: usize) {
                self.lock_writer().move_right(n);
            }
            /// Moves the cursor to the first column of the current line.
            pub fn move_to_first_column(&self) {
                self.lock_writer().move_to_first_column()
            }
            /// Pushes a character sequence to the back of the input queue.
            pub fn push_input(&self, s: &str) {
                self.lock_reader().push_input(s.as_bytes());
            }
            /// Reads some input from the input buffer.
            pub fn read_input(&self, buf: &mut [u8]) -> usize {
                self.lock_reader().read_input(buf)
            }
            /// Changes the size of the terminal buffer.
            /// The buffer will be truncated or filled with spaces, as necessary.
            ///
            /// # Panics
            ///
            /// If either of the `lines` or `columns` fields are `0` or if the area
            /// exceeds `usize` maximum.
            pub fn resize(&self, new_size: Size) {
                self.lock_writer().resize(new_size);
                self.lock_reader().resize(new_size);
            }
            /// Moves the contents of the buffer up `n` lines.
            /// The first `n` lines of text will be erased.
            pub fn scroll_up(&self, n: usize) {
                self.lock_writer().scroll_up(n);
            }
            /// Returns the `(line, column)` position of the cursor.
            pub fn cursor(&self) -> (usize, usize) {
                let r = self.lock_writer();
                (r.line, r.col)
            }
            /// Sets the cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) {
                self.lock_writer().set_cursor_mode(mode);
            }
            /// Returns the cursor mode.
            pub fn cursor_mode(&self) -> CursorMode {
                self.lock_writer().cursor_mode()
            }
            /// Returns the size of the terminal buffer.
            pub fn size(&self) -> Size {
                self.lock_writer().size
            }
            /// Writes some text into the buffer.
            ///
            /// If the text extends beyond the length of the current line without a
            /// newline character (`'\n'`), the extraneous text will be dropped.
            pub fn write(&self, s: &str) {
                self.lock_writer().write(s);
            }

            fn lock_reader(&self) -> MutexGuard<Reader> {
                self.read.lock().unwrap()
            }

            fn lock_writer(&self) -> MutexGuard<Writer> {
                self.write.lock().unwrap()
            }
        }

        impl Default for MemoryTerminal {
            fn default() -> MemoryTerminal {
                MemoryTerminal::with_size(DEFAULT_SIZE)
            }
        }

        impl Reader {
            fn new() -> Reader {
                Reader{
                    input: Vec::new(),
                    resize: None,
                }
            }

            fn has_input(&mut self) -> bool {
                self.resize.is_some() || !self.input.is_empty()
            }

            fn clear_input(&mut self) {
                self.input.clear();
            }

            fn push_input(&mut self, bytes: &[u8]) {
                self.input.extend(bytes);
            }

            fn read_input(&mut self, buf: &mut [u8]) -> usize {
                let n = min(buf.len(), self.input.len());

                buf[..n].copy_from_slice(&self.input[..n]);
                let _ = self.input.drain(..n);
                n
            }

            fn resize(&mut self, size: Size) {
                self.resize = Some(size);
            }
        }

        impl Writer {
            fn new(size: Size) -> Writer {
                assert!(size.lines != 0 && size.columns != 0,
                    "zero-area terminal buffer: {:?}", size);

                let n_chars = size.lines * size.columns;

                Writer{
                    memory: vec![' '; n_chars],
                    col: 0,
                    line: 0,
                    cursor_mode: CursorMode::Normal,
                    size: size,
                }
            }

            fn clear_all(&mut self) {
                for ch in &mut self.memory {
                    *ch = ' ';
                }
                self.col = 0;
                self.line = 0;
            }

            fn clear_to_end(&mut self) {
                let idx = self.index();

                for ch in &mut self.memory[idx..] {
                    *ch = ' ';
                }
            }

            fn move_up(&mut self, n: usize) {
                self.line = self.line.saturating_sub(n);
            }

            fn move_down(&mut self, n: usize) {
                self.line = min(self.size.lines - 1, self.line + n);
            }

            fn move_left(&mut self, n: usize) {
                self.col = self.col.saturating_sub(n);
            }

            fn move_right(&mut self, n: usize) {
                self.col = min(self.size.columns - 1, self.col + n);
            }

            fn move_to_first_column(&mut self) {
                self.col = 0;
            }

            fn resize(&mut self, new_size: Size) {
                if self.size != new_size {
                    let n_chars = new_size.lines.checked_mul(new_size.columns)
                        .unwrap_or_else(|| panic!("terminal size too large: {:?}", new_size));

                    assert!(n_chars != 0, "zero-area terminal buffer: {:?}", new_size);

                    let mut new_buf = Vec::with_capacity(n_chars);

                    let (n_copy, n_extra) = if new_size.columns > self.size.columns {
                        (self.size.columns, new_size.columns - self.size.columns)
                    } else {
                        (new_size.columns, 0)
                    };

                    for line in self.memory.chunks(self.size.columns).take(new_size.lines) {
                        new_buf.extend(&line[..n_copy]);
                        new_buf.extend(repeat(' ').take(n_extra));
                    }

                    if new_size.lines > self.size.lines {
                        let n_lines = new_size.lines - self.size.lines;
                        new_buf.extend(repeat(' ').take(n_lines * new_size.columns));
                    }

                    debug_assert_eq!(new_buf.len(), n_chars);

                    self.col = min(self.col, new_size.columns);
                    self.line = min(self.line, new_size.lines);
                    self.size = new_size;
                    self.memory = new_buf;
                }
            }

            fn scroll_up(&mut self, n: usize) {
                let chars = min(self.memory.len(), self.size.columns * n);
                self.memory.drain(..chars);
                self.memory.extend(repeat(' ').take(chars));
                self.line = self.line.saturating_sub(n);
            }

            fn set_cursor_mode(&mut self, mode: CursorMode) {
                self.cursor_mode = mode;
            }

            fn cursor_mode(&self) -> CursorMode {
                self.cursor_mode
            }

            fn write(&mut self, s: &str) {
                for ch in s.chars() {
                    if ch == '\n' {
                        self.advance_line();
                    } else if ch == '\r' {
                        self.col = 0;
                    } else {
                        self.write_char(ch);
                    }
                }
            }

            fn advance_line(&mut self) {
                self.line += 1;
                self.col = 0;
                if self.line == self.size.lines {
                    self.scroll_up(1);
                }
            }

            fn write_char(&mut self, ch: char) {
                if self.col >= self.size.columns {
                    self.advance_line();
                }

                let idx = self.index();
                self.memory[idx] = ch;
                self.col += 1;
            }

            fn index(&self) -> usize {
                self.line * self.size.columns + self.col
            }
        }
        /// Iterator over lines in a `MemoryTerminal` buffer.
        ///
        /// Note that while this value behaves as an iterator, it cannot implement
        /// the `Iterator` trait because its yielded values borrow `self`.
        pub struct Lines<'a> {
            writer: MutexGuard<'a, Writer>,
            line: usize,
        }

        impl<'a> Lines<'a> {
            /// Returns the next line in the buffer.
            pub fn next(&mut self) -> Option<&[char]> {
                if self.line >= self.writer.size.lines {
                    None
                } else {
                    let start = self.writer.size.columns * self.line;
                    self.line += 1;
                    let end = self.writer.size.columns * self.line;

                    Some(&self.writer.memory[start..end])
                }
            }
            /// Returns the number of lines remaining in the iterator.
            pub fn lines_remaining(&self) -> usize {
                self.writer.size.lines - self.line
            }
        }

        impl Terminal for MemoryTerminal {
            // No preparation needed for in-memory terminal
            type PrepareState = ();
            //type Reader = MemoryReadGuard;
            //type Writer = MemoryWriteGuard;

            fn name(&self) -> &str { "memory-terminal" }

            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a> {
                Box::new(MemoryReadGuard(self.lock_reader()))
            }

            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a> {
                Box::new(MemoryWriteGuard(self.lock_writer()))
            }
        }

        impl<'a> TerminalReader<MemoryTerminal> for MemoryReadGuard<'a> {
            fn wait_for_input(&mut self, _timeout: Option<Duration>) -> io::Result<bool> {
                Ok(!self.0.input.is_empty())
            }

            fn prepare(&mut self, _block_signals: bool, _report_signals: SignalSet)
                    -> io::Result<()> { Ok(()) }

            unsafe fn prepare_with_lock(&mut self,
                    _lock: &mut dyn TerminalWriter<MemoryTerminal>,
                    _block_signals: bool, _report_signals: SignalSet)
                    -> io::Result<()> { Ok(()) }

            fn restore(&mut self, _state: ()) -> io::Result<()> { Ok(()) }

            unsafe fn restore_with_lock(&mut self,
                    _lock: &mut dyn TerminalWriter<MemoryTerminal>, _state: ())
                    -> io::Result<()> { Ok(()) }

            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead> {
                if let Some(size) = self.0.resize.take() {
                    return Ok(RawRead::Resize(size));
                }

                buf.reserve(16);

                let cap = buf.capacity();
                let len = buf.len();
                let n;

                unsafe {
                    buf.set_len(cap);
                    n = self.0.read_input(&mut buf[len..]);
                    buf.set_len(len + n);
                }

                Ok(RawRead::Bytes(n))
            }
        }

        impl<'a> TerminalWriter<MemoryTerminal> for MemoryWriteGuard<'a> {
            fn size(&self) -> io::Result<Size> {
                Ok(self.0.size)
            }

            fn clear_screen(&mut self) -> io::Result<()> {
                self.0.clear_all();
                Ok(())
            }

            fn clear_to_screen_end(&mut self) -> io::Result<()> {
                self.0.clear_to_end();
                Ok(())
            }

            fn move_up(&mut self, n: usize) -> io::Result<()> {
                self.0.move_up(n);
                Ok(())
            }

            fn move_down(&mut self, n: usize) -> io::Result<()> {
                self.0.move_down(n);
                Ok(())
            }

            fn move_left(&mut self, n: usize) -> io::Result<()> {
                self.0.move_left(n);
                Ok(())
            }

            fn move_right(&mut self, n: usize) -> io::Result<()> {
                self.0.move_right(n);
                Ok(())
            }

            fn move_to_first_column(&mut self) -> io::Result<()> {
                self.0.move_to_first_column();
                Ok(())
            }

            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.0.set_cursor_mode(mode);
                Ok(())
            }

            fn write(&mut self, s: &str) -> io::Result<()> {
                self.0.write(s);
                Ok(())
            }

            fn flush(&mut self) -> io::Result<()> { Ok(()) }
        }
    }

    pub mod prompter
    {
        //! Provides access to prompt input state
        use ::
        {
            *,
        };
        
        use std::io;
        use std::mem::replace;
        use std::ops::Range;
        use std::sync::Arc;
        use std::time::Instant;

        use mortal::FindResult;

        use crate::chars::{is_ctrl, is_printable, DELETE, EOF};
        use crate::command::{Category, Command};
        use crate::complete::Completion;
        use crate::function::Function;
        use crate::reader::{BindingIter, InputState, ReadLock, ReadResult};
        use crate::table::{format_columns, Line, Table};
        use crate::terminal::{CursorMode, Signal, Size, Terminal};
        use crate::util::{
            get_open_paren, find_matching_paren, first_word,
            longest_common_prefix, repeat_char,
            back_n_words, forward_n_words,
            backward_char, forward_char, backward_word, forward_word,
            word_start, word_end, RangeArgument,
        };
        use crate::variables::VariableIter;
        use crate::writer::{
            BLINK_DURATION, display_str,
            Digit, Display, HistoryIter, PromptType, Writer, WriteLock,
        };

        /// Provides access to the current state of input while a `read_line` call
        /// is in progress.
        ///
        /// Holds read and write locks on terminal operations.
        /// See [`Interface`] for more information about concurrent operations.
        ///
        /// Instances of this type cannot be constructed by public methods.
        /// Instead, an instance is created internally during a call to [`read_line`].
        ///
        /// [`Interface`]: ../interface/struct.Interface.html
        /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
        pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminal> {
            pub read: &'a mut ReadLock<'b, Term>,
            write: WriteLock<'b, Term>,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Prompter<'a, 'b, Term> {
            pub fn new(read: &'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term>)
                    -> Prompter<'a, 'b, Term> {
                Prompter{read, write}
            }
            /// Returns a `Writer` instance using the currently held write lock.
            ///
            /// This method will move the cursor to a new line after the prompt,
            /// allowing output to be written without corrupting the prompt text.
            /// The prompt will be redrawn when the `Writer` instance is dropped.
            ///
            /// To instead erase the prompt and write text, use [`writer_erase`].
            ///
            /// [`writer_erase`]: #method.writer_erase
            pub fn writer_append<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>> {
                Writer::with_ref(&mut self.write, false)
            }
            /// Returns a `Writer` instance using the currently held write lock.
            ///
            /// This method will erase the prompt, allowing output to be written
            /// without corrupting the prompt text. The prompt will be redrawn
            /// when the `Writer` instance is dropped.
            ///
            /// To instead write text after the prompt, use [`writer_append`].
            ///
            /// [`writer_append`]: #method.writer_append
            pub fn writer_erase<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>> {
                Writer::with_ref(&mut self.write, true)
            }
            /// Resets input state at the start of `read_line`
            fn reset_input(&mut self) {
                self.read.reset_data();
                self.write.reset_data();
            }

            pub fn start_read_line(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.is_prompt_drawn = true;
                self.write.update_size()?;
                self.write.draw_prompt()
            }

            pub fn end_read_line(&mut self) -> io::Result<()> {
                self.write.expire_blink()?;

                if self.read.overwrite_mode {
                    self.write.set_cursor_mode(CursorMode::Normal)?;
                }
                if self.write.is_prompt_drawn {
                    self.write.move_to_end()?;
                    self.write.write_str("\n")?;
                    self.write.is_prompt_drawn = false;
                }

                self.reset_input();
                self.read.state = InputState::Inactive;

                Ok(())
            }

            pub fn handle_input(&mut self, ch: char) -> io::Result<Option<ReadResult>> {
                self.write.expire_blink()?;

                match self.read.state {
                    InputState::Inactive => panic!("input received in inactive state"),
                    InputState::NewSequence => {
                        if ch == EOF && self.write.buffer.is_empty() {
                            self.write.write_str("\n")?;
                            self.write.is_prompt_drawn = false;
                            return Ok(Some(ReadResult::Eof));
                        } else {
                            self.read.sequence.push(ch);
                            self.execute_sequence()?;

                            if self.read.input_accepted {
                                let s = replace(&mut self.write.buffer, String::new());
                                return Ok(Some(ReadResult::Input(s)));
                            }
                        }
                    }
                    InputState::ContinueSequence{expiry: _} => {
                        self.read.sequence.push(ch);

                        self.execute_sequence()?;

                        if self.read.input_accepted {
                            let s = replace(&mut self.write.buffer, String::new());
                            return Ok(Some(ReadResult::Input(s)));
                        }
                    }
                    InputState::Number => {
                        if let Some(digit) = ch.to_digit(10) {
                            self.write.input_arg.input(digit as i32);

                            if self.write.input_arg.is_out_of_bounds() {
                                self.read.state = InputState::NewSequence;
                                self.write.input_arg = Digit::None;
                                self.write.explicit_arg = false;
                                self.write.redraw_prompt(PromptType::Normal)?;
                            } else {
                                self.write.redraw_prompt(PromptType::Number)?;
                            }
                        } else {
                            self.read.state = InputState::NewSequence;
                            self.write.redraw_prompt(PromptType::Normal)?;
                            self.read.macro_buffer.insert(0, ch);
                        }
                    }
                    InputState::CharSearch{n, backward} => {
                        if n != 0 {
                            if backward {
                                self.write.backward_search_char(n, ch)?;
                            } else {
                                self.write.forward_search_char(n, ch)?;
                            }
                        }
                        self.read.state = InputState::NewSequence;
                    }
                    InputState::TextSearch => {
                        if ch == DELETE {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.pop();
                                write.last_search.clone_from(&write.search_buffer);
                            }
                            self.write.search_history_update()?;
                        } else if self.is_abort(ch) {
                            self.abort_search_history()?;
                        } else if is_ctrl(ch) {
                            // End search, handle input after cancelling
                            self.end_search_history()?;
                            self.read.macro_buffer.insert(0, ch);
                        } else {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.push(ch);
                                write.last_search.clone_from(&write.search_buffer);
                            }
                            self.write.search_history_update()?;
                        }
                    }
                    InputState::CompleteIntro => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.write_str("\n")?;
                                self.show_completions_page(0)?;
                            }
                            '\r' | '\n' => {
                                self.write.write_str("\n")?;
                                self.show_completions_line(0)?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.write_str("\n")?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::CompleteMore(offset) => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.clear_prompt()?;
                                self.show_completions_page(offset)?;
                            }
                            '\r' | '\n' => {
                                self.write.clear_prompt()?;
                                self.show_completions_line(offset)?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.clear_prompt()?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::QuotedInsert(n) => {
                        if n != 0 {
                            self.insert(n, ch)?;
                        }
                        self.read.state = InputState::NewSequence;
                    }
                }

                Ok(None)
            }
            /// Returns the current buffer.
            pub fn buffer(&self) -> &str {
                &self.write.buffer
            }
            /// Returns the "backup" buffer.
            ///
            /// When the user is currently editing a history entry, the backup buffer
            /// contains the original user input.
            pub fn backup_buffer(&self) -> &str {
                &self.write.backup_buffer
            }
            /// Returns the command `Category` of the most recently executed command.
            ///
            /// Some commands may use this to influence behavior of repeated commands.
            pub fn last_command_category(&self) -> Category {
                self.read.last_cmd
            }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars(&self) -> &str {
                &self.read.word_break
            }
            /// Sets the buffer to the given value.
            ///
            /// The cursor is moved to the end of the buffer.
            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
                self.write.set_buffer(buf)
            }
            /// Returns the current position of the cursor.
            pub fn cursor(&self) -> usize {
                self.write.cursor
            }
            /// Sets the cursor to the given position within the buffer.
            ///
            /// # Panics
            ///
            /// If the given position is out of bounds or is not aligned to `char` boundaries.
            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
                self.write.set_cursor(pos)
            }
            /// Sets the prompt that will be displayed when `read_line` is called.
            ///
            /// # Notes
            ///
            /// If `prompt` contains any terminal escape sequences (e.g. color codes),
            /// such escape sequences should be immediately preceded by the character
            /// `'\x01'` and immediately followed by the character `'\x02'`.
            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
                self.write.set_prompt(prompt)
            }
            /// Returns the size of the terminal at the last draw operation.
            pub fn screen_size(&self) -> Size {
                self.write.screen_size
            }
            /// Returns whether a numerical argument was explicitly supplied by the user.
            pub fn explicit_arg(&self) -> bool {
                self.write.explicit_arg
            }
            /// Returns the current input sequence.
            pub fn sequence(&self) -> &str {
                &self.read.sequence
            }
            /// Returns an iterator over bound sequences
            pub fn bindings(&self) -> BindingIter {
                self.read.bindings()
            }
            /// Returns an iterator over variable values.
            pub fn variables(&self) -> VariableIter {
                self.read.variables()
            }
            /// Returns an iterator over history entries
            pub fn history(&self) -> HistoryIter {
                self.write.history()
            }
            /// Returns the index into history currently being edited.
            ///
            /// If the user is not editing a line of history, `None` is returned.
            pub fn history_index(&self) -> Option<usize> {
                self.write.history_index
            }
            /// Returns the current number of history entries.
            pub fn history_len(&self) -> usize {
                self.write.history.len()
            }

            fn next_history(&mut self, n: usize) -> io::Result<()> {
                self.write.next_history(n)
            }

            fn prev_history(&mut self, n: usize) -> io::Result<()> {
                self.write.prev_history(n)
            }
            /// Selects the history entry currently being edited by the user.
            ///
            /// Setting the entry to `None` will result in editing the input buffer.
            ///
            /// # Panics
            ///
            /// If the index is out of bounds.
            pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
                self.write.select_history_entry(new)
            }
            /// Returns the current set of completions.
            ///
            /// Unless the most recent command executed was one operating on completion
            /// sets, the result is `None`.
            pub fn completions(&self) -> Option<&[Completion]> {
                self.read.completions.as_ref().map(|v| &v[..])
            }
            /// Sets the current set of completions.
            ///
            /// This completion set is accessed by commands such as `complete` and
            /// `possible-completions`.
            ///
            /// This set will only remain active until the end of the next
            /// non-completion command's execution. Therefore, any `Function`
            /// that uses this method must be of the `Complete` category.
            pub fn set_completions(&mut self, completions: Option<Vec<Completion>>) {
                self.read.completions = completions;
            }
            /// Attempts to execute the current sequence.
            ///
            /// If no bindings match and the sequence contains only printable characters,
            /// the sequence will be inserted as text.
            ///
            /// Returns `true` if a complete sequence was found and executed.
            fn execute_sequence(&mut self) -> io::Result<()> {
                match self.find_binding(&self.read.sequence) {
                    FindResult::Found(cmd) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.read.state = InputState::NewSequence;
                        self.execute_command(cmd, n, ch)?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.read.state = InputState::NewSequence;
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => {
                        let expiry = None;
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                    FindResult::Undecided(_) => {
                        let expiry = self.keyseq_expiry();
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                }

                Ok(())
            }

            fn force_execute_sequence(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;

                match self.find_binding(&self.read.sequence) {
                    FindResult::Found(cmd) |
                    FindResult::Undecided(cmd) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.execute_command(cmd, n, ch)?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => unreachable!(),
                }

                Ok(())
            }
            /// Execute the command `SelfInsert` on the first character in the input
            /// sequence, if it is printable. Then, queue the remaining characters
            /// so they may be reinterpreted.
            fn insert_first_char(&mut self) -> io::Result<()> {
                let (first, rest) = {
                    let mut chars = self.read.sequence.chars();

                    (chars.next().unwrap(), chars.as_str().to_owned())
                };

                self.read.sequence.clear();

                if is_printable(first) {
                    let n = self.write.input_arg.to_i32();
                    self.execute_command(Command::SelfInsert, n, first)?;
                }

                if !rest.is_empty() {
                    self.read.queue_input(&rest);
                }

                Ok(())
            }

            fn find_binding(&self, seq: &str) -> FindResult<Command> {
                self.read.bindings.find(seq).cloned()
            }

            fn get_function(&self, name: &str) -> Option<&Arc<dyn Function<Term>>> {
                self.read.functions.get(name)
            }

            fn is_abort(&self, ch: char) -> bool {
                let mut buf = [0; 4];
                let s = ch.encode_utf8(&mut buf);

                self.find_binding(&s) == FindResult::Found(Command::Abort)
            }

            fn execute_command(&mut self, cmd: Command, n: i32, ch: char) -> io::Result<()> {
                use crate::command::Command::*;

                let mut category = cmd.category();

                if self.read.overwrite_mode {
                    match cmd {
                        DigitArgument | SelfInsert => (),
                        BackwardDeleteChar if n >= 0 => (),
                        _ => self.read.overwritten_chars.clear()
                    }
                }

                match cmd {
                    Abort => (),
                    AcceptLine => {
                        self.accept_input()?;
                    }
                    Complete => {
                        if !self.read.disable_completion {
                            self.complete_word()?;
                        } else if is_printable(ch) {
                            self.execute_command(SelfInsert, n, ch)?;
                        }
                    }
                    InsertCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some(completions) = self.read.completions.take() {
                            self.insert_completions(&completions)?;
                            self.read.completions = Some(completions);
                        }
                    }
                    PossibleCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some(completions) = self.read.completions.take() {
                            self.show_completions(&completions)?;
                            self.read.completions = Some(completions);
                        }
                    }
                    MenuComplete => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.next_completion(n as usize)?;
                        } else {
                            self.prev_completion((-n) as usize)?;
                        }
                    }
                    MenuCompleteBackward => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.prev_completion(n as usize)?;
                        } else {
                            self.next_completion((-n) as usize)?;
                        }
                    }
                    DigitArgument => {
                        self.read.state = InputState::Number;
                        self.write.set_digit_from_char(ch);
                        self.write.redraw_prompt(PromptType::Number)?;
                    }
                    SelfInsert => {
                        if n > 0 {
                            let n = n as usize;

                            if self.read.overwrite_mode {
                                self.overwrite(n, ch)?;
                            } else {
                                self.insert(n, ch)?;
                            }

                            if self.read.blink_matching_paren {
                                if let Some(open) = get_open_paren(ch) {
                                    if let Some(pos) = find_matching_paren(
                                            &self.write.buffer[..self.write.cursor],
                                            &self.read.string_chars, open, ch) {
                                        self.blink(pos)?;
                                    }
                                }
                            }
                        }
                    }
                    TabInsert => {
                        if n > 0 {
                            self.insert(n as usize, '\t')?;
                        }
                    }
                    InsertComment => {
                        if self.explicit_arg() &&
                                self.write.buffer.starts_with(&self.read.comment_begin[..]) {
                            self.write.move_to(0)?;
                            let n = self.read.comment_begin.len();

                            self.delete_range(..n)?;
                            self.accept_input()?;
                        } else {
                            self.write.move_to(0)?;
                            let s = self.read.comment_begin.clone();
                            self.insert_str(&s)?;
                            self.accept_input()?;
                        }
                    }
                    BackwardChar => {
                        if n > 0 {
                            self.write.backward_char(n as usize)?;
                        } else if n < 0 {
                            self.write.forward_char((-n) as usize)?;
                        }
                    }
                    ForwardChar => {
                        if n > 0 {
                            self.write.forward_char(n as usize)?;
                        } else if n < 0 {
                            self.write.backward_char((-n) as usize)?;
                        }
                    }
                    CharacterSearch => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: false,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: (-n) as usize,
                                backward: true,
                            };
                        }
                    }
                    CharacterSearchBackward => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: true,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: (-n) as usize,
                                backward: false,
                            };
                        }
                    }
                    BackwardWord => {
                        if n > 0 {
                            self.backward_word(n as usize)?;
                        } else if n < 0 {
                            self.forward_word((-n) as usize)?;
                        }
                    }
                    ForwardWord => {
                        if n > 0 {
                            let pos = forward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            self.write.move_to(pos)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            self.write.move_to(pos)?;
                        }
                    }
                    BackwardKillLine => {
                        let r = ..self.write.cursor;
                        self.kill_range(r)?;
                    }
                    KillLine => {
                        let r = self.write.cursor..;
                        self.kill_range(r)?;
                    }
                    BackwardKillWord => {
                        if n > 0 {
                            let pos = backward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        }
                    }
                    KillWord => {
                        if n > 0 {
                            let pos = forward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = backward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        }
                    }
                    UnixWordRubout => {
                        if n > 0 {
                            let pos = backward_word(n as usize,
                                &self.write.buffer, self.write.cursor, " \t\n");
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, " \t\n");
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        }
                    }
                    ClearScreen => {
                        self.write.clear_screen()?;
                    }
                    BeginningOfLine => self.write.move_to(0)?,
                    EndOfLine => self.write.move_to_end()?,
                    BackwardDeleteChar => {
                        if n > 0 {
                            if self.read.overwrite_mode {
                                self.overwrite_back(n as usize)?;
                            } else {
                                let pos = backward_char(n as usize,
                                    &self.write.buffer, self.write.cursor);
                                let r = pos..self.write.cursor;
                                self.delete_range(r)?;
                            }
                        } else if n < 0 {
                            let pos = forward_char((-n) as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = self.write.cursor..pos;
                            self.delete_range(r)?;
                        }
                    }
                    DeleteChar => {
                        if n > 0 {
                            let pos = forward_char(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = self.write.cursor..pos;
                            self.delete_range(r)?;
                        } else if n < 0 {
                            let pos = backward_char(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = pos..self.write.cursor;
                            self.delete_range(r)?;
                        }
                    }
                    TransposeChars => {
                        if n != 0 && self.write.cursor != 0 {
                            let (src, dest);

                            if !self.explicit_arg() && self.write.cursor == self.write.buffer.len() {
                                let end = backward_char(1, &self.write.buffer, self.write.cursor);
                                let start = backward_char(1, &self.write.buffer, end);

                                src = start..end;
                                dest = end..self.write.cursor;
                            } else {
                                let start = backward_char(1, &self.write.buffer, self.write.cursor);
                                let end = self.write.cursor;

                                src = start..end;

                                dest = if n < 0 {
                                    let back = backward_char((-n) as usize, &self.write.buffer, start);
                                    back..start
                                } else {
                                    let fwd = forward_char(n as usize + 1, &self.write.buffer, start);
                                    end..fwd
                                };
                            }

                            self.transpose_range(src, dest)?;
                        }
                    }
                    TransposeWords => {
                        if n != 0 {
                            if let Some(first) = first_word(&self.write.buffer[..self.write.cursor], &self.read.word_break) {
                                let start = word_start(&self.write.buffer, self.write.cursor, &self.read.word_break);

                                if first != start {
                                    let (src, dest);

                                    if !self.explicit_arg() && start == self.write.buffer.len() {
                                        let dest_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                        let dest_end = word_end(&self.write.buffer, dest_start, &self.read.word_break);

                                        let src_start = backward_word(1, &self.write.buffer, dest_start, &self.read.word_break);
                                        let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                        src = src_start..src_end;
                                        dest = dest_start..dest_end;
                                    } else {
                                        let src_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                        let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                        src = src_start..src_end;

                                        dest = if n < 0 {
                                            back_n_words((-n) as usize, &self.write.buffer, src_start, &self.read.word_break)
                                        } else {
                                            forward_n_words(n as usize, &self.write.buffer, src_start, &self.read.word_break)
                                        };
                                    }

                                    self.transpose_range(src, dest)?;
                                }
                            }
                        }
                    }
                    BeginningOfHistory => {
                        self.select_history_entry(Some(0))?;
                    }
                    EndOfHistory => {
                        self.select_history_entry(None)?;
                    }
                    NextHistory => {
                        if n > 0 {
                            self.next_history(n as usize)?;
                        } else if n < 0 {
                            self.prev_history((-n) as usize)?;
                        }
                    }
                    PreviousHistory => {
                        if n > 0 {
                            self.prev_history(n as usize)?;
                        } else if n < 0 {
                            self.next_history((-n) as usize)?;
                        }
                    }
                    ForwardSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history(false)?;
                        } else {
                            self.write.start_search_history(false)?;
                        }
                    }
                    ReverseSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history(true)?;
                        } else {
                            self.write.start_search_history(true)?;
                        }
                    }
                    HistorySearchForward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search(false)?;
                        } else {
                            self.write.start_history_search(false)?;
                        }
                    }
                    HistorySearchBackward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search(true)?;
                        } else {
                            self.write.start_history_search(true)?;
                        }
                    }
                    QuotedInsert => {
                        self.read.state = InputState::QuotedInsert(
                            if n >= 0 { n as usize } else { 0 });
                    }
                    OverwriteMode => {
                        self.read.overwrite_mode = !self.read.overwrite_mode;

                        if !self.read.overwrite_mode {
                            self.read.overwritten_append = 0;
                            self.read.overwritten_chars.clear();
                        }

                        let mode = if self.read.overwrite_mode {
                            CursorMode::Overwrite
                        } else {
                            CursorMode::Normal
                        };

                        self.write.set_cursor_mode(mode)?;
                    }
                    Yank => {
                        self.yank()?;
                    }
                    YankPop => {
                        self.yank_pop()?;
                    }
                    Custom(ref name) => {
                        if let Some(fun) = self.get_function(name).cloned() {
                            fun.execute(self, n, ch)?;

                            category = fun.category();
                        }
                    }
                    Macro(ref seq) => {
                        self.read.queue_input(seq);
                    }
                }

                if category != Category::Digit {
                    self.write.input_arg = Digit::None;
                    self.write.explicit_arg = false;

                    self.read.last_cmd = category;

                    if category != Category::Complete {
                        self.read.completions = None;
                    }

                    if category != Category::Yank {
                        self.read.last_yank = None;
                    }
                }

                Ok(())
            }
            /// Accepts the current input buffer as user input.
            ///
            /// This method may be called by a [`Function`] implementation, immediately
            /// before ending execution, in order to simulate the `accept-line` command;
            /// e.g. to implement a command that extends the default behavior of the
            /// `accept-line` action.
            ///
            /// Behavior of this method is undefined if called outside of a `Function`
            /// implementation.
            ///
            /// [`Function`]: ../function/trait.Function.html
            pub fn accept_input(&mut self) -> io::Result<()> {
                self.write.move_to_end()?;
                self.write.write_str("\n")?;
                self.read.input_accepted = true;
                self.write.is_prompt_drawn = false;
                Ok(())
            }
            /// Moves the cursor to the given position, waits for 500 milliseconds
            /// (or until next user input), then restores the original cursor position.
            ///
            /// # Panics
            ///
            /// If the given position is out of bounds or is not aligned to `char` boundaries.
            pub fn blink(&mut self, pos: usize) -> io::Result<()> {
                self.write.blink(pos)?;

                self.read.max_wait_duration = Some(BLINK_DURATION);

                Ok(())
            }

            fn check_expire_blink(&mut self, now: Instant) -> io::Result<()> {
                if self.write.check_expire_blink(now)? {
                    self.read.max_wait_duration = None;
                }

                Ok(())
            }

            fn check_expire_sequence(&mut self, now: Instant) -> io::Result<()> {
                if let InputState::ContinueSequence{expiry: Some(expiry)} = self.read.state {
                    if now >= expiry {
                        self.read.max_wait_duration = None;
                        self.force_execute_sequence()?;
                    }
                }

                Ok(())
            }

            fn keyseq_expiry(&mut self) -> Option<Instant> {
                if let Some(t) = self.read.keyseq_timeout {
                    self.read.max_wait_duration = Some(t);
                    Some(Instant::now() + t)
                } else {
                    None
                }
            }

            pub fn check_expire_timeout(&mut self) -> io::Result<()> {
                let now = Instant::now();

                self.check_expire_blink(now)?;
                self.check_expire_sequence(now)
            }

            fn expire_blink(&mut self) -> io::Result<()> {
                self.read.max_wait_duration = None;
                self.write.expire_blink()
            }

            fn build_completions(&mut self) {
                let compl = self.read.completer.clone();
                let end = self.write.cursor;
                let start = compl.word_start(&self.write.buffer, end, self);

                if start > end {
                    panic!("Completer::word_start returned invalid index; \
                        start > end ({} > {})", start, end);
                }

                let unquoted = compl.unquote(&self.write.buffer[start..end]).into_owned();

                let completions = compl.complete(&unquoted, self, start, end);
                let n_completions = completions.as_ref().map_or(0, |c| c.len());

                self.read.completions = completions;
                self.read.completion_index = n_completions;
                self.read.completion_start = start;
                self.read.completion_prefix = end;
            }

            fn complete_word(&mut self) -> io::Result<()> {
                if let Some(completions) = self.read.completions.take() {
                    if completions.len() == 1 {
                        self.substitute_completion(&completions[0])?;
                    } else {
                        self.show_completions(&completions)?;
                        self.read.completions = Some(completions);
                    }
                } else {
                    self.build_completions();
                    let completions = self.read.completions.take().unwrap_or_default();

                    if completions.len() == 1 {
                        self.substitute_completion(&completions[0])?;
                    } else if !completions.is_empty() {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;

                        {
                            let pfx = longest_common_prefix(completions.iter()
                                .map(|compl| &compl.completion[..]))
                                .unwrap_or_default();
                            self.replace_str_forward(start..end, &pfx)?;
                        }

                        self.read.completions = Some(completions);
                    }
                }

                Ok(())
            }

            fn substitute_completion(&mut self, compl: &Completion) -> io::Result<()> {
                let mut s = self.read.completer.quote(&compl.completion);

                if let Some(suffix) = compl.suffix.with_default(self.read.completion_append_character) {
                    s.to_mut().push(suffix);
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;
                self.replace_str_forward(start..end, &s)
            }

            fn insert_completions(&mut self, completions: &[Completion]) -> io::Result<()> {
                let mut words = String::new();

                for compl in completions {
                    words.push_str(&self.read.completer.unquote(&compl.completion));
                    words.push(' ');
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;

                self.replace_str_forward(start..end, &words)
            }

            fn show_completions(&mut self, completions: &[Completion]) -> io::Result<()> {
                if completions.is_empty() {
                    return Ok(());
                }

                let eff_width = self.write.screen_size.columns
                    .min(self.read.completion_display_width);

                let completions = completions.iter()
                    .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                    .collect::<Vec<_>>();

                let cols = format_columns(&completions, eff_width,
                    self.read.print_completions_horizontally);
                let table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                    self.read.print_completions_horizontally);

                self.write.write_str("\n")?;

                let n_completions = completions.len();

                if self.read.page_completions &&
                        n_completions >= self.read.completion_query_items {
                    // TODO: Replace borrowed data in `Table` with owned data.
                    // Then, store table here to avoid regenerating column widths
                    self.start_page_completions(n_completions)
                } else {
                    self.show_list_completions(table)?;
                    self.write.draw_prompt()
                }
            }

            fn start_page_completions(&mut self, n_completions: usize) -> io::Result<()> {
                self.read.state = InputState::CompleteIntro;
                self.write.redraw_prompt(PromptType::CompleteIntro(n_completions))
            }

            fn end_page_completions(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.prompt_type = PromptType::Normal;
                self.write.draw_prompt()
            }

            fn is_paging_completions(&self) -> bool {
                match self.read.state {
                    InputState::CompleteMore(_) => true,
                    _ => false
                }
            }

            fn show_completions_page(&mut self, offset: usize) -> io::Result<()> {
                if let Some(compl) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min(self.read.completion_display_width);
                    let n_lines = self.write.screen_size.lines - 1;

                    let completions = compl.iter()
                        .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                        .collect::<Vec<_>>();

                    let cols = format_columns(&completions, width,
                        self.read.print_completions_horizontally);
                    let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                        self.read.print_completions_horizontally);

                    for row in table.by_ref().skip(offset).take(n_lines) {
                        self.show_completion_line(row)?;
                    }

                    if table.has_more() {
                        self.read.completions = Some(compl);
                        self.read.state = InputState::CompleteMore(offset + n_lines);
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok(())
            }

            fn show_completions_line(&mut self, offset: usize) -> io::Result<()> {
                if let Some(compl) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min(self.read.completion_display_width);
                    let completions = compl.iter()
                        .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                        .collect::<Vec<_>>();

                    let cols = format_columns(&completions, width,
                        self.read.print_completions_horizontally);
                    let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                        self.read.print_completions_horizontally);

                    if let Some(row) = table.by_ref().skip(offset).next() {
                        self.show_completion_line(row)?;
                    }

                    if table.has_more() {
                        self.read.completions = Some(compl);
                        self.read.state = InputState::CompleteMore(offset + 1);
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok(())
            }

            fn show_completion_line<S: AsRef<str>>(&mut self, line: Line<S>) -> io::Result<()> {
                let mut space = 0;

                for (width, name) in line {
                    self.write.move_right(space)?;
                    self.write.write_str(name)?;
                    space = width - name.chars().count();
                }

                self.write.write_str("\n")
            }

            fn show_list_completions<S: AsRef<str>>(&mut self, table: Table<S>) -> io::Result<()> {
                for line in table {
                    let mut space = 0;

                    for (width, name) in line {
                        self.write.move_right(space)?;
                        self.write.write_str(name)?;
                        space = width - name.chars().count();
                    }
                    self.write.write_str("\n")?;
                }

                Ok(())
            }

            fn next_completion(&mut self, n: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let max = len + 1;

                let old = self.read.completion_index;
                let new = (old + n) % max;

                if old != new {
                    self.set_completion(new)?;
                }

                Ok(())
            }

            fn prev_completion(&mut self, n: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let max = len + 1;

                let old = self.read.completion_index;
                let new = if n <= old {
                    max - old - n
                } else {
                    old - n
                };

                self.set_completion(new)
            }

            fn set_completion(&mut self, new: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let old = self.read.completion_index;

                if old != new {
                    self.read.completion_index = new;

                    if new == len {
                        let start = self.read.completion_prefix;
                        let end = self.write.cursor;

                        self.delete_range(start..end)?;
                    } else {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;
                        let s = self.read.completions.as_ref().unwrap()[new]
                            .completion(self.read.completion_append_character).into_owned();

                        self.replace_str_forward(start..end, &s)?;
                    }
                }

                Ok(())
            }

            fn abort_search_history(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.read.last_cmd = Category::Other;
                self.write.abort_search_history()
            }

            fn end_search_history(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.end_search_history()
            }

            pub fn handle_resize(&mut self, size: Size) -> io::Result<()> {
                self.expire_blink()?;

                if self.is_paging_completions() {
                    self.end_page_completions()?;
                }

                self.write.screen_size = size;

                let p = self.write.prompt_type;
                self.write.redraw_prompt(p)
            }

            pub fn handle_signal(&mut self, signal: Signal) -> io::Result<()> {
                self.expire_blink()?;

                match signal {
                    Signal::Continue => {
                        self.write.draw_prompt()?;
                    }
                    Signal::Interrupt => {
                        self.read.macro_buffer.clear();
                        self.write.move_to_end()?;

                        if self.read.echo_control_characters {
                            self.write.write_str("^C")?;
                        }

                        self.write.write_str("\n")?;
                        self.reset_input();
                        self.write.draw_prompt()?;
                    }
                    _ => ()
                }

                Ok(())
            }

            fn backward_word(&mut self, n: usize) -> io::Result<()> {
                let pos = backward_word(n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break);
                self.write.move_to(pos)
            }

            fn forward_word(&mut self, n: usize) -> io::Result<()> {
                let pos = forward_word(n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break);
                self.write.move_to(pos)
            }
            /// Deletes a range of text from the input buffer.
            ///
            /// # Panics
            ///
            /// If the given range is out of bounds or is not aligned to `char` boundaries.
            pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                self.write.delete_range(range)
            }
            /// Deletes a range from the buffer and adds the removed text to the
            /// kill ring.
            ///
            /// # Panics
            ///
            /// If the given range is out of bounds or is not aligned to `char` boundaries.
            pub fn kill_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                let len = end - start;

                if len != 0 {
                    let buf = self.write.buffer[start..end].to_owned();

                    if self.read.last_cmd != Category::Kill {
                        self.push_kill_ring(buf);
                    } else if end == self.write.cursor {
                        self.prepend_kill_ring(buf);
                    } else {
                        self.append_kill_ring(buf);
                    }

                    self.delete_range(start..end)?;
                }

                Ok(())
            }

            fn push_kill_ring(&mut self, s: String) {
                if self.read.kill_ring.len() == self.read.kill_ring.capacity() {
                    self.read.kill_ring.pop_back();
                }
                self.read.kill_ring.push_front(s);
            }

            fn rotate_kill_ring(&mut self) {
                if let Some(kill) = self.read.kill_ring.pop_front() {
                    self.read.kill_ring.push_back(kill);
                }
            }

            fn append_kill_ring(&mut self, s: String) {
                if let Some(kill) = self.read.kill_ring.front_mut() {
                    kill.push_str(&s);
                    return;
                }
                self.push_kill_ring(s);
            }

            fn prepend_kill_ring(&mut self, s: String) {
                if let Some(kill) = self.read.kill_ring.front_mut() {
                    kill.insert_str(0, &s);
                    return;
                }
                self.push_kill_ring(s);
            }
            /// Transposes two regions of the buffer, `src` and `dest`.
            /// The cursor is placed at the end of the new location of `src`.
            ///
            /// # Panics
            ///
            /// If `src` and `dest` overlap, are out of bounds,
            /// or are not aligned to `char` boundaries.
            pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                    -> io::Result<()> {
                self.write.transpose_range(src, dest)
            }
            /// Insert text from the front of the kill ring at the current cursor position.
            /// The cursor is placed at the end of the new text.
            pub fn yank(&mut self) -> io::Result<()> {
                if let Some(kill) = self.read.kill_ring.front().cloned() {
                    let start = self.write.cursor;
                    self.read.last_yank = Some((start, start + kill.len()));

                    self.insert_str(&kill)?;
                }

                Ok(())
            }
            /// Rotates the kill ring and replaces yanked text with the new front.
            ///
            /// If the previous operation was not `yank`, this has no effect.
            pub fn yank_pop(&mut self) -> io::Result<()> {
                if let Some((start, end)) = self.read.last_yank {
                    self.rotate_kill_ring();

                    if let Some(kill) = self.read.kill_ring.front().cloned() {
                        self.read.last_yank = Some((start, start + kill.len()));

                        self.write.move_to(start)?;
                        self.replace_str_forward(start..end, &kill)?;
                    }
                }

                Ok(())
            }
            /// Overwrite `n` characters; assumes `n >= 1`
            fn overwrite(&mut self, n: usize, ch: char) -> io::Result<()> {
                let start = self.write.cursor;
                let end = forward_char(n, &self.write.buffer, start);

                {
                    let over = &self.write.buffer[start..end];
                    let n_chars = over.chars().count();

                    if n > n_chars {
                        self.read.overwritten_append += n - n_chars;
                    }

                    if !over.is_empty() {
                        self.read.overwritten_chars.push_str(&over);
                    }
                }

                let s = repeat_char(ch, n);
                self.replace_str_forward(start..end, &s)
            }

            fn overwrite_back(&mut self, mut n: usize) -> io::Result<()> {
                if self.read.overwritten_append != 0 {
                    let n_del = n.min(self.read.overwritten_append);

                    let pos = backward_char(n_del, &self.write.buffer, self.write.cursor);
                    let r = pos..self.write.cursor;
                    self.delete_range(r)?;

                    self.read.overwritten_append -= n_del;
                    n -= n_del;
                }

                if n != 0 && !self.read.overwritten_chars.is_empty() {
                    let n_repl = n.min(self.read.overwritten_chars.chars().count());

                    let pos = backward_char(n_repl, &self.write.buffer, self.write.cursor);

                    let over_pos = backward_char(n_repl,
                        &self.read.overwritten_chars, self.read.overwritten_chars.len());

                    let over = self.read.overwritten_chars.drain(over_pos..).collect::<String>();

                    let r = pos..self.write.cursor;
                    self.replace_str_backward(r, &over)?;

                    n -= n_repl;
                }

                if n != 0 {
                    self.write.backward_char(n)?;
                }

                Ok(())
            }
            /// Insert a given character at the current cursor position `n` times.
            ///
            /// The cursor position remains the same.
            pub fn insert(&mut self, n: usize, ch: char) -> io::Result<()> {
                if n != 0 {
                    let s = repeat_char(ch, n);
                    self.insert_str(&s)?;
                }

                Ok(())
            }
            /// Insert a string at the current cursor position.
            ///
            /// The cursor is placed at the end of the new string.
            pub fn insert_str(&mut self, s: &str) -> io::Result<()> {
                self.write.insert_str(s)
            }
            /// Replaces a range in the buffer and redraws.
            ///
            /// The cursor is placed at the start of the range.
            pub fn replace_str_backward<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                self.replace_str_impl(range, s)?;
                let len = self.write.buffer.len();
                self.write.move_from(len)
            }
            /// Replaces a range in the buffer and redraws.
            ///
            /// The cursor is placed at the end of the new string.
            pub fn replace_str_forward<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                self.replace_str_impl(range, s)?;
                self.write.cursor += s.len();
                let len = self.write.buffer.len();
                self.write.move_from(len)
            }
            /// Replaces a range in the buffer and redraws.
            ///
            /// The cursor position is set to start of range, on-screen cursor remains
            /// at end of buffer.
            fn replace_str_impl<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                self.write.move_to(start)?;

                let _ = self.write.buffer.drain(start..end);
                let cursor = self.write.cursor;
                self.write.buffer.insert_str(cursor, s);

                self.write.draw_buffer(cursor)?;
                self.write.clear_to_screen_end()
            }
        }
    }

    pub mod reader
    {
        //! Provides access to terminal read operations
        use ::
        {
            *,
        };
        

        use std::borrow::Cow;
        use std::collections::{HashMap, VecDeque};
        use std::io;
        use std::mem::replace;
        use std::ops::{Deref, DerefMut};
        use std::path::{Path, PathBuf};
        use std::slice;
        use std::sync::{Arc, MutexGuard};
        use std::time::{Duration, Instant};

        use mortal::SequenceMap;

        use crate::command::{Category, Command};
        use crate::complete::{Completer, Completion, DummyCompleter};
        use crate::function::Function;
        use crate::inputrc::{parse_file, Directive};
        use crate::interface::Interface;
        use crate::prompter::Prompter;
        use crate::sys::path::{env_init_file, system_init_file, user_init_file};
        use crate::terminal::{
            RawRead, Signal, SignalSet, Size,
            Terminal, TerminalReader,
        };
        use crate::util::{first_char, match_name};
        use crate::variables::{Variable, Variables, VariableIter};

        /// Default set of string characters
        pub const STRING_CHARS: &str = "\"'";

        /// Default set of word break characters
        pub const WORD_BREAK_CHARS: &str = " \t\n\"\\'`@$><=;|&{(";

        /// Indicates the start of a series of invisible characters in the prompt
        pub const START_INVISIBLE: char = '\x01';

        /// Indicates the end of a series of invisible characters in the prompt
        pub const END_INVISIBLE: char = '\x02';

        /// Maximum size of kill ring
        const MAX_KILLS: usize = 10;

        /// Provides access to data related to reading and processing user input.
        ///
        /// Holds a lock on terminal read operations.
        /// See [`Interface`] for more information about concurrent operations.
        ///
        /// An instance of this type can be constructed using the
        /// [`Interface::lock_reader`] method.
        ///
        /// [`Interface`]: ../interface/struct.Interface.html
        /// [`Interface::lock_reader`]: ../interface/struct.Interface.html#method.lock_reader
        pub struct Reader<'a, Term: 'a + Terminal> {
            iface: &'a Interface<Term>,
            lock: ReadLock<'a, Term>,
        }

        pub struct Read<Term: Terminal> {
            /// Application name
            pub application: Cow<'static, str>,

            /// Pending input
            pub input_buffer: Vec<u8>,
            /// Pending macro sequence
            pub macro_buffer: String,

            pub bindings: SequenceMap<Cow<'static, str>, Command>,
            pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,

            /// Current input sequence
            pub sequence: String,
            /// Whether newline has been received
            pub input_accepted: bool,

            /// Whether overwrite mode is currently active
            pub overwrite_mode: bool,
            /// Characters appended while in overwrite mode
            pub overwritten_append: usize,
            /// Characters overwritten in overwrite mode
            pub overwritten_chars: String,

            /// Configured completer
            pub completer: Arc<dyn Completer<Term>>,
            /// Character appended to completions
            pub completion_append_character: Option<char>,
            /// Current set of possible completions
            pub completions: Option<Vec<Completion>>,
            /// Current "menu-complete" entry being viewed:
            pub completion_index: usize,
            /// Start of the completed word
            pub completion_start: usize,
            /// Start of the inserted prefix of a completed word
            pub completion_prefix: usize,

            pub string_chars: Cow<'static, str>,
            pub word_break: Cow<'static, str>,

            pub last_cmd: Category,
            pub last_yank: Option<(usize, usize)>,
            pub kill_ring: VecDeque<String>,

            pub catch_signals: bool,
            pub ignore_signals: SignalSet,
            pub report_signals: SignalSet,
            pub last_resize: Option<Size>,
            pub last_signal: Option<Signal>,

            variables: Variables,

            pub state: InputState,
            pub max_wait_duration: Option<Duration>,
        }

        pub struct ReadLock<'a, Term: 'a + Terminal> {
            term: Box<dyn TerminalReader<Term> + 'a>,
            data: MutexGuard<'a, Read<Term>>,
        }
        /// Returned from [`read_line`] to indicate user input
        ///
        /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
        #[derive(Debug)]
        pub enum ReadResult {
            /// User issued end-of-file
            Eof,
            /// User input received
            Input(String),
            /// Reported signal was received
            Signal(Signal),
        }

        #[derive(Copy, Clone, Debug)]
        pub enum InputState {
            Inactive,
            NewSequence,
            ContinueSequence{
                expiry: Option<Instant>,
            },
            Number,
            CharSearch{
                n: usize,
                backward: bool,
            },
            TextSearch,
            CompleteIntro,
            CompleteMore(usize),
            QuotedInsert(usize),
        }

        impl<'a, Term: 'a + Terminal> Reader<'a, Term> {
            pub fn new(iface: &'a Interface<Term>, lock: ReadLock<'a, Term>)
                    -> Reader<'a, Term> {
                Reader{iface, lock}
            }
            /// Interactively reads a line from the terminal device.
            ///
            /// User input is collected until one of the following conditions is met:
            ///
            /// * If the user issues an end-of-file, `ReadResult::Eof` is returned.
            /// * When the user inputs a newline (`'\n'`), the resulting input
            ///   (not containing a trailing newline character) is returned as
            ///   `ReadResult::Input(_)`.
            /// * When a reported signal (see [`set_report_signal`]) is received,
            ///   it is returned as `ReadResult::Signal(_)`. The `read_line` operation may
            ///   then be either resumed with another call to `read_line` or ended by
            ///   calling [`cancel_read_line`].
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`set_report_signal`]: #method.set_report_signal
            pub fn read_line(&mut self) -> io::Result<ReadResult> {
                loop {
                    if let Some(res) = self.read_line_step(None)? {
                        return Ok(res);
                    }
                }
            }
            /// Performs one step of the interactive `read_line` loop.
            ///
            /// This method can be used to drive the `read_line` process asynchronously.
            /// It will wait for input only up to the specified duration, then process
            /// any available input from the terminal.
            ///
            /// If the user completes the input process, `Ok(Some(result))` is returned.
            /// Otherwise, `Ok(None)` is returned to indicate that the interactive loop
            /// may continue.
            ///
            /// The interactive prompt may be cancelled prematurely using the
            /// [`cancel_read_line`] method.
            ///
            /// See [`read_line`] for details on the return value.
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`read_line`]: #method.read_line
            pub fn read_line_step(&mut self, timeout: Option<Duration>)
                    -> io::Result<Option<ReadResult>> {
                self.initialize_read_line()?;

                let state = self.prepare_term()?;
                let res = self.read_line_step_impl(timeout);
                self.lock.term.restore(state)?;

                res
            }
            /// Cancels an in-progress `read_line` operation.
            ///
            /// This method will reset internal data structures to their original state
            /// and move the terminal cursor to a new, empty line.
            ///
            /// This method is called to prematurely end the interactive loop when
            /// using the [`read_line_step`] method.
            ///
            /// It is not necessary to call this method if using the [`read_line`] method.
            ///
            /// [`read_line`]: #method.read_line
            /// [`read_line_step`]: #method.read_line_step
            pub fn cancel_read_line(&mut self) -> io::Result<()> {
                self.end_read_line()
            }

            fn initialize_read_line(&mut self) -> io::Result<()> {
                if !self.lock.is_active() {
                    self.prompter().start_read_line()?;
                }
                Ok(())
            }

            fn read_line_step_impl(&mut self, timeout: Option<Duration>)
                    -> io::Result<Option<ReadResult>> {
                let do_read = if self.lock.is_input_available() {
                    // This branch will be taken only if a macro has buffered some input.
                    // We check for input with a zero duration to see if the user has
                    // entered Ctrl-C, e.g. to interrupt an infinitely recursive macro.
                    self.lock.term.wait_for_input(Some(Duration::from_secs(0)))?
                } else {
                    let timeout = limit_duration(timeout, self.lock.max_wait_duration);
                    self.lock.term.wait_for_input(timeout)?
                };

                if do_read {
                    self.lock.read_input()?;
                }

                if let Some(size) = self.lock.take_resize() {
                    self.handle_resize(size)?;
                }

                if let Some(sig) = self.lock.take_signal() {
                    if self.lock.report_signals.contains(sig) {
                        return Ok(Some(ReadResult::Signal(sig)));
                    }
                    if !self.lock.ignore_signals.contains(sig) {
                        self.handle_signal(sig)?;
                    }
                }

                // Acquire the write lock and process all available input
                {
                    let mut prompter = self.prompter();

                    prompter.check_expire_timeout()?;

                    // If the macro buffer grows in size while input is being processed,
                    // we end this step and let the caller try again. This is to allow
                    // reading Ctrl-C to interrupt (perhaps infinite) macro execution.
                    let mut macro_len = prompter.read.data.macro_buffer.len();

                    while prompter.read.is_input_available() {
                        if let Some(ch) = prompter.read.read_char()? {
                            if let Some(r) = prompter.handle_input(ch)? {
                                prompter.end_read_line()?;
                                return Ok(Some(r));
                            }
                        }

                        let new_macro_len = prompter.read.data.macro_buffer.len();

                        if new_macro_len != 0 && new_macro_len >= macro_len {
                            break;
                        }

                        macro_len = new_macro_len;
                    }
                }

                Ok(None)
            }

            fn end_read_line(&mut self) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().end_read_line()?;
                }
                Ok(())
            }

            fn prepare_term(&mut self) -> io::Result<Term::PrepareState> {
                if self.read_next_raw() {
                    self.lock.term.prepare(true, SignalSet::new())
                } else {
                    let mut signals = self.lock.report_signals.union(self.lock.ignore_signals);

                    if self.lock.catch_signals {
                        // Ctrl-C is always intercepted (unless we're catching no signals).
                        // By default, lineread handles it by clearing the current input state.
                        signals.insert(Signal::Interrupt);
                    }

                    let block_signals = !self.lock.catch_signals;

                    self.lock.term.prepare(block_signals, signals)
                }
            }

            fn read_next_raw(&self) -> bool {
                match self.lock.state {
                    InputState::QuotedInsert(_) => true,
                    _ => false
                }
            }
            /// Sets the input buffer to the given string.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// # Notes
            ///
            /// To prevent invalidating the cursor, this method sets the cursor
            /// position to the end of the new buffer.
            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_buffer(buf)
                } else {
                    self.iface.lock_write_data().set_buffer(buf);
                    Ok(())
                }
            }
            /// Sets the cursor position in the input buffer.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// # Panics
            ///
            /// If the given position is out of bounds or not on a `char` boundary.
            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_cursor(pos)
                } else {
                    self.iface.lock_write_data().set_cursor(pos);
                    Ok(())
                }
            }
            /// Sets the prompt that will be displayed when `read_line` is called.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// # Notes
            ///
            /// If `prompt` contains any terminal escape sequences (e.g. color codes),
            /// such escape sequences should be immediately preceded by the character
            /// `'\x01'` and immediately followed by the character `'\x02'`.
            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
                self.prompter().set_prompt(prompt)
            }
            /// Adds a line to history.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn add_history(&self, line: String) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history(line);
                }
            }
            /// Adds a line to history, unless it is identical to the most recent entry.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn add_history_unique(&self, line: String) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history_unique(line);
                }
            }
            /// Removes all history entries.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn clear_history(&self) {
                if !self.lock.is_active() {
                    self.iface.lock_write().clear_history();
                }
            }
            /// Removes the history entry at the given index.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If the index is out of bounds, this method has no effect.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn remove_history(&self, idx: usize) {
                if !self.lock.is_active() {
                    self.iface.lock_write().remove_history(idx);
                }
            }
            /// Sets the maximum number of history entries.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If `n` is less than the current number of history entries,
            /// the oldest entries are truncated to meet the given requirement.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn set_history_size(&self, n: usize) {
                if !self.lock.is_active() {
                    self.iface.lock_write().set_history_size(n);
                }
            }
            /// Truncates history to the only the most recent `n` entries.
            ///
            /// This method internally acquires the `Interface` write lock.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn truncate_history(&self, n: usize) {
                if !self.lock.is_active() {
                    self.iface.lock_write().truncate_history(n);
                }
            }
            /// Returns the application name
            pub fn application(&self) -> &str {
                &self.lock.application
            }
            /// Sets the application name
            pub fn set_application<T>(&mut self, application: T)
                    where T: Into<Cow<'static, str>> {
                self.lock.application = application.into();
            }
            /// Returns a reference to the current completer instance.
            pub fn completer(&self) -> &Arc<dyn Completer<Term>> {
                &self.lock.completer
            }
            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer(&mut self, completer: Arc<dyn Completer<Term>>)
                    -> Arc<dyn Completer<Term>> {
                replace(&mut self.lock.completer, completer)
            }
            /// Returns the value of the named variable or `None`
            /// if no such variable exists.
            pub fn get_variable(&self, name: &str) -> Option<Variable> {
                self.lock.get_variable(name)
            }
            /// Sets the value of the named variable and returns the previous
            /// value.
            ///
            /// If `name` does not refer to a variable or the `value` is not
            /// a valid value for the variable, `None` is returned.
            pub fn set_variable(&mut self, name: &str, value: &str) -> Option<Variable> {
                self.lock.set_variable(name, value)
            }
            /// Returns an iterator over stored variables.
            pub fn variables(&self) -> VariableIter {
                self.lock.variables.iter()
            }
            /// Returns whether to "blink" matching opening parenthesis character
            /// when a closing parenthesis character is entered.
            ///
            /// The default value is `false`.
            pub fn blink_matching_paren(&self) -> bool {
                self.lock.blink_matching_paren
            }
            /// Sets the `blink-matching-paren` variable.
            pub fn set_blink_matching_paren(&mut self, set: bool) {
                self.lock.blink_matching_paren = set;
            }
            /// Returns whether `lineread` will catch certain signals.
            pub fn catch_signals(&self) -> bool {
                self.lock.catch_signals
            }
            /// Sets whether `lineread` will catch certain signals.
            ///
            /// This setting is `true` by default. It can be disabled to allow the
            /// host program to handle signals itself.
            pub fn set_catch_signals(&mut self, enabled: bool) {
                self.lock.catch_signals = enabled;
            }
            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal(&self, signal: Signal) -> bool {
                self.lock.ignore_signals.contains(signal)
            }
            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal(&mut self, signal: Signal, set: bool) {
                if set {
                    self.lock.ignore_signals.insert(signal);
                    self.lock.report_signals.remove(signal);
                } else {
                    self.lock.ignore_signals.remove(signal);
                }
            }
            /// Returns whether the given `Signal` is to be reported.
            pub fn report_signal(&self, signal: Signal) -> bool {
                self.lock.report_signals.contains(signal)
            }
            /// Sets whether to report the given `Signal`.
            ///
            /// When a reported signal is received via the terminal, it will be returned
            /// from `Interface::read_line` as `Ok(Signal(signal))`.
            pub fn set_report_signal(&mut self, signal: Signal, set: bool) {
                if set {
                    self.lock.report_signals.insert(signal);
                    self.lock.ignore_signals.remove(signal);
                } else {
                    self.lock.report_signals.remove(signal);
                }
            }
            /// Returns whether Tab completion is disabled.
            ///
            /// The default value is `false`.
            pub fn disable_completion(&self) -> bool {
                self.lock.disable_completion
            }
            /// Sets the `disable-completion` variable.
            pub fn set_disable_completion(&mut self, disable: bool) {
                self.lock.disable_completion = disable;
            }
            /// When certain control characters are pressed, a character sequence
            /// equivalent to this character will be echoed.
            ///
            /// The default value is `true`.
            pub fn echo_control_characters(&self) -> bool {
                self.lock.echo_control_characters
            }
            /// Sets the `echo-control-characters` variable.
            pub fn set_echo_control_characters(&mut self, echo: bool) {
                self.lock.echo_control_characters = echo;
            }
            /// Returns the character, if any, that is appended to a successful completion.
            pub fn completion_append_character(&self) -> Option<char> {
                self.lock.completion_append_character
            }
            /// Sets the character, if any, that is appended to a successful completion.
            pub fn set_completion_append_character(&mut self, ch: Option<char>) {
                self.lock.completion_append_character = ch;
            }
            /// Returns the width of completion listing display.
            ///
            /// If this value is greater than the terminal width, terminal width is used
            /// instead.
            ///
            /// The default value is equal to `usize::max_value()`.
            pub fn completion_display_width(&self) -> usize {
                self.lock.completion_display_width
            }
            /// Sets the `completion-display-width` variable.
            pub fn set_completion_display_width(&mut self, n: usize) {
                self.lock.completion_display_width = n;
            }
            /// Returns the minimum number of completion items that require user
            /// confirmation before listing.
            ///
            /// The default value is `100`.
            pub fn completion_query_items(&self) -> usize {
                self.lock.completion_query_items
            }
            /// Sets the `completion-query-items` variable.
            pub fn set_completion_query_items(&mut self, n: usize) {
                self.lock.completion_query_items = n;
            }
            /// Returns the timeout to wait for further user input when an ambiguous
            /// sequence has been entered. If the value is `None`, wait is indefinite.
            ///
            /// The default value 500 milliseconds.
            pub fn keyseq_timeout(&self) -> Option<Duration> {
                self.lock.keyseq_timeout
            }
            /// Sets the `keyseq-timeout` variable.
            pub fn set_keyseq_timeout(&mut self, timeout: Option<Duration>) {
                self.lock.keyseq_timeout = timeout;
            }
            /// Returns whether to list possible completions one page at a time.
            ///
            /// The default value is `true`.
            pub fn page_completions(&self) -> bool {
                self.lock.page_completions
            }
            /// Sets the `page-completions` variable.
            pub fn set_page_completions(&mut self, set: bool) {
                self.lock.page_completions = set;
            }
            /// Returns whether to list completions horizontally, rather than down
            /// the screen.
            ///
            /// The default value is `false`.
            pub fn print_completions_horizontally(&self) -> bool {
                self.lock.print_completions_horizontally
            }
            /// Sets the `print-completions-horizontally` variable.
            pub fn set_print_completions_horizontally(&mut self, set: bool) {
                self.lock.print_completions_horizontally = set;
            }
            /// Returns the set of characters that delimit strings.
            pub fn string_chars(&self) -> &str {
                &self.lock.string_chars
            }
            /// Sets the set of characters that delimit strings.
            pub fn set_string_chars<T>(&mut self, chars: T)
                    where T: Into<Cow<'static, str>> {
                self.lock.string_chars = chars.into();
            }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars(&self) -> &str {
                &self.lock.word_break
            }
            /// Sets the set of characters that indicate a word break.
            pub fn set_word_break_chars<T>(&mut self, chars: T)
                    where T: Into<Cow<'static, str>> {
                self.lock.word_break = chars.into();
            }
            /// Returns an iterator over bound sequences
            pub fn bindings(&self) -> BindingIter {
                self.lock.bindings()
            }
            /// Binds a sequence to a command.
            ///
            /// Returns the previously bound command.
            pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.lock.bind_sequence(seq, cmd)
            }
            /// Binds a sequence to a command, if and only if the given sequence
            /// is not already bound to a command.
            ///
            /// Returns `true` if a new binding was created.
            pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                self.lock.bind_sequence_if_unbound(seq, cmd)
            }
            /// Removes a binding for the given sequence.
            ///
            /// Returns the previously bound command.
            pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
                self.lock.unbind_sequence(seq)
            }
            /// Defines a named function to which sequences may be bound.
            ///
            /// The name should consist of lowercase ASCII letters and numbers,
            /// containing no spaces, with words separated by hyphens. However,
            /// this is not a requirement.
            ///
            /// Returns the function previously defined with the same name.
            pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.lock.define_function(name, cmd)
            }
            /// Removes a function defined with the given name.
            ///
            /// Returns the defined function.
            pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.lock.remove_function(name)
            }

            pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
                self.lock.data.evaluate_directives(term, dirs)
            }

            pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
                self.lock.data.evaluate_directive(term, dir)
            }

            fn prompter<'b>(&'b mut self) -> Prompter<'b, 'a, Term> {
                Prompter::new(
                    &mut self.lock,
                    self.iface.lock_write())
            }

            fn handle_resize(&mut self, size: Size) -> io::Result<()> {
                self.prompter().handle_resize(size)
            }

            fn handle_signal(&mut self, sig: Signal) -> io::Result<()> {
                self.prompter().handle_signal(sig)
            }
        }

        impl<'a, Term: 'a + Terminal> ReadLock<'a, Term> {
            pub fn new(term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>>)
                    -> ReadLock<'a, Term> {
                ReadLock{term, data}
            }
            /// Reads the next character of input.
            ///
            /// Performs a non-blocking read from the terminal, if necessary.
            ///
            /// If non-input data was received (e.g. a signal) or insufficient input
            /// is available, `Ok(None)` is returned.
            pub fn read_char(&mut self) -> io::Result<Option<char>> {
                if let Some(ch) = self.macro_pop() {
                    Ok(Some(ch))
                } else if let Some(ch) = self.decode_input()? {
                    Ok(Some(ch))
                } else {
                    Ok(None)
                }
            }

            fn read_input(&mut self) -> io::Result<()> {
                match self.term.read(&mut self.data.input_buffer)? {
                    RawRead::Bytes(_) => (),
                    RawRead::Resize(new_size) => {
                        self.last_resize = Some(new_size);
                    }
                    RawRead::Signal(sig) => {
                        self.last_signal = Some(sig);
                    }
                }

                Ok(())
            }

            fn is_input_available(&self) -> bool {
                !self.data.macro_buffer.is_empty() || match self.peek_input() {
                    Ok(Some(_)) | Err(_) => true,
                    Ok(None) => false
                }
            }

            fn macro_pop(&mut self) -> Option<char> {
                if self.data.macro_buffer.is_empty() {
                    None
                } else {
                    Some(self.data.macro_buffer.remove(0))
                }
            }

            fn decode_input(&mut self) -> io::Result<Option<char>> {
                let res = self.peek_input();

                if let Ok(Some(ch)) = res {
                    self.data.input_buffer.drain(..ch.len_utf8());
                }

                res
            }

            fn peek_input(&self) -> io::Result<Option<char>> {
                if self.data.input_buffer.is_empty() {
                    Ok(None)
                } else {
                    first_char(&self.data.input_buffer)
                }
            }

            pub fn reset_data(&mut self) {
                self.data.reset_data();
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for ReadLock<'a, Term> {
            type Target = Read<Term>;

            fn deref(&self) -> &Read<Term> {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for ReadLock<'a, Term> {
            fn deref_mut(&mut self) -> &mut Read<Term> {
                &mut self.data
            }
        }

        impl<Term: Terminal> Deref for Read<Term> {
            type Target = Variables;

            fn deref(&self) -> &Variables {
                &self.variables
            }
        }

        impl<Term: Terminal> DerefMut for Read<Term> {
            fn deref_mut(&mut self) -> &mut Variables {
                &mut self.variables
            }
        }

        impl<Term: Terminal> Read<Term> {
            pub fn new(term: &Term, application: Cow<'static, str>) -> Read<Term> {
                let mut r = Read{
                    application,

                    bindings: default_bindings(),
                    functions: HashMap::new(),

                    input_buffer: Vec::new(),
                    macro_buffer: String::new(),

                    sequence: String::new(),
                    input_accepted: false,

                    overwrite_mode: false,
                    overwritten_append: 0,
                    overwritten_chars: String::new(),

                    completer: Arc::new(DummyCompleter),
                    completion_append_character: Some(' '),
                    completions: None,
                    completion_index: 0,
                    completion_start: 0,
                    completion_prefix: 0,

                    string_chars: STRING_CHARS.into(),
                    word_break: WORD_BREAK_CHARS.into(),

                    last_cmd: Category::Other,
                    last_yank: None,
                    kill_ring: VecDeque::with_capacity(MAX_KILLS),

                    catch_signals: true,
                    ignore_signals: SignalSet::new(),
                    report_signals: SignalSet::new(),
                    last_resize: None,
                    last_signal: None,

                    variables: Variables::default(),

                    state: InputState::Inactive,
                    max_wait_duration: None,
                };

                r.read_init(term);
                r
            }

            pub fn bindings(&self) -> BindingIter {
                BindingIter(self.bindings.sequences().iter())
            }

            pub fn variables(&self) -> VariableIter {
                self.variables.iter()
            }

            fn take_resize(&mut self) -> Option<Size> {
                self.last_resize.take()
            }

            fn take_signal(&mut self) -> Option<Signal> {
                self.last_signal.take()
            }

            pub fn queue_input(&mut self, seq: &str) {
                self.macro_buffer.insert_str(0, seq);
            }

            pub fn is_active(&self) -> bool {
                match self.state {
                    InputState::Inactive => false,
                    _ => true
                }
            }

            pub fn reset_data(&mut self) {
                self.state = InputState::NewSequence;
                self.input_accepted = false;
                self.overwrite_mode = false;
                self.overwritten_append = 0;
                self.overwritten_chars.clear();
                self.sequence.clear();

                self.completions = None;

                self.last_cmd = Category::Other;
                self.last_yank = None;

                self.last_resize = None;
                self.last_signal = None;
            }

            pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.bindings.insert(seq.into(), cmd)
            }

            pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                use mortal::sequence::Entry;

                match self.bindings.entry(seq.into()) {
                    Entry::Occupied(_) => false,
                    Entry::Vacant(ent) => {
                        ent.insert(cmd);
                        true
                    }
                }
            }

            pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
                self.bindings.remove(seq)
                    .map(|(_, cmd)| cmd)
            }

            pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.functions.insert(name.into(), cmd)
            }

            pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.functions.remove(name)
            }

            fn read_init(&mut self, term: &Term) {
                if let Some(path) = env_init_file() {
                    // If `INPUTRC` is present, even if invalid, parse nothing else.
                    // Thus, an empty `INPUTRC` will inhibit loading configuration.
                    self.read_init_file_if_exists(term, Some(path));
                } else {
                    if !self.read_init_file_if_exists(term, user_init_file()) {
                        self.read_init_file_if_exists(term, system_init_file());
                    }
                }
            }

            fn read_init_file_if_exists(&mut self, term: &Term, path: Option<PathBuf>) -> bool {
                match path {
                    Some(ref path) if path.exists() => {
                        self.read_init_file(term, path);
                        true
                    }
                    _ => false
                }
            }

            fn read_init_file(&mut self, term: &Term, path: &Path) {
                if let Some(dirs) = parse_file(path) {
                    self.evaluate_directives(term, dirs);
                }
            }
            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
                for dir in dirs {
                    self.evaluate_directive(term, dir);
                }
            }
            /// Evaluates a single configuration directive.
            pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
                match dir {
                    Directive::Bind(seq, cmd) => {
                        self.bind_sequence(seq, cmd);
                    }
                    Directive::Conditional{name, value, then_group, else_group} => {
                        let name = name.as_ref().map(|s| &s[..]);

                        if self.eval_condition(term, name, &value) {
                            self.evaluate_directives(term, then_group);
                        } else {
                            self.evaluate_directives(term, else_group);
                        }
                    }
                    Directive::SetVariable(name, value) => {
                        self.set_variable(&name, &value);
                    }
                }
            }

            fn eval_condition(&self, term: &Term, name: Option<&str>, value: &str) -> bool {
                match name {
                    None => self.application == value,
                    Some("lib") => value == "lineread",
                    Some("mode") => value == "emacs",
                    Some("term") => self.term_matches(term, value),
                    _ => false
                }
            }

            fn term_matches(&self, term: &Term, value: &str) -> bool {
                match_name(term.name(), value)
            }
        }
        /// Iterator over `Reader` bindings
        pub struct BindingIter<'a>(slice::Iter<'a, (Cow<'static, str>, Command)>);

        impl<'a> ExactSizeIterator for BindingIter<'a> {}

        impl<'a> Iterator for BindingIter<'a> {
            type Item = (&'a str, &'a Command);

            #[inline]
            fn next(&mut self) -> Option<Self::Item> {
                self.0.next().map(|&(ref s, ref cmd)| (&s[..], cmd))
            }

            #[inline]
            fn nth(&mut self, n: usize) -> Option<Self::Item> {
                self.0.nth(n).map(|&(ref s, ref cmd)| (&s[..], cmd))
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.0.size_hint()
            }
        }

        impl<'a> DoubleEndedIterator for BindingIter<'a> {
            #[inline]
            fn next_back(&mut self) -> Option<Self::Item> {
                self.0.next_back().map(|&(ref s, ref cmd)| (&s[..], cmd))
            }
        }

        fn default_bindings() -> SequenceMap<Cow<'static, str>, Command> {
            use crate::command::Command::*;

            SequenceMap::from(vec![
                // Carriage return and line feed
                ("\r".into(), AcceptLine),
                ("\n".into(), AcceptLine),

                // Possible sequences for arrow keys, Home, End
                ("\x1b[A".into(), PreviousHistory),
                ("\x1b[B".into(), NextHistory),
                ("\x1b[C".into(), ForwardChar),
                ("\x1b[D".into(), BackwardChar),
                ("\x1b[H".into(), BeginningOfLine),
                ("\x1b[F".into(), EndOfLine),

                // More possible sequences for arrow keys, Home, End
                ("\x1bOA".into(), PreviousHistory),
                ("\x1bOB".into(), NextHistory),
                ("\x1bOC".into(), ForwardChar),
                ("\x1bOD".into(), BackwardChar),
                ("\x1bOH".into(), BeginningOfLine),
                ("\x1bOF".into(), EndOfLine),

                // Possible sequences for Insert, Delete
                ("\x1b[2~".into(), OverwriteMode),
                ("\x1b[3~".into(), DeleteChar),

                // Basic commands
                ("\x01"    .into(), BeginningOfLine),           // Ctrl-A
                ("\x02"    .into(), BackwardChar),              // Ctrl-B
                ("\x04"    .into(), DeleteChar),                // Ctrl-D
                ("\x05"    .into(), EndOfLine),                 // Ctrl-E
                ("\x06"    .into(), ForwardChar),               // Ctrl-F
                ("\x07"    .into(), Abort),                     // Ctrl-G
                ("\x08"    .into(), BackwardDeleteChar),        // Ctrl-H
                ("\x0b"    .into(), KillLine),                  // Ctrl-K
                ("\x0c"    .into(), ClearScreen),               // Ctrl-L
                ("\x0e"    .into(), NextHistory),               // Ctrl-N
                ("\x10"    .into(), PreviousHistory),           // Ctrl-P
                ("\x12"    .into(), ReverseSearchHistory),      // Ctrl-R
                ("\x14"    .into(), TransposeChars),            // Ctrl-T
                ("\x15"    .into(), BackwardKillLine),          // Ctrl-U
                ("\x16"    .into(), QuotedInsert),              // Ctrl-V
                ("\x17"    .into(), UnixWordRubout),            // Ctrl-W
                ("\x19"    .into(), Yank),                      // Ctrl-Y
                ("\x1d"    .into(), CharacterSearch),           // Ctrl-]
                ("\x7f"    .into(), BackwardDeleteChar),        // Rubout
                ("\x1b\x08".into(), BackwardKillWord),          // Escape, Ctrl-H
                ("\x1b\x1d".into(), CharacterSearchBackward),   // Escape, Ctrl-]
                ("\x1b\x7f".into(), BackwardKillWord),          // Escape, Rubout
                ("\x1bb"   .into(), BackwardWord),              // Escape, b
                ("\x1bd"   .into(), KillWord),                  // Escape, d
                ("\x1bf"   .into(), ForwardWord),               // Escape, f
                ("\x1bt"   .into(), TransposeWords),            // Escape, t
                ("\x1by"   .into(), YankPop),                   // Escape, y
                ("\x1b#"   .into(), InsertComment),             // Escape, #
                ("\x1b<"   .into(), BeginningOfHistory),        // Escape, <
                ("\x1b>"   .into(), EndOfHistory),              // Escape, >

                // Completion commands
                ("\t"   .into(), Complete),             // Tab
                ("\x1b?".into(), PossibleCompletions),  // Escape, ?
                ("\x1b*".into(), InsertCompletions),    // Escape, *

                // Digit commands
                ("\x1b-".into(), DigitArgument),    // Escape, -
                ("\x1b0".into(), DigitArgument),    // Escape, 0
                ("\x1b1".into(), DigitArgument),    // Escape, 1
                ("\x1b2".into(), DigitArgument),    // Escape, 2
                ("\x1b3".into(), DigitArgument),    // Escape, 3
                ("\x1b4".into(), DigitArgument),    // Escape, 4
                ("\x1b5".into(), DigitArgument),    // Escape, 5
                ("\x1b6".into(), DigitArgument),    // Escape, 6
                ("\x1b7".into(), DigitArgument),    // Escape, 7
                ("\x1b8".into(), DigitArgument),    // Escape, 8
                ("\x1b9".into(), DigitArgument),    // Escape, 9
            ])
        }

        fn limit_duration(dur: Option<Duration>, max: Option<Duration>) -> Option<Duration> {
            match (dur, max) {
                (dur, None) | (None, dur) => dur,
                (Some(dur), Some(max)) => Some(dur.min(max)),
            }
        }
    }

    pub mod table
    {
        //! Provides utilities for formatting strings in a table
        use ::
        {
            *,
        };
        

        use std::cmp::min;

        const COL_SPACE: usize = 2;

        /// Represents a table of strings, formatted into rows and columns
        ///
        /// A `Table` is an `Iterator` yielding `Line` elements, which are in turn
        /// iterators yielding `(usize, &str)` elements, describing the width and content
        /// of each cell in a given row.
        pub struct Table<'a, S: 'a> {
            strings: &'a [S],
            sizes: Option<&'a [usize]>,
            offset: usize,
            per_col: usize,
            rows: usize,
            horizontal: bool,
        }

        impl<'a, S: 'a + AsRef<str>> Table<'a, S> {
            /// Constructs a new table from the given set of strings, using the given column sizes.
            pub fn new(strs: &'a [S], mut sizes: Option<&'a [usize]>,
                    horizontal: bool) -> Table<'a, S> {
                if let Some(sz) = sizes {
                    if sz.is_empty() {
                        sizes = None;
                    }
                }

                let n_strs = strs.len();
                let n_cols = sizes.map_or(1, |sz| sz.len());

                let rows = n_strs / n_cols + (n_strs % n_cols != 0) as usize;

                Table{
                    strings: strs,
                    sizes: sizes,
                    offset: 0,
                    per_col: (strs.len() + (n_cols - 1)) / n_cols,
                    rows: rows,
                    horizontal: horizontal,
                }
            }
            /// Returns whether more lines are present in the table.
            pub fn has_more(&self) -> bool {
                self.offset < self.rows
            }

            fn num_cols(&self) -> usize {
                self.sizes.map_or(1, |sz| sz.len())
            }
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Table<'a, S> {
            type Item = Line<'a, S>;

            fn next(&mut self) -> Option<Line<'a, S>> {
                if self.offset == self.rows {
                    return None;
                }

                let n = self.num_cols();

                let (start, end, stride) = if self.horizontal {
                    let start = self.offset * n;
                    let end = min(self.strings.len(), start + n);
                    (start, end, 1)
                } else {
                    let start = self.offset;
                    let end = min(self.strings.len(), start + self.per_col * n);
                    (start, end, self.per_col)
                };

                self.offset += 1;

                Some(Line{
                    strings: &self.strings[start..end],
                    sizes: self.sizes,
                    stride: stride,
                    offset: 0,
                })
            }
        }
        /// Represents a single line of the table.
        pub struct Line<'a, S: 'a> {
            strings: &'a [S],
            sizes: Option<&'a [usize]>,
            stride: usize,
            offset: usize,
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Line<'a, S> {
            type Item = (usize, &'a str);

            fn next(&mut self) -> Option<(usize, &'a str)> {
                let s = self.strings.get(self.offset * self.stride)?.as_ref();

                let width = self.sizes.and_then(|sz| sz.get(self.offset).cloned())
                    .unwrap_or_else(|| s.chars().count());

                self.offset += 1;

                Some((width, s))
            }
        }
        /// Formats a series of strings into columns, fitting within a given screen width.
        /// Returns the size of each resulting column, including spacing.
        pub fn format_columns<S: AsRef<str>>(strs: &[S], screen_width: usize,
                horizontal: bool) -> Option<Vec<usize>> {
            if strs.is_empty() {
                return None;
            }

            let n_strs = strs.len();

            let (mut min_len, mut max_len) = min_max(strs.iter().map(|s| s.as_ref().chars().count()));

            if min_len == 0 { min_len = 1; }
            if max_len == 0 { max_len = 1; }

            let mut min_cols = min(n_strs, screen_width / max_len);
            let max_cols = min(n_strs, screen_width / min_len);

            if min_cols <= 1 {
                // No point in checking whether text can fit within one column
                min_cols = 2;
            }

            if max_cols <= 1 {
                return None;
            }

            let mut col_sizes = if min_cols == max_cols {
                vec![vec![0; max_cols]]
            } else {
                (min_cols..max_cols + 1)
                    .map(|n| vec![0; n]).collect::<Vec<_>>()
            };

            for (i, s) in strs.iter().enumerate() {
                let len = s.as_ref().chars().count();

                for cols in &mut col_sizes {
                    let n_cols = cols.len();

                    let col = if horizontal {
                        i % n_cols
                    } else {
                        let per_col = (n_strs + (n_cols - 1)) / n_cols;
                        i / per_col
                    };

                    let real_len = if col == n_cols - 1 { len } else { len + COL_SPACE };

                    if real_len > cols[col] {
                        cols[col] = real_len;
                    }
                }
            }

            for cols in col_sizes.into_iter().rev() {
                if cols.iter().fold(0, |a, b| a + b) <= screen_width {
                    return Some(cols);
                }
            }

            None
        }

        fn min_max<I>(iter: I) -> (usize, usize) where I: Iterator<Item=usize> {
            let mut min = usize::max_value();
            let mut max = 0;

            for n in iter {
                if n < min {
                    min = n;
                }
                if n + COL_SPACE > max {
                    max = n + COL_SPACE;
                }
            }

            (min, max)
        }
    }

    pub mod terminal
    {
        //! Provides a low-level terminal interface
        use ::
        {
            *,
        };
        

        use std::io;
        use std::time::Duration;

        use mortal::{self, PrepareConfig, PrepareState, TerminalReadGuard, TerminalWriteGuard};
        use crate::sys;

        pub use mortal::{CursorMode, Signal, SignalSet, Size};

        /// Default `Terminal` interface
        pub struct DefaultTerminal(mortal::Terminal);

        /// Represents the result of a `Terminal` read operation
        pub enum RawRead {
            /// `n` bytes were read from the device
            Bytes(usize),
            /// The terminal window was resized
            Resize(Size),
            /// A signal was received while waiting for input
            Signal(Signal),
        }
        /// Defines a low-level interface to the terminal
        pub trait Terminal: Sized + Send + Sync {
            // TODO: When generic associated types are implemented (and stabilized),
            // boxed trait objects may be replaced by `Reader` and `Writer`.
            /// Returned by `prepare`; passed to `restore` to restore state.
            type PrepareState;
            /*
            /// Holds an exclusive read lock and provides read operations
            type Reader: TerminalReader;
            /// Holds an exclusive write lock and provides write operations
            type Writer: TerminalWriter;
            */

            /// Returns the name of the terminal.
            fn name(&self) -> &str;

            /// Acquires a lock on terminal read operations and returns a value holding
            /// that lock and granting access to such operations.
            ///
            /// The lock must not be released until the returned value is dropped.
            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a>;

            /// Acquires a lock on terminal write operations and returns a value holding
            /// that lock and granting access to such operations.
            ///
            /// The lock must not be released until the returned value is dropped.
            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a>;
        }
        /// Holds a lock on `Terminal` read operations
        pub trait TerminalReader<Term: Terminal> {
            /// Prepares the terminal for line reading and editing operations.
            ///
            /// If `block_signals` is `true`, the terminal will be configured to treat
            /// special characters that would otherwise be interpreted as signals as
            /// their literal value.
            ///
            /// If `block_signals` is `false`, a signal contained in the `report_signals`
            /// set may be returned.
            ///
            /// # Notes
            ///
            /// This method may be called more than once. However, if the state values
            /// are not restored in reverse order in which they were created,
            /// the state of the underlying terminal device becomes undefined.
            fn prepare(&mut self, block_signals: bool, report_signals: SignalSet)
                -> io::Result<Term::PrepareState>;

            /// Like `prepare`, but called when the write lock is already held.
            ///
            /// # Safety
            ///
            /// This method must be called with a `TerminalWriter` instance returned
            /// by the same `Terminal` instance to which this `TerminalReader` belongs.
            unsafe fn prepare_with_lock(&mut self, lock: &mut dyn TerminalWriter<Term>,
                    block_signals: bool, report_signals: SignalSet)
                    -> io::Result<Term::PrepareState>;

            /// Restores the terminal state using the given state data.
            fn restore(&mut self, state: Term::PrepareState) -> io::Result<()>;

            /// Like `restore`, but called when the write lock is already held.
            ///
            /// # Safety
            ///
            /// This method must be called with a `TerminalWriter` instance returned
            /// by the same `Terminal` instance to which this `TerminalReader` belongs.
            unsafe fn restore_with_lock(&mut self, lock: &mut dyn TerminalWriter<Term>,
                    state: Term::PrepareState) -> io::Result<()>;

            /// Reads some input from the terminal and appends it to the given buffer.
            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead>;

            /// Waits `timeout` for user input. If `timeout` is `None`, waits indefinitely.
            ///
            /// Returns `Ok(true)` if input becomes available within the given timeout
            /// or if a signal is received.
            ///
            /// Returns `Ok(false)` if the timeout expires before input becomes available.
            fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool>;
        }
        /// Holds a lock on `Terminal` write operations
        pub trait TerminalWriter<Term: Terminal> {
            /// Returns the size of the terminal window
            fn size(&self) -> io::Result<Size>;

            /// Presents a clear terminal screen, with cursor at first row, first column.
            ///
            /// If the terminal possesses a scrolling window over a buffer, this shall
            /// have the effect of moving the visible window down such that it shows
            /// an empty view of the buffer, preserving some or all of existing buffer
            /// contents, where possible.
            fn clear_screen(&mut self) -> io::Result<()>;

            /// Clears characters on the line occupied by the cursor, beginning with the
            /// cursor and ending at the end of the line. Also clears all characters on
            /// all lines after the cursor.
            fn clear_to_screen_end(&mut self) -> io::Result<()>;

            /// Moves the cursor up `n` cells; `n` may be zero.
            fn move_up(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor down `n` cells; `n` may be zero.
            fn move_down(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor left `n` cells; `n` may be zero.
            fn move_left(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor right `n` cells; `n` may be zero.
            fn move_right(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor to the first column of the current line
            fn move_to_first_column(&mut self) -> io::Result<()>;

            /// Set the current cursor mode
            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>;

            /// Writes output to the terminal.
            ///
            /// For each carriage return `'\r'` written to the terminal, the cursor
            /// should be moved to the first column of the current line.
            ///
            /// For each newline `'\n'` written to the terminal, the cursor should
            /// be moved to the first column of the following line.
            ///
            /// The terminal interface shall not automatically move the cursor to the next
            /// line when `write` causes a character to be written to the final column.
            fn write(&mut self, s: &str) -> io::Result<()>;

            /// Flushes any currently buffered output data.
            ///
            /// `TerminalWriter` instances may not buffer data on all systems.
            ///
            /// Data must be flushed when the `TerminalWriter` instance is dropped.
            fn flush(&mut self) -> io::Result<()>;
        }

        impl DefaultTerminal {
            /// Opens access to the terminal device associated with standard output.
            pub fn new() -> io::Result<DefaultTerminal> {
                mortal::Terminal::new().map(DefaultTerminal)
            }
            /// Opens access to the terminal device associated with standard error.
            pub fn stderr() -> io::Result<DefaultTerminal> {
                mortal::Terminal::stderr().map(DefaultTerminal)
            }

            unsafe fn cast_writer<'a>(writer: &'a mut dyn TerminalWriter<Self>)
                    -> &'a mut TerminalWriteGuard<'a> {
                &mut *(writer as *mut _ as *mut TerminalWriteGuard)
            }
        }

        impl Terminal for DefaultTerminal {
            type PrepareState = PrepareState;

            fn name(&self) -> &str {
                self.0.name()
            }

            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a> {
                Box::new(self.0.lock_read().unwrap())
            }

            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a> {
                Box::new(self.0.lock_write().unwrap())
            }
        }

        impl<'a> TerminalReader<DefaultTerminal> for TerminalReadGuard<'a> {
            fn prepare(&mut self, block_signals: bool, report_signals: SignalSet)
                    -> io::Result<PrepareState> {
                self.prepare(PrepareConfig{
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                })
            }

            unsafe fn prepare_with_lock(&mut self,
                    lock: &mut dyn TerminalWriter<DefaultTerminal>,
                    block_signals: bool, report_signals: SignalSet)
                    -> io::Result<PrepareState> {
                let lock = DefaultTerminal::cast_writer(lock);

                self.prepare_with_lock(lock, PrepareConfig{
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                })
            }

            fn restore(&mut self, state: PrepareState) -> io::Result<()> {
                self.restore(state)
            }

            unsafe fn restore_with_lock(&mut self,
                    lock: &mut dyn TerminalWriter<DefaultTerminal>, state: PrepareState)
                    -> io::Result<()> {
                let lock = DefaultTerminal::cast_writer(lock);
                self.restore_with_lock(lock, state)
            }

            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead> {
                sys::terminal_read(self, buf)
            }

            fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                self.wait_event(timeout)
            }

        }

        impl<'a> TerminalWriter<DefaultTerminal> for TerminalWriteGuard<'a> {
            fn size(&self) -> io::Result<Size> {
                self.size()
            }

            fn clear_screen(&mut self) -> io::Result<()> {
                self.clear_screen()
            }

            fn clear_to_screen_end(&mut self) -> io::Result<()> {
                self.clear_to_screen_end()
            }

            fn move_up(&mut self, n: usize) -> io::Result<()> {
                self.move_up(n)
            }
            fn move_down(&mut self, n: usize) -> io::Result<()> {
                self.move_down(n)
            }
            fn move_left(&mut self, n: usize) -> io::Result<()> {
                self.move_left(n)
            }
            fn move_right(&mut self, n: usize) -> io::Result<()> {
                self.move_right(n)
            }

            fn move_to_first_column(&mut self) -> io::Result<()> {
                self.move_to_first_column()
            }

            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.set_cursor_mode(mode)
            }

            fn write(&mut self, s: &str) -> io::Result<()> {
                self.write_str(s)
            }

            fn flush(&mut self) -> io::Result<()> {
                self.flush()
            }
        }
    }

    pub mod util
    {
        //! Provides miscellaneous utilities
        use ::
        {
            *,
        };
        

        use std::borrow::Cow;
        use std::io;
        use std::ops::{Range, RangeFrom, RangeFull, RangeTo};
        use std::str::{from_utf8, from_utf8_unchecked};

        pub fn filter_visible(s: &str) -> Cow<str> {
            use crate::reader::{START_INVISIBLE, END_INVISIBLE};

            if !s.contains(START_INVISIBLE) {
                return Cow::Borrowed(s);
            }

            let mut virt = String::new();
            let mut ignore = false;

            for ch in s.chars() {
                if ch == START_INVISIBLE {
                    ignore = true;
                } else if ch == END_INVISIBLE {
                    ignore = false;
                } else if !ignore {
                    virt.push(ch);
                }
            }

            Cow::Owned(virt)
        }
        /// Returns the longest common prefix of a set of strings.
        ///
        /// If no common prefix exists, `None` is returned.
        pub fn longest_common_prefix<'a, I, S>(iter: I) -> Option<&'a str> where
                I: IntoIterator<Item=&'a S>,
                S: 'a + ?Sized + AsRef<str>,
                {
            let mut iter = iter.into_iter();

            let mut pfx = iter.next()?.as_ref();

            for s in iter {
                let s = s.as_ref();

                let n = pfx.chars().zip(s.chars())
                    .take_while(|&(a, b)| a == b)
                    .map(|(ch, _)| ch.len_utf8()).sum();

                if n == 0 {
                    return None;
                } else {
                    pfx = &pfx[..n];
                }
            }

            Some(pfx)
        }
        /// Returns a string consisting of a `char`, repeated `n` times.
        pub fn repeat_char(ch: char, n: usize) -> String {
            let mut buf = [0; 4];
            let s = ch.encode_utf8(&mut buf);

            s.repeat(n)
        }
        /// Implemented for built-in range types
        // Waiting for stabilization of `std` trait of the same name
        pub trait RangeArgument<T> {
            /// Returns the start of range, if present.
            fn start(&self) -> Option<&T> { None }
            /// Returns the end of range, if present.
            fn end(&self) -> Option<&T> { None }
        }

        impl<T> RangeArgument<T> for Range<T> {
            fn start(&self) -> Option<&T> { Some(&self.start) }

            fn end(&self) -> Option<&T> { Some(&self.end) }
        }

        impl<T> RangeArgument<T> for RangeFrom<T> {
            fn start(&self) -> Option<&T> { Some(&self.start) }
        }

        impl<T> RangeArgument<T> for RangeTo<T> {
            fn end(&self) -> Option<&T> { Some(&self.end) }
        }

        impl<T> RangeArgument<T> for RangeFull {}

        pub fn backward_char(n: usize, s: &str, cur: usize) -> usize {
            let mut chars = s[..cur].char_indices()
                .filter(|&(_, ch)| !is_combining_mark(ch));
            let mut res = cur;

            for _ in 0..n {
                match chars.next_back() {
                    Some((idx, _)) => res = idx,
                    None => return 0
                }
            }

            res
        }

        pub fn forward_char(n: usize, s: &str, cur: usize) -> usize {
            let mut chars = s[cur..].char_indices()
                .filter(|&(_, ch)| !is_combining_mark(ch));

            for _ in 0..n {
                match chars.next() {
                    Some(_) => (),
                    None => return s.len()
                }
            }

            match chars.next() {
                Some((idx, _)) => cur + idx,
                None => s.len()
            }
        }

        pub fn backward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize> {
            let mut pos = None;

            for _ in 0..n {
                match buf[..cur].rfind(ch) {
                    Some(p) => {
                        cur = p;
                        pos = Some(cur);
                    }
                    None => break
                }
            }

            pos
        }

        pub fn forward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize> {
            let mut pos = None;

            for _ in 0..n {
                // Skip past the character under the cursor
                let off = match buf[cur..].chars().next() {
                    Some(ch) => ch.len_utf8(),
                    None => break
                };

                match buf[cur + off..].find(ch) {
                    Some(p) => {
                        cur += off + p;
                        pos = Some(cur);
                    }
                    None => break
                }
            }

            pos
        }

        pub fn backward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize {
            let mut chars = buf[..cur].char_indices().rev();

            for _ in 0..n {
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
            }

            match chars.next() {
                Some((ind, ch)) => ind + ch.len_utf8(),
                None => 0
            }
        }

        pub fn forward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize {
            let mut chars = buf[cur..].char_indices();

            for _ in 0..n {
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
            }

            match chars.next() {
                Some((ind, _)) => cur + ind,
                None => buf.len()
            }
        }

        pub fn back_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize> {
            let prev = backward_word(1, buf, cur, word_break);
            let end = word_end(&buf, prev, word_break);

            if n > 1 {
                let start = backward_word(n - 1, buf, prev, word_break);
                start..end
            } else {
                prev..end
            }
        }

        pub fn forward_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize> {
            let start = next_word(1, buf, cur, word_break);

            if n > 1 {
                let last = next_word(n - 1, buf, start, word_break);
                let end = word_end(buf, last, word_break);
                start..end
            } else {
                let end = word_end(buf, start, word_break);
                start..end
            }
        }
        /// Returns the first character in the buffer, if it contains any valid characters.
        pub fn first_char(buf: &[u8]) -> io::Result<Option<char>> {
            match from_utf8(buf) {
                Ok(s) => Ok(s.chars().next()),
                Err(e) => {
                    if e.error_len().is_some() {
                        return Err(io::Error::new(io::ErrorKind::InvalidData,
                            "invalid utf-8 input received"));
                    }

                    let valid = e.valid_up_to();

                    let s = unsafe { from_utf8_unchecked(&buf[..valid]) };
                    Ok(s.chars().next())
                }
            }
        }

        pub fn first_word(buf: &str, word_break: &str) -> Option<usize> {
            let mut chars = buf.char_indices();

            drop_while(&mut chars, |(_, ch)| word_break.contains(ch));

            chars.next().map(|(idx, _)| idx)
        }

        pub fn word_start(buf: &str, cur: usize, word_break: &str) -> usize {
            let fwd = match buf[cur..].chars().next() {
                Some(ch) => word_break.contains(ch),
                None => return buf.len()
            };

            if fwd {
                next_word(1, buf, cur, word_break)
            } else {
                let mut chars = buf[..cur].char_indices().rev();

                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

                match chars.next() {
                    Some((idx, ch)) => idx + ch.len_utf8(),
                    None => 0
                }
            }
        }

        pub fn next_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize {
            let mut chars = buf[cur..].char_indices();

            for _ in 0..n {
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
            }

            match chars.next() {
                Some((idx, _)) => cur + idx,
                None => buf.len()
            }
        }

        pub fn word_end(buf: &str, cur: usize, word_break: &str) -> usize {
            let mut chars = buf[cur..].char_indices();

            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

            match chars.next() {
                Some((idx, _)) => cur + idx,
                None => buf.len()
            }
        }

        pub fn drop_while<I, T, F>(iter: &mut I, mut f: F)  where I: Iterator<Item=T> + Clone, F: FnMut(T) -> bool {
            loop {
                let mut clone = iter.clone();

                match clone.next() {
                    None => break,
                    Some(t) => {
                        if f(t) {
                            *iter = clone;
                        } else {
                            break;
                        }
                    }
                }
            }
        }

        pub fn get_open_paren(ch: char) -> Option<char> {
            match ch {
                ')' => Some('('),
                ']' => Some('['),
                '}' => Some('{'),
                _ => None
            }
        }

        pub fn find_matching_paren(s: &str, quotes: &str, open: char, close: char) -> Option<usize> {
            let mut chars = s.char_indices().rev();
            let mut level = 0;
            let mut string_delim = None;

            while let Some((ind, ch)) = chars.next() {
                if string_delim == Some(ch) {
                    string_delim = None;
                } else if quotes.contains(ch) {
                    string_delim = Some(ch);
                } else if string_delim.is_none() && ch == close {
                    level += 1;
                } else if string_delim.is_none() && ch == open {
                    level -= 1;

                    if level == 0 {
                        return Some(ind);
                    }
                }
            }

            None
        }

        pub fn is_combining_mark(ch: char) -> bool {
            use mortal::util::is_combining_mark;

            is_combining_mark(ch)
        }

        pub fn is_wide(ch: char) -> bool {
            use mortal::util::char_width;

            char_width(ch) == Some(2)
        }

        pub fn match_name(name: &str, value: &str) -> bool {
            // A value of "foo" matches both "foo" and "foo-bar"
            name == value ||
                (name.starts_with(value) && name.as_bytes()[value.len()] == b'-')
        }
    }

    pub mod variables
    {
        //! Contains types associated with user-configurable variables
        use ::
        {
            *,
        };
        

        use std::borrow::Cow;
        use std::fmt;
        use std::mem::replace;
        use std::time::Duration;

        /// Default `keyseq_timeout`, in milliseconds
        const KEYSEQ_TIMEOUT_MS: u64 = 500;

        /// Iterator over `Reader` variable values
        #[derive(Clone)]
        pub struct VariableIter<'a> {
            vars: &'a Variables,
            n: usize,
        }
        /// Represents a `Reader` variable of a given type
        #[derive(Clone, Debug)]
        pub enum Variable {
            /// Boolean variable
            Boolean(bool),
            /// Integer variable
            Integer(i32),
            /// String variable
            String(Cow<'static, str>),
        }

        impl From<bool> for Variable {
            fn from(b: bool) -> Variable {
                Variable::Boolean(b)
            }
        }

        impl From<i32> for Variable {
            fn from(i: i32) -> Variable {
                Variable::Integer(i)
            }
        }

        impl From<&'static str> for Variable {
            fn from(s: &'static str) -> Variable {
                Variable::String(s.into())
            }
        }

        impl From<Cow<'static, str>> for Variable {
            fn from(s: Cow<'static, str>) -> Variable {
                Variable::String(s)
            }
        }

        impl From<String> for Variable {
            fn from(s: String) -> Variable {
                Variable::String(s.into())
            }
        }

        impl fmt::Display for Variable {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match *self {
                    Variable::Boolean(b) => f.write_str(if b { "on" } else { "off" }),
                    Variable::Integer(n) => fmt::Display::fmt(&n, f),
                    Variable::String(ref s) => fmt::Display::fmt(&s[..], f),
                }
            }
        }

        macro_rules! define_variables {
            ( $( $field:ident : $ty:ty => ( $name:expr , $conv:ident ,
                    |$gr:ident| $getter:expr , |$sr:ident, $v:ident| $setter:expr ) , )+ ) => {
                static VARIABLE_NAMES: &[&str] = &[ $( $name ),+ ];

                pub struct Variables {
                    $( pub $field : $ty ),*
                }

                impl Variables {
                    pub fn get_variable(&self, name: &str) -> Option<Variable> {
                        match name {
                            $( $name => {
                                let $gr = self;
                                Some(Variable::from($getter))
                            } )+
                            _ => None
                        }
                    }

                    pub fn set_variable(&mut self, name: &str, value: &str)
                            -> Option<Variable> {
                        match name {
                            $( $name => {
                                if let Some($v) = $conv(value) {
                                    let $sr = self;
                                    Some(Variable::from($setter))
                                } else {
                                    None
                                }
                            } )+
                            _ => None
                        }
                    }

                    pub fn iter(&self) -> VariableIter {
                        VariableIter{vars: self, n: 0}
                    }
                }

                impl<'a> Iterator for VariableIter<'a> {
                    type Item = (&'static str, Variable);

                    fn next(&mut self) -> Option<Self::Item> {
                        let res = match VARIABLE_NAMES.get(self.n).cloned() {
                            $( Some($name) => ($name, {
                                let $gr = self.vars;
                                Variable::from($getter)
                            }) , )+
                            _ => return None
                        };

                        self.n += 1;
                        Some(res)
                    }
                }
            }
        }

        define_variables!{
            blink_matching_paren: bool => ("blink-matching-paren", parse_bool,
                |r| r.blink_matching_paren,
                |r, v| replace(&mut r.blink_matching_paren, v)),
            comment_begin: Cow<'static, str> => ("comment-begin", parse_string,
                |r| r.comment_begin.clone(),
                |r, v| replace(&mut r.comment_begin, v.into())),
            completion_display_width: usize => ("completion-display-width", parse_usize,
                |r| usize_as_i32(r.completion_display_width),
                |r, v| usize_as_i32(replace(&mut r.completion_display_width, v))),
            completion_query_items: usize => ("completion-query-items", parse_usize,
                |r| usize_as_i32(r.completion_query_items),
                |r, v| usize_as_i32(replace(&mut r.completion_query_items, v))),
            disable_completion: bool => ("disable-completion", parse_bool,
                |r| r.disable_completion,
                |r, v| replace(&mut r.disable_completion, v)),
            echo_control_characters: bool => ("echo-control-characters", parse_bool,
                |r| r.echo_control_characters,
                |r, v| replace(&mut r.echo_control_characters, v)),
            keyseq_timeout: Option<Duration> => ("keyseq-timeout", parse_duration,
                |r| as_millis(r.keyseq_timeout),
                |r, v| as_millis(replace(&mut r.keyseq_timeout, v))),
            page_completions: bool => ("page-completions", parse_bool,
                |r| r.page_completions,
                |r, v| replace(&mut r.page_completions, v)),
            print_completions_horizontally: bool => ("print-completions-horizontally", parse_bool,
                |r| r.print_completions_horizontally,
                |r, v| replace(&mut r.print_completions_horizontally, v)),
        }

        impl Default for Variables {
            fn default() -> Variables {
                Variables{
                    blink_matching_paren: false,
                    comment_begin: "#".into(),
                    completion_display_width: usize::max_value(),
                    completion_query_items: 100,
                    disable_completion: false,
                    echo_control_characters: true,
                    keyseq_timeout: Some(Duration::from_millis(KEYSEQ_TIMEOUT_MS)),
                    page_completions: true,
                    print_completions_horizontally: false,
                }
            }
        }

        fn parse_bool(s: &str) -> Option<bool> {
            match s {
                "0" => Some(false),
                "1" => Some(true),
                s if s.eq_ignore_ascii_case("off") => Some(false),
                s if s.eq_ignore_ascii_case("on") => Some(true),
                _ => None
            }
        }

        fn parse_string(s: &str) -> Option<String> {
            Some(s.to_owned())
        }

        fn as_millis(timeout: Option<Duration>) -> i32 {
            match timeout {
                Some(t) => {
                    let s = (t.as_secs() * 1_000) as i32;
                    let ms = (t.subsec_nanos() / 1_000_000) as i32;

                    s + ms
                }
                None => -1
            }
        }

        fn parse_duration(s: &str) -> Option<Option<Duration>> {
            match s.parse::<i32>() {
                Ok(n) if n <= 0 => Some(None),
                Ok(n) => Some(Some(Duration::from_millis(n as u64))),
                Err(_) => Some(None)
            }
        }

        fn usize_as_i32(u: usize) -> i32 {
            match u {
                u if u > i32::max_value() as usize => -1,
                u => u as i32
            }
        }

        fn parse_usize(s: &str) -> Option<usize> {
            match s.parse::<i32>() {
                Ok(n) if n < 0 => Some(usize::max_value()),
                Ok(n) => Some(n as usize),
                Err(_) => None
            }
        }
    }

    pub mod writer
    {
        //! Provides access to terminal write operations
        use ::
        {
            *,
        };
        

        #![allow(dead_code)] // XXX

        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::collections::{vec_deque, VecDeque};
        use std::fmt;
        use std::io;
        use std::iter::{repeat, Skip};
        use std::mem::swap;
        use std::ops::{Deref, DerefMut, Range};
        use std::sync::Arc;
        use std::sync::MutexGuard;
        use std::time::{Duration, Instant};

        use crate::chars::{is_ctrl, unctrl, ESCAPE, RUBOUT};
        use crate::highlighting::{Highlighter, Style, RESET_STYLE};
        use crate::reader::{START_INVISIBLE, END_INVISIBLE};
        use crate::terminal::{CursorMode, Size, Terminal, TerminalWriter};
        use crate::util::{
            backward_char, forward_char, backward_search_char, forward_search_char,
            filter_visible, is_combining_mark, is_wide, RangeArgument,
        };

        /// Duration to wait for input when "blinking"
        pub const BLINK_DURATION: Duration = Duration::from_millis(500);

        const COMPLETE_MORE: &'static str = "--More--";

        /// Default maximum history size
        const MAX_HISTORY: usize = !0;

        /// Tab column interval
        const TAB_STOP: usize = 8;

        // Length of "(arg: "
        const PROMPT_NUM_PREFIX: usize = 6;
        // Length of ") "
        const PROMPT_NUM_SUFFIX: usize = 2;

        // Length of "(i-search)`"
        const PROMPT_SEARCH_PREFIX: usize = 11;
        // Length of "failed "
        const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
        // Length of "reverse-"
        const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
        // Length of "': "
        const PROMPT_SEARCH_SUFFIX: usize = 3;

        /// Provides an interface to write line-by-line output to the terminal device.
        ///
        /// Holds a lock on terminal write operations.
        /// See [`Interface`] for more information about concurrent operations.
        ///
        /// An instance of this type can be constructed using either the
        /// [`Interface::lock_writer_append`] or the [`Interface::lock_writer_erase`]
        /// method.
        ///
        /// [`Interface`]: ../interface/struct.Interface.html
        /// [`Interface::lock_writer_append`]: ../interface/struct.Interface.html#method.lock_writer_append
        /// [`Interface::lock_writer_erase`]: ../interface/struct.Interface.html#method.lock_writer_erase
        pub struct Writer<'a, 'b: 'a, Term: 'b + Terminal> {
            write: WriterImpl<'a, 'b, Term>,
        }

        enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminal> {
            Mutex(WriteLock<'b, Term>),
            MutRef(&'a mut WriteLock<'b, Term>),
        }

        #[derive(Debug)]
        pub struct Write {
            /// Input buffer
            pub buffer: String,
            /// Original buffer entered before searching through history
            pub backup_buffer: String,
            /// Position of the cursor
            pub cursor: usize,
            /// Position of the cursor if currently performing a blink
            blink: Option<Blink>,

            /// Stored history entries
            pub history: VecDeque<String>,
            /// History entry currently being edited;
            /// `None` if the new buffer is being edited
            pub history_index: Option<usize>,
            /// Maximum size of history
            history_size: usize,
            /// Number of history entries added since last loading history
            history_new_entries: usize,

            /// Whether the prompt is drawn; i.e. a `read_line` operation is in progress
            pub is_prompt_drawn: bool,

            /// Portion of prompt up to and including the final newline
            pub prompt_prefix: String,
            prompt_prefix_len: usize,
            /// Portion of prompt after the final newline
            pub prompt_suffix: String,
            prompt_suffix_len: usize,

            /// Current type of prompt
            pub prompt_type: PromptType,

            /// Whether a search in progress is a reverse search
            pub reverse_search: bool,
            /// Whether a search in progress has failed to find a match
            pub search_failed: bool,
            /// Current search string
            pub search_buffer: String,
            /// Last search string
            pub last_search: String,
            /// Selected history entry prior to a history search
            pub prev_history: Option<usize>,
            /// Position of the cursor prior to a history search
            pub prev_cursor: usize,

            /// Numerical argument
            pub input_arg: Digit,
            /// Whether a numerical argument was supplied
            pub explicit_arg: bool,

            /// Terminal size as of last draw operation
            pub screen_size: Size,
        }

        pub struct WriteLock<'a, Term: 'a + Terminal> {
            term: Box<dyn TerminalWriter<Term> + 'a>,
            data: MutexGuard<'a, Write>,
            highlighter: Option<Arc<dyn Highlighter + Send + Sync>>,
        }

        impl<'a, Term: Terminal> WriteLock<'a, Term> {
            pub fn new(term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write>,
                    highlighter: Option<Arc<dyn Highlighter + Send + Sync>>
                    ) -> WriteLock<'a, Term> {
                WriteLock{
                    term,
                    data,
                    highlighter,
                }
            }

            pub fn size(&self) -> io::Result<Size> {
                self.term.size()
            }

            pub fn flush(&mut self) -> io::Result<()> {
                self.term.flush()
            }

            pub fn update_size(&mut self) -> io::Result<()> {
                let size = self.size()?;
                self.screen_size = size;
                Ok(())
            }

            pub fn blink(&mut self, pos: usize) -> io::Result<()> {
                self.expire_blink()?;

                let orig = self.cursor;
                self.move_to(pos)?;
                self.cursor = orig;

                let expiry = Instant::now() + BLINK_DURATION;

                self.blink = Some(Blink{
                    pos,
                    expiry,
                });

                Ok(())
            }

            pub fn check_expire_blink(&mut self, now: Instant) -> io::Result<bool> {
                if let Some(blink) = self.data.blink {
                    if now >= blink.expiry {
                        self.expire_blink()?;
                    }
                }

                Ok(self.blink.is_none())
            }

            pub fn expire_blink(&mut self) -> io::Result<()> {
                if let Some(blink) = self.data.blink.take() {
                    self.move_from(blink.pos)?;
                }

                Ok(())
            }

            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
                self.expire_blink()?;

                let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

                if redraw {
                    self.clear_full_prompt()?;
                }

                self.data.set_prompt(prompt);

                if redraw {
                    self.draw_prompt()?;
                }

                Ok(())
            }
            /// Draws the prompt and current input, assuming the cursor is at column 0
            pub fn draw_prompt(&mut self) -> io::Result<()> {
                self.draw_prompt_prefix()?;
                self.draw_prompt_suffix()
            }

            pub fn draw_prompt_prefix(&mut self) -> io::Result<()> {
                match self.prompt_type {
                    // Prefix is not drawn when completions are shown
                    PromptType::CompleteMore => Ok(()),
                    _ => {
                        let pfx = self.prompt_prefix.clone();
                        self.draw_raw_prompt(&pfx, Vec::new())
                    }
                }
            }

            pub fn draw_prompt_suffix(&mut self) -> io::Result<()> {
                match self.prompt_type {
                    PromptType::Normal => {
                        let sfx = self.prompt_suffix.clone();

                        let styles = self.highlighter.as_ref().map(|h|
                            h.highlight(&sfx)
                        ).unwrap_or_default();

                        self.draw_raw_prompt(&sfx, styles)?;
                    }
                    PromptType::Number => {
                        let n = self.input_arg.to_i32();
                        let s = format!("(arg: {}) ", n);
                        self.draw_text(0, &s)?;
                    }
                    PromptType::Search => {
                        let pre = match (self.reverse_search, self.search_failed) {
                            (false, false) => "(i-search)",
                            (false, true)  => "(failed i-search)",
                            (true,  false) => "(reverse-i-search)",
                            (true,  true)  => "(failed reverse-i-search)",
                        };

                        let entry_str = self.get_history(self.history_index).to_owned();
                        let prefix_str = format!("{}`{}': ", pre, self.search_buffer);
                        let prefix_len = prefix_str.len();

                        // Calculate styles for the history entry part
                        let entry_styles = self.highlighter.as_ref()
                            .map(|h| h.highlight(&entry_str))
                            .unwrap_or_default();

                        // Adjust style ranges to account for the prefix string
                        let adjusted_styles: Vec<(Range<usize>, Style)> = entry_styles.into_iter()
                            .map(|(range, style)| (range.start + prefix_len .. range.end + prefix_len, style))
                            .collect();

                        let full_str = format!("{}{}", prefix_str, entry_str);

                        // Draw the full string with adjusted styles using draw_text_impl
                        // Use Display options similar to draw_raw_prompt for consistency
                        self.draw_text_impl(0, &full_str, Display {
                            allow_tab: true,
                            allow_newline: true,
                            allow_escape: true,
                        }, false, &adjusted_styles, 0)?;

                        // Calculate screen coordinates using start_col = 0 because full_str includes the prefix.
                        let (end_line, _end_col) = self.line_col_with(full_str.len(), &full_str, 0);
                        let target_cursor_pos_in_full_str = prefix_len + self.cursor;
                        let (target_line, target_col) = self.line_col_with(target_cursor_pos_in_full_str, &full_str, 0);

                        // Calculate relative movement directly
                        let lines = target_line as isize - end_line as isize;
                        // Calculate the column move: move to beginning of target line, then right by target_col.
                        // We know we ended at the beginning of the line *after* end_line (due to wrap or newline logic in draw_text_impl)
                        // or at _end_col if end_line == target_line and no wrap occurred.
                        // It's simpler to move to the beginning of the target line and then right.
                        let cols = target_col as isize; // We will move_up/down first, then move_to_first_column, then move_right.

                        // Apply movement
                        if lines > 0 {
                            self.term.move_down(lines as usize)?;
                        } else if lines < 0 {
                            self.term.move_up((-lines) as usize)?;
                        }
                        self.term.move_to_first_column()?;
                        if cols > 0 {
                            self.term.move_right(cols as usize)?;
                        }
                        // We don't need to call self.move_rel as we performed the terminal moves directly.
                        // Also, don't update self.cursor here, it's already correct (index within history entry).
                        return Ok(())
                    }
                    PromptType::CompleteIntro(n) => {
                        return self.term.write(&complete_intro(n));
                    }
                    PromptType::CompleteMore => {
                        return self.term.write(COMPLETE_MORE);
                    }
                }

                self.draw_buffer(0)?;
                let len = self.buffer.len();
                self.move_from(len)
            }

            pub fn redraw_prompt(&mut self, new_prompt: PromptType) -> io::Result<()> {
                self.clear_prompt()?;
                self.prompt_type = new_prompt;
                self.draw_prompt_suffix()
            }
            /// Draws a portion of the buffer, starting from the given cursor position
            pub fn draw_buffer(&mut self, pos: usize) -> io::Result<()> {
                let (_, col) = self.line_col(pos);

                let styles = self.highlighter.as_ref().map(|h|
                    h.highlight(&self.buffer)
                ).unwrap_or_default();

                let buf_slice = self.buffer[pos..].to_owned();

                self.draw_text_impl(col, &buf_slice, Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                }, false, &styles, pos)?;

                Ok(())
            }
            /// Draw some text with the cursor beginning at the given column.
            fn draw_text(&mut self, start_col: usize, text: &str) -> io::Result<()> {
                self.draw_text_impl(start_col, text, Display{
                    allow_newline: true,
                    .. Display::default()
                }, false, &[], 0)
            }

            fn draw_raw_prompt(&mut self, text: &str, styles: Vec<(Range<usize>, Style)>) -> io::Result<()> {
                self.draw_text_impl(0, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    allow_escape: true,
                }, true, &styles, 0)
            }

            fn draw_text_impl(&mut self, start_col: usize, text: &str, disp: Display,
                    handle_invisible: bool, styles: &[(Range<usize>, Style)], text_offset: usize) -> io::Result<()> {
                let width = self.screen_size.columns;
                let mut col = start_col;
                let mut out = String::with_capacity(text.len());

                let mut current_style = &Style::Default;
                let mut style_iter = styles.iter().peekable();
                let mut current_text_byte = 0;

                let mut clear = false;
                let mut hidden = false;

                for ch in text.chars() {
                    if handle_invisible && ch == START_INVISIBLE {
                        hidden = true;
                    } else if handle_invisible && ch == END_INVISIBLE {
                        hidden = false;
                    } else if hidden {
                        // Render the character, but assume it has 0 width.
                        out.push(ch);
                        current_text_byte += ch.len_utf8();
                    } else {
                        // Determine style for the current character
                        let absolute_byte_pos = text_offset + current_text_byte;
                        // Advance style iterator past ranges that end before the current position
                        while let Some((range, _)) = style_iter.peek() {
                            if range.end <= absolute_byte_pos {
                                style_iter.next();
                            } else {
                                break;
                            }
                        }

                        // Find the style that applies to the current position
                        let new_style = style_iter.peek()
                            .filter(|(range, _)| range.start <= absolute_byte_pos)
                            .map(|(_, style)| style)
                            .unwrap_or(&Style::Default);

                        // Apply style change if needed
                        if new_style != current_style {
                            if current_style != &Style::Default {
                                out.push_str(RESET_STYLE); // Reset previous style
                            }
                            if let Style::AnsiColor(ansi_code) = new_style {
                                out.push_str(ansi_code); // Apply new style
                            }
                            current_style = new_style;
                        }

                        // Apply style if changed
                        for ch in display(ch, disp) {
                            if ch == '\t' {
                                let n = TAB_STOP - (col % TAB_STOP);

                                if col + n > width {
                                    let pre = width - col;
                                    out.extend(repeat(' ').take(pre));
                                    out.push_str(" \r");
                                    out.extend(repeat(' ').take(n - pre));
                                    col = n - pre;
                                } else {
                                    out.extend(repeat(' ').take(n));
                                    col += n;

                                    if col == width {
                                        out.push_str(" \r");
                                        col = 0;
                                    }
                                }
                            } else if ch == '\n' {
                                if !clear {
                                    self.term.write(&out)?;
                                    out.clear();
                                    self.term.clear_to_screen_end()?;
                                    clear = true;
                                }

                                out.push('\n');
                                col = 0;
                            } else if is_combining_mark(ch) {
                                out.push(ch);
                            } else if is_wide(ch) {
                                if col == width - 1 {
                                    out.push_str("  \r");
                                    out.push(ch);
                                    col = 2;
                                } else {
                                    out.push(ch);
                                    col += 2;
                                }
                            } else {
                                out.push(ch);
                                col += 1;

                                if col == width {
                                    // Space pushes the cursor to the next line,
                                    // CR brings back to the start of the line.
                                    out.push_str(" \r");
                                    col = 0;
                                }
                            }
                        }
                        current_text_byte += ch.len_utf8(); // Advance byte counter *after* processing character
                    }
                }

                // Ensure style is reset at the end
                if current_style != &Style::Default {
                    // Check if the last applied style was actually from the styles vec
                    let last_applied_style = styles.iter().rev().find(|(range, _)| range.start < text_offset + text.len());
                    match last_applied_style {
                        Some((_, Style::Default)) => {}, // Already default
                        Some((_, Style::AnsiColor(_))) => out.push_str(RESET_STYLE),
                        None if !styles.is_empty() => out.push_str(RESET_STYLE), // Reset if styles were provided but didn't cover the end
                        _ => {} // No styles or last was default
                    }
                }

                if col == width {
                    out.push_str(" \r");
                }

                self.term.write(&out)
            }

            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
                self.expire_blink()?;

                self.move_to(0)?;
                self.buffer.clear();
                self.buffer.push_str(buf);
                self.new_buffer()
            }

            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
                self.expire_blink()?;

                if !self.buffer.is_char_boundary(pos) {
                    panic!("invalid cursor position {} in buffer {:?}",
                        pos, self.buffer);
                }

                self.move_to(pos)
            }

            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.term.set_cursor_mode(mode)
            }

            pub fn history_len(&self) -> usize {
                self.history.len()
            }

            pub fn history_size(&self) -> usize {
                self.history_size
            }

            pub fn set_history_size(&mut self, n: usize) {
                self.history_size = n;
                self.truncate_history(n);
            }

            pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                self.term.write(s)
            }

            pub fn start_history_search(&mut self, reverse: bool) -> io::Result<()> {
                self.search_buffer = self.buffer[..self.cursor].to_owned();

                self.continue_history_search(reverse)
            }

            pub fn continue_history_search(&mut self, reverse: bool) -> io::Result<()> {
                if let Some(idx) = self.find_history_search(reverse) {
                    let original_cursor = self.cursor;
                    self.set_history_entry(Some(idx));

                    // Clear the old line content visually
                    self.clear_prompt()?;
                    // Redraw the prompt and the entire new buffer content
                    self.draw_prompt_suffix()?;
                    // Move the cursor back to its original position
                    self.move_to(original_cursor)?; // This updates self.cursor and moves physical cursor
                }
                Ok(())
            }

            pub fn info(&self) -> String {
                format!(
                    "buffer: {:?}, cursor: {} hindex: {:?} pmt_suffix_len: {} pmt_type: {:?} search_buffer: {:?} last_s: {:?} prompt_p: {:?} ({}) prompt_s: {:?} ({})",
                    self.buffer, self.cursor, self.history_index,
                    self.prompt_suffix_len, self.prompt_type, self.search_buffer,
                    self.last_search, self.prompt_prefix, self.prompt_prefix_len,
                    self.prompt_suffix, self.prompt_suffix_len,
                )
            }

            fn find_history_search(&self, reverse: bool) -> Option<usize> {
                let len = self.history.len();
                let idx = self.history_index.unwrap_or(len);

                if reverse {
                    self.history.iter().rev().skip(len - idx)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx - (pos + 1))
                } else {
                    self.history.iter().skip(idx + 1)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx + (pos + 1))
                }
            }

            pub fn start_search_history(&mut self, reverse: bool) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;
                self.search_buffer.clear();
                self.prev_history = self.history_index;
                self.prev_cursor = self.cursor;

                self.redraw_prompt(PromptType::Search)
            }

            pub fn continue_search_history(&mut self, reverse: bool) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;

                {
                    let data = &mut *self.data;
                    data.search_buffer.clone_from(&data.last_search);
                }

                self.search_history_step()
            }

            pub fn end_search_history(&mut self) -> io::Result<()> {
                self.redraw_prompt(PromptType::Normal)
            }

            pub fn abort_search_history(&mut self) -> io::Result<()> {
                self.clear_prompt()?;

                let ent = self.prev_history;
                self.set_history_entry(ent);
                self.cursor = self.prev_cursor;

                self.prompt_type = PromptType::Normal;
                self.draw_prompt_suffix()
            }

            fn show_search_match(&mut self, next_match: Option<(Option<usize>, usize)>)
                    -> io::Result<()> {
                self.clear_prompt()?;

                if let Some((idx, pos)) = next_match {
                    self.search_failed = false;
                    self.set_history_entry(idx);
                    self.cursor = pos;
                } else {
                    self.search_failed = true;
                }


                self.prompt_type = PromptType::Search;
                self.draw_prompt_suffix()
            }

            pub fn search_history_update(&mut self) -> io::Result<()> {
                // Search for the next match, perhaps including the current position
                let next_match = if self.reverse_search {
                    self.search_history_backward(&self.search_buffer, true)
                } else {
                    self.search_history_forward(&self.search_buffer, true)
                };

                self.show_search_match(next_match)
            }

            fn search_history_step(&mut self) -> io::Result<()> {
                if self.search_buffer.is_empty() {
                    return self.redraw_prompt(PromptType::Search);
                }

                // Search for the next match
                let next_match = if self.reverse_search {
                    self.search_history_backward(&self.search_buffer, false)
                } else {
                    self.search_history_forward(&self.search_buffer, false)
                };

                self.show_search_match(next_match)
            }

            fn search_history_backward(&self, s: &str, include_cur: bool)
                    -> Option<(Option<usize>, usize)> {
                let mut idx = self.history_index;
                let mut pos = Some(self.cursor);

                if include_cur && !self.search_failed {
                    if let Some(p) = pos {
                        if self.get_history(idx).is_char_boundary(p + s.len()) {
                            pos = Some(p + s.len());
                        }
                    }
                }

                loop {
                    let line = self.get_history(idx);

                    match line[..pos.unwrap_or(line.len())].rfind(s) {
                        Some(found) => {
                            pos = Some(found);
                            break;
                        }
                        None => {
                            match idx {
                                Some(0) => return None,
                                Some(n) => {
                                    idx = Some(n - 1);
                                    pos = None;
                                }
                                None => {
                                    if self.history.is_empty() {
                                        return None;
                                    } else {
                                        idx = Some(self.history.len() - 1);
                                        pos = None;
                                    }
                                }
                            }
                        }
                    }
                }

                pos.map(|pos| (idx, pos))
            }

            fn search_history_forward(&self, s: &str, include_cur: bool)
                    -> Option<(Option<usize>, usize)> {
                let mut idx = self.history_index;
                let mut pos = Some(self.cursor);

                if !include_cur {
                    if let Some(p) = pos {
                        pos = Some(forward_char(1, self.get_history(idx), p));
                    }
                }

                loop {
                    let line = self.get_history(idx);

                    match line[pos.unwrap_or(0)..].find(s) {
                        Some(found) => {
                            pos = pos.map(|n| n + found).or(Some(found));
                            break;
                        }
                        None => {
                            if let Some(n) = idx {
                                if n + 1 == self.history.len() {
                                    idx = None;
                                } else {
                                    idx = Some(n + 1);
                                }
                                pos = None;
                            } else {
                                return None;
                            }
                        }
                    }
                }

                pos.map(|pos| (idx, pos))
            }

            pub fn add_history(&mut self, line: String) {
                if self.history.len() == self.history_size {
                    self.history.pop_front();
                }

                self.history.push_back(line);
                self.history_new_entries = self.history.len()
                    .min(self.history_new_entries + 1);
            }

            pub fn add_history_unique(&mut self, line: String) {
                let is_duplicate = self.history.back().map_or(false, |ent| *ent == line);

                if !is_duplicate {
                    self.add_history(line);
                }
            }

            pub fn clear_history(&mut self) {
                self.truncate_history(0);
                self.history_new_entries = 0;
            }

            pub fn remove_history(&mut self, n: usize) {
                if n < self.history.len() {
                    let first_new = self.history.len() - self.history_new_entries;

                    if n >= first_new {
                        self.history_new_entries -= 1;
                    }

                    self.history.remove(n);
                }
            }

            pub fn truncate_history(&mut self, n: usize) {
                let len = self.history.len();

                if n < len {
                    let _ = self.history.drain(..len - n);
                    self.history_new_entries = self.history_new_entries.max(n);
                }
            }

            pub fn next_history(&mut self, n: usize) -> io::Result<()> {
                if let Some(old) = self.history_index {
                    let new = old.saturating_add(n);

                    if new >= self.history.len() {
                        self.select_history_entry(None)?;
                    } else {
                        self.select_history_entry(Some(new))?;
                    }
                }

                Ok(())
            }

            pub fn prev_history(&mut self, n: usize) -> io::Result<()> {
                if !self.history.is_empty() && self.history_index != Some(0) {
                    let new = if let Some(old) = self.history_index {
                        old.saturating_sub(n)
                    } else {
                        self.history.len().saturating_sub(n)
                    };

                    self.select_history_entry(Some(new))?;
                }

                Ok(())
            }

            pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
                if new != self.history_index {
                    self.move_to(0)?;
                    self.set_history_entry(new);
                    self.new_buffer()?;
                }

                Ok(())
            }

            pub fn set_history_entry(&mut self, new: Option<usize>) {
                let old = self.history_index;

                if old != new {
                    let data = &mut *self.data;
                    data.history_index = new;

                    if let Some(old) = old {
                        data.history[old].clone_from(&data.buffer);
                    } else {
                        swap(&mut data.buffer, &mut data.backup_buffer);
                    }

                    if let Some(new) = new {
                        data.buffer.clone_from(&data.history[new]);
                    } else {
                        data.buffer.clear();
                        swap(&mut data.buffer, &mut data.backup_buffer);
                    }
                }
            }

            fn get_history(&self, n: Option<usize>) -> &str {
                if self.history_index == n {
                    &self.buffer
                } else if let Some(n) = n {
                    &self.history[n]
                } else {
                    &self.backup_buffer
                }
            }

            pub fn backward_char(&mut self, n: usize) -> io::Result<()> {
                let pos = backward_char(n, &self.buffer, self.cursor);
                self.move_to(pos)
            }

            pub fn forward_char(&mut self, n: usize) -> io::Result<()> {
                let pos = forward_char(n, &self.buffer, self.cursor);
                self.move_to(pos)
            }

            pub fn backward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> {
                if let Some(pos) = backward_search_char(n, &self.buffer, self.cursor, ch) {
                    self.move_to(pos)?;
                }

                Ok(())
            }

            pub fn forward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> {
                if let Some(pos) = forward_search_char(n, &self.buffer, self.cursor, ch) {
                    self.move_to(pos)?;
                }

                Ok(())
            }
            /// Deletes a range from the buffer; the cursor is moved to the end
            /// of the given range.
            pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.buffer.len());

                // Move to the start of the deletion range
                self.move_to(start)?;

                // Remove the characters in the range
                let _ = self.buffer.drain(start..end);

                // Move physical cursor to the beginning of the editable area
                let current_internal_cursor = self.cursor; // Save internal cursor state
                self.move_to(0)?; // Move physical cursor to start of input area
                self.cursor = current_internal_cursor; // Restore internal cursor state

                // Redraw the entire buffer from position 0 with updated highlighting
                self.draw_buffer(0)?;

                // Clear any leftover characters from the previous render
                self.term.clear_to_screen_end()?;

                // Update internal cursor state to the deletion point
                self.cursor = start;

                // Move physical cursor from the end of the drawn buffer back to deletion point
                let len = self.buffer.len();
                self.move_from(len)?;

                Ok(())
            }

            pub fn insert_str(&mut self, s: &str) -> io::Result<()> {
                let original_cursor = self.cursor;
                self.buffer.insert_str(original_cursor, s);
                let new_cursor = original_cursor + s.len();

                // Move physical cursor to the beginning of the editable area (position 0 relative to prompt suffix)
                // Need to use move_rel carefully or move_to(0) which recalculates absolute position.
                // Let's recalculate using move_to(0).
                let current_internal_cursor = self.cursor; // Save internal cursor state before move_to potentially changes it
                self.move_to(0)?; // Move physical cursor to the start of the input area
                self.cursor = current_internal_cursor; // Restore internal cursor state

                // Redraw the entire buffer from position 0 with updated highlighting
                self.draw_buffer(0)?; // This draws the text and leaves the physical cursor at the end


                // Clear any leftover characters from the previous render (if the line got shorter)
                // Although in insert_str it only gets longer or stays same. Still good practice.
                self.term.clear_to_screen_end()?;

                // Update the internal cursor state to the correct position after insertion
                self.cursor = new_cursor;

                // Move the physical cursor from the end of the drawn buffer
                // back to the correct internal cursor position.
                let len = self.buffer.len();
                self.move_from(len)?;

                Ok(())
            }

            pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                    -> io::Result<()> {
                // Ranges must not overlap
                assert!(src.end <= dest.start || src.start >= dest.end);

                // Final cursor position
                let final_cur = if src.start < dest.start {
                    dest.end
                } else {
                    dest.start + (src.end - src.start)
                };

                let (left, right) = if src.start < dest.start {
                    (src, dest)
                } else {
                    (dest, src)
                };

                self.move_to(left.start)?;

                let a = self.buffer[left.clone()].to_owned();
                let b = self.buffer[right.clone()].to_owned();

                let _ = self.buffer.drain(right.clone());
                self.buffer.insert_str(right.start, &a);

                let _ = self.buffer.drain(left.clone());
                self.buffer.insert_str(left.start, &b);

                let cursor = self.cursor;
                self.draw_buffer(cursor)?;
                self.term.clear_to_screen_end()?;

                self.cursor = final_cur;
                let len = self.buffer.len();
                self.move_from(len)
            }

            fn prompt_suffix_length(&self) -> usize {
                match self.prompt_type {
                    PromptType::Normal => self.prompt_suffix_len,
                    PromptType::Number => {
                        let n = number_len(self.input_arg.to_i32());
                        PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                    }
                    PromptType::Search => {
                        let mut prefix = PROMPT_SEARCH_PREFIX;

                        if self.reverse_search {
                            prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                        }
                        if self.search_failed {
                            prefix += PROMPT_SEARCH_FAILED_PREFIX;
                        }

                        let n = self.display_size(&self.search_buffer, prefix);
                        prefix + n + PROMPT_SEARCH_SUFFIX
                    }
                    PromptType::CompleteIntro(n) => complete_intro(n).len(),
                    PromptType::CompleteMore => COMPLETE_MORE.len(),
                }
            }

            fn line_col(&self, pos: usize) -> (usize, usize) {
                let prompt_len = self.prompt_suffix_length();

                match self.prompt_type {
                    PromptType::CompleteIntro(_) |
                    PromptType::CompleteMore => {
                        let width = self.screen_size.columns;
                        (prompt_len / width, prompt_len % width)
                    }
                    _ => self.line_col_with(pos, &self.buffer, prompt_len)
                }
            }

            fn line_col_with(&self, pos: usize, buf: &str, start_col: usize) -> (usize, usize) {
                let width = self.screen_size.columns;
                if width == 0 {
                    return (0, 0);
                }

                let n = start_col + self.display_size(&buf[..pos], start_col);

                (n / width, n % width)
            }

            pub fn clear_screen(&mut self) -> io::Result<()> {
                self.term.clear_screen()?;
                self.draw_prompt()?;

                Ok(())
            }

            pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
                self.term.clear_to_screen_end()
            }
            /// Draws a new buffer on the screen. Cursor position is assumed to be `0`.
            pub fn new_buffer(&mut self) -> io::Result<()> {
                self.draw_buffer(0)?;
                self.cursor = self.buffer.len();

                self.term.clear_to_screen_end()?;

                Ok(())
            }

            pub fn clear_full_prompt(&mut self) -> io::Result<()> {
                let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
                let (line, _) = self.line_col(self.cursor);
                self.term.move_up(prefix_lines + line)?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }

            pub fn clear_prompt(&mut self) -> io::Result<()> {
                let (line, _) = self.line_col(self.cursor);

                self.term.move_up(line)?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }
            /// Move back to true cursor position from some other position
            pub fn move_from(&mut self, pos: usize) -> io::Result<()> {
                let (lines, cols) = self.move_delta(pos, self.cursor, &self.buffer);
                self.move_rel(lines, cols)
            }

            pub fn move_to(&mut self, pos: usize) -> io::Result<()> {
                if pos != self.cursor {
                    let (lines, cols) = self.move_delta(self.cursor, pos, &self.buffer);
                    self.move_rel(lines, cols)?;
                    self.cursor = pos;
                }

                Ok(())
            }

            pub fn move_to_end(&mut self) -> io::Result<()> {
                let pos = self.buffer.len();
                self.move_to(pos)
            }

            pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                self.term.move_right(n)
            }
            /// Moves from `old` to `new` cursor position, using the given buffer
            /// as current input.
            fn move_delta(&self, old: usize, new: usize, buf: &str) -> (isize, isize) {
                let prompt_len = self.prompt_suffix_length();
                let (old_line, old_col) = self.line_col_with(old, buf, prompt_len);
                let (new_line, new_col) = self.line_col_with(new, buf, prompt_len);

                (new_line as isize - old_line as isize,
                new_col as isize - old_col as isize)
            }

            fn move_rel(&mut self, lines: isize, cols: isize) -> io::Result<()> {
                if lines > 0 {
                    self.term.move_down(lines as usize)?;
                } else if lines < 0 {
                    self.term.move_up((-lines) as usize)?;
                }

                if cols > 0 {
                    self.term.move_right(cols as usize)?;
                } else if cols < 0 {
                    self.term.move_left((-cols) as usize)?;
                }

                Ok(())
            }

            pub fn reset_data(&mut self) {
                self.data.reset_data();
            }

            pub fn set_digit_from_char(&mut self, ch: char) {
                let digit = match ch {
                    '-' => Digit::NegNone,
                    '0' ..= '9' => Digit::from(ch),
                    _ => Digit::None
                };

                self.input_arg = digit;
                self.explicit_arg = true;
            }
        }

        #[derive(Copy, Clone, Debug)]
        struct Blink {
            pos: usize,
            expiry: Instant,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Writer<'a, 'b, Term> {
            fn new(mut write: WriterImpl<'a, 'b, Term>, clear: bool) -> io::Result<Self> {
                write.expire_blink()?;

                if write.is_prompt_drawn {
                    if clear {
                        write.clear_full_prompt()?;
                    } else {
                        write.move_to_end()?;
                        write.write_str("\n")?;
                    }
                }

                Ok(Writer{write})
            }

            pub fn with_lock(write: WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
                Writer::new(WriterImpl::Mutex(write), clear)
            }

            pub fn with_ref(write: &'a mut WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
                Writer::new(WriterImpl::MutRef(write), clear)
            }
            /// Returns an iterator over history entries.
            pub fn history(&self) -> HistoryIter {
                self.write.history()
            }
            /// Writes some text to the terminal device.
            ///
            /// Before the `Writer` is dropped, any output written should be followed
            /// by a newline. A newline is automatically written if the `writeln!`
            /// macro is used.
            pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                self.write.write_str(s)
            }
            /// Writes formatted text to the terminal display.
            ///
            /// This method enables `Interface` to be used as the receiver to
            /// the [`writeln!`] macro.
            ///
            /// If the text contains any unprintable characters (e.g. escape sequences),
            /// those characters will be escaped before printing.
            ///
            /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
            /// [`writeln!`]: https://doc.rust-lang.org/std/macro.writeln.html
            pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Drop for Writer<'a, 'b, Term> {
            fn drop(&mut self) {
                if self.write.is_prompt_drawn {
                    // There's not really anything useful to be done with this error.
                    let _ = self.write.draw_prompt();
                }
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for WriteLock<'a, Term> {
            type Target = Write;

            fn deref(&self) -> &Write {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for WriteLock<'a, Term> {
            fn deref_mut(&mut self) -> &mut Write {
                &mut self.data
            }
        }

        impl Write {
            pub fn new(screen_size: Size) -> Write {
                Write{
                    buffer: String::new(),
                    backup_buffer: String::new(),
                    cursor: 0,
                    blink: None,

                    history: VecDeque::new(),
                    history_index: None,
                    history_size: MAX_HISTORY,
                    history_new_entries: 0,

                    is_prompt_drawn: false,

                    prompt_prefix: String::new(),
                    prompt_prefix_len: 0,
                    prompt_suffix: String::new(),
                    prompt_suffix_len: 0,

                    prompt_type: PromptType::Normal,

                    reverse_search: false,
                    search_failed: false,
                    search_buffer: String::new(),
                    last_search: String::new(),
                    prev_history: None,
                    prev_cursor: !0,

                    input_arg: Digit::None,
                    explicit_arg: false,

                    screen_size,
                }
            }

            pub fn history(&self) -> HistoryIter {
                HistoryIter(self.history.iter())
            }

            pub fn new_history(&self) -> Skip<HistoryIter> {
                let first_new = self.history.len() - self.history_new_entries;
                self.history().skip(first_new)
            }

            pub fn new_history_entries(&self) -> usize {
                self.history_new_entries
            }

            pub fn reset_data(&mut self) {
                self.buffer.clear();
                self.backup_buffer.clear();
                self.cursor = 0;
                self.history_index = None;

                self.prompt_type = PromptType::Normal;

                self.input_arg = Digit::None;
                self.explicit_arg = false;
            }

            pub fn reset_new_history(&mut self) {
                self.history_new_entries = 0;
            }

            pub fn set_buffer(&mut self, buf: &str) {
                self.buffer.clear();
                self.buffer.push_str(buf);
                self.cursor = buf.len();
            }

            pub fn set_cursor(&mut self, pos: usize) {
                if !self.buffer.is_char_boundary(pos) {
                    panic!("invalid cursor position {} in buffer {:?}",
                        pos, self.buffer);
                }

                self.cursor = pos;
            }

            pub fn set_prompt(&mut self, prompt: &str) {
                let (pre, suf) = match prompt.rfind('\n') {
                    Some(pos) => (&prompt[..pos + 1], &prompt[pos + 1..]),
                    None => (&prompt[..0], prompt)
                };

                self.prompt_prefix = pre.to_owned();
                self.prompt_suffix = suf.to_owned();

                let pre_virt = filter_visible(pre);
                self.prompt_prefix_len = self.display_size(&pre_virt, 0);

                let suf_virt = filter_visible(suf);
                self.prompt_suffix_len = self.display_size(&suf_virt, 0);
            }

            pub fn display_size(&self, s: &str, start_col: usize) -> usize {
                let width = self.screen_size.columns;
                let mut col = start_col;

                let disp = Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                };

                for ch in filter_visible(s).chars().flat_map(|ch| display(ch, disp)) {
                    let n = match ch {
                        '\n' => width - (col % width),
                        '\t' => TAB_STOP - (col % TAB_STOP),
                        ch if is_combining_mark(ch) => 0,
                        ch if is_wide(ch) => {
                            if col % width == width - 1 {
                                // Can't render a fullwidth character into last column
                                3
                            } else {
                                2
                            }
                        }
                        _ => 1
                    };

                    col += n;
                }

                col - start_col
            }
        }
        /// Maximum value of digit input
        const NUMBER_MAX: i32 = 1_000_000;

        #[derive(Copy, Clone, Debug)]
        pub enum Digit {
            None,
            NegNone,
            Num(i32),
            NegNum(i32),
        }

        impl Digit {
            pub fn input(&mut self, n: i32) {
                match *self {
                    Digit::None => *self = Digit::Num(n),
                    Digit::NegNone => *self = Digit::NegNum(n),
                    Digit::Num(ref mut m) | Digit::NegNum(ref mut m) => {
                        *m *= 10;
                        *m += n;
                    }
                }
            }

            pub fn is_out_of_bounds(&self) -> bool {
                match *self {
                    Digit::Num(n) | Digit::NegNum(n) if n > NUMBER_MAX => true,
                    _ => false
                }
            }

            pub fn to_i32(&self) -> i32 {
                match *self {
                    Digit::None => 1,
                    Digit::NegNone => -1,
                    Digit::Num(n) => n,
                    Digit::NegNum(n) => -n,
                }
            }
        }

        impl From<char> for Digit {
            /// Convert a decimal digit character to a `Digit` value.
            ///
            /// The input must be in the range `'0' ..= '9'`.
            fn from(ch: char) -> Digit {
                let n = (ch as u8) - b'0';
                Digit::Num(n as i32)
            }
        }

        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum PromptType {
            Normal,
            Number,
            Search,
            CompleteIntro(usize),
            CompleteMore,
        }

        impl PromptType {
            pub fn is_normal(&self) -> bool {
                *self == PromptType::Normal
            }
        }

        impl<'a, 'b, Term: 'b + Terminal> Deref for WriterImpl<'a, 'b, Term> {
            type Target = WriteLock<'b, Term>;

            fn deref(&self) -> &WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex(ref m) => m,
                    WriterImpl::MutRef(ref m) => m,
                }
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> DerefMut for WriterImpl<'a, 'b, Term> {
            fn deref_mut(&mut self) -> &mut WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex(ref mut m) => m,
                    WriterImpl::MutRef(ref mut m) => m,
                }
            }
        }
        /// Iterator over `Interface` history entries
        pub struct HistoryIter<'a>(vec_deque::Iter<'a, String>);

        impl<'a> ExactSizeIterator for HistoryIter<'a> {}

        impl<'a> Iterator for HistoryIter<'a> {
            type Item = &'a str;

            #[inline]
            fn next(&mut self) -> Option<&'a str> {
                self.0.next().map(|s| &s[..])
            }

            #[inline]
            fn nth(&mut self, n: usize) -> Option<&'a str> {
                self.0.nth(n).map(|s| &s[..])
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.0.size_hint()
            }
        }

        impl<'a> DoubleEndedIterator for HistoryIter<'a> {
            #[inline]
            fn next_back(&mut self) -> Option<&'a str> {
                self.0.next_back().map(|s| &s[..])
            }
        }

        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum DisplaySequence {
            Char(char),
            Escape(char),
            End,
        }

        impl Iterator for DisplaySequence {
            type Item = char;

            fn next(&mut self) -> Option<char> {
                use self::DisplaySequence::*;

                let (res, next) = match *self {
                    Char(ch) => (ch, End),
                    Escape(ch) => ('^', Char(ch)),
                    End => return None
                };

                *self = next;
                Some(res)
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                use self::DisplaySequence::*;

                let n = match *self {
                    Char(_) => 1,
                    Escape(_) => 2,
                    End => 0,
                };

                (n, Some(n))
            }
        }

        #[derive(Copy, Clone, Debug, Default)]
        pub struct Display {
            allow_tab: bool,
            allow_newline: bool,
            allow_escape: bool,
        }

        pub fn display(ch: char, style: Display) -> DisplaySequence {
            match ch {
                '\t' if style.allow_tab => DisplaySequence::Char(ch),
                '\n' if style.allow_newline => DisplaySequence::Char(ch),
                ESCAPE if style.allow_escape => DisplaySequence::Char(ch),
                '\0' => DisplaySequence::Escape('@'),
                RUBOUT => DisplaySequence::Escape('?'),
                ch if is_ctrl(ch) => DisplaySequence::Escape(unctrl(ch)),
                ch => DisplaySequence::Char(ch)
            }
        }

        pub fn display_str<'a>(s: &'a str, style: Display) -> Cow<'a, str> {
            if s.chars().all(|ch| display(ch, style) == DisplaySequence::Char(ch)) {
                Borrowed(s)
            } else {
                Owned(s.chars().flat_map(|ch| display(ch, style)).collect())
            }
        }

        fn complete_intro(n: usize) -> String {
            format!("Display all {} possibilities? (y/n)", n)
        }

        fn number_len(n: i32) -> usize {
            match n {
                -1_000_000              => 8,
                -  999_999 ..= -100_000 => 7,
                -   99_999 ..= - 10_000 => 6,
                -    9_999 ..= -  1_000 => 5,
                -      999 ..= -    100 => 4,
                -       99 ..= -     10 => 3,
                -        9 ..= -      1 => 2,
                        0 ..=        9 => 1,
                        10 ..=       99 => 2,
                    100 ..=      999 => 3,
                    1_000 ..=    9_999 => 4,
                    10_000 ..=   99_999 => 5,
                100_000 ..=  999_999 => 6,
                1_000_000              => 7,
                _ => unreachable!()
            }
        }
    }

    pub mod system
    {
        use ::
        {
            *,
        };

        pub mod unix
        {

        }

        pub mod windows
        {
            
        }
    }
    #[cfg(unix)] pub use self::system::unix as sys;
    #[cfg(windows)] pub use self::system::windows as sys;
    /*
    #[cfg(unix)]
    #[path = "unix/mod.rs"]
    mod sys;

    #[cfg(windows)]
    #[path = "windows/mod.rs"]
    mod sys;
    */
}

pub mod pest
{
    //! # pest. The Elegant Parser
    use ::
    {
        *,
    };

    pub mod derive
    {
        use ::
        {
            *,
        };
    }

    pub use crate::parser::Parser;
    pub use crate::parser_state::{
        set_call_limit, set_error_detail, state, Atomicity, Lookahead, MatchDir, ParseResult,
        ParserState,
    };
    pub use crate::position::Position;
    pub use crate::span::{merge_spans, Lines, LinesSpan, Span};
    pub use crate::stack::Stack;
    pub use crate::token::Token;
    use core::fmt::Debug;
    use core::hash::Hash;

    pub mod error
    {
        //! Types for different kinds of parsing failures.
        use ::
        {
            *,
        };
        

        

        use crate::parser_state::{ParseAttempts, ParsingToken, RulesCallStack};
        use alloc::borrow::Cow;
        use alloc::borrow::ToOwned;
        use alloc::boxed::Box;
        use alloc::collections::{BTreeMap, BTreeSet};
        use alloc::format;
        use alloc::string::String;
        use alloc::string::ToString;
        use alloc::vec;
        use alloc::vec::Vec;
        use core::cmp;
        use core::fmt;
        use core::mem;

        use crate::position::Position;
        use crate::span::Span;
        use crate::RuleType;

        /// Parse-related error type.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        #[cfg_attr(feature = "std", derive(thiserror::Error))]
        pub struct Error<R> {
            /// Variant of the error
            pub variant: ErrorVariant<R>,
            /// Location within the input string
            pub location: InputLocation,
            /// Line/column within the input string
            pub line_col: LineColLocation,
            path: Option<String>,
            line: String,
            continued_line: Option<String>,
            parse_attempts: Option<ParseAttempts<R>>,
        }
        /// Different kinds of parsing errors.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        #[cfg_attr(feature = "std", derive(thiserror::Error))]
        pub enum ErrorVariant<R> {
            /// Generated parsing error with expected and unexpected `Rule`s
            ParsingError {
                /// Positive attempts
                positives: Vec<R>,
                /// Negative attempts
                negatives: Vec<R>,
            },
            /// Custom error with a message
            CustomError {
                /// Short explanation
                message: String,
            },
        }
        /// Where an `Error` has occurred.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub enum InputLocation {
            /// `Error` was created by `Error::new_from_pos`
            Pos(usize),
            /// `Error` was created by `Error::new_from_span`
            Span((usize, usize)),
        }
        /// Line/column where an `Error` has occurred.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub enum LineColLocation {
            /// Line/column pair if `Error` was created by `Error::new_from_pos`
            Pos((usize, usize)),
            /// Line/column pairs if `Error` was created by `Error::new_from_span`
            Span((usize, usize), (usize, usize)),
        }

        impl From<Position<'_>> for LineColLocation {
            fn from(value: Position<'_>) -> Self {
                Self::Pos(value.line_col())
            }
        }

        impl From<Span<'_>> for LineColLocation {
            fn from(value: Span<'_>) -> Self {
                let (start, end) = value.split();
                Self::Span(start.line_col(), end.line_col())
            }
        }
        /// Function mapping rule to its helper message defined by user.
        pub type RuleToMessageFn<R> = Box<dyn Fn(&R) -> Option<String>>;
        /// Function mapping string element to bool denoting whether it's a whitespace defined by user.
        pub type IsWhitespaceFn = Box<dyn Fn(String) -> bool>;

        impl ParsingToken {
            pub fn is_whitespace(&self, is_whitespace: &IsWhitespaceFn) -> bool {
                match self {
                    ParsingToken::Sensitive { token } => is_whitespace(token.clone()),
                    ParsingToken::Insensitive { token } => is_whitespace(token.clone()),
                    ParsingToken::Range { .. } => false,
                    ParsingToken::BuiltInRule => false,
                }
            }
        }

        impl<R: RuleType> ParseAttempts<R> {
            /// Helper formatting function to get message informing about tokens we've
            /// (un)expected to see.
            /// Used as a part of `parse_attempts_error`.
            fn tokens_helper_messages(
                &self,
                is_whitespace_fn: &IsWhitespaceFn,
                spacing: &str,
            ) -> Vec<String> {
                let mut helper_messages = Vec::new();
                let tokens_header_pairs = vec![
                    (self.expected_tokens(), "expected"),
                    (self.unexpected_tokens(), "unexpected"),
                ];

                for (tokens, header) in &tokens_header_pairs {
                    if tokens.is_empty() {
                        continue;
                    }

                    let mut helper_tokens_message = format!("{spacing}note: {header} ");
                    helper_tokens_message.push_str(if tokens.len() == 1 {
                        "token: "
                    } else {
                        "one of tokens: "
                    });

                    let expected_tokens_set: BTreeSet<String> = tokens
                        .iter()
                        .map(|token| {
                            if token.is_whitespace(is_whitespace_fn) {
                                String::from("WHITESPACE")
                            } else {
                                format!("`{}`", token)
                            }
                        })
                        .collect();

                    helper_tokens_message.push_str(
                        &expected_tokens_set
                            .iter()
                            .cloned()
                            .collect::<Vec<String>>()
                            .join(", "),
                    );
                    helper_messages.push(helper_tokens_message);
                }

                helper_messages
            }
        }

        impl<R: RuleType> Error<R> {
            /// Creates `Error` from `ErrorVariant` and `Position`.
            pub fn new_from_pos(variant: ErrorVariant<R>, pos: Position<'_>) -> Error<R> {
                let visualize_ws = pos.match_char('\n') || pos.match_char('\r');
                let line_of = pos.line_of();
                let line = if visualize_ws {
                    visualize_whitespace(line_of)
                } else {
                    line_of.replace(&['\r', '\n'][..], "")
                };
                Error {
                    variant,
                    location: InputLocation::Pos(pos.pos()),
                    path: None,
                    line,
                    continued_line: None,
                    line_col: LineColLocation::Pos(pos.line_col()),
                    parse_attempts: None,
                }
            }
            /// Wrapper function to track `parse_attempts` as a result of `state` function call in `parser_state.rs`.
            pub fn new_from_pos_with_parsing_attempts(
                variant: ErrorVariant<R>,
                pos: Position<'_>,
                parse_attempts: ParseAttempts<R>,
            ) -> Error<R> {
                let mut error = Self::new_from_pos(variant, pos);
                error.parse_attempts = Some(parse_attempts);
                error
            }
            /// Creates `Error` from `ErrorVariant` and `Span`.
            pub fn new_from_span(variant: ErrorVariant<R>, span: Span<'_>) -> Error<R> {
                let end = span.end_pos();
                let mut end_line_col = end.line_col();
                // end position is after a \n, so we want to point to the visual lf symbol
                if end_line_col.1 == 1 {
                    let mut visual_end = end;
                    visual_end.skip_back(1);
                    let lc = visual_end.line_col();
                    end_line_col = (lc.0, lc.1 + 1);
                };

                let mut line_iter = span.lines();
                let sl = line_iter.next().unwrap_or("");
                let mut chars = span.as_str().chars();
                let visualize_ws = matches!(chars.next(), Some('\n') | Some('\r'))
                    || matches!(chars.last(), Some('\n') | Some('\r'));
                let start_line = if visualize_ws {
                    visualize_whitespace(sl)
                } else {
                    sl.to_owned().replace(&['\r', '\n'][..], "")
                };
                let ll = line_iter.last();
                let continued_line = if visualize_ws {
                    ll.map(str::to_owned)
                } else {
                    ll.map(visualize_whitespace)
                };

                Error {
                    variant,
                    location: InputLocation::Span((span.start(), end.pos())),
                    path: None,
                    line: start_line,
                    continued_line,
                    line_col: LineColLocation::Span(span.start_pos().line_col(), end_line_col),
                    parse_attempts: None,
                }
            }
            /// Returns `Error` variant with `path` which is shown when formatted with `Display`.
            pub fn with_path(mut self, path: &str) -> Error<R> {
                self.path = Some(path.to_owned());

                self
            }
            /// Returns the path set using [`Error::with_path()`].
            pub fn path(&self) -> Option<&str> {
                self.path.as_deref()
            }
            /// Returns the line that the error is on.
            pub fn line(&self) -> &str {
                self.line.as_str()
            }
            /// Renames all `Rule`s if this is a [`ParsingError`]. It does nothing when called on a [`CustomError`].
            pub fn renamed_rules<F>(mut self, f: F) -> Error<R>
            where
                F: FnMut(&R) -> String,
            {
                let variant = match self.variant {
                    ErrorVariant::ParsingError {
                        positives,
                        negatives,
                    } => {
                        let message = Error::parsing_error_message(&positives, &negatives, f);
                        ErrorVariant::CustomError { message }
                    }
                    variant => variant,
                };

                self.variant = variant;

                self
            }
            /// Get detailed information about errored rules sequence.
            pub fn parse_attempts(&self) -> Option<ParseAttempts<R>> {
                self.parse_attempts.clone()
            }
            /// Get error message based on parsing attempts.
            pub fn parse_attempts_error(
                &self,
                input: &str,
                rule_to_message: &RuleToMessageFn<R>,
                is_whitespace: &IsWhitespaceFn,
            ) -> Option<Error<R>> {
                let attempts = if let Some(ref parse_attempts) = self.parse_attempts {
                    parse_attempts.clone()
                } else {
                    return None;
                };

                let spacing = self.spacing() + "   ";
                let error_position = attempts.max_position;
                let message = {
                    let mut help_lines: Vec<String> = Vec::new();
                    help_lines.push(String::from("error: parsing error occurred."));

                    // Note: at least one of `(un)expected_tokens` must not be empty.
                    for tokens_helper_message in attempts.tokens_helper_messages(is_whitespace, &spacing) {
                        help_lines.push(tokens_helper_message);
                    }

                    let call_stacks = attempts.call_stacks();
                    // Group call stacks by their parents so that we can print common header and
                    // several sub helper messages.
                    let mut call_stacks_parents_groups: BTreeMap<Option<R>, Vec<RulesCallStack<R>>> =
                        BTreeMap::new();
                    for call_stack in call_stacks {
                        call_stacks_parents_groups
                            .entry(call_stack.parent)
                            .or_default()
                            .push(call_stack);
                    }

                    for (group_parent, group) in call_stacks_parents_groups {
                        if let Some(parent_rule) = group_parent {
                            let mut contains_meaningful_info = false;
                            help_lines.push(format!(
                                "{spacing}help: {}",
                                if let Some(message) = rule_to_message(&parent_rule) {
                                    contains_meaningful_info = true;
                                    message
                                } else {
                                    String::from("[Unknown parent rule]")
                                }
                            ));
                            for call_stack in group {
                                if let Some(r) = call_stack.deepest.get_rule() {
                                    if let Some(message) = rule_to_message(r) {
                                        contains_meaningful_info = true;
                                        help_lines.push(format!("{spacing}      - {message}"));
                                    }
                                }
                            }
                            if !contains_meaningful_info {
                                // Have to remove useless line for unknown parent rule.
                                help_lines.pop();
                            }
                        } else {
                            for call_stack in group {
                                // Note that `deepest` rule may be `None`. E.g. in case it corresponds
                                // to WHITESPACE expected token which has no parent rule (on the top level
                                // parsing).
                                if let Some(r) = call_stack.deepest.get_rule() {
                                    let helper_message = rule_to_message(r);
                                    if let Some(helper_message) = helper_message {
                                        help_lines.push(format!("{spacing}help: {helper_message}"));
                                    }
                                }
                            }
                        }
                    }

                    help_lines.join("\n")
                };
                let error = Error::new_from_pos(
                    ErrorVariant::CustomError { message },
                    Position::new_internal(input, error_position),
                );
                Some(error)
            }

            fn start(&self) -> (usize, usize) {
                match self.line_col {
                    LineColLocation::Pos(line_col) => line_col,
                    LineColLocation::Span(start_line_col, _) => start_line_col,
                }
            }

            fn spacing(&self) -> String {
                let line = match self.line_col {
                    LineColLocation::Pos((line, _)) => line,
                    LineColLocation::Span((start_line, _), (end_line, _)) => cmp::max(start_line, end_line),
                };

                let line_str_len = format!("{}", line).len();

                let mut spacing = String::new();
                for _ in 0..line_str_len {
                    spacing.push(' ');
                }

                spacing
            }

            fn underline(&self) -> String {
                let mut underline = String::new();

                let mut start = self.start().1;
                let end = match self.line_col {
                    LineColLocation::Span(_, (_, mut end)) => {
                        let inverted_cols = start > end;
                        if inverted_cols {
                            mem::swap(&mut start, &mut end);
                            start -= 1;
                            end += 1;
                        }

                        Some(end)
                    }
                    _ => None,
                };
                let offset = start - 1;
                let line_chars = self.line.chars();

                for c in line_chars.take(offset) {
                    match c {
                        '\t' => underline.push('\t'),
                        _ => underline.push(' '),
                    }
                }

                if let Some(end) = end {
                    underline.push('^');
                    if end - start > 1 {
                        for _ in 2..(end - start) {
                            underline.push('-');
                        }
                        underline.push('^');
                    }
                } else {
                    underline.push_str("^---")
                }

                underline
            }

            fn message(&self) -> String {
                self.variant.message().to_string()
            }

            fn parsing_error_message<F>(positives: &[R], negatives: &[R], mut f: F) -> String
            where
                F: FnMut(&R) -> String,
            {
                match (negatives.is_empty(), positives.is_empty()) {
                    (false, false) => format!(
                        "unexpected {}; expected {}",
                        Error::enumerate(negatives, &mut f),
                        Error::enumerate(positives, &mut f)
                    ),
                    (false, true) => format!("unexpected {}", Error::enumerate(negatives, &mut f)),
                    (true, false) => format!("expected {}", Error::enumerate(positives, &mut f)),
                    (true, true) => "unknown parsing error".to_owned(),
                }
            }

            fn enumerate<F>(rules: &[R], f: &mut F) -> String
            where
                F: FnMut(&R) -> String,
            {
                match rules.len() {
                    1 => f(&rules[0]),
                    2 => format!("{} or {}", f(&rules[0]), f(&rules[1])),
                    l => {
                        let non_separated = f(&rules[l - 1]);
                        let separated = rules
                            .iter()
                            .take(l - 1)
                            .map(f)
                            .collect::<Vec<_>>()
                            .join(", ");
                        format!("{}, or {}", separated, non_separated)
                    }
                }
            }

            pub fn format(&self) -> String {
                let spacing = self.spacing();
                let path = self
                    .path
                    .as_ref()
                    .map(|path| format!("{}:", path))
                    .unwrap_or_default();

                let pair = (self.line_col.clone(), &self.continued_line);
                if let (LineColLocation::Span(_, end), Some(ref continued_line)) = pair {
                    let has_line_gap = end.0 - self.start().0 > 1;
                    if has_line_gap {
                        format!(
                            "{s    }--> {p}{ls}:{c}\n\
                            {s    } |\n\
                            {ls:w$} | {line}\n\
                            {s    } | ...\n\
                            {le:w$} | {continued_line}\n\
                            {s    } | {underline}\n\
                            {s    } |\n\
                            {s    } = {message}",
                            s = spacing,
                            w = spacing.len(),
                            p = path,
                            ls = self.start().0,
                            le = end.0,
                            c = self.start().1,
                            line = self.line,
                            continued_line = continued_line,
                            underline = self.underline(),
                            message = self.message()
                        )
                    } else {
                        format!(
                            "{s    }--> {p}{ls}:{c}\n\
                            {s    } |\n\
                            {ls:w$} | {line}\n\
                            {le:w$} | {continued_line}\n\
                            {s    } | {underline}\n\
                            {s    } |\n\
                            {s    } = {message}",
                            s = spacing,
                            w = spacing.len(),
                            p = path,
                            ls = self.start().0,
                            le = end.0,
                            c = self.start().1,
                            line = self.line,
                            continued_line = continued_line,
                            underline = self.underline(),
                            message = self.message()
                        )
                    }
                } else {
                    format!(
                        "{s}--> {p}{l}:{c}\n\
                        {s} |\n\
                        {l} | {line}\n\
                        {s} | {underline}\n\
                        {s} |\n\
                        {s} = {message}",
                        s = spacing,
                        p = path,
                        l = self.start().0,
                        c = self.start().1,
                        line = self.line,
                        underline = self.underline(),
                        message = self.message()
                    )
                }
            }

            #[cfg(feature = "miette-error")]
            /// Turns an error into a [miette](crates.io/miette) Diagnostic.
            pub fn into_miette(self) -> impl ::miette::Diagnostic {
                miette_adapter::MietteAdapter(self)
            }
        }

        impl<R: RuleType> ErrorVariant<R> {
            ///
            /// Returns the error message for [`ErrorVariant`].
            pub fn message(&self) -> Cow<'_, str> {
                match self {
                    ErrorVariant::ParsingError {
                        ref positives,
                        ref negatives,
                    } => Cow::Owned(Error::parsing_error_message(positives, negatives, |r| {
                        format!("{:?}", r)
                    })),
                    ErrorVariant::CustomError { ref message } => Cow::Borrowed(message),
                }
            }
        }

        impl<R: RuleType> fmt::Display for Error<R> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, "{}", self.format())
            }
        }

        impl<R: RuleType> fmt::Display for ErrorVariant<R> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    ErrorVariant::ParsingError { .. } => write!(f, "parsing error: {}", self.message()),
                    ErrorVariant::CustomError { .. } => write!(f, "{}", self.message()),
                }
            }
        }

        fn visualize_whitespace(input: &str) -> String {
            input.to_owned().replace('\r', "").replace('\n', "")
        }

        #[cfg(feature = "miette-error")]
        mod miette_adapter {
            use alloc::string::ToString;
            use std::boxed::Box;

            use crate::error::LineColLocation;

            use super::{Error, RuleType};

            use miette::{Diagnostic, LabeledSpan, SourceCode};

            #[derive(thiserror::Error, Debug)]
            #[error("Failure to parse at {:?}", self.0.line_col)]
            pub struct MietteAdapter<R: RuleType>(pub Error<R>);

            impl<R: RuleType> Diagnostic for MietteAdapter<R> {
                fn source_code(&self) -> Option<&dyn SourceCode> {
                    Some(&self.0.line)
                }

                fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan>>> {
                    let message = self.0.variant.message().to_string();

                    let (offset, length) = match self.0.line_col {
                        LineColLocation::Pos((_, c)) => (c - 1, 1),
                        LineColLocation::Span((_, start_c), (_, end_c)) => {
                            (start_c - 1, end_c - start_c + 1)
                        }
                    };

                    let span = LabeledSpan::new(Some(message), offset, length);

                    Some(Box::new(std::iter::once(span)))
                }

                fn help<'a>(&'a self) -> Option<Box<dyn core::fmt::Display + 'a>> {
                    Some(Box::new(self.0.message()))
                }
            }
        }
    }

    pub mod iterators
    {
        //! Types and iterators for parser output.
        use ::
        {
            *,
        };
        

        

        pub mod flat_pairs
        {
            use ::
            {
                *,
            };
            // pest. The Elegant Parser
            // Copyright (c) 2018 Drago Tiselice
            //
            // Licensed under the Apache License, Version 2.0
            // <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
            // license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. All files in the project carrying such notice may not be copied,
            // modified, or distributed except according to those terms.

            use alloc::rc::Rc;
            use alloc::vec::Vec;
            use core::fmt;

            use super::line_index::LineIndex;
            use super::pair::{self, Pair};
            use super::queueable_token::QueueableToken;
            use super::tokens::{self, Tokens};
            use crate::RuleType;

            /// An iterator over [`Pair`]s. It is created by [`Pairs::flatten`].
            ///
            /// [`Pair`]: struct.Pair.html
            /// [`Pairs::flatten`]: struct.Pairs.html#method.flatten
            pub struct FlatPairs<'i, R> {
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                start: usize,
                end: usize,
                line_index: Rc<LineIndex>,
            }

            pub fn new<'i, R: RuleType>(
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                line_index: Rc<LineIndex>,
                start: usize,
                end: usize,
            ) -> FlatPairs<'i, R> {
                FlatPairs {
                    queue,
                    input,
                    line_index,
                    start,
                    end,
                }
            }

            impl<'i, R: RuleType> FlatPairs<'i, R> {
                /// Returns the `Tokens` for these pairs.
                #[inline]
                pub fn tokens(self) -> Tokens<'i, R> {
                    tokens::new(self.queue, self.input, self.start, self.end)
                }

                fn next_start(&mut self) {
                    self.start += 1;

                    while self.start < self.end && !self.is_start(self.start) {
                        self.start += 1;
                    }
                }

                fn next_start_from_end(&mut self) {
                    self.end -= 1;

                    while self.end >= self.start && !self.is_start(self.end) {
                        self.end -= 1;
                    }
                }

                fn is_start(&self, index: usize) -> bool {
                    match self.queue[index] {
                        QueueableToken::Start { .. } => true,
                        QueueableToken::End { .. } => false,
                    }
                }
            }

            impl<'i, R: RuleType> ExactSizeIterator for FlatPairs<'i, R> {
                fn len(&self) -> usize {
                    // Tokens len is exactly twice as flatten pairs len
                    (self.end - self.start) >> 1
                }
            }

            impl<'i, R: RuleType> Iterator for FlatPairs<'i, R> {
                type Item = Pair<'i, R>;

                fn next(&mut self) -> Option<Self::Item> {
                    if self.start >= self.end {
                        return None;
                    }

                    let pair = pair::new(
                        Rc::clone(&self.queue),
                        self.input,
                        Rc::clone(&self.line_index),
                        self.start,
                    );
                    self.next_start();

                    Some(pair)
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    let len = <Self as ExactSizeIterator>::len(self);
                    (len, Some(len))
                }
            }

            impl<'i, R: RuleType> DoubleEndedIterator for FlatPairs<'i, R> {
                fn next_back(&mut self) -> Option<Self::Item> {
                    if self.end <= self.start {
                        return None;
                    }

                    self.next_start_from_end();

                    let pair = pair::new(
                        Rc::clone(&self.queue),
                        self.input,
                        Rc::clone(&self.line_index),
                        self.end,
                    );

                    Some(pair)
                }
            }

            impl<'i, R: RuleType> fmt::Debug for FlatPairs<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_struct("FlatPairs")
                        .field("pairs", &self.clone().collect::<Vec<_>>())
                        .finish()
                }
            }

            impl<'i, R: Clone> Clone for FlatPairs<'i, R> {
                fn clone(&self) -> FlatPairs<'i, R> {
                    FlatPairs {
                        queue: Rc::clone(&self.queue),
                        input: self.input,
                        line_index: Rc::clone(&self.line_index),
                        start: self.start,
                        end: self.end,
                    }
                }
            }
        }

        pub mod line_index
        {
            //! `LineIndex` to make a line_offsets, each item is an byte offset (start from 0) of the beginning of the line.
            use ::
            {
                *,
            };
            
            use alloc::vec::Vec;

            #[derive(Clone)]
            pub struct LineIndex {
                /// Offset (bytes) the the beginning of each line, zero-based
                line_offsets: Vec<usize>,
            }

            impl LineIndex {
                pub fn new(text: &str) -> LineIndex {
                    let mut line_offsets: Vec<usize> = alloc::vec![0];

                    let mut offset = 0;

                    for c in text.chars() {
                        offset += c.len_utf8();
                        if c == '\n' {
                            line_offsets.push(offset);
                        }
                    }

                    LineIndex { line_offsets }
                }
                /// Returns (line, col) of pos.
                ///
                /// The pos is a byte offset, start from 0, e.g. "ab" is 2, "" is 6
                pub fn line_col(&self, input: &str, pos: usize) -> (usize, usize) {
                    let line = self.line_offsets.partition_point(|&it| it <= pos) - 1;
                    let first_offset = self.line_offsets[line];

                    // Get line str from original input, then we can get column offset
                    let line_str = &input[first_offset..pos];
                    let col = line_str.chars().count();

                    (line + 1, col + 1)
                }
            }
        }

        pub mod pair
        {
            use ::
            {
                *,
            };
            // pest. The Elegant Parser
            // Copyright (c) 2018 Drago Tiselice
            //
            // Licensed under the Apache License, Version 2.0
            // <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
            // license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. All files in the project carrying such notice may not be copied,
            // modified, or distributed except according to those terms.

            use alloc::format;
            use alloc::rc::Rc;
            #[cfg(feature = "pretty-print")]
            use alloc::string::String;
            use alloc::vec::Vec;
            use core::borrow::Borrow;
            use core::fmt;
            use core::hash::{Hash, Hasher};
            use core::ptr;
            use core::str;

            #[cfg(feature = "pretty-print")]
            use serde::ser::SerializeStruct;

            use super::line_index::LineIndex;
            use super::pairs::{self, Pairs};
            use super::queueable_token::QueueableToken;
            use super::tokens::{self, Tokens};
            use crate::span::Span;
            use crate::RuleType;

            /// A matching pair of [`Token`]s and everything between them.
            #[derive(Clone)]
            pub struct Pair<'i, R> {
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                /// Token index into `queue`.
                start: usize,
                line_index: Rc<LineIndex>,
            }

            pub fn new<'i, R: RuleType>(
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                line_index: Rc<LineIndex>,
                start: usize,
            ) -> Pair<'i, R> {
                Pair {
                    queue,
                    input,
                    start,
                    line_index,
                }
            }

            impl<'i, R: RuleType> Pair<'i, R> {
                /// Returns the `Rule` of the `Pair`.
                #[inline]
                pub fn as_rule(&self) -> R {
                    match self.queue[self.pair()] {
                        QueueableToken::End { rule, .. } => rule,
                        _ => unreachable!(),
                    }
                }
                /// Captures a slice from the `&str` defined by the token `Pair`.
                #[inline]
                pub fn as_str(&self) -> &'i str {
                    let start = self.pos(self.start);
                    let end = self.pos(self.pair());

                    // Generated positions always come from Positions and are UTF-8 borders.
                    &self.input[start..end]
                }
                /// Returns the input string of the `Pair`.
                pub fn get_input(&self) -> &'i str {
                    self.input
                }
                /// Returns the `Span` defined by the `Pair`, consuming it.
                #[inline]
                #[deprecated(since = "2.0.0", note = "Please use `as_span` instead")]
                pub fn into_span(self) -> Span<'i> {
                    self.as_span()
                }
                /// Returns the `Span` defined by the `Pair`, **without** consuming it.
                #[inline]
                pub fn as_span(&self) -> Span<'i> {
                    let start = self.pos(self.start);
                    let end = self.pos(self.pair());

                    Span::new_internal(self.input, start, end)
                }
                /// Get current node tag
                #[inline]
                pub fn as_node_tag(&self) -> Option<&str> {
                    match &self.queue[self.pair()] {
                        QueueableToken::End { tag, .. } => tag.as_ref().map(|x| x.borrow()),
                        _ => None,
                    }
                }
                /// Returns the inner `Pairs` between the `Pair`, consuming it.
                #[inline]
                pub fn into_inner(self) -> Pairs<'i, R> {
                    let pair = self.pair();

                    pairs::new(
                        self.queue,
                        self.input,
                        Some(self.line_index),
                        self.start + 1,
                        pair,
                    )
                }
                /// Returns the `Tokens` for the `Pair`.
                #[inline]
                pub fn tokens(self) -> Tokens<'i, R> {
                    let end = self.pair();

                    tokens::new(self.queue, self.input, self.start, end + 1)
                }
                /// Generates a string that stores the lexical information of `self` in a pretty-printed JSON format.
                #[cfg(feature = "pretty-print")]
                pub fn to_json(&self) -> String {
                    ::serde_json::to_string_pretty(self).expect("Failed to pretty-print Pair to json.")
                }
                /// Returns the `line`, `col` of this pair start.
                pub fn line_col(&self) -> (usize, usize) {
                    let pos = self.pos(self.start);
                    self.line_index.line_col(self.input, pos)
                }

                fn pair(&self) -> usize {
                    match self.queue[self.start] {
                        QueueableToken::Start {
                            end_token_index, ..
                        } => end_token_index,
                        _ => unreachable!(),
                    }
                }

                fn pos(&self, index: usize) -> usize {
                    match self.queue[index] {
                        QueueableToken::Start { input_pos, .. } | QueueableToken::End { input_pos, .. } => {
                            input_pos
                        }
                    }
                }
            }

            impl<'i, R: RuleType> Pairs<'i, R> {
                /// Create a new `Pairs` iterator containing just the single `Pair`.
                pub fn single(pair: Pair<'i, R>) -> Self {
                    let end = pair.pair();
                    pairs::new(
                        pair.queue,
                        pair.input,
                        Some(pair.line_index),
                        pair.start,
                        end,
                    )
                }
            }

            impl<'i, R: RuleType> fmt::Debug for Pair<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let pair = &mut f.debug_struct("Pair");
                    pair.field("rule", &self.as_rule());
                    // In order not to break compatibility
                    if let Some(s) = self.as_node_tag() {
                        pair.field("node_tag", &s);
                    }
                    pair.field("span", &self.as_span())
                        .field("inner", &self.clone().into_inner().collect::<Vec<_>>())
                        .finish()
                }
            }

            impl<'i, R: RuleType> fmt::Display for Pair<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let rule = self.as_rule();
                    let start = self.pos(self.start);
                    let end = self.pos(self.pair());
                    let mut pairs = self.clone().into_inner().peekable();

                    if pairs.peek().is_none() {
                        write!(f, "{:?}({}, {})", rule, start, end)
                    } else {
                        write!(
                            f,
                            "{:?}({}, {}, [{}])",
                            rule,
                            start,
                            end,
                            pairs
                                .map(|pair| format!("{}", pair))
                                .collect::<Vec<_>>()
                                .join(", ")
                        )
                    }
                }
            }

            impl<'i, R: PartialEq> PartialEq for Pair<'i, R> {
                fn eq(&self, other: &Pair<'i, R>) -> bool {
                    Rc::ptr_eq(&self.queue, &other.queue)
                        && ptr::eq(self.input, other.input)
                        && self.start == other.start
                }
            }

            impl<'i, R: Eq> Eq for Pair<'i, R> {}

            impl<'i, R: Hash> Hash for Pair<'i, R> {
                fn hash<H: Hasher>(&self, state: &mut H) {
                    (&*self.queue as *const Vec<QueueableToken<'i, R>>).hash(state);
                    (self.input as *const str).hash(state);
                    self.start.hash(state);
                }
            }

            #[cfg(feature = "pretty-print")]
            impl<'i, R: RuleType> ::serde::Serialize for Pair<'i, R> {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where
                    S: ::serde::Serializer,
                {
                    let start = self.pos(self.start);
                    let end = self.pos(self.pair());
                    let rule = format!("{:?}", self.as_rule());
                    let inner = self.clone().into_inner();

                    let mut ser = serializer.serialize_struct("Pairs", 3)?;
                    ser.serialize_field("pos", &(start, end))?;
                    ser.serialize_field("rule", &rule)?;

                    if inner.peek().is_none() {
                        ser.serialize_field("inner", &self.as_str())?;
                    } else {
                        ser.serialize_field("inner", &inner)?;
                    }

                    ser.end()
                }
            }
        }

        pub mod pairs
        {
            use ::
            {
                *,
            };
            // pest. The Elegant Parser
            // Copyright (c) 2018 Drago Tiselice
            //
            // Licensed under the Apache License, Version 2.0
            // <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
            // license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. All files in the project carrying such notice may not be copied,
            // modified, or distributed except according to those terms.

            use alloc::format;
            use alloc::rc::Rc;
            use alloc::string::String;
            use alloc::vec::Vec;
            use core::fmt;
            use core::hash::{Hash, Hasher};
            use core::iter::Filter;
            use core::ptr;
            use core::str;

            #[cfg(feature = "pretty-print")]
            use serde::ser::SerializeStruct;

            use super::flat_pairs::{self, FlatPairs};
            use super::line_index::LineIndex;
            use super::pair::{self, Pair};
            use super::queueable_token::QueueableToken;
            use super::tokens::{self, Tokens};
            use crate::RuleType;

            /// An iterator over [`Pair`]s. It is created by [`pest::state`] and [`Pair::into_inner`].
            ///
            /// [`Pair`]: struct.Pair.html
            /// [`pest::state`]: ../fn.state.html
            /// [`Pair::into_inner`]: struct.Pair.html#method.into_inner
            #[derive(Clone)]
            pub struct Pairs<'i, R> {
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                start: usize,
                end: usize,
                pairs_count: usize,
                line_index: Rc<LineIndex>,
            }

            pub fn new<'i, R: RuleType>(
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                line_index: Option<Rc<LineIndex>>,
                start: usize,
                end: usize,
            ) -> Pairs<'i, R> {
                let line_index = match line_index {
                    Some(line_index) => line_index,
                    None => {
                        let last_input_pos = queue
                            .last()
                            .map(|token| match *token {
                                QueueableToken::Start { input_pos, .. }
                                | QueueableToken::End { input_pos, .. } => input_pos,
                            })
                            .unwrap_or(0);

                        Rc::new(LineIndex::new(&input[..last_input_pos]))
                    }
                };

                let mut pairs_count = 0;
                let mut cursor = start;
                while cursor < end {
                    cursor = match queue[cursor] {
                        QueueableToken::Start {
                            end_token_index, ..
                        } => end_token_index,
                        _ => unreachable!(),
                    } + 1;
                    pairs_count += 1;
                }

                Pairs {
                    queue,
                    input,
                    start,
                    end,
                    pairs_count,
                    line_index,
                }
            }

            impl<'i, R: RuleType> Pairs<'i, R> {
                /// Captures a slice from the `&str` defined by the starting position of the first token `Pair`
                /// and the ending position of the last token `Pair` of the `Pairs`.
                #[inline]
                pub fn as_str(&self) -> &'i str {
                    if self.start < self.end {
                        let start = self.pos(self.start);
                        let end = self.pos(self.end - 1);
                        // Generated positions always come from Positions and are UTF-8 borders.
                        &self.input[start..end]
                    } else {
                        ""
                    }
                }
                /// Returns the input string of `Pairs`.
                pub fn get_input(&self) -> &'i str {
                    self.input
                }
                /// Captures inner token `Pair`s and concatenates resulting `&str`s. This does not capture
                /// the input between token `Pair`s.
                #[inline]
                pub fn concat(&self) -> String {
                    self.clone()
                        .fold(String::new(), |string, pair| string + pair.as_str())
                }
                /// Flattens the `Pairs`.
                #[inline]
                pub fn flatten(self) -> FlatPairs<'i, R> {
                    flat_pairs::new(
                        self.queue,
                        self.input,
                        self.line_index,
                        self.start,
                        self.end,
                    )
                }
                /// Finds the first pair that has its node or branch tagged with the provided
                /// label. Searches in the flattened [`Pairs`] iterator.
                #[inline]
                pub fn find_first_tagged(&self, tag: &'i str) -> Option<Pair<'i, R>> {
                    self.clone().find_tagged(tag).next()
                }
                /// Returns the iterator over pairs that have their node or branch tagged
                /// with the provided label. The iterator is built from a flattened [`Pairs`] iterator.
                #[inline]
                pub fn find_tagged(
                    self,
                    tag: &'i str,
                ) -> Filter<FlatPairs<'i, R>, impl FnMut(&Pair<'i, R>) -> bool + '_> {
                    self.flatten()
                        .filter(move |pair: &Pair<'i, R>| matches!(pair.as_node_tag(), Some(nt) if nt == tag))
                }
                /// Returns the `Tokens` for the `Pairs`.
                #[inline]
                pub fn tokens(self) -> Tokens<'i, R> {
                    tokens::new(self.queue, self.input, self.start, self.end)
                }
                /// Peek at the first inner `Pair` without changing the position of this iterator.
                #[inline]
                pub fn peek(&self) -> Option<Pair<'i, R>> {
                    if self.start < self.end {
                        Some(pair::new(
                            Rc::clone(&self.queue),
                            self.input,
                            Rc::clone(&self.line_index),
                            self.start,
                        ))
                    } else {
                        None
                    }
                }
                /// Generates a string that stores the lexical information of `self` in a pretty-printed JSON format.
                #[cfg(feature = "pretty-print")]
                pub fn to_json(&self) -> String {
                    ::serde_json::to_string_pretty(self).expect("Failed to pretty-print Pairs to json.")
                }

                fn pair(&self) -> usize {
                    match self.queue[self.start] {
                        QueueableToken::Start {
                            end_token_index, ..
                        } => end_token_index,
                        _ => unreachable!(),
                    }
                }

                fn pair_from_end(&self) -> usize {
                    match self.queue[self.end - 1] {
                        QueueableToken::End {
                            start_token_index, ..
                        } => start_token_index,
                        _ => unreachable!(),
                    }
                }

                fn pos(&self, index: usize) -> usize {
                    match self.queue[index] {
                        QueueableToken::Start { input_pos, .. } | QueueableToken::End { input_pos, .. } => {
                            input_pos
                        }
                    }
                }
            }

            impl<'i, R: RuleType> ExactSizeIterator for Pairs<'i, R> {
                #[inline]
                fn len(&self) -> usize {
                    self.pairs_count
                }
            }

            impl<'i, R: RuleType> Iterator for Pairs<'i, R> {
                type Item = Pair<'i, R>;

                fn next(&mut self) -> Option<Self::Item> {
                    let pair = self.peek()?;

                    self.start = self.pair() + 1;
                    self.pairs_count -= 1;
                    Some(pair)
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    let len = <Self as ExactSizeIterator>::len(self);
                    (len, Some(len))
                }
            }

            impl<'i, R: RuleType> DoubleEndedIterator for Pairs<'i, R> {
                fn next_back(&mut self) -> Option<Self::Item> {
                    if self.end <= self.start {
                        return None;
                    }

                    self.end = self.pair_from_end();
                    self.pairs_count -= 1;

                    let pair = pair::new(
                        Rc::clone(&self.queue),
                        self.input,
                        Rc::clone(&self.line_index),
                        self.end,
                    );

                    Some(pair)
                }
            }

            impl<'i, R: RuleType> fmt::Debug for Pairs<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_list().entries(self.clone()).finish()
                }
            }

            impl<'i, R: RuleType> fmt::Display for Pairs<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    write!(
                        f,
                        "[{}]",
                        self.clone()
                            .map(|pair| format!("{}", pair))
                            .collect::<Vec<_>>()
                            .join(", ")
                    )
                }
            }

            impl<'i, R: PartialEq> PartialEq for Pairs<'i, R> {
                fn eq(&self, other: &Pairs<'i, R>) -> bool {
                    Rc::ptr_eq(&self.queue, &other.queue)
                        && ptr::eq(self.input, other.input)
                        && self.start == other.start
                        && self.end == other.end
                }
            }

            impl<'i, R: Eq> Eq for Pairs<'i, R> {}

            impl<'i, R: Hash> Hash for Pairs<'i, R> {
                fn hash<H: Hasher>(&self, state: &mut H) {
                    (&*self.queue as *const Vec<QueueableToken<'i, R>>).hash(state);
                    (self.input as *const str).hash(state);
                    self.start.hash(state);
                    self.end.hash(state);
                }
            }

            #[cfg(feature = "pretty-print")]
            impl<'i, R: RuleType> ::serde::Serialize for Pairs<'i, R> {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where
                    S: ::serde::Serializer,
                {
                    let start = self.pos(self.start);
                    let end = self.pos(self.end - 1);
                    let pairs = self.clone().collect::<Vec<_>>();

                    let mut ser = serializer.serialize_struct("Pairs", 2)?;
                    ser.serialize_field("pos", &(start, end))?;
                    ser.serialize_field("pairs", &pairs)?;
                    ser.end()
                }
            }
        }

        pub mod queueable_token
        {
            use ::
            {
                *,
            };

            // pest. The Elegant Parser
            // Copyright (c) 2018 Drago Tiselice
            //
            // Licensed under the Apache License, Version 2.0
            // <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
            // license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. All files in the project carrying such notice may not be copied,
            // modified, or distributed except according to those terms.

            // This structure serves to improve performance over Token objects in two ways:
            //
            //   * it is smaller than a Token, leading to both less memory use when stored in the queue but also
            //     increased speed when pushing to the queue
            //   * it finds its pair in O(1) time instead of O(N), since pair positions are known at parse time
            //     and can easily be stored instead of recomputed
            #[derive(Debug)]
            pub enum QueueableToken<'i, R> {
                Start {
                    /// Queue (as a vec) contains both `Start` token and `End` for the same rule.
                    /// This field is an index of corresponding `End` token in vec.
                    end_token_index: usize,
                    /// Position from which rule was tried to parse (or successfully parsed).
                    input_pos: usize,
                },
                End {
                    /// Queue (as a vec) contains both `Start` token and `End` for the same rule.
                    /// This filed is an index of corresponding `Start` token in vec.
                    start_token_index: usize,
                    rule: R,
                    tag: Option<&'i str>,
                    /// Position at which successfully parsed rule finished (ended).
                    input_pos: usize,
                },
            }
        }

        pub mod tokens
        {
            use ::
            {
                *,
            };
            // pest. The Elegant Parser
            // Copyright (c) 2018 Drago Tiselice
            //
            // Licensed under the Apache License, Version 2.0
            // <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
            // license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
            // option. All files in the project carrying such notice may not be copied,
            // modified, or distributed except according to those terms.

            use alloc::rc::Rc;
            use alloc::vec::Vec;
            use core::fmt;
            use core::str;

            use super::queueable_token::QueueableToken;
            use crate::position;
            use crate::token::Token;
            use crate::RuleType;

            /// An iterator over [`Token`]s. It is created by [`Pair::tokens`] and [`Pairs::tokens`].
            ///
            /// [`Token`]: ../enum.Token.html
            /// [`Pair::tokens`]: struct.Pair.html#method.tokens
            /// [`Pairs::tokens`]: struct.Pairs.html#method.tokens
            #[derive(Clone)]
            pub struct Tokens<'i, R> {
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                start: usize,
                end: usize,
            }

            pub fn new<'i, R: RuleType>(
                queue: Rc<Vec<QueueableToken<'i, R>>>,
                input: &'i str,
                start: usize,
                end: usize,
            ) -> Tokens<'i, R> {
                if cfg!(debug_assertions) {
                    for tok in queue.iter() {
                        match *tok {
                            QueueableToken::Start { input_pos, .. } | QueueableToken::End { input_pos, .. } => {
                                assert!(
                                    input.get(input_pos..).is_some(),
                                    " INVALID `Tokens` CREATED "
                                )
                            }
                        }
                    }
                }

                Tokens {
                    queue,
                    input,
                    start,
                    end,
                }
            }

            impl<'i, R: RuleType> Tokens<'i, R> {
                fn create_token(&self, index: usize) -> Token<'i, R> {
                    match self.queue[index] {
                        QueueableToken::Start {
                            end_token_index,
                            input_pos,
                        } => {
                            let rule = match self.queue[end_token_index] {
                                QueueableToken::End { rule, .. } => rule,
                                _ => unreachable!(),
                            };

                            Token::Start {
                                rule,
                                pos: position::Position::new_internal(self.input, input_pos),
                            }
                        }
                        QueueableToken::End {
                            rule, input_pos, ..
                        } => Token::End {
                            rule,
                            pos: position::Position::new_internal(self.input, input_pos),
                        },
                    }
                }
            }

            impl<'i, R: RuleType> ExactSizeIterator for Tokens<'i, R> {
                fn len(&self) -> usize {
                    self.end - self.start
                }
            }

            impl<'i, R: RuleType> Iterator for Tokens<'i, R> {
                type Item = Token<'i, R>;

                fn next(&mut self) -> Option<Self::Item> {
                    if self.start >= self.end {
                        return None;
                    }

                    let token = self.create_token(self.start);

                    self.start += 1;

                    Some(token)
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    let len = <Self as ExactSizeIterator>::len(self);
                    (len, Some(len))
                }
            }

            impl<'i, R: RuleType> DoubleEndedIterator for Tokens<'i, R> {
                fn next_back(&mut self) -> Option<Self::Item> {
                    if self.end <= self.start {
                        return None;
                    }

                    let token = self.create_token(self.end - 1);

                    self.end -= 1;

                    Some(token)
                }
            }

            impl<'i, R: RuleType> fmt::Debug for Tokens<'i, R> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_list().entries(self.clone()).finish()
                }
            }
        }
        
        pub use self::flat_pairs::FlatPairs;
        pub use self::pair::Pair;
        pub use self::pairs::Pairs;
        pub use self::queueable_token::QueueableToken;
        pub use self::tokens::Tokens;
    }

    pub mod macros
    {
        use ::
        {
            *,
        };
        

        #[doc(hidden)]
        #[macro_export]
        macro_rules! consumes_to {
            ( $_rules:ident, $tokens:expr, [] ) => ();
            ( $rules:ident, $tokens:expr, [ $name:ident ( $start:expr, $end:expr ) ] ) => {
                let expected = format!("expected Start {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $start);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::Start { rule, pos } => {
                        assert!(
                            rule == $rules::$name && pos.pos() == $start,
                            "{} but found Start {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        )
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                let expected = format!("expected End {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $end);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::End { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $end,
                            "{} but found End {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };
            };
            ( $rules:ident, $tokens:expr, [ $name:ident ( $start:expr, $end:expr ),
                                            $( $names:ident $calls:tt ),* $(,)* ] ) => {

                let expected = format!("expected Start {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $start);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::Start { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $start,
                            "{} but found Start {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                let expected = format!("expected End {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $end);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::End { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $end,
                            "{} but found End {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                consumes_to!($rules, $tokens, [ $( $names $calls ),* ]);
            };
            ( $rules:ident, $tokens:expr, [ $name:ident ( $start:expr, $end:expr,
                                                        [ $( $names:ident $calls:tt ),* $(,)* ] ) ] ) => {
                let expected = format!("expected Start {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $start);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::Start { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $start,
                            "{} but found Start {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                consumes_to!($rules, $tokens, [ $( $names $calls ),* ]);

                let expected = format!("expected End {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $end);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::End { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $end,
                            "{} but found End {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };
            };
            ( $rules:ident, $tokens:expr, [ $name:ident ( $start:expr, $end:expr,
                                                        [ $( $nested_names:ident $nested_calls:tt ),*
                                                        $(,)* ] ),
                                            $( $names:ident $calls:tt ),* ] ) => {

                let expected = format!("expected Start {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $start);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::Start { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $start,
                            "{} but found Start {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                consumes_to!($rules, $tokens, [ $( $nested_names $nested_calls ),* ]);

                let expected = format!("expected End {{ rule: {:?}, pos: Position {{ pos: {} }} }}",
                                    $rules::$name, $end);
                match $tokens.next().expect(&format!("{} but found nothing", expected)) {
                    $crate::Token::End { rule, pos } => {
                        assert!(rule == $rules::$name && pos.pos() == $end,
                            "{} but found End {{ rule: {:?}, pos: Position {{ {} }} }}",
                            expected, rule, pos.pos(),
                        );
                    },
                    token => panic!("{} but found {:?}", expected, token)
                };

                consumes_to!($rules, $tokens, [ $( $names $calls ),* ]);
            };
        }
        /// Testing tool that compares produced tokens.
        #[macro_export]
        macro_rules! parses_to {
            ( parser: $parser:ident, input: $string:expr, rule: $rules:tt :: $rule:tt,
            tokens: [ $( $names:ident $calls:tt ),* $(,)* ] ) => {

                #[allow(unused_mut)]
                {
                    use $crate::Parser;

                    let mut tokens = $parser::parse($rules::$rule, $string).unwrap().tokens();

                    consumes_to!($rules, &mut tokens, [ $( $names $calls ),* ]);

                    let rest: Vec<_> = tokens.collect();

                    match rest.len() {
                        0 => (),
                        2 => {
                            let (first, second) = (&rest[0], &rest[1]);

                            match (first, second) {
                                (
                                    &$crate::Token::Start { rule: ref first_rule, .. },
                                    &$crate::Token::End { rule: ref second_rule, .. }
                                ) => {
                                    assert!(
                                        format!("{:?}", first_rule) == "EOI",
                                        "expected end of input, but found {:?}", rest
                                    );
                                    assert!(
                                        format!("{:?}", second_rule) == "EOI",
                                        "expected end of input, but found {:?}", rest
                                    );
                                }
                                _ => panic!("expected end of input, but found {:?}", rest)
                            }
                        }
                        _ => panic!("expected end of input, but found {:?}", rest)
                    };
                }
            };
        }
        /// Testing tool that compares produced errors.
        #[macro_export]
        macro_rules! fails_with {
            ( parser: $parser:ident, input: $string:expr, rule: $rules:tt :: $rule:tt,
            positives: $positives:expr, negatives: $negatives:expr, pos: $pos:expr ) => {
                #[allow(unused_mut)]
                {
                    use $crate::Parser;

                    let error = $parser::parse($rules::$rule, $string).unwrap_err();

                    match error.variant {
                        $crate::error::ErrorVariant::ParsingError {
                            positives,
                            negatives,
                        } => {
                            assert_eq!(positives, $positives, "positives");
                            assert_eq!(negatives, $negatives, "negatives");
                        }
                        _ => unreachable!(),
                    };

                    match error.location {
                        $crate::error::InputLocation::Pos(pos) => assert_eq!(pos, $pos, "pos"),
                        _ => unreachable!(),
                    }
                }
            };
        }
    }

    pub mod parser
    {
        use ::
        {
            *,
        };
        

        use crate::error::Error;
        use crate::iterators::Pairs;
        use crate::RuleType;

        /// A trait with a single method that parses strings.
        pub trait Parser<R: RuleType> {
            /// Parses a `&str` starting from `rule`.
            #[allow(clippy::perf)]
            fn parse(rule: R, input: &str) -> Result<Pairs<'_, R>, Error<R>>;
        }
    }

    pub mod parser_state
    {
        //! The core functionality of parsing grammar.
        use ::
        {
            *,
        };
        

        

        use alloc::borrow::ToOwned;
        use alloc::boxed::Box;
        use alloc::collections::BTreeSet;
        use alloc::rc::Rc;
        use alloc::string::String;
        use alloc::vec;
        use alloc::vec::Vec;
        use core::fmt::{Debug, Display, Formatter};
        use core::num::NonZeroUsize;
        use core::ops::Range;
        use core::sync::atomic::{AtomicBool, AtomicUsize, Ordering};

        use crate::error::{Error, ErrorVariant};
        use crate::iterators::pairs::new;
        use crate::iterators::{pairs, QueueableToken};
        use crate::position::Position;
        use crate::span::Span;
        use crate::stack::Stack;
        use crate::RuleType;

        /// The current lookahead status of a [`ParserState`].
        ///
        /// [`ParserState`]: struct.ParserState.html
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum Lookahead {
            /// The positive predicate, written as an ampersand &,
            /// attempts to match its inner expression.
            /// If the inner expression succeeds, parsing continues,
            /// but at the same position as the predicate 
            /// &foo ~ bar is thus a kind of "AND" statement:
            /// "the input string must match foo AND bar".
            /// If the inner expression fails,
            /// the whole expression fails too.
            Positive,
            /// The negative predicate, written as an exclamation mark !,
            /// attempts to match its inner expression.
            /// If the inner expression fails, the predicate succeeds
            /// and parsing continues at the same position as the predicate.
            /// If the inner expression succeeds, the predicate fails 
            /// !foo ~ bar is thus a kind of "NOT" statement:
            /// "the input string must match bar but NOT foo".
            Negative,
            /// No lookahead (i.e. it will consume input).
            None,
        }
        /// The current atomicity of a [`ParserState`].
        ///
        /// [`ParserState`]: struct.ParserState.html
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum Atomicity {
            /// prevents implicit whitespace: inside an atomic rule,
            /// the tilde ~ means "immediately followed by",
            /// and repetition operators (asterisk * and plus sign +)
            /// have no implicit separation. In addition, all other rules
            /// called from an atomic rule are also treated as atomic.
            /// (interior matching rules are silent)
            Atomic,
            /// The same as atomic, but inner tokens are produced as normal.
            CompoundAtomic,
            /// implicit whitespace is enabled
            NonAtomic,
        }
        /// Type alias to simplify specifying the return value of chained closures.
        pub type ParseResult<S> = Result<S, S>;

        /// Match direction for the stack. Used in `PEEK[a..b]`/`stack_match_peek_slice`.
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum MatchDir {
            /// from the bottom to the top of the stack
            BottomToTop,
            /// from the top to the bottom of the stack
            TopToBottom,
        }

        static CALL_LIMIT: AtomicUsize = AtomicUsize::new(0);

        /// Sets the maximum call limit for the parser state
        /// to prevent stack overflows or excessive execution times
        /// in some grammars.
        /// If set, the calls are tracked as a running total
        /// over all non-terminal rules that can nest closures
        /// (which are passed to transform the parser state).
        ///
        /// # Arguments
        ///
        /// * `limit` - The maximum number of calls. If None,
        ///             the number of calls is unlimited.
        pub fn set_call_limit(limit: Option<NonZeroUsize>) {
            CALL_LIMIT.store(limit.map(|f| f.get()).unwrap_or(0), Ordering::Relaxed);
        }

        static ERROR_DETAIL: AtomicBool = AtomicBool::new(false);

        /// Sets whether information for more error details
        /// should be collected. This is useful for debugging
        /// parser errors (as it leads to more comprehensive
        /// error messages), but it has a higher performance cost.
        /// (hence, it's off by default)
        ///
        /// # Arguments
        ///
        /// * `enabled` - Whether to enable the collection for
        ///               more error details.
        pub fn set_error_detail(enabled: bool) {
            ERROR_DETAIL.store(enabled, Ordering::Relaxed);
        }

        #[derive(Debug)]
        struct CallLimitTracker {
            current_call_limit: Option<(usize, usize)>,
        }

        impl Default for CallLimitTracker {
            fn default() -> Self {
                let limit = CALL_LIMIT.load(Ordering::Relaxed);
                let current_call_limit = if limit > 0 { Some((0, limit)) } else { None };
                Self { current_call_limit }
            }
        }

        impl CallLimitTracker {
            fn limit_reached(&self) -> bool {
                self.current_call_limit
                    .map_or(false, |(current, limit)| current >= limit)
            }

            fn increment_depth(&mut self) {
                if let Some((current, _)) = &mut self.current_call_limit {
                    *current += 1;
                }
            }
        }
        /// Number of call stacks that may result from a sequence of rules parsing.
        const CALL_STACK_INITIAL_CAPACITY: usize = 20;
        /// Max (un)expected number of tokens that we may see on the parsing error position.
        const EXPECTED_TOKENS_INITIAL_CAPACITY: usize = 30;
        /// Max rule children number for which we'll extend calls stacks.
        ///
        /// In case rule we're working with has too many children rules that failed in parsing,
        /// we don't want to store long stacks for all of them. If rule has more than this number
        /// of failed children, they all will be collapsed in a parent rule.
        const CALL_STACK_CHILDREN_THRESHOLD: usize = 4;

        /// Structure tracking errored parsing call (associated with specific `ParserState` function).
        #[derive(Debug, Hash, PartialEq, Eq, Clone, PartialOrd, Ord)]
        pub enum ParseAttempt<R> {
            /// Call of `rule` errored.
            Rule(R),
            /// Call of token element (e.g., `match_string` or `match_insensitive`) errored.
            /// Works as indicator of that leaf node is not a rule. In order to get the token value we
            /// can address `ParseAttempts` `(un)expected_tokens`.
            Token,
        }

        impl<R> ParseAttempt<R> {
            pub fn get_rule(&self) -> Option<&R> {
                match self {
                    ParseAttempt::Rule(r) => Some(r),
                    ParseAttempt::Token => None,
                }
            }
        }
        /// Rules call stack.
        /// Contains sequence of rule calls that resulted in new parsing attempt.
        #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub struct RulesCallStack<R> {
            /// Deepest rule caused a parsing error (ParseAttempt::Token transformed into a rule).
            pub deepest: ParseAttempt<R>,
            /// Most top rule covering `deepest`.
            pub parent: Option<R>,
        }

        impl<R> RulesCallStack<R> {
            fn new(deepest: ParseAttempt<R>) -> RulesCallStack<R> {
                RulesCallStack {
                    deepest,
                    parent: None,
                }
            }
        }

        #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum ParsingToken {
            Sensitive { token: String },
            Insensitive { token: String },
            Range { start: char, end: char },
            BuiltInRule,
        }

        impl Display for ParsingToken {
            fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
                match self {
                    ParsingToken::Sensitive { token } => write!(f, "{token}"),
                    ParsingToken::Insensitive { token } => write!(f, "{}", token.to_uppercase()),
                    ParsingToken::Range { start, end } => write!(f, "{start}..{end}"),
                    ParsingToken::BuiltInRule => write!(f, "BUILTIN_RULE"),
                }
            }
        }
        /// Structure that tracks all the parsing attempts made on the max position.
        #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub struct ParseAttempts<R> {
            /// Indicates whether the parsing attempts are tracked.
            enabled: bool,
            /// Vec of rule calls sequences awaiting tokens at the same `max_position`.
            /// If there are several stacks in vec, it means all those rule stacks are "equal"
            /// because their attempts occurred on the same position.
            pub call_stacks: Vec<RulesCallStack<R>>,
            /// Tokens that could be putted at `max_position`
            /// in order to get a valid grammar query.
            expected_tokens: Vec<ParsingToken>,
            /// Tokens that we've prohibited to be putted at `max_position`
            /// in order to get a valid grammar query.
            unexpected_tokens: Vec<ParsingToken>,
            /// Max position at which we were expecting to see one of `expected_tokens`.
            pub max_position: usize,
        }

        impl<R: RuleType> ParseAttempts<R> {
            /// Create new `ParseAttempts` instance with `call_stacks` and `expected_tokens`
            /// initialized with capacity.
            pub fn new() -> Self {
                Self {
                    call_stacks: Vec::with_capacity(CALL_STACK_INITIAL_CAPACITY),
                    expected_tokens: Vec::with_capacity(EXPECTED_TOKENS_INITIAL_CAPACITY),
                    unexpected_tokens: Vec::with_capacity(EXPECTED_TOKENS_INITIAL_CAPACITY),
                    max_position: 0,
                    enabled: ERROR_DETAIL.load(Ordering::Relaxed),
                }
            }
            /// Get number of currently present call stacks.
            fn call_stacks_number(&self) -> usize {
                self.call_stacks.len()
            }

            pub fn expected_tokens(&self) -> Vec<ParsingToken> {
                self.expected_tokens
                    .iter()
                    .cloned()
                    .collect::<BTreeSet<_>>()
                    .into_iter()
                    .collect()
            }

            pub fn unexpected_tokens(&self) -> Vec<ParsingToken> {
                self.unexpected_tokens
                    .iter()
                    .cloned()
                    .collect::<BTreeSet<_>>()
                    .into_iter()
                    .collect()
            }
            /// Retrieve call stacks.
            pub fn call_stacks(&self) -> Vec<RulesCallStack<R>> {
                self.call_stacks
                    .iter()
                    .cloned()
                    .collect::<BTreeSet<_>>()
                    .into_iter()
                    .collect()
            }
            /// In case we've tried to parse a rule, which start position is bigger than previous
            /// `max_position` it means that we've advanced in our parsing and found better candidate.
            ///
            /// `start_index` is:
            /// * Number of call stacks present in state at the moment current `rule` was called. The idea
            ///   is that we'd like to update only those stacks that originated from the current `rule` and
            ///   not from those that were called previously.
            /// * 0 in case we've successfully parsed some token since the moment `rule` was called.
            fn try_add_new_stack_rule(&mut self, rule: R, start_index: usize) {
                let mut non_token_call_stacks = Vec::new();
                let mut token_call_stack_met = false;
                for call_stack in self.call_stacks.iter().skip(start_index) {
                    if matches!(call_stack.deepest, ParseAttempt::Token) {
                        token_call_stack_met = true;
                    } else {
                        non_token_call_stacks.push(call_stack.clone())
                    }
                }
                if token_call_stack_met && non_token_call_stacks.is_empty() {
                    // If `non_token_call_stacks` is not empty we wouldn't like to add a new standalone
                    // `RulesCallStack::new(ParseAttempt::Token)` (that will later be transformed into a
                    // rule) as soon as it doesn't give us any useful additional info.
                    non_token_call_stacks.push(RulesCallStack::new(ParseAttempt::Token));
                }
                self.call_stacks
                    .splice(start_index.., non_token_call_stacks);

                let children_number_over_threshold =
                    self.call_stacks_number() - start_index >= CALL_STACK_CHILDREN_THRESHOLD;
                if children_number_over_threshold {
                    self.call_stacks.truncate(start_index);
                    self.call_stacks
                        .push(RulesCallStack::new(ParseAttempt::Rule(rule)));
                } else {
                    for call_stack in self.call_stacks.iter_mut().skip(start_index) {
                        if matches!(call_stack.deepest, ParseAttempt::Token) {
                            call_stack.deepest = ParseAttempt::Rule(rule);
                        } else {
                            call_stack.parent = Some(rule);
                        }
                    }
                }
            }
            /// If `expected` flag is set to false, it means we've successfully parsed token being in the
            /// state of negative lookahead and want to track `token` in the `unexpected_tokens`. Otherwise,
            /// we want to track it the `expected_tokens`. Let's call chosen vec a `target_vec`.
            ///
            /// In case `position` is:
            /// * Equal to `max_position`, add `token` to `target_vec`,
            /// * Bigger than `max_position`, set `token` as the only new element of `target_vec`.
            #[allow(clippy::comparison_chain)]
            fn try_add_new_token(
                &mut self,
                token: ParsingToken,
                start_position: usize,
                position: usize,
                negative_lookahead: bool,
            ) {
                let target_vec_push_token = |attempts: &mut ParseAttempts<R>| {
                    let target_vec = if negative_lookahead {
                        &mut attempts.unexpected_tokens
                    } else {
                        &mut attempts.expected_tokens
                    };
                    target_vec.push(token);
                };

                if position > self.max_position {
                    if negative_lookahead && start_position > self.max_position {
                        // We encountered a sequence under negative lookahead.
                        // We would like to track only first failed token in this sequence (which
                        // `start_position` should be equal to `self.max_position`).
                        return;
                    }
                    target_vec_push_token(self);

                    if negative_lookahead {
                        // In case of successful parsing of token under negative lookahead the only
                        // thing we'd like to do is to track the token in the `unexpected_tokens`.
                        return;
                    }
                    self.max_position = position;
                    self.expected_tokens.clear();
                    self.unexpected_tokens.clear();
                    self.call_stacks.clear();
                    self.call_stacks
                        .push(RulesCallStack::new(ParseAttempt::Token));
                } else if position == self.max_position {
                    target_vec_push_token(self);
                    self.call_stacks
                        .push(RulesCallStack::new(ParseAttempt::Token));
                }
            }
            /// Reset state in case we've successfully parsed some token in
            /// `match_string` or `match_insensetive`.
            fn nullify_expected_tokens(&mut self, new_max_position: usize) {
                self.call_stacks.clear();
                self.expected_tokens.clear();
                self.unexpected_tokens.clear();
                self.max_position = new_max_position;
            }
        }

        impl<R: RuleType> Default for ParseAttempts<R> {
            fn default() -> Self {
                Self::new()
            }
        }
        /// The complete state of a [`Parser`].
        #[derive(Debug)]
        pub struct ParserState<'i, R: RuleType> {
            /// Current position from which we try to apply some parser function.
            /// Initially is 0.
            /// E.g., we are parsing `create user 'Bobby'` query, we parsed "create" via `match_insensitive`
            /// and switched our `position` from 0 to the length of "create".
            ///
            /// E.g., see `match_string` -> `self.position.match_string(string)` which updates `self.pos`.
            position: Position<'i>,
            /// Queue representing rules partially (`QueueableToken::Start`) and
            /// totally (`QueueableToken::End`) parsed. When entering rule we put it in the queue in a state
            /// of `Start` and after all its sublogic (subrules or strings) are parsed, we change it to
            /// `End` state.
            queue: Vec<QueueableToken<'i, R>>,
            /// Status set in case specific lookahead logic is used in grammar.
            /// See `Lookahead` for more information.
            lookahead: Lookahead,
            /// Rules that we HAVE expected, tried to parse, but failed.
            pos_attempts: Vec<R>,
            /// Rules that we have NOT expected, tried to parse, but failed.
            neg_attempts: Vec<R>,
            /// Max position in the query from which we've tried to parse some rule but failed.
            attempt_pos: usize,
            /// Current atomicity status. For more information see `Atomicity`.
            atomicity: Atomicity,
            /// Helper structure tracking `Stack` status (used in case grammar contains stack PUSH/POP
            /// invocations).
            stack: Stack<Span<'i>>,
            /// Used for setting max parser calls limit.
            call_tracker: CallLimitTracker,
            /// Together with tracking of `pos_attempts` and `attempt_pos`
            /// as a pair of (list of rules that we've tried to parse but failed, max parsed position)
            /// we track those rules (which we've tried to parse at the same max pos) at this helper struct.
            ///
            /// Note, that we may try to parse several rules on different positions. We want to track only
            /// those rules, which attempt position is bigger, because we consider that it's nearer to the
            /// query that user really wanted to pass.
            ///
            /// E.g. we have a query `create user "Bobby"` and two root rules:
            /// * CreateUser  = { "create" ~ "user"  ~ Name }
            /// * CreateTable = { "create" ~ "table" ~ Name }
            /// * Name = { SOME_DEFINITION }
            ///
            /// While parsing the query we'll update tracker position to the start of "Bobby", because we'd
            /// successfully parse "create" + "user" (and not "table").
            parse_attempts: ParseAttempts<R>,
        }
        /// Creates a `ParserState` from a `&str`, supplying it to a closure `f`.
        #[allow(clippy::perf)]
        pub fn state<'i, R: RuleType, F>(input: &'i str, f: F) -> Result<pairs::Pairs<'i, R>, Error<R>>
        where
            F: FnOnce(Box<ParserState<'i, R>>) -> ParseResult<Box<ParserState<'i, R>>>,
        {
            let state = ParserState::new(input);

            match f(state) {
                Ok(state) => {
                    let len = state.queue.len();
                    Ok(new(Rc::new(state.queue), input, None, 0, len))
                }
                Err(mut state) => {
                    let variant = if state.reached_call_limit() {
                        ErrorVariant::CustomError {
                            message: "call limit reached".to_owned(),
                        }
                    } else {
                        state.pos_attempts.sort();
                        state.pos_attempts.dedup();
                        state.neg_attempts.sort();
                        state.neg_attempts.dedup();
                        ErrorVariant::ParsingError {
                            positives: state.pos_attempts.clone(),
                            negatives: state.neg_attempts.clone(),
                        }
                    };

                    if state.parse_attempts.enabled {
                        Err(Error::new_from_pos_with_parsing_attempts(
                            variant,
                            Position::new_internal(input, state.attempt_pos),
                            state.parse_attempts.clone(),
                        ))
                    } else {
                        Err(Error::new_from_pos(
                            variant,
                            Position::new_internal(input, state.attempt_pos),
                        ))
                    }
                }
            }
        }

        impl<'i, R: RuleType> ParserState<'i, R> {
            /// Allocates a fresh `ParserState` object to the heap and returns the owned `Box`.
            pub fn new(input: &'i str) -> Box<Self> {
                Box::new(ParserState {
                    position: Position::from_start(input),
                    queue: vec![],
                    lookahead: Lookahead::None,
                    pos_attempts: vec![],
                    neg_attempts: vec![],
                    attempt_pos: 0,
                    atomicity: Atomicity::NonAtomic,
                    stack: Stack::new(),
                    call_tracker: Default::default(),
                    parse_attempts: ParseAttempts::new(),
                })
            }
            /// Get all parse attempts after process of parsing is finished.
            pub fn get_parse_attempts(&self) -> &ParseAttempts<R> {
                &self.parse_attempts
            }
            /// Returns a reference to the current `Position` of the `ParserState`.
            pub fn position(&self) -> &Position<'i> {
                &self.position
            }
            /// Returns the current atomicity of the `ParserState`.
            pub fn atomicity(&self) -> Atomicity {
                self.atomicity
            }

            #[inline]
            fn inc_call_check_limit(mut self: Box<Self>) -> ParseResult<Box<Self>> {
                if self.call_tracker.limit_reached() {
                    return Err(self);
                }
                self.call_tracker.increment_depth();
                Ok(self)
            }

            #[inline]
            fn reached_call_limit(&self) -> bool {
                self.call_tracker.limit_reached()
            }
            /// Wrapper needed to generate tokens. This will associate the `R` type rule to the closure meant to match the rule.
            #[inline]
            pub fn rule<F>(mut self: Box<Self>, rule: R, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                // Position from which this `rule` starts parsing.
                let actual_pos = self.position.pos();
                // Remember index of the `self.queue` element that will be associated with this `rule`.
                let index = self.queue.len();

                let (pos_attempts_index, neg_attempts_index) = if actual_pos == self.attempt_pos {
                    (self.pos_attempts.len(), self.neg_attempts.len())
                } else {
                    // Attempts have not been cleared yet since the attempt_pos is older.
                    (0, 0)
                };

                if self.lookahead == Lookahead::None && self.atomicity != Atomicity::Atomic {
                    // Pair's position will only be known after running the closure.
                    self.queue.push(QueueableToken::Start {
                        end_token_index: 0,
                        input_pos: actual_pos,
                    });
                }

                // Remember attempts number before `f` call.
                // In `track` using this variable we can say, how many attempts were added
                // during children rules traversal.
                let attempts = self.attempts_at(actual_pos);
                // Number of call stacks present in `self.parse_attempts` before `f` call.
                // We need to remember this number only in case there wasn't found any farther attempt.
                // E.g. we are handling rule, on start position of which may be tested two
                // children rules. At the moment we'll return from `f` call below,
                // there will be two more children rules in `self.parse_attempts` that we'll
                // consider to be the children of current `rule`.
                let mut remember_call_stacks_number = self.parse_attempts.call_stacks_number();
                // Max parsing attempt position at the moment of `rule` handling.
                // It case it's raised during children rules handling, it means
                // we've made a parsing progress.
                let remember_max_position = self.parse_attempts.max_position;

                let result = f(self);

                let mut try_add_rule_to_stack = |new_state: &mut Box<ParserState<'_, R>>| {
                    if new_state.parse_attempts.max_position > remember_max_position {
                        // It means that one of `match_string` or e.g. `match_insensetive` function calls
                        // have already erased `self.parse_attempts.call_stacks` and that previously
                        // remembered values are not valid anymore.
                        remember_call_stacks_number = 0;
                    }
                    if !matches!(new_state.atomicity, Atomicity::Atomic) {
                        new_state
                            .parse_attempts
                            .try_add_new_stack_rule(rule, remember_call_stacks_number);
                    }
                };

                match result {
                    Ok(mut new_state) => {
                        if new_state.lookahead == Lookahead::Negative {
                            new_state.track(
                                rule,
                                actual_pos,
                                pos_attempts_index,
                                neg_attempts_index,
                                attempts,
                            );
                        }

                        if new_state.lookahead == Lookahead::None
                            && new_state.atomicity != Atomicity::Atomic
                        {
                            // Index of `QueueableToken::End` token added below
                            // that corresponds to previously added `QueueableToken::Start` token.
                            let new_index = new_state.queue.len();
                            match new_state.queue[index] {
                                QueueableToken::Start {
                                    ref mut end_token_index,
                                    ..
                                } => *end_token_index = new_index,
                                _ => unreachable!(),
                            };

                            let new_pos = new_state.position.pos();

                            new_state.queue.push(QueueableToken::End {
                                start_token_index: index,
                                rule,
                                tag: None,
                                input_pos: new_pos,
                            });
                        }

                        // Note, that we need to count positive parsing results too, because we can fail in
                        // optional rule call inside which may lie the farthest
                        // parsed token.
                        if new_state.parse_attempts.enabled {
                            try_add_rule_to_stack(&mut new_state);
                        }
                        Ok(new_state)
                    }
                    Err(mut new_state) => {
                        if new_state.lookahead != Lookahead::Negative {
                            new_state.track(
                                rule,
                                actual_pos,
                                pos_attempts_index,
                                neg_attempts_index,
                                attempts,
                            );
                            if new_state.parse_attempts.enabled {
                                try_add_rule_to_stack(&mut new_state);
                            }
                        }

                        if new_state.lookahead == Lookahead::None
                            && new_state.atomicity != Atomicity::Atomic
                        {
                            new_state.queue.truncate(index);
                        }

                        Err(new_state)
                    }
                }
            }
            /// Tag current node.
            #[inline]
            pub fn tag_node(mut self: Box<Self>, tag: &'i str) -> ParseResult<Box<Self>> {
                if let Some(QueueableToken::End { tag: old, .. }) = self.queue.last_mut() {
                    *old = Some(tag)
                }
                Ok(self)
            }
            /// Get number of allowed rules attempts + prohibited rules attempts.
            fn attempts_at(&self, pos: usize) -> usize {
                if self.attempt_pos == pos {
                    self.pos_attempts.len() + self.neg_attempts.len()
                } else {
                    0
                }
            }

            fn track(
                &mut self,
                rule: R,
                pos: usize,
                pos_attempts_index: usize,
                neg_attempts_index: usize,
                prev_attempts: usize,
            ) {
                if self.atomicity == Atomicity::Atomic {
                    return;
                }

                // If nested rules made no progress, there is no use to report them; it's only useful to
                // track the current rule, the exception being when only one attempt has been made during
                // the children rules.
                let curr_attempts = self.attempts_at(pos);
                if curr_attempts > prev_attempts && curr_attempts - prev_attempts == 1 {
                    return;
                }

                if pos == self.attempt_pos {
                    self.pos_attempts.truncate(pos_attempts_index);
                    self.neg_attempts.truncate(neg_attempts_index);
                }

                if pos > self.attempt_pos {
                    self.pos_attempts.clear();
                    self.neg_attempts.clear();
                    self.attempt_pos = pos;
                }

                let attempts = if self.lookahead != Lookahead::Negative {
                    &mut self.pos_attempts
                } else {
                    &mut self.neg_attempts
                };

                if pos == self.attempt_pos {
                    attempts.push(rule);
                }
            }
            /// Starts a sequence of transformations provided by `f` from the `Box<ParserState>`.
            #[inline]
            pub fn sequence<F>(mut self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                let token_index = self.queue.len();
                let initial_pos = self.position;

                let result = f(self);

                match result {
                    Ok(new_state) => Ok(new_state),
                    Err(mut new_state) => {
                        // Restore the initial position and truncate the token queue.
                        new_state.position = initial_pos;
                        new_state.queue.truncate(token_index);
                        Err(new_state)
                    }
                }
            }
            /// Repeatedly applies the transformation provided by `f` from the `Box<ParserState>`.
            #[inline]
            pub fn repeat<F>(mut self: Box<Self>, mut f: F) -> ParseResult<Box<Self>>
            where
                F: FnMut(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                let mut result = f(self);

                loop {
                    match result {
                        Ok(state) => result = f(state),
                        Err(state) => return Ok(state),
                    };
                }
            }
            /// Optionally applies the transformation provided by `f` from the `Box<ParserState>`.
            #[inline]
            pub fn optional<F>(mut self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                match f(self) {
                    Ok(state) | Err(state) => Ok(state),
                }
            }
            /// Generic function to handle result of char/string/range parsing in order to track (un)expected tokens.
            fn handle_token_parse_result(
                &mut self,
                start_position: usize,
                token: ParsingToken,
                parse_succeeded: bool,
            ) {
                // New position after tracked parsed element for case of `parse_succeded` is true.
                // Position of parsing failure otherwise.
                let current_pos = self.position.pos();

                if parse_succeeded {
                    if self.lookahead == Lookahead::Negative {
                        self.parse_attempts
                            .try_add_new_token(token, start_position, current_pos, true);
                    } else if current_pos > self.parse_attempts.max_position {
                        self.parse_attempts.nullify_expected_tokens(current_pos);
                    }
                } else if self.lookahead != Lookahead::Negative {
                    self.parse_attempts
                        .try_add_new_token(token, start_position, current_pos, false);
                }
            }
            /// Attempts to match a single character based on a filter function.
            #[inline]
            pub fn match_char_by<F>(mut self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(char) -> bool,
            {
                let start_position = self.position.pos();
                let succeeded = self.position.match_char_by(f);
                if self.parse_attempts.enabled {
                    let token = ParsingToken::BuiltInRule;
                    self.handle_token_parse_result(start_position, token, succeeded);
                }
                if succeeded {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to match the given string.
            #[inline]
            pub fn match_string(mut self: Box<Self>, string: &str) -> ParseResult<Box<Self>> {
                let start_position = self.position.pos();
                let succeeded = self.position.match_string(string);
                if self.parse_attempts.enabled {
                    let token = ParsingToken::Sensitive {
                        token: String::from(string),
                    };
                    self.handle_token_parse_result(start_position, token, succeeded);
                }
                if succeeded {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to case-insensitively match the given string. 
            #[inline]
            pub fn match_insensitive(mut self: Box<Self>, string: &str) -> ParseResult<Box<Self>> {
                let start_position: usize = self.position().pos();
                let succeeded = self.position.match_insensitive(string);
                if self.parse_attempts.enabled {
                    let token = ParsingToken::Insensitive {
                        token: String::from(string),
                    };
                    self.handle_token_parse_result(start_position, token, succeeded);
                }
                if succeeded {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to match a single character from the given range.
            #[inline]
            pub fn match_range(mut self: Box<Self>, range: Range<char>) -> ParseResult<Box<Self>> {
                let start_position = self.position().pos();
                let token = ParsingToken::Range {
                    start: range.start,
                    end: range.end,
                };
                let succeeded = self.position.match_range(range);
                if self.parse_attempts.enabled {
                    self.handle_token_parse_result(start_position, token, succeeded);
                }
                if succeeded {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to skip `n` characters forward.
            #[inline]
            pub fn skip(mut self: Box<Self>, n: usize) -> ParseResult<Box<Self>> {
                if self.position.skip(n) {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to skip forward until one of the given strings is found.
            #[inline]
            pub fn skip_until(mut self: Box<Self>, strings: &[&str]) -> ParseResult<Box<Self>> {
                self.position.skip_until(strings);
                Ok(self)
            }
            /// Attempts to match the start of the input.
            #[inline]
            pub fn start_of_input(self: Box<Self>) -> ParseResult<Box<Self>> {
                if self.position.at_start() {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Attempts to match the end of the input.
            #[inline]
            pub fn end_of_input(self: Box<Self>) -> ParseResult<Box<Self>> {
                if self.position.at_end() {
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Starts a lookahead transformation provided by `f` from the `Box<ParserState>`.
            #[inline]
            pub fn lookahead<F>(mut self: Box<Self>, is_positive: bool, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                let initial_lookahead = self.lookahead;

                self.lookahead = if is_positive {
                    match initial_lookahead {
                        Lookahead::None | Lookahead::Positive => Lookahead::Positive,
                        Lookahead::Negative => Lookahead::Negative,
                    }
                } else {
                    match initial_lookahead {
                        Lookahead::None | Lookahead::Positive => Lookahead::Negative,
                        Lookahead::Negative => Lookahead::Positive,
                    }
                };

                let initial_pos = self.position;

                let result = f(self.checkpoint());

                let result_state = match result {
                    Ok(mut new_state) => {
                        new_state.position = initial_pos;
                        new_state.lookahead = initial_lookahead;
                        Ok(new_state.restore())
                    }
                    Err(mut new_state) => {
                        new_state.position = initial_pos;
                        new_state.lookahead = initial_lookahead;
                        Err(new_state.restore())
                    }
                };

                if is_positive {
                    result_state
                } else {
                    match result_state {
                        Ok(state) => Err(state),
                        Err(state) => Ok(state),
                    }
                }
            }
            /// Transformation which stops `Token`s from being generated according to `is_atomic`.
            #[inline]
            pub fn atomic<F>(mut self: Box<Self>, atomicity: Atomicity, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                // In case child parsing call is another `atomic` it will have its own atomicity status.
                let initial_atomicity = self.atomicity;
                // In case child atomicity is the same as we've demanded, we shouldn't do nothing.
                // E.g. we have the following rules:
                // * RootRule = @{ InnerRule }
                // * InnerRule = @{ ... }
                let should_toggle = self.atomicity != atomicity;

                // Note that we take atomicity of the top rule and not of the leaf (inner).
                if should_toggle {
                    self.atomicity = atomicity;
                }

                let result = f(self);

                match result {
                    Ok(mut new_state) => {
                        if should_toggle {
                            new_state.atomicity = initial_atomicity;
                        }
                        Ok(new_state)
                    }
                    Err(mut new_state) => {
                        if should_toggle {
                            new_state.atomicity = initial_atomicity;
                        }
                        Err(new_state)
                    }
                }
            }
            /// Evaluates the result of closure `f` and pushes the span of the input consumed from before
            /// `f` is called to after `f` is called to the stack. 
            #[inline]
            pub fn stack_push<F>(mut self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                self = self.inc_call_check_limit()?;
                let start = self.position;

                let result = f(self);

                match result {
                    Ok(mut state) => {
                        let end = state.position;
                        state.stack.push(start.span(&end));
                        Ok(state)
                    }
                    Err(state) => Err(state),
                }
            }
            /// Peeks the top of the stack and attempts to match the string.
            #[inline]
            pub fn stack_peek(self: Box<Self>) -> ParseResult<Box<Self>> {
                let string = self
                    .stack
                    .peek()
                    .expect("peek was called on empty stack")
                    .as_str();
                self.match_string(string)
            }
            /// Pops the top of the stack and attempts to match the string.
            #[inline]
            pub fn stack_pop(mut self: Box<Self>) -> ParseResult<Box<Self>> {
                let string = self
                    .stack
                    .pop()
                    .expect("pop was called on empty stack")
                    .as_str();
                self.match_string(string)
            }
            /// Matches part of the state of the stack.
            #[inline]
            pub fn stack_match_peek_slice(
                mut self: Box<Self>,
                start: i32,
                end: Option<i32>,
                match_dir: MatchDir,
            ) -> ParseResult<Box<Self>> {
                let range = match constrain_idxs(start, end, self.stack.len()) {
                    Some(r) => r,
                    None => return Err(self),
                };
                // return true if an empty sequence is requested
                if range.end <= range.start {
                    return Ok(self);
                }

                let mut position = self.position;
                let result = {
                    let mut iter_b2t = self.stack[range].iter();
                    let matcher = |span: &Span<'_>| position.match_string(span.as_str());
                    match match_dir {
                        MatchDir::BottomToTop => iter_b2t.all(matcher),
                        MatchDir::TopToBottom => iter_b2t.rev().all(matcher),
                    }
                };
                if result {
                    self.position = position;
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Matches the full state of the stack.
            #[inline]
            pub fn stack_match_peek(self: Box<Self>) -> ParseResult<Box<Self>> {
                self.stack_match_peek_slice(0, None, MatchDir::TopToBottom)
            }
            /// Matches the full state of the stack.
            #[inline]
            pub fn stack_match_pop(mut self: Box<Self>) -> ParseResult<Box<Self>> {
                let mut position = self.position;
                let mut result = true;
                while let Some(span) = self.stack.pop() {
                    result = position.match_string(span.as_str());
                    if !result {
                        break;
                    }
                }

                if result {
                    self.position = position;
                    Ok(self)
                } else {
                    Err(self)
                }
            }
            /// Drops the top of the stack.
            #[inline]
            pub fn stack_drop(mut self: Box<Self>) -> ParseResult<Box<Self>> {
                match self.stack.pop() {
                    Some(_) => Ok(self),
                    None => Err(self),
                }
            }
            /// Restores the original state of the `ParserState` when `f` returns an `Err`.
            #[inline]
            pub fn restore_on_err<F>(self: Box<Self>, f: F) -> ParseResult<Box<Self>>
            where
                F: FnOnce(Box<Self>) -> ParseResult<Box<Self>>,
            {
                match f(self.checkpoint()) {
                    Ok(state) => Ok(state.checkpoint_ok()),
                    Err(state) => Err(state.restore()),
                }
            }
            /// Mark the current state as a checkpoint and return the `Box`.
            #[inline]
            pub fn checkpoint(mut self: Box<Self>) -> Box<Self> {
                self.stack.snapshot();
                self
            }
            /// The checkpoint was cleared successfully so remove it without touching other stack state.
            #[inline]
            pub fn checkpoint_ok(mut self: Box<Self>) -> Box<Self> {
                self.stack.clear_snapshot();
                self
            }
            /// Restore the current state to the most recent checkpoint.
            #[inline]
            pub fn restore(mut self: Box<Self>) -> Box<Self> {
                self.stack.restore();
                self
            }
        }
        /// Helper function used only in case stack operations (PUSH/POP) are used in grammar.
        fn constrain_idxs(start: i32, end: Option<i32>, len: usize) -> Option<Range<usize>> {
            let start_norm = normalize_index(start, len)?;
            let end_norm = end.map_or(Some(len), |e| normalize_index(e, len))?;
            Some(start_norm..end_norm)
        }
        /// `constrain_idxs` helper function.
        fn normalize_index(i: i32, len: usize) -> Option<usize> {
            if i > len as i32 {
                None
            } else if i >= 0 {
                Some(i as usize)
            } else {
                let real_i = len as i32 + i;
                if real_i >= 0 {
                    Some(real_i as usize)
                } else {
                    None
                }
            }
        }
    }

    pub mod position
    {
        use ::
        {
            *,
        };
        

        use core::cmp::Ordering;
        use core::fmt;
        use core::hash::{Hash, Hasher};
        use core::ops::Range;
        use core::ptr;
        use core::str;

        use crate::span;

        /// A cursor position in a `&str` which provides useful methods to manually parse that string.
        #[derive(Clone, Copy)]
        pub struct Position<'i> {
            input: &'i str,
            pos: usize,
        }

        impl<'i> Position<'i> {
            /// Create a new `Position` without checking invariants. (Checked with `debug_assertions`.)
            pub fn new_internal(input: &str, pos: usize) -> Position<'_> {
                debug_assert!(input.get(pos..).is_some());
                Position { input, pos }
            }
            /// Attempts to create a new `Position` at the given position.
            pub fn new(input: &str, pos: usize) -> Option<Position<'_>> {
                input.get(pos..).map(|_| Position { input, pos })
            }
            /// Creates a `Position` at the start of a `&str`.
            #[inline]
            pub fn from_start(input: &'i str) -> Position<'i> {
                // Position 0 is always safe because it's always a valid UTF-8 border.
                Position { input, pos: 0 }
            }
            /// Returns the byte position of this `Position` as a `usize`.
            #[inline]
            pub fn pos(&self) -> usize {
                self.pos
            }
            /// Creates a `Span` from two `Position`s.
            #[inline]
            pub fn span(&self, other: &Position<'i>) -> span::Span<'i> {
                if ptr::eq(self.input, other.input)
                /* && self.input.get(self.pos..other.pos).is_some() */
                {
                    span::Span::new_internal(self.input, self.pos, other.pos)
                } else {
                    // TODO: maybe a panic if self.pos < other.pos
                    panic!("span created from positions from different inputs")
                }
            }
            /// Returns the line and column number of this `Position`.
            #[inline]
            pub fn line_col(&self) -> (usize, usize) {
                if self.pos > self.input.len() {
                    panic!("position out of bounds");
                }
                let mut pos = self.pos;
                let slice = &self.input[..pos];
                let mut chars = slice.chars().peekable();

                let mut line_col = (1, 1);

                while pos != 0 {
                    match chars.next() {
                        Some('\r') => {
                            if let Some(&'\n') = chars.peek() {
                                chars.next();

                                if pos == 1 {
                                    pos -= 1;
                                } else {
                                    pos -= 2;
                                }

                                line_col = (line_col.0 + 1, 1);
                            } else {
                                pos -= 1;
                                line_col = (line_col.0, line_col.1 + 1);
                            }
                        }
                        Some('\n') => {
                            pos -= 1;
                            line_col = (line_col.0 + 1, 1);
                        }
                        Some(c) => {
                            pos -= c.len_utf8();
                            line_col = (line_col.0, line_col.1 + 1);
                        }
                        None => unreachable!(),
                    }
                }

                line_col
            }
            /// Returns the entire line of the input that contains this `Position`.
            #[inline]
            pub fn line_of(&self) -> &'i str {
                if self.pos > self.input.len() {
                    panic!("position out of bounds");
                };
                // Safe since start and end can only be valid UTF-8 borders.
                &self.input[self.find_line_start()..self.find_line_end()]
            }

            pub fn find_line_start(&self) -> usize {
                if self.input.is_empty() {
                    return 0;
                };
                // Position's pos is always a UTF-8 border.
                let start = self
                    .input
                    .char_indices()
                    .rev()
                    .skip_while(|&(i, _)| i >= self.pos)
                    .find(|&(_, c)| c == '\n');
                match start {
                    Some((i, _)) => i + 1,
                    None => 0,
                }
            }

            pub fn find_line_end(&self) -> usize {
                if self.input.is_empty() {
                    0
                } else if self.pos == self.input.len() - 1 {
                    self.input.len()
                } else {
                    // Position's pos is always a UTF-8 border.
                    let end = self
                        .input
                        .char_indices()
                        .skip_while(|&(i, _)| i < self.pos)
                        .find(|&(_, c)| c == '\n');
                    match end {
                        Some((i, _)) => i + 1,
                        None => self.input.len(),
                    }
                }
            }
            /// Returns `true` when the `Position` points to the start of the input `&str`.
            #[inline]
            pub fn at_start(&self) -> bool {
                self.pos == 0
            }
            /// Returns `true` when the `Position` points to the end of the input `&str`.
            #[inline]
            pub fn at_end(&self) -> bool {
                self.pos == self.input.len()
            }
            /// Skips `n` `char`s from the `Position` and returns `true` if the skip was possible or `false`
            /// otherwise. If the return value is `false`, `pos` will not be updated.
            #[inline]
            pub fn skip(&mut self, n: usize) -> bool {
                let skipped = {
                    let mut len = 0;
                    // Position's pos is always a UTF-8 border.
                    let mut chars = self.input[self.pos..].chars();
                    for _ in 0..n {
                        if let Some(c) = chars.next() {
                            len += c.len_utf8();
                        } else {
                            return false;
                        }
                    }
                    len
                };

                self.pos += skipped;
                true
            }
            /// Goes back `n` `char`s from the `Position` and returns `true` if the skip was possible or `false`
            /// otherwise. If the return value is `false`, `pos` will not be updated.
            #[inline]
            pub fn skip_back(&mut self, n: usize) -> bool {
                let skipped = {
                    let mut len = 0;
                    // Position's pos is always a UTF-8 border.
                    let mut chars = self.input[..self.pos].chars().rev();
                    for _ in 0..n {
                        if let Some(c) = chars.next() {
                            len += c.len_utf8();
                        } else {
                            return false;
                        }
                    }
                    len
                };

                self.pos -= skipped;
                true
            }
            /// Skips until one of the given `strings` is found. If none of the `strings` can be found,
            /// this function will return `false` but its `pos` will *still* be updated.
            #[inline]
            pub fn skip_until(&mut self, strings: &[&str]) -> bool {
                #[cfg(not(feature = "memchr"))]
                {
                    self.skip_until_basic(strings)
                }
                #[cfg(feature = "memchr")]
                {
                    match strings {
                        [] => (),
                        [s1] => {
                            if let Some(from) =
                                memchr::memmem::find(&self.input.as_bytes()[self.pos..], s1.as_bytes())
                            {
                                self.pos += from;
                                return true;
                            }
                        }
                        [s1, s2] if !s1.is_empty() && !s2.is_empty() => {
                            let b1 = s1.as_bytes()[0];
                            let b2 = s2.as_bytes()[0];
                            let miter = memchr::memchr2_iter(b1, b2, &self.input.as_bytes()[self.pos..]);
                            for from in miter {
                                let start = &self.input[self.pos + from..];
                                if start.starts_with(s1) || start.starts_with(s2) {
                                    self.pos += from;
                                    return true;
                                }
                            }
                        }
                        [s1, s2, s3] if !s1.is_empty() && !s2.is_empty() && s3.is_empty() => {
                            let b1 = s1.as_bytes()[0];
                            let b2 = s2.as_bytes()[0];
                            let b3 = s2.as_bytes()[0];
                            let miter =
                                memchr::memchr3_iter(b1, b2, b3, &self.input.as_bytes()[self.pos..]);
                            for from in miter {
                                let start = &self.input[self.pos + from..];
                                if start.starts_with(s1) || start.starts_with(s2) || start.starts_with(s3) {
                                    self.pos += from;
                                    return true;
                                }
                            }
                        }
                        _ => {
                            return self.skip_until_basic(strings);
                        }
                    }
                    self.pos = self.input.len();
                    false
                }
            }

            #[inline]
            fn skip_until_basic(&mut self, strings: &[&str]) -> bool {
                // TODO: optimize with Aho-Corasick, e.g. https://crates.io/crates/daachorse?
                for from in self.pos..self.input.len() {
                    let bytes = if let Some(string) = self.input.get(from..) {
                        string.as_bytes()
                    } else {
                        continue;
                    };

                    for slice in strings.iter() {
                        let to = slice.len();
                        if Some(slice.as_bytes()) == bytes.get(0..to) {
                            self.pos = from;
                            return true;
                        }
                    }
                }

                self.pos = self.input.len();
                false
            }
            /// Matches the char at the `Position` against a specified character and returns `true` if a match
            /// was made. If no match was made, returns `false`.
            /// `pos` will not be updated in either case.
            #[inline]
            pub fn match_char(&self, c: char) -> bool {
                matches!(self.input[self.pos..].chars().next(), Some(cc) if c == cc)
            }
            /// Matches the char at the `Position` against a filter function and returns `true` if a match
            /// was made. If no match was made, returns `false` and `pos` will not be updated.
            #[inline]
            pub fn match_char_by<F>(&mut self, f: F) -> bool
            where
                F: FnOnce(char) -> bool,
            {
                if let Some(c) = self.input[self.pos..].chars().next() {
                    if f(c) {
                        self.pos += c.len_utf8();
                        true
                    } else {
                        false
                    }
                } else {
                    false
                }
            }
            /// Matches `string` from the `Position` and returns `true` if a match was made or `false`
            /// otherwise. If no match was made, `pos` will not be updated.
            #[inline]
            pub fn match_string(&mut self, string: &str) -> bool {
                let to = self.pos + string.len();

                if Some(string.as_bytes()) == self.input.as_bytes().get(self.pos..to) {
                    self.pos = to;
                    true
                } else {
                    false
                }
            }
            /// Case-insensitively matches `string` from the `Position` and returns `true` if a match was
            /// made or `false` otherwise. If no match was made, `pos` will not be updated.
            #[inline]
            pub fn match_insensitive(&mut self, string: &str) -> bool {
                let matched = {
                    let slice = &self.input[self.pos..];
                    if let Some(slice) = slice.get(0..string.len()) {
                        slice.eq_ignore_ascii_case(string)
                    } else {
                        false
                    }
                };

                if matched {
                    self.pos += string.len();
                    true
                } else {
                    false
                }
            }
            /// Matches `char` `range` from the `Position` and returns `true` if a match was made or `false`
            /// otherwise. If no match was made, `pos` will not be updated.
            #[inline]
            pub fn match_range(&mut self, range: Range<char>) -> bool {
                if let Some(c) = self.input[self.pos..].chars().next() {
                    if range.start <= c && c <= range.end {
                        self.pos += c.len_utf8();
                        return true;
                    }
                }

                false
            }
        }

        impl<'i> fmt::Debug for Position<'i> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("Position").field("pos", &self.pos).finish()
            }
        }

        impl<'i> PartialEq for Position<'i> {
            fn eq(&self, other: &Position<'i>) -> bool {
                ptr::eq(self.input, other.input) && self.pos == other.pos
            }
        }

        impl<'i> Eq for Position<'i> {}

        #[allow(clippy::non_canonical_partial_ord_impl)]
        impl<'i> PartialOrd for Position<'i> {
            fn partial_cmp(&self, other: &Position<'i>) -> Option<Ordering> {
                if ptr::eq(self.input, other.input) {
                    self.pos.partial_cmp(&other.pos)
                } else {
                    None
                }
            }
        }

        impl<'i> Ord for Position<'i> {
            fn cmp(&self, other: &Position<'i>) -> Ordering {
                self.partial_cmp(other)
                    .expect("cannot compare positions from different strs")
            }
        }

        impl<'i> Hash for Position<'i> {
            fn hash<H: Hasher>(&self, state: &mut H) {
                (self.input as *const str).hash(state);
                self.pos.hash(state);
            }
        }
    }

    pub mod pratt_parser
    {
        //! Constructs useful in prefix, postfix, and infix operator parsing with the Pratt parsing method.
        use ::
        {
            *,
        };
        

        

        use core::iter::Peekable;
        use core::marker::PhantomData;
        use core::ops::BitOr;

        use alloc::boxed::Box;
        use alloc::collections::BTreeMap;

        use crate::iterators::Pair;
        use crate::RuleType;

        /// Associativity of an infix binary operator, used by [`Op::infix(Assoc)`].
        ///
        /// [`Op::infix(Assoc)`]: struct.Op.html
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum Assoc {
            /// Left operator associativity. Evaluate expressions from left-to-right.
            Left,
            /// Right operator associativity. Evaluate expressions from right-to-left.
            Right,
        }

        type Prec = u32;
        const PREC_STEP: Prec = 10;

        /// An operator that corresponds to a rule.
        pub struct Op<R: RuleType> {
            rule: R,
            affix: Affix,
            next: Option<Box<Op<R>>>,
        }

        enum Affix {
            Prefix,
            Postfix,
            Infix(Assoc),
        }

        impl<R: RuleType> Op<R> {
            /// Defines `rule` as a prefix unary operator.
            pub fn prefix(rule: R) -> Self {
                Self {
                    rule,
                    affix: Affix::Prefix,
                    next: None,
                }
            }
            /// Defines `rule` as a postfix unary operator.
            pub fn postfix(rule: R) -> Self {
                Self {
                    rule,
                    affix: Affix::Postfix,
                    next: None,
                }
            }
            /// Defines `rule` as an infix binary operator with associativity `assoc`.
            pub fn infix(rule: R, assoc: Assoc) -> Self {
                Self {
                    rule,
                    affix: Affix::Infix(assoc),
                    next: None,
                }
            }
        }

        impl<R: RuleType> BitOr for Op<R> {
            type Output = Self;

            fn bitor(mut self, rhs: Self) -> Self {
                fn assign_next<R: RuleType>(op: &mut Op<R>, next: Op<R>) {
                    if let Some(ref mut child) = op.next {
                        assign_next(child, next);
                    } else {
                        op.next = Some(Box::new(next));
                    }
                }

                assign_next(&mut self, rhs);
                self
            }
        }
        /// Struct containing operators and precedences, which can perform [Pratt parsing][1] on
        /// primary, prefix, postfix and infix expressions over [`Pairs`].
        pub struct PrattParser<R: RuleType> {
            prec: Prec,
            ops: BTreeMap<R, (Affix, Prec)>,
            has_prefix: bool,
            has_postfix: bool,
            has_infix: bool,
        }

        impl<R: RuleType> Default for PrattParser<R> {
            fn default() -> Self {
                Self::new()
            }
        }

        impl<R: RuleType> PrattParser<R> {
            /// Instantiate a new `PrattParser`.
            pub fn new() -> Self {
                Self {
                    prec: PREC_STEP,
                    ops: BTreeMap::new(),
                    has_prefix: false,
                    has_postfix: false,
                    has_infix: false,
                }
            }
            /// Add `op` to `PrattParser`.
            pub fn op(mut self, op: Op<R>) -> Self {
                self.prec += PREC_STEP;
                let mut iter = Some(op);
                while let Some(Op { rule, affix, next }) = iter.take() {
                    match affix {
                        Affix::Prefix => self.has_prefix = true,
                        Affix::Postfix => self.has_postfix = true,
                        Affix::Infix(_) => self.has_infix = true,
                    }
                    self.ops.insert(rule, (affix, self.prec));
                    iter = next.map(|op| *op);
                }
                self
            }
            /// Maps primary expressions with a closure `primary`.
            pub fn map_primary<'pratt, 'a, 'i, X, T>(
                &'pratt self,
                primary: X,
            ) -> PrattParserMap<'pratt, 'a, 'i, R, X, T>
            where
                X: FnMut(Pair<'i, R>) -> T,
                R: 'pratt,
            {
                PrattParserMap {
                    pratt: self,
                    primary,
                    prefix: None,
                    postfix: None,
                    infix: None,
                    phantom: PhantomData,
                }
            }
        }

        type PrefixFn<'a, 'i, R, T> = Box<dyn FnMut(Pair<'i, R>, T) -> T + 'a>;
        type PostfixFn<'a, 'i, R, T> = Box<dyn FnMut(T, Pair<'i, R>) -> T + 'a>;
        type InfixFn<'a, 'i, R, T> = Box<dyn FnMut(T, Pair<'i, R>, T) -> T + 'a>;

        /// Product of calling [`map_primary`] on [`PrattParser`], defines how expressions should be mapped.
        pub struct PrattParserMap<'pratt, 'a, 'i, R, F, T>
        where
            R: RuleType,
            F: FnMut(Pair<'i, R>) -> T,
        {
            pratt: &'pratt PrattParser<R>,
            primary: F,
            prefix: Option<PrefixFn<'a, 'i, R, T>>,
            postfix: Option<PostfixFn<'a, 'i, R, T>>,
            infix: Option<InfixFn<'a, 'i, R, T>>,
            phantom: PhantomData<T>,
        }

        impl<'pratt, 'a, 'i, R, F, T> PrattParserMap<'pratt, 'a, 'i, R, F, T>
        where
            R: RuleType + 'pratt,
            F: FnMut(Pair<'i, R>) -> T,
        {
            /// Maps prefix operators with closure `prefix`.
            pub fn map_prefix<X>(mut self, prefix: X) -> Self
            where
                X: FnMut(Pair<'i, R>, T) -> T + 'a,
            {
                self.prefix = Some(Box::new(prefix));
                self
            }
            /// Maps postfix operators with closure `postfix`.
            pub fn map_postfix<X>(mut self, postfix: X) -> Self
            where
                X: FnMut(T, Pair<'i, R>) -> T + 'a,
            {
                self.postfix = Some(Box::new(postfix));
                self
            }
            /// Maps infix operators with a closure `infix`.
            pub fn map_infix<X>(mut self, infix: X) -> Self
            where
                X: FnMut(T, Pair<'i, R>, T) -> T + 'a,
            {
                self.infix = Some(Box::new(infix));
                self
            }
            /// The last method to call on the provided pairs to execute the Pratt
            /// parser (previously defined using [`map_primary`], [`map_prefix`], [`map_postfix`],
            /// and [`map_infix`] methods).
            ///
            /// [`map_primary`]: struct.PrattParser.html#method.map_primary
            /// [`map_prefix`]: struct.PrattParserMap.html#method.map_prefix
            /// [`map_postfix`]: struct.PrattParserMap.html#method.map_postfix
            /// [`map_infix`]: struct.PrattParserMap.html#method.map_infix
            pub fn parse<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: P) -> T {
                self.expr(&mut pairs.peekable(), 0)
            }

            fn expr<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: &mut Peekable<P>, rbp: Prec) -> T {
                let mut lhs = self.nud(pairs);
                while rbp < self.lbp(pairs) {
                    lhs = self.led(pairs, lhs);
                }
                lhs
            }
            /// Null-Denotation
            ///
            /// "the action that should happen when the symbol is encountered
            ///  as start of an expression (most notably, prefix operators)
            fn nud<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: &mut Peekable<P>) -> T {
                let pair = pairs.next().expect("Pratt parsing expects non-empty Pairs");
                match self.pratt.ops.get(&pair.as_rule()) {
                    Some((Affix::Prefix, prec)) => {
                        let rhs = self.expr(pairs, *prec - 1);
                        match self.prefix.as_mut() {
                            Some(prefix) => prefix(pair, rhs),
                            None => panic!("Could not map {}, no `.map_prefix(...)` specified", pair),
                        }
                    }
                    None => (self.primary)(pair),
                    _ => panic!("Expected prefix or primary expression, found {}", pair),
                }
            }
            /// Left-Denotation
            ///
            /// "the action that should happen when the symbol is encountered
            /// after the start of an expression (most notably, infix and postfix operators)"
            fn led<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: &mut Peekable<P>, lhs: T) -> T {
                let pair = pairs.next().unwrap();
                match self.pratt.ops.get(&pair.as_rule()) {
                    Some((Affix::Infix(assoc), prec)) => {
                        let rhs = match *assoc {
                            Assoc::Left => self.expr(pairs, *prec),
                            Assoc::Right => self.expr(pairs, *prec - 1),
                        };
                        match self.infix.as_mut() {
                            Some(infix) => infix(lhs, pair, rhs),
                            None => panic!("Could not map {}, no `.map_infix(...)` specified", pair),
                        }
                    }
                    Some((Affix::Postfix, _)) => match self.postfix.as_mut() {
                        Some(postfix) => postfix(lhs, pair),
                        None => panic!("Could not map {}, no `.map_postfix(...)` specified", pair),
                    },
                    _ => panic!("Expected postfix or infix expression, found {}", pair),
                }
            }
            /// Left-Binding-Power
            ///
            /// "describes the symbol's precedence in infix form (most notably, operator precedence)"
            fn lbp<P: Iterator<Item = Pair<'i, R>>>(&mut self, pairs: &mut Peekable<P>) -> Prec {
                match pairs.peek() {
                    Some(pair) => match self.pratt.ops.get(&pair.as_rule()) {
                        Some((_, prec)) => *prec,
                        None => panic!("Expected operator, found {}", pair),
                    },
                    None => 0,
                }
            }
        }
    }

    pub mod prec_climber
    {
        //! Constructs useful in infix operator parsing with the precedence climbing method.
        use ::
        {
            *,
        };
        

        

        use alloc::borrow::Cow;
        use alloc::boxed::Box;
        use alloc::vec::Vec;
        use core::iter::Peekable;
        use core::ops::BitOr;

        use crate::iterators::Pair;
        use crate::RuleType;

        /// Macro for more convenient const fn definition of `prec_climber::PrecClimber`.
        #[cfg(feature = "const_prec_climber")]
        #[macro_export]
        macro_rules! prec_climber {
            (
                $( $assoc:ident $rule:ident $( | $rules:ident )* ),+ $(,)?
            ) => {{
                prec_climber!(
                    @precedences { 1u32 }
                    $( [ $rule $( $rules )* ] )*
                );

                $crate::prec_climber::PrecClimber::new_const(
                    prec_climber!(
                        @array
                        $( $assoc $rule $(, $assoc $rules )* ),*
                    )
                )
            }};

            ( @assoc L ) => { $crate::prec_climber::Assoc::Left };
            ( @assoc R ) => { $crate::prec_climber::Assoc::Right };

            (
                @array
                $(
                    $assoc:ident $rule:ident
                ),*
            ) => {
                &[
                    $(
                        (
                            Rule::$rule,
                            $rule,
                            prec_climber!( @assoc $assoc ),
                        )
                    ),*
                ]
            };

            (
                @precedences { $precedence:expr }
            ) => {};

            (
                @precedences { $precedence:expr }
                [ $( $rule:ident )* ]
                $( [ $( $rules:ident )* ] )*
            ) => {
                $(
                    #[allow(non_upper_case_globals)]
                    const $rule: u32 = $precedence;
                )*
                prec_climber!(
                    @precedences { 1u32 + $precedence }
                    $( [ $( $rules )* ] )*
                );
            };
        }
        /// Associativity of an [`Operator`].
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub enum Assoc {
            /// Left `Operator` associativity
            Left,
            /// Right `Operator` associativity
            Right,
        }
        /// Infix operator used in [`PrecClimber`].
        #[derive(Debug)]
        pub struct Operator<R: RuleType> {
            rule: R,
            assoc: Assoc,
            next: Option<Box<Operator<R>>>,
        }

        impl<R: RuleType> Operator<R> {
            /// Creates a new `Operator` from a `Rule` and `Assoc`.
            pub fn new(rule: R, assoc: Assoc) -> Operator<R> {
                Operator {
                    rule,
                    assoc,
                    next: None,
                }
            }
        }

        impl<R: RuleType> BitOr for Operator<R> {
            type Output = Self;

            fn bitor(mut self, rhs: Self) -> Self {
                fn assign_next<R: RuleType>(op: &mut Operator<R>, next: Operator<R>) {
                    if let Some(ref mut child) = op.next {
                        assign_next(child, next);
                    } else {
                        op.next = Some(Box::new(next));
                    }
                }

                assign_next(&mut self, rhs);
                self
            }
        }
        /// List of operators and precedences, which can perform [precedence climbing] on infix expressions contained in a [`Pairs`].
        #[derive(Debug)]
        pub struct PrecClimber<R: Clone + 'static> {
            ops: Cow<'static, [(R, u32, Assoc)]>,
        }

        #[cfg(feature = "const_prec_climber")]
        impl<R: Clone + 'static> PrecClimber<R> {
            /// Creates a new `PrecClimber` directly from a static slice of  `(rule: Rule, precedence: u32, associativity: Assoc)` tuples.
            pub const fn new_const(ops: &'static [(R, u32, Assoc)]) -> PrecClimber<R> {
                PrecClimber {
                    ops: Cow::Borrowed(ops),
                }
            }
        }

        impl<R: RuleType> PrecClimber<R> {
            // find matching operator by `rule`
            fn get(&self, rule: &R) -> Option<(u32, Assoc)> {
                self.ops
                    .iter()
                    .find(|(r, _, _)| r == rule)
                    .map(|(_, precedence, assoc)| (*precedence, *assoc))
            }
            /// Creates a new `PrecClimber` from the `Operator`s contained in `ops`.
            pub fn new(ops: Vec<Operator<R>>) -> PrecClimber<R> {
                let ops = ops
                    .into_iter()
                    .zip(1..)
                    .fold(Vec::new(), |mut vec, (op, prec)| {
                        let mut next = Some(op);

                        while let Some(op) = next.take() {
                            let Operator {
                                rule,
                                assoc,
                                next: op_next,
                            } = op;

                            vec.push((rule, prec, assoc));
                            next = op_next.map(|op| *op);
                        }

                        vec
                    });

                PrecClimber {
                    ops: Cow::Owned(ops),
                }
            }
            /// Performs the precedence climbing algorithm on the `pairs` in a similar manner to map-reduce.
            pub fn climb<'i, P, F, G, T>(&self, mut pairs: P, mut primary: F, mut infix: G) -> T
            where
                P: Iterator<Item = Pair<'i, R>>,
                F: FnMut(Pair<'i, R>) -> T,
                G: FnMut(T, Pair<'i, R>, T) -> T,
            {
                let lhs = primary(
                    pairs
                        .next()
                        .expect("precedence climbing requires a non-empty Pairs"),
                );
                self.climb_rec(lhs, 0, &mut pairs.peekable(), &mut primary, &mut infix)
            }

            fn climb_rec<'i, P, F, G, T>(
                &self,
                mut lhs: T,
                min_prec: u32,
                pairs: &mut Peekable<P>,
                primary: &mut F,
                infix: &mut G,
            ) -> T
            where
                P: Iterator<Item = Pair<'i, R>>,
                F: FnMut(Pair<'i, R>) -> T,
                G: FnMut(T, Pair<'i, R>, T) -> T,
            {
                while pairs.peek().is_some() {
                    let rule = pairs.peek().unwrap().as_rule();
                    if let Some((prec, _)) = self.get(&rule) {
                        if prec >= min_prec {
                            let op = pairs.next().unwrap();
                            let mut rhs = primary(pairs.next().expect(
                                "infix operator must be followed by \
                                a primary expression",
                            ));

                            while pairs.peek().is_some() {
                                let rule = pairs.peek().unwrap().as_rule();
                                if let Some((new_prec, assoc)) = self.get(&rule) {
                                    if new_prec > prec || assoc == Assoc::Right && new_prec == prec {
                                        rhs = self.climb_rec(rhs, new_prec, pairs, primary, infix);
                                    } else {
                                        break;
                                    }
                                } else {
                                    break;
                                }
                            }

                            lhs = infix(lhs, op, rhs);
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                lhs
            }
        }
    }

    pub mod span
    {
        use ::
        {
            *,
        };
        

        use core::fmt;
        use core::hash::{Hash, Hasher};
        use core::ops::{Bound, RangeBounds};
        use core::ptr;
        use core::str;

        use crate::position;

        /// A span over a `&str`. It is created from either [two `Position`s] or from a [`Pair`].
        ///
        /// [two `Position`s]: struct.Position.html#method.span
        /// [`Pair`]: ../iterators/struct.Pair.html#method.span
        #[derive(Clone, Copy)]
        pub struct Span<'i> {
            input: &'i str,
            start: usize,
            end: usize,
        }

        impl<'i> Span<'i> {
            /// Create a new `Span` without checking invariants. (Checked with `debug_assertions`.)
            pub fn new_internal(input: &str, start: usize, end: usize) -> Span<'_> {
                debug_assert!(input.get(start..end).is_some());
                Span { input, start, end }
            }
            /// Attempts to create a new span. Will return `None` if `input[start..end]` is an invalid index
            /// into `input`.
            pub fn new(input: &str, start: usize, end: usize) -> Option<Span<'_>> {
                if input.get(start..end).is_some() {
                    Some(Span { input, start, end })
                } else {
                    None
                }
            }
            /// Attempts to create a new span based on a sub-range.
            pub fn get(&self, range: impl RangeBounds<usize>) -> Option<Span<'i>> {
                let start = match range.start_bound() {
                    Bound::Included(offset) => *offset,
                    Bound::Excluded(offset) => *offset + 1,
                    Bound::Unbounded => 0,
                };
                let end = match range.end_bound() {
                    Bound::Included(offset) => *offset + 1,
                    Bound::Excluded(offset) => *offset,
                    Bound::Unbounded => self.as_str().len(),
                };

                self.as_str().get(start..end).map(|_| Span {
                    input: self.input,
                    start: self.start + start,
                    end: self.start + end,
                })
            }
            /// Returns the `Span`'s start byte position as a `usize`.
            #[inline]
            pub fn start(&self) -> usize {
                self.start
            }
            /// Returns the `Span`'s end byte position as a `usize`.
            #[inline]
            pub fn end(&self) -> usize {
                self.end
            }
            /// Returns the `Span`'s start `Position`.
            #[inline]
            pub fn start_pos(&self) -> position::Position<'i> {
                position::Position::new_internal(self.input, self.start)
            }
            /// Returns the `Span`'s end `Position`.
            #[inline]
            pub fn end_pos(&self) -> position::Position<'i> {
                position::Position::new_internal(self.input, self.end)
            }
            /// Splits the `Span` into a pair of `Position`s.
            #[inline]
            pub fn split(self) -> (position::Position<'i>, position::Position<'i>) {
                let pos1 = position::Position::new_internal(self.input, self.start);
                let pos2 = position::Position::new_internal(self.input, self.end);

                (pos1, pos2)
            }
            /// Captures a slice from the `&str` defined by the `Span`.
            #[inline]
            pub fn as_str(&self) -> &'i str {
                // Span's start and end positions are always a UTF-8 borders.
                &self.input[self.start..self.end]
            }
            /// Returns the input string of the `Span`.
            pub fn get_input(&self) -> &'i str {
                self.input
            }
            /// Iterates over all lines (partially) covered by this span. Yielding a `&str` for each line.
            #[inline]
            pub fn lines(&self) -> Lines<'_> {
                Lines {
                    inner: self.lines_span(),
                }
            }
            /// Iterates over all lines (partially) covered by this span. Yielding a `Span` for each line.
            pub fn lines_span(&self) -> LinesSpan<'_> {
                LinesSpan {
                    span: self,
                    pos: self.start,
                }
            }
        }

        impl<'i> fmt::Debug for Span<'i> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("Span")
                    .field("str", &self.as_str())
                    .field("start", &self.start)
                    .field("end", &self.end)
                    .finish()
            }
        }

        impl<'i> PartialEq for Span<'i> {
            fn eq(&self, other: &Span<'i>) -> bool {
                ptr::eq(self.input, other.input) && self.start == other.start && self.end == other.end
            }
        }

        impl<'i> Eq for Span<'i> {}

        impl<'i> Hash for Span<'i> {
            fn hash<H: Hasher>(&self, state: &mut H) {
                (self.input as *const str).hash(state);
                self.start.hash(state);
                self.end.hash(state);
            }
        }
        /// Merges two spans into one.
        pub fn merge_spans<'i>(a: &Span<'i>, b: &Span<'i>) -> Option<Span<'i>> {
            if a.end() >= b.start() && a.start() <= b.end() {
                // The spans overlap or are contiguous, so they can be merged.
                Span::new(
                    a.get_input(),
                    core::cmp::min(a.start(), b.start()),
                    core::cmp::max(a.end(), b.end()),
                )
            } else {
                // The spans don't overlap and aren't contiguous, so they can't be merged.
                None
            }
        }
        /// Line iterator for Spans, created by [`Span::lines_span()`].
        pub struct LinesSpan<'i> {
            span: &'i Span<'i>,
            pos: usize,
        }

        impl<'i> Iterator for LinesSpan<'i> {
            type Item = Span<'i>;
            fn next(&mut self) -> Option<Self::Item> {
                if self.pos > self.span.end {
                    return None;
                }
                let pos = position::Position::new(self.span.input, self.pos)?;
                if pos.at_end() {
                    return None;
                }

                let line_start = pos.find_line_start();
                self.pos = pos.find_line_end();

                Span::new(self.span.input, line_start, self.pos)
            }
        }
        /// Line iterator for Spans, created by [`Span::lines()`].
        pub struct Lines<'i> {
            inner: LinesSpan<'i>,
        }

        impl<'i> Iterator for Lines<'i> {
            type Item = &'i str;
            fn next(&mut self) -> Option<Self::Item> {
                self.inner.next().map(|span| span.as_str())
            }
        }
    }

    pub mod stack
    {
        use ::
        {
            *,
        };
        

        use alloc::vec;
        use alloc::vec::Vec;
        use core::ops::{Index, Range};

        /// Implementation of a `Stack` which maintains popped elements and length of previous states
        /// in order to rewind the stack to a previous state.
        #[derive(Debug)]
        pub struct Stack<T: Clone> {
            /// All elements in the stack.
            cache: Vec<T>,
            /// All elements that are in previous snapshots but may not be in the next state.
            /// They will be pushed back to `cache` if the snapshot is restored,
            /// otherwise be dropped if the snapshot is cleared.
            ///
            /// Those elements from a sequence of snapshots are stacked in one [`Vec`], and
            /// `popped.len() == lengths.iter().map(|(len, remained)| len - remained).sum()`
            popped: Vec<T>,
            /// Every element corresponds to a snapshot, and each element has two fields:
            /// - Length of `cache` when corresponding snapshot is taken (AKA `len`).
            /// - Count of elements that come from corresponding snapshot
            ///   and are still in next snapshot or current state (AKA `remained`).
            ///
            /// And `len` is never less than `remained`.
            ///
            /// On restoring, the `cache` can be divided into two parts:
            /// - `0..remained` are untouched since the snapshot is taken.
            ///
            ///   There's nothing to do with those elements. Just let them stay where they are.
            ///
            /// - `remained..cache.len()` are pushed after the snapshot is taken.
            lengths: Vec<(usize, usize)>,
        }

        impl<T: Clone> Default for Stack<T> {
            fn default() -> Self {
                Self::new()
            }
        }

        impl<T: Clone> Stack<T> {
            /// Creates a new `Stack`.
            pub fn new() -> Self {
                Stack {
                    cache: vec![],
                    popped: vec![],
                    lengths: vec![],
                }
            }
            /// Returns `true` if the stack is currently empty.
            
            pub fn is_empty(&self) -> bool {
                self.cache.is_empty()
            }
            /// Returns the top-most `&T` in the `Stack`.
            pub fn peek(&self) -> Option<&T> {
                self.cache.last()
            }
            /// Pushes a `T` onto the `Stack`.
            pub fn push(&mut self, elem: T) {
                self.cache.push(elem);
            }
            /// Pops the top-most `T` from the `Stack`.
            pub fn pop(&mut self) -> Option<T> {
                let len = self.cache.len();
                let popped = self.cache.pop();
                if let Some(popped) = &popped {
                    if let Some((_, remained_count)) = self.lengths.last_mut() {
                        // `len >= *unpopped_count`
                        if len == *remained_count {
                            *remained_count -= 1;
                            self.popped.push(popped.clone());
                        }
                    }
                }
                popped
            }
            /// Returns the size of the stack
            pub fn len(&self) -> usize {
                self.cache.len()
            }
            /// Takes a snapshot of the current `Stack`.
            pub fn snapshot(&mut self) {
                self.lengths.push((self.cache.len(), self.cache.len()))
            }
            /// The parsing after the last snapshot was successful so clearing it.
            pub fn clear_snapshot(&mut self) {
                if let Some((len, unpopped)) = self.lengths.pop() {
                    // Popped elements from previous state are no longer needed.
                    self.popped.truncate(self.popped.len() - (len - unpopped));
                }
            }
            /// Rewinds the `Stack` to the most recent `snapshot()`. If no `snapshot()` has been taken, this
            /// function return the stack to its initial state.
            pub fn restore(&mut self) {
                match self.lengths.pop() {
                    Some((len_stack, remained)) => {
                        if remained < self.cache.len() {
                            // Remove those elements that are pushed after the snapshot.
                            self.cache.truncate(remained);
                        }
                        if len_stack > remained {
                            let rewind_count = len_stack - remained;
                            let new_len = self.popped.len() - rewind_count;
                            let recovered_elements = self.popped.drain(new_len..);
                            self.cache.extend(recovered_elements.rev());
                            debug_assert_eq!(self.popped.len(), new_len);
                        }
                    }
                    None => {
                        self.cache.clear();
                        // As `self.popped` and `self.lengths` should already be empty,
                        // there is no need to clear it.
                        debug_assert!(self.popped.is_empty());
                        debug_assert!(self.lengths.is_empty());
                    }
                }
            }
        }

        impl<T: Clone> Index<Range<usize>> for Stack<T> {
            type Output = [T];

            fn index(&self, range: Range<usize>) -> &[T] {
                self.cache.index(range)
            }
        }
    }

    pub mod token
    {
        use ::
        {
            *,
        };
        

        use crate::position::Position;

        /// A token generated by a `Parser`.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub enum Token<'i, R> {
            /// The starting `Position` of a matched `Rule`
            Start {
                /// matched rule
                rule: R,
                /// starting position
                pos: Position<'i>,
            },
            /// The ending `Position` of a matched `Rule`
            End {
                /// matched rule
                rule: R,
                /// ending position
                pos: Position<'i>,
            },
        }
    }
    
    pub mod unicode
    {
        //! Character inclusion in binary or General_Category value Unicode sets.
        use ::
        {
            *,
        };
        

        #![allow(bad_style)]
        #![allow(clippy::all)]

        use alloc::boxed::Box;

        macro_rules! property_functions {
            ($module:ident, $property_names:ident, [$(
                $prop:ident,
            )*]) => {
                #[allow(unused)]
                mod $module;
                // unicode::ALPHABETIC('a')
                $(pub fn $prop(c: char) -> bool {
                    self::$module::$prop.contains_char(c)
                })*

                pub static $property_names: &[&str] = &[
                    $(stringify!($prop),)*
                ];
            };
        }

        macro_rules! char_property_functions {
            // For define custom property names
            {$(
                mod $module:ident;
                static $property_names:ident = [$(
                    $prop:ident,
                )*];
            )*} => {$(
                property_functions!($module, $property_names, [$(
                    $prop,
                )*]);
            )*};
            // For define property by copy BY_NAME values from `ucd-generate` generated.
            {$(
                mod $module:ident;
                static $property_names:ident = [$(
                    ($_name:tt, $prop:ident),
                )*];
            )*} => {$(
                property_functions!($module, $property_names, [$(
                    $prop,
                )*]);
            )*};
        }

        char_property_functions! {
            mod binary
            {
                // DO NOT EDIT THIS FILE. IT WAS AUTOMATICALLY GENERATED BY:
                //
                //   ucd-generate property-bool --trie-set ./target/ucd/
                //
                // Unicode version: 16.0.0.
                //
                // ucd-generate 0.3.1 is available on crates.io.

                pub const BY_NAME: &'static [(&'static str, &'static ::ucd_trie::TrieSet)] = &[
                ("ASCII_Hex_Digit", ASCII_HEX_DIGIT), ("Alphabetic", ALPHABETIC),
                ("Bidi_Control", BIDI_CONTROL), ("Bidi_Mirrored", BIDI_MIRRORED),
                ("Case_Ignorable", CASE_IGNORABLE), ("Cased", CASED),
                ("Changes_When_Casefolded", CHANGES_WHEN_CASEFOLDED),
                ("Changes_When_Casemapped", CHANGES_WHEN_CASEMAPPED),
                ("Changes_When_Lowercased", CHANGES_WHEN_LOWERCASED),
                ("Changes_When_Titlecased", CHANGES_WHEN_TITLECASED),
                ("Changes_When_Uppercased", CHANGES_WHEN_UPPERCASED), ("Dash", DASH),
                ("Default_Ignorable_Code_Point", DEFAULT_IGNORABLE_CODE_POINT),
                ("Deprecated", DEPRECATED), ("Diacritic", DIACRITIC), ("Emoji", EMOJI),
                ("Emoji_Component", EMOJI_COMPONENT), ("Emoji_Modifier", EMOJI_MODIFIER),
                ("Emoji_Modifier_Base", EMOJI_MODIFIER_BASE),
                ("Emoji_Presentation", EMOJI_PRESENTATION),
                ("Extended_Pictographic", EXTENDED_PICTOGRAPHIC), ("Extender", EXTENDER),
                ("Grapheme_Base", GRAPHEME_BASE), ("Grapheme_Extend", GRAPHEME_EXTEND),
                ("Grapheme_Link", GRAPHEME_LINK), ("Hex_Digit", HEX_DIGIT),
                ("Hyphen", HYPHEN), ("IDS_Binary_Operator", IDS_BINARY_OPERATOR),
                ("IDS_Trinary_Operator", IDS_TRINARY_OPERATOR),
                ("IDS_Unary_Operator", IDS_UNARY_OPERATOR),
                ("ID_Compat_Math_Continue", ID_COMPAT_MATH_CONTINUE),
                ("ID_Compat_Math_Start", ID_COMPAT_MATH_START),
                ("ID_Continue", ID_CONTINUE), ("ID_Start", ID_START),
                ("Ideographic", IDEOGRAPHIC), ("InCB", INCB),
                ("Join_Control", JOIN_CONTROL),
                ("Logical_Order_Exception", LOGICAL_ORDER_EXCEPTION),
                ("Lowercase", LOWERCASE), ("Math", MATH),
                ("Modifier_Combining_Mark", MODIFIER_COMBINING_MARK),
                ("Noncharacter_Code_Point", NONCHARACTER_CODE_POINT),
                ("Other_Alphabetic", OTHER_ALPHABETIC),
                ("Other_Default_Ignorable_Code_Point", OTHER_DEFAULT_IGNORABLE_CODE_POINT),
                ("Other_Grapheme_Extend", OTHER_GRAPHEME_EXTEND),
                ("Other_ID_Continue", OTHER_ID_CONTINUE),
                ("Other_ID_Start", OTHER_ID_START), ("Other_Lowercase", OTHER_LOWERCASE),
                ("Other_Math", OTHER_MATH), ("Other_Uppercase", OTHER_UPPERCASE),
                ("Pattern_Syntax", PATTERN_SYNTAX),
                ("Pattern_White_Space", PATTERN_WHITE_SPACE),
                ("Prepended_Concatenation_Mark", PREPENDED_CONCATENATION_MARK),
                ("Quotation_Mark", QUOTATION_MARK), ("Radical", RADICAL),
                ("Regional_Indicator", REGIONAL_INDICATOR),
                ("Sentence_Terminal", SENTENCE_TERMINAL), ("Soft_Dotted", SOFT_DOTTED),
                ("Terminal_Punctuation", TERMINAL_PUNCTUATION),
                ("Unified_Ideograph", UNIFIED_IDEOGRAPH), ("Uppercase", UPPERCASE),
                ("Variation_Selector", VARIATION_SELECTOR), ("White_Space", WHITE_SPACE),
                ("XID_Continue", XID_CONTINUE), ("XID_Start", XID_START),
                ];

                pub const ASCII_HEX_DIGIT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0x7E0000007E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const ALPHABETIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3, 0, 0xBCDFFFF800000020,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF027FFFFF, 0xBFFF0000000001FF,
                    0x787FFFFFF00B6, 0xFFFFFFFF07FF0000, 0xFFFFC000FEFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x9C00E1FE1FEFFFFF, 0xFFFFFFFFFFFF0000,
                    0xFFFFFFFFFFFFE000, 0x3FFFFFFFFFFFF, 0x43007FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36,
                    36, 36, 37, 38, 39, 40, 41, 42, 43, 44, 36, 36, 36, 36, 36, 36, 36, 36,
                    45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
                    63, 64, 65, 66, 67, 68, 69, 70, 71, 36, 36, 36, 72, 36, 36, 36, 36, 73,
                    74, 75, 76, 31, 77, 78, 31, 79, 80, 81, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 82, 83, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 36, 36, 36,
                    84, 85, 86, 87, 88, 89, 31, 31, 31, 31, 31, 31, 31, 90, 44, 91, 92, 93,
                    36, 94, 95, 31, 31, 31, 31, 31, 31, 31, 31, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 31, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 96, 97, 36, 36, 36, 36, 98,
                    99, 36, 100, 101, 36, 102, 103, 104, 105, 36, 106, 107, 108, 109, 110, 68,
                    111, 112, 113, 114, 115, 36, 116, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 117, 118, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 36, 36, 36, 36, 36, 119, 36, 120,
                    121, 122, 123, 124, 36, 36, 36, 36, 125, 33, 126, 127, 31, 128, 36, 129,
                    130, 131, 112, 132,
                ],
                tree2_level2: &[
                    0x1FFFFCFFFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00807EFF,
                    0xFFFF03F8FFF003FF, 0xEFFFFFFFFFFFFFFF, 0xFFFE000FFFE1DFFF,
                    0xE3C5FDFFFFF99FEF, 0x1003000FB080599F, 0xC36DFDFFFFF987EE,
                    0x3F00005E021987, 0xE3EDFDFFFFFBBFEE, 0x1E00000F00011BBF,
                    0xE3EDFDFFFFF99FEE, 0x2000FB0C0199F, 0xC3FFC718D63DC7EC, 0x811DC7,
                    0xE3FFFDFFFFFDDFFF, 0xF27601DDF, 0xE3EFFDFFFFFDDFEF, 0xE000F60601DDF,
                    0xE7FFFFFFFFFDDFFF, 0xFC00000F80F05DDF, 0x2FFBFFFFFC7FFFEE,
                    0xC0000FF5F807F, 0x7FFFFFFFFFFFFFE, 0x207F, 0x3BFFFFAFFFFFF7D6,
                    0xF000205F, 0x1, 0xFFFE1FFFFFFFFEFF, 0x1FFFFFFFFEFFFF0F, 0,
                    0xF97FFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFF3C00FFFF,
                    0xF7FFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF,
                    0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x7FFFFFF,
                    0xFFFFFFFF0000FFFF, 0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF,
                    0xFFFFF800FFFFF, 0xDDFFF000FFFFF, 0xFFCFFFFFFFFFFFFF, 0x108001FF,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFFF, 0xFFFF07FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0x1FF0FFF7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF,
                    0x3FF, 0xFFFFFFFF0FFFFFFF, 0x1FFFFE7FFFFFFF, 0x8000008000000000, 0x7001,
                    0xFFEFFFFFFFFFFFFF, 0x1FEF, 0xFC00F3FFFFFFFFFF, 0x3FFBFFFFFFFFF,
                    0x7FFFFFFFFFFFFF, 0x3FFFFFFFFC00E000, 0xE7FFFFFFFFFF07FF,
                    0x46FDE0000000000, 0x1FFFFFFFF80000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF3FFBD503E2FFC84, 0xFFFFFFFF000043E0,
                    0x1FF, 0xFFC0000000000000, 0x3FFFFFFFFFF, 0xC781FFFFFFFFF,
                    0xFFFF20BFFFFFFFFF, 0x80FFFFFFFFFF, 0x7F7F7F7F007FFFFF,
                    0xFFFFFFFF7F7F7F7F, 0x800000000000, 0x1F3E03FE000000E0,
                    0xFFFFFFFEE07FFFFF, 0xF7FFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFE0,
                    0xFFFFFFFF00007FFF, 0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000,
                    0xC00FFFF1FFF, 0x8FF07FFFFFFFFFFF, 0xFFFFFFFFFFFF, 0xFFFFFFFCFF800000,
                    0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0xFFFFFFFFBF, 0xFFFFFFFFFFFFF,
                    0xE8FC00000000002F, 0xFFFF07FFFFFFFC00, 0x1FFFFFFF0007FFFF,
                    0xFFF7FFFFFFFFFFFF, 0x7C00FFFF00008000, 0xFC7FFFFF00003FFF,
                    0x7FFFFFFFFFFFFFFF, 0x3CFFFF38000005, 0xFFFF7F7F007E7E7E,
                    0xFFFF03FFF7FFFFFF, 0x7FFFFFFFFFF, 0xFFFF000FFFFFFFFF, 0xFFFFFFFFFFFF87F,
                    0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFE0F8007F, 0xFFFFFFFFFFFFFFDB,
                    0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000, 0x3FFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFCFFFF, 0xFFF0000000000FF, 0xFFDF000000000000,
                    0x1FFFFFFFFFFFFFFF, 0x7FFFFFE00000000, 0xFFFFFFC007FFFFFE, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 5, 11, 12, 13, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 14, 15, 16, 7, 17, 18, 7, 19, 20, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15,
                    16, 17, 2, 2, 2, 2, 18, 19, 20, 4, 21, 22, 23, 24, 25, 4, 26, 4, 27, 28,
                    29, 30, 31, 32, 33, 4, 2, 34, 35, 35, 36, 37, 38, 4, 4, 4, 39, 40, 41, 42,
                    43, 44, 2, 45, 46, 47, 35, 48, 2, 49, 50, 51, 52, 53, 54, 55, 56, 57, 2,
                    58, 2, 59, 4, 4, 60, 61, 62, 63, 64, 4, 65, 66, 4, 4, 46, 4, 67, 68, 69,
                    70, 71, 72, 73, 74, 75, 46, 4, 4, 4, 76, 77, 78, 79, 4, 80, 81, 82, 4, 4,
                    4, 4, 83, 84, 85, 86, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 87, 4,
                    2, 88, 2, 2, 2, 89, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 74, 90,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 91, 92, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 66, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 88,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 46, 93, 62, 94, 91, 95, 96, 4, 4, 4, 4, 4,
                    4, 97, 4, 4, 4, 2, 4, 4, 2, 98, 99, 100, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 101, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 102, 34, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 103, 2, 2, 2, 2, 104, 105, 2, 2, 2, 2, 2, 106, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 107, 108, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 109, 110, 111,
                    112, 113, 2, 2, 2, 2, 114, 115, 116, 117, 118, 119, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 120, 4, 4,
                    4, 121, 122, 123, 4, 124, 125, 4, 4, 4, 4, 94, 126, 4, 4, 4, 4, 4, 4, 4,
                    127, 4, 4, 4, 128, 4, 4, 4, 4, 4, 4, 4, 129, 2, 2, 2, 130, 2, 131, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 132, 133, 134, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 135, 136, 137, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 138, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 139, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 140, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 141, 2, 2, 2, 2, 2, 2, 2, 2, 2, 142, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 142, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 143, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 91, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF,
                    0x7FFFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F, 0xFFFF00003FFFFFFF,
                    0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF, 0xF7FF000FFFFFFFFF,
                    0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                    0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF,
                    0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEFF06F,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF, 0xFFFFFFFFFF,
                    0xFFFF823FFFFFFC00, 0x3F, 0x31BFFFFFFFFFF, 0x100000000000001C,
                    0xFFFF00801FFFFFFF, 0xFFFF00000000003F, 0xFFFF000000000003,
                    0x7FFFFF0000001F, 0x3E00000000003F, 0x1FFFFFFFFFFFFFF, 0x1FFFFFF0004,
                    0x47FFFFFFFF00F0, 0x1400C01E, 0xC09FFFFFFFFBFFFF, 0x3, 0xFFFF01FFBFFFBD7F,
                    0x1FFFFFFFFFF, 0xE3EDFDFFFFF99FEF, 0xFE081199F, 0xFFBFFFFFFFFF4BFF,
                    0xA37A5, 0x3800007BB, 0xB3, 0x7F3FFFFFFFFFFFFF, 0x3F000000,
                    0x7FFFFFFFFFFFFFFF, 0x11, 0x13FFFFFFFFFFFFF, 0x7FFE7FFFFFF, 0x7F,
                    0xFFFFFFFF00000000, 0x80000000FFFFFFFF, 0x99BFFFFFFF6FF27F, 0x7,
                    0xFFFFFCFF00000000, 0x1AFCFFFFFF, 0x7FE7FFFFFFFFFFFF, 0xFFFFFFFFFFFF0000,
                    0xFFFF000020FFFFFF, 0x1FFFFFFFF, 0x7F7FFFFFFFFFFDFF, 0xFFFC000000000001,
                    0x7FFEFFFFFCFFFF, 0xB47FFFFFFFFFFB7F, 0xFFFFFDBF000000CB, 0x17B7FFF,
                    0x7FFFFF00000000, 0xC7FFFFFFFFFDFFFF, 0x1, 0x1000000000000, 0x3FFFFFF,
                    0x7FFFFFFFFFFF, 0xF, 0x1FFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0xFFFFFFFF0000007E,
                    0xFFFF00007FFFFFFF, 0x3FFFFFFF0000, 0xE0FFFFF80000000F, 0xFFFF,
                    0x1FFFFFFFFFFF, 0xFFFFFFFFFFFF87FF, 0xFFFF80FF, 0x3000B00000000,
                    0xFFFFFFFFFFFFFF, 0x80000000003FFFFF, 0x6FEF000000000000, 0x40007FFFFFFFF,
                    0xFFFF00F000270000, 0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x43FF01FF,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFFFF, 0xFFFF07DBF9FFFF7F,
                    0x3FFFFFFFFFFF, 0x8000, 0x3F801FFFFFFFFFFF, 0x4000, 0xFFFFFFFFFFF,
                    0xFFFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F, 0x88F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF,
                    0xFFFF000000000000, 0xFFFF03FFFFFF03FF, 0x3FF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const BIDI_CONTROL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x10000000, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7C000000C000, 0x3C000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BIDI_MIRRORED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x5000030000000000, 0x2800000028000000, 0x800080000000000, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0,
                    0, 6, 0, 0, 7, 8, 9, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 12, 0, 13, 0, 0, 0, 0, 0, 0, 14, 15, 16, 17, 18, 19, 0, 0, 0, 20, 0, 0,
                    0, 0, 0, 0, 0, 0, 21, 22, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 25, 26, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3C00000000000000, 0x18000000, 0x600000000000000, 0x6000000000000060,
                    0x6000, 0x1, 0xFA0FF857BC623F1E, 0xFFFFEFF5803C1FFF, 0xC1FFFFCC01079FFF,
                    0xFFFF3FFFFFC33E00, 0x60300000F00, 0x3FFF0000000000, 0xFFFC70783B79,
                    0x100FFFDF9FFFFF8, 0x33F0033A1F37C23F, 0x70307A53DFFFFC00,
                    0xFE19BC3001800000, 0xFFFFBFCFFFFFFFFF, 0x2F88707C507FFFFF,
                    0x4000000000000000, 0x3FF3000363C, 0x1FE00000, 0xFF3FF00, 0x307E000000,
                    0x2800000050000300, 0xDA8000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x8000000, 0x200000, 0x8000, 0x200, 0x8,
                ],
                };

                pub const CASE_IGNORABLE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x400408000000000, 0x140000000, 0x190A10000000000, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFF000000000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x430FFFFFFFFFFFF, 0xB0, 0, 0, 0, 0x3F8, 0, 0, 0x82000000,
                    0xBFFFFFFFFFFE0000, 0x100000000000B6, 0x17FF003F, 0x10000FFFFF801, 0,
                    0x3DFFBFC00000, 0xFFFF000000028000, 0x7FF, 0x1FFC000000000,
                    0x243FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 10, 11, 12, 13, 14, 15, 16, 11, 17, 18,
                    19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 35, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 36, 37, 38, 39, 40, 41, 42, 34, 43, 34, 34, 34, 44, 45, 46,
                    47, 48, 49, 50, 51, 52, 53, 34, 54, 55, 56, 57, 58, 34, 34, 34, 34, 34,
                    34, 59, 60, 61, 62, 63, 64, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 65, 34,
                    66, 34, 67, 34, 68, 69, 34, 34, 34, 34, 34, 34, 34, 70, 34, 71, 72, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 73, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 53, 34, 34, 34, 34, 74,
                    75, 76, 77, 78, 79, 80, 81, 82, 34, 34, 83, 84, 85, 86, 87, 88, 89, 90,
                    91, 34, 92, 34, 93, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 94, 34, 95,
                    96, 34, 34, 34, 34, 34, 34, 34, 34, 97, 98, 34, 99, 100, 101, 102, 103,
                ],
                tree2_level2: &[
                    0x3FFFFFC00000, 0xE000000, 0xFF830100, 0xFFFFFFFFFFFFFE00,
                    0x1400000000000007, 0x2000C00FE21FE, 0x1000000000000002,
                    0x4000000C0000201E, 0x1000000000000006, 0x23000000023986,
                    0xFC00000C000021BE, 0x9000000000000002, 0xC0060201E, 0x4, 0x2001,
                    0xD000000000000011, 0xC00603DC1, 0xC00003040, 0x1800000000000003,
                    0xC0000201E, 0x2, 0x5C0400, 0x7F2000000000000, 0x7FC0, 0x1FF2000000000000,
                    0x7F40, 0x2A0000003000000, 0x7FFE000000000000, 0x1FFFFFFFFEFFE0DF, 0x40,
                    0x66FDE00000000000, 0x1E0001C3000000, 0x20002064, 0x1000000000000000, 0,
                    0xE0000000, 0xC0000001C0000, 0xC0000000C0000, 0x3FB0000000000000,
                    0x208FFE40, 0xF800, 0x8, 0x20000000060, 0xE04018700000000, 0x9800000,
                    0x9FF81FE57F400000, 0xFFFF008000000000, 0x7FFF, 0x17D000000000000F,
                    0xFF80000000004, 0x3B3C00000003, 0x3A34000000000, 0xCFF00000000000,
                    0x3F00000000000000, 0x31021FDFFF70000, 0xFFFFF00000000000,
                    0x10007FFFFFFFFFF, 0xFFFFFFFFF8000000, 0xFFFFFFFFFFFFFFFF,
                    0xA000000000000000, 0x6000E000E000E003, 0x7C900300F800,
                    0x8002FFDF00000000, 0x1FFF0000, 0x1FFFFFFFF0000, 0x3000000000000000,
                    0x3800000000000, 0x8000800000000000, 0xFFFFFFFF00000000, 0x800000000000,
                    0x83E3C0000000020, 0x7E000000, 0x7000000000000000, 0x200000, 0x1000,
                    0xBFF7800000000000, 0xF0000000, 0x3000000000000, 0x3FFFFFFFF,
                    0x1000000000000, 0x700, 0x31C000000000000, 0x106000000844,
                    0x8003FFFF00000030, 0x3FC000000000, 0x3FF80, 0x33C8000000000007,
                    0x6000008000, 0x667E0000000000, 0x1001000000001008, 0xC19D000000000000,
                    0x58300020000002, 0xE00F8000000, 0x212000000000, 0x40000000,
                    0xFFFC000000000000, 0x7, 0xFFFF0008FFFF, 0x240000, 0x8000000000000000,
                    0x4000000004004080, 0x1000000000001, 0xC0000000, 0xE00000800000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 5, 6, 7, 8, 9, 10, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 6, 0, 0, 0, 0, 0, 0,
                    0, 0, 7, 8, 0, 0, 0, 0, 9, 10, 0, 11, 12, 0, 13, 14, 15, 16, 17, 18, 19,
                    20, 21, 22, 0, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 32, 33, 34, 35,
                    36, 0, 37, 0, 0, 0, 38, 0, 0, 0, 39, 40, 0, 41, 42, 43, 44, 0, 0, 0, 0, 0,
                    45, 0, 46, 0, 47, 48, 49, 0, 0, 0, 0, 50, 51, 52, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    53, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 58, 0, 0, 0,
                    0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 60, 61, 62, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 65, 66, 0, 0, 0, 0, 0, 0, 0, 67, 68, 0, 0, 69, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 70, 71, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 73, 74, 60, 0, 75, 0, 0, 0, 0, 0, 76, 77, 0, 0, 0, 0, 0, 0, 0,
                    78, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 81, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 83, 0, 0, 83, 83, 83, 84, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x7FDFFFFFFFFFFBF,
                    0x870000000000F06E, 0x6000000000, 0xF000000000, 0xBE0000004000,
                    0x180000000000, 0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000002,
                    0x801900000000007F, 0x2678000000000003, 0x2004, 0x1FEF8000000007,
                    0x8000000000000, 0x7FC0000000000003, 0x9E00, 0x40D3800000000000, 0x2,
                    0x7F880000000, 0x1800000000000003, 0x1F1FC000000001, 0xF800000000000000,
                    0x600054001, 0xFF00000000000000, 0x4000005C, 0x85F8000000000000, 0xD,
                    0xB03C000000000000, 0x30000001, 0xA7F8000000000000, 0x1, 0xBF280000000000,
                    0xFBCA0000000, 0x6FF800000000000, 0x5800000000000000, 0x8, 0x10CF00000,
                    0x79F80000000007FE, 0xE7E0080, 0x37FFC00, 0xBF7F000000000000,
                    0x6DFCFFFFFC0000, 0xB47E000000000000, 0xBF, 0xA30000, 0x18000000000000,
                    0x7C0000000000003, 0x4000005, 0xFFFF000000000000, 0x3FFF81,
                    0xE3FFC0000000, 0x1F000000000000, 0x7F000000000000, 0xF, 0x180000000007,
                    0x8000, 0xFFFF8000, 0x1B00000000, 0x6FEF000000000000, 0xF60000000,
                    0xFFFF3FFFFFFFFFFF, 0x7F, 0xFFF8038000000000, 0x3C0000000FE7, 0x1C,
                    0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0xFFFF07DBF9FFFF7F,
                    0x3FFFFFFFFFFF, 0x3FFF000000000000, 0x400000000000, 0xF00000000000,
                    0xF80000000000, 0xC00000000000, 0x7F0000, 0xFF0, 0xFFFFFFFF00000002,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const CASED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xF7FFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFF0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x1FFFFFFFFEFFFFF, 0x1F00000003, 0, 0xBCCF000000000020,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF007FFFFF, 0x1FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 5, 5, 0, 5, 5, 5, 5, 6, 7, 8, 9, 0, 10, 11,
                    0, 12, 13, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 16, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5,
                    17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 5, 22, 23, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 24, 25, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xF7FFFFFFFFFF20BF, 0x3F3FFFFFFFFFFFFF,
                    0xE7FFFFFFFFFF07FF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF21FBD503E2FFC84, 0xFFFFFFFF000043E0,
                    0x18, 0xFFC0000000000000, 0x3FFFFFFFFFF, 0xC781FFFFFFFFF, 0x20BFFFFFFFFF,
                    0x3FFFFFFFFFFF, 0x3FFFFFFF, 0xFFFFFFFC00000000, 0xFFFFFFFFFFFF78FF,
                    0x77C00001FEB3FFF, 0xFFFF000000000000, 0xFFFF03FFF7FFFFFF, 0xF8007F,
                    0x7FFFFFE00000000, 0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 5, 6, 0, 0,
                    0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    8, 8, 0, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    11, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 13, 14, 15, 16, 17, 1, 1, 1, 1, 18, 19, 20, 21, 22, 23, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24,
                    0, 0, 0, 3, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 26, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
                    27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF, 0xFFFF000000000000, 0xFFFFFFFFF0FFFFF,
                    0xF7FF000000000000, 0x1BFBFFFBFFB7F7FF, 0x7FDFFFFFFFFFFB9,
                    0x7FFFFFFFFFFFF, 0xFFFF003FFFFF0000, 0x3F, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFBFF, 0x3FFFFFFFFFFF, 0xF,
                    0xFFFF03FFFFFF03FF, 0x3FF,
                ],
                };

                pub const CHANGES_WHEN_CASEFOLDED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE, 0x20000000000000, 0xFF7FFFFF, 0xAA55555555555555,
                    0xAB555555555556AA, 0x11AED2D5B1DBCED6, 0x55D655554AAAADB0,
                    0x6C05555555555555, 0x557A, 0, 0, 0, 0x8045000000000020, 0xFFBFFFED740,
                    0xE6B3555555638004, 0xFFFFFFFFFFFF, 0x5555555500000000,
                    0x5555555555555401, 0x5555555555552AAB, 0xFFFE555555555555, 0x7FFFFF,
                    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 11, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17,
                    5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0,
                    0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x20BF, 0x3F00000000000000, 0xE7FFFFFFFFFF03FF,
                    0x5555555555555555, 0x555555554C155555, 0xFF00FF003F00FF00,
                    0xFF00AA003F00, 0x1F9CFFFFFFFFFFFF, 0x1F9C1F000F001F9C, 0x40C4000000000,
                    0xFFFF00000000, 0x8, 0xFFC0000000000000, 0xFFFF, 0xFFFFFFFFFFFF,
                    0xC025EA9D00000000, 0x4280555555555, 0x155555555555, 0x5555555,
                    0x5554555400000000, 0x6A00555555555555, 0x555F7D5555452855,
                    0x20000015411AF5, 0xFFFF000000000000, 0xFFFFFFFFFFFFFFFF, 0xF8007F,
                    0x7FFFFFE00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF, 0xFFFF000000000000, 0xFFFFF, 0xF7FF000000000000,
                    0x37F7FF, 0x7FFFFFFFFFFFF, 0x3FFFFF0000, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0x3FFFFFFFF,
                ],
                };

                pub const CHANGES_WHEN_CASEMAPPED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x20000000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFEFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xB3FFF3FFFFFFDFFF,
                    0xFFFFFFFFFFFFFFF0, 0xFC0FFFFDFFFFFFFF, 0x20269F7B1ADFFFFF, 0x60041F8D, 0,
                    0, 0xB8CF000000000020, 0xFFFFFFFBFFFFD740, 0xEFBFFFFFFFE3FFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03,
                    0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF, 0xFFFFFFFE007FFFFF, 0xFF, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 6, 0, 7, 7, 8, 7, 9, 10, 11, 12, 0, 0, 0,
                    0, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 18,
                    7, 19, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22, 0, 23, 24, 25, 26, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 30, 0,
                    0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xE7FFFFFFFFFF20BF, 0x3F3FFFFFFFFFFFFF,
                    0xE7FFFFFFFFFF07FF, 0x2200000000000000, 0x4000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFF4FFFFFFF, 0xFFFFFFFF3F3FFFFF, 0x3FFFFFFFAAFF3F3F,
                    0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC, 0x40C4000000000,
                    0xFFFFFFFF00004000, 0x18, 0xFFC0000000000000, 0x3FFFFFFFFFF,
                    0xC06DFFFFFFFFFFFF, 0xC780FFFFFFFFF, 0x20BFFFFFFFFF, 0x3FFFFFFFFFFF,
                    0xFFFFFFF, 0xFFFCFFFC00000000, 0xFE00FFFFFFFFFFFF, 0xFFFF7FFFFFDF38FF,
                    0x6000001FC33FFF, 0xFFFF000000080000, 0xF8007F, 0x7FFFFFE00000000,
                    0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 5, 6, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    7, 7, 0, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,
                    11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 12, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF, 0xFFFF000000000000, 0xFFFFFFFFF0FFFFF,
                    0xF7FF000000000000, 0x1BFBFFFBFFB7F7FF, 0x7FFFFFFFFFFFF,
                    0xFFFF003FFFFF0000, 0x3F, 0xFFFFFFFF00000000, 0xFFFFFFFF, 0xF,
                ],
                };

                pub const CHANGES_WHEN_LOWERCASED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE, 0, 0x7F7FFFFF, 0xAA55555555555555, 0x2B555555555554AA,
                    0x11AED2D5B1DBCED6, 0x55D655554AAAADB0, 0x6C05555555555555, 0x557A, 0, 0,
                    0, 0x8045000000000000, 0xFFBFFFED740, 0xE690555555008000, 0xFFFFFFFFFFFF,
                    0x5555555500000000, 0x5555555555555401, 0x5555555555552AAB,
                    0xFFFE555555555555, 0x7FFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 11, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17,
                    5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x20BF, 0x3FFFFFFFFFFFFF, 0xE7FFFFFFFFFF0200,
                    0x5555555555555555, 0x5555555540155555, 0xFF00FF003F00FF00,
                    0xFF00AA003F00, 0x1F00FF00FF00FF00, 0x1F001F000F001F00, 0x40C4000000000,
                    0xFFFF00000000, 0x8, 0xFFC0000000000000, 0xFFFF, 0xFFFFFFFFFFFF,
                    0xC025EA9D00000000, 0x4280555555555, 0x155555555555, 0x5555555,
                    0x5554555400000000, 0x6A00555555555555, 0x555F7D5555452855,
                    0x20000015411AF5, 0x7FFFFFE00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF, 0xFFFF000000000000, 0xFFFFF, 0xF7FF000000000000,
                    0x37F7FF, 0x7FFFFFFFFFFFF, 0x3FFFFF0000, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0x3FFFFFFFF,
                ],
                };

                pub const CHANGES_WHEN_TITLECASED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE00000000, 0x20000000000000, 0xFF7FFFFF80000000,
                    0x54AAAAAAAAAAAAAA, 0xD4AAAAAAAAAAAB55, 0xA251212A4E241129,
                    0xAA2BAAAAB55556D0, 0x900AAAA8AAAAAAAA, 0x20269F7B1ADFAA85, 0x60041F8D, 0,
                    0, 0x388A000000000020, 0xFFFFF00000010000, 0x92FAAAAAAE37FFF,
                    0xFFFF000000000000, 0xAAAAAAAAFFFFFFFF, 0xAAAAAAAAAAAAA802,
                    0xAAAAAAAAAAAAD554, 0xAAAAAAAAAAAA, 0xFFFFFFFE00000000, 0xFF, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 4, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 0, 11, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 5,
                    16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 19, 0, 20, 21, 22, 23, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3F00000000000000, 0x5FF, 0x2200000000000000, 0x4000,
                    0xAAAAAAAAAAAAAAAA, 0xAAAAAAAA0FEAAAAA, 0xFF00FF003F00FF,
                    0x3FFF00FF00FF003F, 0x40DF00FF00FF00FF, 0xDC00FF00CF00DC,
                    0xFFFF000000004000, 0x10, 0x3FFFFFF0000, 0xFFFF000000000000,
                    0x481562FFFFFFFF, 0x8500AAAAAAAAA, 0x20BFFFFFFFFF, 0x2AAAAAAAAAAA,
                    0xAAAAAAA, 0xAAA8AAA800000000, 0x9400AAAAAAAAAAAA, 0xAAA002AAAA9A10AA,
                    0x4000000A82250A, 0xFFFF000000080000, 0xFFFFFFFFFFFFFFFF, 0xF8007F,
                    0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFF0000000000, 0xFFFF, 0xFFFFFFFFF000000, 0x1BFBFFFBFF800000,
                    0x7FFFFFFFFFFFF, 0xFFFF000000000000, 0x3F, 0xFFFFFFFF, 0xFFFFFFFF00000000,
                    0xFFFFFFFC00000000, 0xF,
                ],
                };

                pub const CHANGES_WHEN_UPPERCASED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE00000000, 0x20000000000000, 0xFF7FFFFF80000000,
                    0x54AAAAAAAAAAAAAA, 0xD4AAAAAAAAAAAB55, 0xA251212A4E241129,
                    0xAA2DAAAAB5555B60, 0x900AAAA8AAAAAAAA, 0x20269F7B1ADFAA85, 0x60041F8D, 0,
                    0, 0x388A000000000020, 0xFFFFF00000010000, 0x92FAAAAAAE37FFF,
                    0xFFFF000000000000, 0xAAAAAAAAFFFFFFFF, 0xAAAAAAAAAAAAA802,
                    0xAAAAAAAAAAAAD554, 0xAAAAAAAAAAAA, 0xFFFFFFFE00000000, 0xFF, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 5, 0, 6, 6, 7, 6, 8, 9, 10, 11, 0, 0, 0,
                    0, 0, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 16, 6,
                    17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xE7FFFFFFFFFF0000, 0x3F00000000000000, 0x5FF, 0x2200000000000000,
                    0x4000, 0xAAAAAAAAAAAAAAAA, 0xAAAAAAAA0FEAAAAA, 0xFF00FF003F00FF,
                    0x3FFF00FF00FF003F, 0x50DFFFFFFFFFFFFF, 0x10DC00FF00CF10DC,
                    0xFFFF000000004000, 0x10, 0x3FFFFFF0000, 0xFFFF000000000000,
                    0x481562FFFFFFFF, 0x8500AAAAAAAAA, 0x20BFFFFFFFFF, 0x2AAAAAAAAAAA,
                    0xAAAAAAA, 0xAAA8AAA800000000, 0x9400AAAAAAAAAAAA, 0xAAA002AAAA9A10AA,
                    0x4000000A82250A, 0xFFFF000000080000, 0xFFFFFFFFFFFFFFFF, 0xF8007F,
                    0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFF0000000000, 0xFFFF, 0xFFFFFFFFF000000, 0x1BFBFFFBFF800000,
                    0x7FFFFFFFFFFFF, 0xFFFF000000000000, 0x3F, 0xFFFFFFFF, 0xFFFFFFFF00000000,
                    0xFFFFFFFC00000000, 0xF,
                ],
                };

                pub const DASH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0x4000000000000400, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0,
                    0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 7, 8, 0, 0, 0, 0, 0, 0, 9, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 0, 0, 13, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x40, 0x3F0000, 0x800000000080000, 0x800, 0x40000,
                    0xC00000004800000, 0x20000001, 0x1000010000000, 0x100000000,
                    0x6000000000000, 0x801000000, 0x2000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x400000000000, 0x200000000000,
                ],
                };

                pub const DEFAULT_IGNORABLE_CODE_POINT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x8000, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0x10000000, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 8, 0, 0, 9, 10,
                ],
                tree2_level2: &[
                    0, 0x180000000, 0x30000000000000, 0xF800, 0x7C000000F800, 0xFFFF00000000,
                    0x1000000000, 0xFFFF, 0x8000000000000000, 0x100000000, 0x1FF000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level3: &[
                    0, 0xF00000000, 0x7F8000000000000, 0xFFFFFFFFFFFFFFFF,
                ],
                };

                pub const DEPRECATED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0x200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0x8000000000000, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x280000000000000, 0x1800000000, 0xFC0000000000, 0x60000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2,
                ],
                };

                pub const DIACRITIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x140000000, 0x190810000000000, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFF000000000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x4300007E0FF7FFF, 0x30, 0, 0, 0, 0xF8, 0, 0, 0x2000000,
                    0xBFFFFFFBFFFE0000, 0x16, 0, 0x187F800, 0, 0x1C6180000000,
                    0xFFFF000000000000, 0x7FF, 0x1FFC000000000, 0x3FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 4, 6, 4, 6, 4, 7, 4, 8, 1, 6, 4, 6, 4, 6, 9, 6, 1, 10,
                    11, 12, 11, 13, 14, 1, 15, 16, 17, 18, 19, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    20, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21, 1, 1, 22, 1, 1, 1, 1,
                    23, 1, 1, 1, 1, 24, 25, 26, 27, 28, 29, 30, 31, 32, 1, 33, 34, 35, 1, 36,
                    1, 1, 1, 1, 1, 1, 37, 38, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 39, 1, 1, 1, 1, 40, 1, 1, 1, 1, 1, 1, 1, 41,
                    1, 42, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 43,
                    44, 45, 46, 1, 47, 48, 49, 1, 1, 50, 51, 52, 53, 54, 1, 55, 56, 57, 1, 58,
                    1, 59, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 60, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 61, 1, 1, 1, 62, 63, 64, 65,
                ],
                tree2_level2: &[
                    0x3000000, 0, 0xFF000000, 0x7FFFFFF80007FE00, 0x1000000000000000,
                    0x20000001E2000, 0x2000, 0xE000000000002000, 0x202000, 0x1800000000000000,
                    0x400, 0x400000000000000, 0x5F80, 0x1F00, 0xC2A0000003000000, 0xDC, 0x40,
                    0x680000000000000, 0x3E1800000000, 0xC00BF80, 0xE0000000,
                    0x10000000300000, 0x200FFE00, 0xE00000000000000, 0x9FE0000100000000,
                    0x7FFF000000000000, 0xFFE, 0x10000000000000, 0xFF80000000010,
                    0xC0000000000, 0xC004000000000, 0xC0000000000000, 0x3F00000000000000,
                    0x39021FFFFFF0000, 0xFFFFF00000000000, 0x7FFFFFFFFFF, 0xFFE000000000FFF0,
                    0xA000000000000000, 0x6000E000E000E003, 0x3800000000000, 0x800000000000,
                    0xFC0000000000, 0x1E000000, 0xB000800000000000, 0x30000000,
                    0x3000000000000, 0x3FFFFFFFF, 0x700, 0x300000000000000, 0x100000000040,
                    0x3FFFF00000010, 0x780000000000, 0x80000, 0x8000000000000, 0x2000000001,
                    0x3800000000000000, 0x8000000000000000, 0x40000000000007, 0xE00F8000000,
                    0x300000000000, 0x40000000, 0xFFFF00000000, 0x4000000000000000,
                    0x1000000000001, 0xC0000000, 0x800000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 5, 2, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0, 0, 0, 0,
                    0, 0, 5, 6, 0, 0, 0, 0, 0, 7, 0, 8, 9, 0, 0, 10, 11, 0, 12, 13, 0, 14, 15,
                    0, 0, 16, 17, 18, 0, 19, 0, 20, 0, 21, 0, 0, 22, 23, 22, 0, 24, 0, 25, 0,
                    0, 0, 11, 0, 0, 0, 26, 27, 0, 1, 28, 29, 30, 0, 0, 0, 0, 0, 22, 0, 0, 0,
                    0, 31, 32, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 37, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0,
                    0, 0, 0, 0, 0, 0, 39, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 0, 0, 0, 0, 0, 0, 0, 44, 45, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 46, 47, 0, 0, 37, 0, 0, 0, 0, 0, 48, 49, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 52, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x100000000, 0x7FDFFFFFFFFFFBF, 0x8700000000000000, 0x6000000000,
                    0xFC00000000, 0x3E0000004000, 0xE000000000000000, 0x1FFC0, 0x3C,
                    0x1000000000040, 0x600000000000000, 0x18000000000000, 0x8000000000000,
                    0x1C01, 0x60000000000000, 0x60000000000, 0x1800000000000000,
                    0x1F1FC000002000, 0x6000DC000, 0x44, 0xC, 0x8000000000000000, 0x1,
                    0xC0000000000000, 0x80000000000, 0x6000000000000000, 0x8,
                    0x10000000000000, 0x80, 0x2000000, 0x34, 0x800000, 0x4000006, 0x3FFF80,
                    0x800000000000, 0x1F000000000000, 0x7F000000000000, 0x180000000000,
                    0xFFFF8000, 0x3000000000000, 0x6FEF000000000000, 0xFFFF3FFFFFFFFFFF, 0x7F,
                    0xF807E38000000000, 0x3C0000000FE7, 0xFFFF000000000000, 0x3FFFFFFFFFFF,
                    0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x770,
                ],
                };

                pub const EMOJI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF040800000000, 0, 0x420000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    3, 0, 4, 0, 0, 0, 0, 0, 5, 0, 0, 6, 0, 0, 0, 7, 0, 0, 8, 9, 10, 11, 12,
                    13, 14, 15, 16, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 18, 19, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1000000000000000, 0x200, 0x200000400000000, 0x60003F00000,
                    0x1000C000000, 0x70FFE0000008000, 0x4, 0x400C0000000000,
                    0x7800000000000001, 0x700C44D2132401F, 0xC8000169800FFF05,
                    0x60030C831AFC0000, 0x27BF0600001AC130, 0x1801022054BF24, 0x1800B85090,
                    0x8001000200E00000, 0x30000000000000, 0x180000E0, 0x210000,
                    0x2001000000000000, 0x2800000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 4, 5, 6, 7, 0,
                    0, 8, 9, 10, 11, 9, 9, 9, 12, 13, 14, 15, 16, 9, 17, 9, 18, 0, 0, 0, 19,
                    0, 0, 0, 0, 20, 21, 9, 9, 0, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x10, 0x8000, 0xC003000000000000, 0x7FE4000, 0xFFFFFFC000000000,
                    0x7FC800004000006, 0x30000, 0xFFFFFFF3FFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFCECFFFFF, 0xFFB9FFFFFFFFFFFF, 0xBFFFFFFFFFFFFFFF,
                    0x3FFFFFFFFFFFFFFF, 0x7F980FFFFFF7E00, 0x1006013000613C80,
                    0xFC08810A700E001C, 0xFFFF, 0x1FF91A3FF0E7F83F, 0x10FFF00000000,
                    0xF7FFFFFFFFFFF000, 0xFFFFFFFFFFFFFFBF, 0x1FFF000000000000,
                    0xFFFFFFFFFFFF83FF, 0x1FF03FF9FFFC07F,
                ],
                };

                pub const EMOJI_COMPONENT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF040800000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2000, 0x800000000, 0x8000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFC000000000, 0xF800000000000000, 0xF000000000000,
                    0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFF,
                ],
                };

                pub const EMOJI_MODIFIER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF800000000000000,
                ],
                };

                pub const EMOJI_MODIFIER_BASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 3,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x20000000, 0x200000000000000, 0x3C00,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 2, 0, 3, 4, 0, 0, 5, 6, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0,
                    10, 11, 12, 13, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x20, 0x1C9C, 0x11FFFFC00001FFCC, 0x400000280EE, 0x430000000000000,
                    0x610000, 0xF8E0, 0x70000800000000, 0x1001, 0x73FF0040FF009000,
                    0x80000000000000, 0xB60000000000000, 0x3FFEE000, 0x1FF000000000038,
                ],
                };

                pub const EMOJI_PRESENTATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6, 7, 8,
                    9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC000000, 0x91E0000000000, 0x6000000000000000, 0x300000,
                    0x80000000000FFF00, 0x60000C0200080000, 0x242C040000104030, 0x10000000C20,
                    0xB85000, 0x8001000000E00000, 0x18000000, 0x210000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 4, 5, 6, 0,
                    0, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 13, 19, 13, 20, 0, 0, 0,
                    21, 0, 0, 0, 0, 22, 23, 13, 13, 0, 24, 25, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x10, 0x8000, 0x7FE4000, 0xFFFFFFC000000000, 0x77C800004000002,
                    0x30000, 0xFFBFE001FFFFFFFF, 0xDFFFFFFFFFFFFFFF, 0xFFFFFFFF000FFFFF,
                    0xFF11FFFF000F87FF, 0x7FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFD,
                    0xFFFFFFFFFFFFFFFF, 0x9FFFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFF,
                    0x40000FFFFFF7800, 0x1000600000, 0xF800000000000000, 0xFFFF,
                    0x1FF01800F0E7103F, 0x10FFF00000000, 0xF7FFFFFFFFFFF000,
                    0xFFFFFFFFFFFFFFBF, 0x1FFF000000000000, 0xFFFFFFFFFFFF83FF,
                    0x1FF03FF9FFFC07F,
                ],
                };

                pub const EXTENDED_PICTOGRAPHIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x420000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    3, 0, 4, 0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 0, 0, 8, 0, 0, 9, 10, 11, 12, 13,
                    12, 14, 15, 16, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 18, 19, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1000000000000000, 0x200, 0x200000400000000, 0x60003F00000,
                    0x1000C000000, 0x100, 0x70FFE0000008000, 0x4, 0x400C0000000000,
                    0x7800000000000001, 0xFFFFFFFFFFF7FFBF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF003F, 0x1801022057FF3F, 0xF800B85090, 0x8001000200E00000,
                    0x30000000000000, 0x180000E0, 0x210000, 0x2001000000000000, 0x2800000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 1,
                    1, 1, 1, 1, 8, 1, 1, 1, 1, 9, 10, 1, 1, 1, 11, 1, 1, 0, 12, 0, 13, 14, 15,
                    16, 1, 17, 18, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 9,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x80000000E000, 0xC003F00000000000,
                    0xFFFFE00007FE4000, 0x3FFFFFFFFF, 0xF7FC80000400FFFE, 0xFFFFFFFFFFFFFE00,
                    0x7FFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFC0, 0xFFFF,
                    0xFFF0000000000000, 0xFFFFFFFFFFE00000, 0xF000, 0xFC00FF00,
                    0xFFFFC0000000FF00, 0xF7FFFFFFFFFFF000, 0xFFFFFFFFFFFFFFBF,
                ],
                };

                pub const EXTENDER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x80000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0x30000, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0x1, 0, 0, 0, 0, 0, 0x400000000000000,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 7,
                    0, 0, 0, 0, 0, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13,
                    0, 14, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2000000000000, 0x800000000000000, 0x200000, 0x40, 0x400, 0x8,
                    0x8000000000, 0x40000000000000, 0x3E000000000020, 0x60000000,
                    0x7000000000000000, 0x1000, 0x4000008000, 0x1000000000000,
                    0x18000020000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,
                    0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x6, 0x840000004000, 0x80000000000000, 0x20000000, 0xC0000, 0x1C0,
                    0x1000000, 0xC, 0xB00000000, 0x3000000000000000, 0x800000000000, 0x70,
                ],
                };

                pub const GRAPHEME_BASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFFFFFFFF00000000, 0x7FFFFFFFFFFFFFFF, 0xFFFFDFFF00000000,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0,
                    0xFCFF000000000000, 0xFFFFFFFBFFFFD7F0, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC07,
                    0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF, 0xFFFFFFFFFE7FFFFF,
                    0x400000000000E7FF, 0x1F87FFFFFF0049, 0xFFFFFFFFE800FFC0,
                    0xFFFEFFFF000007FF, 0xFFFFFFFFFFFFFFFF, 0xFFFFC260403FFFFF,
                    0xFFFFFFFD3FFF, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF, 0xC7F007FFFFFFFFFF,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36,
                    36, 36, 37, 38, 39, 40, 41, 42, 43, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 44, 45, 46, 47, 48, 49, 50, 45, 51, 52, 53, 54, 55, 56, 57, 58, 59,
                    60, 61, 62, 63, 64, 65, 66, 67, 68, 36, 36, 36, 60, 36, 36, 36, 36, 69,
                    70, 71, 72, 73, 74, 75, 76, 36, 36, 77, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 78, 79, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 80, 81, 36, 36, 36, 36,
                    82, 83, 84, 85, 86, 36, 87, 88, 89, 36, 36, 36, 90, 91, 92, 93, 36, 94,
                    36, 95, 96, 97, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 98, 99, 36, 36, 36, 36, 100,
                    101, 102, 103, 36, 36, 36, 104, 105, 106, 36, 107, 108, 109, 110, 111,
                    112, 113, 114, 115, 116, 55, 36, 117, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
                    36, 36, 36, 118, 119, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 36, 36, 36, 36, 36, 120, 36,
                    121, 122, 123, 36, 124, 36, 36, 36, 36, 36, 36, 125, 126, 127, 128, 36,
                    129, 92, 36, 130, 131,
                ],
                tree2_level2: &[
                    0x7FFF0110043FFFFF, 0xFFFF07FF41FFFFFF, 0xFFFFFFFF00007FFF, 0x3FF,
                    0xEBFFFFFFFFFFFFF8, 0xFFFFFFF3FF01DE01, 0xA3C5FDFFFFF99FED,
                    0x3FFFFFC3B0005981, 0xC36DFDFFFFF987E8, 0x5CFFC05E000001,
                    0xE3EDFDFFFFFBBFE8, 0x203FFC300011A01, 0x23EDFDFFFFF99FEC,
                    0xFFFFC3B0001981, 0x83FFC718D63DC7E8, 0x7FFFFC000011DC6,
                    0x23FFFDFFFFFDDFEE, 0xFF80FFC32700001E, 0x63EFFDFFFFFDDFFD,
                    0xEFFC36000001A, 0xA7FFFFFFFFFDDFFC, 0xFFFFFFC3FF70DDC1,
                    0x2FFBFFFFFC7FFFEC, 0x1CFFC07F03007F, 0x800DFFFFFFFFFFFE, 0xFFF807F,
                    0x200DFFAFFFFFF7D6, 0xF3FF005F, 0xFD5FFFFFFCFFFFFF, 0x80001FFFFFFFFEFF,
                    0xC000000000001F20, 0x7FFDFBF, 0x99021FFFFFFFFFFF, 0xFFE1FFFE3CFFFFFF,
                    0xFFFFFFFFDFFFDF9B, 0xFFFFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D,
                    0xFFFFFFFFFF3DFFFF, 0x1FFFFFFF07FFFFFF, 0xFFFFFFFF03FFFFFF,
                    0x3F3FFFFFFFFFFFFF, 0xFFFFFFFF1FFFFFFF, 0x1FFFFFFFFFFFFFF,
                    0x63FFFF8003FFFF, 0x1DFFF0003FFFF, 0xC04FFFFFFFFFFFFF, 0x3FF03FF1FF001BF,
                    0xFFFFFFFF03FF07FF, 0xFFFF05FFFFFFFF9F, 0x3FFFFFFFFFFFFF,
                    0x1FB0E787FFFFFFF, 0x1F3FFFFFFFFFF1, 0xFFFF0FFFFFFFFFFF,
                    0xFFFFFFFFC7FF03FF, 0xFFFFFFFFC67FFFFF, 0x7E01A00BFFFFF, 0x3FFF03FF03FF,
                    0, 0xC00FFFFFFFFFFFF0, 0xFFF007FFFFFFDFE3, 0xFFFFC0C3FFFFFFFC,
                    0xF0005CBFFFFFFFFF, 0xF8300FFFFFFFFFFF, 0xFFFFFFFFFFFFE3FF,
                    0xE7FFFFFFFFFF07FF, 0x4EFDE02000800FF, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0xFFDFFFFFFFFFFFFF, 0x7FDCFFFFEFCFFFDF,
                    0xFFFF80FFFFFF07FF, 0xFFF30000FFFFFFFF, 0xFFFFFFFF1FFF7FFF, 0x1,
                    0xFFFFFFFFFFFF0FFF, 0x3FFFFFFFFFF, 0xFFFFFFFF000007FF, 0xFFCFFFFFFFFFFFFF,
                    0xFFFFFFFFFFBFFFFF, 0xFE0C7FFFFFFFFFFF, 0xFFFF20BFFFFFFFFF,
                    0x180FFFFFFFFFF, 0x7F7F7F7F007FFFFF, 0x7F7F7F7F, 0x3FFFFFFF,
                    0xFFFFFFFFFBFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFF0000003FFFFF,
                    0xFFFF03FFFFFFFFFF, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFF87FFFFF,
                    0xFFFEFFFFFFFFFFE0, 0xFFFFFFFFFFFF7FFF, 0xFFFF803FFFFFFFFF,
                    0xFFFFFFFF7FFFFFFF, 0xFFFFFFFFFFFF1FFF, 0xFFFFFFFFFFFF007F, 0xFFFFFFFFFFF,
                    0xC0087FFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFCFFFFFFFFFFFF,
                    0xFFFC00001FEB3FFF, 0x3FF0F9FFFFFF7BB, 0xFFFFFFFFFFFFFF,
                    0x7FFC000003FFC00F, 0xFFFFC03FFFFFFFFF, 0x1FFFFFFF8004007F,
                    0xCC37FFFFFFFFFFF8, 0x7FFFFFDFC3FFBFFE, 0x1981FFFFFFFFFF,
                    0xEFFFFFFFF3FF2FF7, 0x3E62FFFFFFFFFFFF, 0x3FCFFFF8000005,
                    0xFFFF7F7F007E7E7E, 0x3FF1EDFFFFFFFFF, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFFFFA0F8007F,
                    0xFFFFFFFFFFFFFFDB, 0xFFFFFFFFFFF80007, 0xFFFFFFFFFFFCFFFF,
                    0xFFFF0000000080FF, 0xFFFF000003FF0000, 0xFFDF0F7FFFF7FFFF,
                    0x1FFFFFFFFFFFFFFF, 0x7FFFFFFF3FFFFFFF, 0x30007F7F1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 2, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 2, 2, 14, 15, 16, 17,
                    18, 19, 2, 2, 2, 2, 20, 21, 22, 7, 23, 24, 25, 26, 27, 7, 28, 29, 30, 31,
                    32, 33, 34, 35, 36, 7, 2, 37, 38, 39, 40, 41, 42, 7, 7, 43, 44, 45, 16,
                    46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
                    64, 65, 66, 67, 68, 7, 7, 69, 70, 71, 72, 73, 74, 75, 76, 7, 7, 77, 7, 78,
                    79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 7, 7, 89, 90, 91, 92, 7, 93, 94,
                    95, 7, 7, 7, 7, 96, 97, 98, 99, 100, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 101, 7, 2, 102, 2, 2, 2, 103, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 104, 38, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 105, 106,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 76, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 107, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 87, 108, 109, 110, 111,
                    112, 113, 7, 7, 7, 7, 7, 7, 114, 7, 7, 7, 2, 115, 7, 2, 116, 117, 118, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 65, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 119, 37, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 120, 2, 2, 2, 2, 121,
                    122, 2, 2, 2, 2, 2, 123, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 124, 125,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 114, 2, 2, 2, 2, 2, 2, 19, 7, 7,
                    104, 2, 103, 2, 2, 2, 126, 127, 128, 129, 130, 2, 131, 7, 132, 2, 133, 7,
                    7, 2, 134, 135, 136, 137, 138, 2, 2, 2, 2, 139, 2, 2, 2, 2, 140, 2, 2, 2,
                    2, 2, 2, 2, 2, 141, 142, 143, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 144, 7, 7, 7, 145, 146, 7, 7, 147, 148, 7, 7, 7, 7, 149, 150, 7, 7,
                    7, 7, 7, 7, 7, 151, 7, 7, 7, 152, 7, 7, 7, 7, 7, 7, 7, 153, 2, 2, 2, 154,
                    2, 155, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 156, 157, 7, 158, 7, 7, 7, 159,
                    160, 161, 162, 7, 7, 7, 7, 163, 2, 164, 165, 2, 2, 146, 166, 167, 168, 7,
                    7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 169, 2, 170, 2, 171, 172,
                    173, 174, 175, 2, 2, 2, 2, 2, 176, 177, 178, 2, 2, 179, 114, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 114, 2, 2, 2, 180, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 181, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 182, 2, 2, 2, 2, 2, 2, 2, 2, 2, 183, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 183, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 116, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 105, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF,
                    0xFF8FFFFFFFFFFF87, 0x11FFF7FFF, 0x1FFFFFFFFFFF0000, 0,
                    0xFFFFFFFF1FFFFFFF, 0xFFFFFFE0001FFFF, 0xFFFFE00FFFFFFFFF,
                    0x3FFFFFFFFF07FF, 0xFFFFFFFFBFFFFFFF, 0x3FFF0F, 0xFFFF03FF3FFFFFFF,
                    0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF, 0xF7FF800FFFFFFFFF,
                    0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                    0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0xFFFFFFFFFFBFFFFF, 0xFF807FFFFFFF,
                    0xF837FFFF00000000, 0x83FFFFFF8FFFFFFF, 0xF0FFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFCFFFF, 0x3FFFFFFEEF0001, 0xFFFFFFFF01FF01FF, 0xFFFFFFFF,
                    0x7FF81FFFFFFFFF, 0xFE3FFFFFFFFFFFFF, 0xFF07FFFFFF3FFFFF, 0xFE001E03FFFF,
                    0x1FF, 0x7FFFFFFFFFFFF, 0xFC07FFFFFFFFFFFF, 0x3FF000FFFFFFFFF,
                    0xFFFFC03FFFFFFFFF, 0xC03F, 0x7FFFFFFF00000000, 0x323FFFFFFFFFF, 0x1C,
                    0xFFFF000003FE003F, 0xFFFF0000000003C3, 0x7FFFFF00000FFF,
                    0xFFFFFFFFFFFFFD, 0x26FFFFFFFC3F80, 0xD987FFFFFFFFFFFC, 0x3FF01FFFFFF0003,
                    0xFFC0107FFFFFFFF8, 0x77FFFFFFFF00FF, 0x803FFFFFFFFFFFFC,
                    0x1FFFFEFFFF61FE, 0xBF0C7FFFFFFBFFFF, 0x1, 0xFFFF03FFBFFFBD7F,
                    0x3FF00077FFFFFFF, 0xA3EDFDFFFFF99FEC, 0xFE001199E, 0x6BFFFFFFFFF4BFF,
                    0x1BA3400, 0xFFFFFFFFFFFFFF, 0x3AFFFFFA3, 0x5A06FFFFFFFFFFFF, 0x3FF00F2,
                    0x4F037FFFFFFFFFFF, 0xFFFFFFE, 0x5807FFFFFFFFFFFF, 0x1FFF03FF001E,
                    0x300D7FFFFFFFFFF, 0xFFFFF03FF, 0xFFFF004347FFFFFF, 0x7F,
                    0x9007FFFFFFFFFFF, 0xFFFFFFFF00000000, 0x8007FFFFFFFFFFFF,
                    0x81BEFFFFFF6FF27F, 0x3FF0077, 0xFFFFFCFF00000000, 0x1EF00FFFFF,
                    0x8607FFFFFFFFF801, 0xFFFFFFFFF181007F, 0xFFFF0007FC8003FF,
                    0x1FFFFFFFFFFFFFF, 0x3FF, 0x3FF0003FFFFFFFF, 0x4000FFFFFFFFFDFF,
                    0xFFFF1FFFFFFF003F, 0x1202000000FFFF, 0x1FFFFFFFFFB7F, 0xFFFFFDBF03FF0040,
                    0x3FF01587FFF, 0x1E7FFFF00000000, 0xC03FFFFFFFFDFFFC, 0x3FFFFF8,
                    0x1000000000000, 0x8003FFFFFFFFFFFF, 0x3FFFFFF, 0x1F7FFFFFFFFFFF, 0xF,
                    0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFF, 0xFFFFFFFF0000007E, 0x3FF1C003FFFFFFF,
                    0xFFFFC3FF7FFFFFFF, 0x7FFFFFFFFFFFFFFF, 0x203FFFFFFF03FF,
                    0xFF80FFFFFFFFFFFF, 0xE0FFFFFBFBFF003F, 0xFFFF, 0x3FFFFFFFFFFFFFF,
                    0x7FFFFFF, 0xFFFFFFFFFFFF07FF, 0xFFF800FF, 0xF00000000,
                    0x80000000003FFFFF, 0x6FEF000000000000, 0x40007FFFFFFFF,
                    0xFFFF00F000270000, 0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x93FF01FF,
                    0x3FFFFFFFFFFFFF, 0xFFFFFE7FFFFFFFFF, 0x1C1FFFFFFFFF, 0xFFFFC3FFFFFFF018,
                    0x7FFFFFFFFFF, 0x23, 0xFFFFF000FFFFF, 0x1FFFFFF007FFFFF,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xFFFFFFFFFFFFCFFF, 0x780000000000000, 0xFFDFE00000000000, 0xFEF,
                    0x7E07FFFFFFF, 0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x3F801FFFFFFFFFFF,
                    0xC3FF, 0x3FFFFFFF0000, 0x83FF0FFFFFFFFFFF, 0x3FF0FFFFFFF0000,
                    0x87FF3FFFFFFF0000, 0x7FFF6F7F00000000, 0xFF9F, 0xC3FF080F,
                    0xFFFE000000000000, 0x1FFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFE,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0x3000000000000,
                    0xFFFF0FFFFFFFFFFF, 0xFFFE7FFF000FFFFF, 0x3FFFFFFFFEFFFE,
                    0xFFFFFFC000000000, 0xFFFFFFFFFFF0007, 0x3F000301FF, 0x1FFF1FFFF0FFFFFF,
                    0xF87FFFFFFFFFFFFF, 0x10FFF03FFFFFF, 0xFFFFFFFFFFFF0FFF,
                    0xFFFFFFFF03FF00FF, 0xFFF3FFFFFFF00FF, 0x3, 0x1FFF3FFF000FFFFF,
                    0xFFFFFFFFFFFF83FF, 0x1FF03FF9FFFC07F, 0xFFFFFFFFFFF7FFFF,
                    0xFFFFFFFF3FFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                ],
                };

                pub const GRAPHEME_EXTEND: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0x3F8, 0, 0, 0, 0xBFFFFFFFFFFE0000, 0xB6, 0x7FF0000,
                    0x10000FFFFF800, 0, 0x3D9F9FC00000, 0xFFFF000000020000, 0x7FF,
                    0x1FFC000000000, 0x200FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 35, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 36, 37, 38, 39, 40, 34, 41, 34, 42, 34, 34, 34, 43, 44, 45,
                    46, 47, 48, 49, 50, 51, 34, 34, 52, 34, 34, 34, 53, 34, 34, 34, 34, 34,
                    34, 34, 34, 54, 34, 34, 55, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    56, 34, 57, 34, 58, 34, 34, 34, 34, 34, 34, 34, 34, 59, 34, 60, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    61, 62, 63, 34, 34, 34, 34, 64, 34, 34, 65, 66, 67, 68, 69, 70, 71, 72,
                    73, 34, 34, 34, 74, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 75, 34, 34,
                    34, 34, 34, 34, 34, 34, 34, 34, 34, 76, 34, 34, 34, 34, 34, 62, 34,
                ],
                tree2_level2: &[
                    0x3EEFFBC00000, 0xE000000, 0xFF800000, 0xFFFFFFFBFFFFFC00,
                    0x1400000000000007, 0xC00FE21FE, 0x5000000000000002, 0x4000000C0080201E,
                    0x1000000000000006, 0x23000000023986, 0xFC00000C000021BE,
                    0xD000000000000002, 0xC00E0201E, 0x4000000000000004, 0x802001,
                    0xD000000000000011, 0xC00603DC1, 0x9000000000000002, 0xC00603DC5,
                    0x5800000000000003, 0xC0080201E, 0x2, 0x805C8400, 0x7F2000000000000,
                    0x7F80, 0x1FF2000000000000, 0x7F00, 0x2A0000003000000, 0x7FFE000000000000,
                    0x1FFFFFFFFEFFE0DF, 0x40, 0x66FDE00000000000, 0x1E0001C3000000,
                    0x20002064, 0, 0xE0000000, 0x1C0000003C0000, 0xC0000000C0000,
                    0x3FB0000000000000, 0x200FFE40, 0xB800, 0x20000000060, 0xE04018700000000,
                    0x9800000, 0x9FF81FE57F400000, 0xFFFF000000000000, 0x7FFF,
                    0x3FF000000000000F, 0xFF8000000001C, 0x3F3C00000003, 0xFA34000000000,
                    0xCFF00000000000, 0x31021FDFFF70000, 0xFFFFFFFFFFFFFFFF, 0x1000,
                    0x1FFFFFFFF0000, 0x3800000000000, 0x8000000000000000, 0xFFFFFFFF00000000,
                    0xFC0000000000, 0x6000000, 0x3FF7800000000000, 0xC0000000,
                    0x3000000000000, 0x106000000844, 0x8003FFFF00000030, 0x3FC000000000,
                    0xBFF80, 0x33C8000000000007, 0x2000000001, 0x667E0000000000,
                    0x1000000000001008, 0xC19D000000000000, 0x40300000000002, 0x212000000000,
                    0x40000000, 0xFFFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 2, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0,
                    0, 0, 6, 7, 0, 0, 0, 0, 8, 9, 0, 10, 11, 0, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0, 0, 31, 32, 33, 34,
                    35, 0, 36, 0, 0, 0, 37, 0, 0, 0, 38, 39, 0, 40, 41, 42, 43, 0, 0, 0, 0, 0,
                    44, 0, 45, 0, 46, 47, 48, 0, 0, 0, 0, 49, 50, 51, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 55, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 61, 0, 0, 0, 0, 0, 0, 0,
                    62, 63, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 66, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 56, 0, 55, 0, 0, 0, 0, 0, 69, 70,
                    0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72,
                    0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 74, 75, 0, 0, 75, 75, 75, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x870000000000F06E,
                    0x6000000000, 0xF000000000, 0x3E0000000000, 0x180000000000,
                    0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000002, 0x801900000000007F,
                    0x678000000000003, 0x4, 0x1FEF8000000007, 0x8000000000000,
                    0x7FC0000000000003, 0x9E01, 0x40F3800000000000, 0x2, 0x7F880000000,
                    0x5800000000000003, 0x1F1FC000802001, 0xF900000000000000, 0x60005C3A5,
                    0xFF00000000000000, 0x4000005C, 0xA5F9000000000000, 0xD,
                    0xB03C800000000000, 0x30000001, 0xA7F8000000000000, 0x1, 0xFF280000000000,
                    0xFBCA0000000, 0x6FF800000000000, 0x7801000000000000, 0x8, 0x10CF00000,
                    0x79F80000000007FE, 0xE7E0080, 0x37FFC00, 0xBF7F000000000000,
                    0x6DFCFFFFFC0000, 0xB47E000000000000, 0xBF, 0xA30000, 0x18000000000000,
                    0x7C0000000000003, 0x4000007, 0x3FFF81, 0xE3FFC0000000, 0x1F000000000000,
                    0x7F000000000000, 0x8000, 0x78000, 0x3001000000000, 0x60000000,
                    0xFFFF3FFFFFFFFFFF, 0x7F, 0xF807E3E000000000, 0x3C0000000FE7, 0x1C,
                    0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7DBF9FFFF7F,
                    0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x7F0,
                    0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const GRAPHEME_LINK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 1, 0, 3, 4,
                    0, 4, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0,
                    0, 0, 5, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 5, 0, 14, 0,
                    15, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2000, 0x1800000000000000, 0x400, 0x400000000000000, 0x10,
                    0x600000000000000, 0x10000000300000, 0x40000, 0x100000000, 0xC0000000000,
                    0xC000000000000, 0x8000000000000000, 0x100000000040, 0x80000, 0x1,
                    0x40000000000000, 0x200000000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 4, 0, 0, 5, 6, 0, 0,
                    7, 0, 8, 0, 9, 0, 10, 0, 10, 0, 0, 1, 0, 1, 0, 11, 0, 12, 0, 0, 0, 3, 0,
                    0, 0, 13, 0, 0, 14, 15, 16, 17, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 19, 0,
                    0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x8000000000000000, 0x8001000000000040, 0x200000000000000,
                    0x18000000000000, 0x1, 0x20000000000000, 0x40000000000, 0x2000, 0x1C000,
                    0x4, 0x40000000000000, 0x80000000000, 0x6000000000000000, 0x100000000,
                    0x10000000000000, 0x80, 0x2000000, 0x30, 0x800000, 0x6, 0x800000000000,
                ],
                };

                pub const HEX_DIGIT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0x7E0000007E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7E03FF0000, 0x7E,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const HYPHEN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x200000000000, 0, 0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0x400, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 6, 7, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x40, 0x30000, 0x800000, 0x800000000000000, 0x800000000, 0x2000,
                    0x2000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const IDS_BINARY_OPERATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3FF3000000000000, 0x800000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const IDS_TRINARY_OPERATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC000000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const IDS_UNARY_OPERATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC000000000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const ID_COMPAT_MATH_CONTINUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x20C000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FF1000000000000, 0x7FFF, 0x40000084,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x800000008000002, 0x20000000200000, 0x800000008000, 0x20000000200,
                    0x8,
                ],
                };

                pub const ID_COMPAT_MATH_START: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x40000084,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x800000008000002, 0x20000000200000, 0x800000008000, 0x20000000200,
                    0x8,
                ],
                };

                pub const ID_CONTINUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0x7FFFFFE87FFFFFE, 0x4A0040000000000,
                    0xFF7FFFFFFF7FFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3,
                    0xFFFFFFFFFFFFFFFF, 0xBCDFFFFFFFFFFFFF, 0xFFFFFFFBFFFFD7C0,
                    0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFCFB, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF,
                    0xFFFFFFFF027FFFFF, 0xBFFFFFFFFFFE01FF, 0x787FFFFFF00B6,
                    0xFFFFFFFF07FF0000, 0xFFFFC3FFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x9FFFFDFF9FEFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFFE7FF,
                    0x3FFFFFFFFFFFF, 0x243FFFFFFFFFFFFF,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 4, 32, 33, 34, 4, 4, 4, 4, 4,
                    35, 36, 37, 38, 39, 40, 41, 42, 4, 4, 4, 4, 4, 4, 4, 4, 43, 44, 45, 46,
                    47, 4, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 4, 61, 4, 62,
                    63, 64, 65, 66, 4, 4, 4, 4, 4, 4, 4, 4, 67, 68, 69, 70, 71, 72, 73, 74,
                    75, 76, 77, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 4, 4, 4, 79, 80, 81, 82, 83, 78, 78, 78,
                    78, 78, 78, 78, 78, 84, 42, 85, 4, 86, 4, 87, 88, 78, 78, 78, 78, 78, 78,
                    78, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 89, 90, 4, 4, 4, 4, 91, 92, 4, 93, 94, 4, 95, 96, 97, 62, 4,
                    98, 99, 100, 4, 101, 102, 103, 4, 104, 105, 106, 4, 107, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 108, 109, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 4, 4, 4, 4, 4, 99, 4, 110, 111, 112, 93, 113, 4, 4, 4, 4,
                    114, 115, 116, 117, 118, 119, 4, 120, 121, 122, 123, 124,
                ],
                tree2_level2: &[
                    0x3FFFFFFFFFFF, 0xFFFF07FF0FFFFFFF, 0xFFFFFFFFFF807EFF,
                    0xFFFFFFFBFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFCFFFFFFFFF,
                    0xF3C5FDFFFFF99FEF, 0x5003FFCFB080799F, 0xD36DFDFFFFF987EE,
                    0x3FFFC05E023987, 0xF3EDFDFFFFFBBFEE, 0xFE00FFCF00013BBF,
                    0xF3EDFDFFFFF99FEE, 0x2FFCFB0E0399F, 0xC3FFC718D63DC7EC, 0xFFC000813DC7,
                    0xF3FFFDFFFFFDDFFF, 0xFFCF27603DDF, 0xF3EFFDFFFFFDDFEF, 0xEFFCF60603DDF,
                    0xFFFFFFFFFFFDDFFF, 0xFC00FFCF80F07DDF, 0x2FFBFFFFFC7FFFEE,
                    0xCFFC0FF5F847F, 0x7FFFFFFFFFFFFFE, 0x3FF7FFF, 0x3FFFFFAFFFFFF7D6,
                    0xF3FF7F5F, 0xC2A003FF03000001, 0xFFFE1FFFFFFFFEFF, 0x1FFFFFFFFEFFFFDF,
                    0x40, 0xFFFFFFFFFFFF03FF, 0xFFFFFFFF3FFFFFFF, 0xF7FFFFFFFFFF20BF,
                    0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D,
                    0xFFFFFFFFFF3DFFFF, 0x3FE00E7FFFFFF, 0xFFFFFFFF0000FFFF,
                    0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE, 0xFFFF9FFFFFFFFFFF,
                    0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF, 0x1FFFFF803FFFFF, 0xDDFFF000FFFFF,
                    0x3FF308FFFFF, 0xFFFFFFFF03FFB800, 0x1FFFFFFFFFFFFFF, 0xFFFF07FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0xFFF0FFF7FFFFFFF, 0x1F3FFFFFFFFFC0, 0xFFFF0FFFFFFFFFFF,
                    0x7FF03FF, 0xFFFFFFFF0FFFFFFF, 0x9FFFFFFF7FFFFFFF, 0xBFFF008003FF03FF,
                    0x7FFF, 0xFF80003FF1FFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF,
                    0x3FFFFFFFFFFFE3FF, 0xE7FFFFFFFFFF07FF, 0x7FFFFFFFFF70000,
                    0xFFFFFFFF3F3FFFFF, 0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF,
                    0x1FDC1FFF0FCF1FDC, 0x8000000000003000, 0x8002000000100001, 0x1FFF0000,
                    0x1FFE21FFF0000, 0xF3FFFD503F2FFC84, 0xFFFFFFFF000043E0, 0x1FF, 0,
                    0xFF81FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x800080FFFFFFFFFF,
                    0x7F7F7F7F007FFFFF, 0xFFFFFFFF7F7F7F7F, 0x1F3EFFFE000000E0,
                    0xFFFFFFFEFE7FFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xFFFFFFF1FFF,
                    0xBFF0FFFFFFFFFFFF, 0x3FFFFFFFFFFFF, 0xFFFFFFFCFF800000,
                    0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x10FFFFFFFFFF,
                    0xE8FFFFFF03FF003F, 0xFFFF3FFFFFFFFFFF, 0x1FFFFFFF000FFFFF,
                    0x7FFFFFFF03FF8001, 0x7FFFFFFFFFFFFF, 0xFC7FFFFF03FF3FFF,
                    0x7CFFFF38000007, 0xFFFF7F7F007E7E7E, 0xFFFF03FFF7FFFFFF,
                    0x3FF37FFFFFFFFFF, 0xFFFF000FFFFFFFFF, 0xFFFFFFFFFFFF87F, 0x3FFFFFF,
                    0x5F7FFDFFE0F8007F, 0xFFFFFFFFFFFFFFDB, 0xFFFFFFFFFFF80000,
                    0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFCFFFF,
                    0xFFF0000000000FF, 0x18FFFF0000FFFF, 0xFFDF00000000E000,
                    0x1FFFFFFFFFFFFFFF, 0x87FFFFFE03FF0000, 0xFFFFFFE007FFFFFE,
                    0x7FFFFFFFFFFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 6, 4, 4, 7, 8, 9, 10, 11, 12, 2, 2, 13, 14, 15, 16,
                    17, 18, 2, 2, 2, 2, 19, 20, 21, 4, 22, 23, 24, 25, 26, 4, 27, 4, 28, 29,
                    30, 31, 32, 33, 34, 4, 2, 35, 36, 36, 37, 38, 39, 4, 4, 4, 40, 41, 42, 43,
                    44, 45, 2, 46, 3, 47, 48, 49, 2, 50, 51, 52, 53, 54, 55, 56, 57, 58, 2,
                    59, 2, 60, 4, 4, 61, 62, 2, 63, 64, 65, 66, 67, 4, 4, 3, 4, 68, 69, 70,
                    71, 72, 73, 74, 75, 76, 64, 4, 4, 4, 77, 78, 79, 80, 4, 81, 82, 83, 4, 4,
                    4, 4, 84, 85, 86, 87, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 88, 4,
                    2, 89, 2, 2, 2, 90, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 91, 92,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 93, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 67, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 64, 96, 74, 97, 19, 98, 99, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 35, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 112, 4, 4, 4, 4, 4, 4, 4, 4, 113, 67, 4, 4, 4, 4, 4, 4, 4,
                    114, 115, 4, 4, 116, 4, 4, 4, 4, 4, 4, 2, 117, 118, 119, 120, 121, 2, 2,
                    2, 2, 122, 123, 124, 125, 126, 127, 4, 4, 4, 4, 4, 4, 4, 4, 128, 129, 130,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 131, 4, 4, 4, 132, 133,
                    134, 4, 135, 136, 4, 4, 4, 4, 137, 95, 4, 4, 4, 4, 4, 4, 4, 138, 4, 4, 4,
                    139, 4, 4, 4, 4, 4, 4, 4, 140, 2, 2, 2, 141, 2, 142, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 143, 144, 145, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 112, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 146, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 95, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    147, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 148, 2, 2, 2, 2, 2, 2, 2, 2, 2, 149, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 149, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 150, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 93, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2,
                    93, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0x2000000000000000, 0xFFFFFFFF1FFFFFFF, 0x10001FFFF,
                    0xFFFFE000FFFFFFFF, 0x7FFFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F,
                    0xFFFF03FF3FFFFFFF, 0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF,
                    0xF7FF000FFFFFFFFF, 0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF,
                    0xFF003FFFFF, 0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF,
                    0x7FFFFFFF, 0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF,
                    0x873FFFFFFEEFF06F, 0x1FFFFFFF00000000, 0x1FFFFFFF, 0x7FFFFFFEFF,
                    0x3FFFFFFFFFFFFF, 0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF,
                    0x3FF00FFFFFFFFFF, 0xFFFFBE3FFFFFFFFF, 0x3F, 0x31BFFFFFFFFFF,
                    0xF00000000000001C, 0xFFFF00801FFFFFFF, 0xFFFF00000001FFFF,
                    0xFFFF00000000003F, 0x7FFFFF0000001F, 0x803FFFC00000007F,
                    0x3FF01FFFFFF0004, 0xFFDFFFFFFFFFFFFF, 0x4FFFFFFFFF00F0, 0x17FFDE1F,
                    0xC0FFFFFFFFFBFFFF, 0x3, 0xFFFF01FFBFFFBD7F, 0x3FF07FFFFFFFFFF,
                    0xFBEDFDFFFFF99FEF, 0x1F1FCFE081399F, 0xFFBFFFFFFFFF4BFF, 0x6000FF7A5,
                    0x3C3FF07FF, 0x3FF00BF, 0xFF3FFFFFFFFFFFFF, 0x3F000001, 0x3FF0011,
                    0x1FFFFFFFFFFFFFF, 0xFFFFF03FF, 0x3FF0FFFE7FFFFFF, 0x7F,
                    0xFFFFFFFF00000000, 0x800003FFFFFFFFFF, 0xF9BFFFFFFF6FF27F, 0x3FF000F,
                    0xFFFFFCFF00000000, 0x1BFCFFFFFF, 0x7FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0080,
                    0xFFFF000023FFFFFF, 0x3FF0001FFFFFFFF, 0xFF7FFFFFFFFFFDFF,
                    0xFFFC000003FF0001, 0x7FFEFFFFFCFFFF, 0xB47FFFFFFFFFFB7F,
                    0xFFFFFDBF03FF00FF, 0x3FF01FB7FFF, 0x7FFFFF00000000, 0xC7FFFFFFFFFDFFFF,
                    0x7FF0007, 0x1000000000000, 0x3FFFFFF, 0x7FFFFFFFFFFF, 0xF,
                    0xFFFFFFFFFFFF0000, 0x1FFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0xFFFFFFFF003FFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF03FF7FFFFFFF, 0x1F3FFFFFFF03FF,
                    0xE0FFFFF803FF000F, 0xFFFF, 0x3FF1FFFFFFFFFFF, 0xFFFFFFFFFFFF87FF,
                    0xFFFF80FF, 0x3001B00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                    0x6FEF000000000000, 0x40007FFFFFFFF, 0xFFFF00F000270000,
                    0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x63FF01FF, 0x3FF000000000000,
                    0xFFFF3FFFFFFFFFFF, 0xF807E3E000000000, 0x3C0000000FE7, 0x1C,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFFFFFFFFFFFFCFF7, 0xF87FFFFFFFFFFFFF,
                    0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7E07FFFFFFF, 0xFFFF07DBF9FFFF7F,
                    0x3FFFFFFFFFFF, 0x8000, 0x3FFF1FFFFFFFFFFF, 0x43FF, 0x7FFFFFFF0000,
                    0x3FFFFFFFFFF0000, 0x7FFFFFFFFFF0000, 0x7FFF6F7F00000000, 0x7F001F,
                    0x3FF0FFF, 0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF,
                    0xFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const ID_START: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3, 0, 0xBCDF000000000000,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF027FFFFF, 0x1FF, 0x787FFFFFF0000,
                    0xFFFFFFFF00000000, 0xFFFEC000000007FF, 0xFFFFFFFFFFFFFFFF,
                    0x9C00C060002FFFFF, 0xFFFFFFFD0000, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF,
                    0x43007FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 35, 35,
                    35, 35, 36, 37, 38, 39, 40, 41, 42, 43, 35, 35, 35, 35, 35, 35, 35, 35,
                    44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 3, 58, 59, 60, 30,
                    61, 62, 63, 64, 65, 66, 67, 68, 35, 35, 35, 30, 35, 35, 35, 35, 69, 70,
                    71, 72, 30, 73, 74, 30, 75, 76, 77, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 78,
                    79, 80, 81, 82, 30, 30, 30, 30, 30, 30, 30, 30, 83, 43, 84, 85, 86, 35,
                    87, 88, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 30, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 89, 90, 35, 35, 35, 35, 91, 92,
                    93, 94, 95, 35, 96, 97, 98, 49, 99, 100, 101, 102, 103, 104, 105, 106,
                    107, 108, 109, 110, 35, 111, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 112, 113, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 114, 35, 115, 116,
                    117, 118, 119, 35, 35, 35, 35, 120, 121, 122, 123, 30, 124, 35, 125, 126,
                    127, 128, 129,
                ],
                tree2_level2: &[
                    0x110043FFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00007EFF, 0x3FF,
                    0x23FFFFFFFFFFFFF0, 0xFFFE0003FF010000, 0x23C5FDFFFFF99FE1,
                    0x10030003B0004000, 0x36DFDFFFFF987E0, 0x1C00005E000000,
                    0x23EDFDFFFFFBBFE0, 0x200000300010000, 0x23EDFDFFFFF99FE0,
                    0x20003B0000000, 0x3FFC718D63DC7E8, 0x10000, 0x23FFFDFFFFFDDFE0,
                    0x327000000, 0x23EFFDFFFFFDDFE1, 0x6000360000000, 0x27FFFFFFFFFDDFF0,
                    0xFC00000380704000, 0x2FFBFFFFFC7FFFE0, 0x7F, 0xDFFFFFFFFFFFE,
                    0x200DFFAFFFFFF7D6, 0xF000005F, 0x1, 0x1FFFFFFFFEFF, 0x1F00, 0,
                    0x800007FFFFFFFFFF, 0xFFE1C0623C3F0000, 0xFFFFFFFF00004003,
                    0xF7FFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF,
                    0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x7FFFFFF,
                    0xFFFFFFFF0000FFFF, 0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF,
                    0x3FFFF8003FFFF, 0x1DFFF0003FFFF, 0xFFFFFFFFFFFFF, 0x10800000,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFFF, 0xFFFF05FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0x7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF,
                    0xFFFFFFFF007FFFFF, 0x1FFFFF, 0x8000000000, 0xFFFFFFFFFFFE0, 0x1FE0,
                    0xFC00C001FFFFFFF8, 0x3FFFFFFFFF, 0xFFFFFFFFF, 0x3FFFFFFFFC00E000,
                    0xE7FFFFFFFFFF07FF, 0x46FDE0000000000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF3FFFD503F2FFC84, 0xFFFFFFFF000043E0,
                    0x1FF, 0xC781FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x80FFFFFFFFFF,
                    0x7F7F7F7F007FFFFF, 0x7F7F7F7F, 0x1F3E03FE000000E0, 0xFFFFFFFEF87FFFFF,
                    0xF7FFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xC00FFFF1FFF,
                    0x80007FFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFFFFFFFFFFFF,
                    0xFFFFFFFCFF800000, 0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x7FFFFF7BB,
                    0xFFFFFFFFFFFFC, 0x68FC000000000000, 0xFFFF003FFFFFFC00,
                    0x1FFFFFFF0000007F, 0x7FFFFFFFFFFF0, 0x7C00FFDF00008000, 0x1FFFFFFFFFF,
                    0xC47FFFFF00000FF7, 0x3E62FFFFFFFFFFFF, 0x1C07FF38000005,
                    0xFFFF7F7F007E7E7E, 0xFFFF03FFF7FFFFFF, 0x7FFFFFFFF, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFA0F8007F,
                    0xFFFFFFFFFFFFFFDB, 0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000,
                    0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFCFFFF,
                    0xFFF0000000000FF, 0xFFDF000000000000, 0x1FFFFFFFFFFFFFFF,
                    0x7FFFFFE00000000, 0xFFFFFFC007FFFFFE, 0x7FFFFFFFFFFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 5, 11, 12, 5, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 13, 14, 15, 7, 16, 17, 7, 18, 19, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15,
                    16, 17, 2, 2, 2, 2, 18, 19, 20, 4, 21, 22, 23, 24, 25, 4, 26, 4, 27, 28,
                    29, 30, 31, 32, 33, 4, 2, 34, 35, 35, 36, 37, 38, 4, 4, 4, 39, 40, 41, 42,
                    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 23, 56, 57, 58, 59, 5,
                    60, 61, 62, 4, 4, 63, 64, 61, 65, 66, 4, 67, 68, 4, 4, 69, 4, 70, 71, 72,
                    73, 74, 75, 76, 77, 78, 79, 4, 4, 4, 80, 81, 82, 83, 4, 84, 85, 86, 4, 4,
                    4, 4, 87, 88, 4, 89, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 4,
                    2, 63, 2, 2, 2, 91, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 92, 93,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 61, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 68, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 79, 96, 97, 98, 61, 99, 83, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 34, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 112, 113, 114,
                    115, 116, 2, 2, 2, 2, 117, 118, 119, 120, 121, 122, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 123, 4, 4,
                    4, 124, 125, 4, 4, 126, 127, 4, 4, 4, 4, 98, 69, 4, 4, 4, 4, 4, 4, 4, 128,
                    4, 4, 4, 129, 4, 4, 4, 4, 4, 4, 4, 130, 2, 2, 2, 131, 2, 132, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 133, 134, 135, 4, 4, 4, 4, 4, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 136, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 137, 2, 2, 2, 10, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 138, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 139, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2,
                    95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 140, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 61, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF,
                    0x3FFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F, 0xFFFF00003FFFFFFF,
                    0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF, 0xF7FF000FFFFFFFFF,
                    0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                    0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF,
                    0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEF0001,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF, 0xFFFFFFFFF,
                    0xFFFF803FFFFFFC00, 0x3F, 0x303FFFFFFFFFF, 0x1C, 0xFFFF00801FFFFFFF,
                    0xFFFF00000000003F, 0xFFFF000000000003, 0x7FFFFF0000001F,
                    0xFFFFFFFFFFFFF8, 0x26000000000000, 0xFFFFFFFFFFF8, 0x1FFFFFF0000,
                    0x7FFFFFFFF8, 0x47FFFFFFFF0090, 0x7FFFFFFFFFFF8, 0x1400001E,
                    0x80000FFFFFFBFFFF, 0x1, 0xFFFF01FFBFFFBD7F, 0x23EDFDFFFFF99FE0,
                    0x3E0010000, 0xBFFFFFFFFF4BFF, 0xA0000, 0x380000780, 0xFFFFFFFFFFFF, 0xB0,
                    0x7FFFFFFFFFFF, 0xF000000, 0x10, 0x10007FFFFFFFFFF, 0x7FFFFFF, 0x7F,
                    0xFFFFFFFFFFF, 0xFFFFFFFF00000000, 0x80000000FFFFFFFF, 0x8000FFFFFF6FF27F,
                    0x2, 0xFFFFFCFF00000000, 0xA0001FFFF, 0x407FFFFFFFFF801,
                    0xFFFFFFFFF0010000, 0xFFFF0000200003FF, 0x1FFFFFFFFFFFFFF, 0x1FFFFFFFF,
                    0x7FFFFFFFFDFF, 0xFFFC000000000001, 0xFFFF, 0x1FFFFFFFFFB7F,
                    0xFFFFFDBF00000040, 0x10003FF, 0x7FFFF00000000, 0xFFFFFFFFDFFF4,
                    0x1000000000000, 0x3FFFFFF, 0xF, 0xFFFFFFFFFFFF0000, 0x1FFFFFFFFFFFF,
                    0xFFFFFFFF0000007E, 0x3FFFFFFF, 0xFFFF00007FFFFFFF, 0x7FFFFFFFFFFFFFFF,
                    0x3FFFFFFF0000, 0xE0FFFFF80000000F, 0x1FFFFFFFFFFF, 0x107FF, 0xFFF80000,
                    0xB00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF, 0x6FEF000000000000,
                    0x40007FFFFFFFF, 0xFFFF00F000270000, 0xFFFFFFFFFFFFFFF,
                    0x1FFF07FFFFFFFFFF, 0x3FF01FF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF,
                    0xFFFF7FFFFFFF7FFF, 0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFFFF,
                    0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x3F801FFFFFFFFFFF, 0x4000,
                    0xFFFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F, 0x80F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const IDEOGRAPHIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 3, 2, 4, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x70003FE000000C0, 0xFFFFFFFFFFFFFFFF, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 4, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 5, 6, 7, 2, 8, 9, 2, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 5, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 2, 2, 2, 2, 7, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 12, 2, 2, 2, 2, 2, 2, 2, 2, 2, 13, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 13, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 14, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 15,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1000000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                    0x1FF, 0xFFFF000000000000, 0xFFFFFFFFFFFFFFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFFFF0003FFFFFFFF,
                    0xFFFF0001FFFFFFFF, 0x3FFFFFFF, 0xFFFFFFFFFFFF07FF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const INCB: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0x3F8, 0, 0, 0, 0xBFFFFFFFFFFE0000, 0xB6, 0x7FF0000,
                    0x10000FFFFF800, 0, 0x3D9F9FC00000, 0xFFFF000000020000, 0x7FF,
                    0x1FFC000000000, 0x200FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 36, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 37, 38, 39, 40, 41, 35, 42, 35, 43, 35, 35, 35, 44, 45, 46,
                    47, 48, 49, 50, 51, 52, 35, 35, 53, 35, 35, 35, 54, 35, 35, 35, 35, 35,
                    35, 35, 35, 55, 35, 35, 56, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    57, 35, 58, 35, 59, 35, 35, 35, 35, 35, 35, 35, 35, 60, 35, 61, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    62, 63, 64, 35, 35, 35, 35, 65, 35, 35, 66, 67, 68, 69, 70, 71, 72, 73,
                    74, 35, 35, 35, 75, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 76, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 77, 35, 35, 35, 35, 35, 63, 35,
                ],
                tree2_level2: &[
                    0x3EEFFBC00000, 0xE000000, 0xFF800000, 0xFFFFFFFBFFFFFC00,
                    0x17FFFFFFFFE00007, 0xFF00000CFFFE21FE, 0x53C5FDFFFFE00002,
                    0x4003000CB080201E, 0x1000000000000006, 0x23000000023986,
                    0x13EDFDFFFFE00006, 0xFE00000C000021BE, 0xD3EDFDFFFFE00002,
                    0x2000CB0E0201E, 0x4000000000000004, 0x802001, 0xD3FFFDFFFFE00011,
                    0xC07603DC1, 0x9000000000000002, 0xC00603DC5, 0x5FFFFFFFFFE00003,
                    0xC0080201E, 0x2, 0x805C8400, 0x7F2000000000000, 0x7F80,
                    0x1FF2000000000000, 0x7F00, 0x2A0000003000000, 0x7FFE000000000000,
                    0x1FFFFFFFFEFFE0DF, 0x40, 0x66FDE00000000000, 0x1E0001C3000000,
                    0x20002064, 0, 0xE0000000, 0x1C0000003C0000, 0xC0000000C0000,
                    0x3FB0000000000000, 0x200FFE40, 0xB800, 0x20000000060, 0xE04018700000000,
                    0x9800000, 0x9FF81FE57F400000, 0xFFFF000000000000, 0x7FFF,
                    0x3FF000000000000F, 0xFF8000000001C, 0x3F3C00000003, 0xFA34000000000,
                    0xCFF00000000000, 0x31021FDFFF70000, 0xFFFFFFFFFFFFFFFF, 0x2000,
                    0x1FFFFFFFF0000, 0x3800000000000, 0x8000000000000000, 0xFFFFFFFF00000000,
                    0xFC0000000000, 0x6000000, 0x3FF7800000000000, 0xC0000000,
                    0x3000000000000, 0x106000000844, 0x8003FFFF00000030, 0x3FC000000000,
                    0xBFF80, 0x33C8000000000007, 0x2000000001, 0x667E0000000000,
                    0x1000000000001008, 0xC19D000000000000, 0x40300000000002, 0x212000000000,
                    0x40000000, 0xFFFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 2, 5, 6, 7, 8, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0,
                    0, 0, 6, 7, 0, 0, 0, 0, 8, 9, 0, 10, 11, 0, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0, 0, 31, 32, 33, 34,
                    35, 0, 36, 0, 0, 0, 37, 0, 0, 0, 38, 39, 0, 40, 41, 42, 43, 0, 0, 0, 0, 0,
                    44, 0, 45, 0, 46, 47, 48, 0, 0, 0, 0, 49, 50, 51, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 55, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 61, 0, 0, 0, 0, 0, 0, 0,
                    62, 63, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 66, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 56, 0, 55, 0, 0, 0, 0, 0, 69, 70,
                    0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72,
                    0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 76, 0, 0, 76,
                    76, 76, 77, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x870000000000F06E,
                    0x6000000000, 0xF000000000, 0x3E0000000000, 0x180000000000,
                    0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000002, 0x801900000000007F,
                    0x678000000000003, 0x4, 0x1FEF8000000007, 0x8000000000000,
                    0x7FC0000000000003, 0x9E01, 0x40F3800000000000, 0x2, 0x7F880000000,
                    0x5800000000000003, 0x1F1FC000802001, 0xF900000000000000, 0x60005C3A5,
                    0xFF00000000000000, 0x4000005C, 0xA5F9000000000000, 0xD,
                    0xB03C800000000000, 0x30000001, 0xA7F8000000000000, 0x1, 0xFF280000000000,
                    0xFBCA0000000, 0x6FF800000000000, 0x7801000000000000, 0x8, 0x10CF00000,
                    0x79F80000000007FE, 0xE7E0080, 0x37FFC00, 0xBF7F000000000000,
                    0x6DFCFFFFFC0000, 0xB47E000000000000, 0xBF, 0xA30000, 0x18000000000000,
                    0x7C0000000000003, 0x4000007, 0x3FFF81, 0xE3FFC0000000, 0x1F000000000000,
                    0x7F000000000000, 0x8000, 0x78000, 0x3001000000000, 0x60000000,
                    0xFFFF3FFFFFFFFFFF, 0x7F, 0xF807E3E000000000, 0x3C0000000FE7, 0x1C,
                    0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7DBF9FFFF7F,
                    0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x7F0,
                    0xF800000000000000, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF,
                ],
                };

                pub const JOIN_CONTROL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LOGICAL_ORDER_EXCEPTION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1F, 0x4E0000000000000, 0x1A60000000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LOWERCASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE00000000, 0x420040000000000, 0xFF7FFFFF80000000,
                    0x55AAAAAAAAAAAAAA, 0xD4AAAAAAAAAAAB55, 0xE6512D2A4E243129,
                    0xAA29AAAAB5555240, 0x93FAAAAAAAAAAAAA, 0xFFFFFFFFFFFFAA85,
                    0x1FFFFFFFFEFFFFF, 0x1F00000003, 0, 0x3C8A000000000020,
                    0xFFFFF00000010000, 0x192FAAAAAAE37FFF, 0xFFFF000000000000,
                    0xAAAAAAAAFFFFFFFF, 0xAAAAAAAAAAAAA802, 0xAAAAAAAAAAAAD554,
                    0xAAAAAAAAAAAA, 0xFFFFFFFF00000000, 0x1FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 4, 4, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 11, 12,
                    0, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18,
                    5, 19, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22, 0, 23, 24, 25, 26, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 27, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0,
                    0,
                ],
                tree2_level2: &[
                    0, 0xF7FFFFFFFFFF0000, 0x3F00000000000000, 0x5FF, 0xFFFFFFFFFFFFFFFF,
                    0xAAAAAAAAAAAAAAAA, 0xAAAAAAAABFEAAAAA, 0xFF00FF003F00FF,
                    0x3FFF00FF00FF003F, 0x40DF00FF00FF00FF, 0xDC00FF00CF00DC,
                    0x8002000000000000, 0x1FFF0000, 0x321080000008C400, 0xFFFF0000000043C0,
                    0x10, 0x3FFFFFF0000, 0xFFFF000000000000, 0x3FDA1562FFFFFFFF,
                    0x8501AAAAAAAAA, 0x20BFFFFFFFFF, 0x2AAAAAAAAAAA, 0x3AAAAAAA,
                    0xAAABAAA800000000, 0x95FFAAAAAAAAAAAA, 0xAAA082AAAABA50AA,
                    0x75C00000AAA250A, 0xFFFF03FFF7FFFFFF, 0xF8007F, 0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0,
                    0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 6, 0, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11,
                    12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27,
                    0, 0, 0, 7, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 30, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFF0000000000, 0xFFFF, 0xFFFFFFFFF000000, 0x1BFBFFFBFF800000,
                    0x7FDFFFFFFFFFFB9, 0x7FFFFFFFFFFFF, 0xFFFF000000000000, 0x3F, 0xFFFFFFFF,
                    0xFFFFFFFF00000000, 0xFFFFFFC000000, 0xFFFFDFC000, 0xEBC000000FFFFFFC,
                    0xFFFFFC000000FFEF, 0xFFFFFFC000000F, 0xFFFFFFC0000, 0xFC000000FFFFFFC0,
                    0xFFFFC000000FFFFF, 0xFFFFFFC000000FF, 0xFFFFFFC00000, 0x3FFFFFFC00,
                    0xF0000003F7FFFFFC, 0xFFC000000FDFFFFF, 0xFFFF0000003F7FFF,
                    0xFFFFFC000000FDFF, 0xBF7, 0x7E07FFFFBFF, 0x3FFFFFFFFFFF,
                    0xFFFFFFFC00000000, 0xF,
                ],
                };

                pub const MATH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x7000080000000000, 0x5000000040000000, 0x2100000000000, 0x80000000800000,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x73000000270000, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x1C0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4,
                    5, 6, 7, 8, 9, 9, 9, 9, 10, 11, 12, 13, 0, 0, 0, 0, 0, 0, 14, 15, 16, 17,
                    0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 18, 19, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 22, 23, 0, 24,
                ],
                tree2_level2: &[
                    0, 0x1C000000400000, 0x7C00001E00040011, 0x7C00, 0xF8621FFF0000,
                    0xF1FBB3103F2FFC84, 0xBFF, 0xF0C37EFFFFFF0000, 0xFFF000302FFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x300000F00, 0x1000000000000000, 0xBFFFFFF8000000,
                    0x7F0010000, 0xF0FFC00300000000, 0xFF001F94000F8CC3, 0x60, 0xE00F00000005,
                    0xFFFF000000000000, 0x1F9F, 0x20000000000, 0x17E00000000,
                    0x5000000070000800, 0x50000000, 0x1E0400000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7,
                    2, 2, 2, 2, 8, 2, 2, 2, 2, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,
                    11, 12, 13, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xFFFFFFFFFFFFCFFF, 0xAF7FE96FFFFFFEF,
                    0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0x3000000000000,
                ],
                };

                pub const MODIFIER_COMBINING_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x1300000, 0, 0x18810000000, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x800000008EC00,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const NONCHARACTER_CODE_POINT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF0000, 0xC000000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1,
                ],
                tree3_level3: &[
                    0, 0xC000000000000000,
                ],
                };

                pub const OTHER_ALPHABETIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFF800000020, 0, 0, 0, 0, 0, 0,
                    0, 0, 0xBFFF000000000000, 0xB6, 0x7FF0000, 0x10000FEFFF800, 0,
                    0x219E1FC00000, 0xFFFF000000020000, 0, 0x1FFC000000000, 0,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 6, 8, 6, 9, 6, 10, 11, 12, 13, 14, 6, 15, 16, 17,
                    18, 19, 20, 21, 22, 21, 1, 23, 24, 1, 25, 26, 27, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 28, 28, 29, 30, 1, 1,
                    31, 1, 32, 1, 1, 1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 1, 1, 1, 1, 1, 1,
                    42, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 29, 43, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 44, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    45, 46, 1, 1, 1, 1, 1, 47, 1, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 1,
                    1, 1, 58, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 59, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                ],
                tree2_level2: &[
                    0x1EEFF8C00000, 0, 0x800000, 0xFFFF03F8FFF00000, 0xCC0000000000000F,
                    0xC00E0DFFF, 0xC00000000000000E, 0xC0080199F, 0x23000000021987,
                    0x1C00000C00001BBF, 0xC00C0199F, 0xC000000000000004, 0x801DC7,
                    0xC00000000000001F, 0xC00601DDF, 0x8000C00601DDF, 0xC00000000000000F,
                    0xC00801DDF, 0xE, 0xC0000FF5F8000, 0x7F2000000000000, 0x2000,
                    0x1BF2000000000000, 0xFFFE000000000000, 0x1FFFFFFFFEFFE00F,
                    0x797FF80000000000, 0x1E3F9DC3C00000, 0x3C00BFFC, 0xC0000000C0000,
                    0xFFC0000000000000, 0x1FF, 0x20000000060, 0x1FF0FFF00000000, 0xF800000,
                    0x1FFFFE7FE00000, 0x8000000000000000, 0x7001, 0xFFE000000000001F, 0xF,
                    0x33FE00000007, 0x3FF8000000000, 0x7FFFF000000000, 0x1FFFFFFFF80000,
                    0x3FFFFFFFFFF, 0xFFFFFFFF00000000, 0xFF0000000000000, 0xC0000000,
                    0xF800000804, 0xFFF0000000000003, 0x800000000000002F, 0x7C000000000,
                    0x7FF80, 0xFFF000000000000F, 0x2000000000, 0x7FFE0000000000,
                    0x3800000000003008, 0x419D000000000000, 0x20F80000000000, 0x7F800000000,
                    0x40000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 2, 2, 5, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 3, 4, 0, 0, 0, 0, 5, 6, 0, 0, 0, 0, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                    16, 0, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 26, 27, 28, 29, 30, 0,
                    31, 0, 0, 0, 32, 0, 0, 0, 33, 34, 0, 35, 36, 37, 38, 0, 0, 0, 0, 0, 39, 0,
                    40, 0, 41, 42, 43, 0, 0, 0, 0, 44, 45, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 48, 49, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 24, 54, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7C0000000000000, 0xF06E, 0xF000000000, 0x20000000000, 0x180000000000,
                    0x1000000000000000, 0xFF00000000000007, 0x1800000000003F,
                    0x1FF000000000007, 0x4, 0x7FF8000000007, 0x60, 0xFFF8000000000007, 0xC000,
                    0x409FF00000000000, 0x2, 0x1FF80000000, 0xC00000000000000F, 0xC0080199F,
                    0xFF00000000000000, 0x37A5, 0xFFE0000000000000, 0x3B, 0xFFFF000000000000,
                    0x3, 0x7F3F800000000000, 0x30000000, 0x7FFF000000000000, 0x1,
                    0x3FF80000000000, 0x7FFE0000000, 0x1FFF00000000000, 0x19BF000000000000,
                    0x5, 0x10FCFE0000, 0x7BE00000000007FE, 0xFFE0000, 0xFFFC00,
                    0x7F7F800000000000, 0x7FFEFFFFFC0000, 0xB47E000000000000, 0x8B, 0x7B7C00,
                    0x78000000000000, 0xC7F000000000000B, 0x7FFFC0000000, 0xFFFFFFFFFFFE8000,
                    0x780FF, 0x3000000000000, 0x40000000, 0x7DBF9FFFF7F, 0x8000, 0x80,
                    0xFFFF03FFFFFF03FF, 0x3FF,
                ],
                };

                pub const OTHER_DEFAULT_IGNORABLE_CODE_POINT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x8000, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6,
                ],
                tree2_level2: &[
                    0, 0x180000000, 0x30000000000000, 0x2000000000, 0x1000000000, 0x100000000,
                    0x1FF000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 2, 0, 0, 0, 3, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFD, 0xFFFFFFFFFFFFFFFF, 0xFFFF000000000000,
                ],
                };

                pub const OTHER_GRAPHEME_EXTEND: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 2, 0, 0, 0, 3, 1, 2, 0, 4, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0,
                    13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0,
                ],
                tree2_level2: &[
                    0, 0x4000000000000000, 0x800000, 0x600D85, 0x80008000, 0x10000000200000,
                    0x2820000000000000, 0x18, 0x40000000000, 0xC000000000000, 0x1000,
                    0xC00000000000, 0x80000, 0x1, 0xC0000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 3, 4, 5, 6, 0, 0, 7, 0, 0, 0, 8, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 12,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 13, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1, 0x20000000000000, 0x4000000000000000, 0x802000, 0x100000000000000,
                    0x83A4, 0x2001000000000000, 0x800000000000, 0x40000000000000, 0x2,
                    0x3000000000000, 0x7E06000000000, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFF,
                ],
                };

                pub const OTHER_ID_CONTINUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x80000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3FE0000000000, 0x4000000, 0x3000, 0x800000000000000, 0x2000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OTHER_ID_START: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x60, 0x400001000000, 0x18000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OTHER_LOWERCASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x400040000000000, 0, 0, 0, 0, 0, 0, 0, 0x1FF000000000000,
                    0x1F00000003, 0, 0x400000000000020, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 0,
                    0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 11, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1000000000000000, 0xFFFFF00000000000, 0x10007FFFFFFFFFF,
                    0xFFFFFFFFF8000000, 0x8002000000000000, 0x1FFF0000, 0xFFFF000000000000,
                    0x3FFFFFF0000, 0x3000000000000000, 0x30000000, 0x1000000000000,
                    0x31C000000000000, 0x200F0000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FDFFFFFFFFFFB9, 0xFFFF000000000000, 0x3FFFFFFFFFFF,
                ],
                };

                pub const OTHER_MATH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x40000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x33000000270000, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4,
                    5, 6, 7, 8, 0, 0, 0, 0, 9, 0, 10, 11, 0, 0, 0, 0, 0, 0, 12, 13, 14, 15, 0,
                    0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 20, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1C000000400000, 0x6000001E00000001, 0x6000, 0xF8621FFF0000,
                    0xF1FBB3103E2FFC84, 0x3E0, 0xF0C33EB6F3E00000, 0x302FEB3FFF, 0xF00,
                    0xB0000000000000, 0x400010000, 0xF07FC00300000000, 0x1F94000F8CC1, 0x60,
                    0x600F00000005, 0xFFC000000060, 0x1FFFFF8, 0x300000000F000000,
                    0x10A00000000, 0x5000000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 1, 1, 1, 1, 7, 8, 9, 10, 11, 12, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 14, 15, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF,
                    0xFFFF7FFFFFFF7FFF, 0xFFFFFDFFFFFFFDFF, 0xFFFFFFFFFFFFCFF7,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF,
                ],
                };

                pub const OTHER_UPPERCASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF00000000, 0xFFC0000000000000, 0xFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0xFFFF03FFFFFF03FF, 0x3FF,
                ],
                };

                pub const PATTERN_SYNTAX: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFC00FFFE00000000, 0x7800000178000001, 0x88435AFE00000000,
                    0x80000000800000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    6, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0,
                    0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FFF00FFFFFF0000, 0x7FEFFFFE, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFF, 0x3FFFFFFFFFFFFF, 0xFFFFFFFFFFF00000, 0x10001FFFFFF0E,
                    0xC000000000000000, 0x60,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const PATTERN_WHITE_SPACE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x100003E00, 0, 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3000000C000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const PREPENDED_CONCATENATION_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x3F, 0, 0, 0x20000000, 0x8000, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x30000, 0x400000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x2000,
                ],
                };

                pub const QUOTATION_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8400000000, 0, 0x800080000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 6, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x6000000FF000000, 0x4, 0xE000F000, 0x1E, 0x84, 0xC00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const RADICAL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFBFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x3FFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const REGIONAL_INDICATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFC000000000,
                ],
                };

                pub const SENTENCE_TERMINAL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8000400200000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0x200, 0, 0xE0000000, 0, 0, 0x100000, 0x7, 0, 0,
                    0x200000000000000,
                ],
                tree2_level1: &[
                    0, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 6, 1, 1, 7, 8, 1, 1, 1, 1, 9, 1, 1, 1, 1,
                    10, 1, 1, 11, 1, 1, 12, 13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14,
                    15, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 16, 1, 1, 1, 1, 17, 18, 1, 1, 1, 1, 1, 1, 19, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 20, 1, 1, 1, 1, 21, 1, 1, 22, 1, 1, 1, 1, 1, 23,
                    1, 21, 24, 1, 1, 25, 1, 26, 1, 27, 1, 1, 1, 28, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 29, 30, 1, 1, 31,
                    32, 1, 1,
                ],
                tree2_level2: &[
                    0x6280000000000000, 0, 0x3000000000, 0xC00, 0x18400000000, 0x400000000000,
                    0x60000000000000, 0x300000, 0x208, 0x30, 0xF0000000000,
                    0xE0000000CC00C000, 0x1800000000000000, 0xC000000000000000,
                    0x3000001000000000, 0x380, 0xE00000000000000, 0x1000400000000000,
                    0x180000, 0x4, 0x8000000000000000, 0xC000, 0x88000000000000,
                    0xC0000000000000, 0x800000000000, 0x300, 0xE0000000, 0x3000000000000,
                    0x80000000000, 0x640000, 0xC40000, 0x80004002, 0x200000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 4, 5, 6, 0, 7, 0, 8, 9, 0,
                    10, 0, 0, 0, 0, 11, 0, 12, 0, 0, 0, 0, 0, 13, 0, 14, 0, 0, 15, 0, 0, 0, 0,
                    0, 0, 0, 0, 16, 0, 0, 0, 17, 18, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 19, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 22, 19, 23, 0, 0, 0, 0,
                    0, 0, 0, 21, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC00000, 0x3E00000, 0x3C0, 0x180, 0xC000000000000000, 0x3, 0xE,
                    0xC0002060, 0x1B00000000000000, 0x20000000000, 0x300000, 0x1800, 0xFFFE0C,
                    0x6, 0x7000000000000000, 0x50, 0xC, 0x18000000, 0x180000000000000, 0x18,
                    0xC00000000000, 0x20000000000000, 0x10, 0x1000000, 0x80000000, 0x100,
                ],
                };

                pub const SOFT_DOTTED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x60000000000, 0, 0, 0x800000000000, 0, 0, 0, 0, 0x10000000200,
                    0x4000020000000, 0, 0, 0, 0, 0x8000000000000, 0, 0x1400000, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0, 0, 0, 0, 5, 0, 0,
                    0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x400000000, 0x11000400000, 0x200000000000, 0x800, 0x2000000000000,
                    0x300, 0x1000000000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    12, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC00000000, 0xC00000, 0xC000000000000C00, 0xC000000000000,
                    0xC000000000, 0xC000000, 0xC000, 0xC000000000000C, 0xC0000000000,
                    0xC0000000, 0xC0000, 0x4000000, 0x10000003000,
                ],
                };

                pub const TERMINAL_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8C00500200000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x4000000000000000, 0x80, 0, 0, 0, 0, 0, 0, 0, 0x200, 0x8, 0xE8001000, 0,
                    0, 0x100000, 0x17FF, 0, 0, 0x300000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    4, 2, 2, 5, 2, 2, 2, 2, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 8, 2, 9, 10, 2, 2, 11, 12, 2, 2, 2, 2, 13, 2, 2, 2,
                    2, 14, 2, 2, 15, 2, 2, 16, 17, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    18, 19, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 20, 2, 2, 2, 2, 21, 22, 2, 2, 2, 2, 2, 2, 23, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 17, 2, 2, 2, 2, 24, 2, 2, 25, 2, 2, 2, 2, 2,
                    26, 2, 27, 28, 2, 2, 19, 2, 29, 2, 30, 2, 2, 2, 31, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 33, 2,
                    2, 34, 35, 2, 2,
                ],
                tree2_level2: &[
                    0x7FBF000000000000, 0x40000000, 0, 0x3000000000, 0xC000000, 0x7E100,
                    0xC00, 0x1FE00000000, 0x400000000000, 0x380000000000, 0x60000000000000,
                    0x4700000, 0x33C, 0x30, 0xF0000000000, 0xE0000000EC00C000,
                    0xF800000000000000, 0xC000000000000000, 0x3000001000000000, 0x380,
                    0xE00000000000000, 0x1000400000000000, 0x18D002, 0x6, 0xE000,
                    0xF8000000000000, 0xC0000000000000, 0xC000, 0x800000000000, 0xE0000000,
                    0x3000080000000, 0x80000000000, 0x640000, 0xF70000, 0x8C005002,
                    0x1200000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 3, 3, 3, 3, 5, 3, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 4, 0, 5, 6, 0, 7, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 10, 11, 12, 0, 13, 0, 14, 15,
                    0, 16, 0, 0, 0, 0, 17, 0, 18, 0, 0, 0, 0, 0, 19, 0, 20, 0, 0, 21, 0, 0, 0,
                    0, 0, 0, 0, 0, 22, 0, 0, 0, 23, 24, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 26, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 33,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x80000000, 0x10000, 0x800000, 0xC00000, 0x3F000000000000,
                    0xFC00000000000000, 0x1E000000, 0x3E00000, 0x3C0, 0x3F80,
                    0xC000000000000000, 0x3, 0xE, 0xC0002060, 0x1F00000000000000,
                    0x20000000000, 0x300000, 0xC003800, 0xFFFE3C, 0x6, 0x7000000000000000,
                    0x50, 0xC, 0x618000000, 0x200000000000E, 0x180000000000000, 0x18,
                    0x1F000000000000, 0xC00000000000, 0x20000000000000, 0x380000000000000,
                    0x10, 0x1800000, 0x780,
                ],
                };

                pub const UNIFIED_IDEOGRAPH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x39A801AC000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 2, 3, 4, 1, 5, 0, 1, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 7, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF, 0x3FFFFFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF,
                    0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF, 0xFFFFFFFFFFFF07FF,
                    0xFFFFFFFFFFFF,
                ],
                };

                pub const UPPERCASE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE, 0, 0x7F7FFFFF, 0xAA55555555555555, 0x2B555555555554AA,
                    0x11AED2D5B1DBCED6, 0x55D255554AAAA490, 0x6C05555555555555, 0x557A, 0, 0,
                    0, 0x8045000000000000, 0xFFBFFFED740, 0xE6905555551C8000, 0xFFFFFFFFFFFF,
                    0x5555555500000000, 0x5555555555555401, 0x5555555555552AAB,
                    0xFFFE555555555555, 0x7FFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 11, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17,
                    5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x20BF, 0x3FFFFFFFFFFFFF, 0xE7FFFFFFFFFF0200,
                    0x5555555555555555, 0x5555555540155555, 0xFF00FF003F00FF00,
                    0xFF00AA003F00, 0xF00000000000000, 0xF001F000F000F00, 0xC00F3D503E273884,
                    0xFFFF00000020, 0x8, 0xFFC0000000000000, 0xFFFF, 0xFFFFFFFFFFFF,
                    0xC025EA9D00000000, 0x4280555555555, 0x155555555555, 0x5555555,
                    0x5554555400000000, 0x6A00555555555555, 0x555F7D5555452855,
                    0x20000015411AF5, 0x7FFFFFE00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11,
                    12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 27, 28, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF, 0xFFFF000000000000, 0xFFFFF, 0xF7FF000000000000,
                    0x37F7FF, 0x7FFFFFFFFFFFF, 0x3FFFFF0000, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0xFFF0000003FFFFFF, 0xFFFFFF0000003FFF, 0x3FDE64D0000003, 0x3FFFFFF0000,
                    0x7B0000001FDFE7B0, 0xFFFFF0000001FC5F, 0x3FFFFFF0000003F, 0x3FFFFFF00000,
                    0xF0000003FFFFFF00, 0xFFFF0000003FFFFF, 0xFFFFFF00000003FF,
                    0x7FFFFFC00000001, 0x1FFFFFF0000000, 0x7FFFFFC00000, 0x1FFFFFF0000, 0x400,
                    0x3FFFFFFFF, 0xFFFF03FFFFFF03FF, 0x3FF,
                ],
                };

                pub const VARIATION_SELECTOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xB800, 0xFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const WHITE_SPACE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x100003E00, 0, 0x100000020, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x8300000007FF, 0x80000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const XID_CONTINUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0x7FFFFFE87FFFFFE, 0x4A0040000000000,
                    0xFF7FFFFFFF7FFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3,
                    0xFFFFFFFFFFFFFFFF, 0xB8DFFFFFFFFFFFFF, 0xFFFFFFFBFFFFD7C0,
                    0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFCFB, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF,
                    0xFFFFFFFF027FFFFF, 0xBFFFFFFFFFFE01FF, 0x787FFFFFF00B6,
                    0xFFFFFFFF07FF0000, 0xFFFFC3FFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x9FFFFDFF9FEFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFFE7FF,
                    0x3FFFFFFFFFFFF, 0x243FFFFFFFFFFFFF,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 4, 32, 33, 34, 4, 4, 4, 4, 4,
                    35, 36, 37, 38, 39, 40, 41, 42, 4, 4, 4, 4, 4, 4, 4, 4, 43, 44, 45, 46,
                    47, 4, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 4, 61, 4, 62,
                    63, 64, 65, 66, 4, 4, 4, 4, 4, 4, 4, 4, 67, 68, 69, 70, 71, 72, 73, 74,
                    75, 76, 77, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 4, 4, 4, 79, 80, 81, 82, 83, 78, 78, 78,
                    78, 78, 78, 78, 78, 84, 42, 85, 4, 86, 4, 87, 88, 78, 78, 78, 78, 78, 78,
                    78, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 89, 90, 4, 4, 4, 4, 91, 92, 4, 93, 94, 4, 95, 96, 97, 62, 4,
                    98, 99, 100, 4, 101, 102, 103, 4, 104, 105, 106, 4, 107, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 108, 109, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
                    78, 78, 78, 78, 4, 4, 4, 4, 4, 99, 4, 110, 111, 112, 93, 113, 4, 114, 4,
                    4, 115, 116, 117, 118, 119, 120, 4, 121, 122, 123, 124, 125,
                ],
                tree2_level2: &[
                    0x3FFFFFFFFFFF, 0xFFFF07FF0FFFFFFF, 0xFFFFFFFFFF807EFF,
                    0xFFFFFFFBFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFCFFFFFFFFF,
                    0xF3C5FDFFFFF99FEF, 0x5003FFCFB080799F, 0xD36DFDFFFFF987EE,
                    0x3FFFC05E023987, 0xF3EDFDFFFFFBBFEE, 0xFE00FFCF00013BBF,
                    0xF3EDFDFFFFF99FEE, 0x2FFCFB0E0399F, 0xC3FFC718D63DC7EC, 0xFFC000813DC7,
                    0xF3FFFDFFFFFDDFFF, 0xFFCF27603DDF, 0xF3EFFDFFFFFDDFEF, 0xEFFCF60603DDF,
                    0xFFFFFFFFFFFDDFFF, 0xFC00FFCF80F07DDF, 0x2FFBFFFFFC7FFFEE,
                    0xCFFC0FF5F847F, 0x7FFFFFFFFFFFFFE, 0x3FF7FFF, 0x3FFFFFAFFFFFF7D6,
                    0xF3FF7F5F, 0xC2A003FF03000001, 0xFFFE1FFFFFFFFEFF, 0x1FFFFFFFFEFFFFDF,
                    0x40, 0xFFFFFFFFFFFF03FF, 0xFFFFFFFF3FFFFFFF, 0xF7FFFFFFFFFF20BF,
                    0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D,
                    0xFFFFFFFFFF3DFFFF, 0x3FE00E7FFFFFF, 0xFFFFFFFF0000FFFF,
                    0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE, 0xFFFF9FFFFFFFFFFF,
                    0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF, 0x1FFFFF803FFFFF, 0xDDFFF000FFFFF,
                    0x3FF308FFFFF, 0xFFFFFFFF03FFB800, 0x1FFFFFFFFFFFFFF, 0xFFFF07FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0xFFF0FFF7FFFFFFF, 0x1F3FFFFFFFFFC0, 0xFFFF0FFFFFFFFFFF,
                    0x7FF03FF, 0xFFFFFFFF0FFFFFFF, 0x9FFFFFFF7FFFFFFF, 0xBFFF008003FF03FF,
                    0x7FFF, 0xFF80003FF1FFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF,
                    0x3FFFFFFFFFFFE3FF, 0xE7FFFFFFFFFF07FF, 0x7FFFFFFFFF70000,
                    0xFFFFFFFF3F3FFFFF, 0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF,
                    0x1FDC1FFF0FCF1FDC, 0x8000000000003000, 0x8002000000100001, 0x1FFF0000,
                    0x1FFE21FFF0000, 0xF3FFFD503F2FFC84, 0xFFFFFFFF000043E0, 0x1FF, 0,
                    0xFF81FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x800080FFFFFFFFFF,
                    0x7F7F7F7F007FFFFF, 0xFFFFFFFF7F7F7F7F, 0x1F3EFFFE000000E0,
                    0xFFFFFFFEE67FFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xFFFFFFF1FFF,
                    0xBFF0FFFFFFFFFFFF, 0x3FFFFFFFFFFFF, 0xFFFFFFFCFF800000,
                    0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x10FFFFFFFFFF,
                    0xE8FFFFFF03FF003F, 0xFFFF3FFFFFFFFFFF, 0x1FFFFFFF000FFFFF,
                    0x7FFFFFFF03FF8001, 0x7FFFFFFFFFFFFF, 0xFC7FFFFF03FF3FFF,
                    0x7CFFFF38000007, 0xFFFF7F7F007E7E7E, 0xFFFF03FFF7FFFFFF,
                    0x3FF37FFFFFFFFFF, 0xFFFF000FFFFFFFFF, 0xFFFFFFFFFFFF87F, 0x3FFFFFF,
                    0x5F7FFDFFE0F8007F, 0xFFFFFFFFFFFFFFDB, 0xFFFFFFFFFFF80000,
                    0xFFFFFFF03FFFFFFF, 0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000,
                    0xFFFFFFFFFFFCFFFF, 0x3FF0000000000FF, 0x18FFFF0000FFFF,
                    0xAA8A00000000E000, 0x1FFFFFFFFFFFFFFF, 0x87FFFFFE03FF0000,
                    0xFFFFFFE007FFFFFE, 0x7FFFFFFFFFFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 6, 4, 4, 7, 8, 9, 10, 11, 12, 2, 2, 13, 14, 15, 16,
                    17, 18, 2, 2, 2, 2, 19, 20, 21, 4, 22, 23, 24, 25, 26, 4, 27, 4, 28, 29,
                    30, 31, 32, 33, 34, 4, 2, 35, 36, 36, 37, 38, 39, 4, 4, 4, 40, 41, 42, 43,
                    44, 45, 2, 46, 3, 47, 48, 49, 2, 50, 51, 52, 53, 54, 55, 56, 57, 58, 2,
                    59, 2, 60, 4, 4, 61, 62, 2, 63, 64, 65, 66, 67, 4, 4, 3, 4, 68, 69, 70,
                    71, 72, 73, 74, 75, 76, 64, 4, 4, 4, 77, 78, 79, 80, 4, 81, 82, 83, 4, 4,
                    4, 4, 84, 85, 86, 87, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 88, 4,
                    2, 89, 2, 2, 2, 90, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 91, 92,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 93, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 67, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 64, 96, 74, 97, 19, 98, 99, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 35, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 112, 4, 4, 4, 4, 4, 4, 4, 4, 113, 67, 4, 4, 4, 4, 4, 4, 4,
                    114, 115, 4, 4, 116, 4, 4, 4, 4, 4, 4, 2, 117, 118, 119, 120, 121, 2, 2,
                    2, 2, 122, 123, 124, 125, 126, 127, 4, 4, 4, 4, 4, 4, 4, 4, 128, 129, 130,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 131, 4, 4, 4, 132, 133,
                    134, 4, 135, 136, 4, 4, 4, 4, 137, 95, 4, 4, 4, 4, 4, 4, 4, 138, 4, 4, 4,
                    139, 4, 4, 4, 4, 4, 4, 4, 140, 2, 2, 2, 141, 2, 142, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 143, 144, 145, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 112, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 146, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 95, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    147, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 148, 2, 2, 2, 2, 2, 2, 2, 2, 2, 149, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 149, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 150, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 93, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2,
                    93, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0x2000000000000000, 0xFFFFFFFF1FFFFFFF, 0x10001FFFF,
                    0xFFFFE000FFFFFFFF, 0x7FFFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F,
                    0xFFFF03FF3FFFFFFF, 0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF,
                    0xF7FF000FFFFFFFFF, 0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF,
                    0xFF003FFFFF, 0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF,
                    0x7FFFFFFF, 0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF,
                    0x873FFFFFFEEFF06F, 0x1FFFFFFF00000000, 0x1FFFFFFF, 0x7FFFFFFEFF,
                    0x3FFFFFFFFFFFFF, 0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF,
                    0x3FF00FFFFFFFFFF, 0xFFFFBE3FFFFFFFFF, 0x3F, 0x31BFFFFFFFFFF,
                    0xF00000000000001C, 0xFFFF00801FFFFFFF, 0xFFFF00000001FFFF,
                    0xFFFF00000000003F, 0x7FFFFF0000001F, 0x803FFFC00000007F,
                    0x3FF01FFFFFF0004, 0xFFDFFFFFFFFFFFFF, 0x4FFFFFFFFF00F0, 0x17FFDE1F,
                    0xC0FFFFFFFFFBFFFF, 0x3, 0xFFFF01FFBFFFBD7F, 0x3FF07FFFFFFFFFF,
                    0xFBEDFDFFFFF99FEF, 0x1F1FCFE081399F, 0xFFBFFFFFFFFF4BFF, 0x6000FF7A5,
                    0x3C3FF07FF, 0x3FF00BF, 0xFF3FFFFFFFFFFFFF, 0x3F000001, 0x3FF0011,
                    0x1FFFFFFFFFFFFFF, 0xFFFFF03FF, 0x3FF0FFFE7FFFFFF, 0x7F,
                    0xFFFFFFFF00000000, 0x800003FFFFFFFFFF, 0xF9BFFFFFFF6FF27F, 0x3FF000F,
                    0xFFFFFCFF00000000, 0x1BFCFFFFFF, 0x7FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0080,
                    0xFFFF000023FFFFFF, 0x3FF0001FFFFFFFF, 0xFF7FFFFFFFFFFDFF,
                    0xFFFC000003FF0001, 0x7FFEFFFFFCFFFF, 0xB47FFFFFFFFFFB7F,
                    0xFFFFFDBF03FF00FF, 0x3FF01FB7FFF, 0x7FFFFF00000000, 0xC7FFFFFFFFFDFFFF,
                    0x7FF0007, 0x1000000000000, 0x3FFFFFF, 0x7FFFFFFFFFFF, 0xF,
                    0xFFFFFFFFFFFF0000, 0x1FFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0xFFFFFFFF003FFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF03FF7FFFFFFF, 0x1F3FFFFFFF03FF,
                    0xE0FFFFF803FF000F, 0xFFFF, 0x3FF1FFFFFFFFFFF, 0xFFFFFFFFFFFF87FF,
                    0xFFFF80FF, 0x3001B00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                    0x6FEF000000000000, 0x40007FFFFFFFF, 0xFFFF00F000270000,
                    0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x63FF01FF, 0x3FF000000000000,
                    0xFFFF3FFFFFFFFFFF, 0xF807E3E000000000, 0x3C0000000FE7, 0x1C,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFFFFFFFFFFFFCFF7, 0xF87FFFFFFFFFFFFF,
                    0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7E07FFFFFFF, 0xFFFF07DBF9FFFF7F,
                    0x3FFFFFFFFFFF, 0x8000, 0x3FFF1FFFFFFFFFFF, 0x43FF, 0x7FFFFFFF0000,
                    0x3FFFFFFFFFF0000, 0x7FFFFFFFFFF0000, 0x7FFF6F7F00000000, 0x7F001F,
                    0x3FF0FFF, 0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF,
                    0xFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const XID_START: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3, 0, 0xB8DF000000000000,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF027FFFFF, 0x1FF, 0x787FFFFFF0000,
                    0xFFFFFFFF00000000, 0xFFFEC000000007FF, 0xFFFFFFFFFFFFFFFF,
                    0x9C00C060002FFFFF, 0xFFFFFFFD0000, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF,
                    0x43007FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 35, 35,
                    35, 35, 36, 37, 38, 39, 40, 41, 42, 43, 35, 35, 35, 35, 35, 35, 35, 35,
                    44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 3, 58, 59, 60, 30,
                    61, 62, 63, 64, 65, 66, 67, 68, 35, 35, 35, 30, 35, 35, 35, 35, 69, 70,
                    71, 72, 30, 73, 74, 30, 75, 76, 77, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 78,
                    79, 80, 81, 82, 30, 30, 30, 30, 30, 30, 30, 30, 83, 43, 84, 85, 86, 35,
                    87, 88, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 30, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 89, 90, 35, 35, 35, 35, 91, 92,
                    93, 94, 95, 35, 96, 97, 98, 49, 99, 100, 101, 102, 103, 104, 105, 106,
                    107, 108, 109, 110, 35, 111, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 112, 113, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 114, 35, 115, 116,
                    117, 118, 119, 35, 120, 35, 35, 121, 122, 123, 124, 30, 125, 35, 126, 127,
                    128, 129, 130,
                ],
                tree2_level2: &[
                    0x110043FFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00007EFF, 0x3FF,
                    0x23FFFFFFFFFFFFF0, 0xFFFE0003FF010000, 0x23C5FDFFFFF99FE1,
                    0x10030003B0004000, 0x36DFDFFFFF987E0, 0x1C00005E000000,
                    0x23EDFDFFFFFBBFE0, 0x200000300010000, 0x23EDFDFFFFF99FE0,
                    0x20003B0000000, 0x3FFC718D63DC7E8, 0x10000, 0x23FFFDFFFFFDDFE0,
                    0x327000000, 0x23EFFDFFFFFDDFE1, 0x6000360000000, 0x27FFFFFFFFFDDFF0,
                    0xFC00000380704000, 0x2FFBFFFFFC7FFFE0, 0x7F, 0x5FFFFFFFFFFFE,
                    0x2005FFAFFFFFF7D6, 0xF000005F, 0x1, 0x1FFFFFFFFEFF, 0x1F00, 0,
                    0x800007FFFFFFFFFF, 0xFFE1C0623C3F0000, 0xFFFFFFFF00004003,
                    0xF7FFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF,
                    0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x7FFFFFF,
                    0xFFFFFFFF0000FFFF, 0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FFC7FFFFFFFFFF,
                    0x3FFFF8003FFFF, 0x1DFFF0003FFFF, 0xFFFFFFFFFFFFF, 0x10800000,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFFF, 0xFFFF05FFFFFFFFFF,
                    0x3FFFFFFFFFFFFF, 0x7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF,
                    0xFFFFFFFF007FFFFF, 0x1FFFFF, 0x8000000000, 0xFFFFFFFFFFFE0, 0x1FE0,
                    0xFC00C001FFFFFFF8, 0x3FFFFFFFFF, 0xFFFFFFFFF, 0x3FFFFFFFFC00E000,
                    0xE7FFFFFFFFFF07FF, 0x46FDE0000000000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF3FFFD503F2FFC84, 0xFFFFFFFF000043E0,
                    0x1FF, 0xC781FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x80FFFFFFFFFF,
                    0x7F7F7F7F007FFFFF, 0x7F7F7F7F, 0x1F3E03FE000000E0, 0xFFFFFFFEE07FFFFF,
                    0xF7FFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xC00FFFF1FFF,
                    0x80007FFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFFFFFFFFFFFF,
                    0xFFFFFFFCFF800000, 0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x7FFFFF7BB,
                    0xFFFFFFFFFFFFC, 0x68FC000000000000, 0xFFFF003FFFFFFC00,
                    0x1FFFFFFF0000007F, 0x7FFFFFFFFFFF0, 0x7C00FFDF00008000, 0x1FFFFFFFFFF,
                    0xC47FFFFF00000FF7, 0x3E62FFFFFFFFFFFF, 0x1C07FF38000005,
                    0xFFFF7F7F007E7E7E, 0xFFFF03FFF7FFFFFF, 0x7FFFFFFFF, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFA0F8007F,
                    0xFFFFFFFFFFFFFFDB, 0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000,
                    0xFFFFFFF03FFFFFFF, 0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000,
                    0xFFFFFFFFFFFCFFFF, 0x3FF0000000000FF, 0xAA8A000000000000,
                    0x1FFFFFFFFFFFFFFF, 0x7FFFFFE00000000, 0xFFFFFFC007FFFFFE,
                    0x7FFFFFFF3FFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 5, 11, 12, 5, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 13, 14, 15, 7, 16, 17, 7, 18, 19, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15,
                    16, 17, 2, 2, 2, 2, 18, 19, 20, 4, 21, 22, 23, 24, 25, 4, 26, 4, 27, 28,
                    29, 30, 31, 32, 33, 4, 2, 34, 35, 35, 36, 37, 38, 4, 4, 4, 39, 40, 41, 42,
                    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 23, 56, 57, 58, 59, 5,
                    60, 61, 62, 4, 4, 63, 64, 61, 65, 66, 4, 67, 68, 4, 4, 69, 4, 70, 71, 72,
                    73, 74, 75, 76, 77, 78, 79, 4, 4, 4, 80, 81, 82, 83, 4, 84, 85, 86, 4, 4,
                    4, 4, 87, 88, 4, 89, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 4,
                    2, 63, 2, 2, 2, 91, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 92, 93,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 61, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 68, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 79, 96, 97, 98, 61, 99, 83, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 34, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 112, 113, 114,
                    115, 116, 2, 2, 2, 2, 117, 118, 119, 120, 121, 122, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 123, 4, 4,
                    4, 124, 125, 4, 4, 126, 127, 4, 4, 4, 4, 98, 69, 4, 4, 4, 4, 4, 4, 4, 128,
                    4, 4, 4, 129, 4, 4, 4, 4, 4, 4, 4, 130, 2, 2, 2, 131, 2, 132, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 133, 134, 135, 4, 4, 4, 4, 4, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 136, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 137, 2, 2, 2, 10, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 138, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 139, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2,
                    95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 140, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 61, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0x1FFFFFFFFFFFFF, 0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF,
                    0x3FFFFFFFFF07FF, 0xFFFFFFFF3FFFFFFF, 0x3EFF0F, 0xFFFF00003FFFFFFF,
                    0xFFFFFFFFF0FFFFF, 0xFFFF00FFFFFFFFFF, 0xF7FF000FFFFFFFFF,
                    0x1BFBFFFBFFB7F7FF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                    0x7FDFFFFFFFFFFBF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF,
                    0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEF0001,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF, 0xFFFFFFFFF,
                    0xFFFF803FFFFFFC00, 0x3F, 0x303FFFFFFFFFF, 0x1C, 0xFFFF00801FFFFFFF,
                    0xFFFF00000000003F, 0xFFFF000000000003, 0x7FFFFF0000001F,
                    0xFFFFFFFFFFFFF8, 0x26000000000000, 0xFFFFFFFFFFF8, 0x1FFFFFF0000,
                    0x7FFFFFFFF8, 0x47FFFFFFFF0090, 0x7FFFFFFFFFFF8, 0x1400001E,
                    0x80000FFFFFFBFFFF, 0x1, 0xFFFF01FFBFFFBD7F, 0x23EDFDFFFFF99FE0,
                    0x3E0010000, 0xBFFFFFFFFF4BFF, 0xA0000, 0x380000780, 0xFFFFFFFFFFFF, 0xB0,
                    0x7FFFFFFFFFFF, 0xF000000, 0x10, 0x10007FFFFFFFFFF, 0x7FFFFFF, 0x7F,
                    0xFFFFFFFFFFF, 0xFFFFFFFF00000000, 0x80000000FFFFFFFF, 0x8000FFFFFF6FF27F,
                    0x2, 0xFFFFFCFF00000000, 0xA0001FFFF, 0x407FFFFFFFFF801,
                    0xFFFFFFFFF0010000, 0xFFFF0000200003FF, 0x1FFFFFFFFFFFFFF, 0x1FFFFFFFF,
                    0x7FFFFFFFFDFF, 0xFFFC000000000001, 0xFFFF, 0x1FFFFFFFFFB7F,
                    0xFFFFFDBF00000040, 0x10003FF, 0x7FFFF00000000, 0xFFFFFFFFDFFF4,
                    0x1000000000000, 0x3FFFFFF, 0xF, 0xFFFFFFFFFFFF0000, 0x1FFFFFFFFFFFF,
                    0xFFFFFFFF0000007E, 0x3FFFFFFF, 0xFFFF00007FFFFFFF, 0x7FFFFFFFFFFFFFFF,
                    0x3FFFFFFF0000, 0xE0FFFFF80000000F, 0x1FFFFFFFFFFF, 0x107FF, 0xFFF80000,
                    0xB00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF, 0x6FEF000000000000,
                    0x40007FFFFFFFF, 0xFFFF00F000270000, 0xFFFFFFFFFFFFFFF,
                    0x1FFF07FFFFFFFFFF, 0x3FF01FF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF,
                    0xFFFF7FFFFFFF7FFF, 0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFFFF,
                    0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x3F801FFFFFFFFFFF, 0x4000,
                    0xFFFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F, 0x80F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };
            }
            static BINARY_PROPERTY_NAMES = [
                // ASCII_HEX_DIGIT, // let this one be stripped out -- the full trie is wasteful for ASCII
                ALPHABETIC, BIDI_CONTROL, CASE_IGNORABLE, CASED, CHANGES_WHEN_CASEFOLDED,
                CHANGES_WHEN_CASEMAPPED, CHANGES_WHEN_LOWERCASED, CHANGES_WHEN_TITLECASED,
                CHANGES_WHEN_UPPERCASED, DASH, DEFAULT_IGNORABLE_CODE_POINT, DEPRECATED, DIACRITIC,
                EMOJI, EMOJI_COMPONENT, EMOJI_MODIFIER, EMOJI_MODIFIER_BASE, EMOJI_PRESENTATION, EXTENDED_PICTOGRAPHIC,
                EXTENDER, GRAPHEME_BASE, GRAPHEME_EXTEND, GRAPHEME_LINK, HEX_DIGIT, HYPHEN,
                IDS_BINARY_OPERATOR, IDS_TRINARY_OPERATOR, ID_CONTINUE, ID_START, IDEOGRAPHIC, JOIN_CONTROL,
                LOGICAL_ORDER_EXCEPTION, LOWERCASE, MATH, NONCHARACTER_CODE_POINT, OTHER_ALPHABETIC,
                OTHER_DEFAULT_IGNORABLE_CODE_POINT, OTHER_GRAPHEME_EXTEND, OTHER_ID_CONTINUE,
                OTHER_ID_START, OTHER_LOWERCASE, OTHER_MATH, OTHER_UPPERCASE, PATTERN_SYNTAX,
                PATTERN_WHITE_SPACE, PREPENDED_CONCATENATION_MARK, QUOTATION_MARK, RADICAL,
                REGIONAL_INDICATOR, SENTENCE_TERMINAL, SOFT_DOTTED, TERMINAL_PUNCTUATION, UNIFIED_IDEOGRAPH,
                UPPERCASE, VARIATION_SELECTOR, WHITE_SPACE, XID_CONTINUE, XID_START,
            ];
        }

        char_property_functions! {
            mod category
            {
                // DO NOT EDIT THIS FILE. IT WAS AUTOMATICALLY GENERATED BY:
                //
                //   ucd-generate general-category --trie-set ./target/ucd/
                //
                // Unicode version: 16.0.0.
                //
                // ucd-generate 0.3.1 is available on crates.io.

                pub const BY_NAME: &'static [(&'static str, &'static ::ucd_trie::TrieSet)] = &[
                ("Cased_Letter", CASED_LETTER), ("Close_Punctuation", CLOSE_PUNCTUATION),
                ("Connector_Punctuation", CONNECTOR_PUNCTUATION), ("Control", CONTROL),
                ("Currency_Symbol", CURRENCY_SYMBOL),
                ("Dash_Punctuation", DASH_PUNCTUATION), ("Decimal_Number", DECIMAL_NUMBER),
                ("Enclosing_Mark", ENCLOSING_MARK),
                ("Final_Punctuation", FINAL_PUNCTUATION), ("Format", FORMAT),
                ("Initial_Punctuation", INITIAL_PUNCTUATION), ("Letter", LETTER),
                ("Letter_Number", LETTER_NUMBER), ("Line_Separator", LINE_SEPARATOR),
                ("Lowercase_Letter", LOWERCASE_LETTER), ("Mark", MARK),
                ("Math_Symbol", MATH_SYMBOL), ("Modifier_Letter", MODIFIER_LETTER),
                ("Modifier_Symbol", MODIFIER_SYMBOL), ("Nonspacing_Mark", NONSPACING_MARK),
                ("Number", NUMBER), ("Open_Punctuation", OPEN_PUNCTUATION),
                ("Other", OTHER), ("Other_Letter", OTHER_LETTER),
                ("Other_Number", OTHER_NUMBER), ("Other_Punctuation", OTHER_PUNCTUATION),
                ("Other_Symbol", OTHER_SYMBOL),
                ("Paragraph_Separator", PARAGRAPH_SEPARATOR), ("Private_Use", PRIVATE_USE),
                ("Punctuation", PUNCTUATION), ("Separator", SEPARATOR),
                ("Space_Separator", SPACE_SEPARATOR), ("Spacing_Mark", SPACING_MARK),
                ("Surrogate", SURROGATE), ("Symbol", SYMBOL),
                ("Titlecase_Letter", TITLECASE_LETTER), ("Unassigned", UNASSIGNED),
                ("Uppercase_Letter", UPPERCASE_LETTER),
                ];

                pub const CASED_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x20000000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xF7FFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFF0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFEFFFFF, 0, 0, 0xB8CF000000000000, 0xFFFFFFFBFFFFD740,
                    0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFFF,
                    0xFFFFFFFF007FFFFF, 0x1FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 6, 7, 0, 8, 8, 8, 8, 9, 10, 11, 12, 0, 0, 0,
                    0, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 16, 8,
                    17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 20, 0, 21, 22, 23, 24, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 25, 26, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 29, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xE7FFFFFFFFFF20BF, 0x3F3FFFFFFFFFFFFF,
                    0xE7FFFFFFFFFF07FF, 0xFFFFFFFFFFF, 0xFEFFF80000000000, 0x7FFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3F3FFFFF, 0x3FFFFFFFAAFF3F3F,
                    0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC, 0xF21FBD503E2FFC84, 0x43E0, 0x18,
                    0xCFFFFFFFFFFFFFFF, 0xC781FFFFFFFFF, 0x20BFFFFFFFFF, 0x3FFFFFFFFFFF,
                    0xFFFFFFF, 0xFFFFFFFC00000000, 0xFFFEFFFFFFFFFFFF, 0xFFFFFFFFFFFF78FF,
                    0x46000001FEB3FFF, 0xFFFF000000000000, 0xFFFF01FF07FFFFFF, 0xF8007F,
                    0x7FFFFFE00000000, 0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 5, 6, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    7, 7, 0, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,
                    11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    12, 13, 14, 15, 16, 1, 1, 1, 1, 17, 18, 19, 20, 21, 22, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF, 0xFFFF000000000000, 0xFFFFFFFFF0FFFFF,
                    0xF7FF000000000000, 0x1BFBFFFBFFB7F7FF, 0x7FFFFFFFFFFFF,
                    0xFFFF003FFFFF0000, 0x3F, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF,
                    0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF,
                    0xF7FFFFFFF7FFFFFD, 0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF,
                    0xFFFFFDFFFFFFFDFF, 0xFF7, 0x7E07FFFFBFF, 0xF,
                ],
                };

                pub const CLOSE_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x20000000000, 0x2000000020000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 7, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 10, 11, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 14, 15, 0, 0, 16, 17, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2800000000000000, 0x10000000, 0x4000000000000040, 0x4000,
                    0x40000000A00, 0x2AAA0000000000, 0xAA8000000040, 0x1555550,
                    0x200000000A000000, 0x2A800000000, 0x15400000, 0xCAA2AA00,
                    0x4000000000000000, 0x5540000001000000, 0x54000115, 0x2000000000000200,
                    0x920000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CONNECTOR_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x80000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 0, 0, 1, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x8000000000000000, 0x100001, 0x18000000000000, 0xE000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CONTROL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFFFFFFFF, 0x8000000000000000, 0xFFFFFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CURRENCY_SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x1000000000, 0, 0x3C00000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0x8000, 0, 0x800, 0, 0, 0, 0, 0, 0, 0xC000000000000000,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 10, 0, 0, 11, 0, 0, 12,
                ],
                tree2_level2: &[
                    0, 0x80C000000000000, 0x2000000000000, 0x200000000000000,
                    0x8000000000000000, 0x8000000, 0xFFFFFFFF00000000, 0x1, 0x100000000000000,
                    0x1000000000000000, 0x20000000000, 0x10, 0x6300000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1E0000000, 0x8000000000000000, 0x1000000000000,
                ],
                };

                pub const DASH_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0x4000000000000400, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 4, 5, 0, 0, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 10, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x40, 0x3F0000, 0xC00000004800000, 0x20000001, 0x1000010000000,
                    0x100000000, 0x6000000000000, 0x801000000, 0x2000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x400000000000, 0x200000000000,
                ],
                };

                pub const DECIMAL_NUMBER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0x3FF00000000, 0, 0x3FF000000000000, 0, 0, 0, 0x3FF,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
                    2, 0, 2, 3, 0, 0, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0, 0, 5, 0, 2, 0, 0, 6,
                    0, 0, 2, 7, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0, 8, 0, 2,
                    0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFC000000000, 0x3FF0000, 0x3FF00000000, 0x3FF, 0xFFC0, 0x3FF03FF,
                    0x3FF000000000000, 0x3FF000003FF0000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 4, 5, 6, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 5, 0, 0, 6, 0, 0, 0,
                    2, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 6, 0, 7, 2, 0, 0, 0, 0, 0, 0, 1,
                    0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 6, 1, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
                    0, 0, 0, 2, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF00000000, 0x3FF000000000000, 0x3FF, 0xFFC000000000,
                    0xFFC0000000000000, 0x3FF0000, 0xFFFFF03FF, 0xFFFFFFFFFFFFC000,
                    0x7FE000000000000,
                ],
                };

                pub const ENCLOSING_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x300, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x4000000000000000, 0x1DE0000000, 0x7000000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const FINAL_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x800000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x400000022000000, 0x220002428,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const FORMAT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x200000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0x1000003F, 0, 0, 0x20000000, 0x8000, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 7,
                ],
                tree2_level2: &[
                    0, 0x30000, 0x400000000, 0x4000, 0x7C000000F800, 0xFFDF00000000,
                    0x8000000000000000, 0xE00000000000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x2000, 0xFFFF000000000000, 0xF00000000,
                    0x7F8000000000000, 0xFFFFFFFF00000002, 0xFFFFFFFFFFFFFFFF,
                ],
                };

                pub const INITIAL_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x80000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x200000099000000, 0x110001214,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x420040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x501F0003FFC3, 0, 0xBCDF000000000000,
                    0xFFFFFFFBFFFFD740, 0xFFBFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFC03, 0xFFFFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFFF, 0xFFFFFFFF027FFFFF, 0x1FF, 0x787FFFFFF0000,
                    0xFFFFFFFF00000000, 0xFFFEC000000007FF, 0xFFFFFFFFFFFFFFFF,
                    0x9C00C060002FFFFF, 0xFFFFFFFD0000, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF,
                    0x43007FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 35, 35,
                    35, 35, 36, 37, 38, 39, 40, 41, 42, 43, 35, 35, 35, 35, 35, 35, 35, 35,
                    44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 3, 58, 59, 60, 30,
                    61, 62, 63, 64, 65, 66, 67, 68, 35, 35, 35, 30, 35, 35, 35, 35, 69, 70,
                    71, 72, 30, 73, 74, 30, 75, 76, 77, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 78,
                    79, 80, 81, 82, 83, 30, 30, 30, 30, 30, 30, 30, 84, 43, 85, 86, 87, 35,
                    88, 89, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 30, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 90, 91, 35, 35, 35, 35, 92, 93,
                    94, 64, 95, 35, 96, 97, 98, 49, 99, 100, 101, 102, 103, 104, 105, 106,
                    107, 108, 109, 110, 35, 111, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 112, 113, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 114, 35, 115, 116,
                    117, 118, 119, 35, 35, 35, 35, 120, 121, 122, 123, 30, 124, 35, 125, 126,
                    127, 128, 129,
                ],
                tree2_level2: &[
                    0x110043FFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00007EFF, 0x3FF,
                    0x23FFFFFFFFFFFFF0, 0xFFFE0003FF010000, 0x23C5FDFFFFF99FE1,
                    0x10030003B0004000, 0x36DFDFFFFF987E0, 0x1C00005E000000,
                    0x23EDFDFFFFFBBFE0, 0x200000300010000, 0x23EDFDFFFFF99FE0,
                    0x20003B0000000, 0x3FFC718D63DC7E8, 0x10000, 0x23FFFDFFFFFDDFE0,
                    0x327000000, 0x23EFFDFFFFFDDFE1, 0x6000360000000, 0x27FFFFFFFFFDDFF0,
                    0xFC00000380704000, 0x2FFBFFFFFC7FFFE0, 0x7F, 0xDFFFFFFFFFFFE,
                    0x200DFFAFFFFFF7D6, 0xF000005F, 0x1, 0x1FFFFFFFFEFF, 0x1F00, 0,
                    0x800007FFFFFFFFFF, 0xFFE1C0623C3F0000, 0xFFFFFFFF00004003,
                    0xF7FFFFFFFFFF20BF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF,
                    0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x7FFFFFF,
                    0xFFFFFFFF0000FFFF, 0x3F3FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FE07FFFFFFFFFF,
                    0x3FFFF8003FFFF, 0x1DFFF0003FFFF, 0xFFFFFFFFFFFFF, 0x10800000,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFFF, 0xFFFF05FFFFFFFF9F,
                    0x3FFFFFFFFFFFFF, 0x7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF,
                    0xFFFFFFFF007FFFFF, 0x1FFFFF, 0x8000000000, 0xFFFFFFFFFFFE0, 0x1FE0,
                    0xFC00C001FFFFFFF8, 0x3FFFFFFFFF, 0xFFFFFFFFF, 0x3FFFFFFFFC00E000,
                    0xE7FFFFFFFFFF07FF, 0x46FDE0000000000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0x5FDFFFFFFFFFFFFF, 0x1FDC1FFF0FCF1FDC,
                    0x8002000000000000, 0x1FFF0000, 0xF3FFBD503E2FFC84, 0x43E0, 0x18,
                    0xC781FFFFFFFFF, 0xFFFF20BFFFFFFFFF, 0x80FFFFFFFFFF, 0x7F7F7F7F007FFFFF,
                    0x7F7F7F7F, 0x800000000000, 0x183E000000000060, 0xFFFFFFFEE07FFFFF,
                    0xF7FFFFFFFFFFFFFF, 0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF,
                    0xFFFF000000000000, 0x1FFF, 0x3FFFFFFFFFFF0000, 0xC00FFFF1FFF,
                    0x80007FFFFFFFFFFF, 0xFFFFFFFF3FFFFFFF, 0xFFFFFFFCFF800000,
                    0xFFFFFFFFFFFFF9FF, 0xFFFC00001FEB3FFF, 0x7FFFFF7BB, 0xFFFFFFFFFFFFC,
                    0x68FC000000000000, 0xFFFF003FFFFFFC00, 0x1FFFFFFF0000007F,
                    0x7FFFFFFFFFFF0, 0x7C00FFDF00008000, 0x1FFFFFFFFFF, 0xC47FFFFF00000FF7,
                    0x3E62FFFFFFFFFFFF, 0x1C07FF38000005, 0xFFFF7F7F007E7E7E,
                    0xFFFF03FFF7FFFFFF, 0x7FFFFFFFF, 0xFFFF000FFFFFFFFF, 0xFFFFFFFFFFFF87F,
                    0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFA0F8007F, 0xFFFFFFFFFFFFFFDB,
                    0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000, 0x3FFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFCFFFF, 0xFFF0000000000FF,
                    0xFFDF000000000000, 0x1FFFFFFFFFFFFFFF, 0x7FFFFFE00000000,
                    0xFFFFFFC007FFFFFE, 0x7FFFFFFFFFFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 5, 11, 12, 5, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 13, 14, 15, 7, 16, 17, 7, 18, 19, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 2, 2, 11, 12, 13, 14, 15,
                    16, 2, 2, 2, 2, 17, 18, 19, 4, 20, 21, 22, 23, 24, 4, 25, 4, 26, 27, 28,
                    29, 30, 31, 32, 4, 2, 33, 34, 34, 35, 36, 37, 4, 4, 4, 38, 39, 40, 41, 42,
                    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 22, 55, 56, 57, 58, 59,
                    60, 61, 62, 4, 4, 63, 64, 61, 65, 66, 4, 67, 68, 4, 4, 69, 4, 70, 71, 72,
                    73, 74, 75, 76, 77, 78, 79, 4, 4, 4, 80, 81, 82, 83, 4, 84, 85, 86, 4, 4,
                    4, 4, 87, 88, 4, 89, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 4,
                    4, 4, 2, 2, 2, 91, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 92, 93,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 61, 94, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 68, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 79, 96, 97, 98, 61, 99, 83, 4, 4, 4, 4, 4,
                    4, 100, 4, 4, 4, 2, 4, 4, 2, 101, 102, 103, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 105, 33, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 2, 107, 108, 2, 2, 2, 2, 2, 109, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 110, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 112, 113, 114,
                    115, 116, 2, 2, 2, 2, 117, 118, 119, 120, 121, 122, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 123, 4, 4,
                    4, 124, 125, 4, 4, 126, 127, 4, 4, 4, 4, 98, 69, 4, 4, 4, 4, 4, 4, 4, 128,
                    4, 4, 4, 129, 4, 4, 4, 4, 4, 4, 4, 130, 2, 2, 2, 131, 2, 132, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 133, 134, 135, 4, 4, 4, 4, 4, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 136, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 137, 2, 2, 2, 9, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 138, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 139, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2,
                    95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 140, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 61, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF, 0x3FFFFFFFFF03FD,
                    0xFFFFFFFF3FFFFFFF, 0xFF0F, 0xFFFF00003FFFFFFF, 0xFFFFFFFFF0FFFFF,
                    0xFFFF00FFFFFFFFFF, 0xF7FF000FFFFFFFFF, 0x1BFBFFFBFFB7F7FF,
                    0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF, 0x7FDFFFFFFFFFFBF,
                    0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF, 0x37FFFF00000000,
                    0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEF0001,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0x7FFFFFFFFFFFF, 0xFFFFFFFFF,
                    0xFFFF803FFFFFFC00, 0x3F, 0x303FFFFFFFFFF, 0x1C, 0xFFFF00801FFFFFFF,
                    0xFFFF00000000003F, 0xFFFF000000000003, 0x7FFFFF0000001F,
                    0xFFFFFFFFFFFFF8, 0x26000000000000, 0xFFFFFFFFFFF8, 0x1FFFFFF0000,
                    0x7FFFFFFFF8, 0x47FFFFFFFF0090, 0x7FFFFFFFFFFF8, 0x1400001E,
                    0x80000FFFFFFBFFFF, 0x1, 0xFFFF01FFBFFFBD7F, 0x23EDFDFFFFF99FE0,
                    0x3E0010000, 0xBFFFFFFFFF4BFF, 0xA0000, 0x1FFFFFFFFFFFFF, 0x380000780,
                    0xFFFFFFFFFFFF, 0xB0, 0x7FFFFFFFFFFF, 0xF000000, 0x10, 0x10007FFFFFFFFFF,
                    0x7FFFFFF, 0x7F, 0xFFFFFFFFFFF, 0xFFFFFFFF00000000, 0x80000000FFFFFFFF,
                    0x8000FFFFFF6FF27F, 0x2, 0xFFFFFCFF00000000, 0xA0001FFFF,
                    0x407FFFFFFFFF801, 0xFFFFFFFFF0010000, 0xFFFF0000200003FF,
                    0x1FFFFFFFFFFFFFF, 0x1FFFFFFFF, 0x7FFFFFFFFDFF, 0xFFFC000000000001,
                    0xFFFF, 0x1FFFFFFFFFB7F, 0xFFFFFDBF00000040, 0x10003FF, 0x7FFFF00000000,
                    0xFFFFFFFFDFFF4, 0x1000000000000, 0x3FFFFFF, 0xF, 0xFFFFFFFFFFFF0000,
                    0x1FFFFFFFFFFFF, 0xFFFFFFFF0000007E, 0x3FFFFFFF, 0xFFFF00007FFFFFFF,
                    0x7FFFFFFFFFFFFFFF, 0x3FFFFFFF0000, 0xE0FFFFF80000000F, 0x1FFFFFFFFFFF,
                    0x107FF, 0xFFF80000, 0xB00000000, 0xFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                    0x6FEF000000000000, 0x40007FFFFFFFF, 0xFFFF00F000270000,
                    0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x3FF01FF, 0xFFFFFFFFFFDFFFFF,
                    0xEBFFDE64DFFFFFFF, 0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF,
                    0xFFFFFFFFFFFDFC5F, 0xFFFFFF3FFFFFFFFF, 0xF7FFFFFFF7FFFFFD,
                    0xFFDFFFFFFFDFFFFF, 0xFFFF7FFFFFFF7FFF, 0xFFFFFDFFFFFFFDFF, 0xFF7,
                    0x7E07FFFFFFF, 0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x3F801FFFFFFFFFFF,
                    0x4000, 0xFFFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F, 0x80F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const LETTER_NUMBER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1C00000000000, 0xFFFFFFFF00000000, 0x1E7, 0x70003FE00000080,
                    0xFFC000000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFFFFFFFFFF, 0x402, 0x3E0000, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFF,
                ],
                };

                pub const LINE_SEPARATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x10000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LOWERCASE_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE00000000, 0x20000000000000, 0xFF7FFFFF80000000,
                    0x55AAAAAAAAAAAAAA, 0xD4AAAAAAAAAAAB55, 0xE6512D2A4E243129,
                    0xAA29AAAAB5555240, 0x93FAAAAAAAAAAAAA, 0xFFFFFFFFFFFFAA85,
                    0xFFFFFFEFFFFF, 0, 0, 0x388A000000000000, 0xFFFFF00000010000,
                    0x192FAAAAAAE37FFF, 0xFFFF000000000000, 0xAAAAAAAAFFFFFFFF,
                    0xAAAAAAAAAAAAA802, 0xAAAAAAAAAAAAD554, 0xAAAAAAAAAAAA,
                    0xFFFFFFFF00000000, 0x1FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 5, 6, 0, 7, 7, 8, 7, 9, 10, 11, 12, 0, 0, 0,
                    0, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17, 7,
                    18, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 0, 22, 23, 24, 25, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 16, 26, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xE7FFFFFFFFFF0000, 0x3F00000000000000, 0x5FF, 0xFFFFFFFFFFF,
                    0xFEFFF80000000000, 0x7FFFFFF, 0xAAAAAAAAAAAAAAAA, 0xAAAAAAAABFEAAAAA,
                    0xFF00FF003F00FF, 0x3FFF00FF00FF003F, 0x40DF00FF00FF00FF,
                    0xDC00FF00CF00DC, 0x321080000008C400, 0x43C0, 0x10, 0xFFFF000000000000,
                    0xFDA1562FFFFFFFF, 0x8501AAAAAAAAA, 0x20BFFFFFFFFF, 0x2AAAAAAAAAAA,
                    0xAAAAAAA, 0xAAABAAA800000000, 0x95FEAAAAAAAAAAAA, 0xAAA082AAAABA50AA,
                    0x44000000AAA250A, 0xFFFF01FF07FFFFFF, 0xFFFFFFFFFFFFFFFF, 0xF8007F,
                    0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 4, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11,
                    12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFF0000000000, 0xFFFF, 0xFFFFFFFFF000000, 0x1BFBFFFBFF800000,
                    0x7FFFFFFFFFFFF, 0xFFFF000000000000, 0x3F, 0xFFFFFFFF, 0xFFFFFFFF00000000,
                    0xFFFFFFC000000, 0xFFFFDFC000, 0xEBC000000FFFFFFC, 0xFFFFFC000000FFEF,
                    0xFFFFFFC000000F, 0xFFFFFFC0000, 0xFC000000FFFFFFC0, 0xFFFFC000000FFFFF,
                    0xFFFFFFC000000FF, 0xFFFFFFC00000, 0x3FFFFFFC00, 0xF0000003F7FFFFFC,
                    0xFFC000000FDFFFFF, 0xFFFF0000003F7FFF, 0xFFFFFC000000FDFF, 0xBF7,
                    0x7E07FFFFBFF, 0xFFFFFFFC00000000, 0xF,
                ],
                };

                pub const MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0x3F8, 0, 0, 0, 0xBFFFFFFFFFFE0000, 0xB6, 0x7FF0000,
                    0x10000FFFFF800, 0, 0x3D9F9FC00000, 0xFFFF000000020000, 0x7FF,
                    0x1FFC000000000, 0x200FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 6, 8, 6, 9, 6, 10, 11, 12, 13, 14, 6, 15, 16, 17,
                    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 32, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 33, 34, 35, 36, 37, 31, 38, 31, 39, 31, 31, 31, 40, 41, 42, 43,
                    44, 45, 46, 47, 48, 31, 31, 49, 31, 31, 31, 50, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 51, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 52,
                    31, 53, 31, 54, 31, 31, 31, 31, 31, 31, 31, 31, 55, 31, 56, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 57,
                    58, 59, 31, 31, 31, 31, 60, 31, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
                    31, 31, 31, 71, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 72, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 73, 31, 31, 31, 31, 31, 31, 31,
                ],
                tree2_level2: &[
                    0x3EEFFBC00000, 0xE000000, 0xFF800000, 0xFFFFFFFBFFFFFC00,
                    0xDC0000000000000F, 0xC00FEFFFF, 0xD00000000000000E, 0x4000000C0080399F,
                    0x23000000023987, 0xFC00000C00003BBF, 0xC00E0399F, 0xC000000000000004,
                    0x803DC7, 0xD00000000000001F, 0xC00603DDF, 0x8000C00603DDF,
                    0xD80000000000000F, 0xC00803DDF, 0xE, 0xC0000FF5F8400, 0x7F2000000000000,
                    0x7F80, 0x1FF2000000000000, 0x7F00, 0xC2A0000003000000,
                    0xFFFE000000000000, 0x1FFFFFFFFEFFE0DF, 0x40, 0x7FFFF80000000000,
                    0x1E3F9DC3C00000, 0x3C00BFFC, 0, 0xE0000000, 0x1C0000003C0000,
                    0xC0000000C0000, 0xFFF0000000000000, 0x200FFFFF, 0xB800, 0x20000000060,
                    0xFFF0FFF00000000, 0xF800000, 0x9FFFFFFF7FE00000, 0xFFFF000000000000,
                    0x7FFF, 0xFFF000000000001F, 0xFF8000000001F, 0x3FFE00000007,
                    0xFFFC000000000, 0xFFFFF000000000, 0x39021FFFFF70000, 0xFFFFFFFFFFFFFFFF,
                    0x1FFFFFFFF0000, 0x3800000000000, 0x8000000000000000, 0xFFFFFFFF00000000,
                    0xFC0000000000, 0x6000000, 0x3FF7800000000000, 0xC0000000,
                    0x3000000000000, 0x10F800000844, 0xFFF0000000000003, 0x8003FFFF0000003F,
                    0x3FC000000000, 0xFFF80, 0xFFF800000000000F, 0x2000000001,
                    0x7FFE0000000000, 0x3800000000003008, 0xC19D000000000000,
                    0x60F80000000002, 0x37F800000000, 0x40000000, 0xFFFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 2, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0,
                    0, 0, 6, 7, 0, 0, 0, 0, 8, 9, 0, 10, 11, 0, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0, 0, 31, 32, 29, 33,
                    34, 0, 35, 0, 0, 0, 36, 0, 0, 0, 37, 38, 0, 39, 40, 41, 42, 0, 0, 0, 0, 0,
                    43, 0, 44, 0, 45, 46, 47, 0, 0, 0, 0, 48, 49, 50, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 54, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 60, 0, 0, 0, 0, 0, 0, 0,
                    61, 62, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 65, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 68, 0, 54, 0, 0, 0, 0, 0, 69, 70,
                    0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72,
                    0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 74, 74, 74, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x870000000000F06E,
                    0x6000000000, 0xF000000000, 0x3E0000000000, 0x180000000000,
                    0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000007, 0x801900000000007F,
                    0x7FF000000000007, 0x4, 0x1FFF8000000007, 0x8000000000060,
                    0xFFF8000000000007, 0xDE01, 0x40FFF00000000000, 0x2, 0x7FF80000000,
                    0xD80000000000000F, 0x1F1FCC0080399F, 0xFF00000000000000, 0x60005F7A5,
                    0xFFE0000000000000, 0x4000007F, 0xFFFF000000000000, 0xF,
                    0xFF3F800000000000, 0x30000001, 0x1, 0xFFF80000000000, 0xFFFE0000000,
                    0x7FFF00000000000, 0x79BF000000000000, 0xD, 0x11FCFE0000,
                    0x7BF80000000007FE, 0xFFE0080, 0x3FFFC00, 0xFF7F800000000000,
                    0x7FFEFFFFFC0000, 0xB47E000000000000, 0xBF, 0xFB7C00, 0x78000000000000,
                    0xC7F000000000000B, 0x4000007, 0x3FFF81, 0xFFFFC0000000, 0x1F000000000000,
                    0x7F000000000000, 0xFFFFFFFFFFFE8000, 0x780FF, 0x3001000000000,
                    0x60000000, 0xFFFF3FFFFFFFFFFF, 0x7F, 0xF807E3E000000000, 0x3C0000000FE7,
                    0x1C, 0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7DBF9FFFF7F,
                    0x8000, 0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x7F0,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const MATH_SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x7000080000000000, 0x5000000000000000, 0x2100000000000, 0x80000000800000,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x40000000000000, 0, 0, 0, 0, 0, 0, 0, 0,
                    0x1C0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    3, 4, 5, 6, 7, 7, 7, 7, 8, 9, 10, 11, 0, 0, 0, 0, 0, 0, 12, 13, 0, 14, 0,
                    0, 0, 0, 0, 15, 0, 0, 0, 0, 7, 7, 16, 17, 7, 7, 7, 7, 18, 19, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 22, 23, 0, 24,
                ],
                tree2_level2: &[
                    0, 0x1C00000000040010, 0x1C00, 0x1000000, 0x81F, 0x40490C1F0000,
                    0xFFF000000014C000, 0xFFFFFFFFFFFFFFFF, 0x300000000, 0x1000000000000000,
                    0xFFFFFF8000000, 0x3F0000000, 0x80000000000000, 0xFF00000000000002,
                    0x800000000000, 0xFFFF003FFFFFFF9F, 0xFFFFFFFFFE000007,
                    0xCFFFFFFFF0FFFFFF, 0xFFFF000000000000, 0x1F9F, 0x20000000000,
                    0x7400000000, 0x70000800, 0x50000000, 0x1E0400000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 7, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC000, 0x800000008000002, 0x20000000200000, 0x800000008000,
                    0x20000000200, 0x8, 0x3000000000000,
                ],
                };

                pub const MODIFIER_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFF000000000000, 0x501F0003FFC3, 0,
                    0x410000000000000, 0, 0, 0, 0, 0, 0, 0, 0x2000000, 0, 0, 0, 0x1, 0,
                    0x6000000000, 0, 0, 0, 0x430000000000000,
                ],
                tree2_level1: &[
                    0, 1, 1, 2, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    4, 1, 4, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 7, 1, 1, 1, 1, 1, 1, 1, 1, 8,
                    1, 1, 1, 1, 1, 1, 9, 1, 1, 10, 11, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13,
                    14, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15,
                    1, 1, 1, 16, 1, 1, 16, 1, 1, 1, 1, 1, 1, 1, 17, 1, 18, 19, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 21, 22, 23, 1, 24, 25, 26, 27,
                    1, 1, 1, 1, 1, 1, 1, 28, 1, 25, 1, 29, 1, 30, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 25, 31, 1,
                ],
                tree2_level2: &[
                    0x11004000000, 0, 0x200, 0x2000000000000, 0x40, 0x1000000000000000,
                    0x800000, 0x8, 0x8000000000, 0x3F00000000000000, 0xFFFFF00000000000,
                    0x10007FFFFFFFFFF, 0xFFFFFFFFF8000000, 0x8002000000000000, 0x1FFF0000,
                    0x3000000000000000, 0x800000000000, 0x83E000000000020, 0x60000000,
                    0x7000000000000000, 0x200000, 0x1000, 0x8000000000000000, 0x30000000,
                    0xFF800000, 0x1000000000000, 0x100, 0x31C000000000000, 0x4000008000,
                    0x18000020000000, 0x200F0000000, 0xC0000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,
                    0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 7, 8, 9, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FDFFFFFFFFFFBF, 0x800000004000, 0xF, 0x180000000007, 0xFFF80000,
                    0xB00000000, 0x6FEF000000000000, 0xFFFF000000000000, 0x3FFFFFFFFFFF,
                    0x3F80000000000000, 0x80000000000, 0x800,
                ],
                };

                pub const MODIFIER_SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x140000000, 0x110810000000000, 0, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFFAFE0FFFC003C, 0, 0x20000000000000, 0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 0, 12,
                ],
                tree2_level2: &[
                    0, 0x100, 0xA000000000000000, 0x6000E000E000E003, 0x18000000, 0x3007FFFFF,
                    0x600, 0xC0008000000, 0xFFFC000000000000, 0x7, 0x4000000000000000, 0x1,
                    0x800000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF800000000000000,
                ],
                };

                pub const NONSPACING_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0xF8, 0, 0, 0, 0xBFFFFFFFFFFE0000, 0xB6, 0x7FF0000,
                    0x10000FFFFF800, 0, 0x3D9F9FC00000, 0xFFFF000000020000, 0x7FF,
                    0x1FFC000000000, 0x200FF80000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 10, 11, 12, 13, 14, 15, 16, 11, 17, 18,
                    19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 34, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 35, 36, 37, 38, 39, 33, 40, 33, 41, 33, 33, 33, 42, 43, 44,
                    45, 46, 47, 48, 49, 50, 33, 33, 51, 33, 33, 33, 52, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 53, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    54, 33, 55, 33, 56, 33, 33, 33, 33, 33, 33, 33, 33, 57, 33, 58, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    59, 60, 61, 33, 33, 33, 33, 62, 33, 33, 63, 64, 65, 66, 67, 68, 69, 70,
                    71, 33, 33, 33, 72, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 73, 33, 33,
                    33, 33, 33, 33, 33, 33, 33, 33, 33, 74, 33, 33, 33, 33, 33, 33, 33,
                ],
                tree2_level2: &[
                    0x3EEFFBC00000, 0xE000000, 0xFF800000, 0xFFFFFFFBFFFFFC00,
                    0x1400000000000007, 0xC00FE21FE, 0x1000000000000002, 0x4000000C0000201E,
                    0x1000000000000006, 0x23000000023986, 0xFC00000C000021BE,
                    0x9000000000000002, 0xC0060201E, 0x4, 0x2001, 0xD000000000000011,
                    0xC00603DC1, 0xC00003040, 0x1800000000000003, 0xC0000201E, 0x2, 0x5C0400,
                    0x7F2000000000000, 0x7F80, 0x1FF2000000000000, 0x7F00, 0x2A0000003000000,
                    0x7FFE000000000000, 0x1FFFFFFFFEFFE0DF, 0x40, 0x66FDE00000000000,
                    0x1E0001C3000000, 0x20002064, 0, 0xE0000000, 0xC0000001C0000,
                    0xC0000000C0000, 0x3FB0000000000000, 0x200FFE40, 0xB800, 0x20000000060,
                    0xE04018700000000, 0x9800000, 0x9FF81FE57F400000, 0xBFFF000000000000,
                    0x7FFF, 0x17D000000000000F, 0xFF80000000004, 0x3B3C00000003,
                    0x3A34000000000, 0xCFF00000000000, 0x31021FDFFF70000, 0xFFFFFFFFFFFFFFFF,
                    0x1FFE21FFF0000, 0x3800000000000, 0x8000000000000000, 0xFFFFFFFF00000000,
                    0x3C0000000000, 0x6000000, 0x3FF0800000000000, 0xC0000000,
                    0x3000000000000, 0x106000000844, 0x8003FFFF00000030, 0x3FC000000000,
                    0x3FF80, 0x33C8000000000007, 0x2000000000, 0x667E0000000000,
                    0x1000000000001008, 0xC19D000000000000, 0x40300000000002, 0x212000000000,
                    0x40000000, 0xFFFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 2, 2, 4, 2, 2, 2, 2, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0,
                    0, 0, 6, 7, 0, 0, 0, 0, 8, 9, 0, 10, 11, 0, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0, 0, 31, 32, 33, 34,
                    35, 0, 36, 0, 0, 0, 37, 0, 0, 0, 38, 39, 0, 40, 41, 42, 43, 0, 0, 0, 0, 0,
                    44, 0, 45, 0, 46, 47, 48, 0, 0, 0, 0, 49, 50, 51, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 55, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 61, 0, 0, 0, 0, 0, 0, 0,
                    62, 63, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 66, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 56, 0, 55, 0, 0, 0, 0, 0, 69, 70,
                    0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72,
                    0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 74, 74, 74, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x7C0000000000000, 0x870000000000F06E,
                    0x6000000000, 0xF000000000, 0x3E0000000000, 0x180000000000,
                    0xF000000000000000, 0x1FFC0, 0x3C, 0xFF00000000000002, 0x801900000000007F,
                    0x678000000000003, 0x4, 0x1FEF8000000007, 0x8000000000000,
                    0x7FC0000000000003, 0x9E00, 0x40D3800000000000, 0x2, 0x7F880000000,
                    0x1800000000000003, 0x1F1FC000000001, 0xF800000000000000, 0x600054001,
                    0xFF00000000000000, 0x4000005C, 0x85F8000000000000, 0xD,
                    0xB03C000000000000, 0x30000001, 0xA7F8000000000000, 0x1, 0xBF280000000000,
                    0xFBCA0000000, 0x6FF800000000000, 0x5800000000000000, 0x8, 0x10CF00000,
                    0x79F80000000007FE, 0xE7E0080, 0x37FFC00, 0xBF7F000000000000,
                    0x6DFCFFFFFC0000, 0xB47E000000000000, 0xBF, 0xA30000, 0x18000000000000,
                    0x7C0000000000003, 0x4000005, 0x3FFF81, 0xE3FFC0000000, 0x1F000000000000,
                    0x7F000000000000, 0x8000, 0x78000, 0x1000000000, 0x60000000,
                    0xFFFF3FFFFFFFFFFF, 0x7F, 0xF800038000000000, 0x3C0000000FE7, 0x1C,
                    0xF87FFFFFFFFFFFFF, 0x201FFFFFFFFFFF, 0xFFFEF8000010, 0x7DBF9FFFF7F,
                    0x400000000000, 0xF00000000000, 0xC00000000000, 0x7F0000, 0x7F0,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const NUMBER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x3FF000000000000, 0, 0x720C000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x3FF00000000, 0, 0x3FF000000000000, 0,
                    0, 0, 0x3FF,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 1, 0, 2, 0, 1, 0, 1, 0, 3, 0, 4, 0, 5, 0, 1, 0, 6, 0, 1, 0,
                    7, 0, 7, 8, 0, 0, 0, 0, 9, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 12, 7, 0, 0, 0, 0, 13, 0, 14,
                    0, 0, 15, 0, 0, 7, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 17, 9, 0, 0, 18, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 27,
                    0, 28, 29, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 1, 0, 0, 0, 0,
                    31, 0, 0, 7, 9, 0, 0, 32, 0, 7, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,
                    0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFC000000000, 0x3F0FFC000000000, 0xFCFFC000000000, 0x7FFC000000000,
                    0x7F00FFC000000000, 0x1FFFFC07F000000, 0x3FF0000, 0xFFFFF00000000, 0x3FF,
                    0x1FFFFE0000000000, 0x1C00000000000, 0x3FF03FF00000000, 0xFFC0, 0x7FF0000,
                    0x3FF03FF, 0x3FF000000000000, 0x3F1000000000000, 0xFFFFFFFFFFFF0000,
                    0x3E7, 0xFFFFFFFF00000000, 0xFFFFFFF, 0xFFFFFC0000000000,
                    0xFFC0000000000000, 0xFFFFF, 0x2000000000000000, 0x70003FE00000080,
                    0x3C0000, 0x3FF00000000, 0xFFFEFF00, 0xFFFE0000000003FF, 0x3F000000000000,
                    0x3FF000003FF0000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 3, 3, 3, 3, 3, 5, 6, 7, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 4, 5, 6, 0, 7, 0, 0, 8, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 11, 12, 0, 13, 14, 0, 15, 16, 17, 0, 18,
                    19, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 24, 25, 0, 26, 0, 27, 0,
                    21, 28, 0, 0, 29, 0, 0, 0, 21, 0, 0, 0, 0, 0, 30, 0, 30, 0, 0, 0, 0, 0,
                    30, 0, 31, 32, 0, 0, 0, 0, 0, 0, 33, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21,
                    0, 34, 0, 0, 0, 30, 8, 0, 0, 0, 0, 0, 0, 30, 0, 35, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 22, 0, 38, 0, 0, 0, 0, 0,
                    0, 0, 21, 0, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 41, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    22, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 43, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 44, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 46,
                    0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFF80, 0x1FFFFFFFFFFFFFF, 0xC00, 0xFFFFFFE00000000,
                    0xF00000000, 0x402, 0x3E0000, 0x3FF00000000, 0xFE000000FF000000,
                    0xFF8000000000, 0xF800000000000000, 0xFC00000, 0x3000000000000000,
                    0xFFFFFFFFFFFCFFFF, 0x60000000000001FF, 0xE0000000, 0xF80000000000,
                    0xFF000000FF000000, 0xFE0000000000, 0xFC00000000000000, 0x3FF000000000000,
                    0x3FF, 0x7FFFFFFF00000000, 0x7FE0000000, 0x1E0000, 0xFE0, 0xFFFFFFFC0000,
                    0xFFC0000000000000, 0x1FFFFE03FF0000, 0x3FF0000, 0xFFFFF03FF,
                    0xFFF000000000000, 0x7FFFF00000000, 0x1FFFFFFF0000, 0x1FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFF, 0x3FBFF0000, 0x7FFFFF,
                    0xFFFFF000FFFFF, 0x1FFFFFF00000000, 0xFFFFFFFFFFFFC000, 0x7FE000000000000,
                    0xFF80, 0xFFFE000000000000, 0x1EEFFFFFFFFFFF, 0x3FFFBFFFFFFFFFFE, 0x1FFF,
                ],
                };

                pub const OPEN_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x10000000000, 0x800000008000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    7, 0, 8, 0, 0, 0, 0, 0, 0, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 11, 12, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 15, 16, 0, 0, 17, 18, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1400000000000000, 0x8000000, 0x44000000, 0x2000000000000020, 0x2000,
                    0x20000000500, 0x15550000000000, 0x554000000020, 0xAAAAA8,
                    0x1000000005000000, 0x15400000000, 0xAA00004, 0x25515500,
                    0x8000000000000000, 0xAAA0000000800000, 0x2A00008A, 0x800000000000100,
                    0x488000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OTHER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFFFFFFFF, 0x8000000000000000, 0x2000FFFFFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0x300000000000000, 0x40000280F, 0, 0, 0, 0, 0, 0x1000000000000,
                    0x1800000, 0x11800, 0xFFE078000000FF00, 0x1000003F, 0, 0, 0x20000000,
                    0xC000, 0x1800, 0xFFFC000000000000, 0x1800000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                    20, 21, 22, 23, 24, 25, 26, 4, 27, 28, 29, 4, 4, 4, 30, 4, 4, 4, 4, 4, 31,
                    32, 33, 34, 35, 36, 37, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 38, 39, 40, 41, 4,
                    42, 43, 39, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 4, 54, 4, 55, 56, 57,
                    58, 59, 4, 4, 4, 4, 4, 4, 4, 4, 60, 61, 62, 63, 64, 65, 66, 67, 4, 4, 68,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 69, 70, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 71, 72, 4, 4, 4, 4, 73, 74, 75,
                    76, 77, 4, 78, 79, 80, 4, 4, 4, 81, 4, 82, 83, 4, 84, 4, 85, 86, 87, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 88, 89, 4, 4, 4, 4, 90, 4, 4, 91, 4, 4, 4, 92, 93, 91, 4,
                    94, 4, 95, 4, 96, 97, 98, 4, 99, 100, 48, 4, 101, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 102, 103, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
                    104, 104, 104, 104, 104, 104, 104, 104, 104, 4, 4, 4, 4, 4, 105, 4, 106,
                    107, 108, 4, 109, 4, 4, 4, 4, 4, 4, 110, 111, 36, 112, 4, 113, 82, 4, 114,
                    115,
                ],
                tree2_level2: &[
                    0x8000C00000000000, 0xF800B0000000, 0x7F8000, 0x400000000, 0,
                    0xC3A020000066010, 0x800000304F7F8660, 0x2C92020000067811,
                    0xFF80003FA1FDC678, 0xC12020000044011, 0x1FC0030FFFEC440,
                    0xC12020000066011, 0xFF0000304F1FC660, 0x3C0038E729C23813,
                    0xF800003FFF7EC238, 0xC00020000022000, 0x7F0030D89FC220,
                    0xC10020000022000, 0xFFF100309F9FC220, 0x22000, 0x30000F0220,
                    0xD004000003800011, 0xFFE3003F00A07B80, 0x7800000000000001,
                    0xFFFFFFFFF0000000, 0xC000005000000829, 0xFFFFFFFF0C0080A0,
                    0x1E00000000100, 0x2000000001000000, 0xFFFFFFFFF8002000, 0xDF40,
                    0xC280C200, 0x80C200000000C200, 0x8000C2, 0xC20000, 0xE000000018000000,
                    0xFC000000, 0xC0C0000000000000, 0xE0000000, 0xFE00000000000000,
                    0xFF8000007FC00000, 0xFFF22000FFF00000, 0xFC00FC00C0000000, 0xFC004000,
                    0xF80000000000, 0xFFC0000000000000, 0xF000F00080000000,
                    0xFFE0C0000000000E, 0xF00000000000, 0x3800FC00, 0x30000000,
                    0x6000000080000000, 0xC000FC00FC00, 0xFFFFFFFFFFFF8000, 0x2000,
                    0xFF0000000000000, 0x700000000000000, 0x1C00, 0x180000000000F800,
                    0xF80000000000FF00, 0xC0C00000, 0xC00000005500C0C0, 0x20000000000000,
                    0x8023000010300020, 0x7C000000F800, 0xCFFFF00000000, 0xE0008000,
                    0xFFFE00000000FFFE, 0xF000, 0xFFFFFC0000000000, 0xFFFFF800,
                    0x30000000000000, 0x400000, 0x1F0000000000000, 0xDF4000000000,
                    0x7FFE7F0000000000, 0x80808080FF800000, 0x80808080, 0xFFFFFFFFC0000000,
                    0x4000000, 0xFFF0000000000000, 0xFFFFFFC00000, 0x1, 0x1800000,
                    0x100000000001F, 0x8000, 0x7FC000000000, 0x80000000, 0xE000, 0xFF80,
                    0xFFFFF00000000000, 0xFF00000000000000, 0x3FFFFE014C000,
                    0xFC00E00000000000, 0xFC003FC0, 0xE00000007FF00000, 0x800000003C004000,
                    0xFF80000000000000, 0xC00C000, 0xFF80000007FFFFF8, 0x8080FF818181,
                    0xFC00C00000000000, 0xFFF000000000, 0xF000000000000780,
                    0xFFFFFFFFFFFFFFFF, 0xC00000000000, 0xFFFFFFFFFC000000,
                    0xA08000001F07FF80, 0x24, 0x7FFF8, 0x30000, 0xFFFFFFFF7F00,
                    0x20F08000080000, 0xE000000000000000, 0x8000000000000000,
                    0xCFFF8080E3030303,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 2, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 2, 2, 14, 15, 16, 17,
                    18, 19, 2, 2, 2, 2, 20, 21, 22, 7, 23, 24, 25, 26, 27, 7, 28, 29, 30, 31,
                    32, 33, 34, 35, 36, 7, 2, 37, 38, 39, 40, 41, 42, 7, 7, 43, 44, 45, 16,
                    46, 47, 48, 2, 49, 50, 51, 52, 53, 2, 54, 55, 56, 57, 58, 59, 60, 61, 62,
                    2, 63, 2, 64, 7, 7, 65, 66, 2, 67, 68, 69, 70, 71, 7, 7, 72, 7, 73, 74,
                    75, 76, 77, 78, 2, 79, 80, 81, 82, 7, 7, 83, 84, 85, 86, 7, 87, 88, 89, 7,
                    7, 7, 7, 90, 91, 92, 93, 94, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 95,
                    7, 2, 96, 2, 2, 2, 97, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 98,
                    38, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 99, 100, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 71, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    68, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 81, 101, 102, 103, 2, 104, 105, 7, 7,
                    7, 7, 7, 7, 68, 7, 7, 7, 2, 92, 7, 2, 106, 107, 108, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 109, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 110, 37, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 111, 2, 2, 2, 2, 112, 113, 2, 2, 2, 2, 2,
                    72, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 114, 115, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 2, 2, 2, 68, 2, 2, 2, 2, 2, 2, 19, 7, 116, 117, 2, 97, 2, 2,
                    2, 118, 119, 120, 2, 121, 2, 122, 7, 123, 2, 124, 7, 7, 2, 125, 126, 127,
                    128, 129, 2, 2, 2, 2, 130, 2, 2, 2, 2, 131, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    132, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 133, 7, 7, 7, 134,
                    135, 136, 7, 137, 138, 7, 7, 7, 7, 139, 140, 7, 7, 7, 7, 7, 7, 7, 141, 7,
                    7, 7, 142, 7, 7, 7, 7, 7, 7, 7, 143, 2, 2, 2, 144, 2, 145, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 146, 147, 7, 148, 7, 7, 7, 149, 150, 151, 152, 7, 7, 7,
                    7, 153, 2, 154, 155, 2, 2, 135, 156, 157, 158, 7, 7, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 159, 2, 160, 2, 161, 162, 163, 164, 56, 2, 2, 2,
                    2, 2, 165, 166, 167, 2, 2, 168, 68, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 32, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 68, 2, 2,
                    2, 169, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 170, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 171, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 66, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2,
                    2, 2, 2, 2, 2, 66, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 172, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 99, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 99, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                ],
                tree3_level3: &[
                    0x4800008000001000, 0xFFFFFFFFC000C000, 0, 0xF800000000000000,
                    0x70000000000078, 0xFFFFFFFEE0008000, 0xC00000000000FFFF,
                    0xFFFFFFFFFFFFFFFF, 0xE0000000, 0xF0000000FFFE0000, 0x1FF000000000,
                    0xF80000000000F800, 0x40000000, 0xFFFFFFFFFFC000F0, 0xFC00C0000000,
                    0xF000000000F00000, 0xFF0000000000, 0x8007FF000000000, 0xE404000400480800,
                    0xFFF0000000000000, 0xFF80000000000000, 0xFFFFFF00FFC00000,
                    0xF802000000000040, 0x6E400000000002C0, 0x400000, 0xFFFF007F80000000,
                    0x7C80000FFFFFFFF, 0x7C00000070000000, 0xF00000000000000, 0x30000,
                    0x78C0000001100F90, 0xFE00FE00, 0xFFFFFFFF00000000, 0xFF80078000000000,
                    0x1C0000000000000, 0xF8000000C00000, 0xFFFF01FFE1FC0000,
                    0xFFFFFFFFFFFFFE00, 0xFFF8000000000000, 0x3F8000000000000,
                    0xFC00FF0000000000, 0x1C000000000, 0xFFFFFFFFFFFF3FC0, 0x80000000FFFFFFFF,
                    0xFFFCC40000000000, 0xFFFFFFFFFFFFFE3, 0xFFFFFC000000, 0xFFFFFFFFFC00,
                    0xFF800000FFFFF000, 0x7FC000000003C000, 0x2000000000000000,
                    0xFC00FE000000FFF8, 0x20000000000000, 0xFF8000000000FF00,
                    0xFFE0000100000000, 0x40000, 0xFFFFFFFFFFFFFFFC, 0xFC0040004280,
                    0xFC00F80000000000, 0x412020000066010, 0xFFE0E0301F7EC660,
                    0x4000000000B400, 0xFFFFFFF9FE40085A, 0xFFFFFFFC10000000,
                    0xFFFFFFFFFC00FF00, 0xC0000000000000, 0xFFFFFFFFC0000000,
                    0xFFFFE000FC00FFE0, 0xFC00000000000000, 0xFFFFFFF00000FC00,
                    0xF00018000000, 0xFFFFFFFFFFFFFF80, 0xF000000000000000, 0xFFFFFFFF,
                    0x7FF8000000000000, 0x640000000900D80, 0xFFFFFFFFFC00FF80, 0x300FFFFFFFF,
                    0xFFFFFFE003000000, 0xFF00, 0xFFF800000000, 0xFE00000000000000,
                    0xFFFFFFFFFFFFFC00, 0xFC00FFFC00000000, 0x80000000000200, 0xE0000000FFC0,
                    0xFF80010000030000, 0x4B80000000000480, 0x240FC00FF00, 0xFFFFFC00FE048000,
                    0xFE000000FFFFFFFF, 0x3800000000020000, 0xFFFFFFFFF8000000,
                    0xFFFEFFFFFFFFFFFF, 0x7FFC000000000000, 0xFFFFFFFFFC000000,
                    0xFFE0800000000000, 0xFFFFFFFFFFFFFFF0, 0xFFFF, 0xFFFF000000000000,
                    0xFFC00000, 0x3C0080000000, 0x8000000000000000, 0xFFC0C0000000FC00,
                    0x1F0000040400FFC0, 0xFFFFFFFFFFFF0000, 0x7800, 0xFFFFFFFF00007F00,
                    0xFFFCFFE0FFFFFFFF, 0xFF00000000000000, 0x7FFFFFFFFFC00000,
                    0x9010FFFFFFFFFFFF, 0xFFFBFFF800000000, 0xFF0FFFD8FFFF,
                    0xE000F80000000000, 0xFFFFFFFF0C00FE00, 0xC00000000000, 0xFF80,
                    0xFFC0000000000000, 0x18000000000, 0x7F8000000000000, 0xFFFFF80000000000,
                    0xFFFFFFFFFFFFFFC0, 0xFFF00000FFF00000, 0xFE000000FF800000, 0x200000,
                    0x1400219B20000000, 0x10, 0x8400000020201840, 0x203A0, 0xC000000000,
                    0x3000, 0xFFFF000107FFF000, 0xFFFFF81F80000000, 0xF82406000080,
                    0xFFFFC00000000000, 0xFFFFFFFFFFFF7FFF, 0xC000E00000000000,
                    0xFFFFFFFFFFFF3C00, 0xFFFF80000000FFFF, 0x7C00000000000000,
                    0xFC0000000000FFFF, 0x780000000000FFFF, 0x80009080FFFFFFFF,
                    0xFFFFFFFFFF800060, 0xFFFFFFFF3C00F000, 0x1FFFFFFFFFFFF,
                    0xFFE0000000000000, 0xC000000000000001, 0xF508016900000010,
                    0xA10808695569157B, 0xF0000411F0000400, 0xFFFCFFFFFFFFFFFF,
                    0xF00000000000, 0x18000FFF00000, 0xFFC0000000010001, 0x3FFFFFFFFF,
                    0xF00000000000FFF8, 0xFFFFFFC0FFFCFE00, 0xE000E0000F000000,
                    0x780000000000000, 0xFFFEF000FC000000, 0xF000, 0xFC00FF00,
                    0xF000C0000000FF00, 0xE000C000FFF00000, 0x7C00, 0xFE00FC0060003F80,
                    0x80000, 0xC0000000, 0xFFFC00000000, 0xFFFE00000000, 0xF800,
                ],
                };

                pub const OTHER_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x400040000000000, 0, 0, 0, 0x800000000000000, 0xF, 0, 0, 0x100000,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x787FFFFFF0000, 0xFFFFFFFF00000000,
                    0xFFFEC000000007FE, 0xFFFFFFFFFFFFFFFF, 0x9C00C000002FFFFF,
                    0xFFFFFFFD0000, 0xFFFFFFFFFFFFE000, 0x2003FFFFFFFFF, 0x7FFFFFFFC00,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 31, 35, 35, 35,
                    35, 35, 36, 37, 38, 39, 40, 41, 31, 42, 35, 35, 35, 35, 35, 35, 35, 35,
                    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 31,
                    31, 60, 61, 62, 63, 64, 65, 31, 66, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 67, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 68, 69, 70, 71, 31, 31, 31, 31, 31, 31, 31, 31, 72, 42, 73, 74, 75,
                    35, 76, 68, 31, 31, 31, 31, 31, 31, 31, 31, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 31, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 77, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 78, 79, 35, 35, 35, 35, 80,
                    81, 50, 63, 31, 31, 82, 83, 84, 48, 85, 86, 87, 88, 89, 90, 91, 92, 93,
                    94, 95, 31, 31, 96, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
                    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 97,
                    98, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
                    31, 31, 31, 31, 31, 31, 31, 35, 35, 35, 35, 35, 99, 35, 100, 101, 102,
                    103, 104, 35, 35, 35, 35, 105, 106, 107, 108, 31, 109, 35, 110, 31, 111,
                    112, 113,
                ],
                tree2_level2: &[
                    0x3FFFFF, 0xFFFF07FF01FFFFFF, 0xFFFFFFFF00007EFF, 0x1FF,
                    0x23FFFFFFFFFFFFF0, 0xFFFC0003FF010000, 0x23C5FDFFFFF99FE1,
                    0x10030003B0004000, 0x36DFDFFFFF987E0, 0x1C00005E000000,
                    0x23EDFDFFFFFBBFE0, 0x200000300010000, 0x23EDFDFFFFF99FE0,
                    0x20003B0000000, 0x3FFC718D63DC7E8, 0x10000, 0x23FFFDFFFFFDDFE0,
                    0x327000000, 0x23EFFDFFFFFDDFE1, 0x6000360000000, 0x27FFFFFFFFFDDFF0,
                    0xFC00000380704000, 0x2FFBFFFFFC7FFFE0, 0x7F, 0xDFFFFFFFFFFFE, 0x3F,
                    0x200DFFAFFFFFF7D6, 0xF000001F, 0x1, 0x1FFFFFFFFEFF, 0x1F00, 0,
                    0x800007FFFFFFFFFF, 0xFFE1C0623C3F0000, 0x4003, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF, 0xFFFFFFFFFF7FFF3D,
                    0xFFFFFFFFFF3DFFFF, 0x7FFFFFF, 0xFFFF, 0xFFFFFFFFFFFFFFFE,
                    0xFFFF9FFFFFFFFFFF, 0xFFFFFFFF07FFFFFE, 0x1FE07FFFFFFFFFF,
                    0x3FFFF8003FFFF, 0x1DFFF0003FFFF, 0xFFFFFFFFFFFFF, 0x10000000,
                    0xFFFFFFFF00000000, 0x1FFFFFFFFFFFFF7, 0xFFFF05FFFFFFFF9F,
                    0x3FFFFFFFFFFFFF, 0x7FFFFFFF, 0x1F3FFFFFFF0000, 0xFFFF0FFFFFFFFFFF, 0x3FF,
                    0xFFFFFFFF007FFFFF, 0x1FFFFF, 0xFFFFFFFFFFFE0, 0x1FE0, 0xFC00C001FFFFFFF8,
                    0x3FFFFFFFFF, 0xFFFFFFFFF, 0xFFFFFFFC00E000, 0x46FDE0000000000,
                    0x1E0000000000000, 0xFFFF000000000000, 0xFFFFFFFFFF, 0x7F7F7F7F007FFFFF,
                    0x7F7F7F7F, 0x1000000000000040, 0xFFFFFFFE807FFFFF, 0x87FFFFFFFFFFFFFF,
                    0xFFFEFFFFFFFFFFE0, 0xFFFFFFFF00007FFF, 0xFFFFFFFFFFDFFFFF, 0x1FFF,
                    0xFFFFFFFFFF0000, 0xC00FFFF0FFF, 0x400000000000, 0x8000,
                    0xF880000000000000, 0x7FFFFF7BB, 0xFFFFFFFFFFFFC, 0x68FC000000000000,
                    0xFFFF003FFFFFFC00, 0x1FFFFFFF0000007F, 0x7FFFFFFFFFFF0,
                    0x7C00FF9F00000000, 0x1FFFFFFFFFF, 0xC47EFFFF00000FF7, 0x3E62FFFFFFFFFFFF,
                    0x407FF18000005, 0x7F7F007E7E7E, 0x7FFFFFFFF, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF, 0x5F7FFDFFA0000000,
                    0xFFFFFFFFFFFFFFDB, 0x3FFFFFFFFFFFF, 0xFFFFFFFFFFF80000,
                    0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFCFFFF,
                    0xFFF0000000000FF, 0xFFDF000000000000, 0x1FFFFFFFFFFFFFFF,
                    0xFFFEFFC000000000, 0x7FFFFFFF3FFFFFFF, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 12, 13, 14, 7, 15, 16, 7, 17, 18, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 4, 11, 12, 4, 13, 14, 4,
                    15, 2, 2, 2, 2, 16, 17, 4, 4, 18, 19, 20, 21, 22, 4, 23, 4, 24, 25, 26,
                    27, 28, 29, 30, 4, 2, 31, 4, 4, 14, 32, 4, 4, 4, 4, 33, 34, 35, 36, 37,
                    38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 20, 50, 51, 52, 53, 54,
                    55, 56, 57, 4, 4, 58, 59, 56, 60, 61, 4, 62, 63, 4, 4, 64, 4, 4, 65, 66,
                    67, 68, 69, 70, 71, 72, 73, 4, 4, 4, 74, 75, 76, 77, 4, 78, 79, 80, 4, 4,
                    4, 4, 81, 82, 4, 83, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 84, 4,
                    4, 4, 2, 2, 2, 85, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 11, 86,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 56, 87, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 63, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 12,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 73, 88, 89, 90, 56, 91, 77, 4, 4, 4, 4, 4,
                    4, 92, 4, 4, 4, 4, 4, 4, 2, 93, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 94, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 95, 31, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 96, 97,
                    2, 2, 2, 2, 2, 98, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 99, 100, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 101, 4, 4, 4,
                    4, 4, 4, 4, 102, 103, 4, 4, 4, 4, 90, 64, 4, 4, 4, 4, 4, 4, 4, 104, 4, 4,
                    4, 105, 4, 4, 4, 4, 4, 4, 4, 106, 2, 2, 2, 107, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 108, 109, 110, 4, 4, 4, 4, 4, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 111,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 112, 2, 2, 2, 9, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 113, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 114, 2, 2, 2, 2, 2, 2, 2, 2, 2, 12,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 12, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 115, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    56, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                    0xFFFFFFFF1FFFFFFF, 0x1FFFF, 0xFFFFE000FFFFFFFF, 0x3FFFFFFFFF03FD,
                    0xFFFFFFFF3FFFFFFF, 0xFF0F, 0xFFFFFFFFFFFF0000, 0x3FFFFFFF,
                    0xFFFF00FFFFFFFFFF, 0xFFFFFFFFF, 0xFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF,
                    0xFF003FFFFF, 0x91BFFFFFFFFFFD3F, 0x7FFFFF003FFFFF, 0x7FFFFFFF,
                    0x37FFFF00000000, 0x3FFFFFF003FFFFF, 0xC0FFFFFFFFFFFFFF, 0x3FFFFFFEEF0001,
                    0x1FFFFFFF00000000, 0x1FFFFFFF, 0x1FFFFFFEFF, 0x3FFFFFFFFFFFFF,
                    0x7FFFF003FFFFF, 0x3FFFF, 0x1FF, 0xBC00, 0x303FFFFFFFFFF, 0x1C,
                    0xFFFF00801FFFFFFF, 0xFFFF00000000003F, 0xFFFF000000000003,
                    0x7FFFFF0000001F, 0xFFFFFFFFFFFFF8, 0x26000000000000, 0xFFFFFFFFFFF8,
                    0x1FFFFFF0000, 0x7FFFFFFFF8, 0x47FFFFFFFF0090, 0x7FFFFFFFFFFF8,
                    0x1400001E, 0x80000FFFFFFBFFFF, 0x1, 0xFFFF01FFBFFFBD7F,
                    0x23EDFDFFFFF99FE0, 0x3E0010000, 0xBFFFFFFFFF4BFF, 0xA0000,
                    0x1FFFFFFFFFFFFF, 0x380000780, 0xFFFFFFFFFFFF, 0xB0, 0x7FFFFFFFFFFF,
                    0xF000000, 0x10, 0x10007FFFFFFFFFF, 0x7FFFFFF, 0x7F, 0xFFFFFFFFFFF,
                    0x8000000000000000, 0x8000FFFFFF6FF27F, 0x2, 0xFFFFFCFF00000000,
                    0xA0001FFFF, 0x407FFFFFFFFF801, 0xFFFFFFFFF0010000, 0xFFFF0000200003FF,
                    0x1FFFFFFFFFFFFFF, 0x1FFFFFFFF, 0x7FFFFFFFFDFF, 0xFFFC000000000001,
                    0xFFFF, 0x1FFFFFFFFFB7F, 0xFFFFFDBF00000040, 0x10003FF, 0x7FFFF00000000,
                    0xFFFFFFFFDFFF4, 0x1000000000000, 0x3FFFFFF, 0xF, 0x1FFFFFFFFFFFF,
                    0xFFFFFFFF0000007E, 0xFFFF00007FFFFFFF, 0x7FFFFFFFFFFFFFFF,
                    0x3FFFFFFF0000, 0xE0FFFFF800000000, 0x7FFFFFFFFF8, 0x107FF,
                    0xFFFFFFFFFFFFFF, 0x80000000003FFFFF, 0x40007FFFFFFFF, 0xFFFF00F000270000,
                    0xFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0x3FF01FF, 0x400, 0x1FFFFFFFFFFF,
                    0x4000, 0x7FFFFFF0000, 0x13FFFFFFF0000, 0x7FFF6F7F00000000, 0x1F,
                    0xAF7FE96FFFFFFEF, 0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0xFFFFFFFF,
                    0x3FFFFFFFFFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF,
                    0xFFFFFFFFFFFF07FF,
                ],
                };

                pub const OTHER_NUMBER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x720C000000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 3, 0, 4, 0, 0, 0, 5, 0, 0, 0,
                    0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11,
                    0, 0, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 16, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 21,
                    22, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3F0000000000000, 0xFC000000000000, 0x7000000000000,
                    0x7F00000000000000, 0x1FF00007F000000, 0xFFC0000000000,
                    0x1FFFFE0000000000, 0x3FF000000000000, 0x4000000, 0x3F1000000000000,
                    0x3FF, 0xFFFF0000, 0x200, 0xFFFFFFFF00000000, 0xFFFFFFF,
                    0xFFFFFC0000000000, 0xFFC0000000000000, 0xFFFFF, 0x2000000000000000,
                    0x3C0000, 0x3FF00000000, 0xFFFEFF00, 0xFFFE0000000003FF, 0x3F000000000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 8, 9, 0, 10, 11, 0, 12, 13, 14, 0, 15, 16,
                    0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 18, 0, 0, 19, 20, 0, 21, 0, 22, 0, 0, 0, 0,
                    0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0,
                    0, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 30, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 33, 34, 0, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFF80, 0x1E0000000000000, 0xC00, 0xFFFFFFE00000000,
                    0xF00000000, 0xFE000000FF000000, 0xFF8000000000, 0xF800000000000000,
                    0xFC00000, 0x3000000000000000, 0xFFFFFFFFFFFCFFFF, 0x60000000000001FF,
                    0xE0000000, 0xF80000000000, 0xFF000000FF000000, 0xFE0000000000,
                    0xFC00000000000000, 0x7FFFFFFF00000000, 0x7FE0000000, 0x1E0000, 0xFE0,
                    0x3FFFFC0000, 0x1FFFFE00000000, 0xC00000000000000, 0x7FC0000000000,
                    0x1FFFFC000000, 0x1FFFFF, 0x3F8000000, 0x7FFFFF, 0xFFFFF000FFFFF,
                    0x1FFFFFF00000000, 0xFF80, 0xFFFE000000000000, 0x1EEFFFFFFFFFFF,
                    0x3FFFBFFFFFFFFFFE, 0x1FFF,
                ],
                };

                pub const OTHER_PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8C00D4EE00000000, 0x10000001, 0x80C0008200000000, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0x4000000000000000, 0x80, 0, 0, 0, 0, 0, 0, 0xFC000000, 0x200,
                    0x18000000000049, 0xE8003600, 0x3C0000000000, 0, 0x100000, 0x3FFF, 0, 0,
                    0x380000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 2, 2, 2, 2, 7, 8, 2, 2, 2, 2, 9, 2,
                    10, 2, 2, 11, 2, 12, 13, 2, 14, 2, 15, 2, 2, 2, 2, 2, 2, 2, 2, 2, 16, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 17, 2, 18, 19, 2, 2, 20, 21, 2, 2, 2, 2, 22,
                    2, 2, 23, 2, 24, 2, 2, 25, 2, 26, 27, 28, 2, 29, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 30, 31, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 32, 2, 6, 2, 2, 33, 34, 2, 2, 2, 2, 2, 2, 35, 2, 2, 15,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 28, 2, 2, 2, 2, 36, 37, 2, 38, 2,
                    2, 2, 2, 2, 39, 2, 40, 41, 42, 2, 43, 2, 44, 2, 45, 2, 2, 2, 46, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    47, 48, 2, 2, 49, 50, 2, 2,
                ],
                tree2_level2: &[
                    0x7FFF000000000000, 0x40000000, 0, 0x1003000000000, 0x2000000000000000,
                    0x40000000000000, 0x1000000000000, 0x80000000000000, 0x10,
                    0x10000000000000, 0xC008000, 0x17FFF0, 0x20, 0x61F0000, 0xFC00,
                    0x800000000000000, 0x1FF00000000, 0x400000000000, 0x380000000000,
                    0x60000000000000, 0x7700000, 0x7BF, 0x30, 0xC0000000, 0x3F7F00000000,
                    0xE0000001FC00C000, 0xF000000000000000, 0xF800000000000000,
                    0xC000000000000000, 0x800FF, 0x79FF00FF00C00000, 0x7FEBFF8E,
                    0xDE00000000000000, 0xF3FF7C00CB7FC9C3, 0x1CFFFA, 0x200000000000000E,
                    0xE000, 0x4008000000000000, 0xFC000000000000, 0xF0000000000000,
                    0x170000000000C000, 0xC00000000000, 0x80000000, 0xC0003FFE, 0xF0000000,
                    0x30000C0000000, 0x80000000000, 0x10000027F0000, 0xD0380F71E60,
                    0x100000018C00D4EE, 0x3200000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 3, 3, 3, 3, 5, 3, 6, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 4, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 6, 0, 0, 0, 0, 7, 0, 8, 9, 0, 10, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 0, 0, 13, 14, 15, 0, 16, 0,
                    17, 18, 0, 19, 0, 0, 0, 0, 20, 0, 21, 0, 22, 0, 0, 0, 23, 0, 24, 25, 0,
                    26, 0, 0, 0, 27, 0, 0, 0, 0, 28, 0, 29, 30, 31, 32, 0, 33, 0, 0, 34, 0,
                    35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 37, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 41, 42, 43, 0, 0, 0, 0, 0,
                    0, 0, 44, 0, 0, 0, 0, 45, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7, 0x80000000, 0x10000, 0x800000000000, 0x800000, 0x8000000080000000,
                    0x8000000001FF0000, 0x7F000000000000, 0xFE00000000000000, 0x1E000000,
                    0x3E00000, 0x3C0, 0x3F80, 0xD800000000000000, 0x3, 0x3000000000000F,
                    0xE80021E0, 0x3F00000000000000, 0x20000000000, 0x1B00000, 0x2C00F800,
                    0x40, 0xFFFFFE, 0x1FFF0000000E, 0x200000000000000, 0x7000000000000000,
                    0x800000000000000, 0x70, 0x400000000, 0x8000000000000000, 0x7F,
                    0x7DC000000, 0x3FF, 0x200000000, 0x300000000003E, 0x180000000000000,
                    0xFFF8, 0x1F000000000000, 0x6000000000000, 0xC00000000000,
                    0x20000000000000, 0xF80000000000000, 0x10, 0xE00000000000, 0x7800000,
                    0xF80, 0xC0000000,
                ],
                };

                pub const OTHER_SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0x1424000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4,
                    0, 0, 0, 0x6000, 0, 0xC000, 0, 0, 0x6000020040000000, 0, 0, 0,
                    0x40000000000000,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 3, 0, 4, 0, 0, 0, 5, 0, 0, 0,
                    0, 0, 0, 6, 0, 7, 8, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 13, 0,
                    0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 15, 16, 17, 18, 0, 0, 0, 0, 19, 20, 21, 22, 23, 24, 25, 23, 26,
                    26, 27, 28, 26, 29, 26, 26, 26, 30, 31, 0, 26, 26, 26, 26, 0, 0, 0, 0, 0,
                    0, 0, 0, 32, 33, 34, 26, 0, 0, 0, 35, 0, 0, 0, 0, 0, 36, 37, 38, 26, 26,
                    26, 39, 40, 0, 0, 0, 0, 0, 41, 42, 43, 44, 45, 26, 26, 26, 26, 26, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    46, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0,
                    49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 51, 0, 0, 0, 0, 0, 0, 0, 52,
                ],
                tree2_level2: &[
                    0, 0x400000000000000, 0x1000000000000, 0x5F8000000000000,
                    0x8000000000000000, 0x200000000008000, 0x1500000FCE8000E,
                    0xC000000000000000, 0x1E0DFBF, 0xC0000000, 0x3FF0000, 0x200000000000, 0x1,
                    0xFFFFFFFFC0000000, 0x1FF007FE00000000, 0xC0042AFC0D0037B, 0xB400,
                    0xFFFFBFB6F3E00C00, 0xFFFFFFFEB3FFF, 0xFFFFF9FCFFFFF0FF,
                    0xEFFFFFFFFFFFFFFF, 0xFFF0000007FFFFFF, 0xFFFFFFFC0FFFFFFF, 0x3FFFFFFFFFF,
                    0x7FF, 0xFFFFFFFFF0000000, 0xFFFFFFFFFFFFFFFF, 0xFF7FFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFD, 0xFFFF7FFFFFFFFFFF, 0xFFFFFFFFFF, 0xFFFFFFFFFFF00000,
                    0xFFFFFFFFFFFF, 0xFFCFFFFFFFFFE060, 0xFFFFFFFFFFBFFFFF, 0x7E000000000,
                    0x30000, 0xFFFFFFFFFBFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFF0000003FFFFF,
                    0xC0C00001000C0010, 0xFFC30000, 0x803FFFFFFFFF, 0xFFFFFC007FFFFFFF,
                    0xFFFFFFFF000100FF, 0x1FFFFFFFFFC00, 0xFFFFFFFFFFFF0000, 0x7F,
                    0x2C00F0000000000, 0x380000000000000, 0xFFFF, 0xE000000000008000,
                    0x3000611000000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12,
                    13, 12, 12, 12, 12, 12, 12, 14, 0, 0, 15, 12, 16, 12, 12, 12, 17, 18, 19,
                    20, 21, 12, 22, 0, 0, 12, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 24, 25, 26, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 29, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 30, 12, 31, 32, 33, 12, 34, 35, 36, 37, 0, 0, 12, 12, 12,
                    38, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 39, 12, 40, 12, 41, 42,
                    43, 44, 45, 12, 12, 12, 12, 12, 46, 47, 48, 12, 12, 49, 13, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF80000000000000, 0xFE00000000000000, 0x11FFF73FF,
                    0x1FFFFFFFFFFF0000, 0x180000000000000, 0x100, 0x8000000000000000,
                    0x3FFFE1FE00000, 0xF000000000000000, 0x20, 0x10000000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xF,
                    0x3FFFFFFFFFFFFF, 0xFFFFFE7FFFFFFFFF, 0x1C1FFFFFFFFF, 0xFFFFC3FFFFFFF018,
                    0x7FFFFFFFFFF, 0x23, 0x7FFFFF, 0x780000000000000, 0xFFDFE00000000000,
                    0x6F, 0x8000, 0x100000000000, 0x400000000000, 0xFFFF0FFFFFFFFFFF,
                    0xFFFE7FFF000FFFFF, 0x3FFFFFFFFEFFFE, 0xFFFFFFFFFFFFE000, 0x3FFFFFFFFFFF,
                    0xFFFFFFC000000000, 0xFFFFFFFFFFF0007, 0x3F000301FF, 0x7FFFFFFFFFFFFFF,
                    0x1FFF1FFFF0FFFFFF, 0xF87FFFFFFFFFFFFF, 0x10FFF03FFFFFF,
                    0xFFFFFFFFFFFF0FFF, 0xFFFFFFFF03FF00FF, 0xFFF3FFFFFFF00FF, 0x3,
                    0x1FFF3FFF000FFFFF, 0xFFFFFFFFFFFF83FF, 0x1FF03FF9FFFC07F,
                    0xFFFFFFFFFFF7FFFF,
                ],
                };

                pub const PARAGRAPH_SEPARATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x20000000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const PRIVATE_USE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFF,
                ],
                };

                pub const PUNCTUATION: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x8C00F7EE00000000, 0x28000000B8000001, 0x88C0088200000000, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0x4000000000000000, 0x80, 0, 0, 0, 0, 0, 0, 0xFC000000,
                    0x4000000000000600, 0x18000000000049, 0xE8003600, 0x3C0000000000, 0,
                    0x100000, 0x3FFF, 0, 0, 0x380000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 2, 2, 2, 2, 7, 8, 2, 2, 2, 2, 9, 2,
                    10, 2, 2, 11, 2, 12, 13, 2, 14, 2, 15, 2, 2, 2, 2, 2, 2, 2, 2, 2, 16, 2,
                    2, 17, 2, 2, 2, 2, 2, 2, 2, 2, 18, 19, 20, 21, 2, 2, 22, 23, 2, 2, 2, 2,
                    24, 2, 2, 25, 2, 26, 2, 2, 27, 2, 28, 29, 30, 2, 31, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 32, 33, 34, 2, 2, 2, 2, 2, 2, 2, 2, 2, 35, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 36, 2, 37, 2, 2, 2, 2, 2, 2, 38, 39, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 40, 2, 6, 2, 2, 41, 42, 2, 2, 2, 2, 2, 2,
                    43, 2, 44, 15, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 30, 2, 2, 2, 2, 45,
                    46, 2, 47, 2, 2, 2, 2, 2, 48, 2, 49, 50, 51, 2, 52, 2, 53, 2, 54, 2, 2, 2,
                    55, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 30, 2, 2, 2, 56, 57, 2, 2, 58, 59, 2, 2,
                ],
                tree2_level2: &[
                    0x7FFF000000000000, 0x40000000, 0, 0x1003000000000, 0x2000000000000000,
                    0x40000000000000, 0x1000000000000, 0x80000000000000, 0x10,
                    0x10000000000000, 0xC008000, 0x3C0000000017FFF0, 0x20, 0x61F0000, 0xFC00,
                    0x800000000000000, 0x1FF00000000, 0x1, 0x400000000000, 0x18000000,
                    0x380000000000, 0x60000000000000, 0x7700000, 0x7FF, 0x30, 0xC0000000,
                    0x3F7F00000000, 0xE0000001FC00C000, 0xF000000000000000,
                    0xF800000000000000, 0xC000000000000000, 0x800FF, 0xFFFF00FFFFFF0000,
                    0x600000007FFBFFEF, 0x6000, 0x60000000F00, 0x3FFF0000000000,
                    0xFFC000000060, 0x1FFFFF8, 0x300000000F000000, 0xDE00000000000000,
                    0xFFFF7FFFFFFFFFFF, 0x3FFCFFFF, 0x20010000FFF3FF0E, 0x100000000, 0xE000,
                    0x4008000000000000, 0xFC000000000000, 0xF0000000000000,
                    0x170000000000C000, 0xC00000000000, 0x80000000, 0xC0003FFE, 0xF0000000,
                    0x30000C0000000, 0x80000000000, 0xFFFF000003FF0000, 0xD0BFFF7FFFF,
                    0xB80000018C00F7EE, 0x3FA8000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 3, 3, 3, 3, 5, 3, 6, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 4, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 6, 0, 0, 0, 0, 7, 0, 8, 9, 0, 10, 0, 0,
                    0, 0, 0, 0, 11, 0, 0, 0, 0, 12, 0, 0, 13, 14, 0, 0, 15, 16, 17, 0, 18, 0,
                    19, 20, 0, 21, 0, 0, 0, 0, 22, 0, 23, 0, 24, 0, 0, 0, 25, 0, 26, 27, 0,
                    28, 0, 0, 0, 29, 0, 0, 0, 0, 30, 0, 31, 32, 33, 34, 0, 35, 0, 0, 36, 0,
                    37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 39, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 0, 43, 44, 45, 0, 0, 0, 0, 0,
                    0, 0, 46, 0, 0, 0, 0, 47, 0, 0, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7, 0x80000000, 0x10000, 0x800000000000, 0x800000, 0x8000000080000000,
                    0x8000000001FF0000, 0x7F000000000000, 0xFE00000000000000, 0x1E000000,
                    0x400000000000, 0x200000000000, 0x3E00000, 0x3C0, 0x3F80,
                    0xD800000000000000, 0x3, 0x3000000000000F, 0xE80021E0, 0x3F00000000000000,
                    0x20000000000, 0x1B00000, 0x2C00F800, 0x40, 0xFFFFFE, 0x1FFF0000000E,
                    0x200000000000000, 0x7000000000000000, 0x800000000000000, 0x70,
                    0x400000000, 0x8000000000000000, 0x7F, 0x7DC000000, 0x3FF, 0x200000000,
                    0x300000000003E, 0x180000000000000, 0xFFF8, 0x1F000000000000,
                    0x6000000000000, 0xC00000000000, 0x20000000000000, 0xF80000000000000,
                    0x10, 0xE00000000000, 0x7800000, 0xF80, 0xC0000000,
                ],
                };

                pub const SEPARATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x100000000, 0, 0x100000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x8300000007FF, 0x80000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SPACE_SEPARATOR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x100000000, 0, 0x100000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1, 0x8000000007FF, 0x80000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SPACING_MARK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 5, 7, 8, 4, 9, 10, 11, 12, 8, 13, 3, 14, 15,
                    16, 0, 0, 0, 0, 9, 17, 0, 0, 18, 19, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 22, 23, 0, 0, 0, 0, 24,
                    0, 0, 0, 25, 26, 0, 0, 27, 28, 29, 30, 31, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    34, 0, 35, 36, 0, 37, 38, 6, 39, 40, 0, 41, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC800000000000008, 0xDE01, 0xC00000000000000C, 0x801981,
                    0xC000000000000008, 0x1, 0x1A01, 0x400000000000000C, 0xC000000000000000,
                    0x801DC6, 0xE, 0x1E, 0x8000000600D9F, 0x801DC1, 0xC, 0xC0000FF038000,
                    0x8000000000000000, 0x1902180000000000, 0x3F9C00C00000, 0x1C009F98,
                    0x10000000200000, 0xC040000000000000, 0x1BF, 0x1FB0E7800000000, 0x6000000,
                    0x7E01A00A00000, 0xE820000000000010, 0x1B, 0x4C200000004, 0xC5C8000000000,
                    0x300FF000000000, 0x80000200000000, 0xC00000000000, 0x9800000000,
                    0xFFF0000000000003, 0xF, 0xC0000, 0xCC30000000000008, 0x19800000000000,
                    0x2800000000002000, 0x20C80000000000, 0x16D800000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 3, 4, 5, 6, 7, 0, 0,
                    8, 9, 10, 11, 12, 13, 14, 15, 16, 0, 0, 17, 0, 18, 0, 19, 0, 20, 0, 0, 0,
                    21, 0, 0, 0, 22, 1, 0, 23, 24, 25, 26, 0, 0, 0, 0, 0, 27, 0, 28, 0, 0, 0,
                    29, 0, 0, 0, 0, 30, 31, 16, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33,
                    34, 35, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x5, 0x187000000000004, 0x100000000000, 0x60, 0x8038000000000004,
                    0x4001, 0x2C700000000000, 0x700000000, 0xC00000000000000C, 0xC0080399E,
                    0x700000000000000, 0xB7A4, 0xE0000000000000, 0x23, 0x7A07000000000000,
                    0x2, 0x4F03800000000000, 0x5807000000000000, 0x40D00000000000,
                    0x4340000000, 0x100700000000000, 0x21BF000000000000, 0x10F00E0000,
                    0x200000000000000, 0x1800000, 0x800000, 0x4000800000000000,
                    0x12020000000000, 0x587C00, 0x60000000000000, 0xC030000000000008,
                    0x1C0000000000, 0xFFFFFFFFFFFE0000, 0xFF, 0x3000000000000,
                    0x7E06000000000,
                ],
                };

                pub const SURROGATE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SYMBOL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0x7000081000000000, 0x5000000140000000, 0x113D37C00000000,
                    0x80000000800000, 0, 0, 0, 0, 0, 0, 0, 0xFFFFAFE0FFFC003C, 0,
                    0x20000000000000, 0x30, 0x40000000000000, 0, 0, 0x4, 0, 0, 0, 0xE000, 0,
                    0xC9C0, 0, 0, 0x6000020040000000, 0, 0, 0, 0xC040000000000000,
                ],
                tree2_level1: &[
                    0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 4, 0, 5, 0, 6, 0, 0, 0, 7, 0, 0, 6,
                    0, 0, 0, 8, 0, 9, 10, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 15, 0, 16,
                    0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 19,
                    0, 20, 21, 15, 22, 23, 24, 25, 25, 25, 25, 25, 26, 25, 25, 25, 27, 28, 29,
                    27, 25, 25, 25, 25, 25, 25, 25, 25, 25, 30, 31, 32, 25, 25, 25, 25, 25,
                    25, 33, 34, 25, 25, 25, 25, 25, 35, 36, 25, 0, 0, 0, 37, 0, 0, 0, 0, 0,
                    38, 39, 40, 25, 25, 25, 41, 42, 0, 43, 0, 0, 0, 44, 45, 46, 47, 48, 25,
                    25, 25, 25, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 49, 50, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 52, 0, 53, 0,
                    0, 0, 0, 0, 0, 0, 0, 54, 0, 0, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 56, 0, 57, 58, 0, 0, 0, 0, 0, 59, 0, 60, 0, 61, 0, 0,
                    62, 63, 0, 64,
                ],
                tree2_level2: &[
                    0, 0x100, 0xC0C000000000000, 0x2000000000000, 0x1000000000000,
                    0x7F8000000000000, 0x8000000000000000, 0x200000000008000,
                    0x1500000FCE8000E, 0xC000000000000000, 0x1E0DFBF, 0xC0000000, 0x3FF0000,
                    0x200000000000, 0x8000000, 0x1, 0xFFFFFFFFC0000000, 0x1FF007FE00000000,
                    0xA000000000000000, 0x6000E000E000E003, 0x1C00000000040010,
                    0xFFFFFFFF00001C00, 0xC0042AFC1D0037B, 0xBC1F, 0xFFFFFFFFFFFF0C00,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFF9FFFFFFF0FF, 0x3FFFFFFFFFF, 0x7FF,
                    0xFFFFFFFFF0000000, 0xFFFFFFFFFF, 0xFFFFFFFFFFF00000, 0xFFFF003FFFFFFF9F,
                    0xFFFFFFFFFE000007, 0xCFFFFFFFF0FFFFFF, 0xFFCFFFFFFFFFFFFF,
                    0xFFFFFFFFFFBFFFFF, 0x7E000000000, 0x30000, 0xFFFFFFFFFBFFFFFF,
                    0xFFFFFFFFFFFFF, 0xFFFF0000003FFFFF, 0xC0C00001000C0010, 0x18000000,
                    0xFFC30000, 0x803FFFFFFFFF, 0xFFFFFC007FFFFFFF, 0xFFFFFFFF000100FF,
                    0x1FFFFFFFFFC00, 0xFFFFFFFFFFFF0000, 0x7F, 0x3007FFFFF, 0x600,
                    0x3C00F0000000000, 0x380000000000000, 0xC0008000000, 0x20000000000,
                    0xFFFC000000000000, 0x7, 0xFFFF, 0xF000000000008000, 0x27400000000,
                    0x4000000070000810, 0x50000001, 0x30007F7F00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 5, 6, 7, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 13, 13,
                    14, 13, 13, 13, 13, 13, 13, 15, 0, 0, 16, 13, 17, 13, 13, 13, 18, 19, 20,
                    21, 22, 13, 23, 0, 0, 13, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25,
                    26, 27, 28, 29, 13, 13, 13, 13, 13, 13, 13, 13, 30, 31, 32, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0,
                    0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 35, 0, 0, 0, 0,
                    0, 0, 36, 0, 0, 0, 0, 37, 13, 38, 39, 40, 13, 41, 42, 43, 44, 0, 0, 13,
                    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 45, 13, 46, 13,
                    47, 48, 49, 50, 51, 13, 13, 13, 13, 13, 52, 53, 54, 13, 13, 55, 14, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF80000000000000, 0xFE00000000000000, 0x11FFF73FF,
                    0x1FFFFFFFFFFF0000, 0x180000000000000, 0x100, 0xC000, 0x8000000000000000,
                    0x3FFFFFFE00000, 0xF000000000000000, 0x20, 0x10000000, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFF0000, 0xF,
                    0x3FFFFFFFFFFFFF, 0xFFFFFE7FFFFFFFFF, 0x1C1FFFFFFFFF, 0xFFFFC3FFFFFFF018,
                    0x7FFFFFFFFFF, 0x23, 0x7FFFFF, 0x800000008000002, 0x20000000200000,
                    0x800000008000, 0x20000000200, 0x8, 0x780000000000000, 0xFFDFE00000000000,
                    0x6F, 0x8000, 0x1100000000000, 0x400000000000, 0x3000000000000,
                    0xFFFF0FFFFFFFFFFF, 0xFFFE7FFF000FFFFF, 0x3FFFFFFFFEFFFE,
                    0xFFFFFFFFFFFFE000, 0x3FFFFFFFFFFF, 0xFFFFFFC000000000, 0xFFFFFFFFFFF0007,
                    0x3F000301FF, 0x1FFF1FFFF0FFFFFF, 0xF87FFFFFFFFFFFFF, 0x10FFF03FFFFFF,
                    0xFFFFFFFFFFFF0FFF, 0xFFFFFFFF03FF00FF, 0xFFF3FFFFFFF00FF, 0x3,
                    0x1FFF3FFF000FFFFF, 0xFFFFFFFFFFFF83FF, 0x1FF03FF9FFFC07F,
                    0xFFFFFFFFFFF7FFFF,
                ],
                };

                pub const TITLECASE_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0x4000000000920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1000FF00FF00FF00, 0x1000000000001000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const UNASSIGNED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x300000000000000, 0x40000280F, 0,
                    0, 0, 0, 0, 0x1000000000000, 0x1800000, 0x11800, 0xFFE078000000FF00, 0, 0,
                    0, 0, 0x4000, 0x1800, 0xFFFC000000000000, 0x1800000000000000,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
                    19, 20, 21, 22, 23, 24, 25, 3, 26, 27, 28, 3, 3, 3, 29, 3, 3, 3, 3, 3, 30,
                    31, 32, 33, 34, 35, 36, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 37, 38, 39, 40, 3,
                    41, 35, 38, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 3, 52, 3, 53, 54, 55,
                    56, 57, 3, 3, 3, 3, 3, 3, 3, 3, 58, 59, 60, 61, 3, 62, 63, 64, 3, 3, 65,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 66, 67, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 69, 3, 3, 3, 3, 70, 71, 72,
                    73, 74, 3, 75, 76, 77, 3, 3, 3, 78, 3, 79, 80, 3, 81, 3, 82, 83, 84, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 85, 86, 3, 3, 3, 3, 87, 3, 3, 88, 3, 3, 3, 89, 90, 88, 3,
                    91, 3, 92, 3, 93, 94, 95, 3, 96, 97, 46, 3, 98, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 99, 100, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 101, 3, 102, 103, 104, 3, 105, 3, 3, 3, 3, 3, 3, 106, 107,
                    35, 108, 3, 109, 79, 3, 110, 111,
                ],
                tree2_level2: &[
                    0x8000C00000000000, 0xF800B0000000, 0x7C8000, 0, 0xC3A020000066010,
                    0x800000304F7F8660, 0x2C92020000067811, 0xFF80003FA1FDC678,
                    0xC12020000044011, 0x1FC0030FFFEC440, 0xC12020000066011,
                    0xFF0000304F1FC660, 0x3C0038E729C23813, 0xF800003FFF7EC238,
                    0xC00020000022000, 0x7F0030D89FC220, 0xC10020000022000,
                    0xFFF100309F9FC220, 0x22000, 0x30000F0220, 0xD004000003800011,
                    0xFFE3003F00A07B80, 0x7800000000000001, 0xFFFFFFFFF0000000,
                    0xC000005000000829, 0xFFFFFFFF0C0080A0, 0x1E00000000100,
                    0x2000000001000000, 0xFFFFFFFFF8002000, 0xDF40, 0xC280C200,
                    0x80C200000000C200, 0x8000C2, 0xC20000, 0xE000000018000000, 0xFC000000,
                    0xC0C0000000000000, 0xE0000000, 0xFE00000000000000, 0xFF8000007FC00000,
                    0xFFF22000FFF00000, 0xFC00FC00C0000000, 0xF80000000000,
                    0xFFC0000000000000, 0xF000F00080000000, 0xFFE0C0000000000E,
                    0xF00000000000, 0x3800FC00, 0x30000000, 0x6000000080000000,
                    0xC000FC00FC00, 0xFFFFFFFFFFFF8000, 0x2000, 0xFF0000000000000,
                    0x700000000000000, 0x1C00, 0x180000000000F800, 0xF80000000000FF00,
                    0xC0C00000, 0xC00000005500C0C0, 0x20000000000000, 0x8023000010300020,
                    0xC002000000000, 0xE0008000, 0xFFFE00000000FFFE, 0xF000,
                    0xFFFFFC0000000000, 0xFFFFF800, 0x30000000000000, 0x400000,
                    0x1F0000000000000, 0xDF4000000000, 0x7FFE7F0000000000, 0x80808080FF800000,
                    0x80808080, 0xFFFFFFFFC0000000, 0x4000000, 0xFFF0000000000000,
                    0xFFFFFFC00000, 0x1, 0x1800000, 0x100000000001F, 0x8000, 0x7FC000000000,
                    0x80000000, 0xE000, 0xFF80, 0xFFFFF00000000000, 0xFF00000000000000,
                    0x3FFFFE014C000, 0xFC00E00000000000, 0xFC003FC0, 0xE00000007FF00000,
                    0x800000003C004000, 0xFF80000000000000, 0xC00C000, 0xFF80000007FFFFF8,
                    0x8080FF818181, 0xFC00C00000000000, 0xFFF000000000, 0xF000000000000780,
                    0xC00000000000, 0xFFFFFFFFFC000000, 0xA08000001F07FF80, 0x24, 0x7FFF8,
                    0x30000, 0xFFFFFFFF7F00, 0x20F08000080000, 0x6000000000000000,
                    0x8000000000000000, 0xC1FF8080E3030303,
                ],
                tree3_level1: &[
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 13, 14, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 15, 16, 17, 7, 18, 19, 7, 20, 21, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 23, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 23,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 2, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 2, 2, 14, 15, 16, 17,
                    18, 19, 2, 2, 2, 2, 20, 21, 22, 7, 23, 24, 25, 26, 27, 7, 28, 29, 30, 31,
                    32, 33, 34, 35, 36, 7, 2, 37, 38, 39, 40, 41, 42, 7, 7, 43, 44, 45, 16,
                    46, 47, 48, 2, 49, 2, 50, 51, 52, 2, 53, 54, 55, 56, 57, 58, 59, 60, 61,
                    2, 62, 2, 63, 7, 7, 64, 65, 2, 66, 67, 68, 69, 70, 7, 7, 71, 7, 72, 73,
                    74, 75, 76, 77, 2, 78, 79, 80, 81, 7, 7, 82, 83, 84, 85, 7, 86, 87, 88, 7,
                    7, 7, 7, 89, 90, 91, 92, 93, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 94,
                    7, 2, 95, 2, 2, 2, 96, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 97,
                    38, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 70, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    67, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 80, 99, 100, 101, 2, 102, 103, 7, 7,
                    7, 7, 7, 7, 67, 7, 7, 7, 2, 91, 7, 2, 104, 105, 106, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 107, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 108, 37, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 109, 2, 2, 2, 2, 110, 111, 2, 2, 2, 2, 2,
                    71, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 112, 113, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 2, 2, 2, 67, 2, 2, 2, 2, 2, 2, 19, 7, 114, 115, 2, 96, 2, 2,
                    2, 116, 117, 2, 2, 118, 2, 119, 7, 120, 2, 121, 7, 7, 2, 122, 123, 124,
                    125, 126, 2, 2, 2, 2, 127, 2, 2, 2, 2, 128, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    129, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 130, 7, 7, 7, 131,
                    132, 133, 7, 134, 135, 7, 7, 7, 7, 136, 137, 7, 7, 7, 7, 7, 7, 7, 138, 7,
                    7, 7, 139, 7, 7, 7, 7, 7, 7, 7, 140, 2, 2, 2, 141, 2, 142, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 143, 144, 7, 145, 7, 7, 7, 146, 147, 148, 149, 7, 7, 7,
                    7, 150, 2, 151, 152, 2, 2, 132, 153, 154, 155, 7, 7, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 156, 2, 157, 2, 158, 159, 160, 161, 55, 2, 2, 2,
                    2, 2, 162, 163, 164, 2, 2, 165, 67, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 32, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 67, 2, 2,
                    2, 166, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 167, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 168, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 65, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2,
                    2, 2, 2, 2, 2, 65, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 169, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 170, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 171, 2, 7, 7, 2, 2, 2, 170, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                    7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 172,
                ],
                tree3_level3: &[
                    0x4800008000001000, 0xFFFFFFFFC000C000, 0, 0xF800000000000000,
                    0x70000000000078, 0xFFFFFFFEE0008000, 0xC00000000000FFFF,
                    0xFFFFFFFFFFFFFFFF, 0xE0000000, 0xF0000000FFFE0000, 0x1FF000000000,
                    0xF80000000000F800, 0x40000000, 0xFFFFFFFFFFC000F0, 0xFC00C0000000,
                    0xF000000000F00000, 0xFF0000000000, 0x8007FF000000000, 0xE404000400480800,
                    0xFFF0000000000000, 0xFF80000000000000, 0xFFFFFF00FFC00000,
                    0xF802000000000040, 0x6E400000000002C0, 0x400000, 0xFFFF007F80000000,
                    0x7C80000FFFFFFFF, 0x7C00000070000000, 0xF00000000000000, 0x30000,
                    0x78C0000001100F90, 0xFE00FE00, 0xFFFFFFFF00000000, 0xFF80078000000000,
                    0x1C0000000000000, 0xF8000000C00000, 0xFFFF01FFE1FC0000,
                    0xFFFFFFFFFFFFFE00, 0xFFF8000000000000, 0x3F8000000000000,
                    0xFC00FF0000000000, 0x1C000000000, 0xFFFFFFFFFFFF3FC0, 0x80000000FFFFFFFF,
                    0xFFFCC40000000000, 0xFFFFFFFFFFFFFE3, 0xFFFFFC000000, 0xFFFFFFFFFC00,
                    0xFF800000FFFFF000, 0x7FC000000003C000, 0xFC00FE000000DFF8,
                    0x20000000000000, 0xFF8000000000FF00, 0xFFE0000100000000, 0x40000,
                    0xFFFFFFFFFFFFFFFC, 0xFC0040004280, 0xFC00F80000000000, 0x412020000066010,
                    0xFFE0E0301F7EC660, 0x4000000000B400, 0xFFFFFFF9FE40085A,
                    0xFFFFFFFC10000000, 0xFFFFFFFFFC00FF00, 0xC0000000000000,
                    0xFFFFFFFFC0000000, 0xFFFFE000FC00FFE0, 0xFC00000000000000,
                    0xFFFFFFF00000FC00, 0xF00018000000, 0xFFFFFFFFFFFFFF80,
                    0xF000000000000000, 0xFFFFFFFF, 0x7FF8000000000000, 0x640000000900D80,
                    0xFFFFFFFFFC00FF80, 0x300FFFFFFFF, 0xFFFFFFE003000000, 0xFF00,
                    0xFFF800000000, 0xFE00000000000000, 0xFFFFFFFFFFFFFC00,
                    0xFC00FFFC00000000, 0x80000000000200, 0xE0000000FFC0, 0xFF80010000030000,
                    0x4B80000000000480, 0x240FC00FF00, 0xFFFFFC00FE048000, 0xFE000000FFFFFFFF,
                    0x3800000000020000, 0xFFFFFFFFF8000000, 0xFFFEFFFFFFFFFFFF,
                    0x7FFC000000000000, 0xFFFFFFFFFC000000, 0xFFE0800000000000,
                    0xFFFFFFFFFFFFFFF0, 0xFFFF, 0xFFC00000, 0x3C0080000000,
                    0x8000000000000000, 0xFFC0C0000000FC00, 0x1F0000040400FFC0,
                    0xFFFFFFFFFFFF0000, 0x7800, 0xFFFFFFFF00007F00, 0xFFFCFFE0FFFFFFFF,
                    0xFF00000000000000, 0x7FFFFFFFFFC00000, 0x9010FFFFFFFFFFFF,
                    0xFFFBFFF800000000, 0xFF0FFFD8FFFF, 0xE000F80000000000,
                    0xFFFFFFF00C00FE00, 0xC00000000000, 0xFF80, 0xFFC0000000000000,
                    0x18000000000, 0xFFFFF80000000000, 0xFFFFFFFFFFFFFFC0, 0xFFF00000FFF00000,
                    0xFE000000FF800000, 0x200000, 0x1400219B20000000, 0x10,
                    0x8400000020201840, 0x203A0, 0xC000000000, 0x3000, 0xFFFF000107FFF000,
                    0xFFFFF81F80000000, 0xF82406000080, 0xFFFFC00000000000,
                    0xFFFFFFFFFFFF7FFF, 0xC000E00000000000, 0xFFFFFFFFFFFF3C00,
                    0xFFFF80000000FFFF, 0x7C00000000000000, 0xFC0000000000FFFF,
                    0x780000000000FFFF, 0x80009080FFFFFFFF, 0xFFFFFFFFFF800060,
                    0xFFFFFFFF3C00F000, 0x1FFFFFFFFFFFF, 0xFFE0000000000000,
                    0xC000000000000001, 0xF508016900000010, 0xA10808695569157B,
                    0xF0000411F0000400, 0xFFFCFFFFFFFFFFFF, 0xF00000000000, 0x18000FFF00000,
                    0xFFC0000000010001, 0x3FFFFFFFFF, 0xF00000000000FFF8, 0xFFFFFFC0FFFCFE00,
                    0xE000E0000F000000, 0x780000000000000, 0xFFFEF000FC000000, 0xF000,
                    0xFC00FF00, 0xF000C0000000FF00, 0xE000C000FFF00000, 0x7C00,
                    0xFE00FC0060003F80, 0x80000, 0xC0000000, 0xFFFC00000000, 0xFFFE00000000,
                    0xF800, 0xFFFF000000000000, 0xFFFFFFFD, 0xC000000000000000,
                ],
                };

                pub const UPPERCASE_LETTER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE, 0, 0x7F7FFFFF, 0xAA55555555555555, 0x2B555555555554AA,
                    0x11AED2D5B1DBCED6, 0x55D255554AAAA490, 0x6C05555555555555, 0x557A, 0, 0,
                    0, 0x8045000000000000, 0xFFBFFFED740, 0xE6905555551C8000, 0xFFFFFFFFFFFF,
                    0x5555555500000000, 0x5555555555555401, 0x5555555555552AAB,
                    0xFFFE555555555555, 0x7FFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 5, 5, 6, 5, 7, 8, 9, 10, 0, 0, 0,
                    0, 11, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 5,
                    16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 0, 19, 20, 21, 22, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x20BF, 0x3FFFFFFFFFFFFF, 0xE7FFFFFFFFFF0200,
                    0x5555555555555555, 0x5555555540155555, 0xFF00FF003F00FF00,
                    0xFF00AA003F00, 0xF00000000000000, 0xF001F000F000F00, 0xC00F3D503E273884,
                    0x20, 0x8, 0xFFFFFFFFFFFF, 0xC025EA9D00000000, 0x4280555555555,
                    0x155555555555, 0x5555555, 0x5554555400000000, 0x6A00555555555555,
                    0x555F7D5555452855, 0x20000015411AF5, 0x7FFFFFE00000000,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 4, 5, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    6, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11,
                    12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF, 0xFFFF000000000000, 0xFFFFF, 0xF7FF000000000000,
                    0x37F7FF, 0x7FFFFFFFFFFFF, 0x3FFFFF0000, 0xFFFFFFFF00000000, 0xFFFFFFFF,
                    0xFFF0000003FFFFFF, 0xFFFFFF0000003FFF, 0x3FDE64D0000003, 0x3FFFFFF0000,
                    0x7B0000001FDFE7B0, 0xFFFFF0000001FC5F, 0x3FFFFFF0000003F, 0x3FFFFFF00000,
                    0xF0000003FFFFFF00, 0xFFFF0000003FFFFF, 0xFFFFFF00000003FF,
                    0x7FFFFFC00000001, 0x1FFFFFF0000000, 0x7FFFFFC00000, 0x1FFFFFF0000, 0x400,
                    0x3FFFFFFFF,
                ],
                };
            }
            // Copy from category::BY_NAME
            static CATEGORY_PROPERTY_NAMES = [
                ("Cased_Letter", CASED_LETTER), ("Close_Punctuation", CLOSE_PUNCTUATION),
                ("Connector_Punctuation", CONNECTOR_PUNCTUATION), ("Control", CONTROL),
                ("Currency_Symbol", CURRENCY_SYMBOL),
                ("Dash_Punctuation", DASH_PUNCTUATION), ("Decimal_Number", DECIMAL_NUMBER),
                ("Enclosing_Mark", ENCLOSING_MARK),
                ("Final_Punctuation", FINAL_PUNCTUATION), ("Format", FORMAT),
                ("Initial_Punctuation", INITIAL_PUNCTUATION), ("Letter", LETTER),
                ("Letter_Number", LETTER_NUMBER), ("Line_Separator", LINE_SEPARATOR),
                ("Lowercase_Letter", LOWERCASE_LETTER), ("Mark", MARK),
                ("Math_Symbol", MATH_SYMBOL), ("Modifier_Letter", MODIFIER_LETTER),
                ("Modifier_Symbol", MODIFIER_SYMBOL), ("Nonspacing_Mark", NONSPACING_MARK),
                ("Number", NUMBER), ("Open_Punctuation", OPEN_PUNCTUATION),
                ("Other", OTHER), ("Other_Letter", OTHER_LETTER),
                ("Other_Number", OTHER_NUMBER), ("Other_Punctuation", OTHER_PUNCTUATION),
                ("Other_Symbol", OTHER_SYMBOL),
                ("Paragraph_Separator", PARAGRAPH_SEPARATOR), ("Private_Use", PRIVATE_USE),
                ("Punctuation", PUNCTUATION), ("Separator", SEPARATOR),
                ("Space_Separator", SPACE_SEPARATOR), ("Spacing_Mark", SPACING_MARK),
                ("Surrogate", SURROGATE), ("Symbol", SYMBOL),
                ("Titlecase_Letter", TITLECASE_LETTER), ("Unassigned", UNASSIGNED),
                ("Uppercase_Letter", UPPERCASE_LETTER),
            ];

            mod script
            {
                // DO NOT EDIT THIS FILE. IT WAS AUTOMATICALLY GENERATED BY:
                //
                //   ucd-generate script --trie-set ./target/ucd/
                //
                // Unicode version: 16.0.0.
                //
                // ucd-generate 0.3.1 is available on crates.io.

                pub const BY_NAME: &'static [(&'static str, &'static ::ucd_trie::TrieSet)] = &[
                ("Adlam", ADLAM), ("Ahom", AHOM),
                ("Anatolian_Hieroglyphs", ANATOLIAN_HIEROGLYPHS), ("Arabic", ARABIC),
                ("Armenian", ARMENIAN), ("Avestan", AVESTAN), ("Balinese", BALINESE),
                ("Bamum", BAMUM), ("Bassa_Vah", BASSA_VAH), ("Batak", BATAK),
                ("Bengali", BENGALI), ("Bhaiksuki", BHAIKSUKI), ("Bopomofo", BOPOMOFO),
                ("Brahmi", BRAHMI), ("Braille", BRAILLE), ("Buginese", BUGINESE),
                ("Buhid", BUHID), ("Canadian_Aboriginal", CANADIAN_ABORIGINAL),
                ("Carian", CARIAN), ("Caucasian_Albanian", CAUCASIAN_ALBANIAN),
                ("Chakma", CHAKMA), ("Cham", CHAM), ("Cherokee", CHEROKEE),
                ("Chorasmian", CHORASMIAN), ("Common", COMMON), ("Coptic", COPTIC),
                ("Cuneiform", CUNEIFORM), ("Cypriot", CYPRIOT),
                ("Cypro_Minoan", CYPRO_MINOAN), ("Cyrillic", CYRILLIC),
                ("Deseret", DESERET), ("Devanagari", DEVANAGARI),
                ("Dives_Akuru", DIVES_AKURU), ("Dogra", DOGRA), ("Duployan", DUPLOYAN),
                ("Egyptian_Hieroglyphs", EGYPTIAN_HIEROGLYPHS), ("Elbasan", ELBASAN),
                ("Elymaic", ELYMAIC), ("Ethiopic", ETHIOPIC), ("Garay", GARAY),
                ("Georgian", GEORGIAN), ("Glagolitic", GLAGOLITIC), ("Gothic", GOTHIC),
                ("Grantha", GRANTHA), ("Greek", GREEK), ("Gujarati", GUJARATI),
                ("Gunjala_Gondi", GUNJALA_GONDI), ("Gurmukhi", GURMUKHI),
                ("Gurung_Khema", GURUNG_KHEMA), ("Han", HAN), ("Hangul", HANGUL),
                ("Hanifi_Rohingya", HANIFI_ROHINGYA), ("Hanunoo", HANUNOO),
                ("Hatran", HATRAN), ("Hebrew", HEBREW), ("Hiragana", HIRAGANA),
                ("Imperial_Aramaic", IMPERIAL_ARAMAIC), ("Inherited", INHERITED),
                ("Inscriptional_Pahlavi", INSCRIPTIONAL_PAHLAVI),
                ("Inscriptional_Parthian", INSCRIPTIONAL_PARTHIAN), ("Javanese", JAVANESE),
                ("Kaithi", KAITHI), ("Kannada", KANNADA), ("Katakana", KATAKANA),
                ("Kawi", KAWI), ("Kayah_Li", KAYAH_LI), ("Kharoshthi", KHAROSHTHI),
                ("Khitan_Small_Script", KHITAN_SMALL_SCRIPT), ("Khmer", KHMER),
                ("Khojki", KHOJKI), ("Khudawadi", KHUDAWADI), ("Kirat_Rai", KIRAT_RAI),
                ("Lao", LAO), ("Latin", LATIN), ("Lepcha", LEPCHA), ("Limbu", LIMBU),
                ("Linear_A", LINEAR_A), ("Linear_B", LINEAR_B), ("Lisu", LISU),
                ("Lycian", LYCIAN), ("Lydian", LYDIAN), ("Mahajani", MAHAJANI),
                ("Makasar", MAKASAR), ("Malayalam", MALAYALAM), ("Mandaic", MANDAIC),
                ("Manichaean", MANICHAEAN), ("Marchen", MARCHEN),
                ("Masaram_Gondi", MASARAM_GONDI), ("Medefaidrin", MEDEFAIDRIN),
                ("Meetei_Mayek", MEETEI_MAYEK), ("Mende_Kikakui", MENDE_KIKAKUI),
                ("Meroitic_Cursive", MEROITIC_CURSIVE),
                ("Meroitic_Hieroglyphs", MEROITIC_HIEROGLYPHS), ("Miao", MIAO),
                ("Modi", MODI), ("Mongolian", MONGOLIAN), ("Mro", MRO),
                ("Multani", MULTANI), ("Myanmar", MYANMAR), ("Nabataean", NABATAEAN),
                ("Nag_Mundari", NAG_MUNDARI), ("Nandinagari", NANDINAGARI),
                ("New_Tai_Lue", NEW_TAI_LUE), ("Newa", NEWA), ("Nko", NKO),
                ("Nushu", NUSHU), ("Nyiakeng_Puachue_Hmong", NYIAKENG_PUACHUE_HMONG),
                ("Ogham", OGHAM), ("Ol_Chiki", OL_CHIKI), ("Ol_Onal", OL_ONAL),
                ("Old_Hungarian", OLD_HUNGARIAN), ("Old_Italic", OLD_ITALIC),
                ("Old_North_Arabian", OLD_NORTH_ARABIAN), ("Old_Permic", OLD_PERMIC),
                ("Old_Persian", OLD_PERSIAN), ("Old_Sogdian", OLD_SOGDIAN),
                ("Old_South_Arabian", OLD_SOUTH_ARABIAN), ("Old_Turkic", OLD_TURKIC),
                ("Old_Uyghur", OLD_UYGHUR), ("Oriya", ORIYA), ("Osage", OSAGE),
                ("Osmanya", OSMANYA), ("Pahawh_Hmong", PAHAWH_HMONG),
                ("Palmyrene", PALMYRENE), ("Pau_Cin_Hau", PAU_CIN_HAU),
                ("Phags_Pa", PHAGS_PA), ("Phoenician", PHOENICIAN),
                ("Psalter_Pahlavi", PSALTER_PAHLAVI), ("Rejang", REJANG), ("Runic", RUNIC),
                ("Samaritan", SAMARITAN), ("Saurashtra", SAURASHTRA), ("Sharada", SHARADA),
                ("Shavian", SHAVIAN), ("Siddham", SIDDHAM), ("SignWriting", SIGNWRITING),
                ("Sinhala", SINHALA), ("Sogdian", SOGDIAN), ("Sora_Sompeng", SORA_SOMPENG),
                ("Soyombo", SOYOMBO), ("Sundanese", SUNDANESE), ("Sunuwar", SUNUWAR),
                ("Syloti_Nagri", SYLOTI_NAGRI), ("Syriac", SYRIAC), ("Tagalog", TAGALOG),
                ("Tagbanwa", TAGBANWA), ("Tai_Le", TAI_LE), ("Tai_Tham", TAI_THAM),
                ("Tai_Viet", TAI_VIET), ("Takri", TAKRI), ("Tamil", TAMIL),
                ("Tangsa", TANGSA), ("Tangut", TANGUT), ("Telugu", TELUGU),
                ("Thaana", THAANA), ("Thai", THAI), ("Tibetan", TIBETAN),
                ("Tifinagh", TIFINAGH), ("Tirhuta", TIRHUTA), ("Todhri", TODHRI),
                ("Toto", TOTO), ("Tulu_Tigalari", TULU_TIGALARI), ("Ugaritic", UGARITIC),
                ("Vai", VAI), ("Vithkuqi", VITHKUQI), ("Wancho", WANCHO),
                ("Warang_Citi", WARANG_CITI), ("Yezidi", YEZIDI), ("Yi", YI),
                ("Zanabazar_Square", ZANABAZAR_SQUARE),
                ];

                pub const ADLAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xC3FF0FFF,
                ],
                };

                pub const AHOM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF0FFFE7FFFFFF, 0x7F,
                ],
                };

                pub const ANATOLIAN_HIEROGLYPHS: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x7F,
                ],
                };

                pub const ARABIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFFFFFF77FFEFDF, 0xFFFEFFFFFFC007FE, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFDFFFFFFF, 0, 0xFFFFFFFFFFFF0000, 0, 0,
                ],
                tree2_level1: &[
                    0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5,
                    6, 5, 5, 5, 5, 7, 5, 8, 9, 0, 10, 5, 11, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF000000000000, 0xFFFFFFFFFF837FFF, 0xFFFFFFFBFFFFFFFF,
                    0xFFFFFFFFFFFF0000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFF80007,
                    0x3FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFCFFFF, 0xFFFF0000000080FF,
                    0xFFDF000000000000, 0x1FFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFF00000000, 0xF00000000000001C, 0xAF7FE96FFFFFFEF,
                    0x5EF7F796AA96EA84, 0xFFFFBEE0FFFFBFF, 0x3000000000000,
                ],
                };

                pub const ARMENIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFE000000000000, 0xFFFFFFFFFE7FFFFF, 0xE7FF, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF80000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const AVESTAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFE3FFFFFFFFFFFFF,
                ],
                };

                pub const BALINESE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFDFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BAMUM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                    1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x1FFFFFFFFFFFFFF,
                ],
                };

                pub const BASSA_VAH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3F3FFFFFFF0000,
                ],
                };

                pub const BATAK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF00FFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BENGALI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3C5FDFFFFF99FEF, 0x7FFFFFCFB080799F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BHAIKSUKI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF7FFFFFFFFFFDFF, 0x1FFFFFFF003F,
                ],
                };

                pub const BOPOMOFO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xC0000000000, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFE0, 0xFFFFFFFF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BRAHMI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x803FFFFFFFFC3FFF,
                ],
                };

                pub const BRAILLE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BUGINESE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xCFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const BUHID: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CANADIAN_ABORIGINAL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF000000000000, 0x3FFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000,
                ],
                };

                pub const CARIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000, 0x1FFFF,
                ],
                };

                pub const CAUCASIAN_ALBANIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x800FFFFFFFFF,
                ],
                };

                pub const CHAKMA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFDFFFFFFFFFFFFF, 0xFF,
                ],
                };

                pub const CHAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FFFFFFFFFFFFF, 0xF3FF3FFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CHEROKEE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x3F3FFFFFFFFFFFFF, 0xFFFF000000000000,
                    0xFFFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CHORASMIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0xFFF,
                ],
                };

                pub const COMMON: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0xFFFFFFFFFFFFFFFF, 0xF8000001F8000001, 0xFBFFFBFFFFFFFFFF,
                    0x80000000800000, 0, 0, 0, 0, 0, 0, 0xFE00000000000000,
                    0xFFFFF3E0FFFFFFFF, 0, 0x4010000000000000, 0xA0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0x88001020, 0x1, 0, 0x20000000, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
                    0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 12,
                    13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 17, 17, 17,
                    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 17, 17, 17, 17,
                    17, 17, 17, 17, 17, 20, 21, 17, 0, 0, 0, 0, 0, 0, 0, 0, 17, 22, 0, 0, 0,
                    0, 0, 23, 24, 0, 25, 26, 0, 0, 27, 28, 29, 30, 17, 31, 0, 32, 17, 17, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 34, 0, 35, 0, 0, 0, 36, 0, 0, 37, 0,
                    0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 39, 0, 0, 0, 40, 41, 0, 3, 42, 43, 44, 45,
                ],
                tree2_level2: &[
                    0, 0x400000000, 0x3000000000, 0x8000000000000000, 0x1E00000,
                    0x800000000000000, 0x380000000000, 0x60000000000000, 0x2C,
                    0x4EFDE0200080000, 0xFFFFFFFFFFFFCFFF, 0x7FF1FFDFFFFFFFFF,
                    0xFFFFFFFF00007FFF, 0x1, 0xFFFBF3BFFFFFFFFF, 0xFFFFBFFF,
                    0xFFFFFFFFFFFF0E00, 0xFFFFFFFFFFFFFFFF, 0x3FFFFFFFFFF, 0xFFFFFFFF000007FF,
                    0xFFCFFFFFFFFFFFFF, 0xFFFFFFFFFFBFFFFF, 0x3FFFFFFF, 0xFFFF000000000000,
                    0xF0FF0001FFFFFF5F, 0x118000000, 0x1800000000000000, 0xFFFF0000,
                    0x803FFFFFFFFF, 0xFFFFFFFF00000000, 0x80000000FFFFFFFF,
                    0x800000000000FFFF, 0xFFFFFFFFFF000000, 0x3FFFFFFFF, 0x700,
                    0x3FF000000000000, 0x400000000000, 0x8000, 0xC0008000000,
                    0xC000000000000000, 0xFFFF000003FF0000, 0xF7FFFF7FFFF, 0xF8000001FFFFFFFE,
                    0x1003FF8000001, 0xC0000000, 0x3E007F7F00000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 1, 0, 2, 3, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6,
                    8, 0, 0, 9, 6, 10, 6, 6, 6, 11, 12, 13, 14, 15, 0, 0, 0, 16, 6, 17, 0, 0,
                    6, 18, 19, 20, 21, 22, 6, 6, 6, 6, 23, 6, 6, 6, 6, 24, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    25, 26, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 6, 29, 30, 6, 6, 31,
                    32, 33, 34, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 35, 6, 36,
                    6, 37, 38, 39, 40, 41, 6, 6, 6, 6, 6, 42, 43, 44, 6, 6, 45, 7, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF8FFFFFFFFFFF87, 0x1FFF0000, 0x1FFFFFFFFFFF0000, 0xFFFFFFE00000000,
                    0xF00000000, 0xFFFFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFF, 0xFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF0000, 0xF, 0x3FFFFFFFFFFFFF, 0xFFFFFE7FFFFFFFFF,
                    0x7FFFC7FFFFFFFFF, 0xFFFFC3FFFFFFF018, 0x7FFFFFFFFFF, 0xFFFFF000FFFFF,
                    0x1FFFFFF007FFFFF, 0xFFFFFFFFFFDFFFFF, 0xEBFFDE64DFFFFFFF,
                    0xFFFFFFFFFFFFFFEF, 0x7BFFFFFFDFDFE7BF, 0xFFFFFFFFFFFDFC5F,
                    0xFFFFFF3FFFFFFFFF, 0xFFFFFFFFFFFFCFFF, 0xFFFE000000000000,
                    0x1FFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFE, 0xFFFF0FFFFFFFFFFF,
                    0xFFFE7FFF000FFFFF, 0x3FFFFFFFFEFFFE, 0x3FFFFFFFFFFF, 0xFFFFFFC000000000,
                    0xFFFFFFFFFFF0006, 0x3F000301FF, 0x1FFF1FFFF0FFFFFF, 0xF87FFFFFFFFFFFFF,
                    0x10FFF03FFFFFF, 0xFFFFFFFFFFFF0FFF, 0xFFFFFFFF03FF00FF,
                    0xFFF3FFFFFFF00FF, 0x3, 0x1FFF3FFF000FFFFF, 0xFFFFFFFFFFFF83FF,
                    0x1FF03FF9FFFC07F, 0xFFFFFFFFFFF7FFFF, 0xFFFFFFFF00000002,
                ],
                };

                pub const COPTIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFC00000000, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFE0FFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const CUNEIFORM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 2, 0, 1, 3, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FFFFFF, 0x1F7FFFFFFFFFFF, 0xF,
                ],
                };

                pub const CYPRIOT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x91BFFFFFFFFFFD3F,
                ],
                };

                pub const CYPRO_MINOAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 2,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFF0000, 0x7FFFFFFFFFFFF,
                ],
                };

                pub const CYRILLIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF9F, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FF, 0x80000000000, 0x100000000000000, 0xFFFFFFFF00000000,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF, 0xC00000000000,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x3FFFFFFFFFFF, 0x8000,
                ],
                };

                pub const DESERET: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFF,
                ],
                };

                pub const DEVANAGARI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFCFFFE1FFFF, 0xFFFFFFFF00000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF,
                ],
                };

                pub const DIVES_AKURU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF9BFFFFFFF6FF27F, 0x3FF007F,
                ],
                };

                pub const DOGRA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFF,
                ],
                };

                pub const DUPLOYAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x1FFF07FFFFFFFFFF, 0xF3FF01FF,
                ],
                };

                pub const EGYPTIAN_HIEROGLYPHS: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF003FFFFF, 0x7FFFFFFFFFFFFFF,
                ],
                };

                pub const ELBASAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF,
                ],
                };

                pub const ELYMAIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFF00000000,
                ],
                };

                pub const ETHIOPIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF3D7F3DFF, 0x7F3DFFFFFFFF3DFF,
                    0xFFFFFFFFFF7FFF3D, 0xFFFFFFFFFF3DFFFF, 0x1FFFFFFFE7FFFFFF, 0x3FFFFFF,
                    0x7F7F7F7F007FFFFF, 0x7F7F7F7F, 0x7F7F007E7E7E,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFF6F7F00000000,
                ],
                };

                pub const GARAY: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFE3FFFFFFFFF, 0xC03F,
                ],
                };

                pub const GEORGIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0xF7FFFFFFFFFF20BF, 0xE7FFFFFFFFFF0000,
                    0x20BFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const GLAGOLITIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7DBF9FFFF7F,
                ],
                };

                pub const GOTHIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x7FF,
                ],
                };

                pub const GRANTHA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF3EDFDFFFFF99FEF, 0x1F1FCFE081399F,
                ],
                };

                pub const GREEK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xBCEF000000000000,
                    0xFFFFFFFBFFFFD750, 0xFFFF0003FFFFFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 4, 5, 6, 7, 0, 0, 0, 0,
                    8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7C000000000, 0x7C3E0000000, 0x8000000000000000, 0xFFFFFFFF3F3FFFFF,
                    0x3FFFFFFFAAFF3F3F, 0xFFDFFFFFFFFFFFFF, 0x7FDCFFFFEFCFFFDF, 0x4000000000,
                    0x2000000000,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x100007FFF, 0x3F,
                ],
                };

                pub const GUJARATI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3EDFDFFFFFBBFEE, 0xFE03FFCF00013BBF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const GUNJALA_GONDI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFDBF00000000, 0x3FF01FB7FFF,
                ],
                };

                pub const GURMUKHI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xD36DFDFFFFF987EE, 0x7FFFC05E023987,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const GURUNG_KHEMA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFFFFFFFFFFFFF,
                ],
                };

                pub const HAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 6, 3, 7, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFBFFFFFF, 0xFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x3FFFFF,
                    0xF0003FE000000A0, 0xFFFF3FFFFFFFFFFF, 0x3FFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 3, 4, 5, 2, 6, 7, 2, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 10, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3000C00000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF, 0x3FFFFFFFFFFFFFF,
                    0xFFFFFFFF3FFFFFFF, 0xFFFF0003FFFFFFFF, 0xFFFF0001FFFFFFFF, 0x3FFFFFFF,
                    0xFFFFFFFFFFFF07FF, 0xFFFFFFFFFFFF,
                ],
                };

                pub const HANGUL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 1, 4, 0, 5, 6, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 10,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xC00000000000, 0xFFFE000000000000, 0x7FFF,
                    0x7FFFFFFF, 0x7FFFFFFF00000000, 0x1FFFFFFF00000000, 0xFFFF000FFFFFFFFF,
                    0xFFFFFFFFFFFF87F, 0x1CFCFCFC,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const HANIFI_ROHINGYA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF00FFFFFFFFFF,
                ],
                };

                pub const HANUNOO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1FFFFF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const HATRAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF837FFFF00000000,
                ],
                };

                pub const HEBREW: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0xFFFFFFFFFFFE0000, 0x1F87FFFFFF00FF, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x5F7FFFFFE0000000, 0xFFDB,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const HIRAGANA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFE, 0xE07FFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, 4, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 0x40000FFFFFFFF, 0x70000, 0x1,
                ],
                };

                pub const IMPERIAL_ARAMAIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFBFFFFF,
                ],
                };

                pub const INHERITED: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF, 0,
                    0, 0, 0, 0x60, 0, 0, 0, 0, 0, 0, 0x10000003FF800, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
                    3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 7,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1E0000, 0xFFFF000000000000, 0x7FFF, 0x31021FDFFF70000,
                    0xFFFFFFFFFFFFFFFF, 0x3000, 0x1FFFFFFFF0000, 0x3C0000000000, 0x6000000,
                    0x3FFF0000FFFF,
                ],
                tree3_level1: &[
                    0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 4, 5, 0, 0, 0, 0, 0, 0, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                    8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x2000000000000000, 0x100000000, 0x800000000000000, 0xFFFF3FFFFFFFFFFF,
                    0x7F, 0xF800038000000000, 0x3C0000000FE7, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFF,
                ],
                };

                pub const INSCRIPTIONAL_PAHLAVI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF07FFFF00000000,
                ],
                };

                pub const INSCRIPTIONAL_PARTHIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF3FFFFF,
                ],
                };

                pub const JAVANESE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xC3FF3FFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const KAITHI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x2007,
                ],
                };

                pub const KANNADA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3EFFDFFFFFDDFFF, 0xEFFCF60603DDF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const KATAKANA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 3, 0, 0, 0, 4, 5, 6, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFE00000000, 0xE7FFFFFFFFFFFFFF, 0xFFFF000000000000,
                    0x7FFFFFFFFFFF0000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFF, 0xFFFEFFC000000000,
                    0x3FFFFFFF,
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x6FEF000000000000, 0x1, 0x700000000, 0xF000200000,
                ],
                };

                pub const KAWI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    2, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC7FFFFFFFFFDFFFF, 0x7FFFFFF,
                ],
                };

                pub const KAYAH_LI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xBFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const KHAROSHTHI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x873FFFFFFEEFF06F, 0x1FF01FF,
                ],
                };

                pub const KHITAN_SMALL_SCRIPT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2,
                    2, 2, 2, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1000000000, 0xFFFFFFFFFFFFFFFF, 0x80000000003FFFFF,
                ],
                };

                pub const KHMER: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FF03FF3FFFFFFF, 0xFFFFFFFF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const KHOJKI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFBFFFF, 0x3,
                ],
                };

                pub const KHUDAWADI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x3FF07FFFFFFFFFF,
                ],
                };

                pub const KIRAT_RAI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFFFFFFFFFFFFF,
                ],
                };

                pub const LAO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x3FFFFFAFFFFFF7D6, 0xF3FF7F5F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LATIN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0x7FFFFFE07FFFFFE, 0x400040000000000, 0xFF7FFFFFFF7FFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                    0x1FFFFFFFFFFFFFF, 0x1F00000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 5, 6, 0,
                    7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 4, 12, 13, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFF03FFFFFFFFF, 0xFEFFF83C1FFFFFFF, 0x7FFFFFFFFFFFFFFF,
                    0xFFFFFFFFFFFFFFFF, 0x8002000000000000, 0x1FFF0000, 0x40C0000000000,
                    0xFFFFFFFF00004000, 0x1FF, 0xFFFFFFFF00000000, 0xFFFFFFFC00000000,
                    0xFFFFFFFFFFFFF8FF, 0xFFFC00001FEB3FFF, 0xFFFF000000000000, 0x3DFF7FFFFFF,
                    0x7F, 0x7FFFFFE00000000, 0x7FFFFFE,
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FDFFFFFFFFFFBF, 0x7E07FFFFFFF,
                ],
                };

                pub const LEPCHA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF8FFFFFFFFFFFFFF, 0xE3FF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LIMBU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFF0FFF7FFFFFFF, 0xFFF1,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const LINEAR_A: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    1, 1, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFF003FFFFF,
                ],
                };

                pub const LINEAR_B: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4,
                ],
                tree3_level3: &[
                    0xB7FFFF7FFFFFEFFF, 0x3FFF3FFF, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFF, 0,
                ],
                };

                pub const LISU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFF0000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0,
                ],
                tree3_level3: &[
                    0, 0x1000000000000,
                ],
                };

                pub const LYCIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFFFF,
                ],
                };

                pub const LYDIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x83FFFFFF00000000,
                ],
                };

                pub const MAHAJANI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFFFF0000,
                ],
                };

                pub const MAKASAR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFFF00000000,
                ],
                };

                pub const MALAYALAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFDDFFF, 0xFFFFFFCFFFF0FDDF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const MANDAIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x4FFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const MANICHAEAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FF87FFFFFFFFF,
                ],
                };

                pub const MARCHEN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x7FFEFFFFFCFFFF,
                ],
                };

                pub const MASARAM_GONDI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xB47FFFFFFFFFFB7F, 0x3FF00FF,
                ],
                };

                pub const MEDEFAIDRIN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x7FFFFFF,
                ],
                };

                pub const MEETEI_MAYEK: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FFFFF00000000, 0x3FF3FFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const MENDE_KIKAKUI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x7FFF9F,
                ],
                };

                pub const MEROITIC_CURSIVE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF0FFFFFF00000000, 0xFFFFFFFFFFFCFFFF,
                ],
                };

                pub const MEROITIC_HIEROGLYPHS: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF,
                ],
                };

                pub const MIAO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    2, 3, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF87FF, 0xFFFF80FF,
                ],
                };

                pub const MODI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FF001F,
                ],
                };

                pub const MONGOLIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF03FFFFD3, 0x1FFFFFFFFFFFFFF, 0x7FFFFFFFFFF,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFF00000000,
                ],
                };

                pub const MRO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xC3FF7FFFFFFF,
                ],
                };

                pub const MULTANI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFBFFFBD7F,
                ],
                };

                pub const MYANMAR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF00000000, 0xFFFFFFFF00000000,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFF0000,
                ],
                };

                pub const NABATAEAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF807FFFFFFF,
                ],
                };

                pub const NAG_MUNDARI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFFFFFFFFF0000,
                ],
                };

                pub const NANDINAGARI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFCFF00000000, 0x1FFCFFFFFF,
                ],
                };

                pub const NEW_TAI_LUE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF0FFFFFFFFFFF, 0xC7FF03FF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const NEWA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3EFFFFFFF,
                ],
                };

                pub const NKO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0xE7FFFFFFFFFFFFFF,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const NUSHU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 0, 0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x200000000, 0xFFFF000000000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFF,
                ],
                };

                pub const NYIAKENG_PUACHUE_HMONG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFF1FFFFFFFFFFF, 0xC3FF,
                ],
                };

                pub const OGHAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1FFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OL_CHIKI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFF0000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OL_ONAL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x87FFFFFFFFFF0000,
                ],
                };

                pub const OLD_HUNGARIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFFFFFFF, 0xFC07FFFFFFFFFFFF,
                ],
                };

                pub const OLD_ITALIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xE00FFFFFFFFF,
                ],
                };

                pub const OLD_NORTH_ARABIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF,
                ],
                };

                pub const OLD_PERMIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFFFFF0000,
                ],
                };

                pub const OLD_PERSIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000, 0x3FFF0F,
                ],
                };

                pub const OLD_SOGDIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFF,
                ],
                };

                pub const OLD_SOUTH_ARABIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000,
                ],
                };

                pub const OLD_TURKIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x1FF,
                ],
                };

                pub const OLD_UYGHUR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x3FF,
                ],
                };

                pub const ORIYA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3EDFDFFFFF99FEE, 0xFFFFCFB0E0399F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const OSAGE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0xFFFFFFFFF0FFFFF,
                ],
                };

                pub const OSMANYA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF3FFFFFFF,
                ],
                };

                pub const PAHAWH_HMONG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xE0FFFFFBFBFF003F, 0xFFFF,
                ],
                };

                pub const PALMYRENE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000,
                ],
                };

                pub const PAU_CIN_HAU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFFFFFFFFFFF,
                ],
                };

                pub const PHAGS_PA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const PHOENICIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x8FFFFFFF,
                ],
                };

                pub const PSALTER_PAHLAVI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFE001E03FFFF,
                ],
                };

                pub const REJANG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF000000000000, 0x800FFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const RUNIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x1FFC7FFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SAMARITAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                ],
                tree2_level2: &[
                    0x7FFF3FFFFFFFFFFF, 0,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SAURASHTRA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FFC03F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SHARADA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF,
                ],
                };

                pub const SHAVIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFF0000,
                ],
                };

                pub const SIDDHAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFF3FFFFFFFFFFFFF, 0x3FFFFFFF,
                ],
                };

                pub const SIGNWRITING: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFEF8000FFF,
                ],
                };

                pub const SINHALA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x2FFBFFFFFC7FFFEE, 0x1CFFC0FF5F847F,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x1FFFFE00000000,
                ],
                };

                pub const SOGDIAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x3FFFFFF,
                ],
                };

                pub const SORA_SOMPENG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF01FFFFFF0000,
                ],
                };

                pub const SOYOMBO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFF0000, 0x7FFFFFFFF,
                ],
                };

                pub const SUNDANESE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SUNUWAR: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FF0003FFFFFFFF,
                ],
                };

                pub const SYLOTI_NAGRI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1FFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const SYRIAC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0xFFFFFFFFFFFFBFFF, 0xE7FF, 0, 0,
                ],
                tree2_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAGALOG: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x803FFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAGBANWA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xDDFFF00000000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAI_LE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x1F3FFFFFFF0000,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAI_THAM: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFF00000000, 0x9FFFFFFF7FFFFFFF, 0x3FFF03FF03FF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAI_VIET: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xF8000007,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TAKRI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x3FFFFFFFFFFFFFF, 0x3FF,
                ],
                };

                pub const TAMIL: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xC3FFC718D63DC7EC, 0x7FFFFC000813DC7,
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1,
                ],
                tree3_level3: &[
                    0, 0x8003FFFFFFFFFFFF,
                ],
                };

                pub const TANGSA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFF000000000000, 0x7FFFFFFFFFFFFFFF, 0x3FF,
                ],
                };

                pub const TANGUT: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2,
                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x100000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF, 0x1FF,
                ],
                };

                pub const TELUGU: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xF3FFFDFFFFFDDFFF, 0xFF80FFCF27603DDF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const THAANA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0x3FFFFFFFFFFFF, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const THAI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0x7FFFFFFFFFFFFFE, 0xFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TIBETAN: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFE1FFFFFFFFEFF, 0xDFFFFFFFFEFFFFFF, 0x61FDFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TIFINAGH: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFF000000000000, 0x800180FFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const TIRHUTA: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0x3FF00FF,
                ],
                };

                pub const TODHRI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFF,
                ],
                };

                pub const TOTO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x7FFFFFFF0000,
                ],
                };

                pub const TULU_TIGALARI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFBFFFFFFFFF4BFF, 0x601BFF7A5,
                ],
                };

                pub const UGARITIC: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xBFFFFFFF,
                ],
                };

                pub const VAI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFF,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const VITHKUQI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xF7FF000000000000, 0x1BFBFFFBFFB7F7FF,
                ],
                };

                pub const WANCHO: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x83FFFFFFFFFFFFFF,
                ],
                };

                pub const WARANG_CITI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFF00000000, 0x8007FFFFFFFFFFFF,
                ],
                };

                pub const YEZIDI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0x33BFFFFFFFFFF,
                ],
                };

                pub const YI: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level2: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFF1FFF, 0x7F,
                ],
                tree3_level1: &[
                ],
                tree3_level2: &[
                ],
                tree3_level3: &[
                ],
                };

                pub const ZANABAZAR_SQUARE: &'static ::ucd_trie::TrieSet = &::ucd_trie::TrieSet {
                tree1_level1: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                ],
                tree2_level1: &[
                ],
                tree2_level2: &[
                ],
                tree3_level1: &[
                    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0,
                ],
                tree3_level2: &[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0,
                ],
                tree3_level3: &[
                    0, 0xFFFFFFFFFFFFFFFF, 0xFF,
                ],
                };
            }
            // Copy from script::BY_NAME
            static SCRIPT_PROPERTY_NAMES = [
                ("Adlam", ADLAM),
                ("Ahom", AHOM),
                ("Anatolian_Hieroglyphs", ANATOLIAN_HIEROGLYPHS),
                ("Arabic", ARABIC),
                ("Armenian", ARMENIAN),
                ("Avestan", AVESTAN),
                ("Balinese", BALINESE),
                ("Bamum", BAMUM),
                ("Bassa_Vah", BASSA_VAH),
                ("Batak", BATAK),
                ("Bengali", BENGALI),
                ("Bhaiksuki", BHAIKSUKI),
                ("Bopomofo", BOPOMOFO),
                ("Brahmi", BRAHMI),
                ("Braille", BRAILLE),
                ("Buginese", BUGINESE),
                ("Buhid", BUHID),
                ("Canadian_Aboriginal", CANADIAN_ABORIGINAL),
                ("Carian", CARIAN),
                ("Caucasian_Albanian", CAUCASIAN_ALBANIAN),
                ("Chakma", CHAKMA),
                ("Cham", CHAM),
                ("Cherokee", CHEROKEE),
                ("Chorasmian", CHORASMIAN),
                ("Common", COMMON),
                ("Coptic", COPTIC),
                ("Cuneiform", CUNEIFORM),
                ("Cypriot", CYPRIOT),
                ("Cypro_Minoan", CYPRO_MINOAN),
                ("Cyrillic", CYRILLIC),
                ("Deseret", DESERET),
                ("Devanagari", DEVANAGARI),
                ("Dives_Akuru", DIVES_AKURU),
                ("Dogra", DOGRA),
                ("Duployan", DUPLOYAN),
                ("Egyptian_Hieroglyphs", EGYPTIAN_HIEROGLYPHS),
                ("Elbasan", ELBASAN),
                ("Elymaic", ELYMAIC),
                ("Ethiopic", ETHIOPIC),
                ("Georgian", GEORGIAN),
                ("Glagolitic", GLAGOLITIC),
                ("Gothic", GOTHIC),
                ("Grantha", GRANTHA),
                ("Greek", GREEK),
                ("Gujarati", GUJARATI),
                ("Gunjala_Gondi", GUNJALA_GONDI),
                ("Gurmukhi", GURMUKHI),
                ("Han", HAN),
                ("Hangul", HANGUL),
                ("Hanifi_Rohingya", HANIFI_ROHINGYA),
                ("Hanunoo", HANUNOO),
                ("Hatran", HATRAN),
                ("Hebrew", HEBREW),
                ("Hiragana", HIRAGANA),
                ("Imperial_Aramaic", IMPERIAL_ARAMAIC),
                ("Inherited", INHERITED),
                ("Inscriptional_Pahlavi", INSCRIPTIONAL_PAHLAVI),
                ("Inscriptional_Parthian", INSCRIPTIONAL_PARTHIAN),
                ("Javanese", JAVANESE),
                ("Kaithi", KAITHI),
                ("Kannada", KANNADA),
                ("Katakana", KATAKANA),
                ("Kawi", KAWI),
                ("Kayah_Li", KAYAH_LI),
                ("Kharoshthi", KHAROSHTHI),
                ("Khitan_Small_Script", KHITAN_SMALL_SCRIPT),
                ("Khmer", KHMER),
                ("Khojki", KHOJKI),
                ("Khudawadi", KHUDAWADI),
                ("Lao", LAO),
                ("Latin", LATIN),
                ("Lepcha", LEPCHA),
                ("Limbu", LIMBU),
                ("Linear_A", LINEAR_A),
                ("Linear_B", LINEAR_B),
                ("Lisu", LISU),
                ("Lycian", LYCIAN),
                ("Lydian", LYDIAN),
                ("Mahajani", MAHAJANI),
                ("Makasar", MAKASAR),
                ("Malayalam", MALAYALAM),
                ("Mandaic", MANDAIC),
                ("Manichaean", MANICHAEAN),
                ("Marchen", MARCHEN),
                ("Masaram_Gondi", MASARAM_GONDI),
                ("Medefaidrin", MEDEFAIDRIN),
                ("Meetei_Mayek", MEETEI_MAYEK),
                ("Mende_Kikakui", MENDE_KIKAKUI),
                ("Meroitic_Cursive", MEROITIC_CURSIVE),
                ("Meroitic_Hieroglyphs", MEROITIC_HIEROGLYPHS),
                ("Miao", MIAO),
                ("Modi", MODI),
                ("Mongolian", MONGOLIAN),
                ("Mro", MRO),
                ("Multani", MULTANI),
                ("Myanmar", MYANMAR),
                ("Nabataean", NABATAEAN),
                ("Nag_Mundari", NAG_MUNDARI),
                ("Nandinagari", NANDINAGARI),
                ("New_Tai_Lue", NEW_TAI_LUE),
                ("Newa", NEWA),
                ("Nko", NKO),
                ("Nushu", NUSHU),
                ("Nyiakeng_Puachue_Hmong", NYIAKENG_PUACHUE_HMONG),
                ("Ogham", OGHAM),
                ("Ol_Chiki", OL_CHIKI),
                ("Old_Hungarian", OLD_HUNGARIAN),
                ("Old_Italic", OLD_ITALIC),
                ("Old_North_Arabian", OLD_NORTH_ARABIAN),
                ("Old_Permic", OLD_PERMIC),
                ("Old_Persian", OLD_PERSIAN),
                ("Old_Sogdian", OLD_SOGDIAN),
                ("Old_South_Arabian", OLD_SOUTH_ARABIAN),
                ("Old_Turkic", OLD_TURKIC),
                ("Old_Uyghur", OLD_UYGHUR),
                ("Oriya", ORIYA),
                ("Osage", OSAGE),
                ("Osmanya", OSMANYA),
                ("Pahawh_Hmong", PAHAWH_HMONG),
                ("Palmyrene", PALMYRENE),
                ("Pau_Cin_Hau", PAU_CIN_HAU),
                ("Phags_Pa", PHAGS_PA),
                ("Phoenician", PHOENICIAN),
                ("Psalter_Pahlavi", PSALTER_PAHLAVI),
                ("Rejang", REJANG),
                ("Runic", RUNIC),
                ("Samaritan", SAMARITAN),
                ("Saurashtra", SAURASHTRA),
                ("Sharada", SHARADA),
                ("Shavian", SHAVIAN),
                ("Siddham", SIDDHAM),
                ("SignWriting", SIGNWRITING),
                ("Sinhala", SINHALA),
                ("Sogdian", SOGDIAN),
                ("Sora_Sompeng", SORA_SOMPENG),
                ("Soyombo", SOYOMBO),
                ("Sundanese", SUNDANESE),
                ("Syloti_Nagri", SYLOTI_NAGRI),
                ("Syriac", SYRIAC),
                ("Tagalog", TAGALOG),
                ("Tagbanwa", TAGBANWA),
                ("Tai_Le", TAI_LE),
                ("Tai_Tham", TAI_THAM),
                ("Tai_Viet", TAI_VIET),
                ("Takri", TAKRI),
                ("Tamil", TAMIL),
                ("Tangsa", TANGSA),
                ("Tangut", TANGUT),
                ("Telugu", TELUGU),
                ("Thaana", THAANA),
                ("Thai", THAI),
                ("Tibetan", TIBETAN),
                ("Tifinagh", TIFINAGH),
                ("Tirhuta", TIRHUTA),
                ("Toto", TOTO),
                ("Ugaritic", UGARITIC),
                ("Vai", VAI),
                ("Vithkuqi", VITHKUQI),
                ("Wancho", WANCHO),
                ("Warang_Citi", WARANG_CITI),
                ("Yezidi", YEZIDI),
                ("Yi", YI),
                ("Zanabazar_Square", ZANABAZAR_SQUARE),
            ];
        }
        /// Return all available unicode property names
        pub fn unicode_property_names() -> Box<dyn Iterator<Item = &'static str>> {
            Box::new(
                BINARY_PROPERTY_NAMES
                    .iter()
                    .map(|name| *name)
                    .chain(CATEGORY_PROPERTY_NAMES.iter().map(|name| *name))
                    .chain(SCRIPT_PROPERTY_NAMES.iter().map(|name| *name)),
            )
        }

        pub fn by_name(name: &str) -> Option<Box<dyn Fn(char) -> bool>> {
            for property in binary::BY_NAME {
                if name == property.0.to_uppercase() {
                    return Some(Box::new(move |c| property.1.contains_char(c)));
                }
            }

            for property in category::BY_NAME {
                if name == property.0.to_uppercase() {
                    return Some(Box::new(move |c| property.1.contains_char(c)));
                }
            }

            for property in script::BY_NAME {
                if name == property.0.to_uppercase() {
                    return Some(Box::new(move |c| property.1.contains_char(c)));
                }
            }

            None
        }
    }
    /// A trait which parser rules must implement.
    pub trait RuleType: Copy + Debug + Eq + Hash + Ord {}

    impl<T: Copy + Debug + Eq + Hash + Ord> RuleType for T {}
}

pub mod rusqlite
{
    //! Rusqlite is an ergonomic wrapper for using SQLite from Rust.
    use ::
    {
        *,
    };
    /*
    pub use libsqlite3_sys as ffi;
    use std::cell::RefCell;
    use std::default::Default;
    use std::ffi::{CStr, CString};
    use std::fmt;
    use std::os::raw::{c_char, c_int};
    use std::path::Path;
    use std::result;
    use std::str;
    use std::sync::{Arc, Mutex};
    use crate::cache::StatementCache;
    use crate::inner_connection::InnerConnection;
    use crate::raw_statement::RawStatement;
    use crate::types::ValueRef;
    pub use crate::cache::CachedStatement;
    #[cfg(feature = "column_decltype")]
    pub use crate::column::Column;
    pub use crate::error::{to_sqlite_error, Error};
    pub use crate::ffi::ErrorCode;
    #[cfg(feature = "load_extension")]
    pub use crate::load_extension_guard::LoadExtensionGuard;
    pub use crate::params::{params_from_iter, Params, ParamsFromIter};
    pub use crate::row::{AndThenRows, Map, MappedRows, Row, RowIndex, Rows};
    pub use crate::statement::{Statement, StatementStatus};
    #[cfg(feature = "modern_sqlite")]
    pub use crate::transaction::TransactionState;
    pub use crate::transaction::{DropBehavior, Savepoint, Transaction, TransactionBehavior};
    pub use crate::types::ToSql;
    pub use crate::version::*;
    #[cfg(feature = "rusqlite-macros")]
    #[doc(hidden)]
    pub use rusqlite_macros::__bind;
    */
    mod error
    {
        use ::
        {
            *,
        };
        use crate::types::FromSqlError;
        use crate::types::Type;
        use crate::{errmsg_to_string, ffi, Result};
        use std::error;
        use std::fmt;
        use std::os::raw::c_int;
        use std::path::PathBuf;
        use std::str;

        /// Enum listing possible errors from rusqlite.
        #[derive(Debug)]
        #[allow(clippy::enum_variant_names)]
        #[non_exhaustive]
        pub enum Error {
            /// An error from an underlying SQLite call.
            SqliteFailure(ffi::Error, Option<String>),

            /// Error reported when attempting to open a connection when SQLite was
            /// configured to allow single-threaded use only.
            SqliteSingleThreadedMode,

            /// Error when the value of a particular column is requested, but it cannot
            /// be converted to the requested Rust type.
            FromSqlConversionFailure(usize, Type, Box<dyn error::Error + Send + Sync + 'static>),

            /// Error when SQLite gives us an integral value outside the range of the
            /// requested type (e.g., trying to get the value 1000 into a `u8`).
            /// The associated `usize` is the column index,
            /// and the associated `i64` is the value returned by SQLite.
            IntegralValueOutOfRange(usize, i64),

            /// Error converting a string to UTF-8.
            Utf8Error(str::Utf8Error),

            /// Error converting a string to a C-compatible string because it contained
            /// an embedded nul.
            NulError(std::ffi::NulError),

            /// Error when using SQL named parameters and passing a parameter name not
            /// present in the SQL.
            InvalidParameterName(String),

            /// Error converting a file path to a string.
            InvalidPath(PathBuf),

            /// Error returned when an [`execute`](crate::Connection::execute) call
            /// returns rows.
            ExecuteReturnedResults,

            /// Error when a query that was expected to return at least one row (e.g.,
            /// for [`query_row`](crate::Connection::query_row)) did not return any.
            QueryReturnedNoRows,

            /// Error when the value of a particular column is requested, but the index
            /// is out of range for the statement.
            InvalidColumnIndex(usize),

            /// Error when the value of a named column is requested, but no column
            /// matches the name for the statement.
            InvalidColumnName(String),

            /// Error when the value of a particular column is requested, but the type
            /// of the result in that column cannot be converted to the requested
            /// Rust type.
            InvalidColumnType(usize, String, Type),

            /// Error when a query that was expected to insert one row did not insert
            /// any or insert many.
            StatementChangedRows(usize),

            /// Error returned by
            /// [`functions::Context::get`](crate::functions::Context::get) when the
            /// function argument cannot be converted to the requested type.
            #[cfg(feature = "functions")]
            #[cfg_attr(docsrs, doc(cfg(feature = "functions")))]
            InvalidFunctionParameterType(usize, Type),
            /// Error returned by [`vtab::Values::get`](crate::vtab::Values::get) when
            /// the filter argument cannot be converted to the requested type.
            #[cfg(feature = "vtab")]
            #[cfg_attr(docsrs, doc(cfg(feature = "vtab")))]
            InvalidFilterParameterType(usize, Type),

            /// An error case available for implementors of custom user functions (e.g.,
            /// [`create_scalar_function`](crate::Connection::create_scalar_function)).
            #[cfg(feature = "functions")]
            #[cfg_attr(docsrs, doc(cfg(feature = "functions")))]
            
            UserFunctionError(Box<dyn error::Error + Send + Sync + 'static>),

            /// Error available for the implementors of the
            /// [`ToSql`](crate::types::ToSql) trait.
            ToSqlConversionFailure(Box<dyn error::Error + Send + Sync + 'static>),

            /// Error when the SQL is not a `SELECT`, is not read-only.
            InvalidQuery,

            /// An error case available for implementors of custom modules (e.g.,
            /// [`create_module`](crate::Connection::create_module)).
            #[cfg(feature = "vtab")]
            #[cfg_attr(docsrs, doc(cfg(feature = "vtab")))]
            
            ModuleError(String),

            /// An unwinding panic occurs in a UDF (user-defined function).
            UnwindingPanic,

            /// An error returned when
            /// [`Context::get_aux`](crate::functions::Context::get_aux) attempts to
            /// retrieve data of a different type than what had been stored using
            /// [`Context::set_aux`](crate::functions::Context::set_aux).
            #[cfg(feature = "functions")]
            #[cfg_attr(docsrs, doc(cfg(feature = "functions")))]
            GetAuxWrongType,

            /// Error when the SQL contains multiple statements.
            MultipleStatement,
            /// Error when the number of bound parameters does not match the number of
            /// parameters in the query. The first `usize` is how many parameters were
            /// given, the 2nd is how many were expected.
            InvalidParameterCount(usize, usize),

            /// Returned from various functions in the Blob IO positional API. For
            /// example,
            /// [`Blob::raw_read_at_exact`](crate::blob::Blob::raw_read_at_exact) will
            /// return it if the blob has insufficient data.
            #[cfg(feature = "blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "blob")))]
            BlobSizeError,
            /// Error referencing a specific token in the input SQL
            #[cfg(feature = "modern_sqlite")] // 3.38.0
            #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
            SqlInputError {
                /// error code
                error: ffi::Error,
                /// error message
                msg: String,
                /// SQL input
                sql: String,
                /// byte offset of the start of invalid token
                offset: c_int,
            },
            /// Loadable extension initialization error
            #[cfg(feature = "loadable_extension")]
            #[cfg_attr(docsrs, doc(cfg(feature = "loadable_extension")))]
            InitError(ffi::InitError),
            /// Error when the schema of a particular database is requested, but the index
            /// is out of range.
            #[cfg(feature = "modern_sqlite")] // 3.39.0
            #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
            InvalidDatabaseIndex(usize),
        }

        impl PartialEq for Error {
            fn eq(&self, other: &Error) -> bool {
                match (self, other) {
                    (Error::SqliteFailure(e1, s1), Error::SqliteFailure(e2, s2)) => e1 == e2 && s1 == s2,
                    (Error::SqliteSingleThreadedMode, Error::SqliteSingleThreadedMode) => true,
                    (Error::IntegralValueOutOfRange(i1, n1), Error::IntegralValueOutOfRange(i2, n2)) => {
                        i1 == i2 && n1 == n2
                    }
                    (Error::Utf8Error(e1), Error::Utf8Error(e2)) => e1 == e2,
                    (Error::NulError(e1), Error::NulError(e2)) => e1 == e2,
                    (Error::InvalidParameterName(n1), Error::InvalidParameterName(n2)) => n1 == n2,
                    (Error::InvalidPath(p1), Error::InvalidPath(p2)) => p1 == p2,
                    (Error::ExecuteReturnedResults, Error::ExecuteReturnedResults) => true,
                    (Error::QueryReturnedNoRows, Error::QueryReturnedNoRows) => true,
                    (Error::InvalidColumnIndex(i1), Error::InvalidColumnIndex(i2)) => i1 == i2,
                    (Error::InvalidColumnName(n1), Error::InvalidColumnName(n2)) => n1 == n2,
                    (Error::InvalidColumnType(i1, n1, t1), Error::InvalidColumnType(i2, n2, t2)) => {
                        i1 == i2 && t1 == t2 && n1 == n2
                    }
                    (Error::StatementChangedRows(n1), Error::StatementChangedRows(n2)) => n1 == n2,
                    #[cfg(feature = "functions")]
                    (
                        Error::InvalidFunctionParameterType(i1, t1),
                        Error::InvalidFunctionParameterType(i2, t2),
                    ) => i1 == i2 && t1 == t2,
                    #[cfg(feature = "vtab")]
                    (
                        Error::InvalidFilterParameterType(i1, t1),
                        Error::InvalidFilterParameterType(i2, t2),
                    ) => i1 == i2 && t1 == t2,
                    (Error::InvalidQuery, Error::InvalidQuery) => true,
                    #[cfg(feature = "vtab")]
                    (Error::ModuleError(s1), Error::ModuleError(s2)) => s1 == s2,
                    (Error::UnwindingPanic, Error::UnwindingPanic) => true,
                    #[cfg(feature = "functions")]
                    (Error::GetAuxWrongType, Error::GetAuxWrongType) => true,
                    (Error::InvalidParameterCount(i1, n1), Error::InvalidParameterCount(i2, n2)) => {
                        i1 == i2 && n1 == n2
                    }
                    #[cfg(feature = "blob")]
                    (Error::BlobSizeError, Error::BlobSizeError) => true,
                    #[cfg(feature = "modern_sqlite")]
                    (
                        Error::SqlInputError {
                            error: e1,
                            msg: m1,
                            sql: s1,
                            offset: o1,
                        },
                        Error::SqlInputError {
                            error: e2,
                            msg: m2,
                            sql: s2,
                            offset: o2,
                        },
                    ) => e1 == e2 && m1 == m2 && s1 == s2 && o1 == o2,
                    #[cfg(feature = "loadable_extension")]
                    (Error::InitError(e1), Error::InitError(e2)) => e1 == e2,
                    #[cfg(feature = "modern_sqlite")]
                    (Error::InvalidDatabaseIndex(i1), Error::InvalidDatabaseIndex(i2)) => i1 == i2,
                    (..) => false,
                }
            }
        }

        impl From<str::Utf8Error> for Error {
            #[cold]
            fn from(err: str::Utf8Error) -> Error {
                Error::Utf8Error(err)
            }
        }

        impl From<std::ffi::NulError> for Error {
            #[cold]
            fn from(err: std::ffi::NulError) -> Error {
                Error::NulError(err)
            }
        }

        const UNKNOWN_COLUMN: usize = usize::MAX;

        /// The conversion isn't precise, but it's convenient to have it
        /// to allow use of `get_raw().as_()?` in callbacks that take `Error`.
        impl From<FromSqlError> for Error {
            #[cold]
            fn from(err: FromSqlError) -> Error {
                // The error type requires index and type fields, but they aren't known in this
                // context.
                match err {
                    FromSqlError::OutOfRange(val) => Error::IntegralValueOutOfRange(UNKNOWN_COLUMN, val),
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Blob, Box::new(err))
                    }
                    FromSqlError::Other(source) => {
                        Error::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, source)
                    }
                    _ => Error::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, Box::new(err)),
                }
            }
        }

        #[cfg(feature = "loadable_extension")]
        impl From<ffi::InitError> for Error {
            #[cold]
            fn from(err: ffi::InitError) -> Error {
                Error::InitError(err)
            }
        }

        impl fmt::Display for Error {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match *self {
                    Error::SqliteFailure(ref err, None) => err.fmt(f),
                    Error::SqliteFailure(_, Some(ref s)) => write!(f, "{s}"),
                    Error::SqliteSingleThreadedMode => write!(
                        f,
                        "SQLite was compiled or configured for single-threaded use only"
                    ),
                    Error::FromSqlConversionFailure(i, ref t, ref err) => {
                        if i != UNKNOWN_COLUMN {
                            write!(f, "Conversion error from type {t} at index: {i}, {err}")
                        } else {
                            err.fmt(f)
                        }
                    }
                    Error::IntegralValueOutOfRange(col, val) => {
                        if col != UNKNOWN_COLUMN {
                            write!(f, "Integer {val} out of range at index {col}")
                        } else {
                            write!(f, "Integer {val} out of range")
                        }
                    }
                    Error::Utf8Error(ref err) => err.fmt(f),
                    Error::NulError(ref err) => err.fmt(f),
                    Error::InvalidParameterName(ref name) => write!(f, "Invalid parameter name: {name}"),
                    Error::InvalidPath(ref p) => write!(f, "Invalid path: {}", p.to_string_lossy()),
                    Error::ExecuteReturnedResults => {
                        write!(f, "Execute returned results - did you mean to call query?")
                    }
                    Error::QueryReturnedNoRows => write!(f, "Query returned no rows"),
                    Error::InvalidColumnIndex(i) => write!(f, "Invalid column index: {i}"),
                    Error::InvalidColumnName(ref name) => write!(f, "Invalid column name: {name}"),
                    Error::InvalidColumnType(i, ref name, ref t) => {
                        write!(f, "Invalid column type {t} at index: {i}, name: {name}")
                    }
                    Error::InvalidParameterCount(i1, n1) => write!(
                        f,
                        "Wrong number of parameters passed to query. Got {i1}, needed {n1}"
                    ),
                    Error::StatementChangedRows(i) => write!(f, "Query changed {i} rows"),

                    #[cfg(feature = "functions")]
                    Error::InvalidFunctionParameterType(i, ref t) => {
                        write!(f, "Invalid function parameter type {t} at index {i}")
                    }
                    #[cfg(feature = "vtab")]
                    Error::InvalidFilterParameterType(i, ref t) => {
                        write!(f, "Invalid filter parameter type {t} at index {i}")
                    }
                    #[cfg(feature = "functions")]
                    Error::UserFunctionError(ref err) => err.fmt(f),
                    Error::ToSqlConversionFailure(ref err) => err.fmt(f),
                    Error::InvalidQuery => write!(f, "Query is not read-only"),
                    #[cfg(feature = "vtab")]
                    Error::ModuleError(ref desc) => write!(f, "{desc}"),
                    Error::UnwindingPanic => write!(f, "unwinding panic"),
                    #[cfg(feature = "functions")]
                    Error::GetAuxWrongType => write!(f, "get_aux called with wrong type"),
                    Error::MultipleStatement => write!(f, "Multiple statements provided"),
                    #[cfg(feature = "blob")]
                    Error::BlobSizeError => "Blob size is insufficient".fmt(f),
                    #[cfg(feature = "modern_sqlite")]
                    Error::SqlInputError {
                        ref msg,
                        offset,
                        ref sql,
                        ..
                    } => write!(f, "{msg} in {sql} at offset {offset}"),
                    #[cfg(feature = "loadable_extension")]
                    Error::InitError(ref err) => err.fmt(f),
                    #[cfg(feature = "modern_sqlite")]
                    Error::InvalidDatabaseIndex(i) => write!(f, "Invalid database index: {i}"),
                }
            }
        }

        impl error::Error for Error {
            fn source(&self) -> Option<&(dyn error::Error + 'static)> {
                match *self {
                    Error::SqliteFailure(ref err, _) => Some(err),
                    Error::Utf8Error(ref err) => Some(err),
                    Error::NulError(ref err) => Some(err),

                    Error::IntegralValueOutOfRange(..)
                    | Error::SqliteSingleThreadedMode
                    | Error::InvalidParameterName(_)
                    | Error::ExecuteReturnedResults
                    | Error::QueryReturnedNoRows
                    | Error::InvalidColumnIndex(_)
                    | Error::InvalidColumnName(_)
                    | Error::InvalidColumnType(..)
                    | Error::InvalidPath(_)
                    | Error::InvalidParameterCount(..)
                    | Error::StatementChangedRows(_)
                    | Error::InvalidQuery
                    | Error::MultipleStatement => None,

                    #[cfg(feature = "functions")]
                    Error::InvalidFunctionParameterType(..) => None,
                    #[cfg(feature = "vtab")]
                    Error::InvalidFilterParameterType(..) => None,

                    #[cfg(feature = "functions")]
                    Error::UserFunctionError(ref err) => Some(&**err),

                    Error::FromSqlConversionFailure(_, _, ref err)
                    | Error::ToSqlConversionFailure(ref err) => Some(&**err),

                    #[cfg(feature = "vtab")]
                    Error::ModuleError(_) => None,

                    Error::UnwindingPanic => None,

                    #[cfg(feature = "functions")]
                    Error::GetAuxWrongType => None,

                    #[cfg(feature = "blob")]
                    Error::BlobSizeError => None,
                    #[cfg(feature = "modern_sqlite")]
                    Error::SqlInputError { ref error, .. } => Some(error),
                    #[cfg(feature = "loadable_extension")]
                    Error::InitError(ref err) => Some(err),
                    #[cfg(feature = "modern_sqlite")]
                    Error::InvalidDatabaseIndex(_) => None,
                }
            }
        }

        impl Error {
            /// Returns the underlying SQLite error if this is [`Error::SqliteFailure`].
            #[inline]
            #[must_use]
            pub fn sqlite_error(&self) -> Option<&ffi::Error> {
                match self {
                    Self::SqliteFailure(error, _) => Some(error),
                    _ => None,
                }
            }
            /// Returns the underlying SQLite error code if this is
            /// [`Error::SqliteFailure`].
            #[inline]
            #[must_use]
            pub fn sqlite_error_code(&self) -> Option<ffi::ErrorCode> {
                self.sqlite_error().map(|error| error.code)
            }
        }

        // These are public but not re-exported by lib.rs, so only visible within crate.

        #[cold]
        pub fn error_from_sqlite_code(code: c_int, message: Option<String>) -> Error {
            Error::SqliteFailure(ffi::Error::new(code), message)
        }

        #[cold]
        pub unsafe fn error_from_handle(db: *mut ffi::sqlite3, code: c_int) -> Error {
            let message = if db.is_null() {
                None
            } else {
                Some(errmsg_to_string(ffi::sqlite3_errmsg(db)))
            };
            error_from_sqlite_code(code, message)
        }

        #[cold]
        #[cfg(not(feature = "modern_sqlite"))] // SQLite >= 3.38.0
        pub unsafe fn error_with_offset(db: *mut ffi::sqlite3, code: c_int, _sql: &str) -> Error {
            error_from_handle(db, code)
        }

        #[cold]
        #[cfg(feature = "modern_sqlite")] // SQLite >= 3.38.0
        pub unsafe fn error_with_offset(db: *mut ffi::sqlite3, code: c_int, sql: &str) -> Error {
            if db.is_null() {
                error_from_sqlite_code(code, None)
            } else {
                let error = ffi::Error::new(code);
                let msg = errmsg_to_string(ffi::sqlite3_errmsg(db));
                if ffi::ErrorCode::Unknown == error.code {
                    let offset = ffi::sqlite3_error_offset(db);
                    if offset >= 0 {
                        return Error::SqlInputError {
                            error,
                            msg,
                            sql: sql.to_owned(),
                            offset,
                        };
                    }
                }
                Error::SqliteFailure(error, Some(msg))
            }
        }

        pub fn check(code: c_int) -> Result<()> {
            if code != crate::ffi::SQLITE_OK {
                Err(error_from_sqlite_code(code, None))
            } else {
                Ok(())
            }
        }
        /// Transform Rust error to SQLite error (message and code).
        /// # Safety
        /// This function is unsafe because it uses raw pointer
        pub unsafe fn to_sqlite_error(e: &Error, err_msg: *mut *mut std::os::raw::c_char) -> c_int {
            use crate::util::alloc;
            match e {
                Error::SqliteFailure(err, s) => {
                    if let Some(s) = s {
                        *err_msg = alloc(s);
                    }
                    err.extended_code
                }
                err => {
                    *err_msg = alloc(&err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }
    }
    
    pub mod auto_extension
    {
        //! Automatic extension loading
        use ::
        {
            *,
        };
        
        use super::ffi;
        use crate::error::{check, to_sqlite_error};
        use crate::{Connection, Error, Result};
        use std::os::raw::{c_char, c_int};
        use std::panic::catch_unwind;

        /// Automatic extension initialization routine
        pub type AutoExtension = fn(Connection) -> Result<()>;

        /// Raw automatic extension initialization routine
        pub type RawAutoExtension = unsafe extern "C" fn(
            db: *mut ffi::sqlite3,
            pz_err_msg: *mut *mut c_char,
            _: *const ffi::sqlite3_api_routines,
        ) -> c_int;

        /// Bridge between `RawAutoExtension` and `AutoExtension`
        ///
        /// # Safety
        /// * Opening a database from an auto-extension handler will lead to
        ///   an endless recursion of the auto-handler triggering itself
        ///   indirectly for each newly-opened database.
        /// * Results are undefined if the given db is closed by an auto-extension.
        /// * The list of auto-extensions should not be manipulated from an auto-extension.
        pub unsafe fn init_auto_extension(
            db: *mut ffi::sqlite3,
            pz_err_msg: *mut *mut c_char,
            ax: AutoExtension,
        ) -> c_int {
            let r = catch_unwind(|| {
                let c = Connection::from_handle(db);
                c.and_then(ax)
            })
            .unwrap_or_else(|_| Err(Error::UnwindingPanic));
            match r {
                Err(e) => to_sqlite_error(&e, pz_err_msg),
                _ => ffi::SQLITE_OK,
            }
        }
        /// Register au auto-extension
        ///
        /// # Safety
        /// * Opening a database from an auto-extension handler will lead to
        ///   an endless recursion of the auto-handler triggering itself
        ///   indirectly for each newly-opened database.
        /// * Results are undefined if the given db is closed by an auto-extension.
        /// * The list of auto-extensions should not be manipulated from an auto-extension.
        pub unsafe fn register_auto_extension(ax: RawAutoExtension) -> Result<()> {
            check(ffi::sqlite3_auto_extension(Some(ax)))
        }
        /// Unregister the initialization routine
        pub fn cancel_auto_extension(ax: RawAutoExtension) -> bool {
            unsafe { ffi::sqlite3_cancel_auto_extension(Some(ax)) == 1 }
        }
        /// Disable all automatic extensions previously registered
        pub fn reset_auto_extension() {
            unsafe { ffi::sqlite3_reset_auto_extension() }
        }
    }
    
    pub mod backup
    {
        //! Online SQLite backup API.
        use ::
        {
            *,
        };
        
        use std::marker::PhantomData;
        use std::path::Path;
        use std::ptr;

        use std::os::raw::c_int;
        use std::thread;
        use std::time::Duration;

        use crate::ffi;

        use crate::error::error_from_handle;
        use crate::{Connection, DatabaseName, Result};

        impl Connection {
            /// Back up the `name` database to the given
            /// destination path.
            ///
            /// If `progress` is not `None`, it will be called periodically
            /// until the backup completes.
            ///
            /// For more fine-grained control over the backup process (e.g.,
            /// to sleep periodically during the backup or to back up to an
            /// already-open database connection), see the `backup` module.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the destination path cannot be opened
            /// or if the backup fails.
            pub fn backup<P: AsRef<Path>>(
                &self,
                name: DatabaseName<'_>,
                dst_path: P,
                progress: Option<fn(Progress)>,
            ) -> Result<()> {
                use self::StepResult::{Busy, Done, Locked, More};
                let mut dst = Connection::open(dst_path)?;
                let backup = Backup::new_with_names(self, name, &mut dst, DatabaseName::Main)?;

                let mut r = More;
                while r == More {
                    r = backup.step(100)?;
                    if let Some(f) = progress {
                        f(backup.progress());
                    }
                }

                match r {
                    Done => Ok(()),
                    Busy => Err(unsafe { error_from_handle(ptr::null_mut(), ffi::SQLITE_BUSY) }),
                    Locked => Err(unsafe { error_from_handle(ptr::null_mut(), ffi::SQLITE_LOCKED) }),
                    More => unreachable!(),
                }
            }
            /// Restore the given source path into the
            /// `name` database. If `progress` is not `None`, it will be
            /// called periodically until the restore completes.
            ///
            /// For more fine-grained control over the restore process (e.g.,
            /// to sleep periodically during the restore or to restore from an
            /// already-open database connection), see the `backup` module.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the destination path cannot be opened
            /// or if the restore fails.
            pub fn restore<P: AsRef<Path>, F: Fn(Progress)>(
                &mut self,
                name: DatabaseName<'_>,
                src_path: P,
                progress: Option<F>,
            ) -> Result<()> {
                use self::StepResult::{Busy, Done, Locked, More};
                let src = Connection::open(src_path)?;
                let restore = Backup::new_with_names(&src, DatabaseName::Main, self, name)?;

                let mut r = More;
                let mut busy_count = 0_i32;
                'restore_loop: while r == More || r == Busy {
                    r = restore.step(100)?;
                    if let Some(ref f) = progress {
                        f(restore.progress());
                    }
                    if r == Busy {
                        busy_count += 1;
                        if busy_count >= 3 {
                            break 'restore_loop;
                        }
                        thread::sleep(Duration::from_millis(100));
                    }
                }

                match r {
                    Done => Ok(()),
                    Busy => Err(unsafe { error_from_handle(ptr::null_mut(), ffi::SQLITE_BUSY) }),
                    Locked => Err(unsafe { error_from_handle(ptr::null_mut(), ffi::SQLITE_LOCKED) }),
                    More => unreachable!(),
                }
            }
        }
        /// Possible successful results of calling
        /// [`Backup::step`].
        #[derive(Copy, Clone, Debug, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum StepResult {
            /// The backup is complete.
            Done,

            /// The step was successful but there are still more pages that need to be
            /// backed up.
            More,

            /// The step failed because appropriate locks could not be acquired. This is
            /// not a fatal error - the step can be retried.
            Busy,

            /// The step failed because the source connection was writing to the
            /// database. This is not a fatal error - the step can be retried.
            Locked,
        }
        /// Struct specifying the progress of a backup. The
        /// percentage completion can be calculated as `(pagecount - remaining) /
        /// pagecount`. The progress of a backup is as of the last call to
        /// [`step`](Backup::step) - if the source database is modified after a call to
        /// [`step`](Backup::step), the progress value will become outdated and
        /// potentially incorrect.
        #[derive(Copy, Clone, Debug)]
        pub struct Progress {
            /// Number of pages in the source database that still need to be backed up.
            pub remaining: c_int,
            /// Total number of pages in the source database.
            pub pagecount: c_int,
        }
        /// A handle to an online backup.
        pub struct Backup<'a, 'b> {
            phantom_from: PhantomData<&'a Connection>,
            to: &'b Connection,
            b: *mut ffi::sqlite3_backup,
        }

        impl Backup<'_, '_> {
            /// Attempt to create a new handle that will allow backups from `from` to
            /// `to`. Note that `to` is a `&mut` - this is because SQLite forbids any
            /// API calls on the destination of a backup while the backup is taking
            /// place.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying `sqlite3_backup_init` call returns
            /// `NULL`.
            #[inline]
            pub fn new<'a, 'b>(from: &'a Connection, to: &'b mut Connection) -> Result<Backup<'a, 'b>> {
                Backup::new_with_names(from, DatabaseName::Main, to, DatabaseName::Main)
            }
            /// Attempt to create a new handle that will allow backups from the
            /// `from_name` database of `from` to the `to_name` database of `to`. Note
            /// that `to` is a `&mut` - this is because SQLite forbids any API calls on
            /// the destination of a backup while the backup is taking place.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying `sqlite3_backup_init` call returns
            /// `NULL`.
            pub fn new_with_names<'a, 'b>(
                from: &'a Connection,
                from_name: DatabaseName<'_>,
                to: &'b mut Connection,
                to_name: DatabaseName<'_>,
            ) -> Result<Backup<'a, 'b>> {
                let to_name = to_name.as_cstring()?;
                let from_name = from_name.as_cstring()?;

                let to_db = to.db.borrow_mut().db;

                let b = unsafe {
                    let b = ffi::sqlite3_backup_init(
                        to_db,
                        to_name.as_ptr(),
                        from.db.borrow_mut().db,
                        from_name.as_ptr(),
                    );
                    if b.is_null() {
                        return Err(error_from_handle(to_db, ffi::sqlite3_errcode(to_db)));
                    }
                    b
                };

                Ok(Backup {
                    phantom_from: PhantomData,
                    to,
                    b,
                })
            }
            /// Gets the progress of the backup as of the last call to
            /// [`step`](Backup::step).
            #[inline]
            #[must_use]
            pub fn progress(&self) -> Progress {
                unsafe {
                    Progress {
                        remaining: ffi::sqlite3_backup_remaining(self.b),
                        pagecount: ffi::sqlite3_backup_pagecount(self.b),
                    }
                }
            }
            /// Attempts to back up the given number of pages. If `num_pages` is
            /// negative, will attempt to back up all remaining pages. This will hold a
            /// lock on the source database for the duration, so it is probably not
            /// what you want for databases that are currently active (see
            /// [`run_to_completion`](Backup::run_to_completion) for a better
            /// alternative).
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying `sqlite3_backup_step` call returns
            /// an error code other than `DONE`, `OK`, `BUSY`, or `LOCKED`. `BUSY` and
            /// `LOCKED` are transient errors and are therefore returned as possible
            /// `Ok` values.
            #[inline]
            pub fn step(&self, num_pages: c_int) -> Result<StepResult> {
                use self::StepResult::{Busy, Done, Locked, More};

                let rc = unsafe { ffi::sqlite3_backup_step(self.b, num_pages) };
                match rc {
                    ffi::SQLITE_DONE => Ok(Done),
                    ffi::SQLITE_OK => Ok(More),
                    ffi::SQLITE_BUSY => Ok(Busy),
                    ffi::SQLITE_LOCKED => Ok(Locked),
                    _ => self.to.decode_result(rc).map(|_| More),
                }
            }
            /// Attempts to run the entire backup. Will call
            /// [`step(pages_per_step)`](Backup::step) as many times as necessary,
            /// sleeping for `pause_between_pages` between each call to give the
            /// source database time to process any pending queries. This is a
            /// direct implementation of "Example 2: Online Backup of a Running
            /// Database" from [SQLite's Online Backup API documentation](https://www.sqlite.org/backup.html).
            ///
            /// If `progress` is not `None`, it will be called after each step with the
            /// current progress of the backup. Note that is possible the progress may
            /// not change if the step returns `Busy` or `Locked` even though the
            /// backup is still running.
            ///
            /// # Failure
            ///
            /// Will return `Err` if any of the calls to [`step`](Backup::step) return
            /// `Err`.
            pub fn run_to_completion(
                &self,
                pages_per_step: c_int,
                pause_between_pages: Duration,
                progress: Option<fn(Progress)>,
            ) -> Result<()> {
                use self::StepResult::{Busy, Done, Locked, More};

                assert!(pages_per_step > 0, "pages_per_step must be positive");

                loop {
                    let r = self.step(pages_per_step)?;
                    if let Some(progress) = progress {
                        progress(self.progress());
                    }
                    match r {
                        More | Busy | Locked => thread::sleep(pause_between_pages),
                        Done => return Ok(()),
                    }
                }
            }
        }

        impl Drop for Backup<'_, '_> {
            #[inline]
            fn drop(&mut self) {
                unsafe { ffi::sqlite3_backup_finish(self.b) };
            }
        }
    }
    
    pub mod blob
    {
        //! Incremental BLOB I/O.
        use ::
        {
            *,
        };
        
        use std::cmp::min;
        use std::io;
        use std::ptr;

        use super::ffi;
        use super::types::{ToSql, ToSqlOutput};
        use crate::{Connection, DatabaseName, Result};

        mod pos_io
        {
            use ::
            {
                *,
            };
            use super::Blob;

            use std::mem::MaybeUninit;
            use std::slice::from_raw_parts_mut;

            use crate::ffi;
            use crate::{Error, Result};

            impl<'conn> Blob<'conn> {
                /// Write `buf` to `self` starting at `write_start`, returning an error if
                /// `write_start + buf.len()` is past the end of the blob.
                ///
                /// If an error is returned, no data is written.
                ///
                /// Note: the blob cannot be resized using this function -- that must be
                /// done using SQL (for example, an `UPDATE` statement).
                ///
                /// Note: This is part of the positional I/O API, and thus takes an absolute
                /// position write to, instead of using the internal position that can be
                /// manipulated by the `std::io` traits.
                ///
                /// Unlike the similarly named [`FileExt::write_at`][fext_write_at] function
                /// (from `std::os::unix`), it's always an error to perform a "short write".
                ///
                /// [fext_write_at]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#tymethod.write_at
                #[inline]
                pub fn write_at(&mut self, buf: &[u8], write_start: usize) -> Result<()> {
                    let len = self.len();

                    if buf.len().saturating_add(write_start) > len {
                        return Err(Error::BlobSizeError);
                    }
                    // We know `len` fits in an `i32`, so either:
                    //
                    // 1. `buf.len() + write_start` overflows, in which case we'd hit the
                    //    return above (courtesy of `saturating_add`).
                    //
                    // 2. `buf.len() + write_start` doesn't overflow but is larger than len,
                    //    in which case ditto.
                    //
                    // 3. `buf.len() + write_start` doesn't overflow but is less than len.
                    //    This means that both `buf.len()` and `write_start` can also be
                    //    losslessly converted to i32, since `len` came from an i32.
                    // Sanity check the above.
                    debug_assert!(i32::try_from(write_start).is_ok() && i32::try_from(buf.len()).is_ok());
                    self.conn.decode_result(unsafe {
                        ffi::sqlite3_blob_write(
                            self.blob,
                            buf.as_ptr().cast(),
                            buf.len() as i32,
                            write_start as i32,
                        )
                    })
                }
                /// An alias for `write_at` provided for compatibility with the conceptually
                /// equivalent [`std::os::unix::FileExt::write_all_at`][write_all_at]
                /// function from libstd:
                ///
                /// [write_all_at]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at
                #[inline]
                pub fn write_all_at(&mut self, buf: &[u8], write_start: usize) -> Result<()> {
                    self.write_at(buf, write_start)
                }
                /// Read as much as possible from `offset` to `offset + buf.len()` out of
                /// `self`, writing into `buf`. On success, returns the number of bytes
                /// written.
                ///
                /// If there's insufficient data in `self`, then the returned value will be
                /// less than `buf.len()`.
                ///
                /// See also [`Blob::raw_read_at`], which can take an uninitialized buffer,
                /// or [`Blob::read_at_exact`] which returns an error if the entire `buf` is
                /// not read.
                ///
                /// Note: This is part of the positional I/O API, and thus takes an absolute
                /// position to read from, instead of using the internal position that can
                /// be manipulated by the `std::io` traits. Consequently, it does not change
                /// that value either.
                #[inline]
                pub fn read_at(&self, buf: &mut [u8], read_start: usize) -> Result<usize> {
                    // Safety: this is safe because `raw_read_at` never stores uninitialized
                    // data into `as_uninit`.
                    let as_uninit: &mut [MaybeUninit<u8>] =
                        unsafe { from_raw_parts_mut(buf.as_mut_ptr().cast(), buf.len()) };
                    self.raw_read_at(as_uninit, read_start).map(|s| s.len())
                }
                /// Read as much as possible from `offset` to `offset + buf.len()` out of
                /// `self`, writing into `buf`. On success, returns the portion of `buf`
                /// which was initialized by this call.
                ///
                /// If there's insufficient data in `self`, then the returned value will be
                /// shorter than `buf`.
                ///
                /// See also [`Blob::read_at`], which takes a `&mut [u8]` buffer instead of
                /// a slice of `MaybeUninit<u8>`.
                ///
                /// Note: This is part of the positional I/O API, and thus takes an absolute
                /// position to read from, instead of using the internal position that can
                /// be manipulated by the `std::io` traits. Consequently, it does not change
                /// that value either.
                #[inline]
                pub fn raw_read_at<'a>(
                    &self,
                    buf: &'a mut [MaybeUninit<u8>],
                    read_start: usize,
                ) -> Result<&'a mut [u8]> {
                    let len = self.len();

                    let read_len = match len.checked_sub(read_start) {
                        None | Some(0) => 0,
                        Some(v) => v.min(buf.len()),
                    };

                    if read_len == 0 {
                        // We could return `Ok(&mut [])`, but it seems confusing that the
                        // pointers don't match, so fabricate an empty slice of u8 with the
                        // same base pointer as `buf`.
                        let empty = unsafe { from_raw_parts_mut(buf.as_mut_ptr().cast::<u8>(), 0) };
                        return Ok(empty);
                    }

                    // At this point we believe `read_start as i32` is lossless because:
                    //
                    // 1. `len as i32` is known to be lossless, since it comes from a SQLite
                    //    api returning an i32.
                    //
                    // 2. If we got here, `len.checked_sub(read_start)` was Some (or else
                    //    we'd have hit the `if read_len == 0` early return), so `len` must
                    //    be larger than `read_start`, and so it must fit in i32 as well.
                    debug_assert!(i32::try_from(read_start).is_ok());

                    // We also believe that `read_start + read_len <= len` because:
                    //
                    // 1. This is equivalent to `read_len <= len - read_start` via algebra.
                    // 2. We know that `read_len` is `min(len - read_start, buf.len())`
                    // 3. Expanding, this is `min(len - read_start, buf.len()) <= len - read_start`,
                    //    or `min(A, B) <= A` which is clearly true.
                    //
                    // Note that this stuff is in debug_assert so no need to use checked_add
                    // and such -- we'll always panic on overflow in debug builds.
                    debug_assert!(read_start + read_len <= len);

                    // These follow naturally.
                    debug_assert!(buf.len() >= read_len);
                    debug_assert!(i32::try_from(buf.len()).is_ok());
                    debug_assert!(i32::try_from(read_len).is_ok());

                    unsafe {
                        self.conn.decode_result(ffi::sqlite3_blob_read(
                            self.blob,
                            buf.as_mut_ptr().cast(),
                            read_len as i32,
                            read_start as i32,
                        ))?;

                        Ok(from_raw_parts_mut(buf.as_mut_ptr().cast::<u8>(), read_len))
                    }
                }
                /// Equivalent to [`Blob::read_at`], but returns a `BlobSizeError` if `buf`
                /// is not fully initialized.
                #[inline]
                pub fn read_at_exact(&self, buf: &mut [u8], read_start: usize) -> Result<()> {
                    let n = self.read_at(buf, read_start)?;
                    if n != buf.len() {
                        Err(Error::BlobSizeError)
                    } else {
                        Ok(())
                    }
                }
                /// Equivalent to [`Blob::raw_read_at`], but returns a `BlobSizeError` if
                /// `buf` is not fully initialized.
                #[inline]
                pub fn raw_read_at_exact<'a>(
                    &self,
                    buf: &'a mut [MaybeUninit<u8>],
                    read_start: usize,
                ) -> Result<&'a mut [u8]> {
                    let buflen = buf.len();
                    let initted = self.raw_read_at(buf, read_start)?;
                    if initted.len() != buflen {
                        Err(Error::BlobSizeError)
                    } else {
                        Ok(initted)
                    }
                }
            }
        }
        /// Handle to an open BLOB. See
        /// [`rusqlite::blob`](crate::blob) documentation for in-depth discussion.
        pub struct Blob<'conn> {
            conn: &'conn Connection,
            blob: *mut ffi::sqlite3_blob,
            // used by std::io implementations,
            pos: i32,
        }

        impl Connection {
            /// Open a handle to the BLOB located in `row_id`,
            /// `column`, `table` in database `db`.
            ///
            /// # Failure
            ///
            /// Will return `Err` if `db`/`table`/`column` cannot be converted to a
            /// C-compatible string or if the underlying SQLite BLOB open call
            /// fails.
            #[inline]
            pub fn blob_open<'a>(
                &'a self,
                db: DatabaseName<'_>,
                table: &str,
                column: &str,
                row_id: i64,
                read_only: bool,
            ) -> Result<Blob<'a>> {
                let c = self.db.borrow_mut();
                let mut blob = ptr::null_mut();
                let db = db.as_cstring()?;
                let table = super::str_to_cstring(table)?;
                let column = super::str_to_cstring(column)?;
                let rc = unsafe {
                    ffi::sqlite3_blob_open(
                        c.db(),
                        db.as_ptr(),
                        table.as_ptr(),
                        column.as_ptr(),
                        row_id,
                        !read_only as std::os::raw::c_int,
                        &mut blob,
                    )
                };
                c.decode_result(rc).map(|_| Blob {
                    conn: self,
                    blob,
                    pos: 0,
                })
            }
        }

        impl Blob<'_> {
            /// Move a BLOB handle to a new row.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying SQLite BLOB reopen call fails.
            #[inline]
            pub fn reopen(&mut self, row: i64) -> Result<()> {
                let rc = unsafe { ffi::sqlite3_blob_reopen(self.blob, row) };
                if rc != ffi::SQLITE_OK {
                    return self.conn.decode_result(rc);
                }
                self.pos = 0;
                Ok(())
            }
            /// Return the size in bytes of the BLOB.
            #[inline]
            #[must_use]
            pub fn size(&self) -> i32 {
                unsafe { ffi::sqlite3_blob_bytes(self.blob) }
            }
            /// Return the current size in bytes of the BLOB.
            #[inline]
            #[must_use]
            pub fn len(&self) -> usize {
                self.size().try_into().unwrap()
            }
            /// Return true if the BLOB is empty.
            #[inline]
            #[must_use]
            pub fn is_empty(&self) -> bool {
                self.size() == 0
            }
            /// Close a BLOB handle.
            ///
            /// Calling `close` explicitly is not required (the BLOB will be closed
            /// when the `Blob` is dropped), but it is available, so you can get any
            /// errors that occur.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying SQLite close call fails.
            #[inline]
            pub fn close(mut self) -> Result<()> {
                self.close_()
            }

            #[inline]
            fn close_(&mut self) -> Result<()> {
                let rc = unsafe { ffi::sqlite3_blob_close(self.blob) };
                self.blob = ptr::null_mut();
                self.conn.decode_result(rc)
            }
        }

        impl io::Read for Blob<'_> {
            /// Read data from a BLOB incrementally. Will return Ok(0) if the end of
            /// the blob has been reached.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying SQLite read call fails.
            #[inline]
            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
                let max_allowed_len = (self.size() - self.pos) as usize;
                let n = min(buf.len(), max_allowed_len) as i32;
                if n <= 0 {
                    return Ok(0);
                }
                let rc = unsafe { ffi::sqlite3_blob_read(self.blob, buf.as_mut_ptr().cast(), n, self.pos) };
                self.conn
                    .decode_result(rc)
                    .map(|_| {
                        self.pos += n;
                        n as usize
                    })
                    .map_err(|err| io::Error::new(io::ErrorKind::Other, err))
            }
        }

        impl io::Write for Blob<'_> {
            /// Write data into a BLOB incrementally. Will return `Ok(0)` if the end of
            /// the blob has been reached; consider using `Write::write_all(buf)`
            /// if you want to get an error if the entirety of the buffer cannot be
            /// written.
            ///
            /// This function may only modify the contents of the BLOB; it is not
            /// possible to increase the size of a BLOB using this API.
            ///
            /// # Failure
            ///
            /// Will return `Err` if the underlying SQLite write call fails.
            #[inline]
            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
                let max_allowed_len = (self.size() - self.pos) as usize;
                let n = min(buf.len(), max_allowed_len) as i32;
                if n <= 0 {
                    return Ok(0);
                }
                let rc = unsafe { ffi::sqlite3_blob_write(self.blob, buf.as_ptr() as *mut _, n, self.pos) };
                self.conn
                    .decode_result(rc)
                    .map(|_| {
                        self.pos += n;
                        n as usize
                    })
                    .map_err(|err| io::Error::new(io::ErrorKind::Other, err))
            }

            #[inline]
            fn flush(&mut self) -> io::Result<()> {
                Ok(())
            }
        }

        impl io::Seek for Blob<'_> {
            /// Seek to an offset, in bytes, in BLOB.
            #[inline]
            fn seek(&mut self, pos: io::SeekFrom) -> io::Result<u64> {
                let pos = match pos {
                    io::SeekFrom::Start(offset) => offset as i64,
                    io::SeekFrom::Current(offset) => i64::from(self.pos) + offset,
                    io::SeekFrom::End(offset) => i64::from(self.size()) + offset,
                };

                if pos < 0 {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidInput,
                        "invalid seek to negative position",
                    ))
                } else if pos > i64::from(self.size()) {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidInput,
                        "invalid seek to position past end of blob",
                    ))
                } else {
                    self.pos = pos as i32;
                    Ok(pos as u64)
                }
            }
        }

        #[allow(unused_must_use)]
        impl Drop for Blob<'_> {
            #[inline]
            fn drop(&mut self) {
                self.close_();
            }
        }
        /// BLOB of length N that is filled with zeroes.
        ///
        /// Zeroblobs are intended to serve as placeholders for BLOBs whose content is
        /// later written using incremental BLOB I/O routines.
        ///
        /// A negative value for the zeroblob results in a zero-length BLOB.
        #[derive(Copy, Clone)]
        pub struct ZeroBlob(pub i32);

        impl ToSql for ZeroBlob {
            #[inline]
            fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                let ZeroBlob(length) = *self;
                Ok(ToSqlOutput::ZeroBlob(length))
            }
        }
    }

    mod busy
    {
        //! Busy handler (when the database is locked)
        use ::
        {
            *,
        };
        
        use std::mem;
        use std::os::raw::{c_int, c_void};
        use std::panic::catch_unwind;
        use std::ptr;
        use std::time::Duration;

        use crate::ffi;
        use crate::{Connection, InnerConnection, Result};

        impl Connection {
            /// Set a busy handler that sleeps for a specified amount of time when a
            /// table is locked. The handler will sleep multiple times until at
            /// least "ms" milliseconds of sleeping have accumulated.
            ///
            /// Calling this routine with an argument equal to zero turns off all busy
            /// handlers.
            ///
            /// There can only be a single busy handler for a particular database
            /// connection at any given moment. If another busy handler was defined
            /// (using [`busy_handler`](Connection::busy_handler)) prior to calling this
            /// routine, that other busy handler is cleared.
            ///
            /// Newly created connections currently have a default busy timeout of
            /// 5000ms, but this may be subject to change.
            pub fn busy_timeout(&self, timeout: Duration) -> Result<()> {
                let ms: i32 = timeout
                    .as_secs()
                    .checked_mul(1000)
                    .and_then(|t| t.checked_add(timeout.subsec_millis().into()))
                    .and_then(|t| t.try_into().ok())
                    .expect("too big");
                self.db.borrow_mut().busy_timeout(ms)
            }
            /// Register a callback to handle `SQLITE_BUSY` errors.
            ///
            /// If the busy callback is `None`, then `SQLITE_BUSY` is returned
            /// immediately upon encountering the lock. The argument to the busy
            /// handler callback is the number of times that the
            /// busy handler has been invoked previously for the
            /// same locking event. If the busy callback returns `false`, then no
            /// additional attempts are made to access the
            /// database and `SQLITE_BUSY` is returned to the
            /// application. If the callback returns `true`, then another attempt
            /// is made to access the database and the cycle repeats.
            ///
            /// There can only be a single busy handler defined for each database
            /// connection. Setting a new busy handler clears any previously set
            /// handler. Note that calling [`busy_timeout()`](Connection::busy_timeout)
            /// or evaluating `PRAGMA busy_timeout=N` will change the busy handler
            /// and thus clear any previously set busy handler.
            ///
            /// Newly created connections default to a
            /// [`busy_timeout()`](Connection::busy_timeout) handler with a timeout
            /// of 5000ms, although this is subject to change.
            pub fn busy_handler(&self, callback: Option<fn(i32) -> bool>) -> Result<()> {
                unsafe extern "C" fn busy_handler_callback(p_arg: *mut c_void, count: c_int) -> c_int {
                    let handler_fn: fn(i32) -> bool = mem::transmute(p_arg);
                    c_int::from(catch_unwind(|| handler_fn(count)).unwrap_or_default())
                }
                let c = self.db.borrow_mut();
                let r = match callback {
                    Some(f) => unsafe {
                        ffi::sqlite3_busy_handler(c.db(), Some(busy_handler_callback), f as *mut c_void)
                    },
                    None => unsafe { ffi::sqlite3_busy_handler(c.db(), None, ptr::null_mut()) },
                };
                c.decode_result(r)
            }
        }

        impl InnerConnection {
            #[inline]
            fn busy_timeout(&mut self, timeout: c_int) -> Result<()> {
                let r = unsafe { ffi::sqlite3_busy_timeout(self.db, timeout) };
                self.decode_result(r)
            }
        }
    }

    mod cache
    {
        //! Prepared statements cache for faster execution.
        use ::
        {
            *,
        };
        

        use crate::raw_statement::RawStatement;
        use crate::{Connection, PrepFlags, Result, Statement};
        use hashlink::LruCache;
        use std::cell::RefCell;
        use std::ops::{Deref, DerefMut};
        use std::sync::Arc;

        impl Connection {
            /// Prepare a SQL statement for execution, returning a previously prepared
            /// (but not currently in-use) statement if one is available.
            #[inline]
            pub fn prepare_cached(&self, sql: &str) -> Result<CachedStatement<'_>> {
                self.cache.get(self, sql)
            }
            /// Set the maximum number of cached prepared statements this connection
            /// will hold.
            #[inline]
            pub fn set_prepared_statement_cache_capacity(&self, capacity: usize) {
                self.cache.set_capacity(capacity);
            }
            /// Remove/finalize all prepared statements currently in the cache.
            #[inline]
            pub fn flush_prepared_statement_cache(&self) {
                self.cache.flush();
            }
        }
        /// Prepared statements LRU cache.
        #[derive(Debug)]
        pub struct StatementCache(RefCell<LruCache<Arc<str>, RawStatement>>);

        #[allow(clippy::non_send_fields_in_send_ty)]
        unsafe impl Send for StatementCache {}
        /// Cacheable statement.
        ///
        /// Statement will return automatically to the cache by default.
        /// If you want the statement to be discarded, call
        /// [`discard()`](CachedStatement::discard) on it.
        pub struct CachedStatement<'conn> {
            stmt: Option<Statement<'conn>>,
            cache: &'conn StatementCache,
        }

        impl<'conn> Deref for CachedStatement<'conn> {
            type Target = Statement<'conn>;

            #[inline]
            fn deref(&self) -> &Statement<'conn> {
                self.stmt.as_ref().unwrap()
            }
        }

        impl<'conn> DerefMut for CachedStatement<'conn> {
            #[inline]
            fn deref_mut(&mut self) -> &mut Statement<'conn> {
                self.stmt.as_mut().unwrap()
            }
        }

        impl Drop for CachedStatement<'_> {
            #[allow(unused_must_use)]
            #[inline]
            fn drop(&mut self) {
                if let Some(stmt) = self.stmt.take() {
                    self.cache.cache_stmt(unsafe { stmt.into_raw() });
                }
            }
        }

        impl CachedStatement<'_> {
            #[inline]
            fn new<'conn>(stmt: Statement<'conn>, cache: &'conn StatementCache) -> CachedStatement<'conn> {
                CachedStatement {
                    stmt: Some(stmt),
                    cache,
                }
            }
            /// Discard the statement, preventing it from being returned to its
            /// [`Connection`]'s collection of cached statements.
            #[inline]
            pub fn discard(mut self) {
                self.stmt = None;
            }
        }

        impl StatementCache {
            /// Create a statement cache.
            #[inline]
            pub fn with_capacity(capacity: usize) -> StatementCache {
                StatementCache(RefCell::new(LruCache::new(capacity)))
            }

            #[inline]
            fn set_capacity(&self, capacity: usize) {
                self.0.borrow_mut().set_capacity(capacity);
            }

            // Search the cache for a prepared-statement object that implements `sql`.
            // If no such prepared-statement can be found, allocate and prepare a new one.
            //
            // # Failure
            //
            // Will return `Err` if no cached statement can be found and the underlying
            // SQLite prepare call fails.
            fn get<'conn>(
                &'conn self,
                conn: &'conn Connection,
                sql: &str,
            ) -> Result<CachedStatement<'conn>> {
                let trimmed = sql.trim();
                let mut cache = self.0.borrow_mut();
                let stmt = match cache.remove(trimmed) {
                    Some(raw_stmt) => Ok(Statement::new(conn, raw_stmt)),
                    None => conn.prepare_with_flags(trimmed, PrepFlags::SQLITE_PREPARE_PERSISTENT),
                };
                stmt.map(|mut stmt| {
                    stmt.stmt.set_statement_cache_key(trimmed);
                    CachedStatement::new(stmt, self)
                })
            }

            // Return a statement to the cache.
            fn cache_stmt(&self, mut stmt: RawStatement) {
                if stmt.is_null() {
                    return;
                }
                let mut cache = self.0.borrow_mut();
                stmt.clear_bindings();
                if let Some(sql) = stmt.statement_cache_key() {
                    cache.insert(sql, stmt);
                } else {
                    debug_assert!(
                        false,
                        "bug in statement cache code, statement returned to cache that without key"
                    );
                }
            }

            #[inline]
            fn flush(&self) {
                let mut cache = self.0.borrow_mut();
                cache.clear();
            }
        }
    }
    
    mod collation
    {
        //! Add, remove, or modify a collation
        use ::
        {
            *,
        };
        
        use std::cmp::Ordering;
        use std::os::raw::{c_char, c_int, c_void};
        use std::panic::catch_unwind;
        use std::ptr;
        use std::slice;

        use crate::ffi;
        use crate::{str_to_cstring, Connection, InnerConnection, Result};

        // FIXME copy/paste from function.rs
        unsafe extern "C" fn free_boxed_value<T>(p: *mut c_void) {
            drop(Box::from_raw(p.cast::<T>()));
        }

        impl Connection {
            /// Add or modify a collation.
            #[inline]
            pub fn create_collation<C>(&self, collation_name: &str, x_compare: C) -> Result<()>
            where
                C: Fn(&str, &str) -> Ordering + Send + 'static,
            {
                self.db
                    .borrow_mut()
                    .create_collation(collation_name, x_compare)
            }
            /// Collation needed callback
            #[inline]
            pub fn collation_needed(
                &self,
                x_coll_needed: fn(&Connection, &str) -> Result<()>,
            ) -> Result<()> {
                self.db.borrow_mut().collation_needed(x_coll_needed)
            }
            /// Remove collation.
            #[inline]
            pub fn remove_collation(&self, collation_name: &str) -> Result<()> {
                self.db.borrow_mut().remove_collation(collation_name)
            }
        }

        impl InnerConnection {
            fn create_collation<C>(&mut self, collation_name: &str, x_compare: C) -> Result<()>
            where
                C: Fn(&str, &str) -> Ordering + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<C>(
                    arg1: *mut c_void,
                    arg2: c_int,
                    arg3: *const c_void,
                    arg4: c_int,
                    arg5: *const c_void,
                ) -> c_int
                where
                    C: Fn(&str, &str) -> Ordering,
                {
                    let r = catch_unwind(|| {
                        let boxed_f: *mut C = arg1.cast::<C>();
                        assert!(!boxed_f.is_null(), "Internal error - null function pointer");
                        let s1 = {
                            let c_slice = slice::from_raw_parts(arg3.cast::<u8>(), arg2 as usize);
                            String::from_utf8_lossy(c_slice)
                        };
                        let s2 = {
                            let c_slice = slice::from_raw_parts(arg5.cast::<u8>(), arg4 as usize);
                            String::from_utf8_lossy(c_slice)
                        };
                        (*boxed_f)(s1.as_ref(), s2.as_ref())
                    });
                    let t = match r {
                        Err(_) => {
                            return -1; // FIXME How ?
                        }
                        Ok(r) => r,
                    };

                    match t {
                        Ordering::Less => -1,
                        Ordering::Equal => 0,
                        Ordering::Greater => 1,
                    }
                }

                let boxed_f: *mut C = Box::into_raw(Box::new(x_compare));
                let c_name = str_to_cstring(collation_name)?;
                let flags = ffi::SQLITE_UTF8;
                let r = unsafe {
                    ffi::sqlite3_create_collation_v2(
                        self.db(),
                        c_name.as_ptr(),
                        flags,
                        boxed_f.cast::<c_void>(),
                        Some(call_boxed_closure::<C>),
                        Some(free_boxed_value::<C>),
                    )
                };
                let res = self.decode_result(r);
                // The xDestroy callback is not called if the sqlite3_create_collation_v2()
                // function fails.
                if res.is_err() {
                    drop(unsafe { Box::from_raw(boxed_f) });
                }
                res
            }

            fn collation_needed(
                &mut self,
                x_coll_needed: fn(&Connection, &str) -> Result<()>,
            ) -> Result<()> {
                use std::mem;
                #[allow(clippy::needless_return)]
                unsafe extern "C" fn collation_needed_callback(
                    arg1: *mut c_void,
                    arg2: *mut ffi::sqlite3,
                    e_text_rep: c_int,
                    arg3: *const c_char,
                ) {
                    use std::ffi::CStr;
                    use std::str;

                    if e_text_rep != ffi::SQLITE_UTF8 {
                        // TODO: validate
                        return;
                    }

                    let callback: fn(&Connection, &str) -> Result<()> = mem::transmute(arg1);
                    let res = catch_unwind(|| {
                        let conn = Connection::from_handle(arg2).unwrap();
                        let collation_name = CStr::from_ptr(arg3)
                            .to_str()
                            .expect("illegal collation sequence name");
                        callback(&conn, collation_name)
                    });
                    if res.is_err() {
                        return; // FIXME How ?
                    }
                }

                let r = unsafe {
                    ffi::sqlite3_collation_needed(
                        self.db(),
                        x_coll_needed as *mut c_void,
                        Some(collation_needed_callback),
                    )
                };
                self.decode_result(r)
            }

            #[inline]
            fn remove_collation(&mut self, collation_name: &str) -> Result<()> {
                let c_name = str_to_cstring(collation_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_collation_v2(
                        self.db(),
                        c_name.as_ptr(),
                        ffi::SQLITE_UTF8,
                        ptr::null_mut(),
                        None,
                        None,
                    )
                };
                self.decode_result(r)
            }
        }
    }

    mod column
    {
        use ::
        {
            *,
        };
        use std::str;

        use crate::{Error, Result, Statement};

        /// Information about a column of a SQLite query.
        #[cfg(feature = "column_decltype")]
        #[cfg_attr(docsrs, doc(cfg(feature = "column_decltype")))]
        #[derive(Debug)]
        pub struct Column<'stmt> {
            name: &'stmt str,
            decl_type: Option<&'stmt str>,
        }

        #[cfg(feature = "column_decltype")]
        #[cfg_attr(docsrs, doc(cfg(feature = "column_decltype")))]
        impl Column<'_> {
            /// Returns the name of the column.
            #[inline]
            #[must_use]
            pub fn name(&self) -> &str {
                self.name
            }
            /// Returns the type of the column (`None` for expression).
            #[inline]
            #[must_use]
            pub fn decl_type(&self) -> Option<&str> {
                self.decl_type
            }
        }

        impl Statement<'_> {
            /// Get all the column names in the result set of the prepared statement.
            pub fn column_names(&self) -> Vec<&str> {
                let n = self.column_count();
                let mut cols = Vec::with_capacity(n);
                for i in 0..n {
                    let s = self.column_name_unwrap(i);
                    cols.push(s);
                }
                cols
            }
            /// Return the number of columns in the result set returned by the prepared statement.
            #[inline]
            pub fn column_count(&self) -> usize {
                self.stmt.column_count()
            }
            /// Check that column name reference lifetime is limited:
            /// https://www.sqlite.org/c3ref/column_name.html
            #[inline]
            pub(super) fn column_name_unwrap(&self, col: usize) -> &str {
                // Just panic if the bounds are wrong for now, we never call this
                // without checking first.
                self.column_name(col).expect("Column out of bounds")
            }
            /// Returns the name assigned to a particular column in the result set returned by the prepared statement.
            #[inline]
            pub fn column_name(&self, col: usize) -> Result<&str> {
                self.stmt
                    .column_name(col)
                    // clippy::or_fun_call (nightly) vs clippy::unnecessary-lazy-evaluations (stable)
                    .ok_or(Error::InvalidColumnIndex(col))
                    .map(|slice| {
                        slice
                            .to_str()
                            .expect("Invalid UTF-8 sequence in column name")
                    })
            }
            /// Returns the column index in the result set for a given column name.
            #[inline]
            pub fn column_index(&self, name: &str) -> Result<usize> {
                let bytes = name.as_bytes();
                let n = self.column_count();
                for i in 0..n {
                    // Note: `column_name` is only fallible if `i` is out of bounds,
                    // which we've already checked.
                    if bytes.eq_ignore_ascii_case(self.stmt.column_name(i).unwrap().to_bytes()) {
                        return Ok(i);
                    }
                }
                Err(Error::InvalidColumnName(String::from(name)))
            }
            /// Returns a slice describing the columns of the result of the query.
            pub fn columns(&self) -> Vec<Column> {
                let n = self.column_count();
                let mut cols = Vec::with_capacity(n);
                for i in 0..n {
                    let name = self.column_name_unwrap(i);
                    let slice = self.stmt.column_decltype(i);
                    let decl_type = slice.map(|s| {
                        s.to_str()
                            .expect("Invalid UTF-8 sequence in column declaration")
                    });
                    cols.push(Column { name, decl_type });
                }
                cols
            }
        }
    }

    pub mod config
    {
        //! Configure database connections
        use ::
        {
            *,
        };
        

        use std::os::raw::c_int;

        use crate::error::check;
        use crate::ffi;
        use crate::{Connection, Result};

        /// Database Connection Configuration Options
        /// See [Database Connection Configuration Options](https://sqlite.org/c3ref/c_dbconfig_enable_fkey.html) for details.
        #[repr(i32)]
        #[derive(Copy, Clone, Debug)]
        #[allow(non_snake_case, non_camel_case_types)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms)]
        pub enum DbConfig {
            //SQLITE_DBCONFIG_MAINDBNAME = 1000, /* const char* */
            //SQLITE_DBCONFIG_LOOKASIDE = 1001,  /* void* int int */
            /// Enable or disable the enforcement of foreign key constraints.
            SQLITE_DBCONFIG_ENABLE_FKEY = ffi::SQLITE_DBCONFIG_ENABLE_FKEY,
            /// Enable or disable triggers.
            SQLITE_DBCONFIG_ENABLE_TRIGGER = ffi::SQLITE_DBCONFIG_ENABLE_TRIGGER,
            /// Enable or disable the fts3_tokenizer() function which is part of the
            /// FTS3 full-text search engine extension.
            SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = ffi::SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, // 3.12.0
            //SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005,
            /// In WAL mode, enable or disable the checkpoint operation before closing
            /// the connection.
            SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE = 1006, // 3.16.2
            /// Activates or deactivates the query planner stability guarantee (QPSG).
            SQLITE_DBCONFIG_ENABLE_QPSG = 1007, // 3.20.0
            /// Includes or excludes output for any operations performed by trigger
            /// programs from the output of EXPLAIN QUERY PLAN commands.
            SQLITE_DBCONFIG_TRIGGER_EQP = 1008, // 3.22.0
            /// Activates or deactivates the "reset" flag for a database connection.
            /// Run VACUUM with this flag set to reset the database.
            SQLITE_DBCONFIG_RESET_DATABASE = 1009, // 3.24.0
            /// Activates or deactivates the "defensive" flag for a database connection.
            SQLITE_DBCONFIG_DEFENSIVE = 1010, // 3.26.0
            /// Activates or deactivates the "writable_schema" flag.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_WRITABLE_SCHEMA = 1011, // 3.28.0
            /// Activates or deactivates the legacy behavior of the ALTER TABLE RENAME
            /// command.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_LEGACY_ALTER_TABLE = 1012, // 3.29
            /// Activates or deactivates the legacy double-quoted string literal
            /// misfeature for DML statements only.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_DQS_DML = 1013, // 3.29.0
            /// Activates or deactivates the legacy double-quoted string literal
            /// misfeature for DDL statements.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_DQS_DDL = 1014, // 3.29.0
            /// Enable or disable views.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_ENABLE_VIEW = 1015, // 3.30.0
            /// Activates or deactivates the legacy file format flag.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_LEGACY_FILE_FORMAT = 1016, // 3.31.0
            /// Tells SQLite to assume that database schemas (the contents of the
            /// sqlite_master tables) are untainted by malicious content.
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_TRUSTED_SCHEMA = 1017, // 3.31.0
            /// Sets or clears a flag that enables collection of the
            /// sqlite3_stmt_scanstatus_v2() statistics
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_STMT_SCANSTATUS = 1018, // 3.42.0
            /// Changes the default order in which tables and indexes are scanned
            #[cfg(feature = "modern_sqlite")]
            SQLITE_DBCONFIG_REVERSE_SCANORDER = 1019, // 3.42.0
        }

        impl Connection {
            /// Returns the current value of a `config`.
            ///
            /// - `SQLITE_DBCONFIG_ENABLE_FKEY`: return `false` or `true` to indicate
            ///   whether FK enforcement is off or on
            /// - `SQLITE_DBCONFIG_ENABLE_TRIGGER`: return `false` or `true` to indicate
            ///   whether triggers are disabled or enabled
            /// - `SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER`: return `false` or `true` to
            ///   indicate whether `fts3_tokenizer` are disabled or enabled
            /// - `SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE`: return `false` to indicate
            ///   checkpoints-on-close are not disabled or `true` if they are
            /// - `SQLITE_DBCONFIG_ENABLE_QPSG`: return `false` or `true` to indicate
            ///   whether the QPSG is disabled or enabled
            /// - `SQLITE_DBCONFIG_TRIGGER_EQP`: return `false` to indicate
            ///   output-for-trigger are not disabled or `true` if it is
            #[inline]
            pub fn db_config(&self, config: DbConfig) -> Result<bool> {
                let c = self.db.borrow();
                unsafe {
                    let mut val = 0;
                    check(ffi::sqlite3_db_config(
                        c.db(),
                        config as c_int,
                        -1,
                        &mut val,
                    ))?;
                    Ok(val != 0)
                }
            }
            /// Make configuration changes to a database connection
            ///
            /// - `SQLITE_DBCONFIG_ENABLE_FKEY`: `false` to disable FK enforcement,
            ///   `true` to enable FK enforcement
            /// - `SQLITE_DBCONFIG_ENABLE_TRIGGER`: `false` to disable triggers, `true`
            ///   to enable triggers
            /// - `SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER`: `false` to disable
            ///   `fts3_tokenizer()`, `true` to enable `fts3_tokenizer()`
            /// - `SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE`: `false` (the default) to enable
            ///   checkpoints-on-close, `true` to disable them
            /// - `SQLITE_DBCONFIG_ENABLE_QPSG`: `false` to disable the QPSG, `true` to
            ///   enable QPSG
            /// - `SQLITE_DBCONFIG_TRIGGER_EQP`: `false` to disable output for trigger
            ///   programs, `true` to enable it
            #[inline]
            pub fn set_db_config(&self, config: DbConfig, new_val: bool) -> Result<bool> {
                let c = self.db.borrow_mut();
                unsafe {
                    let mut val = 0;
                    check(ffi::sqlite3_db_config(
                        c.db(),
                        config as c_int,
                        new_val as c_int,
                        &mut val,
                    ))?;
                    Ok(val != 0)
                }
            }
        }
    }
    
    mod context
    {
        //! Code related to `sqlite3_context` common to `functions` and `vtab` modules.
        use ::
        {
            *,
        };
        

        use libsqlite3_sys::sqlite3_value;
        use std::os::raw::{c_int, c_void};
        #[cfg(feature = "array")]
        use std::rc::Rc;

        use crate::ffi;
        use crate::ffi::sqlite3_context;

        use crate::str_for_sqlite;
        use crate::types::{ToSqlOutput, ValueRef};
        #[cfg(feature = "array")]
        use crate::vtab::array::{free_array, ARRAY_TYPE};

        // This function is inline despite it's size because what's in the ToSqlOutput
        // is often known to the compiler, and thus const prop/DCE can substantially
        // simplify the function.
        #[inline]
        pub(super) unsafe fn set_result(
            ctx: *mut sqlite3_context,
            #[allow(unused_variables)] args: &[*mut sqlite3_value],
            result: &ToSqlOutput<'_>,
        ) {
            let value = match *result {
                ToSqlOutput::Borrowed(v) => v,
                ToSqlOutput::Owned(ref v) => ValueRef::from(v),

                #[cfg(feature = "blob")]
                ToSqlOutput::ZeroBlob(len) => {
                    // TODO sqlite3_result_zeroblob64 // 3.8.11
                    return ffi::sqlite3_result_zeroblob(ctx, len);
                }
                #[cfg(feature = "functions")]
                ToSqlOutput::Arg(i) => {
                    return ffi::sqlite3_result_value(ctx, args[i]);
                }
                #[cfg(feature = "array")]
                ToSqlOutput::Array(ref a) => {
                    return ffi::sqlite3_result_pointer(
                        ctx,
                        Rc::into_raw(a.clone()) as *mut c_void,
                        ARRAY_TYPE,
                        Some(free_array),
                    );
                }
            };

            match value {
                ValueRef::Null => ffi::sqlite3_result_null(ctx),
                ValueRef::Integer(i) => ffi::sqlite3_result_int64(ctx, i),
                ValueRef::Real(r) => ffi::sqlite3_result_double(ctx, r),
                ValueRef::Text(s) => {
                    let length = s.len();
                    if length > c_int::MAX as usize {
                        ffi::sqlite3_result_error_toobig(ctx);
                    } else {
                        let (c_str, len, destructor) = match str_for_sqlite(s) {
                            Ok(c_str) => c_str,
                            // TODO sqlite3_result_error
                            Err(_) => return ffi::sqlite3_result_error_code(ctx, ffi::SQLITE_MISUSE),
                        };
                        // TODO sqlite3_result_text64 // 3.8.7
                        ffi::sqlite3_result_text(ctx, c_str, len, destructor);
                    }
                }
                ValueRef::Blob(b) => {
                    let length = b.len();
                    if length > c_int::MAX as usize {
                        ffi::sqlite3_result_error_toobig(ctx);
                    } else if length == 0 {
                        ffi::sqlite3_result_zeroblob(ctx, 0);
                    } else {
                        // TODO sqlite3_result_blob64 // 3.8.7
                        ffi::sqlite3_result_blob(
                            ctx,
                            b.as_ptr().cast::<c_void>(),
                            length as c_int,
                            ffi::SQLITE_TRANSIENT(),
                        );
                    }
                }
            }
        }
    }
    
    pub mod functions
    {
        //! Create or redefine SQL functions.
        use ::
        {
            *,
        };
        
        use std::any::Any;
        use std::marker::PhantomData;
        use std::ops::Deref;
        use std::os::raw::{c_int, c_void};
        use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};
        use std::ptr;
        use std::slice;
        use std::sync::Arc;

        use crate::ffi;
        use crate::ffi::sqlite3_context;
        use crate::ffi::sqlite3_value;

        use crate::context::set_result;
        use crate::types::{FromSql, FromSqlError, ToSql, ToSqlOutput, ValueRef};

        use crate::{str_to_cstring, Connection, Error, InnerConnection, Result};

        unsafe fn report_error(ctx: *mut sqlite3_context, err: &Error) {
            if let Error::SqliteFailure(ref err, ref s) = *err {
                ffi::sqlite3_result_error_code(ctx, err.extended_code);
                if let Some(Ok(cstr)) = s.as_ref().map(|s| str_to_cstring(s)) {
                    ffi::sqlite3_result_error(ctx, cstr.as_ptr(), -1);
                }
            } else {
                ffi::sqlite3_result_error_code(ctx, ffi::SQLITE_CONSTRAINT_FUNCTION);
                if let Ok(cstr) = str_to_cstring(&err.to_string()) {
                    ffi::sqlite3_result_error(ctx, cstr.as_ptr(), -1);
                }
            }
        }

        unsafe extern "C" fn free_boxed_value<T>(p: *mut c_void) {
            drop(Box::from_raw(p.cast::<T>()));
        }
        /// Context is a wrapper for the SQLite function
        /// evaluation context.
        pub struct Context<'a> {
            ctx: *mut sqlite3_context,
            args: &'a [*mut sqlite3_value],
        }

        impl Context<'_> {
            /// Returns the number of arguments to the function.
            #[inline]
            #[must_use]
            pub fn len(&self) -> usize {
                self.args.len()
            }
            /// Returns `true` when there is no argument.
            #[inline]
            #[must_use]
            pub fn is_empty(&self) -> bool {
                self.args.is_empty()
            }
            /// Returns the `idx`th argument as a `T`.
            ///
            /// # Failure
            ///
            /// Will panic if `idx` is greater than or equal to
            /// [`self.len()`](Context::len).
            ///
            /// Will return Err if the underlying SQLite type cannot be converted to a
            /// `T`.
            pub fn get<T: FromSql>(&self, idx: usize) -> Result<T> {
                let arg = self.args[idx];
                let value = unsafe { ValueRef::from_value(arg) };
                FromSql::column_result(value).map_err(|err| match err {
                    FromSqlError::InvalidType => {
                        Error::InvalidFunctionParameterType(idx, value.data_type())
                    }
                    FromSqlError::OutOfRange(i) => Error::IntegralValueOutOfRange(idx, i),
                    FromSqlError::Other(err) => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), err)
                    }
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), Box::new(err))
                    }
                })
            }
            /// Returns the `idx`th argument as a `ValueRef`.
            ///
            /// # Failure
            ///
            /// Will panic if `idx` is greater than or equal to
            /// [`self.len()`](Context::len).
            #[inline]
            #[must_use]
            pub fn get_raw(&self, idx: usize) -> ValueRef<'_> {
                let arg = self.args[idx];
                unsafe { ValueRef::from_value(arg) }
            }
            /// Returns the `idx`th argument as a `SqlFnArg`.
            /// To be used when the SQL function result is one of its arguments.
            #[inline]
            #[must_use]
            pub fn get_arg(&self, idx: usize) -> SqlFnArg {
                assert!(idx < self.len());
                SqlFnArg { idx }
            }
            /// Returns the subtype of `idx`th argument.
            ///
            /// # Failure
            ///
            /// Will panic if `idx` is greater than or equal to
            /// [`self.len()`](Context::len).
            pub fn get_subtype(&self, idx: usize) -> std::os::raw::c_uint {
                let arg = self.args[idx];
                unsafe { ffi::sqlite3_value_subtype(arg) }
            }
            /// Fetch or insert the auxiliary data associated with a particular
            /// parameter. This is intended to be an easier-to-use way of fetching it
            /// compared to calling [`get_aux`](Context::get_aux) and
            /// [`set_aux`](Context::set_aux) separately.
            ///
            /// See `https://www.sqlite.org/c3ref/get_auxdata.html` for a discussion of
            /// this feature, or the unit tests of this module for an example.
            pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>
            where
                T: Send + Sync + 'static,
                E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
                F: FnOnce(ValueRef<'_>) -> Result<T, E>,
            {
                if let Some(v) = self.get_aux(arg)? {
                    Ok(v)
                } else {
                    let vr = self.get_raw(arg as usize);
                    self.set_aux(
                        arg,
                        func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,
                    )
                }
            }
            /// Sets the auxiliary data associated with a particular parameter. See
            /// `https://www.sqlite.org/c3ref/get_auxdata.html` for a discussion of
            /// this feature, or the unit tests of this module for an example.
            pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {
                let orig: Arc<T> = Arc::new(value);
                let inner: AuxInner = orig.clone();
                let outer = Box::new(inner);
                let raw: *mut AuxInner = Box::into_raw(outer);
                unsafe {
                    ffi::sqlite3_set_auxdata(
                        self.ctx,
                        arg,
                        raw.cast(),
                        Some(free_boxed_value::<AuxInner>),
                    );
                };
                Ok(orig)
            }
            /// Gets the auxiliary data that was associated with a given parameter via
            /// [`set_aux`](Context::set_aux). Returns `Ok(None)` if no data has been
            /// associated, and Ok(Some(v)) if it has. Returns an error if the
            /// requested type does not match.
            pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {
                let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };
                if p.is_null() {
                    Ok(None)
                } else {
                    let v: AuxInner = AuxInner::clone(unsafe { &*p });
                    v.downcast::<T>()
                        .map(Some)
                        .map_err(|_| Error::GetAuxWrongType)
                }
            }
            /// Get the db connection handle via [sqlite3_context_db_handle](https://www.sqlite.org/c3ref/context_db_handle.html)
            ///
            /// # Safety
            ///
            /// This function is marked unsafe because there is a potential for other
            /// references to the connection to be sent across threads, [see this comment](https://github.com/rusqlite/rusqlite/issues/643#issuecomment-640181213).
            pub unsafe fn get_connection(&self) -> Result<ConnectionRef<'_>> {
                let handle = ffi::sqlite3_context_db_handle(self.ctx);
                Ok(ConnectionRef {
                    conn: Connection::from_handle(handle)?,
                    phantom: PhantomData,
                })
            }
        }
        /// A reference to a connection handle with a lifetime bound to something.
        pub struct ConnectionRef<'ctx> {
            // comes from Connection::from_handle(sqlite3_context_db_handle(...))
            // and is non-owning
            conn: Connection,
            phantom: PhantomData<&'ctx Context<'ctx>>,
        }

        impl Deref for ConnectionRef<'_> {
            type Target = Connection;

            #[inline]
            fn deref(&self) -> &Connection {
                &self.conn
            }
        }

        type AuxInner = Arc<dyn Any + Send + Sync + 'static>;

        /// Subtype of an SQL function
        pub type SubType = Option<std::os::raw::c_uint>;

        /// Result of an SQL function
        pub trait SqlFnOutput {
            /// Converts Rust value to SQLite value with an optional subtype
            fn to_sql(&self) -> Result<(ToSqlOutput<'_>, SubType)>;
        }

        impl<T: ToSql> SqlFnOutput for T {
            #[inline]
            fn to_sql(&self) -> Result<(ToSqlOutput<'_>, SubType)> {
                ToSql::to_sql(self).map(|o| (o, None))
            }
        }

        impl<T: ToSql> SqlFnOutput for (T, SubType) {
            fn to_sql(&self) -> Result<(ToSqlOutput<'_>, SubType)> {
                ToSql::to_sql(&self.0).map(|o| (o, self.1))
            }
        }
        /// n-th arg of an SQL scalar function
        pub struct SqlFnArg {
            idx: usize,
        }
        impl ToSql for SqlFnArg {
            fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                Ok(ToSqlOutput::Arg(self.idx))
            }
        }

        unsafe fn sql_result<T: SqlFnOutput>(
            ctx: *mut sqlite3_context,
            args: &[*mut sqlite3_value],
            r: Result<T>,
        ) {
            let t = r.as_ref().map(SqlFnOutput::to_sql);

            match t {
                Ok(Ok((ref value, sub_type))) => {
                    set_result(ctx, args, value);
                    if let Some(sub_type) = sub_type {
                        ffi::sqlite3_result_subtype(ctx, sub_type);
                    }
                }
                Ok(Err(err)) => report_error(ctx, &err),
                Err(err) => report_error(ctx, err),
            };
        }
        /// Aggregate is the callback interface for user-defined
        /// aggregate function.
        ///
        /// `A` is the type of the aggregation context and `T` is the type of the final
        /// result. Implementations should be stateless.
        pub trait Aggregate<A, T>
        where
            A: RefUnwindSafe + UnwindSafe,
            T: SqlFnOutput,
        {
            /// Initializes the aggregation context. Will be called prior to the first
            /// call to [`step()`](Aggregate::step) to set up the context for an
            /// invocation of the function. (Note: `init()` will not be called if
            /// there are no rows.)
            fn init(&self, ctx: &mut Context<'_>) -> Result<A>;

            /// "step" function called once for each row in an aggregate group. May be
            /// called 0 times if there are no rows.
            fn step(&self, ctx: &mut Context<'_>, acc: &mut A) -> Result<()>;

            /// Computes and returns the final result. Will be called exactly once for
            /// each invocation of the function. If [`step()`](Aggregate::step) was
            /// called at least once, will be given `Some(A)` (the same `A` as was
            /// created by [`init`](Aggregate::init) and given to
            /// [`step`](Aggregate::step)); if [`step()`](Aggregate::step) was not
            /// called (because the function is running against 0 rows), will be
            /// given `None`.
            ///
            /// The passed context will have no arguments.
            fn finalize(&self, ctx: &mut Context<'_>, acc: Option<A>) -> Result<T>;
        }
        /// `WindowAggregate` is the callback interface for
        /// user-defined aggregate window function.
        #[cfg(feature = "window")]
        #[cfg_attr(docsrs, doc(cfg(feature = "window")))]
        pub trait WindowAggregate<A, T>: Aggregate<A, T>
        where
            A: RefUnwindSafe + UnwindSafe,
            T: SqlFnOutput,
        {
            /// Returns the current value of the aggregate. Unlike xFinal, the
            /// implementation should not delete any context.
            fn value(&self, acc: Option<&mut A>) -> Result<T>;

            /// Removes a row from the current window.
            fn inverse(&self, ctx: &mut Context<'_>, acc: &mut A) -> Result<()>;
        }

        bitflags::bitflags! {
            /// Function Flags.
            /// See [sqlite3_create_function](https://sqlite.org/c3ref/create_function.html)
            /// and [Function Flags](https://sqlite.org/c3ref/c_deterministic.html) for details.
            #[derive(Clone, Copy, Debug)]
            #[repr(C)]
            pub struct FunctionFlags: ::std::os::raw::c_int {
                /// Specifies UTF-8 as the text encoding this SQL function prefers for its parameters.
                const SQLITE_UTF8     = ffi::SQLITE_UTF8;
                /// Specifies UTF-16 using little-endian byte order as the text encoding this SQL function prefers for its parameters.
                const SQLITE_UTF16LE  = ffi::SQLITE_UTF16LE;
                /// Specifies UTF-16 using big-endian byte order as the text encoding this SQL function prefers for its parameters.
                const SQLITE_UTF16BE  = ffi::SQLITE_UTF16BE;
                /// Specifies UTF-16 using native byte order as the text encoding this SQL function prefers for its parameters.
                const SQLITE_UTF16    = ffi::SQLITE_UTF16;
                /// Means that the function always gives the same output when the input parameters are the same.
                const SQLITE_DETERMINISTIC = ffi::SQLITE_DETERMINISTIC; // 3.8.3
                /// Means that the function may only be invoked from top-level SQL.
                const SQLITE_DIRECTONLY    = 0x0000_0008_0000; // 3.30.0
                /// Indicates to SQLite that a function may call `sqlite3_value_subtype()` to inspect the subtypes of its arguments.
                const SQLITE_SUBTYPE       = 0x0000_0010_0000; // 3.30.0
                /// Means that the function is unlikely to cause problems even if misused.
                const SQLITE_INNOCUOUS     = 0x0000_0020_0000; // 3.31.0
                /// Indicates to SQLite that a function might call `sqlite3_result_subtype()` to cause a subtype to be associated with its result.
                const SQLITE_RESULT_SUBTYPE     = 0x0000_0100_0000; // 3.45.0
            }
        }

        impl Default for FunctionFlags {
            #[inline]
            fn default() -> FunctionFlags {
                FunctionFlags::SQLITE_UTF8
            }
        }

        impl Connection {
            /// Attach a user-defined scalar function to this database connection.
            #[inline]
            pub fn create_scalar_function<F, T>(
                &self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                x_func: F,
            ) -> Result<()>
            where
                F: FnMut(&Context<'_>) -> Result<T> + Send + 'static,
                T: SqlFnOutput,
            {
                self.db
                    .borrow_mut()
                    .create_scalar_function(fn_name, n_arg, flags, x_func)
            }
            /// Attach a user-defined aggregate function to this database connection.
            #[inline]
            pub fn create_aggregate_function<A, D, T>(
                &self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                aggr: D,
            ) -> Result<()>
            where
                A: RefUnwindSafe + UnwindSafe,
                D: Aggregate<A, T> + 'static,
                T: SqlFnOutput,
            {
                self.db
                    .borrow_mut()
                    .create_aggregate_function(fn_name, n_arg, flags, aggr)
            }
            /// Attach a user-defined aggregate window function to this database connection.
            #[cfg(feature = "window")]
            #[cfg_attr(docsrs, doc(cfg(feature = "window")))]
            #[inline]
            pub fn create_window_function<A, W, T>(
                &self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                aggr: W,
            ) -> Result<()>
            where
                A: RefUnwindSafe + UnwindSafe,
                W: WindowAggregate<A, T> + 'static,
                T: SqlFnOutput,
            {
                self.db
                    .borrow_mut()
                    .create_window_function(fn_name, n_arg, flags, aggr)
            }
            /// Removes a user-defined function from this database connection.
            #[inline]
            pub fn remove_function(&self, fn_name: &str, n_arg: c_int) -> Result<()> {
                self.db.borrow_mut().remove_function(fn_name, n_arg)
            }
        }

        impl InnerConnection {
            fn create_scalar_function<F, T>(
                &mut self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                x_func: F,
            ) -> Result<()>
            where
                F: FnMut(&Context<'_>) -> Result<T> + Send + 'static,
                T: SqlFnOutput,
            {
                unsafe extern "C" fn call_boxed_closure<F, T>(
                    ctx: *mut sqlite3_context,
                    argc: c_int,
                    argv: *mut *mut sqlite3_value,
                ) where
                    F: FnMut(&Context<'_>) -> Result<T>,
                    T: SqlFnOutput,
                {
                    let args = slice::from_raw_parts(argv, argc as usize);
                    let r = catch_unwind(|| {
                        let boxed_f: *mut F = ffi::sqlite3_user_data(ctx).cast::<F>();
                        assert!(!boxed_f.is_null(), "Internal error - null function pointer");
                        let ctx = Context { ctx, args };
                        (*boxed_f)(&ctx)
                    });
                    let t = match r {
                        Err(_) => {
                            report_error(ctx, &Error::UnwindingPanic);
                            return;
                        }
                        Ok(r) => r,
                    };
                    sql_result(ctx, args, t);
                }

                let boxed_f: *mut F = Box::into_raw(Box::new(x_func));
                let c_name = str_to_cstring(fn_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_function_v2(
                        self.db(),
                        c_name.as_ptr(),
                        n_arg,
                        flags.bits(),
                        boxed_f.cast::<c_void>(),
                        Some(call_boxed_closure::<F, T>),
                        None,
                        None,
                        Some(free_boxed_value::<F>),
                    )
                };
                self.decode_result(r)
            }

            fn create_aggregate_function<A, D, T>(
                &mut self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                aggr: D,
            ) -> Result<()>
            where
                A: RefUnwindSafe + UnwindSafe,
                D: Aggregate<A, T> + 'static,
                T: SqlFnOutput,
            {
                let boxed_aggr: *mut D = Box::into_raw(Box::new(aggr));
                let c_name = str_to_cstring(fn_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_function_v2(
                        self.db(),
                        c_name.as_ptr(),
                        n_arg,
                        flags.bits(),
                        boxed_aggr.cast::<c_void>(),
                        None,
                        Some(call_boxed_step::<A, D, T>),
                        Some(call_boxed_final::<A, D, T>),
                        Some(free_boxed_value::<D>),
                    )
                };
                self.decode_result(r)
            }

            #[cfg(feature = "window")]
            fn create_window_function<A, W, T>(
                &mut self,
                fn_name: &str,
                n_arg: c_int,
                flags: FunctionFlags,
                aggr: W,
            ) -> Result<()>
            where
                A: RefUnwindSafe + UnwindSafe,
                W: WindowAggregate<A, T> + 'static,
                T: SqlFnOutput,
            {
                let boxed_aggr: *mut W = Box::into_raw(Box::new(aggr));
                let c_name = str_to_cstring(fn_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_window_function(
                        self.db(),
                        c_name.as_ptr(),
                        n_arg,
                        flags.bits(),
                        boxed_aggr.cast::<c_void>(),
                        Some(call_boxed_step::<A, W, T>),
                        Some(call_boxed_final::<A, W, T>),
                        Some(call_boxed_value::<A, W, T>),
                        Some(call_boxed_inverse::<A, W, T>),
                        Some(free_boxed_value::<W>),
                    )
                };
                self.decode_result(r)
            }

            fn remove_function(&mut self, fn_name: &str, n_arg: c_int) -> Result<()> {
                let c_name = str_to_cstring(fn_name)?;
                let r = unsafe {
                    ffi::sqlite3_create_function_v2(
                        self.db(),
                        c_name.as_ptr(),
                        n_arg,
                        ffi::SQLITE_UTF8,
                        ptr::null_mut(),
                        None,
                        None,
                        None,
                        None,
                    )
                };
                self.decode_result(r)
            }
        }

        unsafe fn aggregate_context<A>(ctx: *mut sqlite3_context, bytes: usize) -> Option<*mut *mut A> {
            let pac = ffi::sqlite3_aggregate_context(ctx, bytes as c_int) as *mut *mut A;
            if pac.is_null() {
                return None;
            }
            Some(pac)
        }

        unsafe extern "C" fn call_boxed_step<A, D, T>(
            ctx: *mut sqlite3_context,
            argc: c_int,
            argv: *mut *mut sqlite3_value,
        ) where
            A: RefUnwindSafe + UnwindSafe,
            D: Aggregate<A, T>,
            T: SqlFnOutput,
        {
            let pac = if let Some(pac) = aggregate_context(ctx, std::mem::size_of::<*mut A>()) {
                pac
            } else {
                ffi::sqlite3_result_error_nomem(ctx);
                return;
            };

            let r = catch_unwind(|| {
                let boxed_aggr: *mut D = ffi::sqlite3_user_data(ctx).cast::<D>();
                assert!(
                    !boxed_aggr.is_null(),
                    "Internal error - null aggregate pointer"
                );
                let mut ctx = Context {
                    ctx,
                    args: slice::from_raw_parts(argv, argc as usize),
                };

                #[allow(clippy::unnecessary_cast)]
                if (*pac as *mut A).is_null() {
                    *pac = Box::into_raw(Box::new((*boxed_aggr).init(&mut ctx)?));
                }

                (*boxed_aggr).step(&mut ctx, &mut **pac)
            });
            let r = match r {
                Err(_) => {
                    report_error(ctx, &Error::UnwindingPanic);
                    return;
                }
                Ok(r) => r,
            };
            match r {
                Ok(_) => {}
                Err(err) => report_error(ctx, &err),
            };
        }

        #[cfg(feature = "window")]
        unsafe extern "C" fn call_boxed_inverse<A, W, T>(
            ctx: *mut sqlite3_context,
            argc: c_int,
            argv: *mut *mut sqlite3_value,
        ) where
            A: RefUnwindSafe + UnwindSafe,
            W: WindowAggregate<A, T>,
            T: SqlFnOutput,
        {
            let pac = if let Some(pac) = aggregate_context(ctx, std::mem::size_of::<*mut A>()) {
                pac
            } else {
                ffi::sqlite3_result_error_nomem(ctx);
                return;
            };

            let r = catch_unwind(|| {
                let boxed_aggr: *mut W = ffi::sqlite3_user_data(ctx).cast::<W>();
                assert!(
                    !boxed_aggr.is_null(),
                    "Internal error - null aggregate pointer"
                );
                let mut ctx = Context {
                    ctx,
                    args: slice::from_raw_parts(argv, argc as usize),
                };
                (*boxed_aggr).inverse(&mut ctx, &mut **pac)
            });
            let r = match r {
                Err(_) => {
                    report_error(ctx, &Error::UnwindingPanic);
                    return;
                }
                Ok(r) => r,
            };
            match r {
                Ok(_) => {}
                Err(err) => report_error(ctx, &err),
            };
        }

        unsafe extern "C" fn call_boxed_final<A, D, T>(ctx: *mut sqlite3_context)
        where
            A: RefUnwindSafe + UnwindSafe,
            D: Aggregate<A, T>,
            T: SqlFnOutput,
        {
            // Within the xFinal callback, it is customary to set N=0 in calls to
            // sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.
            let a: Option<A> = match aggregate_context(ctx, 0) {
                Some(pac) =>
                {
                    #[allow(clippy::unnecessary_cast)]
                    if (*pac as *mut A).is_null() {
                        None
                    } else {
                        let a = Box::from_raw(*pac);
                        Some(*a)
                    }
                }
                None => None,
            };

            let r = catch_unwind(|| {
                let boxed_aggr: *mut D = ffi::sqlite3_user_data(ctx).cast::<D>();
                assert!(
                    !boxed_aggr.is_null(),
                    "Internal error - null aggregate pointer"
                );
                let mut ctx = Context { ctx, args: &mut [] };
                (*boxed_aggr).finalize(&mut ctx, a)
            });
            let t = match r {
                Err(_) => {
                    report_error(ctx, &Error::UnwindingPanic);
                    return;
                }
                Ok(r) => r,
            };
            sql_result(ctx, &[], t);
        }

        #[cfg(feature = "window")]
        unsafe extern "C" fn call_boxed_value<A, W, T>(ctx: *mut sqlite3_context)
        where
            A: RefUnwindSafe + UnwindSafe,
            W: WindowAggregate<A, T>,
            T: SqlFnOutput,
        {
            // Within the xValue callback, it is customary to set N=0 in calls to
            // sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.
            let pac = aggregate_context(ctx, 0).filter(|&pac| {
                #[allow(clippy::unnecessary_cast)]
                !(*pac as *mut A).is_null()
            });

            let r = catch_unwind(|| {
                let boxed_aggr: *mut W = ffi::sqlite3_user_data(ctx).cast::<W>();
                assert!(
                    !boxed_aggr.is_null(),
                    "Internal error - null aggregate pointer"
                );
                (*boxed_aggr).value(pac.map(|pac| &mut **pac))
            });
            let t = match r {
                Err(_) => {
                    report_error(ctx, &Error::UnwindingPanic);
                    return;
                }
                Ok(r) => r,
            };
            sql_result(ctx, &[], t);
        }
    }
    
    pub mod hooks
    {
        //! Commit, Data Change and Rollback Notification Callbacks
        use ::
        {
            *,
        };
        
        #![allow(non_camel_case_types)]

        use std::os::raw::{c_char, c_int, c_void};
        use std::panic::catch_unwind;
        use std::ptr;

        use crate::ffi;

        use crate::{Connection, InnerConnection};

        #[cfg(feature = "preupdate_hook")]
        pub use preupdate_hook::*;

        #[cfg(feature = "preupdate_hook")]
        mod preupdate_hook
        {
            use ::
            {
                *,
            };
            use std::fmt::Debug;
            use std::os::raw::{c_char, c_int, c_void};
            use std::panic::catch_unwind;
            use std::ptr;

            use super::expect_utf8;
            use super::free_boxed_hook;
            use super::Action;
            use crate::error::check;
            use crate::ffi;
            use crate::inner_connection::InnerConnection;
            use crate::types::ValueRef;
            use crate::Connection;
            use crate::Result;

            /// The possible cases for when a PreUpdateHook gets triggered. Allows access to the relevant
            /// functions for each case through the contained values.
            #[derive(Debug)]
            pub enum PreUpdateCase {
                /// Pre-update hook was triggered by an insert.
                Insert(PreUpdateNewValueAccessor),
                /// Pre-update hook was triggered by a delete.
                Delete(PreUpdateOldValueAccessor),
                /// Pre-update hook was triggered by an update.
                Update {
                    #[allow(missing_docs)]
                    old_value_accessor: PreUpdateOldValueAccessor,
                    #[allow(missing_docs)]
                    new_value_accessor: PreUpdateNewValueAccessor,
                },
                /// This variant is not normally produced by SQLite. You may encounter it
                /// if you're using a different version than what's supported by this library.
                Unknown,
            }

            impl From<PreUpdateCase> for Action {
                fn from(puc: PreUpdateCase) -> Action {
                    match puc {
                        PreUpdateCase::Insert(_) => Action::SQLITE_INSERT,
                        PreUpdateCase::Delete(_) => Action::SQLITE_DELETE,
                        PreUpdateCase::Update { .. } => Action::SQLITE_UPDATE,
                        PreUpdateCase::Unknown => Action::UNKNOWN,
                    }
                }
            }
            /// An accessor to access the old values of the row being deleted/updated during the preupdate callback.
            #[derive(Debug)]
            pub struct PreUpdateOldValueAccessor {
                db: *mut ffi::sqlite3,
                old_row_id: i64,
            }

            impl PreUpdateOldValueAccessor {
                /// Get the amount of columns in the row being deleted/updated.
                pub fn get_column_count(&self) -> i32 {
                    unsafe { ffi::sqlite3_preupdate_count(self.db) }
                }
                /// Get the depth of the query that triggered the preupdate hook.
                /// Returns 0 if the preupdate callback was invoked as a result of
                /// a direct insert, update, or delete operation;
                /// 1 for inserts, updates, or deletes invoked by top-level triggers;
                /// 2 for changes resulting from triggers called by top-level triggers; and so forth.
                pub fn get_query_depth(&self) -> i32 {
                    unsafe { ffi::sqlite3_preupdate_depth(self.db) }
                }
                /// Get the row id of the row being updated/deleted.
                pub fn get_old_row_id(&self) -> i64 {
                    self.old_row_id
                }
                /// Get the value of the row being updated/deleted at the specified index.
                pub fn get_old_column_value(&self, i: i32) -> Result<ValueRef> {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    unsafe {
                        check(ffi::sqlite3_preupdate_old(self.db, i, &mut p_value))?;
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }
            /// An accessor to access the new values of the row being inserted/updated
            /// during the preupdate callback.
            #[derive(Debug)]
            pub struct PreUpdateNewValueAccessor {
                db: *mut ffi::sqlite3,
                new_row_id: i64,
            }

            impl PreUpdateNewValueAccessor {
                /// Get the amount of columns in the row being inserted/updated.
                pub fn get_column_count(&self) -> i32 {
                    unsafe { ffi::sqlite3_preupdate_count(self.db) }
                }
                /// Get the depth of the query that triggered the preupdate hook.
                /// Returns 0 if the preupdate callback was invoked as a result of
                /// a direct insert, update, or delete operation;
                /// 1 for inserts, updates, or deletes invoked by top-level triggers;
                /// 2 for changes resulting from triggers called by top-level triggers; and so forth.
                pub fn get_query_depth(&self) -> i32 {
                    unsafe { ffi::sqlite3_preupdate_depth(self.db) }
                }
                /// Get the row id of the row being inserted/updated.
                pub fn get_new_row_id(&self) -> i64 {
                    self.new_row_id
                }
                /// Get the value of the row being updated/deleted at the specified index.
                pub fn get_new_column_value(&self, i: i32) -> Result<ValueRef> {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    unsafe {
                        check(ffi::sqlite3_preupdate_new(self.db, i, &mut p_value))?;
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }

            impl Connection {
                /// Register a callback function to be invoked before
                /// a row is updated, inserted or deleted.
                ///
                /// The callback parameters are:
                ///
                /// - the name of the database ("main", "temp", ...),
                /// - the name of the table that is updated,
                /// - a variant of the PreUpdateCase enum which allows access to extra functions depending
                /// on whether it's an update, delete or insert.
                #[inline]
                pub fn preupdate_hook<F>(&self, hook: Option<F>)  where
                    F: FnMut(Action, &str, &str, &PreUpdateCase) + Send + 'static,
                {
                    self.db.borrow_mut().preupdate_hook(hook);
                }
            }

            impl InnerConnection {
                #[inline]
                pub fn remove_preupdate_hook(&mut self) {
                    self.preupdate_hook(None::<fn(Action, &str, &str, &PreUpdateCase)>);
                }
                
                fn preupdate_hook<F>(&mut self, hook: Option<F>)  where
                    F: FnMut(Action, &str, &str, &PreUpdateCase) + Send + 'static,
                {
                    unsafe extern "C" fn call_boxed_closure<F>(
                        p_arg: *mut c_void,
                        sqlite: *mut ffi::sqlite3,
                        action_code: c_int,
                        db_name: *const c_char,
                        tbl_name: *const c_char,
                        old_row_id: i64,
                        new_row_id: i64,
                    ) where
                        F: FnMut(Action, &str, &str, &PreUpdateCase),
                    {
                        let action = Action::from(action_code);

                        let preupdate_case = match action {
                            Action::SQLITE_INSERT => PreUpdateCase::Insert(PreUpdateNewValueAccessor {
                                db: sqlite,
                                new_row_id,
                            }),
                            Action::SQLITE_DELETE => PreUpdateCase::Delete(PreUpdateOldValueAccessor {
                                db: sqlite,
                                old_row_id,
                            }),
                            Action::SQLITE_UPDATE => PreUpdateCase::Update {
                                old_value_accessor: PreUpdateOldValueAccessor {
                                    db: sqlite,
                                    old_row_id,
                                },
                                new_value_accessor: PreUpdateNewValueAccessor {
                                    db: sqlite,
                                    new_row_id,
                                },
                            },
                            Action::UNKNOWN => PreUpdateCase::Unknown,
                        };

                        drop(catch_unwind(|| {
                            let boxed_hook: *mut F = p_arg.cast::<F>();
                            (*boxed_hook)(
                                action,
                                expect_utf8(db_name, "database name"),
                                expect_utf8(tbl_name, "table name"),
                                &preupdate_case,
                            );
                        }));
                    }

                    let free_preupdate_hook = if hook.is_some() {
                        Some(free_boxed_hook::<F> as unsafe fn(*mut c_void))
                    } else {
                        None
                    };

                    let previous_hook = match hook {
                        Some(hook) => {
                            let boxed_hook: *mut F = Box::into_raw(Box::new(hook));
                            unsafe {
                                ffi::sqlite3_preupdate_hook(
                                    self.db(),
                                    Some(call_boxed_closure::<F>),
                                    boxed_hook.cast(),
                                )
                            }
                        }
                        _ => unsafe { ffi::sqlite3_preupdate_hook(self.db(), None, ptr::null_mut()) },
                    };
                    if !previous_hook.is_null() {
                        if let Some(free_boxed_hook) = self.free_preupdate_hook {
                            unsafe { free_boxed_hook(previous_hook) };
                        }
                    }
                    self.free_preupdate_hook = free_preupdate_hook;
                }
            }
        }
        /// Action Codes
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        #[repr(i32)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms)]
        pub enum Action {
            /// Unsupported / unexpected action
            UNKNOWN = -1,
            /// DELETE command
            SQLITE_DELETE = ffi::SQLITE_DELETE,
            /// INSERT command
            SQLITE_INSERT = ffi::SQLITE_INSERT,
            /// UPDATE command
            SQLITE_UPDATE = ffi::SQLITE_UPDATE,
        }

        impl From<i32> for Action {
            #[inline]
            fn from(code: i32) -> Action {
                match code {
                    ffi::SQLITE_DELETE => Action::SQLITE_DELETE,
                    ffi::SQLITE_INSERT => Action::SQLITE_INSERT,
                    ffi::SQLITE_UPDATE => Action::SQLITE_UPDATE,
                    _ => Action::UNKNOWN,
                }
            }
        }
        /// The context received by an authorizer hook.
        ///
        /// See <https://sqlite.org/c3ref/set_authorizer.html> for more info.
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        pub struct AuthContext<'c> {
            /// The action to be authorized.
            pub action: AuthAction<'c>,

            /// The database name, if applicable.
            pub database_name: Option<&'c str>,

            /// The inner-most trigger or view responsible for the access attempt.
            /// `None` if the access attempt was made by top-level SQL code.
            pub accessor: Option<&'c str>,
        }
        /// Actions and arguments found within a statement during
        /// preparation.
        ///
        /// See <https://sqlite.org/c3ref/c_alter_table.html> for more info.
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        #[non_exhaustive]
        #[allow(missing_docs)]
        pub enum AuthAction<'c> {
            /// This variant is not normally produced by SQLite. You may encounter it
            // if you're using a different version than what's supported by this library.
            Unknown {
                /// The unknown authorization action code.
                code: i32,
                /// The third arg to the authorizer callback.
                arg1: Option<&'c str>,
                /// The fourth arg to the authorizer callback.
                arg2: Option<&'c str>,
            },
            CreateIndex {
                index_name: &'c str,
                table_name: &'c str,
            },
            CreateTable {
                table_name: &'c str,
            },
            CreateTempIndex {
                index_name: &'c str,
                table_name: &'c str,
            },
            CreateTempTable {
                table_name: &'c str,
            },
            CreateTempTrigger {
                trigger_name: &'c str,
                table_name: &'c str,
            },
            CreateTempView {
                view_name: &'c str,
            },
            CreateTrigger {
                trigger_name: &'c str,
                table_name: &'c str,
            },
            CreateView {
                view_name: &'c str,
            },
            Delete {
                table_name: &'c str,
            },
            DropIndex {
                index_name: &'c str,
                table_name: &'c str,
            },
            DropTable {
                table_name: &'c str,
            },
            DropTempIndex {
                index_name: &'c str,
                table_name: &'c str,
            },
            DropTempTable {
                table_name: &'c str,
            },
            DropTempTrigger {
                trigger_name: &'c str,
                table_name: &'c str,
            },
            DropTempView {
                view_name: &'c str,
            },
            DropTrigger {
                trigger_name: &'c str,
                table_name: &'c str,
            },
            DropView {
                view_name: &'c str,
            },
            Insert {
                table_name: &'c str,
            },
            Pragma {
                pragma_name: &'c str,
                /// The pragma value, if present (e.g., `PRAGMA name = value;`).
                pragma_value: Option<&'c str>,
            },
            Read {
                table_name: &'c str,
                column_name: &'c str,
            },
            Select,
            Transaction {
                operation: TransactionOperation,
            },
            Update {
                table_name: &'c str,
                column_name: &'c str,
            },
            Attach {
                filename: &'c str,
            },
            Detach {
                database_name: &'c str,
            },
            AlterTable {
                database_name: &'c str,
                table_name: &'c str,
            },
            Reindex {
                index_name: &'c str,
            },
            Analyze {
                table_name: &'c str,
            },
            CreateVtable {
                table_name: &'c str,
                module_name: &'c str,
            },
            DropVtable {
                table_name: &'c str,
                module_name: &'c str,
            },
            Function {
                function_name: &'c str,
            },
            Savepoint {
                operation: TransactionOperation,
                savepoint_name: &'c str,
            },
            Recursive,
        }

        impl<'c> AuthAction<'c> {
            fn from_raw(code: i32, arg1: Option<&'c str>, arg2: Option<&'c str>) -> Self {
                match (code, arg1, arg2) {
                    (ffi::SQLITE_CREATE_INDEX, Some(index_name), Some(table_name)) => Self::CreateIndex {
                        index_name,
                        table_name,
                    },
                    (ffi::SQLITE_CREATE_TABLE, Some(table_name), _) => Self::CreateTable { table_name },
                    (ffi::SQLITE_CREATE_TEMP_INDEX, Some(index_name), Some(table_name)) => {
                        Self::CreateTempIndex {
                            index_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_CREATE_TEMP_TABLE, Some(table_name), _) => {
                        Self::CreateTempTable { table_name }
                    }
                    (ffi::SQLITE_CREATE_TEMP_TRIGGER, Some(trigger_name), Some(table_name)) => {
                        Self::CreateTempTrigger {
                            trigger_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_CREATE_TEMP_VIEW, Some(view_name), _) => {
                        Self::CreateTempView { view_name }
                    }
                    (ffi::SQLITE_CREATE_TRIGGER, Some(trigger_name), Some(table_name)) => {
                        Self::CreateTrigger {
                            trigger_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_CREATE_VIEW, Some(view_name), _) => Self::CreateView { view_name },
                    (ffi::SQLITE_DELETE, Some(table_name), None) => Self::Delete { table_name },
                    (ffi::SQLITE_DROP_INDEX, Some(index_name), Some(table_name)) => Self::DropIndex {
                        index_name,
                        table_name,
                    },
                    (ffi::SQLITE_DROP_TABLE, Some(table_name), _) => Self::DropTable { table_name },
                    (ffi::SQLITE_DROP_TEMP_INDEX, Some(index_name), Some(table_name)) => {
                        Self::DropTempIndex {
                            index_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_DROP_TEMP_TABLE, Some(table_name), _) => {
                        Self::DropTempTable { table_name }
                    }
                    (ffi::SQLITE_DROP_TEMP_TRIGGER, Some(trigger_name), Some(table_name)) => {
                        Self::DropTempTrigger {
                            trigger_name,
                            table_name,
                        }
                    }
                    (ffi::SQLITE_DROP_TEMP_VIEW, Some(view_name), _) => Self::DropTempView { view_name },
                    (ffi::SQLITE_DROP_TRIGGER, Some(trigger_name), Some(table_name)) => Self::DropTrigger {
                        trigger_name,
                        table_name,
                    },
                    (ffi::SQLITE_DROP_VIEW, Some(view_name), _) => Self::DropView { view_name },
                    (ffi::SQLITE_INSERT, Some(table_name), _) => Self::Insert { table_name },
                    (ffi::SQLITE_PRAGMA, Some(pragma_name), pragma_value) => Self::Pragma {
                        pragma_name,
                        pragma_value,
                    },
                    (ffi::SQLITE_READ, Some(table_name), Some(column_name)) => Self::Read {
                        table_name,
                        column_name,
                    },
                    (ffi::SQLITE_SELECT, ..) => Self::Select,
                    (ffi::SQLITE_TRANSACTION, Some(operation_str), _) => Self::Transaction {
                        operation: TransactionOperation::from_str(operation_str),
                    },
                    (ffi::SQLITE_UPDATE, Some(table_name), Some(column_name)) => Self::Update {
                        table_name,
                        column_name,
                    },
                    (ffi::SQLITE_ATTACH, Some(filename), _) => Self::Attach { filename },
                    (ffi::SQLITE_DETACH, Some(database_name), _) => Self::Detach { database_name },
                    (ffi::SQLITE_ALTER_TABLE, Some(database_name), Some(table_name)) => Self::AlterTable {
                        database_name,
                        table_name,
                    },
                    (ffi::SQLITE_REINDEX, Some(index_name), _) => Self::Reindex { index_name },
                    (ffi::SQLITE_ANALYZE, Some(table_name), _) => Self::Analyze { table_name },
                    (ffi::SQLITE_CREATE_VTABLE, Some(table_name), Some(module_name)) => {
                        Self::CreateVtable {
                            table_name,
                            module_name,
                        }
                    }
                    (ffi::SQLITE_DROP_VTABLE, Some(table_name), Some(module_name)) => Self::DropVtable {
                        table_name,
                        module_name,
                    },
                    (ffi::SQLITE_FUNCTION, _, Some(function_name)) => Self::Function { function_name },
                    (ffi::SQLITE_SAVEPOINT, Some(operation_str), Some(savepoint_name)) => Self::Savepoint {
                        operation: TransactionOperation::from_str(operation_str),
                        savepoint_name,
                    },
                    (ffi::SQLITE_RECURSIVE, ..) => Self::Recursive,
                    (code, arg1, arg2) => Self::Unknown { code, arg1, arg2 },
                }
            }
        }

        pub type BoxedAuthorizer =
            Box<dyn for<'c> FnMut(AuthContext<'c>) -> Authorization + Send + 'static>;

        /// A transaction operation.
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        #[non_exhaustive]
        #[allow(missing_docs)]
        pub enum TransactionOperation {
            Unknown,
            Begin,
            Release,
            Rollback,
        }

        impl TransactionOperation {
            fn from_str(op_str: &str) -> Self {
                match op_str {
                    "BEGIN" => Self::Begin,
                    "RELEASE" => Self::Release,
                    "ROLLBACK" => Self::Rollback,
                    _ => Self::Unknown,
                }
            }
        }
        /// [`authorizer`](Connection::authorizer) return code
        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        #[non_exhaustive]
        pub enum Authorization {
            /// Authorize the action.
            Allow,
            /// Don't allow access, but don't trigger an error either.
            Ignore,
            /// Trigger an error.
            Deny,
        }

        impl Authorization {
            fn into_raw(self) -> c_int {
                match self {
                    Self::Allow => ffi::SQLITE_OK,
                    Self::Ignore => ffi::SQLITE_IGNORE,
                    Self::Deny => ffi::SQLITE_DENY,
                }
            }
        }

        impl Connection {
            /// Register a callback function to be invoked whenever
            /// a transaction is committed.
            ///
            /// The callback returns `true` to rollback.
            #[inline]
            pub fn commit_hook<F>(&self, hook: Option<F>)
            where
                F: FnMut() -> bool + Send + 'static,
            {
                self.db.borrow_mut().commit_hook(hook);
            }
            /// Register a callback function to be invoked whenever
            /// a transaction is committed.
            #[inline]
            pub fn rollback_hook<F>(&self, hook: Option<F>)
            where
                F: FnMut() + Send + 'static,
            {
                self.db.borrow_mut().rollback_hook(hook);
            }
            /// Register a callback function to be invoked whenever
            /// a row is updated, inserted or deleted in a rowid table.
            ///
            /// The callback parameters are:
            ///
            /// - the type of database update (`SQLITE_INSERT`, `SQLITE_UPDATE` or
            /// `SQLITE_DELETE`),
            /// - the name of the database ("main", "temp", ...),
            /// - the name of the table that is updated,
            /// - the ROWID of the row that is updated.
            #[inline]
            pub fn update_hook<F>(&self, hook: Option<F>)
            where
                F: FnMut(Action, &str, &str, i64) + Send + 'static,
            {
                self.db.borrow_mut().update_hook(hook);
            }
            /// Register a query progress callback.
            ///
            /// The parameter `num_ops` is the approximate number of virtual machine
            /// instructions that are evaluated between successive invocations of the
            /// `handler`. If `num_ops` is less than one then the progress handler
            /// is disabled.
            ///
            /// If the progress callback returns `true`, the operation is interrupted.
            pub fn progress_handler<F>(&self, num_ops: c_int, handler: Option<F>)
            where
                F: FnMut() -> bool + Send + 'static,
            {
                self.db.borrow_mut().progress_handler(num_ops, handler);
            }
            /// Register an authorizer callback that's invoked
            /// as a statement is being prepared.
            #[inline]
            pub fn authorizer<'c, F>(&self, hook: Option<F>)
            where
                F: for<'r> FnMut(AuthContext<'r>) -> Authorization + Send + 'static,
            {
                self.db.borrow_mut().authorizer(hook);
            }
        }

        impl InnerConnection {
            #[inline]
            pub fn remove_hooks(&mut self) {
                self.update_hook(None::<fn(Action, &str, &str, i64)>);
                self.commit_hook(None::<fn() -> bool>);
                self.rollback_hook(None::<fn()>);
                self.progress_handler(0, None::<fn() -> bool>);
                self.authorizer(None::<fn(AuthContext<'_>) -> Authorization>);
            }
            
            fn commit_hook<F>(&mut self, hook: Option<F>)
            where
                F: FnMut() -> bool + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(p_arg: *mut c_void) -> c_int
                where
                    F: FnMut() -> bool,
                {
                    let r = catch_unwind(|| {
                        let boxed_hook: *mut F = p_arg.cast::<F>();
                        (*boxed_hook)()
                    });
                    c_int::from(r.unwrap_or_default())
                }

                // unlike `sqlite3_create_function_v2`, we cannot specify a `xDestroy` with
                // `sqlite3_commit_hook`. so we keep the `xDestroy` function in
                // `InnerConnection.free_boxed_hook`.
                let free_commit_hook = if hook.is_some() {
                    Some(free_boxed_hook::<F> as unsafe fn(*mut c_void))
                } else {
                    None
                };

                let previous_hook = match hook {
                    Some(hook) => {
                        let boxed_hook: *mut F = Box::into_raw(Box::new(hook));
                        unsafe {
                            ffi::sqlite3_commit_hook(
                                self.db(),
                                Some(call_boxed_closure::<F>),
                                boxed_hook.cast(),
                            )
                        }
                    }
                    _ => unsafe { ffi::sqlite3_commit_hook(self.db(), None, ptr::null_mut()) },
                };
                if !previous_hook.is_null() {
                    if let Some(free_boxed_hook) = self.free_commit_hook {
                        unsafe { free_boxed_hook(previous_hook) };
                    }
                }
                self.free_commit_hook = free_commit_hook;
            }
            
            fn rollback_hook<F>(&mut self, hook: Option<F>)
            where
                F: FnMut() + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(p_arg: *mut c_void)  where
                    F: FnMut(),
                {
                    drop(catch_unwind(|| {
                        let boxed_hook: *mut F = p_arg.cast::<F>();
                        (*boxed_hook)();
                    }));
                }

                let free_rollback_hook = if hook.is_some() {
                    Some(free_boxed_hook::<F> as unsafe fn(*mut c_void))
                } else {
                    None
                };

                let previous_hook = match hook {
                    Some(hook) => {
                        let boxed_hook: *mut F = Box::into_raw(Box::new(hook));
                        unsafe {
                            ffi::sqlite3_rollback_hook(
                                self.db(),
                                Some(call_boxed_closure::<F>),
                                boxed_hook.cast(),
                            )
                        }
                    }
                    _ => unsafe { ffi::sqlite3_rollback_hook(self.db(), None, ptr::null_mut()) },
                };
                if !previous_hook.is_null() {
                    if let Some(free_boxed_hook) = self.free_rollback_hook {
                        unsafe { free_boxed_hook(previous_hook) };
                    }
                }
                self.free_rollback_hook = free_rollback_hook;
            }
            
            fn update_hook<F>(&mut self, hook: Option<F>)
            where
                F: FnMut(Action, &str, &str, i64) + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(
                    p_arg: *mut c_void,
                    action_code: c_int,
                    p_db_name: *const c_char,
                    p_table_name: *const c_char,
                    row_id: i64,
                ) where
                    F: FnMut(Action, &str, &str, i64),
                {
                    let action = Action::from(action_code);
                    drop(catch_unwind(|| {
                        let boxed_hook: *mut F = p_arg.cast::<F>();
                        (*boxed_hook)(
                            action,
                            expect_utf8(p_db_name, "database name"),
                            expect_utf8(p_table_name, "table name"),
                            row_id,
                        );
                    }));
                }

                let free_update_hook = if hook.is_some() {
                    Some(free_boxed_hook::<F> as unsafe fn(*mut c_void))
                } else {
                    None
                };

                let previous_hook = match hook {
                    Some(hook) => {
                        let boxed_hook: *mut F = Box::into_raw(Box::new(hook));
                        unsafe {
                            ffi::sqlite3_update_hook(
                                self.db(),
                                Some(call_boxed_closure::<F>),
                                boxed_hook.cast(),
                            )
                        }
                    }
                    _ => unsafe { ffi::sqlite3_update_hook(self.db(), None, ptr::null_mut()) },
                };
                if !previous_hook.is_null() {
                    if let Some(free_boxed_hook) = self.free_update_hook {
                        unsafe { free_boxed_hook(previous_hook) };
                    }
                }
                self.free_update_hook = free_update_hook;
            }
            fn progress_handler<F>(&mut self, num_ops: c_int, handler: Option<F>)
            where
                F: FnMut() -> bool + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(p_arg: *mut c_void) -> c_int
                where
                    F: FnMut() -> bool,
                {
                    let r = catch_unwind(|| {
                        let boxed_handler: *mut F = p_arg.cast::<F>();
                        (*boxed_handler)()
                    });
                    c_int::from(r.unwrap_or_default())
                }

                if let Some(handler) = handler {
                    let boxed_handler = Box::new(handler);
                    unsafe {
                        ffi::sqlite3_progress_handler(
                            self.db(),
                            num_ops,
                            Some(call_boxed_closure::<F>),
                            &*boxed_handler as *const F as *mut _,
                        );
                    }
                    self.progress_handler = Some(boxed_handler);
                } else {
                    unsafe { ffi::sqlite3_progress_handler(self.db(), num_ops, None, ptr::null_mut()) }
                    self.progress_handler = None;
                };
            }
            
            fn authorizer<'c, F>(&'c mut self, authorizer: Option<F>)
            where
                F: for<'r> FnMut(AuthContext<'r>) -> Authorization + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<'c, F>(
                    p_arg: *mut c_void,
                    action_code: c_int,
                    param1: *const c_char,
                    param2: *const c_char,
                    db_name: *const c_char,
                    trigger_or_view_name: *const c_char,
                ) -> c_int
                where
                    F: FnMut(AuthContext<'c>) -> Authorization + Send + 'static,
                {
                    catch_unwind(|| {
                        let action = AuthAction::from_raw(
                            action_code,
                            expect_optional_utf8(param1, "authorizer param 1"),
                            expect_optional_utf8(param2, "authorizer param 2"),
                        );
                        let auth_ctx = AuthContext {
                            action,
                            database_name: expect_optional_utf8(db_name, "database name"),
                            accessor: expect_optional_utf8(
                                trigger_or_view_name,
                                "accessor (inner-most trigger or view)",
                            ),
                        };
                        let boxed_hook: *mut F = p_arg.cast::<F>();
                        (*boxed_hook)(auth_ctx)
                    })
                    .map_or_else(|_| ffi::SQLITE_ERROR, Authorization::into_raw)
                }

                let callback_fn = authorizer
                    .as_ref()
                    .map(|_| call_boxed_closure::<'c, F> as unsafe extern "C" fn(_, _, _, _, _, _) -> _);
                let boxed_authorizer = authorizer.map(Box::new);

                match unsafe {
                    ffi::sqlite3_set_authorizer(
                        self.db(),
                        callback_fn,
                        boxed_authorizer
                            .as_ref()
                            .map_or_else(ptr::null_mut, |f| &**f as *const F as *mut _),
                    )
                } {
                    ffi::SQLITE_OK => {
                        self.authorizer = boxed_authorizer.map(|ba| ba as _);
                    }
                    err_code => {
                        // The only error that `sqlite3_set_authorizer` returns is `SQLITE_MISUSE`
                        // when compiled with `ENABLE_API_ARMOR` and the db pointer is invalid.
                        // This library does not allow constructing a null db ptr, so if this branch
                        // is hit, something very bad has happened. Panicking instead of returning
                        // `Result` keeps this hook's API consistent with the others.
                        panic!("unexpectedly failed to set_authorizer: {}", unsafe {
                            crate::error::error_from_handle(self.db(), err_code)
                        });
                    }
                }
            }
        }

        unsafe fn free_boxed_hook<F>(p: *mut c_void) {
            drop(Box::from_raw(p.cast::<F>()));
        }

        unsafe fn expect_utf8<'a>(p_str: *const c_char, description: &'static str) -> &'a str {
            expect_optional_utf8(p_str, description)
                .unwrap_or_else(|| panic!("received empty {description}"))
        }

        unsafe fn expect_optional_utf8<'a>(
            p_str: *const c_char,
            description: &'static str,
        ) -> Option<&'a str> {
            if p_str.is_null() {
                return None;
            }
            std::ffi::CStr::from_ptr(p_str)
                .to_str()
                .unwrap_or_else(|_| panic!("received non-utf8 string as {description}"))
                .into()
        }
    }

    mod inner_connection
    {
        use ::
        {
            *,
        };
        use std::ffi::CStr;
        use std::os::raw::{c_char, c_int};
        #[cfg(feature = "load_extension")]
        use std::path::Path;
        use std::ptr;
        use std::str;
        use std::sync::{Arc, Mutex};

        use super::ffi;
        use super::str_for_sqlite;
        use super::{Connection, InterruptHandle, OpenFlags, PrepFlags, Result};
        use crate::error::{error_from_handle, error_from_sqlite_code, error_with_offset, Error};
        use crate::raw_statement::RawStatement;
        use crate::statement::Statement;
        use crate::version_number;

        pub struct InnerConnection {
            pub db: *mut ffi::sqlite3,
            // It's unsafe to call `sqlite3_close` while another thread is performing
            // a `sqlite3_interrupt`, and vice versa, so we take this mutex during
            // those functions. This protects a copy of the `db` pointer (which is
            // cleared on closing), however the main copy, `db`, is unprotected.
            // Otherwise, a long-running query would prevent calling interrupt, as
            // interrupt would only acquire the lock after the query's completion.
            interrupt_lock: Arc<Mutex<*mut ffi::sqlite3>>,
            #[cfg(feature = "hooks")]
            pub free_commit_hook: Option<unsafe fn(*mut std::os::raw::c_void)>,
            #[cfg(feature = "hooks")]
            pub free_rollback_hook: Option<unsafe fn(*mut std::os::raw::c_void)>,
            #[cfg(feature = "hooks")]
            pub free_update_hook: Option<unsafe fn(*mut std::os::raw::c_void)>,
            #[cfg(feature = "hooks")]
            pub progress_handler: Option<Box<dyn FnMut() -> bool + Send>>,
            #[cfg(feature = "hooks")]
            pub authorizer: Option<crate::hooks::BoxedAuthorizer>,
            #[cfg(feature = "preupdate_hook")]
            pub free_preupdate_hook: Option<unsafe fn(*mut ::std::os::raw::c_void)>,
            owned: bool,
        }

        unsafe impl Send for InnerConnection {}

        impl InnerConnection {
            #[allow(clippy::mutex_atomic, clippy::arc_with_non_send_sync)] // See unsafe impl Send / Sync for InterruptHandle
            #[inline]
            pub unsafe fn new(db: *mut ffi::sqlite3, owned: bool) -> InnerConnection {
                InnerConnection {
                    db,
                    interrupt_lock: Arc::new(Mutex::new(db)),
                    #[cfg(feature = "hooks")]
                    free_commit_hook: None,
                    #[cfg(feature = "hooks")]
                    free_rollback_hook: None,
                    #[cfg(feature = "hooks")]
                    free_update_hook: None,
                    #[cfg(feature = "hooks")]
                    progress_handler: None,
                    #[cfg(feature = "hooks")]
                    authorizer: None,
                    #[cfg(feature = "preupdate_hook")]
                    free_preupdate_hook: None,
                    owned,
                }
            }

            pub fn open_with_flags(
                c_path: &CStr,
                mut flags: OpenFlags,
                vfs: Option<&CStr>,
            ) -> Result<InnerConnection> {
                ensure_safe_sqlite_threading_mode()?;

                let z_vfs = match vfs {
                    Some(c_vfs) => c_vfs.as_ptr(),
                    None => ptr::null(),
                };

                // turn on extended results code before opening database to have a better diagnostic if a failure happens
                let exrescode = if version_number() >= 3_037_000 {
                    flags |= OpenFlags::SQLITE_OPEN_EXRESCODE;
                    true
                } else {
                    false // flag SQLITE_OPEN_EXRESCODE is ignored by SQLite version < 3.37.0
                };

                unsafe {
                    let mut db: *mut ffi::sqlite3 = ptr::null_mut();
                    let r = ffi::sqlite3_open_v2(c_path.as_ptr(), &mut db, flags.bits(), z_vfs);
                    if r != ffi::SQLITE_OK {
                        let e = if db.is_null() {
                            error_from_sqlite_code(r, Some(c_path.to_string_lossy().to_string()))
                        } else {
                            let mut e = error_from_handle(db, r);
                            if let Error::SqliteFailure(
                                ffi::Error {
                                    code: ffi::ErrorCode::CannotOpen,
                                    ..
                                },
                                Some(msg),
                            ) = e
                            {
                                e = Error::SqliteFailure(
                                    ffi::Error::new(r),
                                    Some(format!("{msg}: {}", c_path.to_string_lossy())),
                                );
                            }
                            ffi::sqlite3_close(db);
                            e
                        };

                        return Err(e);
                    }

                    // attempt to turn on extended results code; don't fail if we can't.
                    if !exrescode {
                        ffi::sqlite3_extended_result_codes(db, 1);
                    }

                    let r = ffi::sqlite3_busy_timeout(db, 5000);
                    if r != ffi::SQLITE_OK {
                        let e = error_from_handle(db, r);
                        ffi::sqlite3_close(db);
                        return Err(e);
                    }

                    Ok(InnerConnection::new(db, true))
                }
            }

            #[inline]
            pub fn db(&self) -> *mut ffi::sqlite3 {
                self.db
            }

            #[inline]
            pub fn decode_result(&self, code: c_int) -> Result<()> {
                unsafe { InnerConnection::decode_result_raw(self.db(), code) }
            }

            #[inline]
            unsafe fn decode_result_raw(db: *mut ffi::sqlite3, code: c_int) -> Result<()> {
                if code == ffi::SQLITE_OK {
                    Ok(())
                } else {
                    Err(error_from_handle(db, code))
                }
            }

            #[allow(clippy::mutex_atomic)]
            pub fn close(&mut self) -> Result<()> {
                if self.db.is_null() {
                    return Ok(());
                }
                self.remove_hooks();
                self.remove_preupdate_hook();
                let mut shared_handle = self.interrupt_lock.lock().unwrap();
                assert!(
                    !shared_handle.is_null(),
                    "Bug: Somehow interrupt_lock was cleared before the DB was closed"
                );
                if !self.owned {
                    self.db = ptr::null_mut();
                    return Ok(());
                }
                unsafe {
                    let r = ffi::sqlite3_close(self.db);
                    // Need to use _raw because _guard has a reference out, and
                    // decode_result takes &mut self.
                    let r = InnerConnection::decode_result_raw(self.db, r);
                    if r.is_ok() {
                        *shared_handle = ptr::null_mut();
                        self.db = ptr::null_mut();
                    }
                    r
                }
            }

            #[inline]
            pub fn get_interrupt_handle(&self) -> InterruptHandle {
                InterruptHandle {
                    db_lock: Arc::clone(&self.interrupt_lock),
                }
            }

            #[inline]
            #[cfg(feature = "load_extension")]
            pub unsafe fn enable_load_extension(&mut self, onoff: c_int) -> Result<()> {
                let r = ffi::sqlite3_enable_load_extension(self.db, onoff);
                self.decode_result(r)
            }

            #[cfg(feature = "load_extension")]
            pub unsafe fn load_extension(
                &self,
                dylib_path: &Path,
                entry_point: Option<&str>,
            ) -> Result<()> {
                let dylib_str = super::path_to_cstring(dylib_path)?;
                let mut errmsg: *mut c_char = ptr::null_mut();
                let r = if let Some(entry_point) = entry_point {
                    let c_entry = crate::str_to_cstring(entry_point)?;
                    ffi::sqlite3_load_extension(self.db, dylib_str.as_ptr(), c_entry.as_ptr(), &mut errmsg)
                } else {
                    ffi::sqlite3_load_extension(self.db, dylib_str.as_ptr(), ptr::null(), &mut errmsg)
                };
                if r == ffi::SQLITE_OK {
                    Ok(())
                } else {
                    let message = super::errmsg_to_string(errmsg);
                    ffi::sqlite3_free(errmsg.cast::<std::os::raw::c_void>());
                    Err(error_from_sqlite_code(r, Some(message)))
                }
            }

            #[inline]
            pub fn last_insert_rowid(&self) -> i64 {
                unsafe { ffi::sqlite3_last_insert_rowid(self.db()) }
            }

            pub fn prepare<'a>(
                &mut self,
                conn: &'a Connection,
                sql: &str,
                flags: PrepFlags,
            ) -> Result<Statement<'a>> {
                let mut c_stmt: *mut ffi::sqlite3_stmt = ptr::null_mut();
                let (c_sql, len, _) = str_for_sqlite(sql.as_bytes())?;
                let mut c_tail: *const c_char = ptr::null();
                #[cfg(not(feature = "unlock_notify"))]
                let r = unsafe { self.prepare_(c_sql, len, flags, &mut c_stmt, &mut c_tail) };
                #[cfg(feature = "unlock_notify")]
                let r = unsafe {
                    use crate::unlock_notify;
                    let mut rc;
                    loop {
                        rc = self.prepare_(c_sql, len, flags, &mut c_stmt, &mut c_tail);
                        if !unlock_notify::is_locked(self.db, rc) {
                            break;
                        }
                        rc = unlock_notify::wait_for_unlock_notify(self.db);
                        if rc != ffi::SQLITE_OK {
                            break;
                        }
                    }
                    rc
                };
                // If there is an error, *ppStmt is set to NULL.
                if r != ffi::SQLITE_OK {
                    return Err(unsafe { error_with_offset(self.db, r, sql) });
                }
                // If the input text contains no SQL (if the input is an empty string or a
                // comment) then *ppStmt is set to NULL.
                let tail = if c_tail.is_null() {
                    0
                } else {
                    let n = (c_tail as isize) - (c_sql as isize);
                    if n <= 0 || n >= len as isize {
                        0
                    } else {
                        n as usize
                    }
                };
                Ok(Statement::new(conn, unsafe {
                    RawStatement::new(c_stmt, tail)
                }))
            }

            #[inline]
            #[cfg(not(feature = "modern_sqlite"))]
            unsafe fn prepare_(
                &self,
                z_sql: *const c_char,
                n_byte: c_int,
                _: PrepFlags,
                pp_stmt: *mut *mut ffi::sqlite3_stmt,
                pz_tail: *mut *const c_char,
            ) -> c_int {
                ffi::sqlite3_prepare_v2(self.db(), z_sql, n_byte, pp_stmt, pz_tail)
            }

            #[inline]
            #[cfg(feature = "modern_sqlite")]
            unsafe fn prepare_(
                &self,
                z_sql: *const c_char,
                n_byte: c_int,
                flags: PrepFlags,
                pp_stmt: *mut *mut ffi::sqlite3_stmt,
                pz_tail: *mut *const c_char,
            ) -> c_int {
                ffi::sqlite3_prepare_v3(self.db(), z_sql, n_byte, flags.bits(), pp_stmt, pz_tail)
            }

            #[inline]
            pub fn changes(&self) -> u64 {
                #[cfg(not(feature = "modern_sqlite"))]
                unsafe {
                    ffi::sqlite3_changes(self.db()) as u64
                }
                #[cfg(feature = "modern_sqlite")] // 3.37.0
                unsafe {
                    ffi::sqlite3_changes64(self.db()) as u64
                }
            }

            #[inline]
            pub fn total_changes(&self) -> u64 {
                #[cfg(not(feature = "modern_sqlite"))]
                unsafe {
                    ffi::sqlite3_total_changes(self.db()) as u64
                }
                #[cfg(feature = "modern_sqlite")] // 3.37.0
                unsafe {
                    ffi::sqlite3_total_changes64(self.db()) as u64
                }
            }

            #[inline]
            pub fn is_autocommit(&self) -> bool {
                unsafe { ffi::sqlite3_get_autocommit(self.db()) != 0 }
            }

            pub fn is_busy(&self) -> bool {
                let db = self.db();
                unsafe {
                    let mut stmt = ffi::sqlite3_next_stmt(db, ptr::null_mut());
                    while !stmt.is_null() {
                        if ffi::sqlite3_stmt_busy(stmt) != 0 {
                            return true;
                        }
                        stmt = ffi::sqlite3_next_stmt(db, stmt);
                    }
                }
                false
            }

            pub fn cache_flush(&mut self) -> Result<()> {
                crate::error::check(unsafe { ffi::sqlite3_db_cacheflush(self.db()) })
            }

            #[cfg(not(feature = "hooks"))]
            #[inline]
            fn remove_hooks(&mut self) {}

            #[cfg(not(feature = "preupdate_hook"))]
            #[inline]
            fn remove_preupdate_hook(&mut self) {}

            pub fn db_readonly(&self, db_name: super::DatabaseName<'_>) -> Result<bool> {
                let name = db_name.as_cstring()?;
                let r = unsafe { ffi::sqlite3_db_readonly(self.db, name.as_ptr()) };
                match r {
                    0 => Ok(false),
                    1 => Ok(true),
                    -1 => Err(Error::SqliteFailure(
                        ffi::Error::new(ffi::SQLITE_MISUSE),
                        Some(format!("{db_name:?} is not the name of a database")),
                    )),
                    _ => Err(error_from_sqlite_code(
                        r,
                        Some("Unexpected result".to_owned()),
                    )),
                }
            }

            #[cfg(feature = "modern_sqlite")] // 3.37.0
            pub fn txn_state(
                &self,
                db_name: Option<super::DatabaseName<'_>>,
            ) -> Result<super::transaction::TransactionState> {
                let r = if let Some(ref name) = db_name {
                    let name = name.as_cstring()?;
                    unsafe { ffi::sqlite3_txn_state(self.db, name.as_ptr()) }
                } else {
                    unsafe { ffi::sqlite3_txn_state(self.db, ptr::null()) }
                };
                match r {
                    0 => Ok(super::transaction::TransactionState::None),
                    1 => Ok(super::transaction::TransactionState::Read),
                    2 => Ok(super::transaction::TransactionState::Write),
                    -1 => Err(Error::SqliteFailure(
                        ffi::Error::new(ffi::SQLITE_MISUSE),
                        Some(format!("{db_name:?} is not the name of a valid schema")),
                    )),
                    _ => Err(error_from_sqlite_code(
                        r,
                        Some("Unexpected result".to_owned()),
                    )),
                }
            }

            #[inline]
            #[cfg(feature = "release_memory")]
            pub fn release_memory(&self) -> Result<()> {
                self.decode_result(unsafe { ffi::sqlite3_db_release_memory(self.db) })
            }

            #[cfg(feature = "modern_sqlite")] // 3.41.0
            pub fn is_interrupted(&self) -> bool {
                unsafe { ffi::sqlite3_is_interrupted(self.db) == 1 }
            }
        }

        impl Drop for InnerConnection {
            #[allow(unused_must_use)]
            #[inline]
            fn drop(&mut self) {
                self.close();
            }
        }

        // threading mode checks are not necessary (and do not work) on target
        // platforms that do not have threading (such as webassembly)
        #[cfg(target_arch = "wasm32")]
        fn ensure_safe_sqlite_threading_mode() -> Result<()> {
            Ok(())
        }

        #[cfg(not(any(target_arch = "wasm32")))]
        fn ensure_safe_sqlite_threading_mode() -> Result<()> {
            // Ensure SQLite was compiled in threadsafe mode.
            if unsafe { ffi::sqlite3_threadsafe() == 0 } {
                return Err(Error::SqliteSingleThreadedMode);
            }

            // Now we know SQLite is _capable_ of being in Multi-thread of Serialized mode,
            // but it's possible someone configured it to be in Single-thread mode
            // before calling into us. That would mean we're exposing an unsafe API via
            // a safe one (in Rust terminology).
            //
            // We can ask SQLite for a mutex and check for
            // the magic value 8. This isn't documented, but it's what SQLite
            // returns for its mutex allocation function in Single-thread mode.
            const SQLITE_SINGLETHREADED_MUTEX_MAGIC: usize = 8;
            let is_singlethreaded = unsafe {
                let mutex_ptr = ffi::sqlite3_mutex_alloc(0);
                let is_singlethreaded = mutex_ptr as usize == SQLITE_SINGLETHREADED_MUTEX_MAGIC;
                ffi::sqlite3_mutex_free(mutex_ptr);
                is_singlethreaded
            };
            if is_singlethreaded {
                Err(Error::SqliteSingleThreadedMode)
            } else {
                Ok(())
            }
        }
    }
    
    pub mod limits
    {
        //! Run-Time Limits
        use ::
        {
            *,
        };
        

        use crate::{ffi, Connection};
        use std::os::raw::c_int;

        /// Run-Time limit categories, for use with [`Connection::limit`] and
        /// [`Connection::set_limit`].
        ///
        /// See the official documentation for more information:
        /// - <https://www.sqlite.org/c3ref/c_limit_attached.html>
        /// - <https://www.sqlite.org/limits.html>
        #[derive(Copy, Clone, Debug)]
        #[repr(i32)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms, non_camel_case_types)]
        #[cfg_attr(docsrs, doc(cfg(feature = "limits")))]
        pub enum Limit {
            /// The maximum size of any string or BLOB or table row, in bytes.
            SQLITE_LIMIT_LENGTH = ffi::SQLITE_LIMIT_LENGTH,
            /// The maximum length of an SQL statement, in bytes.
            SQLITE_LIMIT_SQL_LENGTH = ffi::SQLITE_LIMIT_SQL_LENGTH,
            /// The maximum number of columns in a table definition or in the result set
            /// of a SELECT or the maximum number of columns in an index or in an
            /// ORDER BY or GROUP BY clause.
            SQLITE_LIMIT_COLUMN = ffi::SQLITE_LIMIT_COLUMN,
            /// The maximum depth of the parse tree on any expression.
            SQLITE_LIMIT_EXPR_DEPTH = ffi::SQLITE_LIMIT_EXPR_DEPTH,
            /// The maximum number of terms in a compound SELECT statement.
            SQLITE_LIMIT_COMPOUND_SELECT = ffi::SQLITE_LIMIT_COMPOUND_SELECT,
            /// The maximum number of instructions in a virtual machine program used to
            /// implement an SQL statement.
            SQLITE_LIMIT_VDBE_OP = ffi::SQLITE_LIMIT_VDBE_OP,
            /// The maximum number of arguments on a function.
            SQLITE_LIMIT_FUNCTION_ARG = ffi::SQLITE_LIMIT_FUNCTION_ARG,
            /// The maximum number of attached databases.
            SQLITE_LIMIT_ATTACHED = ffi::SQLITE_LIMIT_ATTACHED,
            /// The maximum length of the pattern argument to the LIKE or GLOB
            /// operators.
            SQLITE_LIMIT_LIKE_PATTERN_LENGTH = ffi::SQLITE_LIMIT_LIKE_PATTERN_LENGTH,
            /// The maximum index number of any parameter in an SQL statement.
            SQLITE_LIMIT_VARIABLE_NUMBER = ffi::SQLITE_LIMIT_VARIABLE_NUMBER,
            /// The maximum depth of recursion for triggers.
            SQLITE_LIMIT_TRIGGER_DEPTH = ffi::SQLITE_LIMIT_TRIGGER_DEPTH,
            /// The maximum number of auxiliary worker threads that a single prepared
            /// statement may start.
            SQLITE_LIMIT_WORKER_THREADS = ffi::SQLITE_LIMIT_WORKER_THREADS,
        }

        impl Connection {
            /// Returns the current value of a [`Limit`].
            #[inline]
            #[cfg_attr(docsrs, doc(cfg(feature = "limits")))]
            pub fn limit(&self, limit: Limit) -> i32 {
                let c = self.db.borrow();
                unsafe { ffi::sqlite3_limit(c.db(), limit as c_int, -1) }
            }
            /// Changes the [`Limit`] to `new_val`, returning the prior
            /// value of the limit.
            #[inline]
            #[cfg_attr(docsrs, doc(cfg(feature = "limits")))]
            pub fn set_limit(&self, limit: Limit, new_val: i32) -> i32 {
                let c = self.db.borrow_mut();
                unsafe { ffi::sqlite3_limit(c.db(), limit as c_int, new_val) }
            }
        }
    }

    mod params
    {
        use ::
        {
            *,
        };
        use crate::{Result, Statement, ToSql};

        mod sealed {
            /// This trait exists just to ensure that the only impls of `trait Params`
            /// that are allowed are ones in this crate.
            pub trait Sealed {}
        }
        use sealed::Sealed;

        /// Trait used for [sets of parameter][params] passed into SQL statements/queries.
        pub trait Params: Sealed {
            // XXX not public api, might not need to expose.
            //
            // Binds the parameters to the statement. It is unlikely calling this
            // explicitly will do what you want. Please use `Statement::query` or
            // similar directly.
            //
            // For now, just hide the function in the docs...
            #[doc(hidden)]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()>;
        }
        
        impl Sealed for [&(dyn ToSql + Send + Sync); 0] {}
        impl Params for [&(dyn ToSql + Send + Sync); 0] {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.ensure_parameter_count(0)
            }
        }

        impl Sealed for &[&dyn ToSql] {}
        impl Params for &[&dyn ToSql] {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.bind_parameters(self)
            }
        }

        impl Sealed for &[(&str, &dyn ToSql)] {}
        impl Params for &[(&str, &dyn ToSql)] {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.bind_parameters_named(self)
            }
        }
        
        impl Sealed for () {}
        impl Params for () {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.ensure_parameter_count(0)
            }
        }
        
        impl<T: ToSql> Sealed for (T,) {}
        impl<T: ToSql> Params for (T,) {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.ensure_parameter_count(1)?;
                stmt.raw_bind_parameter(1, self.0)?;
                Ok(())
            }
        }

        macro_rules! single_tuple_impl {
            ($count:literal : $(($field:tt $ftype:ident)),* $(,)?) => {
                impl<$($ftype,)*> Sealed for ($($ftype,)*) where $($ftype: ToSql,)* {}
                impl<$($ftype,)*> Params for ($($ftype,)*) where $($ftype: ToSql,)* {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.ensure_parameter_count($count)?;
                        $({
                            debug_assert!($field < $count);
                            stmt.raw_bind_parameter($field + 1, self.$field)?;
                        })+
                        Ok(())
                    }
                }
            }
        }
        
        single_tuple_impl!(2: (0 A), (1 B));
        single_tuple_impl!(3: (0 A), (1 B), (2 C));
        single_tuple_impl!(4: (0 A), (1 B), (2 C), (3 D));
        single_tuple_impl!(5: (0 A), (1 B), (2 C), (3 D), (4 E));
        single_tuple_impl!(6: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F));
        single_tuple_impl!(7: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G));
        single_tuple_impl!(8: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H));
        single_tuple_impl!(9: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I));
        single_tuple_impl!(10: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J));
        single_tuple_impl!(11: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K));
        single_tuple_impl!(12: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L));
        single_tuple_impl!(13: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M));
        single_tuple_impl!(14: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N));
        single_tuple_impl!(15: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N), (14 O));
        single_tuple_impl!(16: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N), (14 O), (15 P));

        macro_rules! impl_for_array_ref {
            ($($N:literal)+) => {$(
                // These are already generic, and there's a shedload of them, so lets
                // avoid the compile time hit from making them all inline for now.
                impl<T: ToSql + ?Sized> Sealed for &[&T; $N] {}
                impl<T: ToSql + ?Sized> Params for &[&T; $N] {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters(self)
                    }
                }
                impl<T: ToSql + ?Sized> Sealed for &[(&str, &T); $N] {}
                impl<T: ToSql + ?Sized> Params for &[(&str, &T); $N] {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters_named(self)
                    }
                }
                impl<T: ToSql> Sealed for [T; $N] {}
                impl<T: ToSql> Params for [T; $N] {
                    #[inline]
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters(&self)
                    }
                }
            )+};
        }
        
        impl_for_array_ref!(
            1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
            18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
        );

        /// Adapter type which allows any iterator over [`ToSql`] values to implement [`Params`].
        #[derive(Clone, Debug)]
        pub struct ParamsFromIter<I>(I);

        /// Constructor function for a [`ParamsFromIter`]. See its documentation for more.
        #[inline]
        pub fn params_from_iter<I>(iter: I) -> ParamsFromIter<I>
        where
            I: IntoIterator,
            I::Item: ToSql,
        {
            ParamsFromIter(iter)
        }

        impl<I> Sealed for ParamsFromIter<I>
        where
            I: IntoIterator,
            I::Item: ToSql,
        {
        }

        impl<I> Params for ParamsFromIter<I>
        where
            I: IntoIterator,
            I::Item: ToSql,
        {
            #[inline]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.bind_parameters(self.0)
            }
        }
    }

    mod pragma
    {
        //! Pragma helpers
        use ::
        {
            *,
        };
        

        use std::ops::Deref;

        use crate::error::Error;
        use crate::ffi;
        use crate::types::{ToSql, ToSqlOutput, ValueRef};
        use crate::{Connection, DatabaseName, Result, Row};

        pub struct Sql {
            buf: String,
        }

        impl Sql {
            pub fn new() -> Sql {
                Sql { buf: String::new() }
            }

            pub fn push_pragma(
                &mut self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
            ) -> Result<()> {
                self.push_keyword("PRAGMA")?;
                self.push_space();
                if let Some(schema_name) = schema_name {
                    self.push_schema_name(schema_name);
                    self.push_dot();
                }
                self.push_keyword(pragma_name)
            }

            pub fn push_keyword(&mut self, keyword: &str) -> Result<()> {
                if !keyword.is_empty() && is_identifier(keyword) {
                    self.buf.push_str(keyword);
                    Ok(())
                } else {
                    Err(Error::SqliteFailure(
                        ffi::Error::new(ffi::SQLITE_MISUSE),
                        Some(format!("Invalid keyword \"{keyword}\"")),
                    ))
                }
            }

            pub fn push_schema_name(&mut self, schema_name: DatabaseName<'_>) {
                match schema_name {
                    DatabaseName::Main => self.buf.push_str("main"),
                    DatabaseName::Temp => self.buf.push_str("temp"),
                    DatabaseName::Attached(s) => self.push_identifier(s),
                };
            }

            pub fn push_identifier(&mut self, s: &str) {
                if is_identifier(s) {
                    self.buf.push_str(s);
                } else {
                    self.wrap_and_escape(s, '"');
                }
            }

            pub fn push_value(&mut self, value: &dyn ToSql) -> Result<()> {
                let value = value.to_sql()?;
                let value = match value {
                    ToSqlOutput::Borrowed(v) => v,
                    ToSqlOutput::Owned(ref v) => ValueRef::from(v),
                    #[cfg(feature = "blob")]
                    ToSqlOutput::ZeroBlob(_) => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                    #[cfg(feature = "functions")]
                    ToSqlOutput::Arg(_) => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                    #[cfg(feature = "array")]
                    ToSqlOutput::Array(_) => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                };
                match value {
                    ValueRef::Integer(i) => {
                        self.push_int(i);
                    }
                    ValueRef::Real(r) => {
                        self.push_real(r);
                    }
                    ValueRef::Text(s) => {
                        let s = std::str::from_utf8(s)?;
                        self.push_string_literal(s);
                    }
                    _ => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                };
                Ok(())
            }

            pub fn push_string_literal(&mut self, s: &str) {
                self.wrap_and_escape(s, '\'');
            }

            pub fn push_int(&mut self, i: i64) {
                self.buf.push_str(&i.to_string());
            }

            pub fn push_real(&mut self, f: f64) {
                self.buf.push_str(&f.to_string());
            }

            pub fn push_space(&mut self) {
                self.buf.push(' ');
            }

            pub fn push_dot(&mut self) {
                self.buf.push('.');
            }

            pub fn push_equal_sign(&mut self) {
                self.buf.push('=');
            }

            pub fn open_brace(&mut self) {
                self.buf.push('(');
            }

            pub fn close_brace(&mut self) {
                self.buf.push(')');
            }

            pub fn as_str(&self) -> &str {
                &self.buf
            }

            fn wrap_and_escape(&mut self, s: &str, quote: char) {
                self.buf.push(quote);
                let chars = s.chars();
                for ch in chars {
                    // escape `quote` by doubling it
                    if ch == quote {
                        self.buf.push(ch);
                    }
                    self.buf.push(ch);
                }
                self.buf.push(quote);
            }
        }

        impl Deref for Sql {
            type Target = str;

            fn deref(&self) -> &str {
                self.as_str()
            }
        }

        impl Connection {
            /// Query the current value of `pragma_name`.
            ///
            /// Some pragmas will return multiple rows/values which cannot be retrieved
            /// with this method.
            ///
            /// Prefer [PRAGMA function](https://sqlite.org/pragma.html#pragfunc) introduced in SQLite 3.20:
            /// `SELECT user_version FROM pragma_user_version;`
            pub fn pragma_query_value<T, F>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                f: F,
            ) -> Result<T>
            where
                F: FnOnce(&Row<'_>) -> Result<T>,
            {
                let mut query = Sql::new();
                query.push_pragma(schema_name, pragma_name)?;
                self.query_row(&query, [], f)
            }
            /// Query the current rows/values of `pragma_name`.
            ///
            /// Prefer [PRAGMA function](https://sqlite.org/pragma.html#pragfunc) introduced in SQLite 3.20:
            /// `SELECT * FROM pragma_collation_list;`
            pub fn pragma_query<F>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                mut f: F,
            ) -> Result<()>
            where
                F: FnMut(&Row<'_>) -> Result<()>,
            {
                let mut query = Sql::new();
                query.push_pragma(schema_name, pragma_name)?;
                let mut stmt = self.prepare(&query)?;
                let mut rows = stmt.query([])?;
                while let Some(result_row) = rows.next()? {
                    let row = result_row;
                    f(row)?;
                }
                Ok(())
            }
            /// Query the current value(s) of `pragma_name` associated to
            /// `pragma_value`.
            ///
            /// This method can be used with query-only pragmas which need an argument
            /// (e.g. `table_info('one_tbl')`) or pragmas which returns value(s)
            /// (e.g. `integrity_check`).
            ///
            /// Prefer [PRAGMA function](https://sqlite.org/pragma.html#pragfunc) introduced in SQLite 3.20:
            /// `SELECT * FROM pragma_table_info(?1);`
            pub fn pragma<F, V>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                pragma_value: V,
                mut f: F,
            ) -> Result<()>
            where
                F: FnMut(&Row<'_>) -> Result<()>,
                V: ToSql,
            {
                let mut sql = Sql::new();
                sql.push_pragma(schema_name, pragma_name)?;
                // The argument may be either in parentheses
                // or it may be separated from the pragma name by an equal sign.
                // The two syntaxes yield identical results.
                sql.open_brace();
                sql.push_value(&pragma_value)?;
                sql.close_brace();
                let mut stmt = self.prepare(&sql)?;
                let mut rows = stmt.query([])?;
                while let Some(result_row) = rows.next()? {
                    let row = result_row;
                    f(row)?;
                }
                Ok(())
            }
            /// Set a new value to `pragma_name`.
            ///
            /// Some pragmas will return the updated value which cannot be retrieved
            /// with this method.
            pub fn pragma_update<V>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                pragma_value: V,
            ) -> Result<()>
            where
                V: ToSql,
            {
                let mut sql = Sql::new();
                sql.push_pragma(schema_name, pragma_name)?;
                // The argument may be either in parentheses
                // or it may be separated from the pragma name by an equal sign.
                // The two syntaxes yield identical results.
                sql.push_equal_sign();
                sql.push_value(&pragma_value)?;
                self.execute_batch(&sql)
            }
            /// Set a new value to `pragma_name` and return the updated value.
            ///
            /// Only few pragmas automatically return the updated value.
            pub fn pragma_update_and_check<F, T, V>(
                &self,
                schema_name: Option<DatabaseName<'_>>,
                pragma_name: &str,
                pragma_value: V,
                f: F,
            ) -> Result<T>
            where
                F: FnOnce(&Row<'_>) -> Result<T>,
                V: ToSql,
            {
                let mut sql = Sql::new();
                sql.push_pragma(schema_name, pragma_name)?;
                // The argument may be either in parentheses
                // or it may be separated from the pragma name by an equal sign.
                // The two syntaxes yield identical results.
                sql.push_equal_sign();
                sql.push_value(&pragma_value)?;
                self.query_row(&sql, [], f)
            }
        }

        fn is_identifier(s: &str) -> bool {
            let chars = s.char_indices();
            for (i, ch) in chars {
                if i == 0 {
                    if !is_identifier_start(ch) {
                        return false;
                    }
                } else if !is_identifier_continue(ch) {
                    return false;
                }
            }
            true
        }

        fn is_identifier_start(c: char) -> bool {
            c.is_ascii_uppercase() || c == '_' || c.is_ascii_lowercase() || c > '\x7F'
        }

        fn is_identifier_continue(c: char) -> bool {
            c == '$'
                || c.is_ascii_digit()
                || c.is_ascii_uppercase()
                || c == '_'
                || c.is_ascii_lowercase()
                || c > '\x7F'
        }
    }

    mod raw_statement
    {
        use ::
        {
            *,
        };
        use super::ffi;
        use super::StatementStatus;
        use crate::util::ParamIndexCache;
        use crate::util::SqliteMallocString;
        use std::ffi::CStr;
        use std::os::raw::c_int;
        use std::ptr;
        use std::sync::Arc;

        // Private newtype for raw sqlite3_stmts that finalize themselves when dropped.
        #[derive(Debug)]
        pub struct RawStatement {
            ptr: *mut ffi::sqlite3_stmt,
            tail: usize,
            // Cached indices of named parameters, computed on the fly.
            cache: ParamIndexCache,
            // Cached SQL (trimmed) that we use as the key when we're in the statement
            // cache. This is None for statements which didn't come from the statement
            // cache.
            //
            // This is probably the same as `self.sql()` in most cases, but we don't
            // care either way -- It's a better cache key as it is anyway since it's the
            // actual source we got from rust.
            //
            // One example of a case where the result of `sqlite_sql` and the value in
            // `statement_cache_key` might differ is if the statement has a `tail`.
            statement_cache_key: Option<Arc<str>>,
        }

        impl RawStatement {
            #[inline]
            pub unsafe fn new(stmt: *mut ffi::sqlite3_stmt, tail: usize) -> RawStatement {
                RawStatement {
                    ptr: stmt,
                    tail,
                    cache: ParamIndexCache::default(),
                    statement_cache_key: None,
                }
            }

            #[inline]
            pub fn is_null(&self) -> bool {
                self.ptr.is_null()
            }

            #[inline]
            pub fn set_statement_cache_key(&mut self, p: impl Into<Arc<str>>) {
                self.statement_cache_key = Some(p.into());
            }

            #[inline]
            pub fn statement_cache_key(&self) -> Option<Arc<str>> {
                self.statement_cache_key.clone()
            }

            #[inline]
            pub unsafe fn ptr(&self) -> *mut ffi::sqlite3_stmt {
                self.ptr
            }

            #[inline]
            pub fn column_count(&self) -> usize {
                // Note: Can't cache this as it changes if the schema is altered.
                unsafe { ffi::sqlite3_column_count(self.ptr) as usize }
            }

            #[inline]
            pub fn column_type(&self, idx: usize) -> c_int {
                unsafe { ffi::sqlite3_column_type(self.ptr, idx as c_int) }
            }

            #[inline]
            #[cfg(feature = "column_decltype")]
            pub fn column_decltype(&self, idx: usize) -> Option<&CStr> {
                unsafe {
                    let decltype = ffi::sqlite3_column_decltype(self.ptr, idx as c_int);
                    if decltype.is_null() {
                        None
                    } else {
                        Some(CStr::from_ptr(decltype))
                    }
                }
            }

            #[inline]
            pub fn column_name(&self, idx: usize) -> Option<&CStr> {
                let idx = idx as c_int;
                if idx < 0 || idx >= self.column_count() as c_int {
                    return None;
                }
                unsafe {
                    let ptr = ffi::sqlite3_column_name(self.ptr, idx);
                    // If ptr is null here, it's an OOM, so there's probably nothing
                    // meaningful we can do. Just assert instead of returning None.
                    assert!(
                        !ptr.is_null(),
                        "Null pointer from sqlite3_column_name: Out of memory?"
                    );
                    Some(CStr::from_ptr(ptr))
                }
            }

            #[inline]
            #[cfg(not(feature = "unlock_notify"))]
            pub fn step(&self) -> c_int {
                unsafe { ffi::sqlite3_step(self.ptr) }
            }

            #[cfg(feature = "unlock_notify")]
            pub fn step(&self) -> c_int {
                use crate::unlock_notify;
                let mut db = ptr::null_mut::<ffi::sqlite3>();
                loop {
                    unsafe {
                        let mut rc = ffi::sqlite3_step(self.ptr);
                        // Bail out early for success and errors unrelated to locking. We
                        // still need check `is_locked` after this, but checking now lets us
                        // avoid one or two (admittedly cheap) calls into SQLite that we
                        // don't need to make.
                        if (rc & 0xff) != ffi::SQLITE_LOCKED {
                            break rc;
                        }
                        if db.is_null() {
                            db = ffi::sqlite3_db_handle(self.ptr);
                        }
                        if !unlock_notify::is_locked(db, rc) {
                            break rc;
                        }
                        rc = unlock_notify::wait_for_unlock_notify(db);
                        if rc != ffi::SQLITE_OK {
                            break rc;
                        }
                        self.reset();
                    }
                }
            }

            #[inline]
            pub fn reset(&self) -> c_int {
                unsafe { ffi::sqlite3_reset(self.ptr) }
            }

            #[inline]
            pub fn bind_parameter_count(&self) -> usize {
                unsafe { ffi::sqlite3_bind_parameter_count(self.ptr) as usize }
            }

            #[inline]
            pub fn bind_parameter_index(&self, name: &str) -> Option<usize> {
                self.cache.get_or_insert_with(name, |param_cstr| {
                    let r = unsafe { ffi::sqlite3_bind_parameter_index(self.ptr, param_cstr.as_ptr()) };
                    match r {
                        0 => None,
                        i => Some(i as usize),
                    }
                })
            }

            #[inline]
            pub fn bind_parameter_name(&self, index: i32) -> Option<&CStr> {
                unsafe {
                    let name = ffi::sqlite3_bind_parameter_name(self.ptr, index);
                    if name.is_null() {
                        None
                    } else {
                        Some(CStr::from_ptr(name))
                    }
                }
            }

            #[inline]
            pub fn clear_bindings(&mut self) {
                unsafe {
                    ffi::sqlite3_clear_bindings(self.ptr);
                } // rc is always SQLITE_OK
            }

            #[inline]
            pub fn sql(&self) -> Option<&CStr> {
                if self.ptr.is_null() {
                    None
                } else {
                    Some(unsafe { CStr::from_ptr(ffi::sqlite3_sql(self.ptr)) })
                }
            }

            #[inline]
            pub fn finalize(mut self) -> c_int {
                self.finalize_()
            }

            #[inline]
            fn finalize_(&mut self) -> c_int {
                let r = unsafe { ffi::sqlite3_finalize(self.ptr) };
                self.ptr = ptr::null_mut();
                r
            }

            // does not work for PRAGMA
            #[inline]
            pub fn readonly(&self) -> bool {
                unsafe { ffi::sqlite3_stmt_readonly(self.ptr) != 0 }
            }

            #[inline]
            pub fn expanded_sql(&self) -> Option<SqliteMallocString> {
                unsafe { SqliteMallocString::from_raw(ffi::sqlite3_expanded_sql(self.ptr)) }
            }

            #[inline]
            pub fn get_status(&self, status: StatementStatus, reset: bool) -> i32 {
                assert!(!self.ptr.is_null());
                unsafe { ffi::sqlite3_stmt_status(self.ptr, status as i32, reset as i32) }
            }

            #[inline]
            #[cfg(feature = "extra_check")]
            pub fn has_tail(&self) -> bool {
                self.tail != 0
            }

            #[inline]
            pub fn tail(&self) -> usize {
                self.tail
            }

            #[inline]
            #[cfg(feature = "modern_sqlite")] // 3.28.0
            pub fn is_explain(&self) -> i32 {
                unsafe { ffi::sqlite3_stmt_isexplain(self.ptr) }
            }

            // TODO sqlite3_normalized_sql (https://sqlite.org/c3ref/expanded_sql.html) // 3.27.0 + SQLITE_ENABLE_NORMALIZE
        }

        impl Drop for RawStatement {
            fn drop(&mut self) {
                self.finalize_();
            }
        }
    }

    mod row
    {
        use ::
        {
            *,
        };
        use fallible_iterator::FallibleIterator;
        use fallible_streaming_iterator::FallibleStreamingIterator;
        use std::convert;

        use super::{Error, Result, Statement};
        use crate::types::{FromSql, FromSqlError, ValueRef};

        /// A handle for the resulting rows of a query.
        #[must_use = "Rows is lazy and will do nothing unless consumed"]
        pub struct Rows<'stmt> {
            pub stmt: Option<&'stmt Statement<'stmt>>,
            row: Option<Row<'stmt>>,
        }

        impl<'stmt> Rows<'stmt> {
            #[inline]
            fn reset(&mut self) -> Result<()> {
                if let Some(stmt) = self.stmt.take() {
                    stmt.reset()
                } else {
                    Ok(())
                }
            }
            /// Attempt to get the next row from the query. Returns `Ok(Some(Row))` if
            /// there is another row, `Err(...)` if there was an error
            /// getting the next row, and `Ok(None)` if all rows have been retrieved.
            #[inline]
            pub fn next(&mut self) -> Result<Option<&Row<'stmt>>> {
                self.advance()?;
                Ok((*self).get())
            }
            /// Map over this `Rows`, converting it to a [`Map`], which implements `FallibleIterator`.
            #[inline]
            pub fn map<F, B>(self, f: F) -> Map<'stmt, F>
            where
                F: FnMut(&Row<'_>) -> Result<B>,
            {
                Map { rows: self, f }
            }
            /// Map over this `Rows`, converting it to a [`MappedRows`], which implements `Iterator`.
            #[inline]
            pub fn mapped<F, B>(self, f: F) -> MappedRows<'stmt, F>
            where
                F: FnMut(&Row<'_>) -> Result<B>,
            {
                MappedRows { rows: self, map: f }
            }
            /// Map over this `Rows` with a fallible function, converting it to a
            /// [`AndThenRows`], which implements `Iterator` (instead of
            /// `FallibleStreamingIterator`).
            #[inline]
            pub fn and_then<F, T, E>(self, f: F) -> AndThenRows<'stmt, F>
            where
                F: FnMut(&Row<'_>) -> Result<T, E>,
            {
                AndThenRows { rows: self, map: f }
            }
            /// Give access to the underlying statement
            #[must_use]
            pub fn as_ref(&self) -> Option<&Statement<'stmt>> {
                self.stmt
            }
        }

        impl<'stmt> Rows<'stmt> {
            #[inline]
            pub fn new(stmt: &'stmt Statement<'stmt>) -> Rows<'stmt> {
                Rows {
                    stmt: Some(stmt),
                    row: None,
                }
            }

            #[inline]
            pub fn get_expected_row(&mut self) -> Result<&Row<'stmt>> {
                match self.next()? {
                    Some(row) => Ok(row),
                    None => Err(Error::QueryReturnedNoRows),
                }
            }
        }

        impl Drop for Rows<'_> {
            #[allow(unused_must_use)]
            #[inline]
            fn drop(&mut self) {
                self.reset();
            }
        }
        /// `F` is used to transform the _streaming_ iterator into a _fallible_iterator.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct Map<'stmt, F> {
            rows: Rows<'stmt>,
            f: F,
        }

        impl<F, B> FallibleIterator for Map<'_, F>
        where
            F: FnMut(&Row<'_>) -> Result<B>,
        {
            type Error = Error;
            type Item = B;

            #[inline]
            fn next(&mut self) -> Result<Option<B>> {
                match self.rows.next()? {
                    Some(v) => Ok(Some((self.f)(v)?)),
                    None => Ok(None),
                }
            }
        }
        /// An iterator over the mapped resulting rows of a query.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct MappedRows<'stmt, F> {
            rows: Rows<'stmt>,
            map: F,
        }

        impl<T, F> Iterator for MappedRows<'_, F>
        where
            F: FnMut(&Row<'_>) -> Result<T>,
        {
            type Item = Result<T>;

            #[inline]
            fn next(&mut self) -> Option<Result<T>> {
                let map = &mut self.map;
                self.rows
                    .next()
                    .transpose()
                    .map(|row_result| row_result.and_then(map))
            }
        }
        /// An iterator over the mapped resulting rows of a query, with an Error type unifying with Error.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct AndThenRows<'stmt, F> {
            rows: Rows<'stmt>,
            map: F,
        }

        impl<T, E, F> Iterator for AndThenRows<'_, F>
        where
            E: From<Error>,
            F: FnMut(&Row<'_>) -> Result<T, E>,
        {
            type Item = Result<T, E>;

            #[inline]
            fn next(&mut self) -> Option<Self::Item> {
                let map = &mut self.map;
                self.rows
                    .next()
                    .transpose()
                    .map(|row_result| row_result.map_err(E::from).and_then(map))
            }
        }
        /// `FallibleStreamingIterator` differs from the standard library's `Iterator`
        /// in two ways:
        /// * each call to `next` (`sqlite3_step`) can fail.
        /// * returned `Row` is valid until `next` is called again or `Statement` is
        ///   reset or finalized.
        impl<'stmt> FallibleStreamingIterator for Rows<'stmt> {
            type Error = Error;
            type Item = Row<'stmt>;

            #[inline]
            fn advance(&mut self) -> Result<()> {
                if let Some(stmt) = self.stmt {
                    match stmt.step() {
                        Ok(true) => {
                            self.row = Some(Row { stmt });
                            Ok(())
                        }
                        Ok(false) => {
                            let r = self.reset();
                            self.row = None;
                            r
                        }
                        Err(e) => {
                            let _ = self.reset(); // prevents infinite loop on error
                            self.row = None;
                            Err(e)
                        }
                    }
                } else {
                    self.row = None;
                    Ok(())
                }
            }

            #[inline]
            fn get(&self) -> Option<&Row<'stmt>> {
                self.row.as_ref()
            }
        }
        /// A single result row of a query.
        pub struct Row<'stmt> {
            pub stmt: &'stmt Statement<'stmt>,
        }

        impl<'stmt> Row<'stmt> {
            /// Get the value of a particular column of the result row.
            ///
            /// # Panics
            ///
            /// Panics if calling [`row.get(idx)`](Row::get) would return an error,
            /// including:
            ///
            /// * If the underlying SQLite column type is not a valid type as a source
            ///   for `T`
            /// * If the underlying SQLite integral value is outside the range
            ///   representable by `T`
            /// * If `idx` is outside the range of columns in the returned query
            #[track_caller]
            pub fn get_unwrap<I: RowIndex, T: FromSql>(&self, idx: I) -> T {
                self.get(idx).unwrap()
            }
            /// Get the value of a particular column of the result row.
            ///
            /// ## Failure
            ///
            /// Returns an `Error::InvalidColumnType` if the underlying SQLite column
            /// type is not a valid type as a source for `T`.
            ///
            /// Returns an `Error::InvalidColumnIndex` if `idx` is outside the valid
            /// column range for this row.
            ///
            /// Returns an `Error::InvalidColumnName` if `idx` is not a valid column
            /// name for this row.
            ///
            /// If the result type is i128 (which requires the `i128_blob` feature to be
            /// enabled), and the underlying SQLite column is a blob whose size is not
            /// 16 bytes, `Error::InvalidColumnType` will also be returned.
            #[track_caller]
            pub fn get<I: RowIndex, T: FromSql>(&self, idx: I) -> Result<T> {
                let idx = idx.idx(self.stmt)?;
                let value = self.stmt.value_ref(idx);
                FromSql::column_result(value).map_err(|err| match err {
                    FromSqlError::InvalidType => Error::InvalidColumnType(
                        idx,
                        self.stmt.column_name_unwrap(idx).into(),
                        value.data_type(),
                    ),
                    FromSqlError::OutOfRange(i) => Error::IntegralValueOutOfRange(idx, i),
                    FromSqlError::Other(err) => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), err)
                    }
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), Box::new(err))
                    }
                })
            }
            /// Get the value of a particular column of the result row as a `ValueRef`,
            /// allowing data to be read out of a row without copying.
            ///
            /// This `ValueRef` is valid only as long as this Row, which is enforced by
            /// its lifetime. This means that while this method is completely safe,
            /// it can be somewhat difficult to use, and most callers will be better
            /// served by [`get`](Row::get) or [`get_unwrap`](Row::get_unwrap).
            ///
            /// ## Failure
            ///
            /// Returns an `Error::InvalidColumnIndex` if `idx` is outside the valid
            /// column range for this row.
            ///
            /// Returns an `Error::InvalidColumnName` if `idx` is not a valid column
            /// name for this row.
            pub fn get_ref<I: RowIndex>(&self, idx: I) -> Result<ValueRef<'_>> {
                let idx = idx.idx(self.stmt)?;
                // Narrowing from `ValueRef<'stmt>` (which `self.stmt.value_ref(idx)`
                // returns) to `ValueRef<'a>` is needed because it's only valid until
                // the next call to sqlite3_step.
                let val_ref = self.stmt.value_ref(idx);
                Ok(val_ref)
            }
            /// Get the value of a particular column of the result row as a `ValueRef`,
            /// allowing data to be read out of a row without copying.
            ///
            /// This `ValueRef` is valid only as long as this Row, which is enforced by
            /// its lifetime. This means that while this method is completely safe,
            /// it can be difficult to use, and most callers will be better served by
            /// [`get`](Row::get) or [`get_unwrap`](Row::get_unwrap).
            ///
            /// # Panics
            ///
            /// Panics if calling [`row.get_ref(idx)`](Row::get_ref) would return an
            /// error, including:
            ///
            /// * If `idx` is outside the range of columns in the returned query.
            /// * If `idx` is not a valid column name for this row.
            #[track_caller]
            pub fn get_ref_unwrap<I: RowIndex>(&self, idx: I) -> ValueRef<'_> {
                self.get_ref(idx).unwrap()
            }
        }

        impl<'stmt> AsRef<Statement<'stmt>> for Row<'stmt> {
            fn as_ref(&self) -> &Statement<'stmt> {
                self.stmt
            }
        }
        /// Debug `Row` like an ordered `Map<Result<&str>, Result<(Type, ValueRef)>>`
        /// with column name as key except that for `Type::Blob` only its size is
        /// printed (not its content).
        impl<'stmt> std::fmt::Debug for Row<'stmt> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut dm = f.debug_map();
                for c in 0..self.stmt.column_count() {
                    let name = self.stmt.column_name(c).expect("valid column index");
                    dm.key(&name);
                    let value = self.get_ref(c);
                    match value {
                        Ok(value) => {
                            let dt = value.data_type();
                            match value {
                                ValueRef::Null => {
                                    dm.value(&(dt, ()));
                                }
                                ValueRef::Integer(i) => {
                                    dm.value(&(dt, i));
                                }
                                ValueRef::Real(f) => {
                                    dm.value(&(dt, f));
                                }
                                ValueRef::Text(s) => {
                                    dm.value(&(dt, String::from_utf8_lossy(s)));
                                }
                                ValueRef::Blob(b) => {
                                    dm.value(&(dt, b.len()));
                                }
                            }
                        }
                        Err(ref _err) => {
                            dm.value(&value);
                        }
                    }
                }
                dm.finish()
            }
        }

        mod sealed {
            /// This trait exists just to ensure that the only impls of `trait Params`
            /// that are allowed are ones in this crate.
            pub trait Sealed {}
            impl Sealed for usize {}
            impl Sealed for &str {}
        }
        /// A trait implemented by types that can index into columns of a row.
        pub trait RowIndex: sealed::Sealed {
            /// Returns the index of the appropriate column, or `None` if no such
            /// column exists.
            fn idx(&self, stmt: &Statement<'_>) -> Result<usize>;
        }

        impl RowIndex for usize {
            #[inline]
            fn idx(&self, stmt: &Statement<'_>) -> Result<usize> {
                if *self >= stmt.column_count() {
                    Err(Error::InvalidColumnIndex(*self))
                } else {
                    Ok(*self)
                }
            }
        }

        impl RowIndex for &'_ str {
            #[inline]
            fn idx(&self, stmt: &Statement<'_>) -> Result<usize> {
                stmt.column_index(self)
            }
        }

        macro_rules! tuple_try_from_row {
            ($($field:ident),*) => {
                impl<'a, $($field,)*> convert::TryFrom<&'a Row<'a>> for ($($field,)*) where $($field: FromSql,)* {
                    type Error = crate::Error;

                    // we end with index += 1, which rustc warns about
                    // unused_variables and unused_mut are allowed for ()
                    #[allow(unused_assignments, unused_variables, unused_mut)]
                    fn try_from(row: &'a Row<'a>) -> Result<Self> {
                        let mut index = 0;
                        $(
                            #[allow(non_snake_case)]
                            let $field = row.get::<_, $field>(index)?;
                            index += 1;
                        )*
                        Ok(($($field,)*))
                    }
                }
            }
        }

        macro_rules! tuples_try_from_row {
            () => {
                // not very useful, but maybe some other macro users will find this helpful
                tuple_try_from_row!();
            };
            ($first:ident $(, $remaining:ident)*) => {
                tuple_try_from_row!($first $(, $remaining)*);
                tuples_try_from_row!($($remaining),*);
            };
        }

        tuples_try_from_row!(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P);

    }
    
    pub mod serialize
    {
        //! Serialize a database.
        use ::
        {
            *,
        };
        
        use std::marker::PhantomData;
        use std::ops::Deref;
        use std::ptr::NonNull;

        use crate::error::error_from_handle;
        use crate::ffi;
        use crate::{Connection, DatabaseName, Result};

        /// Shared (SQLITE_SERIALIZE_NOCOPY) serialized database
        pub struct SharedData<'conn> {
            phantom: PhantomData<&'conn Connection>,
            ptr: NonNull<u8>,
            sz: usize,
        }
        /// Owned serialized database
        pub struct OwnedData {
            ptr: NonNull<u8>,
            sz: usize,
        }

        impl OwnedData {
            /// # Safety
            ///
            /// Caller must be certain that `ptr` is allocated by `sqlite3_malloc`.
            pub unsafe fn from_raw_nonnull(ptr: NonNull<u8>, sz: usize) -> Self {
                Self { ptr, sz }
            }

            fn into_raw(self) -> (*mut u8, usize) {
                let raw = (self.ptr.as_ptr(), self.sz);
                std::mem::forget(self);
                raw
            }
        }

        impl Drop for OwnedData {
            fn drop(&mut self) {
                unsafe {
                    ffi::sqlite3_free(self.ptr.as_ptr().cast());
                }
            }
        }
        /// Serialized database
        pub enum Data<'conn> {
            /// Shared (SQLITE_SERIALIZE_NOCOPY) serialized database
            Shared(SharedData<'conn>),
            /// Owned serialized database
            Owned(OwnedData),
        }

        impl<'conn> Deref for Data<'conn> {
            type Target = [u8];

            fn deref(&self) -> &[u8] {
                let (ptr, sz) = match self {
                    Data::Owned(OwnedData { ptr, sz }) => (ptr.as_ptr(), *sz),
                    Data::Shared(SharedData { ptr, sz, .. }) => (ptr.as_ptr(), *sz),
                };
                unsafe { std::slice::from_raw_parts(ptr, sz) }
            }
        }

        impl Connection {
            /// Serialize a database.
            pub fn serialize(&self, schema: DatabaseName) -> Result<Data> {
                let schema = schema.as_cstring()?;
                let mut sz = 0;
                let mut ptr: *mut u8 = unsafe {
                    ffi::sqlite3_serialize(
                        self.handle(),
                        schema.as_ptr(),
                        &mut sz,
                        ffi::SQLITE_SERIALIZE_NOCOPY,
                    )
                };
                Ok(if ptr.is_null() {
                    ptr = unsafe { ffi::sqlite3_serialize(self.handle(), schema.as_ptr(), &mut sz, 0) };
                    if ptr.is_null() {
                        return Err(unsafe { error_from_handle(self.handle(), ffi::SQLITE_NOMEM) });
                    }
                    Data::Owned(OwnedData {
                        ptr: NonNull::new(ptr).unwrap(),
                        sz: sz.try_into().unwrap(),
                    })
                } else {
                    // shared buffer
                    Data::Shared(SharedData {
                        ptr: NonNull::new(ptr).unwrap(),
                        sz: sz.try_into().unwrap(),
                        phantom: PhantomData,
                    })
                })
            }
            /// Deserialize a database.
            pub fn deserialize(
                &mut self,
                schema: DatabaseName<'_>,
                data: OwnedData,
                read_only: bool,
            ) -> Result<()> {
                let schema = schema.as_cstring()?;
                let (data, sz) = data.into_raw();
                let sz = sz.try_into().unwrap();
                let flags = if read_only {
                    ffi::SQLITE_DESERIALIZE_FREEONCLOSE | ffi::SQLITE_DESERIALIZE_READONLY
                } else {
                    ffi::SQLITE_DESERIALIZE_FREEONCLOSE | ffi::SQLITE_DESERIALIZE_RESIZEABLE
                };
                let rc = unsafe {
                    ffi::sqlite3_deserialize(self.handle(), schema.as_ptr(), data, sz, sz, flags)
                };
                if rc != ffi::SQLITE_OK {
                    // TODO sqlite3_free(data) ?
                    return Err(unsafe { error_from_handle(self.handle(), rc) });
                }
                /* TODO
                if let Some(mxSize) = mxSize {
                    unsafe {
                        ffi::sqlite3_file_control(
                            self.handle(),
                            schema.as_ptr(),
                            ffi::SQLITE_FCNTL_SIZE_LIMIT,
                            &mut mxSize,
                        )
                    };
                }*/
                Ok(())
            }
        }
    }
    
    pub mod session
    {
        //! [Session Extension](https://sqlite.org/sessionintro.html)
        use ::
        {
            *,
        };
        
        #![allow(non_camel_case_types)]

        use std::ffi::CStr;
        use std::io::{Read, Write};
        use std::marker::PhantomData;
        use std::os::raw::{c_char, c_int, c_uchar, c_void};
        use std::panic::catch_unwind;
        use std::ptr;
        use std::slice::{from_raw_parts, from_raw_parts_mut};

        use fallible_streaming_iterator::FallibleStreamingIterator;

        use crate::error::{check, error_from_sqlite_code, Error};
        use crate::ffi;
        use crate::hooks::Action;
        use crate::types::ValueRef;
        use crate::{errmsg_to_string, str_to_cstring, Connection, DatabaseName, Result};

        // https://sqlite.org/session.html

        type Filter = Option<Box<dyn Fn(&str) -> bool>>;

        /// An instance of this object is a session that can be
        /// used to record changes to a database.
        pub struct Session<'conn> {
            phantom: PhantomData<&'conn Connection>,
            s: *mut ffi::sqlite3_session,
            filter: Filter,
        }

        impl Session<'_> {
            /// Create a new session object
            #[inline]
            pub fn new(db: &Connection) -> Result<Session<'_>> {
                Session::new_with_name(db, DatabaseName::Main)
            }
            /// Create a new session object
            #[inline]
            pub fn new_with_name<'conn>(
                db: &'conn Connection,
                name: DatabaseName<'_>,
            ) -> Result<Session<'conn>> {
                let name = name.as_cstring()?;

                let db = db.db.borrow_mut().db;

                let mut s: *mut ffi::sqlite3_session = ptr::null_mut();
                check(unsafe { ffi::sqlite3session_create(db, name.as_ptr(), &mut s) })?;

                Ok(Session {
                    phantom: PhantomData,
                    s,
                    filter: None,
                })
            }
            /// Set a table filter
            pub fn table_filter<F>(&mut self, filter: Option<F>)
            where
                F: Fn(&str) -> bool + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(
                    p_arg: *mut c_void,
                    tbl_str: *const c_char,
                ) -> c_int
                where
                    F: Fn(&str) -> bool,
                {
                    let tbl_name = CStr::from_ptr(tbl_str).to_str();
                    c_int::from(
                        catch_unwind(|| {
                            let boxed_filter: *mut F = p_arg.cast::<F>();
                            (*boxed_filter)(tbl_name.expect("non-utf8 table name"))
                        })
                        .unwrap_or_default(),
                    )
                }

                match filter {
                    Some(filter) => {
                        let boxed_filter = Box::new(filter);
                        unsafe {
                            ffi::sqlite3session_table_filter(
                                self.s,
                                Some(call_boxed_closure::<F>),
                                &*boxed_filter as *const F as *mut _,
                            );
                        }
                        self.filter = Some(boxed_filter);
                    }
                    _ => {
                        unsafe { ffi::sqlite3session_table_filter(self.s, None, ptr::null_mut()) }
                        self.filter = None;
                    }
                };
            }
            /// Attach a table. `None` means all tables.
            pub fn attach(&mut self, table: Option<&str>) -> Result<()> {
                let table = if let Some(table) = table {
                    Some(str_to_cstring(table)?)
                } else {
                    None
                };
                let table = table.as_ref().map(|s| s.as_ptr()).unwrap_or(ptr::null());
                check(unsafe { ffi::sqlite3session_attach(self.s, table) })
            }
            /// Generate a Changeset
            pub fn changeset(&mut self) -> Result<Changeset> {
                let mut n = 0;
                let mut cs: *mut c_void = ptr::null_mut();
                check(unsafe { ffi::sqlite3session_changeset(self.s, &mut n, &mut cs) })?;
                Ok(Changeset { cs, n })
            }
            /// Write the set of changes represented by this session to `output`.
            #[inline]
            pub fn changeset_strm(&mut self, output: &mut dyn Write) -> Result<()> {
                let output_ref = &output;
                check(unsafe {
                    ffi::sqlite3session_changeset_strm(
                        self.s,
                        Some(x_output),
                        output_ref as *const &mut dyn Write as *mut c_void,
                    )
                })
            }
            /// Generate a Patchset
            #[inline]
            pub fn patchset(&mut self) -> Result<Changeset> {
                let mut n = 0;
                let mut ps: *mut c_void = ptr::null_mut();
                check(unsafe { ffi::sqlite3session_patchset(self.s, &mut n, &mut ps) })?;
                // TODO Validate: same struct
                Ok(Changeset { cs: ps, n })
            }
            /// Write the set of patches represented by this session to `output`.
            #[inline]
            pub fn patchset_strm(&mut self, output: &mut dyn Write) -> Result<()> {
                let output_ref = &output;
                check(unsafe {
                    ffi::sqlite3session_patchset_strm(
                        self.s,
                        Some(x_output),
                        output_ref as *const &mut dyn Write as *mut c_void,
                    )
                })
            }
            /// Load the difference between tables.
            pub fn diff(&mut self, from: DatabaseName<'_>, table: &str) -> Result<()> {
                let from = from.as_cstring()?;
                let table = str_to_cstring(table)?;
                let table = table.as_ptr();
                unsafe {
                    let mut errmsg = ptr::null_mut();
                    let r =
                        ffi::sqlite3session_diff(self.s, from.as_ptr(), table, &mut errmsg as *mut *mut _);
                    if r != ffi::SQLITE_OK {
                        let errmsg: *mut c_char = errmsg;
                        let message = errmsg_to_string(&*errmsg);
                        ffi::sqlite3_free(errmsg as *mut c_void);
                        return Err(error_from_sqlite_code(r, Some(message)));
                    }
                }
                Ok(())
            }
            /// Test if a changeset has recorded any changes
            #[inline]
            pub fn is_empty(&self) -> bool {
                unsafe { ffi::sqlite3session_isempty(self.s) != 0 }
            }
            /// Query the current state of the session
            #[inline]
            pub fn is_enabled(&self) -> bool {
                unsafe { ffi::sqlite3session_enable(self.s, -1) != 0 }
            }
            /// Enable or disable the recording of changes
            #[inline]
            pub fn set_enabled(&mut self, enabled: bool) {
                unsafe {
                    ffi::sqlite3session_enable(self.s, c_int::from(enabled));
                }
            }
            /// Query the current state of the indirect flag
            #[inline]
            pub fn is_indirect(&self) -> bool {
                unsafe { ffi::sqlite3session_indirect(self.s, -1) != 0 }
            }
            /// Set or clear the indirect change flag
            #[inline]
            pub fn set_indirect(&mut self, indirect: bool) {
                unsafe {
                    ffi::sqlite3session_indirect(self.s, c_int::from(indirect));
                }
            }
        }

        impl Drop for Session<'_> {
            #[inline]
            fn drop(&mut self) {
                if self.filter.is_some() {
                    self.table_filter(None::<fn(&str) -> bool>);
                }
                unsafe { ffi::sqlite3session_delete(self.s) };
            }
        }
        /// Invert a changeset
        #[inline]
        pub fn invert_strm(input: &mut dyn Read, output: &mut dyn Write) -> Result<()> {
            let input_ref = &input;
            let output_ref = &output;
            check(unsafe {
                ffi::sqlite3changeset_invert_strm(
                    Some(x_input),
                    input_ref as *const &mut dyn Read as *mut c_void,
                    Some(x_output),
                    output_ref as *const &mut dyn Write as *mut c_void,
                )
            })
        }
        /// Combine two changesets
        #[inline]
        pub fn concat_strm(
            input_a: &mut dyn Read,
            input_b: &mut dyn Read,
            output: &mut dyn Write,
        ) -> Result<()> {
            let input_a_ref = &input_a;
            let input_b_ref = &input_b;
            let output_ref = &output;
            check(unsafe {
                ffi::sqlite3changeset_concat_strm(
                    Some(x_input),
                    input_a_ref as *const &mut dyn Read as *mut c_void,
                    Some(x_input),
                    input_b_ref as *const &mut dyn Read as *mut c_void,
                    Some(x_output),
                    output_ref as *const &mut dyn Write as *mut c_void,
                )
            })
        }
        /// Changeset or Patchset
        pub struct Changeset {
            cs: *mut c_void,
            n: c_int,
        }

        impl Changeset {
            /// Invert a changeset
            #[inline]
            pub fn invert(&self) -> Result<Changeset> {
                let mut n = 0;
                let mut cs = ptr::null_mut();
                check(unsafe {
                    ffi::sqlite3changeset_invert(self.n, self.cs, &mut n, &mut cs as *mut *mut _)
                })?;
                Ok(Changeset { cs, n })
            }
            /// Create an iterator to traverse a changeset
            #[inline]
            pub fn iter(&self) -> Result<ChangesetIter<'_>> {
                let mut it = ptr::null_mut();
                check(unsafe { ffi::sqlite3changeset_start(&mut it as *mut *mut _, self.n, self.cs) })?;
                Ok(ChangesetIter {
                    phantom: PhantomData,
                    it,
                    item: None,
                })
            }
            /// Concatenate two changeset objects
            #[inline]
            pub fn concat(a: &Changeset, b: &Changeset) -> Result<Changeset> {
                let mut n = 0;
                let mut cs = ptr::null_mut();
                check(unsafe {
                    ffi::sqlite3changeset_concat(a.n, a.cs, b.n, b.cs, &mut n, &mut cs as *mut *mut _)
                })?;
                Ok(Changeset { cs, n })
            }
        }

        impl Drop for Changeset {
            #[inline]
            fn drop(&mut self) {
                unsafe {
                    ffi::sqlite3_free(self.cs);
                }
            }
        }
        /// Cursor for iterating over the elements of a changeset
        /// or patchset.
        pub struct ChangesetIter<'changeset> {
            phantom: PhantomData<&'changeset Changeset>,
            it: *mut ffi::sqlite3_changeset_iter,
            item: Option<ChangesetItem>,
        }

        impl ChangesetIter<'_> {
            /// Create an iterator on `input`
            #[inline]
            pub fn start_strm<'input>(input: &&'input mut dyn Read) -> Result<ChangesetIter<'input>> {
                let mut it = ptr::null_mut();
                check(unsafe {
                    ffi::sqlite3changeset_start_strm(
                        &mut it as *mut *mut _,
                        Some(x_input),
                        input as *const &mut dyn Read as *mut c_void,
                    )
                })?;
                Ok(ChangesetIter {
                    phantom: PhantomData,
                    it,
                    item: None,
                })
            }
        }

        impl FallibleStreamingIterator for ChangesetIter<'_> {
            type Error = crate::error::Error;
            type Item = ChangesetItem;

            #[inline]
            fn advance(&mut self) -> Result<()> {
                let rc = unsafe { ffi::sqlite3changeset_next(self.it) };
                match rc {
                    ffi::SQLITE_ROW => {
                        self.item = Some(ChangesetItem { it: self.it });
                        Ok(())
                    }
                    ffi::SQLITE_DONE => {
                        self.item = None;
                        Ok(())
                    }
                    code => Err(error_from_sqlite_code(code, None)),
                }
            }

            #[inline]
            fn get(&self) -> Option<&ChangesetItem> {
                self.item.as_ref()
            }
        }
        /// Operation
        pub struct Operation<'item> {
            table_name: &'item str,
            number_of_columns: i32,
            code: Action,
            indirect: bool,
        }

        impl Operation<'_> {
            /// Returns the table name.
            #[inline]
            pub fn table_name(&self) -> &str {
                self.table_name
            }
            /// Returns the number of columns in table
            #[inline]
            pub fn number_of_columns(&self) -> i32 {
                self.number_of_columns
            }
            /// Returns the action code.
            #[inline]
            pub fn code(&self) -> Action {
                self.code
            }
            /// Returns `true` for an 'indirect' change.
            #[inline]
            pub fn indirect(&self) -> bool {
                self.indirect
            }
        }

        impl Drop for ChangesetIter<'_> {
            #[inline]
            fn drop(&mut self) {
                unsafe {
                    ffi::sqlite3changeset_finalize(self.it);
                }
            }
        }
        /// An item passed to a conflict-handler by
        /// [`Connection::apply`](Connection::apply), or an item generated by
        /// [`ChangesetIter::next`](ChangesetIter::next).
        // TODO enum ? Delete, Insert, Update, ...
        pub struct ChangesetItem {
            it: *mut ffi::sqlite3_changeset_iter,
        }

        impl ChangesetItem {
            /// Obtain conflicting row values
            ///
            /// May only be called with an `SQLITE_CHANGESET_DATA` or
            /// `SQLITE_CHANGESET_CONFLICT` conflict handler callback.
            #[inline]
            pub fn conflict(&self, col: usize) -> Result<ValueRef<'_>> {
                unsafe {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    check(ffi::sqlite3changeset_conflict(
                        self.it,
                        col as i32,
                        &mut p_value,
                    ))?;
                    if p_value.is_null() {
                        Err(Error::InvalidColumnIndex(col))
                    } else {
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }
            /// Determine the number of foreign key constraint violations
            ///
            /// May only be called with an `SQLITE_CHANGESET_FOREIGN_KEY` conflict
            /// handler callback.
            #[inline]
            pub fn fk_conflicts(&self) -> Result<i32> {
                unsafe {
                    let mut p_out = 0;
                    check(ffi::sqlite3changeset_fk_conflicts(self.it, &mut p_out))?;
                    Ok(p_out)
                }
            }
            /// Obtain new.* Values
            ///
            /// May only be called if the type of change is either `SQLITE_UPDATE` or
            /// `SQLITE_INSERT`.
            #[inline]
            pub fn new_value(&self, col: usize) -> Result<ValueRef<'_>> {
                unsafe {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    check(ffi::sqlite3changeset_new(self.it, col as i32, &mut p_value))?;
                    if p_value.is_null() {
                        Err(Error::InvalidColumnIndex(col))
                    } else {
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }
            /// Obtain old.* Values
            ///
            /// May only be called if the type of change is either `SQLITE_DELETE` or
            /// `SQLITE_UPDATE`.
            #[inline]
            pub fn old_value(&self, col: usize) -> Result<ValueRef<'_>> {
                unsafe {
                    let mut p_value: *mut ffi::sqlite3_value = ptr::null_mut();
                    check(ffi::sqlite3changeset_old(self.it, col as i32, &mut p_value))?;
                    if p_value.is_null() {
                        Err(Error::InvalidColumnIndex(col))
                    } else {
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }
            /// Obtain the current operation
            #[inline]
            pub fn op(&self) -> Result<Operation<'_>> {
                let mut number_of_columns = 0;
                let mut code = 0;
                let mut indirect = 0;
                let tab = unsafe {
                    let mut pz_tab: *const c_char = ptr::null();
                    check(ffi::sqlite3changeset_op(
                        self.it,
                        &mut pz_tab,
                        &mut number_of_columns,
                        &mut code,
                        &mut indirect,
                    ))?;
                    CStr::from_ptr(pz_tab)
                };
                let table_name = tab.to_str()?;
                Ok(Operation {
                    table_name,
                    number_of_columns,
                    code: Action::from(code),
                    indirect: indirect != 0,
                })
            }
            /// Obtain the primary key definition of a table
            #[inline]
            pub fn pk(&self) -> Result<&[u8]> {
                let mut number_of_columns = 0;
                unsafe {
                    let mut pks: *mut c_uchar = ptr::null_mut();
                    check(ffi::sqlite3changeset_pk(
                        self.it,
                        &mut pks,
                        &mut number_of_columns,
                    ))?;
                    Ok(from_raw_parts(pks, number_of_columns as usize))
                }
            }
        }
        /// Used to combine two or more changesets or
        /// patchsets
        pub struct Changegroup {
            cg: *mut ffi::sqlite3_changegroup,
        }

        impl Changegroup {
            /// Create a new change group.
            #[inline]
            pub fn new() -> Result<Self> {
                let mut cg = ptr::null_mut();
                check(unsafe { ffi::sqlite3changegroup_new(&mut cg) })?;
                Ok(Changegroup { cg })
            }
            /// Add a changeset
            #[inline]
            pub fn add(&mut self, cs: &Changeset) -> Result<()> {
                check(unsafe { ffi::sqlite3changegroup_add(self.cg, cs.n, cs.cs) })
            }
            /// Add a changeset read from `input` to this change group.
            #[inline]
            pub fn add_stream(&mut self, input: &mut dyn Read) -> Result<()> {
                let input_ref = &input;
                check(unsafe {
                    ffi::sqlite3changegroup_add_strm(
                        self.cg,
                        Some(x_input),
                        input_ref as *const &mut dyn Read as *mut c_void,
                    )
                })
            }
            /// Obtain a composite Changeset
            #[inline]
            pub fn output(&mut self) -> Result<Changeset> {
                let mut n = 0;
                let mut output: *mut c_void = ptr::null_mut();
                check(unsafe { ffi::sqlite3changegroup_output(self.cg, &mut n, &mut output) })?;
                Ok(Changeset { cs: output, n })
            }
            /// Write the combined set of changes to `output`.
            #[inline]
            pub fn output_strm(&mut self, output: &mut dyn Write) -> Result<()> {
                let output_ref = &output;
                check(unsafe {
                    ffi::sqlite3changegroup_output_strm(
                        self.cg,
                        Some(x_output),
                        output_ref as *const &mut dyn Write as *mut c_void,
                    )
                })
            }
        }

        impl Drop for Changegroup {
            #[inline]
            fn drop(&mut self) {
                unsafe {
                    ffi::sqlite3changegroup_delete(self.cg);
                }
            }
        }

        impl Connection {
            /// Apply a changeset to a database
            pub fn apply<F, C>(&self, cs: &Changeset, filter: Option<F>, conflict: C) -> Result<()>
            where
                F: Fn(&str) -> bool + Send + 'static,
                C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
            {
                let db = self.db.borrow_mut().db;

                let filtered = filter.is_some();
                let tuple = &mut (filter, conflict);
                check(unsafe {
                    if filtered {
                        ffi::sqlite3changeset_apply(
                            db,
                            cs.n,
                            cs.cs,
                            Some(call_filter::<F, C>),
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    } else {
                        ffi::sqlite3changeset_apply(
                            db,
                            cs.n,
                            cs.cs,
                            None,
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    }
                })
            }
            /// Apply a changeset to a database
            pub fn apply_strm<F, C>(
                &self,
                input: &mut dyn Read,
                filter: Option<F>,
                conflict: C,
            ) -> Result<()>
            where
                F: Fn(&str) -> bool + Send + 'static,
                C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
            {
                let input_ref = &input;
                let db = self.db.borrow_mut().db;

                let filtered = filter.is_some();
                let tuple = &mut (filter, conflict);
                check(unsafe {
                    if filtered {
                        ffi::sqlite3changeset_apply_strm(
                            db,
                            Some(x_input),
                            input_ref as *const &mut dyn Read as *mut c_void,
                            Some(call_filter::<F, C>),
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    } else {
                        ffi::sqlite3changeset_apply_strm(
                            db,
                            Some(x_input),
                            input_ref as *const &mut dyn Read as *mut c_void,
                            None,
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    }
                })
            }
        }
        /// Constants passed to the conflict handler
        /// See [here](https://sqlite.org/session.html#SQLITE_CHANGESET_CONFLICT) for details.
        #[allow(missing_docs)]
        #[repr(i32)]
        #[derive(Debug, PartialEq, Eq)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms)]
        pub enum ConflictType {
            UNKNOWN = -1,
            SQLITE_CHANGESET_DATA = ffi::SQLITE_CHANGESET_DATA,
            SQLITE_CHANGESET_NOTFOUND = ffi::SQLITE_CHANGESET_NOTFOUND,
            SQLITE_CHANGESET_CONFLICT = ffi::SQLITE_CHANGESET_CONFLICT,
            SQLITE_CHANGESET_CONSTRAINT = ffi::SQLITE_CHANGESET_CONSTRAINT,
            SQLITE_CHANGESET_FOREIGN_KEY = ffi::SQLITE_CHANGESET_FOREIGN_KEY,
        }
        impl From<i32> for ConflictType {
            fn from(code: i32) -> ConflictType {
                match code {
                    ffi::SQLITE_CHANGESET_DATA => ConflictType::SQLITE_CHANGESET_DATA,
                    ffi::SQLITE_CHANGESET_NOTFOUND => ConflictType::SQLITE_CHANGESET_NOTFOUND,
                    ffi::SQLITE_CHANGESET_CONFLICT => ConflictType::SQLITE_CHANGESET_CONFLICT,
                    ffi::SQLITE_CHANGESET_CONSTRAINT => ConflictType::SQLITE_CHANGESET_CONSTRAINT,
                    ffi::SQLITE_CHANGESET_FOREIGN_KEY => ConflictType::SQLITE_CHANGESET_FOREIGN_KEY,
                    _ => ConflictType::UNKNOWN,
                }
            }
        }
        /// Constants returned by the conflict handler
        /// See [here](https://sqlite.org/session.html#SQLITE_CHANGESET_ABORT) for details.
        #[allow(missing_docs)]
        #[repr(i32)]
        #[derive(Debug, PartialEq, Eq)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms)]
        pub enum ConflictAction {
            SQLITE_CHANGESET_OMIT = ffi::SQLITE_CHANGESET_OMIT,
            SQLITE_CHANGESET_REPLACE = ffi::SQLITE_CHANGESET_REPLACE,
            SQLITE_CHANGESET_ABORT = ffi::SQLITE_CHANGESET_ABORT,
        }

        unsafe extern "C" fn call_filter<F, C>(p_ctx: *mut c_void, tbl_str: *const c_char) -> c_int
        where
            F: Fn(&str) -> bool + Send + 'static,
            C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
        {
            let tbl_name = CStr::from_ptr(tbl_str).to_str();
            c_int::from(
                catch_unwind(|| {
                    let tuple: *mut (Option<F>, C) = p_ctx.cast::<(Option<F>, C)>();
                    if let Some(ref filter) = (*tuple).0 {
                        filter(tbl_name.expect("illegal table name"))
                    } else {
                        true
                    }
                })
                .unwrap_or_default(),
            )
        }

        unsafe extern "C" fn call_conflict<F, C>(
            p_ctx: *mut c_void,
            e_conflict: c_int,
            p: *mut ffi::sqlite3_changeset_iter,
        ) -> c_int
        where
            F: Fn(&str) -> bool + Send + 'static,
            C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
        {
            let conflict_type = ConflictType::from(e_conflict);
            let item = ChangesetItem { it: p };
            if let Ok(action) = catch_unwind(|| {
                let tuple: *mut (Option<F>, C) = p_ctx.cast::<(Option<F>, C)>();
                (*tuple).1(conflict_type, item)
            }) {
                action as c_int
            } else {
                ffi::SQLITE_CHANGESET_ABORT
            }
        }

        unsafe extern "C" fn x_input(p_in: *mut c_void, data: *mut c_void, len: *mut c_int) -> c_int {
            if p_in.is_null() {
                return ffi::SQLITE_MISUSE;
            }
            let bytes: &mut [u8] = from_raw_parts_mut(data as *mut u8, *len as usize);
            let input = p_in as *mut &mut dyn Read;
            match (*input).read(bytes) {
                Ok(n) => {
                    *len = n as i32; // TODO Validate: n = 0 may not mean the reader will always no longer be able to
                                    // produce bytes.
                    ffi::SQLITE_OK
                }
                Err(_) => ffi::SQLITE_IOERR_READ, // TODO check if err is a (ru)sqlite Error => propagate
            }
        }

        unsafe extern "C" fn x_output(p_out: *mut c_void, data: *const c_void, len: c_int) -> c_int {
            if p_out.is_null() {
                return ffi::SQLITE_MISUSE;
            }
            // The sessions module never invokes an xOutput callback with the third
            // parameter set to a value less than or equal to zero.
            let bytes: &[u8] = from_raw_parts(data as *const u8, len as usize);
            let output = p_out as *mut &mut dyn Write;
            match (*output).write_all(bytes) {
                Ok(_) => ffi::SQLITE_OK,
                Err(_) => ffi::SQLITE_IOERR_WRITE, // TODO check if err is a (ru)sqlite Error => propagate
            }
        }
    }

    mod statement
    {
        use ::
        {
            *,
        };
        use std::os::raw::{c_int, c_void};
        #[cfg(feature = "array")]
        use std::rc::Rc;
        use std::slice::from_raw_parts;
        use std::{fmt, mem, ptr, str};

        use super::ffi;
        use super::{len_as_c_int, str_for_sqlite};
        use super::{
            AndThenRows, Connection, Error, MappedRows, Params, RawStatement, Result, Row, Rows, ValueRef,
        };
        use crate::types::{ToSql, ToSqlOutput};
        #[cfg(feature = "array")]
        use crate::vtab::array::{free_array, ARRAY_TYPE};

        /// A prepared statement.
        pub struct Statement<'conn> {
            conn: &'conn Connection,
            pub stmt: RawStatement,
        }

        impl Statement<'_> {
            /// Execute the prepared statement.
            #[inline]
            pub fn execute<P: Params>(&mut self, params: P) -> Result<usize> {
                params.__bind_in(self)?;
                self.execute_with_bound_parameters()
            }
            /// Execute an INSERT and return the ROWID.
            #[inline]
            pub fn insert<P: Params>(&mut self, params: P) -> Result<i64> {
                let changes = self.execute(params)?;
                match changes {
                    1 => Ok(self.conn.last_insert_rowid()),
                    _ => Err(Error::StatementChangedRows(changes)),
                }
            }
            /// Execute the prepared statement, returning a handle to the resulting rows.
            #[inline]
            pub fn query<P: Params>(&mut self, params: P) -> Result<Rows<'_>> {
                params.__bind_in(self)?;
                Ok(Rows::new(self))
            }
            /// Executes the prepared statement and maps a function over the resulting
            /// rows, returning an iterator over the mapped function results.
            pub fn query_map<T, P, F>(&mut self, params: P, f: F) -> Result<MappedRows<'_, F>>
            where
                P: Params,
                F: FnMut(&Row<'_>) -> Result<T>,
            {
                self.query(params).map(|rows| rows.mapped(f))
            }
            /// Executes the prepared statement and maps a function over the resulting
            /// rows, where the function returns a `Result` with `Error` type
            /// implementing `std::convert::From<Error>` (so errors can be unified).
            #[inline]
            pub fn query_and_then<T, E, P, F>(&mut self, params: P, f: F) -> Result<AndThenRows<'_, F>>
            where
                P: Params,
                E: From<Error>,
                F: FnMut(&Row<'_>) -> Result<T, E>,
            {
                self.query(params).map(|rows| rows.and_then(f))
            }
            /// Return `true` if a query in the SQL statement it executes returns one
            /// or more rows and `false` if the SQL returns an empty set.
            #[inline]
            pub fn exists<P: Params>(&mut self, params: P) -> Result<bool> {
                let mut rows = self.query(params)?;
                let exists = rows.next()?.is_some();
                Ok(exists)
            }
            /// Convenience method to execute a query that is expected to return a single row.
            pub fn query_row<T, P, F>(&mut self, params: P, f: F) -> Result<T>
            where
                P: Params,
                F: FnOnce(&Row<'_>) -> Result<T>,
            {
                let mut rows = self.query(params)?;

                rows.get_expected_row().and_then(f)
            }
            /// Consumes the statement.
            #[inline]
            pub fn finalize(mut self) -> Result<()> {
                self.finalize_()
            }
            /// Return the (one-based) index of an SQL parameter given its name.
            #[inline]
            pub fn parameter_index(&self, name: &str) -> Result<Option<usize>> {
                Ok(self.stmt.bind_parameter_index(name))
            }
            /// Return the SQL parameter name given its (one-based) index (the inverse
            /// of [`Statement::parameter_index`]).
            #[inline]
            pub fn parameter_name(&self, index: usize) -> Option<&'_ str> {
                self.stmt.bind_parameter_name(index as i32).map(|name| {
                    name.to_str()
                        .expect("Invalid UTF-8 sequence in parameter name")
                })
            }

            #[inline]
            pub fn bind_parameters<P>(&mut self, params: P) -> Result<()>
            where
                P: IntoIterator,
                P::Item: ToSql,
            {
                let expected = self.stmt.bind_parameter_count();
                let mut index = 0;
                for p in params {
                    index += 1; // The leftmost SQL parameter has an index of 1.
                    if index > expected {
                        break;
                    }
                    self.bind_parameter(&p, index)?;
                }
                if index != expected {
                    Err(Error::InvalidParameterCount(index, expected))
                } else {
                    Ok(())
                }
            }

            #[inline]
            pub fn ensure_parameter_count(&self, n: usize) -> Result<()> {
                let count = self.parameter_count();
                if count != n {
                    Err(Error::InvalidParameterCount(n, count))
                } else {
                    Ok(())
                }
            }

            #[inline]
            pub fn bind_parameters_named<T: ?Sized + ToSql>(
                &mut self,
                params: &[(&str, &T)],
            ) -> Result<()> {
                for &(name, value) in params {
                    if let Some(i) = self.parameter_index(name)? {
                        let ts: &dyn ToSql = &value;
                        self.bind_parameter(ts, i)?;
                    } else {
                        return Err(Error::InvalidParameterName(name.into()));
                    }
                }
                Ok(())
            }
            /// Return the number of parameters that can be bound to this statement.
            #[inline]
            pub fn parameter_count(&self) -> usize {
                self.stmt.bind_parameter_count()
            }
            /// Low level API to directly bind a parameter to a given index.
            #[inline]
            pub fn raw_bind_parameter<T: ToSql>(
                &mut self,
                one_based_col_index: usize,
                param: T,
            ) -> Result<()> {
                // This is the same as `bind_parameter` but slightly more ergonomic and
                // correctly takes `&mut self`.
                self.bind_parameter(&param, one_based_col_index)
            }
            /// Low level API to execute a statement given that all parameters were
            /// bound explicitly with the [`Statement::raw_bind_parameter`] API.
            #[inline]
            pub fn raw_execute(&mut self) -> Result<usize> {
                self.execute_with_bound_parameters()
            }
            /// Low level API to get `Rows` for this query given that all parameters
            /// were bound explicitly with the [`Statement::raw_bind_parameter`] API.
            #[inline]
            pub fn raw_query(&mut self) -> Rows<'_> {
                Rows::new(self)
            }

            // generic because many of these branches can constant fold away.
            fn bind_parameter<P: ?Sized + ToSql>(&self, param: &P, col: usize) -> Result<()> {
                let value = param.to_sql()?;

                let ptr = unsafe { self.stmt.ptr() };
                let value = match value {
                    ToSqlOutput::Borrowed(v) => v,
                    ToSqlOutput::Owned(ref v) => ValueRef::from(v),

                    #[cfg(feature = "blob")]
                    ToSqlOutput::ZeroBlob(len) => {
                        // TODO sqlite3_bind_zeroblob64 // 3.8.11
                        return self
                            .conn
                            .decode_result(unsafe { ffi::sqlite3_bind_zeroblob(ptr, col as c_int, len) });
                    }
                    #[cfg(feature = "functions")]
                    ToSqlOutput::Arg(_) => {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_MISUSE),
                            Some(format!("Unsupported value \"{value:?}\"")),
                        ));
                    }
                    #[cfg(feature = "array")]
                    ToSqlOutput::Array(a) => {
                        return self.conn.decode_result(unsafe {
                            ffi::sqlite3_bind_pointer(
                                ptr,
                                col as c_int,
                                Rc::into_raw(a) as *mut c_void,
                                ARRAY_TYPE,
                                Some(free_array),
                            )
                        });
                    }
                };
                self.conn.decode_result(match value {
                    ValueRef::Null => unsafe { ffi::sqlite3_bind_null(ptr, col as c_int) },
                    ValueRef::Integer(i) => unsafe { ffi::sqlite3_bind_int64(ptr, col as c_int, i) },
                    ValueRef::Real(r) => unsafe { ffi::sqlite3_bind_double(ptr, col as c_int, r) },
                    ValueRef::Text(s) => unsafe {
                        let (c_str, len, destructor) = str_for_sqlite(s)?;
                        // TODO sqlite3_bind_text64 // 3.8.7
                        ffi::sqlite3_bind_text(ptr, col as c_int, c_str, len, destructor)
                    },
                    ValueRef::Blob(b) => unsafe {
                        let length = len_as_c_int(b.len())?;
                        if length == 0 {
                            ffi::sqlite3_bind_zeroblob(ptr, col as c_int, 0)
                        } else {
                            // TODO sqlite3_bind_blob64 // 3.8.7
                            ffi::sqlite3_bind_blob(
                                ptr,
                                col as c_int,
                                b.as_ptr().cast::<c_void>(),
                                length,
                                ffi::SQLITE_TRANSIENT(),
                            )
                        }
                    },
                })
            }

            #[inline]
            fn execute_with_bound_parameters(&mut self) -> Result<usize> {
                self.check_update()?;
                let r = self.stmt.step();
                let rr = self.stmt.reset();
                match r {
                    ffi::SQLITE_DONE => match rr {
                        ffi::SQLITE_OK => Ok(self.conn.changes() as usize),
                        _ => Err(self.conn.decode_result(rr).unwrap_err()),
                    },
                    ffi::SQLITE_ROW => Err(Error::ExecuteReturnedResults),
                    _ => Err(self.conn.decode_result(r).unwrap_err()),
                }
            }

            #[inline]
            fn finalize_(&mut self) -> Result<()> {
                let mut stmt = unsafe { RawStatement::new(ptr::null_mut(), 0) };
                mem::swap(&mut stmt, &mut self.stmt);
                self.conn.decode_result(stmt.finalize())
            }

            #[cfg(feature = "extra_check")]
            #[inline]
            fn check_update(&self) -> Result<()> {
                // sqlite3_column_count works for DML but not for DDL (ie ALTER)
                if self.column_count() > 0 && self.stmt.readonly() {
                    return Err(Error::ExecuteReturnedResults);
                }
                Ok(())
            }

            #[cfg(not(feature = "extra_check"))]
            #[inline]
            #[allow(clippy::unnecessary_wraps)]
            fn check_update(&self) -> Result<()> {
                Ok(())
            }
            /// Returns a string containing the SQL text of prepared statement with
            /// bound parameters expanded.
            pub fn expanded_sql(&self) -> Option<String> {
                self.stmt
                    .expanded_sql()
                    .map(|s| s.to_string_lossy().to_string())
            }
            /// Get the value for one of the status counters for this statement.
            #[inline]
            pub fn get_status(&self, status: StatementStatus) -> i32 {
                self.stmt.get_status(status, false)
            }
            /// Reset the value of one of the status counters for this statement,
            #[inline]
            /// returning the value it had before resetting.
            pub fn reset_status(&self, status: StatementStatus) -> i32 {
                self.stmt.get_status(status, true)
            }
            /// Returns 1 if the prepared statement is an EXPLAIN statement,
            /// or 2 if the statement is an EXPLAIN QUERY PLAN,
            /// or 0 if it is an ordinary statement or a NULL pointer.
            #[inline]
            #[cfg(feature = "modern_sqlite")] // 3.28.0
            #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
            pub fn is_explain(&self) -> i32 {
                self.stmt.is_explain()
            }
            /// Returns true if the statement is read only.
            #[inline]
            pub fn readonly(&self) -> bool {
                self.stmt.readonly()
            }

            #[cfg(feature = "extra_check")]
            #[inline]
            pub fn check_no_tail(&self) -> Result<()> {
                if self.stmt.has_tail() {
                    Err(Error::MultipleStatement)
                } else {
                    Ok(())
                }
            }

            #[cfg(not(feature = "extra_check"))]
            #[inline]
            #[allow(clippy::unnecessary_wraps)]
            pub fn check_no_tail(&self) -> Result<()> {
                Ok(())
            }
            /// Safety: This is unsafe, because using `sqlite3_stmt` after the
            /// connection has closed is illegal, but `RawStatement` does not enforce
            /// this, as it loses our protective `'conn` lifetime bound.
            #[inline]
            pub unsafe fn into_raw(mut self) -> RawStatement {
                let mut stmt = RawStatement::new(ptr::null_mut(), 0);
                mem::swap(&mut stmt, &mut self.stmt);
                stmt
            }
            /// Reset all bindings
            pub fn clear_bindings(&mut self) {
                self.stmt.clear_bindings();
            }
        }

        impl fmt::Debug for Statement<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let sql = if self.stmt.is_null() {
                    Ok("")
                } else {
                    self.stmt.sql().unwrap().to_str()
                };
                f.debug_struct("Statement")
                    .field("conn", self.conn)
                    .field("stmt", &self.stmt)
                    .field("sql", &sql)
                    .finish()
            }
        }

        impl Drop for Statement<'_> {
            #[allow(unused_must_use)]
            #[inline]
            fn drop(&mut self) {
                self.finalize_();
            }
        }

        impl Statement<'_> {
            #[inline]
            pub(super) fn new(conn: &Connection, stmt: RawStatement) -> Statement<'_> {
                Statement { conn, stmt }
            }

            pub(super) fn value_ref(&self, col: usize) -> ValueRef<'_> {
                let raw = unsafe { self.stmt.ptr() };

                match self.stmt.column_type(col) {
                    ffi::SQLITE_NULL => ValueRef::Null,
                    ffi::SQLITE_INTEGER => {
                        ValueRef::Integer(unsafe { ffi::sqlite3_column_int64(raw, col as c_int) })
                    }
                    ffi::SQLITE_FLOAT => {
                        ValueRef::Real(unsafe { ffi::sqlite3_column_double(raw, col as c_int) })
                    }
                    ffi::SQLITE_TEXT => {
                        let s = unsafe {
                            // Quoting from "Using SQLite" book:
                            // To avoid problems, an application should first extract the desired type using
                            // a sqlite3_column_xxx() function, and then call the
                            // appropriate sqlite3_column_bytes() function.
                            let text = ffi::sqlite3_column_text(raw, col as c_int);
                            let len = ffi::sqlite3_column_bytes(raw, col as c_int);
                            assert!(
                                !text.is_null(),
                                "unexpected SQLITE_TEXT column type with NULL data"
                            );
                            from_raw_parts(text.cast::<u8>(), len as usize)
                        };

                        ValueRef::Text(s)
                    }
                    ffi::SQLITE_BLOB => {
                        let (blob, len) = unsafe {
                            (
                                ffi::sqlite3_column_blob(raw, col as c_int),
                                ffi::sqlite3_column_bytes(raw, col as c_int),
                            )
                        };

                        assert!(
                            len >= 0,
                            "unexpected negative return from sqlite3_column_bytes"
                        );
                        if len > 0 {
                            assert!(
                                !blob.is_null(),
                                "unexpected SQLITE_BLOB column type with NULL data"
                            );
                            ValueRef::Blob(unsafe { from_raw_parts(blob.cast::<u8>(), len as usize) })
                        } else {
                            // The return value from sqlite3_column_blob() for a zero-length BLOB
                            // is a NULL pointer.
                            ValueRef::Blob(&[])
                        }
                    }
                    _ => unreachable!("sqlite3_column_type returned invalid value"),
                }
            }

            #[inline]
            pub(super) fn step(&self) -> Result<bool> {
                match self.stmt.step() {
                    ffi::SQLITE_ROW => Ok(true),
                    ffi::SQLITE_DONE => Ok(false),
                    code => Err(self.conn.decode_result(code).unwrap_err()),
                }
            }

            #[inline]
            pub(super) fn reset(&self) -> Result<()> {
                match self.stmt.reset() {
                    ffi::SQLITE_OK => Ok(()),
                    code => Err(self.conn.decode_result(code).unwrap_err()),
                }
            }
        }
        /// Prepared statement status counters.
        ///
        /// See `https://www.sqlite.org/c3ref/c_stmtstatus_counter.html`
        /// for explanations of each.
        ///
        /// Note that depending on your version of SQLite, all of these
        /// may not be available.
        #[repr(i32)]
        #[derive(Clone, Copy, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum StatementStatus {
            /// Equivalent to SQLITE_STMTSTATUS_FULLSCAN_STEP
            FullscanStep = 1,
            /// Equivalent to SQLITE_STMTSTATUS_SORT
            Sort = 2,
            /// Equivalent to SQLITE_STMTSTATUS_AUTOINDEX
            AutoIndex = 3,
            /// Equivalent to SQLITE_STMTSTATUS_VM_STEP
            VmStep = 4,
            /// Equivalent to SQLITE_STMTSTATUS_REPREPARE (3.20.0)
            RePrepare = 5,
            /// Equivalent to SQLITE_STMTSTATUS_RUN (3.20.0)
            Run = 6,
            /// Equivalent to SQLITE_STMTSTATUS_FILTER_MISS
            FilterMiss = 7,
            /// Equivalent to SQLITE_STMTSTATUS_FILTER_HIT
            FilterHit = 8,
            /// Equivalent to SQLITE_STMTSTATUS_MEMUSED (3.20.0)
            MemUsed = 99,
        }
    }
    
    pub mod trace
    {
        //! Tracing and profiling functions. Error and warning log.
        use ::
        {
            *,
        };
        

        use std::ffi::{CStr, CString};
        use std::mem;
        use std::os::raw::{c_char, c_int, c_void};
        use std::panic::catch_unwind;
        use std::ptr;
        use std::time::Duration;

        use super::ffi;
        use crate::Connection;

        /// Set up the process-wide SQLite error logging callback.
        ///
        /// # Safety
        ///
        /// This function is marked unsafe for two reasons:
        ///
        /// * The function is not threadsafe. No other SQLite calls may be made while
        ///   `config_log` is running, and multiple threads may not call `config_log`
        ///   simultaneously.
        /// * The provided `callback` itself function has two requirements:
        ///     * It must not invoke any SQLite calls.
        ///     * It must be threadsafe if SQLite is used in a multithreaded way.
        ///
        /// cf [The Error And Warning Log](http://sqlite.org/errlog.html).
        #[cfg(not(feature = "loadable_extension"))]
        pub unsafe fn config_log(callback: Option<fn(c_int, &str)>) -> crate::Result<()> {
            extern "C" fn log_callback(p_arg: *mut c_void, err: c_int, msg: *const c_char) {
                let s = unsafe { CStr::from_ptr(msg).to_string_lossy() };
                let callback: fn(c_int, &str) = unsafe { mem::transmute(p_arg) };

                drop(catch_unwind(|| callback(err, &s)));
            }

            let rc = if let Some(f) = callback {
                ffi::sqlite3_config(
                    ffi::SQLITE_CONFIG_LOG,
                    log_callback as extern "C" fn(_, _, _),
                    f as *mut c_void,
                )
            } else {
                let nullptr: *mut c_void = ptr::null_mut();
                ffi::sqlite3_config(ffi::SQLITE_CONFIG_LOG, nullptr, nullptr)
            };

            if rc == ffi::SQLITE_OK {
                Ok(())
            } else {
                Err(crate::error::error_from_sqlite_code(rc, None))
            }
        }
        /// Write a message into the error log established by
        /// `config_log`.
        #[inline]
        pub fn log(err_code: c_int, msg: &str) {
            let msg = CString::new(msg).expect("SQLite log messages cannot contain embedded zeroes");
            unsafe {
                ffi::sqlite3_log(err_code, b"%s\0" as *const _ as *const c_char, msg.as_ptr());
            }
        }

        impl Connection {
            /// Register or clear a callback function that can be
            /// used for tracing the execution of SQL statements.
            ///
            /// Prepared statement placeholders are replaced/logged with their assigned
            /// values. There can only be a single tracer defined for each database
            /// connection. Setting a new tracer clears the old one.
            pub fn trace(&mut self, trace_fn: Option<fn(&str)>) {
                unsafe extern "C" fn trace_callback(p_arg: *mut c_void, z_sql: *const c_char) {
                    let trace_fn: fn(&str) = mem::transmute(p_arg);
                    let s = CStr::from_ptr(z_sql).to_string_lossy();
                    drop(catch_unwind(|| trace_fn(&s)));
                }

                let c = self.db.borrow_mut();
                match trace_fn {
                    Some(f) => unsafe {
                        ffi::sqlite3_trace(c.db(), Some(trace_callback), f as *mut c_void);
                    },
                    None => unsafe {
                        ffi::sqlite3_trace(c.db(), None, ptr::null_mut());
                    },
                }
            }
            /// Register or clear a callback function that can be
            /// used for profiling the execution of SQL statements.
            ///
            /// There can only be a single profiler defined for each database
            /// connection. Setting a new profiler clears the old one.
            pub fn profile(&mut self, profile_fn: Option<fn(&str, Duration)>) {
                unsafe extern "C" fn profile_callback(
                    p_arg: *mut c_void,
                    z_sql: *const c_char,
                    nanoseconds: u64,
                ) {
                    let profile_fn: fn(&str, Duration) = mem::transmute(p_arg);
                    let s = CStr::from_ptr(z_sql).to_string_lossy();
                    const NANOS_PER_SEC: u64 = 1_000_000_000;

                    let duration = Duration::new(
                        nanoseconds / NANOS_PER_SEC,
                        (nanoseconds % NANOS_PER_SEC) as u32,
                    );
                    drop(catch_unwind(|| profile_fn(&s, duration)));
                }

                let c = self.db.borrow_mut();
                match profile_fn {
                    Some(f) => unsafe {
                        ffi::sqlite3_profile(c.db(), Some(profile_callback), f as *mut c_void)
                    },
                    None => unsafe { ffi::sqlite3_profile(c.db(), None, ptr::null_mut()) },
                };
            }

            // TODO sqlite3_trace_v2 (https://sqlite.org/c3ref/trace_v2.html) // 3.14.0, #977
        }
    }

    pub mod transaction
    {
        use ::
        {
            *,
        };
        use crate::{Connection, Result};
        use std::ops::Deref;

        /// Options for transaction behavior. See [BEGIN
        /// TRANSACTION](http://www.sqlite.org/lang_transaction.html) for details.
        #[derive(Copy, Clone)]
        #[non_exhaustive]
        pub enum TransactionBehavior {
            /// DEFERRED means that the transaction does not actually start until the
            /// database is first accessed.
            Deferred,
            /// IMMEDIATE cause the database connection to start a new write
            /// immediately, without waiting for a writes statement.
            Immediate,
            /// EXCLUSIVE prevents other database connections from reading the database
            /// while the transaction is underway.
            Exclusive,
        }
        /// Options for how a Transaction or Savepoint should behave when it is dropped.
        #[derive(Copy, Clone, Debug, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum DropBehavior {
            /// Roll back the changes. This is the default.
            Rollback,

            /// Commit the changes.
            Commit,

            /// Do not commit or roll back changes - this will leave the transaction or
            /// savepoint open, so should be used with care.
            Ignore,

            /// Panic. Used to enforce intentional behavior during development.
            Panic,
        }
        /// Represents a transaction on a database connection.
        #[derive(Debug)]
        pub struct Transaction<'conn> {
            conn: &'conn Connection,
            drop_behavior: DropBehavior,
        }
        /// Represents a savepoint on a database connection.
        #[derive(Debug)]
        pub struct Savepoint<'conn> {
            conn: &'conn Connection,
            name: String,
            drop_behavior: DropBehavior,
            committed: bool,
        }

        impl Transaction<'_> {
            /// Begin a new transaction. Cannot be nested; see `savepoint` for nested
            /// transactions.
            ///
            /// Even though we don't mutate the connection, we take a `&mut Connection`
            /// to prevent nested transactions on the same connection. For cases
            /// where this is unacceptable, [`Transaction::new_unchecked`] is available.
            #[inline]
            pub fn new(conn: &mut Connection, behavior: TransactionBehavior) -> Result<Transaction<'_>> {
                Self::new_unchecked(conn, behavior)
            }
            /// Begin a new transaction, failing if a transaction is open.
            ///
            /// If a transaction is already open, this will return an error. Where
            /// possible, [`Transaction::new`] should be preferred, as it provides a
            /// compile-time guarantee that transactions are not nested.
            #[inline]
            pub fn new_unchecked(
                conn: &Connection,
                behavior: TransactionBehavior,
            ) -> Result<Transaction<'_>> {
                let query = match behavior {
                    TransactionBehavior::Deferred => "BEGIN DEFERRED",
                    TransactionBehavior::Immediate => "BEGIN IMMEDIATE",
                    TransactionBehavior::Exclusive => "BEGIN EXCLUSIVE",
                };
                conn.execute_batch(query).map(move |()| Transaction {
                    conn,
                    drop_behavior: DropBehavior::Rollback,
                })
            }
            /// Starts a new [savepoint](http://www.sqlite.org/lang_savepoint.html), allowing nested transactions.
            #[inline]
            pub fn savepoint(&mut self) -> Result<Savepoint<'_>> {
                Savepoint::new_(self.conn)
            }
            /// Create a new savepoint with a custom savepoint name. See `savepoint()`.
            #[inline]
            pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(self.conn, name)
            }
            /// Get the current setting for what happens to the transaction when it is
            /// dropped.
            #[inline]
            #[must_use]
            pub fn drop_behavior(&self) -> DropBehavior {
                self.drop_behavior
            }
            /// Configure the transaction to perform the specified action when it is
            /// dropped.
            #[inline]
            pub fn set_drop_behavior(&mut self, drop_behavior: DropBehavior) {
                self.drop_behavior = drop_behavior;
            }
            /// A convenience method which consumes and commits a transaction.
            #[inline]
            pub fn commit(mut self) -> Result<()> {
                self.commit_()
            }

            #[inline]
            fn commit_(&mut self) -> Result<()> {
                self.conn.execute_batch("COMMIT")?;
                Ok(())
            }
            /// A convenience method which consumes and rolls back a transaction.
            #[inline]
            pub fn rollback(mut self) -> Result<()> {
                self.rollback_()
            }

            #[inline]
            fn rollback_(&mut self) -> Result<()> {
                self.conn.execute_batch("ROLLBACK")?;
                Ok(())
            }
            /// Consumes the transaction, committing or rolling back according to the
            /// current setting (see `drop_behavior`).
            ///
            /// Functionally equivalent to the `Drop` implementation, but allows
            /// callers to see any errors that occur.
            #[inline]
            pub fn finish(mut self) -> Result<()> {
                self.finish_()
            }

            #[inline]
            fn finish_(&mut self) -> Result<()> {
                if self.conn.is_autocommit() {
                    return Ok(());
                }
                match self.drop_behavior() {
                    DropBehavior::Commit => self.commit_().or_else(|_| self.rollback_()),
                    DropBehavior::Rollback => self.rollback_(),
                    DropBehavior::Ignore => Ok(()),
                    DropBehavior::Panic => panic!("Transaction dropped unexpectedly."),
                }
            }
        }

        impl Deref for Transaction<'_> {
            type Target = Connection;

            #[inline]
            fn deref(&self) -> &Connection {
                self.conn
            }
        }

        #[allow(unused_must_use)]
        impl Drop for Transaction<'_> {
            #[inline]
            fn drop(&mut self) {
                self.finish_();
            }
        }

        impl Savepoint<'_> {
            #[inline]
            fn with_name_<T: Into<String>>(conn: &Connection, name: T) -> Result<Savepoint<'_>> {
                let name = name.into();
                conn.execute_batch(&format!("SAVEPOINT {name}"))
                    .map(|()| Savepoint {
                        conn,
                        name,
                        drop_behavior: DropBehavior::Rollback,
                        committed: false,
                    })
            }

            #[inline]
            fn new_(conn: &Connection) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(conn, "_rusqlite_sp")
            }
            /// Begin a new savepoint. Can be nested.
            #[inline]
            pub fn new(conn: &mut Connection) -> Result<Savepoint<'_>> {
                Savepoint::new_(conn)
            }
            /// Begin a new savepoint with a user-provided savepoint name.
            #[inline]
            pub fn with_name<T: Into<String>>(conn: &mut Connection, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(conn, name)
            }
            /// Begin a nested savepoint.
            #[inline]
            pub fn savepoint(&mut self) -> Result<Savepoint<'_>> {
                Savepoint::new_(self.conn)
            }
            /// Begin a nested savepoint with a user-provided savepoint name.
            #[inline]
            pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(self.conn, name)
            }
            /// Get the current setting for what happens to the savepoint when it is
            /// dropped.
            #[inline]
            #[must_use]
            pub fn drop_behavior(&self) -> DropBehavior {
                self.drop_behavior
            }
            /// Configure the savepoint to perform the specified action when it is
            /// dropped.
            #[inline]
            pub fn set_drop_behavior(&mut self, drop_behavior: DropBehavior) {
                self.drop_behavior = drop_behavior;
            }
            /// A convenience method which consumes and commits a savepoint.
            #[inline]
            pub fn commit(mut self) -> Result<()> {
                self.commit_()
            }

            #[inline]
            fn commit_(&mut self) -> Result<()> {
                self.conn.execute_batch(&format!("RELEASE {}", self.name))?;
                self.committed = true;
                Ok(())
            }
            /// A convenience method which rolls back a savepoint.
            ///
            /// ## Note
            ///
            /// Unlike `Transaction`s, savepoints remain active after they have been
            /// rolled back, and can be rolled back again or committed.
            #[inline]
            pub fn rollback(&mut self) -> Result<()> {
                self.conn
                    .execute_batch(&format!("ROLLBACK TO {}", self.name))
            }
            /// Consumes the savepoint, committing or rolling back according to the
            /// current setting (see `drop_behavior`).
            ///
            /// Functionally equivalent to the `Drop` implementation, but allows
            /// callers to see any errors that occur.
            #[inline]
            pub fn finish(mut self) -> Result<()> {
                self.finish_()
            }

            #[inline]
            fn finish_(&mut self) -> Result<()> {
                if self.committed {
                    return Ok(());
                }
                match self.drop_behavior() {
                    DropBehavior::Commit => self
                        .commit_()
                        .or_else(|_| self.rollback().and_then(|()| self.commit_())),
                    DropBehavior::Rollback => self.rollback().and_then(|()| self.commit_()),
                    DropBehavior::Ignore => Ok(()),
                    DropBehavior::Panic => panic!("Savepoint dropped unexpectedly."),
                }
            }
        }

        impl Deref for Savepoint<'_> {
            type Target = Connection;

            #[inline]
            fn deref(&self) -> &Connection {
                self.conn
            }
        }

        #[allow(unused_must_use)]
        impl Drop for Savepoint<'_> {
            #[inline]
            fn drop(&mut self) {
                self.finish_();
            }
        }
        /// Transaction state of a database
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[non_exhaustive]
        #[cfg(feature = "modern_sqlite")] // 3.37.0
        #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
        pub enum TransactionState {
            /// Equivalent to SQLITE_TXN_NONE
            None,
            /// Equivalent to SQLITE_TXN_READ
            Read,
            /// Equivalent to SQLITE_TXN_WRITE
            Write,
        }

        impl Connection {
            /// Begin a new transaction with the default behavior (DEFERRED).
            #[inline]
            pub fn transaction(&mut self) -> Result<Transaction<'_>> {
                Transaction::new(self, self.transaction_behavior)
            }
            /// Begin a new transaction with a specified behavior.
            #[inline]
            pub fn transaction_with_behavior(
                &mut self,
                behavior: TransactionBehavior,
            ) -> Result<Transaction<'_>> {
                Transaction::new(self, behavior)
            }
            /// Begin a new transaction with the default behavior (DEFERRED).
            pub fn unchecked_transaction(&self) -> Result<Transaction<'_>> {
                Transaction::new_unchecked(self, self.transaction_behavior)
            }
            /// Begin a new savepoint with the default behavior (DEFERRED).
            #[inline]
            pub fn savepoint(&mut self) -> Result<Savepoint<'_>> {
                Savepoint::new(self)
            }
            /// Begin a new savepoint with a specified name.
            #[inline]
            pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name(self, name)
            }
            /// Determine the transaction state of a database
            #[cfg(feature = "modern_sqlite")] // 3.37.0
            #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
            pub fn transaction_state(
                &self,
                db_name: Option<crate::DatabaseName<'_>>,
            ) -> Result<TransactionState> {
                self.db.borrow().txn_state(db_name)
            }
            /// Set the default transaction behavior for the connection.
            pub fn set_transaction_behavior(&mut self, behavior: TransactionBehavior) {
                self.transaction_behavior = behavior;
            }
        }
    }

    pub mod types
    {
        //! Traits dealing with SQLite data types.
        use ::
        {
            *,
        };
        /*
        pub use self::from_sql::{FromSql, FromSqlError, FromSqlResult};
        pub use self::to_sql::{ToSql, ToSqlOutput};
        pub use self::value::Value;
        pub use self::value_ref::ValueRef;

        use std::fmt;
        */
        pub mod chrono
        {
            //! Convert most of the [Time Strings](http://sqlite.org/lang_datefunc.html) to chrono types.
            use ::
            {
                *,
            };
            /*
            use chrono::{DateTime, FixedOffset, Local, NaiveDate, NaiveDateTime, NaiveTime, TimeZone, Utc};

            use crate::types::{FromSql, FromSqlError, FromSqlResult, ToSql, ToSqlOutput, ValueRef};
            use crate::Result;
            */
            /// ISO 8601 calendar date without timezone => "YYYY-MM-DD"
            impl ToSql for NaiveDate 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%F").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// "YYYY-MM-DD" => ISO 8601 calendar date without timezone.
            impl FromSql for NaiveDate 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value
                        .as_str()
                        .and_then(|s| match NaiveDate::parse_from_str(s, "%F") {
                            Ok(dt) => Ok(dt),
                            Err(err) => Err(FromSqlError::Other(Box::new(err))),
                        })
                }
            }
            /// ISO 8601 time without timezone => "HH:MM:SS.SSS"
            impl ToSql for NaiveTime 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%T%.f").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// "HH:MM"/"HH:MM:SS"/"HH:MM:SS.SSS" => ISO 8601 time without timezone.
            impl FromSql for NaiveTime 
            {
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        let fmt = match s.len() {
                            5 => "%H:%M",
                            8 => "%T",
                            _ => "%T%.f",
                        };
                        match NaiveTime::parse_from_str(s, fmt) {
                            Ok(dt) => Ok(dt),
                            Err(err) => Err(FromSqlError::Other(Box::new(err))),
                        }
                    })
                }
            }
            /// ISO 8601 combined date and time without timezone =>
            /// "YYYY-MM-DD HH:MM:SS.SSS"
            impl ToSql for NaiveDateTime 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%F %T%.f").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// "YYYY-MM-DD HH:MM:SS"/"YYYY-MM-DD HH:MM:SS.SSS" => ISO 8601 combined date
            /// and time without timezone. ("YYYY-MM-DDTHH:MM:SS"/"YYYY-MM-DDTHH:MM:SS.SSS"
            /// also supported)
            impl FromSql for NaiveDateTime 
            {
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        let fmt = if s.len() >= 11 && s.as_bytes()[10] == b'T' {
                            "%FT%T%.f"
                        } else {
                            "%F %T%.f"
                        };

                        match NaiveDateTime::parse_from_str(s, fmt) {
                            Ok(dt) => Ok(dt),
                            Err(err) => Err(FromSqlError::Other(Box::new(err))),
                        }
                    })
                }
            }
            /// UTC time => UTC RFC3339 timestamp
            /// ("YYYY-MM-DD HH:MM:SS.SSS+00:00").
            impl ToSql for DateTime<Utc> 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%F %T%.f%:z").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// Local time => UTC RFC3339 timestamp
            /// ("YYYY-MM-DD HH:MM:SS.SSS+00:00").
            impl ToSql for DateTime<Local> 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.with_timezone(&Utc).format("%F %T%.f%:z").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// Date and time with time zone => RFC3339 timestamp
            /// ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM").
            impl ToSql for DateTime<FixedOffset> 
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self.format("%F %T%.f%:z").to_string();
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// RFC3339 ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM") into `DateTime<Utc>`.
            impl FromSql for DateTime<Utc> 
            {
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    {
                        // Try to parse value as rfc3339 first.
                        let s = value.as_str()?;

                        let fmt = if s.len() >= 11 && s.as_bytes()[10] == b'T' {
                            "%FT%T%.f%#z"
                        } else {
                            "%F %T%.f%#z"
                        };

                        if let Ok(dt) = DateTime::parse_from_str(s, fmt) {
                            return Ok(dt.with_timezone(&Utc));
                        }
                    }

                    // Couldn't parse as rfc3339 - fall back to NaiveDateTime.
                    NaiveDateTime::column_result(value).map(|dt| Utc.from_utc_datetime(&dt))
                }
            }
            /// RFC3339 ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM") into `DateTime<Local>`.
            impl FromSql for DateTime<Local> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let utc_dt = DateTime::<Utc>::column_result(value)?;
                    Ok(utc_dt.with_timezone(&Local))
                }
            }
            /// RFC3339 ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM") into `DateTime<FixedOffset>`.
            impl FromSql for DateTime<FixedOffset> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let s = String::column_result(value)?;
                    Self::parse_from_rfc3339(s.as_str())
                        .or_else(|_| Self::parse_from_str(s.as_str(), "%F %T%.f%:z"))
                        .map_err(|e| FromSqlError::Other(Box::new(e)))
                }
            }
        }

        pub mod from_sql
        {
            use ::
            {
                *,
            };
            /*
            use super::{Value, ValueRef};
            use std::error::Error;
            use std::fmt;
            */

            /// Enum listing possible errors from [`FromSql`] trait.
            #[derive(Debug)]
            #[non_exhaustive]
            pub enum FromSqlError 
            {
                /// Error when an SQLite value is requested, but the type of the result
                /// cannot be converted to the requested Rust type.
                InvalidType,

                /// Error when the i64 value returned by SQLite cannot be stored into the
                /// requested type.
                OutOfRange(i64),

                /// Error when the blob result returned by SQLite cannot be stored into the
                /// requested type due to a size mismatch.
                InvalidBlobSize {
                    /// The expected size of the blob.
                    expected_size: usize,
                    /// The actual size of the blob that was returned.
                    blob_size: usize,
                },

                /// An error case available for implementors of the [`FromSql`] trait.
                Other(Box<dyn Error + Send + Sync + 'static>),
            }

            impl PartialEq for FromSqlError 
            {
                fn eq(&self, other: &FromSqlError) -> bool {
                    match (self, other) {
                        (FromSqlError::InvalidType, FromSqlError::InvalidType) => true,
                        (FromSqlError::OutOfRange(n1), FromSqlError::OutOfRange(n2)) => n1 == n2,
                        (
                            FromSqlError::InvalidBlobSize {
                                expected_size: es1,
                                blob_size: bs1,
                            },
                            FromSqlError::InvalidBlobSize {
                                expected_size: es2,
                                blob_size: bs2,
                            },
                        ) => es1 == es2 && bs1 == bs2,
                        (..) => false,
                    }
                }
            }

            impl fmt::Display for FromSqlError 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    match *self {
                        FromSqlError::InvalidType => write!(f, "Invalid type"),
                        FromSqlError::OutOfRange(i) => write!(f, "Value {i} out of range"),
                        FromSqlError::InvalidBlobSize {
                            expected_size,
                            blob_size,
                        } => {
                            write!(
                                f,
                                "Cannot read {expected_size} byte value out of {blob_size} byte blob"
                            )
                        }
                        FromSqlError::Other(ref err) => err.fmt(f),
                    }
                }
            }

            impl Error for FromSqlError 
            {
                fn source(&self) -> Option<&(dyn Error + 'static)> {
                    if let FromSqlError::Other(ref err) = self {
                        Some(&**err)
                    } else {
                        None
                    }
                }
            }
            /// Result type for implementors of the [`FromSql`] trait.
            pub type FromSqlResult<T> = Result<T, FromSqlError>;

            /// A trait for types that can be created from a SQLite value.
            pub trait FromSql: Sized 
            {
                /// Converts SQLite value into Rust value.
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self>;
            }

            macro_rules! from_sql_integral(
                ($t:ident) => (
                    impl FromSql for $t {
                        #[inline]
                        fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                            let i = i64::column_result(value)?;
                            i.try_into().map_err(|_| FromSqlError::OutOfRange(i))
                        }
                    }
                );
                (non_zero $nz:ty, $z:ty) => (
                    impl FromSql for $nz {
                        #[inline]
                        fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                            let i = <$z>::column_result(value)?;
                            <$nz>::new(i).ok_or(FromSqlError::OutOfRange(0))
                        }
                    }
                )
            );

            from_sql_integral!(i8);
            from_sql_integral!(i16);
            from_sql_integral!(i32);
            
            from_sql_integral!(isize);
            from_sql_integral!(u8);
            from_sql_integral!(u16);
            from_sql_integral!(u32);
            from_sql_integral!(u64);
            from_sql_integral!(usize);

            from_sql_integral!(non_zero std::num::NonZeroIsize, isize);
            from_sql_integral!(non_zero std::num::NonZeroI8, i8);
            from_sql_integral!(non_zero std::num::NonZeroI16, i16);
            from_sql_integral!(non_zero std::num::NonZeroI32, i32);
            from_sql_integral!(non_zero std::num::NonZeroI64, i64);

            from_sql_integral!(non_zero std::num::NonZeroUsize, usize);
            from_sql_integral!(non_zero std::num::NonZeroU8, u8);
            from_sql_integral!(non_zero std::num::NonZeroU16, u16);
            from_sql_integral!(non_zero std::num::NonZeroU32, u32);
            from_sql_integral!(non_zero std::num::NonZeroU64, u64);

            impl FromSql for i64 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_i64()
                }
            }

            impl FromSql for f32 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Integer(i) => Ok(i as f32),
                        ValueRef::Real(f) => Ok(f as f32),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }

            impl FromSql for f64 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Integer(i) => Ok(i as f64),
                        ValueRef::Real(f) => Ok(f),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }

            impl FromSql for bool 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    i64::column_result(value).map(|i| i != 0)
                }
            }

            impl FromSql for String 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(ToString::to_string)
                }
            }

            impl FromSql for Box<str> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(Into::into)
                }
            }

            impl FromSql for std::rc::Rc<str> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(Into::into)
                }
            }

            impl FromSql for std::sync::Arc<str> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(Into::into)
                }
            }

            impl FromSql for Vec<u8> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_blob().map(<[u8]>::to_vec)
                }
            }

            impl<const N: usize> FromSql for [u8; N] 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let slice = value.as_blob()?;
                    slice.try_into().map_err(|_| FromSqlError::InvalidBlobSize {
                        expected_size: N,
                        blob_size: slice.len(),
                    })
                }
            }

            #[cfg(feature = "uuid")]
            impl FromSql for uuid::Uuid 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let bytes = <[u8; 16]>::column_result(value)?;
                    Ok(uuid::Uuid::from_u128(u128::from_be_bytes(bytes)))
                }
            }

            impl<T: FromSql> FromSql for Option<T> 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Null => Ok(None),
                        _ => FromSql::column_result(value).map(Some),
                    }
                }
            }

            impl FromSql for Value 
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    Ok(value.into())
                }
            }
        }
        
        pub mod time
        {
            //! Convert formats 1-10 in [Time Values](https://sqlite.org/lang_datefunc.html#time_values) to time types.
            use ::
            {
                *,
            };
            
            use crate::types::{FromSql, FromSqlError, FromSqlResult, ToSql, ToSqlOutput, ValueRef};
            use crate::{Error, Result};
            use time::format_description::FormatItem;
            use time::macros::format_description;
            use time::{Date, OffsetDateTime, PrimitiveDateTime, Time};

            const OFFSET_DATE_TIME_ENCODING: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day] [hour]:[minute]:[second].[subsecond][offset_hour sign:mandatory]:[offset_minute]"
            );
            const PRIMITIVE_DATE_TIME_ENCODING: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day] [hour]:[minute]:[second].[subsecond]"
            );
            const TIME_ENCODING: &[FormatItem<'_>] =
                format_description!(version = 2, "[hour]:[minute]:[second].[subsecond]");

            const DATE_FORMAT: &[FormatItem<'_>] = format_description!(version = 2, "[year]-[month]-[day]");
            const TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[hour]:[minute][optional [:[second][optional [.[subsecond]]]]]"
            );
            const PRIMITIVE_DATE_TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day][first [ ][T]][hour]:[minute][optional [:[second][optional [.[subsecond]]]]]"
            );
            const UTC_DATE_TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day][first [ ][T]][hour]:[minute][optional [:[second][optional [.[subsecond]]]]][optional [Z]]"
            );
            const OFFSET_DATE_TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day][first [ ][T]][hour]:[minute][optional [:[second][optional [.[subsecond]]]]][offset_hour sign:mandatory]:[offset_minute]"
            );
            const LEGACY_DATE_TIME_FORMAT: &[FormatItem<'_>] = format_description!(
                version = 2,
                "[year]-[month]-[day] [hour]:[minute]:[second]:[subsecond] [offset_hour sign:mandatory]:[offset_minute]"
            );

            /// OffsetDatetime => RFC3339 format ("YYYY-MM-DD HH:MM:SS.SSS[+-]HH:MM")
            impl ToSql for OffsetDateTime {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let time_string = self
                        .format(&OFFSET_DATE_TIME_ENCODING)
                        .map_err(|err| Error::ToSqlConversionFailure(err.into()))?;
                    Ok(ToSqlOutput::from(time_string))
                }
            }

            // Supports parsing formats 2-7 from https://www.sqlite.org/lang_datefunc.html
            // Formats 2-7 without a timezone assumes UTC
            impl FromSql for OffsetDateTime {
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        if let Some(b' ') = s.as_bytes().get(23) {
                            // legacy
                            return OffsetDateTime::parse(s, &LEGACY_DATE_TIME_FORMAT)
                                .map_err(|err| FromSqlError::Other(Box::new(err)));
                        }
                        if s[8..].contains('+') || s[8..].contains('-') {
                            // Formats 2-7 with timezone
                            return OffsetDateTime::parse(s, &OFFSET_DATE_TIME_FORMAT)
                                .map_err(|err| FromSqlError::Other(Box::new(err)));
                        }
                        // Formats 2-7 without timezone
                        PrimitiveDateTime::parse(s, &UTC_DATE_TIME_FORMAT)
                            .map(|p| p.assume_utc())
                            .map_err(|err| FromSqlError::Other(Box::new(err)))
                    })
                }
            }
            /// ISO 8601 calendar date without timezone => "YYYY-MM-DD"
            impl ToSql for Date {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_str = self
                        .format(&DATE_FORMAT)
                        .map_err(|err| Error::ToSqlConversionFailure(err.into()))?;
                    Ok(ToSqlOutput::from(date_str))
                }
            }
            /// "YYYY-MM-DD" => ISO 8601 calendar date without timezone.
            impl FromSql for Date {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        Date::parse(s, &DATE_FORMAT).map_err(|err| FromSqlError::Other(err.into()))
                    })
                }
            }
            /// ISO 8601 time without timezone => "HH:MM:SS.SSS"
            impl ToSql for Time {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let time_str = self
                        .format(&TIME_ENCODING)
                        .map_err(|err| Error::ToSqlConversionFailure(err.into()))?;
                    Ok(ToSqlOutput::from(time_str))
                }
            }
            /// "HH:MM"/"HH:MM:SS"/"HH:MM:SS.SSS" => ISO 8601 time without timezone.
            impl FromSql for Time {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        Time::parse(s, &TIME_FORMAT).map_err(|err| FromSqlError::Other(err.into()))
                    })
                }
            }
            /// ISO 8601 combined date and time without timezone => "YYYY-MM-DD HH:MM:SS.SSS"
            impl ToSql for PrimitiveDateTime {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    let date_time_str = self
                        .format(&PRIMITIVE_DATE_TIME_ENCODING)
                        .map_err(|err| Error::ToSqlConversionFailure(err.into()))?;
                    Ok(ToSqlOutput::from(date_time_str))
                }
            }
            /// YYYY-MM-DD HH:MM
            /// YYYY-MM-DDTHH:MM
            /// YYYY-MM-DD HH:MM:SS
            /// YYYY-MM-DDTHH:MM:SS
            /// YYYY-MM-DD HH:MM:SS.SSS
            /// YYYY-MM-DDTHH:MM:SS.SSS
            /// => ISO 8601 combined date and time with timezone
            impl FromSql for PrimitiveDateTime {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().and_then(|s| {
                        PrimitiveDateTime::parse(s, &PRIMITIVE_DATE_TIME_FORMAT)
                            .map_err(|err| FromSqlError::Other(err.into()))
                    })
                }
            }
        }
        
        pub mod to_sql
        {
            use ::
            {
                *,
            };
            use super::{Null, Value, ValueRef};
            #[cfg(feature = "array")]
            use crate::vtab::array::Array;
            use crate::{Error, Result};
            use std::borrow::Cow;

            /// `ToSqlOutput` represents the possible output types for implementers of the
            /// [`ToSql`] trait.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ToSqlOutput<'a> {
                /// A borrowed SQLite-representable value.
                Borrowed(ValueRef<'a>),

                /// An owned SQLite-representable value.
                Owned(Value),

                /// A BLOB of the given length that is filled with
                /// zeroes.
                #[cfg(feature = "blob")]
                #[cfg_attr(docsrs, doc(cfg(feature = "blob")))]
                ZeroBlob(i32),

                /// n-th arg of an SQL scalar function
                #[cfg(feature = "functions")]
                #[cfg_attr(docsrs, doc(cfg(feature = "functions")))]
                Arg(usize),

                /// `feature = "array"`
                #[cfg(feature = "array")]
                #[cfg_attr(docsrs, doc(cfg(feature = "array")))]
                Array(Array),
            }

            // Generically allow any type that can be converted into a ValueRef
            // to be converted into a ToSqlOutput as well.
            impl<'a, T: ?Sized> From<&'a T> for ToSqlOutput<'a>
            where
                &'a T: Into<ValueRef<'a>>,
            {
                #[inline]
                fn from(t: &'a T) -> Self {
                    ToSqlOutput::Borrowed(t.into())
                }
            }

            // We cannot also generically allow any type that can be converted
            // into a Value to be converted into a ToSqlOutput because of
            // coherence rules (https://github.com/rust-lang/rust/pull/46192),
            // so we'll manually implement it for all the types we know can
            // be converted into Values.
            macro_rules! from_value(
                ($t:ty) => (
                    impl From<$t> for ToSqlOutput<'_> {
                        #[inline]
                        fn from(t: $t) -> Self { ToSqlOutput::Owned(t.into())}
                    }
                );
                (non_zero $t:ty) => (
                    impl From<$t> for ToSqlOutput<'_> {
                        #[inline]
                        fn from(t: $t) -> Self { ToSqlOutput::Owned(t.get().into())}
                    }
                )
            );
            from_value!(String);
            from_value!(Null);
            from_value!(bool);
            from_value!(i8);
            from_value!(i16);
            from_value!(i32);
            from_value!(i64);
            from_value!(isize);
            from_value!(u8);
            from_value!(u16);
            from_value!(u32);
            from_value!(f32);
            from_value!(f64);
            from_value!(Vec<u8>);

            from_value!(non_zero std::num::NonZeroI8);
            from_value!(non_zero std::num::NonZeroI16);
            from_value!(non_zero std::num::NonZeroI32);
            from_value!(non_zero std::num::NonZeroI64);
            from_value!(non_zero std::num::NonZeroIsize);
            from_value!(non_zero std::num::NonZeroU8);
            from_value!(non_zero std::num::NonZeroU16);
            from_value!(non_zero std::num::NonZeroU32);

            // It would be nice if we could avoid the heap allocation (of the `Vec`) that
            // `i128` needs in `Into<Value>`, but it's probably fine for the moment, and not
            // worth adding another case to Value.
            #[cfg(feature = "i128_blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "i128_blob")))]
            from_value!(i128);

            #[cfg(feature = "i128_blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "i128_blob")))]
            from_value!(non_zero std::num::NonZeroI128);

            #[cfg(feature = "uuid")]
            #[cfg_attr(docsrs, doc(cfg(feature = "uuid")))]
            from_value!(uuid::Uuid);

            impl ToSql for ToSqlOutput<'_> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(match *self {
                        ToSqlOutput::Borrowed(v) => ToSqlOutput::Borrowed(v),
                        ToSqlOutput::Owned(ref v) => ToSqlOutput::Borrowed(ValueRef::from(v)),

                        #[cfg(feature = "blob")]
                        ToSqlOutput::ZeroBlob(i) => ToSqlOutput::ZeroBlob(i),
                        #[cfg(feature = "functions")]
                        ToSqlOutput::Arg(i) => ToSqlOutput::Arg(i),
                        #[cfg(feature = "array")]
                        ToSqlOutput::Array(ref a) => ToSqlOutput::Array(a.clone()),
                    })
                }
            }
            /// A trait for types that can be converted into SQLite values. Returns
            /// [`Error::ToSqlConversionFailure`] if the conversion fails.
            pub trait ToSql {
                /// Converts Rust value to SQLite value
                fn to_sql(&self) -> Result<ToSqlOutput<'_>>;
            }

            impl<T: ToSql + ToOwned + ?Sized> ToSql for Cow<'_, T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            impl<T: ToSql + ?Sized> ToSql for Box<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            impl<T: ToSql + ?Sized> ToSql for std::rc::Rc<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            impl<T: ToSql + ?Sized> ToSql for std::sync::Arc<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            // We should be able to use a generic impl like this:
            //
            // impl<T: Copy> ToSql for T where T: Into<Value> {
            //     fn to_sql(&self) -> Result<ToSqlOutput> {
            //         Ok(ToSqlOutput::from((*self).into()))
            //     }
            // }
            //
            // instead of the following macro, but this runs afoul of
            // https://github.com/rust-lang/rust/issues/30191 and reports conflicting
            // implementations even when there aren't any.

            macro_rules! to_sql_self(
                ($t:ty) => (
                    impl ToSql for $t {
                        #[inline]
                        fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                            Ok(ToSqlOutput::from(*self))
                        }
                    }
                )
            );

            to_sql_self!(Null);
            to_sql_self!(bool);
            to_sql_self!(i8);
            to_sql_self!(i16);
            to_sql_self!(i32);
            to_sql_self!(i64);
            to_sql_self!(isize);
            to_sql_self!(u8);
            to_sql_self!(u16);
            to_sql_self!(u32);
            to_sql_self!(f32);
            to_sql_self!(f64);

            to_sql_self!(std::num::NonZeroI8);
            to_sql_self!(std::num::NonZeroI16);
            to_sql_self!(std::num::NonZeroI32);
            to_sql_self!(std::num::NonZeroI64);
            to_sql_self!(std::num::NonZeroIsize);
            to_sql_self!(std::num::NonZeroU8);
            to_sql_self!(std::num::NonZeroU16);
            to_sql_self!(std::num::NonZeroU32);

            #[cfg(feature = "i128_blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "i128_blob")))]
            to_sql_self!(i128);

            #[cfg(feature = "i128_blob")]
            #[cfg_attr(docsrs, doc(cfg(feature = "i128_blob")))]
            to_sql_self!(std::num::NonZeroI128);

            #[cfg(feature = "uuid")]
            #[cfg_attr(docsrs, doc(cfg(feature = "uuid")))]
            to_sql_self!(uuid::Uuid);

            macro_rules! to_sql_self_fallible(
                ($t:ty) => (
                    impl ToSql for $t {
                        #[inline]
                        fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                            Ok(ToSqlOutput::Owned(Value::Integer(
                                i64::try_from(*self).map_err(
                                    // TODO: Include the values in the error message.
                                    |err| Error::ToSqlConversionFailure(err.into())
                                )?
                            )))
                        }
                    }
                );
                (non_zero $t:ty) => (
                    impl ToSql for $t {
                        #[inline]
                        fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                            Ok(ToSqlOutput::Owned(Value::Integer(
                                i64::try_from(self.get()).map_err(
                                    // TODO: Include the values in the error message.
                                    |err| Error::ToSqlConversionFailure(err.into())
                                )?
                            )))
                        }
                    }
                )
            );

            // Special implementations for usize and u64 because these conversions can fail.
            to_sql_self_fallible!(u64);
            to_sql_self_fallible!(usize);
            to_sql_self_fallible!(non_zero std::num::NonZeroU64);
            to_sql_self_fallible!(non_zero std::num::NonZeroUsize);

            impl<T: ?Sized> ToSql for &'_ T
            where
                T: ToSql,
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    (*self).to_sql()
                }
            }

            impl ToSql for String {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self.as_str()))
                }
            }

            impl ToSql for str {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self))
                }
            }

            impl ToSql for Vec<u8> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self.as_slice()))
                }
            }

            impl<const N: usize> ToSql for [u8; N] {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(&self[..]))
                }
            }

            impl ToSql for [u8] {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self))
                }
            }

            impl ToSql for Value {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self))
                }
            }

            impl<T: ToSql> ToSql for Option<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    match *self {
                        None => Ok(ToSqlOutput::from(Null)),
                        Some(ref t) => t.to_sql(),
                    }
                }
            }
        }
        
        pub mod url
        {
            //! [`ToSql`] and [`FromSql`] implementation for [`url::Url`].
            use ::
            {
                *,
            };
            
            use crate::types::{FromSql, FromSqlError, FromSqlResult, ToSql, ToSqlOutput, ValueRef};
            use crate::Result;
            use url::Url;

            /// Serialize `Url` to text.
            impl ToSql for Url {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self.as_str()))
                }
            }
            /// Deserialize text to `Url`.
            impl FromSql for Url {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Text(s) => {
                            let s = std::str::from_utf8(s).map_err(|e| FromSqlError::Other(Box::new(e)))?;
                            Url::parse(s).map_err(|e| FromSqlError::Other(Box::new(e)))
                        }
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }
        }
        
        pub mod value
        {
            use ::
            {
                *,
            };
            use super::{Null, Type};

            /// Owning [dynamic type value](http://sqlite.org/datatype3.html). Value's type is typically
            /// dictated by SQLite (not by the caller).
            ///
            /// See [`ValueRef`](crate::types::ValueRef) for a non-owning dynamic type
            /// value.
            #[derive(Clone, Debug, PartialEq)]
            pub enum Value {
                /// The value is a `NULL` value.
                Null,
                /// The value is a signed integer.
                Integer(i64),
                /// The value is a floating point number.
                Real(f64),
                /// The value is a text string.
                Text(String),
                /// The value is a blob of data
                Blob(Vec<u8>),
            }

            impl From<Null> for Value {
                #[inline]
                fn from(_: Null) -> Value {
                    Value::Null
                }
            }

            impl From<bool> for Value {
                #[inline]
                fn from(i: bool) -> Value {
                    Value::Integer(i as i64)
                }
            }

            impl From<isize> for Value {
                #[inline]
                fn from(i: isize) -> Value {
                    Value::Integer(i as i64)
                }
            }
            
            impl From<uuid::Uuid> for Value {
                #[inline]
                fn from(id: uuid::Uuid) -> Value {
                    Value::Blob(id.as_bytes().to_vec())
                }
            }

            macro_rules! from_i64(
                ($t:ty) => (
                    impl From<$t> for Value {
                        #[inline]
                        fn from(i: $t) -> Value {
                            Value::Integer(i64::from(i))
                        }
                    }
                )
            );

            from_i64!(i8);
            from_i64!(i16);
            from_i64!(i32);
            from_i64!(u8);
            from_i64!(u16);
            from_i64!(u32);

            impl From<i64> for Value {
                #[inline]
                fn from(i: i64) -> Value {
                    Value::Integer(i)
                }
            }

            impl From<f32> for Value {
                #[inline]
                fn from(f: f32) -> Value {
                    Value::Real(f.into())
                }
            }

            impl From<f64> for Value {
                #[inline]
                fn from(f: f64) -> Value {
                    Value::Real(f)
                }
            }

            impl From<String> for Value {
                #[inline]
                fn from(s: String) -> Value {
                    Value::Text(s)
                }
            }

            impl From<Vec<u8>> for Value {
                #[inline]
                fn from(v: Vec<u8>) -> Value {
                    Value::Blob(v)
                }
            }

            impl<T> From<Option<T>> for Value
            where
                T: Into<Value>,
            {
                #[inline]
                fn from(v: Option<T>) -> Value {
                    match v {
                        Some(x) => x.into(),
                        None => Value::Null,
                    }
                }
            }

            impl Value {
                /// Returns SQLite fundamental datatype.
                #[inline]
                #[must_use]
                pub fn data_type(&self) -> Type {
                    match *self {
                        Value::Null => Type::Null,
                        Value::Integer(_) => Type::Integer,
                        Value::Real(_) => Type::Real,
                        Value::Text(_) => Type::Text,
                        Value::Blob(_) => Type::Blob,
                    }
                }
            }
        }
        
        pub mod value_ref
        {
            use ::
            {
                *,
            };
            use super::{Type, Value};
            use crate::types::{FromSqlError, FromSqlResult};

            /// A non-owning [dynamic type value](http://sqlite.org/datatype3.html). Typically, the
            /// memory backing this value is owned by SQLite.
            ///
            /// See [`Value`](Value) for an owning dynamic type value.
            #[derive(Copy, Clone, Debug, PartialEq)]
            pub enum ValueRef<'a> {
                /// The value is a `NULL` value.
                Null,
                /// The value is a signed integer.
                Integer(i64),
                /// The value is a floating point number.
                Real(f64),
                /// The value is a text string.
                Text(&'a [u8]),
                /// The value is a blob of data
                Blob(&'a [u8]),
            }

            impl ValueRef<'_> {
                /// Returns SQLite fundamental datatype.
                #[inline]
                #[must_use]
                pub fn data_type(&self) -> Type {
                    match *self {
                        ValueRef::Null => Type::Null,
                        ValueRef::Integer(_) => Type::Integer,
                        ValueRef::Real(_) => Type::Real,
                        ValueRef::Text(_) => Type::Text,
                        ValueRef::Blob(_) => Type::Blob,
                    }
                }
            }

            impl<'a> ValueRef<'a> {
                /// If `self` is case `Integer`, returns the integral value. Otherwise,
                /// returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_i64(&self) -> FromSqlResult<i64> {
                    match *self {
                        ValueRef::Integer(i) => Ok(i),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is case `Integer`, returns the integral value.
                /// Otherwise, returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_i64_or_null(&self) -> FromSqlResult<Option<i64>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Integer(i) => Ok(Some(i)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Real`, returns the floating point value. Otherwise,
                /// returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_f64(&self) -> FromSqlResult<f64> {
                    match *self {
                        ValueRef::Real(f) => Ok(f),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is case `Real`, returns the floating point value.
                /// Otherwise, returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_f64_or_null(&self) -> FromSqlResult<Option<f64>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Real(f) => Ok(Some(f)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Text`, returns the string value. Otherwise, returns
                /// [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_str(&self) -> FromSqlResult<&'a str> {
                    match *self {
                        ValueRef::Text(t) => {
                            std::str::from_utf8(t).map_err(|e| FromSqlError::Other(Box::new(e)))
                        }
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is case `Text`, returns the string value.
                /// Otherwise, returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_str_or_null(&self) -> FromSqlResult<Option<&'a str>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Text(t) => std::str::from_utf8(t)
                            .map_err(|e| FromSqlError::Other(Box::new(e)))
                            .map(Some),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Blob`, returns the byte slice. Otherwise, returns
                /// [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_blob(&self) -> FromSqlResult<&'a [u8]> {
                    match *self {
                        ValueRef::Blob(b) => Ok(b),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is case `Blob`, returns the byte slice.
                /// Otherwise, returns [`Err(Error::InvalidColumnType)`](crate::Error::InvalidColumnType).
                #[inline]
                pub fn as_blob_or_null(&self) -> FromSqlResult<Option<&'a [u8]>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Blob(b) => Ok(Some(b)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// Returns the byte slice that makes up this `ValueRef` if it's either
                /// [`ValueRef::Blob`] or [`ValueRef::Text`].
                #[inline]
                pub fn as_bytes(&self) -> FromSqlResult<&'a [u8]> {
                    match self {
                        ValueRef::Text(s) | ValueRef::Blob(s) => Ok(s),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
                /// If `self` is case `Null` returns None.
                /// If `self` is [`ValueRef::Blob`] or [`ValueRef::Text`] returns the byte
                /// slice that makes up this value
                #[inline]
                pub fn as_bytes_or_null(&self) -> FromSqlResult<Option<&'a [u8]>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Text(s) | ValueRef::Blob(s) => Ok(Some(s)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }

            impl From<ValueRef<'_>> for Value {
                #[inline]
                #[track_caller]
                fn from(borrowed: ValueRef<'_>) -> Value {
                    match borrowed {
                        ValueRef::Null => Value::Null,
                        ValueRef::Integer(i) => Value::Integer(i),
                        ValueRef::Real(r) => Value::Real(r),
                        ValueRef::Text(s) => {
                            let s = std::str::from_utf8(s).expect("invalid UTF-8");
                            Value::Text(s.to_string())
                        }
                        ValueRef::Blob(b) => Value::Blob(b.to_vec()),
                    }
                }
            }

            impl<'a> From<&'a str> for ValueRef<'a> {
                #[inline]
                fn from(s: &str) -> ValueRef<'_> {
                    ValueRef::Text(s.as_bytes())
                }
            }

            impl<'a> From<&'a [u8]> for ValueRef<'a> {
                #[inline]
                fn from(s: &[u8]) -> ValueRef<'_> {
                    ValueRef::Blob(s)
                }
            }

            impl<'a> From<&'a Value> for ValueRef<'a> {
                #[inline]
                fn from(value: &'a Value) -> ValueRef<'a> {
                    match *value {
                        Value::Null => ValueRef::Null,
                        Value::Integer(i) => ValueRef::Integer(i),
                        Value::Real(r) => ValueRef::Real(r),
                        Value::Text(ref s) => ValueRef::Text(s.as_bytes()),
                        Value::Blob(ref b) => ValueRef::Blob(b),
                    }
                }
            }

            impl<'a, T> From<Option<T>> for ValueRef<'a>
            where
                T: Into<ValueRef<'a>>,
            {
                #[inline]
                fn from(s: Option<T>) -> ValueRef<'a> {
                    match s {
                        Some(x) => x.into(),
                        None => ValueRef::Null,
                    }
                }
            }

            #[cfg(any(
                feature = "functions",
                feature = "session",
                feature = "vtab",
                feature = "preupdate_hook"
            ))]
            impl<'a> ValueRef<'a> {
                pub unsafe fn from_value(value: *mut crate::ffi::sqlite3_value) -> ValueRef<'a> {
                    use crate::ffi;
                    use std::slice::from_raw_parts;

                    match ffi::sqlite3_value_type(value) {
                        ffi::SQLITE_NULL => ValueRef::Null,
                        ffi::SQLITE_INTEGER => ValueRef::Integer(ffi::sqlite3_value_int64(value)),
                        ffi::SQLITE_FLOAT => ValueRef::Real(ffi::sqlite3_value_double(value)),
                        ffi::SQLITE_TEXT => {
                            let text = ffi::sqlite3_value_text(value);
                            let len = ffi::sqlite3_value_bytes(value);
                            assert!(
                                !text.is_null(),
                                "unexpected SQLITE_TEXT value type with NULL data"
                            );
                            let s = from_raw_parts(text.cast::<u8>(), len as usize);
                            ValueRef::Text(s)
                        }
                        ffi::SQLITE_BLOB => {
                            let (blob, len) = (
                                ffi::sqlite3_value_blob(value),
                                ffi::sqlite3_value_bytes(value),
                            );

                            assert!(
                                len >= 0,
                                "unexpected negative return from sqlite3_value_bytes"
                            );
                            if len > 0 {
                                assert!(
                                    !blob.is_null(),
                                    "unexpected SQLITE_BLOB value type with NULL data"
                                );
                                ValueRef::Blob(from_raw_parts(blob.cast::<u8>(), len as usize))
                            } else {
                                // The return value from sqlite3_value_blob() for a zero-length BLOB
                                // is a NULL pointer.
                                ValueRef::Blob(&[])
                            }
                        }
                        _ => unreachable!("sqlite3_value_type returned invalid value"),
                    }
                }

                // TODO sqlite3_value_nochange // 3.22.0 & VTab xUpdate
                // TODO sqlite3_value_frombind // 3.28.0
            }
        }
        /// Empty struct that can be used to fill in a query parameter as `NULL`.
        #[derive(Copy, Clone)]
        pub struct Null;
        /// SQLite data types.
        #[derive(Copy, Clone, Debug, PartialEq, Eq)]
        pub enum Type 
        {
            /// NULL
            Null,
            /// 64-bit signed integer
            Integer,
            /// 64-bit IEEE floating point number
            Real,
            /// String
            Text,
            /// BLOB
            Blob,
        }

        impl fmt::Display for Type 
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match *self {
                    Type::Null => f.pad("Null"),
                    Type::Integer => f.pad("Integer"),
                    Type::Real => f.pad("Real"),
                    Type::Text => f.pad("Text"),
                    Type::Blob => f.pad("Blob"),
                }
            }
        }
    }
    
    mod unlock_notify
    {
        //! [Unlock Notification](http://sqlite.org/unlock_notify.html)
        use ::
        {
            *,
        };
        

        use std::os::raw::c_int;
        use std::os::raw::c_void;
        use std::panic::catch_unwind;
        use std::sync::{Condvar, Mutex};

        use crate::ffi;

        struct UnlockNotification {
            cond: Condvar,      // Condition variable to wait on
            mutex: Mutex<bool>, // Mutex to protect structure
        }

        #[allow(clippy::mutex_atomic)]
        impl UnlockNotification {
            fn new() -> UnlockNotification {
                UnlockNotification {
                    cond: Condvar::new(),
                    mutex: Mutex::new(false),
                }
            }

            fn fired(&self) {
                let mut flag = unpoison(self.mutex.lock());
                *flag = true;
                self.cond.notify_one();
            }

            fn wait(&self) {
                let mut fired = unpoison(self.mutex.lock());
                while !*fired {
                    fired = unpoison(self.cond.wait(fired));
                }
            }
        }

        #[inline]
        fn unpoison<T>(r: Result<T, std::sync::PoisonError<T>>) -> T {
            r.unwrap_or_else(std::sync::PoisonError::into_inner)
        }
        /// This function is an unlock-notify callback
        unsafe extern "C" fn unlock_notify_cb(ap_arg: *mut *mut c_void, n_arg: c_int) {
            use std::slice::from_raw_parts;
            let args = from_raw_parts(ap_arg as *const &UnlockNotification, n_arg as usize);
            for un in args {
                drop(catch_unwind(std::panic::AssertUnwindSafe(|| un.fired())));
            }
        }

        pub unsafe fn is_locked(db: *mut ffi::sqlite3, rc: c_int) -> bool {
            rc == ffi::SQLITE_LOCKED_SHAREDCACHE
                || (rc & 0xFF) == ffi::SQLITE_LOCKED
                    && ffi::sqlite3_extended_errcode(db) == ffi::SQLITE_LOCKED_SHAREDCACHE
        }
        /// This function assumes that an SQLite API call (either `sqlite3_prepare_v2()`
        /// or `sqlite3_step()`) has just returned `SQLITE_LOCKED`. The argument is the
        /// associated database connection.
        ///
        /// This function calls `sqlite3_unlock_notify()` to register for an
        /// unlock-notify callback, then blocks until that callback is delivered
        /// and returns `SQLITE_OK`. The caller should then retry the failed operation.
        ///
        /// Or, if `sqlite3_unlock_notify()` indicates that to block would deadlock
        /// the system, then this function returns `SQLITE_LOCKED` immediately. In
        /// this case the caller should not retry the operation and should roll
        /// back the current transaction (if any).
        #[cfg(feature = "unlock_notify")]
        pub unsafe fn wait_for_unlock_notify(db: *mut ffi::sqlite3) -> c_int {
            let un = UnlockNotification::new();
            /* Register for an unlock-notify callback. */
            let rc = ffi::sqlite3_unlock_notify(
                db,
                Some(unlock_notify_cb),
                &un as *const UnlockNotification as *mut c_void,
            );
            debug_assert!(
                rc == ffi::SQLITE_LOCKED || rc == ffi::SQLITE_LOCKED_SHAREDCACHE || rc == ffi::SQLITE_OK
            );
            if rc == ffi::SQLITE_OK {
                un.wait();
            }
            rc
        }
    }

    mod version
    {
        use ::
        {
            *,
        };
        use crate::ffi;
        use std::ffi::CStr;

        /// Returns the SQLite version as an integer; e.g., `3016002` for version
        /// 3.16.2.
        ///
        /// See [`sqlite3_libversion_number()`](https://www.sqlite.org/c3ref/libversion.html).
        #[inline]
        #[must_use]
        pub fn version_number() -> i32 {
            unsafe { ffi::sqlite3_libversion_number() }
        }
        /// Returns the SQLite version as a string; e.g., `"3.16.2"` for version 3.16.2.
        ///
        /// See [`sqlite3_libversion()`](https://www.sqlite.org/c3ref/libversion.html).
        ///
        /// # Panics
        ///
        /// Panics when version is not valid UTF-8.
        #[inline]
        #[must_use]
        pub fn version() -> &'static str {
            let cstr = unsafe { CStr::from_ptr(ffi::sqlite3_libversion()) };
            cstr.to_str()
                .expect("SQLite version string is not valid UTF8 ?!")
        }
    }
    
    pub mod vtab
    {
        //! Create virtual tables.
        use ::
        {
            *,
        };
        /*
        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::marker::PhantomData;
        use std::os::raw::{c_char, c_int, c_void};
        use std::ptr;
        use std::slice;

        use crate::context::set_result;
        use crate::error::{error_from_sqlite_code, to_sqlite_error};
        use crate::ffi;
        pub use crate::ffi::{sqlite3_vtab, sqlite3_vtab_cursor};
        use crate::types::{FromSql, FromSqlError, ToSql, ValueRef};
        use crate::util::alloc;
        use crate::{str_to_cstring, Connection, Error, InnerConnection, Result};
        */

        // let conn: Connection = ...;
        // let mod: Module = ...; // VTab builder
        // conn.create_module("module", mod);
        //
        // conn.execute("CREATE VIRTUAL TABLE foo USING module(...)");
        // \-> Module::xcreate
        //  |-> let vtab: VTab = ...; // on the heap
        //  \-> conn.declare_vtab("CREATE TABLE foo (...)");
        // conn = Connection::open(...);
        // \-> Module::xconnect
        //  |-> let vtab: VTab = ...; // on the heap
        //  \-> conn.declare_vtab("CREATE TABLE foo (...)");
        //
        // conn.close();
        // \-> vtab.xdisconnect
        // conn.execute("DROP TABLE foo");
        // \-> vtab.xDestroy
        //
        // let stmt = conn.prepare("SELECT ... FROM foo WHERE ...");
        // \-> vtab.xbestindex
        // stmt.query().next();
        // \-> vtab.xopen
        //  |-> let cursor: VTabCursor = ...; // on the heap
        //  |-> cursor.xfilter or xnext
        //  |-> cursor.xeof
        //  \-> if not eof { cursor.column or xrowid } else { cursor.xclose }
        //

        // db: *mut ffi::sqlite3 => VTabConnection
        // module: *const ffi::sqlite3_module => Module
        // aux: *mut c_void => Module::Aux
        // ffi::sqlite3_vtab => VTab
        // ffi::sqlite3_vtab_cursor => VTabCursor

        /// Virtual table kind
        pub enum VTabKind {
            /// Non-eponymous
            Default,
            /// [`create`](CreateVTab::create) == [`connect`](VTab::connect)
            ///
            /// See [SQLite doc](https://sqlite.org/vtab.html#eponymous_virtual_tables)
            Eponymous,
            /// No [`create`](CreateVTab::create) / [`destroy`](CreateVTab::destroy) or
            /// not used
            ///
            /// SQLite >= 3.9.0
            ///
            /// See [SQLite doc](https://sqlite.org/vtab.html#eponymous_only_virtual_tables)
            EponymousOnly,
        }
        /// Virtual table module
        ///
        /// (See [SQLite doc](https://sqlite.org/c3ref/module.html))
        #[repr(transparent)]
        pub struct Module<'vtab, T: VTab<'vtab>> {
            base: ffi::sqlite3_module,
            phantom: PhantomData<&'vtab T>,
        }

        unsafe impl<'vtab, T: VTab<'vtab>> Send for Module<'vtab, T> {}
        unsafe impl<'vtab, T: VTab<'vtab>> Sync for Module<'vtab, T> {}

        union ModuleZeroHack {
            bytes: [u8; std::mem::size_of::<ffi::sqlite3_module>()],
            module: ffi::sqlite3_module,
        }

        // Used as a trailing initializer for sqlite3_module -- this way we avoid having
        // the build fail if buildtime_bindgen is on. This is safe, as bindgen-generated
        // structs are allowed to be zeroed.
        const ZERO_MODULE: ffi::sqlite3_module = unsafe {
            ModuleZeroHack {
                bytes: [0_u8; std::mem::size_of::<ffi::sqlite3_module>()],
            }
            .module
        };

        macro_rules! module {
            ($lt:lifetime, $vt:ty, $ct:ty, $xc:expr, $xd:expr, $xu:expr) => {
            #[allow(clippy::needless_update)]
            &Module {
                base: ffi::sqlite3_module {
                    // We don't use V3
                    iVersion: 2,
                    xCreate: $xc,
                    xConnect: Some(rust_connect::<$vt>),
                    xBestIndex: Some(rust_best_index::<$vt>),
                    xDisconnect: Some(rust_disconnect::<$vt>),
                    xDestroy: $xd,
                    xOpen: Some(rust_open::<$vt>),
                    xClose: Some(rust_close::<$ct>),
                    xFilter: Some(rust_filter::<$ct>),
                    xNext: Some(rust_next::<$ct>),
                    xEof: Some(rust_eof::<$ct>),
                    xColumn: Some(rust_column::<$ct>),
                    xRowid: Some(rust_rowid::<$ct>), // FIXME optional
                    xUpdate: $xu,
                    xBegin: None,
                    xSync: None,
                    xCommit: None,
                    xRollback: None,
                    xFindFunction: None,
                    xRename: None,
                    xSavepoint: None,
                    xRelease: None,
                    xRollbackTo: None,
                    ..ZERO_MODULE
                },
                phantom: PhantomData::<&$lt $vt>,
            }
            };
        }
        /// Create a modifiable virtual table implementation.
        ///
        /// Step 2 of [Creating New Virtual Table Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).
        #[must_use]
        pub fn update_module<'vtab, T: UpdateVTab<'vtab>>() -> &'static Module<'vtab, T> {
            match T::KIND {
                VTabKind::EponymousOnly => {
                    module!('vtab, T, T::Cursor, None, None, Some(rust_update::<T>))
                }
                VTabKind::Eponymous => {
                    module!('vtab, T, T::Cursor, Some(rust_connect::<T>), Some(rust_disconnect::<T>), Some(rust_update::<T>))
                }
                _ => {
                    module!('vtab, T, T::Cursor, Some(rust_create::<T>), Some(rust_destroy::<T>), Some(rust_update::<T>))
                }
            }
        }
        /// Create a read-only virtual table implementation.
        ///
        /// Step 2 of [Creating New Virtual Table Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).
        #[must_use]
        pub fn read_only_module<'vtab, T: CreateVTab<'vtab>>() -> &'static Module<'vtab, T> {
            match T::KIND {
                VTabKind::EponymousOnly => eponymous_only_module(),
                VTabKind::Eponymous => {
                    // A virtual table is eponymous if its xCreate method is the exact same function
                    // as the xConnect method
                    module!('vtab, T, T::Cursor, Some(rust_connect::<T>), Some(rust_disconnect::<T>), None)
                }
                _ => {
                    // The xConnect and xCreate methods may do the same thing, but they must be
                    // different so that the virtual table is not an eponymous virtual table.
                    module!('vtab, T, T::Cursor, Some(rust_create::<T>), Some(rust_destroy::<T>), None)
                }
            }
        }
        /// Create an eponymous only virtual table implementation.
        ///
        /// Step 2 of [Creating New Virtual Table Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).
        #[must_use]
        pub fn eponymous_only_module<'vtab, T: VTab<'vtab>>() -> &'static Module<'vtab, T> {
            //  For eponymous-only virtual tables, the xCreate method is NULL
            module!('vtab, T, T::Cursor, None, None, None)
        }
        /// Virtual table configuration options
        #[repr(i32)]
        #[non_exhaustive]
        #[derive(Debug, Clone, Copy, Eq, PartialEq)]
        pub enum VTabConfig {
            /// Equivalent to SQLITE_VTAB_CONSTRAINT_SUPPORT
            ConstraintSupport = 1,
            /// Equivalent to SQLITE_VTAB_INNOCUOUS
            Innocuous = 2,
            /// Equivalent to SQLITE_VTAB_DIRECTONLY
            DirectOnly = 3,
            /// Equivalent to SQLITE_VTAB_USES_ALL_SCHEMAS
            UsesAllSchemas = 4,
        }
        /// `feature = "vtab"`
        pub struct VTabConnection(*mut ffi::sqlite3);

        impl VTabConnection {
            /// Configure various facets of the virtual table interface
            pub fn config(&mut self, config: VTabConfig) -> Result<()> {
                crate::error::check(unsafe { ffi::sqlite3_vtab_config(self.0, config as c_int) })
            }

            // TODO sqlite3_vtab_on_conflict (http://sqlite.org/c3ref/vtab_on_conflict.html) & xUpdate

            /// Get access to the underlying SQLite database connection handle.
            ///
            /// # Warning
            ///
            /// You should not need to use this function. If you do need to, please
            /// [open an issue on the rusqlite repository](https://github.com/rusqlite/rusqlite/issues) and describe
            /// your use case.
            ///
            /// # Safety
            ///
            /// This function is unsafe because it gives you raw access
            /// to the SQLite connection, and what you do with it could impact the
            /// safety of this `Connection`.
            pub unsafe fn handle(&mut self) -> *mut ffi::sqlite3 {
                self.0
            }
        }
        /// Eponymous-only virtual table instance trait.
        pub unsafe trait VTab<'vtab>: Sized {
            /// Client data passed to [`Connection::create_module`].
            type Aux;
            /// Specific cursor implementation
            type Cursor: VTabCursor;

            /// Establish a new connection to an existing virtual table.
            ///
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xconnect_method))
            fn connect(
                db: &mut VTabConnection,
                aux: Option<&Self::Aux>,
                args: &[&[u8]],
            ) -> Result<(String, Self)>;

            /// Determine the best way to access the virtual table.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xbestindex_method))
            fn best_index(&self, info: &mut IndexInfo) -> Result<()>;

            /// Create a new cursor used for accessing a virtual table.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xopen_method))
            fn open(&'vtab mut self) -> Result<Self::Cursor>;
        }
        /// Read-only virtual table instance trait.
        ///
        /// (See [SQLite doc](https://sqlite.org/c3ref/vtab.html))
        pub trait CreateVTab<'vtab>: VTab<'vtab> {
            /// For [`EponymousOnly`](VTabKind::EponymousOnly),
            /// [`create`](CreateVTab::create) and [`destroy`](CreateVTab::destroy) are
            /// not called
            const KIND: VTabKind;
            /// Create a new instance of a virtual table in response to a CREATE VIRTUAL
            /// TABLE statement. The `db` parameter is a pointer to the SQLite
            /// database connection that is executing the CREATE VIRTUAL TABLE
            /// statement.
            ///
            /// Call [`connect`](VTab::connect) by default.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xcreate_method))
            fn create(
                db: &mut VTabConnection,
                aux: Option<&Self::Aux>,
                args: &[&[u8]],
            ) -> Result<(String, Self)> {
                Self::connect(db, aux, args)
            }
            /// Destroy the underlying table implementation. This method undoes the work
            /// of [`create`](CreateVTab::create).
            ///
            /// Do nothing by default.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xdestroy_method))
            fn destroy(&self) -> Result<()> {
                Ok(())
            }
        }
        /// Writable virtual table instance trait.
        ///
        /// (See [SQLite doc](https://sqlite.org/vtab.html#xupdate))
        pub trait UpdateVTab<'vtab>: CreateVTab<'vtab> {
            /// Delete rowid or PK
            fn delete(&mut self, arg: ValueRef<'_>) -> Result<()>;
            /// Insert: `args[0] == NULL: old rowid or PK, args[1]: new rowid or PK,
            /// args[2]: ...`
            ///
            /// Return the new rowid.
            // TODO Make the distinction between argv[1] == NULL and argv[1] != NULL ?
            fn insert(&mut self, args: &Values<'_>) -> Result<i64>;
            /// Update: `args[0] != NULL: old rowid or PK, args[1]: new row id or PK,
            /// args[2]: ...`
            fn update(&mut self, args: &Values<'_>) -> Result<()>;
        }
        /// Index constraint operator.
        /// See [Virtual Table Constraint Operator Codes](https://sqlite.org/c3ref/c_index_constraint_eq.html) for details.
        #[derive(Debug, Eq, PartialEq)]
        #[allow(non_snake_case, non_camel_case_types, missing_docs)]
        #[allow(clippy::upper_case_acronyms)]
        pub enum IndexConstraintOp {
            SQLITE_INDEX_CONSTRAINT_EQ,
            SQLITE_INDEX_CONSTRAINT_GT,
            SQLITE_INDEX_CONSTRAINT_LE,
            SQLITE_INDEX_CONSTRAINT_LT,
            SQLITE_INDEX_CONSTRAINT_GE,
            SQLITE_INDEX_CONSTRAINT_MATCH,
            SQLITE_INDEX_CONSTRAINT_LIKE,         // 3.10.0
            SQLITE_INDEX_CONSTRAINT_GLOB,         // 3.10.0
            SQLITE_INDEX_CONSTRAINT_REGEXP,       // 3.10.0
            SQLITE_INDEX_CONSTRAINT_NE,           // 3.21.0
            SQLITE_INDEX_CONSTRAINT_ISNOT,        // 3.21.0
            SQLITE_INDEX_CONSTRAINT_ISNOTNULL,    // 3.21.0
            SQLITE_INDEX_CONSTRAINT_ISNULL,       // 3.21.0
            SQLITE_INDEX_CONSTRAINT_IS,           // 3.21.0
            SQLITE_INDEX_CONSTRAINT_LIMIT,        // 3.38.0
            SQLITE_INDEX_CONSTRAINT_OFFSET,       // 3.38.0
            SQLITE_INDEX_CONSTRAINT_FUNCTION(u8), // 3.25.0
        }

        impl From<u8> for IndexConstraintOp 
        {
            fn from(code: u8) -> IndexConstraintOp {
                match code {
                    2 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_EQ,
                    4 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_GT,
                    8 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_LE,
                    16 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_LT,
                    32 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_GE,
                    64 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_MATCH,
                    65 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_LIKE,
                    66 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_GLOB,
                    67 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_REGEXP,
                    68 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_NE,
                    69 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_ISNOT,
                    70 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_ISNOTNULL,
                    71 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_ISNULL,
                    72 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_IS,
                    73 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_LIMIT,
                    74 => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_OFFSET,
                    v => IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_FUNCTION(v),
                }
            }
        }

        bitflags::bitflags! 
        {
            /// Virtual table scan flags
            /// See [Function Flags](https://sqlite.org/c3ref/c_index_scan_unique.html) for details.
            #[repr(C)]
            #[derive(Copy, Clone, Debug)]
            pub struct IndexFlags: ::std::os::raw::c_int {
                /// Default
                const NONE     = 0;
                /// Scan visits at most 1 row.
                const SQLITE_INDEX_SCAN_UNIQUE  = ffi::SQLITE_INDEX_SCAN_UNIQUE;
            }
        }
        /// Pass information into and receive the reply from the
        /// [`VTab::best_index`] method.
        ///
        /// (See [SQLite doc](http://sqlite.org/c3ref/index_info.html))
        #[derive(Debug)]
        pub struct IndexInfo(*mut ffi::sqlite3_index_info);

        impl IndexInfo
        {
            /// Iterate on index constraint and its associated usage.
            #[inline]
            pub fn constraints_and_usages(&mut self) -> IndexConstraintAndUsageIter<'_> {
                let constraints =
                    unsafe { slice::from_raw_parts((*self.0).aConstraint, (*self.0).nConstraint as usize) };
                let constraint_usages = unsafe {
                    slice::from_raw_parts_mut((*self.0).aConstraintUsage, (*self.0).nConstraint as usize)
                };
                IndexConstraintAndUsageIter {
                    iter: constraints.iter().zip(constraint_usages.iter_mut()),
                }
            }
            /// Record WHERE clause constraints.
            #[inline]
            #[must_use]
            pub fn constraints(&self) -> IndexConstraintIter<'_> {
                let constraints =
                    unsafe { slice::from_raw_parts((*self.0).aConstraint, (*self.0).nConstraint as usize) };
                IndexConstraintIter {
                    iter: constraints.iter(),
                }
            }
            /// Information about the ORDER BY clause.
            #[inline]
            #[must_use]
            pub fn order_bys(&self) -> OrderByIter<'_> {
                let order_bys =
                    unsafe { slice::from_raw_parts((*self.0).aOrderBy, (*self.0).nOrderBy as usize) };
                OrderByIter {
                    iter: order_bys.iter(),
                }
            }
            /// Number of terms in the ORDER BY clause
            #[inline]
            #[must_use]
            pub fn num_of_order_by(&self) -> usize {
                unsafe { (*self.0).nOrderBy as usize }
            }
            /// Information about what parameters to pass to [`VTabCursor::filter`].
            #[inline]
            pub fn constraint_usage(&mut self, constraint_idx: usize) -> IndexConstraintUsage<'_> {
                let constraint_usages = unsafe {
                    slice::from_raw_parts_mut((*self.0).aConstraintUsage, (*self.0).nConstraint as usize)
                };
                IndexConstraintUsage(&mut constraint_usages[constraint_idx])
            }
            /// Number used to identify the index
            #[inline]
            pub fn set_idx_num(&mut self, idx_num: c_int) {
                unsafe {
                    (*self.0).idxNum = idx_num;
                }
            }
            /// String used to identify the index
            pub fn set_idx_str(&mut self, idx_str: &str) {
                unsafe {
                    (*self.0).idxStr = alloc(idx_str);
                    (*self.0).needToFreeIdxStr = 1;
                }
            }
            /// True if output is already ordered
            #[inline]
            pub fn set_order_by_consumed(&mut self, order_by_consumed: bool) {
                unsafe {
                    (*self.0).orderByConsumed = order_by_consumed as c_int;
                }
            }
            /// Estimated cost of using this index
            #[inline]
            pub fn set_estimated_cost(&mut self, estimated_ost: f64) {
                unsafe {
                    (*self.0).estimatedCost = estimated_ost;
                }
            }
            /// Estimated number of rows returned.
            #[inline]
            pub fn set_estimated_rows(&mut self, estimated_rows: i64) {
                unsafe {
                    (*self.0).estimatedRows = estimated_rows;
                }
            }
            /// Mask of SQLITE_INDEX_SCAN_* flags.
            #[inline]
            pub fn set_idx_flags(&mut self, flags: IndexFlags) {
                unsafe { (*self.0).idxFlags = flags.bits() };
            }
            /// Mask of columns used by statement
            #[inline]
            pub fn col_used(&self) -> u64 {
                unsafe { (*self.0).colUsed }
            }
            /// Determine the collation for a virtual table constraint
            pub fn collation(&self, constraint_idx: usize) -> Result<&str> {
                use std::ffi::CStr;
                let idx = constraint_idx as c_int;
                let collation = unsafe { ffi::sqlite3_vtab_collation(self.0, idx) };
                if collation.is_null() {
                    return Err(Error::SqliteFailure(
                        ffi::Error::new(ffi::SQLITE_MISUSE),
                        Some(format!("{constraint_idx} is out of range")),
                    ));
                }
                Ok(unsafe { CStr::from_ptr(collation) }.to_str()?)
            }
        }
        /// Iterate on index constraint and its associated usage.
        pub struct IndexConstraintAndUsageIter<'a> {
            iter: std::iter::Zip<
                slice::Iter<'a, ffi::sqlite3_index_constraint>,
                slice::IterMut<'a, ffi::sqlite3_index_constraint_usage>,
            >,
        }

        impl<'a> Iterator for IndexConstraintAndUsageIter<'a> {
            type Item = (IndexConstraint<'a>, IndexConstraintUsage<'a>);

            #[inline]
            fn next(&mut self) -> Option<(IndexConstraint<'a>, IndexConstraintUsage<'a>)> {
                self.iter
                    .next()
                    .map(|raw| (IndexConstraint(raw.0), IndexConstraintUsage(raw.1)))
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        }
        /// `feature = "vtab"`
        pub struct IndexConstraintIter<'a> {
            iter: slice::Iter<'a, ffi::sqlite3_index_constraint>,
        }

        impl<'a> Iterator for IndexConstraintIter<'a> {
            type Item = IndexConstraint<'a>;

            #[inline]
            fn next(&mut self) -> Option<IndexConstraint<'a>> {
                self.iter.next().map(IndexConstraint)
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        }
        /// WHERE clause constraint.
        pub struct IndexConstraint<'a>(&'a ffi::sqlite3_index_constraint);

        impl IndexConstraint<'_> {
            /// Column constrained.  -1 for ROWID
            #[inline]
            #[must_use]
            pub fn column(&self) -> c_int {
                self.0.iColumn
            }
            /// Constraint operator
            #[inline]
            #[must_use]
            pub fn operator(&self) -> IndexConstraintOp {
                IndexConstraintOp::from(self.0.op)
            }
            /// True if this constraint is usable
            #[inline]
            #[must_use]
            pub fn is_usable(&self) -> bool {
                self.0.usable != 0
            }
        }
        /// Information about what parameters to pass to
        /// [`VTabCursor::filter`].
        pub struct IndexConstraintUsage<'a>(&'a mut ffi::sqlite3_index_constraint_usage);

        impl IndexConstraintUsage<'_> {
            /// if `argv_index` > 0, constraint is part of argv to
            /// [`VTabCursor::filter`]
            #[inline]
            pub fn set_argv_index(&mut self, argv_index: c_int) {
                self.0.argvIndex = argv_index;
            }
            /// if `omit`, do not code a test for this constraint
            #[inline]
            pub fn set_omit(&mut self, omit: bool) {
                self.0.omit = omit as std::os::raw::c_uchar;
            }
        }
        /// `feature = "vtab"`
        pub struct OrderByIter<'a> {
            iter: slice::Iter<'a, ffi::sqlite3_index_orderby>,
        }

        impl<'a> Iterator for OrderByIter<'a> {
            type Item = OrderBy<'a>;

            #[inline]
            fn next(&mut self) -> Option<OrderBy<'a>> {
                self.iter.next().map(OrderBy)
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        }
        /// A column of the ORDER BY clause.
        pub struct OrderBy<'a>(&'a ffi::sqlite3_index_orderby);

        impl OrderBy<'_> {
            /// Column number
            #[inline]
            #[must_use]
            pub fn column(&self) -> c_int {
                self.0.iColumn
            }
            /// True for DESC.  False for ASC.
            #[inline]
            #[must_use]
            pub fn is_order_by_desc(&self) -> bool {
                self.0.desc != 0
            }
        }
        /// Virtual table cursor trait.
        pub unsafe trait VTabCursor: Sized {
            /// Begin a search of a virtual table.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xfilter_method))
            fn filter(&mut self, idx_num: c_int, idx_str: Option<&str>, args: &Values<'_>) -> Result<()>;
            /// Advance cursor to the next row of a result set initiated by
            /// [`filter`](VTabCursor::filter). (See [SQLite doc](https://sqlite.org/vtab.html#the_xnext_method))
            fn next(&mut self) -> Result<()>;
            /// Must return `false` if the cursor currently points to a valid row of
            /// data, or `true` otherwise.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xeof_method))
            fn eof(&self) -> bool;
            /// Find the value for the `i`-th column of the current row.
            /// `i` is zero-based so the first column is numbered 0.
            /// May return its result back to SQLite using one of the specified `ctx`.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xcolumn_method))
            fn column(&self, ctx: &mut Context, i: c_int) -> Result<()>;
            /// Return the rowid of row that the cursor is currently pointing at.
            /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xrowid_method))
            fn rowid(&self) -> Result<i64>;
        }
        /// Context is used by [`VTabCursor::column`] to specify the
        /// cell value.
        pub struct Context(*mut ffi::sqlite3_context);

        impl Context {
            /// Set current cell value
            #[inline]
            pub fn set_result<T: ToSql>(&mut self, value: &T) -> Result<()> {
                let t = value.to_sql()?;
                unsafe { set_result(self.0, &[], &t) };
                Ok(())
            }

            // TODO sqlite3_vtab_nochange (http://sqlite.org/c3ref/vtab_nochange.html) // 3.22.0 & xColumn
        }
        /// Wrapper to [`VTabCursor::filter`] arguments, the values
        /// requested by [`VTab::best_index`].
        pub struct Values<'a> {
            args: &'a [*mut ffi::sqlite3_value],
        }

        impl Values<'_>
        {
            /// Returns the number of values.
            #[inline]
            #[must_use]
            pub fn len(&self) -> usize {
                self.args.len()
            }
            /// Returns `true` if there is no value.
            #[inline]
            #[must_use]
            pub fn is_empty(&self) -> bool {
                self.args.is_empty()
            }
            /// Returns value at `idx`
            pub fn get<T: FromSql>(&self, idx: usize) -> Result<T> {
                let arg = self.args[idx];
                let value = unsafe { ValueRef::from_value(arg) };
                FromSql::column_result(value).map_err(|err| match err {
                    FromSqlError::InvalidType => Error::InvalidFilterParameterType(idx, value.data_type()),
                    FromSqlError::Other(err) => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), err)
                    }
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), Box::new(err))
                    }
                    FromSqlError::OutOfRange(i) => Error::IntegralValueOutOfRange(idx, i),
                })
            }

            // `sqlite3_value_type` returns `SQLITE_NULL` for pointer.
            // So it seems not possible to enhance `ValueRef::from_value`.
            fn get_array(&self, idx: usize) -> Option<array::Array> {
                use crate::types::Value;
                let arg = self.args[idx];
                let ptr = unsafe { ffi::sqlite3_value_pointer(arg, array::ARRAY_TYPE) };
                if ptr.is_null() {
                    None
                } else {
                    Some(unsafe {
                        let ptr = ptr as *const Vec<Value>;
                        array::Array::increment_strong_count(ptr); // don't consume it
                        array::Array::from_raw(ptr)
                    })
                }
            }
            /// Turns `Values` into an iterator.
            #[inline]
            #[must_use]
            pub fn iter(&self) -> ValueIter<'_> {
                ValueIter {
                    iter: self.args.iter(),
                }
            }
            // TODO sqlite3_vtab_in_first / sqlite3_vtab_in_next https://sqlite.org/c3ref/vtab_in_first.html & 3.38.0
        }

        impl<'a> IntoIterator for &'a Values<'a> {
            type IntoIter = ValueIter<'a>;
            type Item = ValueRef<'a>;

            #[inline]
            fn into_iter(self) -> ValueIter<'a> {
                self.iter()
            }
        }
        /// [`Values`] iterator.
        pub struct ValueIter<'a> {
            iter: slice::Iter<'a, *mut ffi::sqlite3_value>,
        }

        impl<'a> Iterator for ValueIter<'a> {
            type Item = ValueRef<'a>;

            #[inline]
            fn next(&mut self) -> Option<ValueRef<'a>> {
                self.iter
                    .next()
                    .map(|&raw| unsafe { ValueRef::from_value(raw) })
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        }

        impl Connection {
            /// Register a virtual table implementation.
            ///
            /// Step 3 of [Creating New Virtual Table
            /// Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).
            #[inline]
            pub fn create_module<'vtab, T: VTab<'vtab>>(
                &self,
                module_name: &str,
                module: &'static Module<'vtab, T>,
                aux: Option<T::Aux>,
            ) -> Result<()> {
                self.db.borrow_mut().create_module(module_name, module, aux)
            }
        }

        impl InnerConnection {
            fn create_module<'vtab, T: VTab<'vtab>>(
                &mut self,
                module_name: &str,
                module: &'static Module<'vtab, T>,
                aux: Option<T::Aux>,
            ) -> Result<()> {
                use crate::version;
                if version::version_number() < 3_009_000 && module.base.xCreate.is_none() {
                    return Err(Error::ModuleError(format!(
                        "Eponymous-only virtual table not supported by SQLite version {}",
                        version::version()
                    )));
                }
                let c_name = str_to_cstring(module_name)?;
                let r = match aux {
                    Some(aux) => {
                        let boxed_aux: *mut T::Aux = Box::into_raw(Box::new(aux));
                        unsafe {
                            ffi::sqlite3_create_module_v2(
                                self.db(),
                                c_name.as_ptr(),
                                &module.base,
                                boxed_aux.cast::<c_void>(),
                                Some(free_boxed_value::<T::Aux>),
                            )
                        }
                    }
                    None => unsafe {
                        ffi::sqlite3_create_module_v2(
                            self.db(),
                            c_name.as_ptr(),
                            &module.base,
                            ptr::null_mut(),
                            None,
                        )
                    },
                };
                self.decode_result(r)
            }
        }
        /// Escape double-quote (`"`) character occurrences by
        /// doubling them (`""`).
        #[must_use]
        pub fn escape_double_quote(identifier: &str) -> Cow<'_, str> {
            if identifier.contains('"') {
                // escape quote by doubling them
                Owned(identifier.replace('"', "\"\""))
            } else {
                Borrowed(identifier)
            }
        }
        /// Dequote string
        #[must_use]
        pub fn dequote(s: &str) -> &str {
            if s.len() < 2 {
                return s;
            }
            match s.bytes().next() {
                Some(b) if b == b'"' || b == b'\'' => match s.bytes().next_back() {
                    Some(e) if e == b => &s[1..s.len() - 1], // FIXME handle inner escaped quote(s)
                    _ => s,
                },
                _ => s,
            }
        }
        
        #[must_use]
        pub fn parse_boolean(s: &str) -> Option<bool> {
            if s.eq_ignore_ascii_case("yes")
                || s.eq_ignore_ascii_case("on")
                || s.eq_ignore_ascii_case("true")
                || s.eq("1")
            {
                Some(true)
            } else if s.eq_ignore_ascii_case("no")
                || s.eq_ignore_ascii_case("off")
                || s.eq_ignore_ascii_case("false")
                || s.eq("0")
            {
                Some(false)
            } else {
                None
            }
        }
        /// `<param_name>=['"]?<param_value>['"]?` => `(<param_name>, <param_value>)`
        pub fn parameter(c_slice: &[u8]) -> Result<(&str, &str)> {
            let arg = std::str::from_utf8(c_slice)?.trim();
            let mut split = arg.split('=');
            if let Some(key) = split.next() {
                if let Some(value) = split.next() {
                    let param = key.trim();
                    let value = dequote(value.trim());
                    return Ok((param, value));
                }
            }
            Err(Error::ModuleError(format!("illegal argument: '{arg}'")))
        }

        // FIXME copy/paste from function.rs
        unsafe extern "C" fn free_boxed_value<T>(p: *mut c_void) {
            drop(Box::from_raw(p.cast::<T>()));
        }

        unsafe extern "C" fn rust_create<'vtab, T>(
            db: *mut ffi::sqlite3,
            aux: *mut c_void,
            argc: c_int,
            argv: *const *const c_char,
            pp_vtab: *mut *mut ffi::sqlite3_vtab,
            err_msg: *mut *mut c_char,
        ) -> c_int
        where
            T: CreateVTab<'vtab>,
        {
            use std::ffi::CStr;

            let mut conn = VTabConnection(db);
            let aux = aux.cast::<T::Aux>();
            let args = slice::from_raw_parts(argv, argc as usize);
            let vec = args
                .iter()
                .map(|&cs| CStr::from_ptr(cs).to_bytes()) // FIXME .to_str() -> Result<&str, Utf8Error>
                .collect::<Vec<_>>();
            match T::create(&mut conn, aux.as_ref(), &vec[..]) {
                Ok((sql, vtab)) => match std::ffi::CString::new(sql) {
                    Ok(c_sql) => {
                        let rc = ffi::sqlite3_declare_vtab(db, c_sql.as_ptr());
                        if rc == ffi::SQLITE_OK {
                            let boxed_vtab: *mut T = Box::into_raw(Box::new(vtab));
                            *pp_vtab = boxed_vtab.cast::<ffi::sqlite3_vtab>();
                            ffi::SQLITE_OK
                        } else {
                            let err = error_from_sqlite_code(rc, None);
                            to_sqlite_error(&err, err_msg)
                        }
                    }
                    Err(err) => {
                        *err_msg = alloc(&err.to_string());
                        ffi::SQLITE_ERROR
                    }
                },
                Err(err) => to_sqlite_error(&err, err_msg),
            }
        }

        unsafe extern "C" fn rust_connect<'vtab, T>(
            db: *mut ffi::sqlite3,
            aux: *mut c_void,
            argc: c_int,
            argv: *const *const c_char,
            pp_vtab: *mut *mut ffi::sqlite3_vtab,
            err_msg: *mut *mut c_char,
        ) -> c_int
        where
            T: VTab<'vtab>,
        {
            use std::ffi::CStr;

            let mut conn = VTabConnection(db);
            let aux = aux.cast::<T::Aux>();
            let args = slice::from_raw_parts(argv, argc as usize);
            let vec = args
                .iter()
                .map(|&cs| CStr::from_ptr(cs).to_bytes()) // FIXME .to_str() -> Result<&str, Utf8Error>
                .collect::<Vec<_>>();
            match T::connect(&mut conn, aux.as_ref(), &vec[..]) {
                Ok((sql, vtab)) => match std::ffi::CString::new(sql) {
                    Ok(c_sql) => {
                        let rc = ffi::sqlite3_declare_vtab(db, c_sql.as_ptr());
                        if rc == ffi::SQLITE_OK {
                            let boxed_vtab: *mut T = Box::into_raw(Box::new(vtab));
                            *pp_vtab = boxed_vtab.cast::<ffi::sqlite3_vtab>();
                            ffi::SQLITE_OK
                        } else {
                            let err = error_from_sqlite_code(rc, None);
                            to_sqlite_error(&err, err_msg)
                        }
                    }
                    Err(err) => {
                        *err_msg = alloc(&err.to_string());
                        ffi::SQLITE_ERROR
                    }
                },
                Err(err) => to_sqlite_error(&err, err_msg),
            }
        }

        unsafe extern "C" fn rust_best_index<'vtab, T>(
            vtab: *mut ffi::sqlite3_vtab,
            info: *mut ffi::sqlite3_index_info,
        ) -> c_int
        where
            T: VTab<'vtab>,
        {
            let vt = vtab.cast::<T>();
            let mut idx_info = IndexInfo(info);
            match (*vt).best_index(&mut idx_info) {
                Ok(_) => ffi::SQLITE_OK,
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg(vtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg(vtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }

        unsafe extern "C" fn rust_disconnect<'vtab, T>(vtab: *mut ffi::sqlite3_vtab) -> c_int
        where
            T: VTab<'vtab>,
        {
            if vtab.is_null() {
                return ffi::SQLITE_OK;
            }
            let vtab = vtab.cast::<T>();
            drop(Box::from_raw(vtab));
            ffi::SQLITE_OK
        }

        unsafe extern "C" fn rust_destroy<'vtab, T>(vtab: *mut ffi::sqlite3_vtab) -> c_int
        where
            T: CreateVTab<'vtab>,
        {
            if vtab.is_null() {
                return ffi::SQLITE_OK;
            }
            let vt = vtab.cast::<T>();
            match (*vt).destroy() {
                Ok(_) => {
                    drop(Box::from_raw(vt));
                    ffi::SQLITE_OK
                }
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg(vtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg(vtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }

        unsafe extern "C" fn rust_open<'vtab, T>(
            vtab: *mut ffi::sqlite3_vtab,
            pp_cursor: *mut *mut ffi::sqlite3_vtab_cursor,
        ) -> c_int
        where
            T: VTab<'vtab> + 'vtab,
        {
            let vt = vtab.cast::<T>();
            match (*vt).open() {
                Ok(cursor) => {
                    let boxed_cursor: *mut T::Cursor = Box::into_raw(Box::new(cursor));
                    *pp_cursor = boxed_cursor.cast::<ffi::sqlite3_vtab_cursor>();
                    ffi::SQLITE_OK
                }
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg(vtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg(vtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }

        unsafe extern "C" fn rust_close<C>(cursor: *mut ffi::sqlite3_vtab_cursor) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor.cast::<C>();
            drop(Box::from_raw(cr));
            ffi::SQLITE_OK
        }

        unsafe extern "C" fn rust_filter<C>(
            cursor: *mut ffi::sqlite3_vtab_cursor,
            idx_num: c_int,
            idx_str: *const c_char,
            argc: c_int,
            argv: *mut *mut ffi::sqlite3_value,
        ) -> c_int
        where
            C: VTabCursor,
        {
            use std::ffi::CStr;
            use std::str;
            let idx_name = if idx_str.is_null() {
                None
            } else {
                let c_slice = CStr::from_ptr(idx_str).to_bytes();
                Some(str::from_utf8_unchecked(c_slice))
            };
            let args = slice::from_raw_parts_mut(argv, argc as usize);
            let values = Values { args };
            let cr = cursor as *mut C;
            cursor_error(cursor, (*cr).filter(idx_num, idx_name, &values))
        }

        unsafe extern "C" fn rust_next<C>(cursor: *mut ffi::sqlite3_vtab_cursor) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor as *mut C;
            cursor_error(cursor, (*cr).next())
        }

        unsafe extern "C" fn rust_eof<C>(cursor: *mut ffi::sqlite3_vtab_cursor) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor.cast::<C>();
            (*cr).eof() as c_int
        }

        unsafe extern "C" fn rust_column<C>(
            cursor: *mut ffi::sqlite3_vtab_cursor,
            ctx: *mut ffi::sqlite3_context,
            i: c_int,
        ) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor.cast::<C>();
            let mut ctxt = Context(ctx);
            result_error(ctx, (*cr).column(&mut ctxt, i))
        }

        unsafe extern "C" fn rust_rowid<C>(
            cursor: *mut ffi::sqlite3_vtab_cursor,
            p_rowid: *mut ffi::sqlite3_int64,
        ) -> c_int
        where
            C: VTabCursor,
        {
            let cr = cursor.cast::<C>();
            match (*cr).rowid() {
                Ok(rowid) => {
                    *p_rowid = rowid;
                    ffi::SQLITE_OK
                }
                err => cursor_error(cursor, err),
            }
        }

        unsafe extern "C" fn rust_update<'vtab, T>(
            vtab: *mut ffi::sqlite3_vtab,
            argc: c_int,
            argv: *mut *mut ffi::sqlite3_value,
            p_rowid: *mut ffi::sqlite3_int64,
        ) -> c_int
        where
            T: UpdateVTab<'vtab> + 'vtab,
        {
            assert!(argc >= 1);
            let args = slice::from_raw_parts_mut(argv, argc as usize);
            let vt = vtab.cast::<T>();
            let r = if args.len() == 1 {
                (*vt).delete(ValueRef::from_value(args[0]))
            } else if ffi::sqlite3_value_type(args[0]) == ffi::SQLITE_NULL {
                // TODO Make the distinction between argv[1] == NULL and argv[1] != NULL ?
                let values = Values { args };
                match (*vt).insert(&values) {
                    Ok(rowid) => {
                        *p_rowid = rowid;
                        Ok(())
                    }
                    Err(e) => Err(e),
                }
            } else {
                let values = Values { args };
                (*vt).update(&values)
            };
            match r {
                Ok(_) => ffi::SQLITE_OK,
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg(vtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg(vtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }
        /// Virtual table cursors can set an error message by assigning a string to `zErrMsg`.
        #[cold] unsafe fn cursor_error<T>(cursor: *mut ffi::sqlite3_vtab_cursor, result: Result<T>) -> c_int {
            match result {
                Ok(_) => ffi::SQLITE_OK,
                Err(Error::SqliteFailure(err, s)) => {
                    if let Some(err_msg) = s {
                        set_err_msg((*cursor).pVtab, &err_msg);
                    }
                    err.extended_code
                }
                Err(err) => {
                    set_err_msg((*cursor).pVtab, &err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }
        /// Virtual tables methods can set an error message by assigning a string to `zErrMsg`.
        #[cold] unsafe fn set_err_msg(vtab: *mut ffi::sqlite3_vtab, err_msg: &str) {
            if !(*vtab).zErrMsg.is_null() {
                ffi::sqlite3_free((*vtab).zErrMsg.cast::<c_void>());
            }
            (*vtab).zErrMsg = alloc(err_msg);
        }
        /// To raise an error, the `column` method should use this method to set the
        /// error message and return the error code.
        #[cold] unsafe fn result_error<T>(ctx: *mut ffi::sqlite3_context, result: Result<T>) -> c_int {
            match result {
                Ok(_) => ffi::SQLITE_OK,
                Err(Error::SqliteFailure(err, s)) => {
                    match err.extended_code {
                        ffi::SQLITE_TOOBIG => {
                            ffi::sqlite3_result_error_toobig(ctx);
                        }
                        ffi::SQLITE_NOMEM => {
                            ffi::sqlite3_result_error_nomem(ctx);
                        }
                        code => {
                            ffi::sqlite3_result_error_code(ctx, code);
                            if let Some(Ok(cstr)) = s.map(|s| str_to_cstring(&s)) {
                                ffi::sqlite3_result_error(ctx, cstr.as_ptr(), -1);
                            }
                        }
                    };
                    err.extended_code
                }
                Err(err) => {
                    ffi::sqlite3_result_error_code(ctx, ffi::SQLITE_ERROR);
                    if let Ok(cstr) = str_to_cstring(&err.to_string()) {
                        ffi::sqlite3_result_error(ctx, cstr.as_ptr(), -1);
                    }
                    ffi::SQLITE_ERROR
                }
            }
        }
        
        pub mod array
        {
            //! Array Virtual Table.
            use ::
            {
                *,
            };
            
            use std::marker::PhantomData;
            use std::os::raw::{c_char, c_int, c_void};
            use std::rc::Rc;

            use crate::ffi;
            use crate::types::{ToSql, ToSqlOutput, Value};
            use crate::vtab::{
                eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,
                Values,
            };
            use crate::{Connection, Result};

            // http://sqlite.org/bindptr.html

            pub const ARRAY_TYPE: *const c_char = c"rarray".as_ptr();

            pub unsafe extern "C" fn free_array(p: *mut c_void) {
                drop(Rc::from_raw(p as *const Vec<Value>));
            }
            /// Array parameter / pointer
            pub type Array = Rc<Vec<Value>>;

            impl ToSql for Array {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::Array(self.clone()))
                }
            }
            /// Register the "rarray" module.
            pub fn load_module(conn: &Connection) -> Result<()> {
                let aux: Option<()> = None;
                conn.create_module("rarray", eponymous_only_module::<ArrayTab>(), aux)
            }

            // Column numbers
            // const CARRAY_COLUMN_VALUE : c_int = 0;
            const CARRAY_COLUMN_POINTER: c_int = 1;

            /// An instance of the Array virtual table
            #[repr(C)]
            struct ArrayTab {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab,
            }

            unsafe impl<'vtab> VTab<'vtab> for ArrayTab {
                type Aux = ();
                type Cursor = ArrayTabCursor<'vtab>;

                fn connect(
                    _: &mut VTabConnection,
                    _aux: Option<&()>,
                    _args: &[&[u8]],
                ) -> Result<(String, ArrayTab)> {
                    let vtab = ArrayTab {
                        base: ffi::sqlite3_vtab::default(),
                    };
                    Ok(("CREATE TABLE x(value,pointer hidden)".to_owned(), vtab))
                }

                fn best_index(&self, info: &mut IndexInfo) -> Result<()> {
                    // Index of the pointer= constraint
                    let mut ptr_idx = false;
                    for (constraint, mut constraint_usage) in info.constraints_and_usages() {
                        if !constraint.is_usable() {
                            continue;
                        }
                        if constraint.operator() != IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_EQ {
                            continue;
                        }
                        if let CARRAY_COLUMN_POINTER = constraint.column() {
                            ptr_idx = true;
                            constraint_usage.set_argv_index(1);
                            constraint_usage.set_omit(true);
                        }
                    }
                    if ptr_idx {
                        info.set_estimated_cost(1_f64);
                        info.set_estimated_rows(100);
                        info.set_idx_num(1);
                    } else {
                        info.set_estimated_cost(2_147_483_647_f64);
                        info.set_estimated_rows(2_147_483_647);
                        info.set_idx_num(0);
                    }
                    Ok(())
                }

                fn open(&mut self) -> Result<ArrayTabCursor<'_>> {
                    Ok(ArrayTabCursor::new())
                }
            }
            /// A cursor for the Array virtual table
            #[repr(C)]
            struct ArrayTabCursor<'vtab> {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab_cursor,
                /// The rowid
                row_id: i64,
                /// Pointer to the array of values ("pointer")
                ptr: Option<Array>,
                phantom: PhantomData<&'vtab ArrayTab>,
            }

            impl ArrayTabCursor<'_> {
                fn new<'vtab>() -> ArrayTabCursor<'vtab> {
                    ArrayTabCursor {
                        base: ffi::sqlite3_vtab_cursor::default(),
                        row_id: 0,
                        ptr: None,
                        phantom: PhantomData,
                    }
                }

                fn len(&self) -> i64 {
                    match self.ptr {
                        Some(ref a) => a.len() as i64,
                        _ => 0,
                    }
                }
            }
            unsafe impl VTabCursor for ArrayTabCursor<'_> {
                fn filter(&mut self, idx_num: c_int, _idx_str: Option<&str>, args: &Values<'_>) -> Result<()> {
                    if idx_num > 0 {
                        self.ptr = args.get_array(0);
                    } else {
                        self.ptr = None;
                    }
                    self.row_id = 1;
                    Ok(())
                }

                fn next(&mut self) -> Result<()> {
                    self.row_id += 1;
                    Ok(())
                }

                fn eof(&self) -> bool {
                    self.row_id > self.len()
                }

                fn column(&self, ctx: &mut Context, i: c_int) -> Result<()> {
                    match i {
                        CARRAY_COLUMN_POINTER => Ok(()),
                        _ => {
                            if let Some(ref array) = self.ptr {
                                let value = &array[(self.row_id - 1) as usize];
                                ctx.set_result(&value)
                            } else {
                                Ok(())
                            }
                        }
                    }
                }

                fn rowid(&self) -> Result<i64> {
                    Ok(self.row_id)
                }
            }
        }
        pub mod csvtab
        {
            //! CSV Virtual Table.
            use ::
            {
                *,
            };
            
            use std::fs::File;
            use std::marker::PhantomData;
            use std::os::raw::c_int;
            use std::path::Path;
            use std::str;

            use crate::ffi;
            use crate::types::Null;
            use crate::vtab::{
                escape_double_quote, parse_boolean, read_only_module, Context, CreateVTab, IndexInfo, VTab,
                VTabConfig, VTabConnection, VTabCursor, VTabKind, Values,
            };
            use crate::{Connection, Error, Result};

            /// Register the "csv" module.
            pub fn load_module(conn: &Connection) -> Result<()> {
                let aux: Option<()> = None;
                conn.create_module("csv", read_only_module::<CsvTab>(), aux)
            }
            /// An instance of the CSV virtual table
            #[repr(C)]
            struct CsvTab {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab,
                /// Name of the CSV file
                filename: String,
                has_headers: bool,
                delimiter: u8,
                quote: u8,
                /// Offset to start of data
                offset_first_row: csv::Position,
            }

            impl CsvTab {
                fn reader(&self) -> Result<csv::Reader<File>, csv::Error> {
                    csv::ReaderBuilder::new()
                        .has_headers(self.has_headers)
                        .delimiter(self.delimiter)
                        .quote(self.quote)
                        .from_path(&self.filename)
                }

                fn parse_byte(arg: &str) -> Option<u8> {
                    if arg.len() == 1 {
                        arg.bytes().next()
                    } else {
                        None
                    }
                }
            }

            unsafe impl<'vtab> VTab<'vtab> for CsvTab {
                type Aux = ();
                type Cursor = CsvTabCursor<'vtab>;

                fn connect(
                    db: &mut VTabConnection,
                    _aux: Option<&()>,
                    args: &[&[u8]],
                ) -> Result<(String, CsvTab)> {
                    if args.len() < 4 {
                        return Err(Error::ModuleError("no CSV file specified".to_owned()));
                    }

                    let mut vtab = CsvTab {
                        base: ffi::sqlite3_vtab::default(),
                        filename: "".to_owned(),
                        has_headers: false,
                        delimiter: b',',
                        quote: b'"',
                        offset_first_row: csv::Position::new(),
                    };
                    let mut schema = None;
                    let mut n_col = None;

                    let args = &args[3..];
                    for c_slice in args {
                        let (param, value) = super::parameter(c_slice)?;
                        match param {
                            "filename" => {
                                if !Path::new(value).exists() {
                                    return Err(Error::ModuleError(format!("file '{value}' does not exist")));
                                }
                                value.clone_into(&mut vtab.filename);
                            }
                            "schema" => {
                                schema = Some(value.to_owned());
                            }
                            "columns" => {
                                if let Ok(n) = value.parse::<u16>() {
                                    if n_col.is_some() {
                                        return Err(Error::ModuleError(
                                            "more than one 'columns' parameter".to_owned(),
                                        ));
                                    } else if n == 0 {
                                        return Err(Error::ModuleError(
                                            "must have at least one column".to_owned(),
                                        ));
                                    }
                                    n_col = Some(n);
                                } else {
                                    return Err(Error::ModuleError(format!(
                                        "unrecognized argument to 'columns': {value}"
                                    )));
                                }
                            }
                            "header" => {
                                if let Some(b) = parse_boolean(value) {
                                    vtab.has_headers = b;
                                } else {
                                    return Err(Error::ModuleError(format!(
                                        "unrecognized argument to 'header': {value}"
                                    )));
                                }
                            }
                            "delimiter" => {
                                if let Some(b) = CsvTab::parse_byte(value) {
                                    vtab.delimiter = b;
                                } else {
                                    return Err(Error::ModuleError(format!(
                                        "unrecognized argument to 'delimiter': {value}"
                                    )));
                                }
                            }
                            "quote" => {
                                if let Some(b) = CsvTab::parse_byte(value) {
                                    if b == b'0' {
                                        vtab.quote = 0;
                                    } else {
                                        vtab.quote = b;
                                    }
                                } else {
                                    return Err(Error::ModuleError(format!(
                                        "unrecognized argument to 'quote': {value}"
                                    )));
                                }
                            }
                            _ => {
                                return Err(Error::ModuleError(format!(
                                    "unrecognized parameter '{param}'"
                                )));
                            }
                        }
                    }

                    if vtab.filename.is_empty() {
                        return Err(Error::ModuleError("no CSV file specified".to_owned()));
                    }

                    let mut cols: Vec<String> = Vec::new();
                    if vtab.has_headers || (n_col.is_none() && schema.is_none()) {
                        let mut reader = vtab.reader()?;
                        if vtab.has_headers {
                            {
                                let headers = reader.headers()?;
                                // headers ignored if cols is not empty
                                if n_col.is_none() && schema.is_none() {
                                    cols = headers
                                        .into_iter()
                                        .map(|header| escape_double_quote(header).into_owned())
                                        .collect();
                                }
                            }
                            vtab.offset_first_row = reader.position().clone();
                        } else {
                            let mut record = csv::ByteRecord::new();
                            if reader.read_byte_record(&mut record)? {
                                for (i, _) in record.iter().enumerate() {
                                    cols.push(format!("c{i}"));
                                }
                            }
                        }
                    } else if let Some(n_col) = n_col {
                        for i in 0..n_col {
                            cols.push(format!("c{i}"));
                        }
                    }

                    if cols.is_empty() && schema.is_none() {
                        return Err(Error::ModuleError("no column specified".to_owned()));
                    }

                    if schema.is_none() {
                        let mut sql = String::from("CREATE TABLE x(");
                        for (i, col) in cols.iter().enumerate() {
                            sql.push('"');
                            sql.push_str(col);
                            sql.push_str("\" TEXT");
                            if i == cols.len() - 1 {
                                sql.push_str(");");
                            } else {
                                sql.push_str(", ");
                            }
                        }
                        schema = Some(sql);
                    }
                    db.config(VTabConfig::DirectOnly)?;
                    Ok((schema.unwrap(), vtab))
                }

                // Only a forward full table scan is supported.
                fn best_index(&self, info: &mut IndexInfo) -> Result<()> {
                    info.set_estimated_cost(1_000_000.);
                    Ok(())
                }

                fn open(&mut self) -> Result<CsvTabCursor<'_>> {
                    Ok(CsvTabCursor::new(self.reader()?))
                }
            }

            impl CreateVTab<'_> for CsvTab {
                const KIND: VTabKind = VTabKind::Default;
            }
            /// A cursor for the CSV virtual table
            #[repr(C)]
            struct CsvTabCursor<'vtab> {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab_cursor,
                /// The CSV reader object
                reader: csv::Reader<File>,
                /// Current cursor position used as rowid
                row_number: usize,
                /// Values of the current row
                cols: csv::StringRecord,
                eof: bool,
                phantom: PhantomData<&'vtab CsvTab>,
            }

            impl CsvTabCursor<'_> {
                fn new<'vtab>(reader: csv::Reader<File>) -> CsvTabCursor<'vtab> {
                    CsvTabCursor {
                        base: ffi::sqlite3_vtab_cursor::default(),
                        reader,
                        row_number: 0,
                        cols: csv::StringRecord::new(),
                        eof: false,
                        phantom: PhantomData,
                    }
                }
                /// Accessor to the associated virtual table.
                fn vtab(&self) -> &CsvTab {
                    unsafe { &*(self.base.pVtab as *const CsvTab) }
                }
            }

            unsafe impl VTabCursor for CsvTabCursor<'_> {
                // Only a full table scan is supported.  So `filter` simply rewinds to
                // the beginning.
                fn filter(
                    &mut self,
                    _idx_num: c_int,
                    _idx_str: Option<&str>,
                    _args: &Values<'_>,
                ) -> Result<()> {
                    {
                        let offset_first_row = self.vtab().offset_first_row.clone();
                        self.reader.seek(offset_first_row)?;
                    }
                    self.row_number = 0;
                    self.next()
                }

                fn next(&mut self) -> Result<()> {
                    {
                        self.eof = self.reader.is_done();
                        if self.eof {
                            return Ok(());
                        }

                        self.eof = !self.reader.read_record(&mut self.cols)?;
                    }

                    self.row_number += 1;
                    Ok(())
                }

                fn eof(&self) -> bool {
                    self.eof
                }

                fn column(&self, ctx: &mut Context, col: c_int) -> Result<()> {
                    if col < 0 || col as usize >= self.cols.len() {
                        return Err(Error::ModuleError(format!(
                            "column index out of bounds: {col}"
                        )));
                    }
                    if self.cols.is_empty() {
                        return ctx.set_result(&Null);
                    }
                    // TODO Affinity
                    ctx.set_result(&self.cols[col as usize].to_owned())
                }

                fn rowid(&self) -> Result<i64> {
                    Ok(self.row_number as i64)
                }
            }

            impl From<csv::Error> for Error {
                #[cold]
                fn from(err: csv::Error) -> Error {
                    Error::ModuleError(err.to_string())
                }
            }
        }
        pub mod series
        {
            //! Generate series virtual table.
            use ::
            {
                *,
            };
            
            use std::marker::PhantomData;
            use std::os::raw::c_int;

            use crate::ffi;
            use crate::types::Type;
            use crate::vtab::{
                eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConfig, VTabConnection,
                VTabCursor, Values,
            };
            use crate::{Connection, Error, Result};

            /// Register the "generate_series" module.
            pub fn load_module(conn: &Connection) -> Result<()> {
                let aux: Option<()> = None;
                conn.create_module("generate_series", eponymous_only_module::<SeriesTab>(), aux)
            }

            // Column numbers
            // const SERIES_COLUMN_VALUE : c_int = 0;
            const SERIES_COLUMN_START: c_int = 1;
            const SERIES_COLUMN_STOP: c_int = 2;
            const SERIES_COLUMN_STEP: c_int = 3;

            bitflags::bitflags! {
                #[derive(Clone, Copy)]
                #[repr(C)]
                struct QueryPlanFlags: ::std::os::raw::c_int {
                    // start = $value  -- constraint exists
                    const START = 1;
                    // stop = $value   -- constraint exists
                    const STOP  = 2;
                    // step = $value   -- constraint exists
                    const STEP  = 4;
                    // output in descending order
                    const DESC  = 8;
                    // output in ascending order
                    const ASC  = 16;
                    // Both start and stop
                    const BOTH  = QueryPlanFlags::START.bits() | QueryPlanFlags::STOP.bits();
                }
            }
            /// An instance of the Series virtual table
            #[repr(C)]
            struct SeriesTab {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab,
            }

            unsafe impl<'vtab> VTab<'vtab> for SeriesTab {
                type Aux = ();
                type Cursor = SeriesTabCursor<'vtab>;

                fn connect(
                    db: &mut VTabConnection,
                    _aux: Option<&()>,
                    _args: &[&[u8]],
                ) -> Result<(String, SeriesTab)> {
                    let vtab = SeriesTab {
                        base: ffi::sqlite3_vtab::default(),
                    };
                    db.config(VTabConfig::Innocuous)?;
                    Ok((
                        "CREATE TABLE x(value,start hidden,stop hidden,step hidden)".to_owned(),
                        vtab,
                    ))
                }

                fn best_index(&self, info: &mut IndexInfo) -> Result<()> {
                    // The query plan bitmask
                    let mut idx_num: QueryPlanFlags = QueryPlanFlags::empty();
                    // Mask of unusable constraints
                    let mut unusable_mask: QueryPlanFlags = QueryPlanFlags::empty();
                    // Constraints on start, stop, and step
                    let mut a_idx: [Option<usize>; 3] = [None, None, None];
                    for (i, constraint) in info.constraints().enumerate() {
                        if constraint.column() < SERIES_COLUMN_START {
                            continue;
                        }
                        let (i_col, i_mask) = match constraint.column() {
                            SERIES_COLUMN_START => (0, QueryPlanFlags::START),
                            SERIES_COLUMN_STOP => (1, QueryPlanFlags::STOP),
                            SERIES_COLUMN_STEP => (2, QueryPlanFlags::STEP),
                            _ => {
                                unreachable!()
                            }
                        };
                        if !constraint.is_usable() {
                            unusable_mask |= i_mask;
                        } else if constraint.operator() == IndexConstraintOp::SQLITE_INDEX_CONSTRAINT_EQ {
                            idx_num |= i_mask;
                            a_idx[i_col] = Some(i);
                        }
                    }
                    // Number of arguments that SeriesTabCursor::filter expects
                    let mut n_arg = 0;
                    for j in a_idx.iter().flatten() {
                        n_arg += 1;
                        let mut constraint_usage = info.constraint_usage(*j);
                        constraint_usage.set_argv_index(n_arg);
                        constraint_usage.set_omit(true);
                        #[cfg(all(test, feature = "modern_sqlite"))]
                        debug_assert_eq!(Ok("BINARY"), info.collation(*j));
                    }
                    if !(unusable_mask & !idx_num).is_empty() {
                        return Err(Error::SqliteFailure(
                            ffi::Error::new(ffi::SQLITE_CONSTRAINT),
                            None,
                        ));
                    }
                    if idx_num.contains(QueryPlanFlags::BOTH) {
                        // Both start= and stop= boundaries are available.
                        #[allow(clippy::bool_to_int_with_if)]
                        info.set_estimated_cost(f64::from(
                            2 - if idx_num.contains(QueryPlanFlags::STEP) {
                                1
                            } else {
                                0
                            },
                        ));
                        info.set_estimated_rows(1000);
                        let order_by_consumed = {
                            let mut order_bys = info.order_bys();
                            if let Some(order_by) = order_bys.next() {
                                if order_by.column() == 0 {
                                    if order_by.is_order_by_desc() {
                                        idx_num |= QueryPlanFlags::DESC;
                                    } else {
                                        idx_num |= QueryPlanFlags::ASC;
                                    }
                                    true
                                } else {
                                    false
                                }
                            } else {
                                false
                            }
                        };
                        if order_by_consumed {
                            info.set_order_by_consumed(true);
                        }
                    } else {
                        // If either boundary is missing, we have to generate a huge span
                        // of numbers.  Make this case very expensive so that the query
                        // planner will work hard to avoid it.
                        info.set_estimated_rows(2_147_483_647);
                    }
                    info.set_idx_num(idx_num.bits());
                    Ok(())
                }

                fn open(&mut self) -> Result<SeriesTabCursor<'_>> {
                    Ok(SeriesTabCursor::new())
                }
            }
            /// A cursor for the Series virtual table
            #[repr(C)]
            struct SeriesTabCursor<'vtab> {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab_cursor,
                /// True to count down rather than up
                is_desc: bool,
                /// The rowid
                row_id: i64,
                /// Current value ("value")
                value: i64,
                /// Minimum value ("start")
                min_value: i64,
                /// Maximum value ("stop")
                max_value: i64,
                /// Increment ("step")
                step: i64,
                phantom: PhantomData<&'vtab SeriesTab>,
            }

            impl SeriesTabCursor<'_> {
                fn new<'vtab>() -> SeriesTabCursor<'vtab> {
                    SeriesTabCursor {
                        base: ffi::sqlite3_vtab_cursor::default(),
                        is_desc: false,
                        row_id: 0,
                        value: 0,
                        min_value: 0,
                        max_value: 0,
                        step: 0,
                        phantom: PhantomData,
                    }
                }
            }
            #[allow(clippy::comparison_chain)]
            unsafe impl VTabCursor for SeriesTabCursor<'_> {
                fn filter(&mut self, idx_num: c_int, _idx_str: Option<&str>, args: &Values<'_>) -> Result<()> {
                    let mut idx_num = QueryPlanFlags::from_bits_truncate(idx_num);
                    let mut i = 0;
                    if idx_num.contains(QueryPlanFlags::START) {
                        self.min_value = args.get::<Option<_>>(i)?.unwrap_or_default();
                        i += 1;
                    } else {
                        self.min_value = 0;
                    }
                    if idx_num.contains(QueryPlanFlags::STOP) {
                        self.max_value = args.get::<Option<_>>(i)?.unwrap_or_default();
                        i += 1;
                    } else {
                        self.max_value = 0xffff_ffff;
                    }
                    if idx_num.contains(QueryPlanFlags::STEP) {
                        self.step = args.get::<Option<_>>(i)?.unwrap_or_default();
                        if self.step == 0 {
                            self.step = 1;
                        } else if self.step < 0 {
                            self.step = -self.step;
                            if !idx_num.contains(QueryPlanFlags::ASC) {
                                idx_num |= QueryPlanFlags::DESC;
                            }
                        }
                    } else {
                        self.step = 1;
                    };
                    for arg in args.iter() {
                        if arg.data_type() == Type::Null {
                            // If any of the constraints have a NULL value, then return no rows.
                            self.min_value = 1;
                            self.max_value = 0;
                            break;
                        }
                    }
                    self.is_desc = idx_num.contains(QueryPlanFlags::DESC);
                    if self.is_desc {
                        self.value = self.max_value;
                        if self.step > 0 {
                            self.value -= (self.max_value - self.min_value) % self.step;
                        }
                    } else {
                        self.value = self.min_value;
                    }
                    self.row_id = 1;
                    Ok(())
                }

                fn next(&mut self) -> Result<()> {
                    if self.is_desc {
                        self.value -= self.step;
                    } else {
                        self.value += self.step;
                    }
                    self.row_id += 1;
                    Ok(())
                }

                fn eof(&self) -> bool {
                    if self.is_desc {
                        self.value < self.min_value
                    } else {
                        self.value > self.max_value
                    }
                }

                fn column(&self, ctx: &mut Context, i: c_int) -> Result<()> {
                    let x = match i {
                        SERIES_COLUMN_START => self.min_value,
                        SERIES_COLUMN_STOP => self.max_value,
                        SERIES_COLUMN_STEP => self.step,
                        _ => self.value,
                    };
                    ctx.set_result(&x)
                }

                fn rowid(&self) -> Result<i64> {
                    Ok(self.row_id)
                }
            }
        }
        
        mod vtablog
        {
            //! Port of C [vtablog](http://www.sqlite.org/cgi/src/finfo?name=ext/misc/vtablog.c)
            use ::
            {
                *,
            };
            
            use std::marker::PhantomData;
            use std::os::raw::c_int;
            use std::str::FromStr;
            use std::sync::atomic::{AtomicUsize, Ordering};

            use crate::vtab::{
                update_module, Context, CreateVTab, IndexInfo, UpdateVTab, VTab, VTabConnection, VTabCursor,
                VTabKind, Values,
            };
            use crate::{ffi, ValueRef};
            use crate::{Connection, Error, Result};

            /// Register the "vtablog" module.
            pub fn load_module(conn: &Connection) -> Result<()> {
                let aux: Option<()> = None;
                conn.create_module("vtablog", update_module::<VTabLog>(), aux)
            }
            /// An instance of the vtablog virtual table
            #[repr(C)]
            struct VTabLog {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab,
                /// Number of rows in the table
                n_row: i64,
                /// Instance number for this vtablog table
                i_inst: usize,
                /// Number of cursors created
                n_cursor: usize,
            }

            impl VTabLog {
                fn connect_create(
                    _: &mut VTabConnection,
                    _: Option<&()>,
                    args: &[&[u8]],
                    is_create: bool,
                ) -> Result<(String, VTabLog)> {
                    static N_INST: AtomicUsize = AtomicUsize::new(1);
                    let i_inst = N_INST.fetch_add(1, Ordering::SeqCst);
                    println!(
                        "VTabLog::{}(tab={}, args={:?}):",
                        if is_create { "create" } else { "connect" },
                        i_inst,
                        args,
                    );
                    let mut schema = None;
                    let mut n_row = None;

                    let args = &args[3..];
                    for c_slice in args {
                        let (param, value) = super::parameter(c_slice)?;
                        match param {
                            "schema" => {
                                if schema.is_some() {
                                    return Err(Error::ModuleError(format!(
                                        "more than one '{param}' parameter"
                                    )));
                                }
                                schema = Some(value.to_owned())
                            }
                            "rows" => {
                                if n_row.is_some() {
                                    return Err(Error::ModuleError(format!(
                                        "more than one '{param}' parameter"
                                    )));
                                }
                                if let Ok(n) = i64::from_str(value) {
                                    n_row = Some(n)
                                }
                            }
                            _ => {
                                return Err(Error::ModuleError(format!(
                                    "unrecognized parameter '{param}'"
                                )));
                            }
                        }
                    }
                    if schema.is_none() {
                        return Err(Error::ModuleError("no schema defined".to_owned()));
                    }
                    let vtab = VTabLog {
                        base: ffi::sqlite3_vtab::default(),
                        n_row: n_row.unwrap_or(10),
                        i_inst,
                        n_cursor: 0,
                    };
                    Ok((schema.unwrap(), vtab))
                }
            }

            impl Drop for VTabLog {
                fn drop(&mut self) {
                    println!("VTabLog::drop({})", self.i_inst);
                }
            }

            unsafe impl<'vtab> VTab<'vtab> for VTabLog {
                type Aux = ();
                type Cursor = VTabLogCursor<'vtab>;

                fn connect(
                    db: &mut VTabConnection,
                    aux: Option<&Self::Aux>,
                    args: &[&[u8]],
                ) -> Result<(String, Self)> {
                    VTabLog::connect_create(db, aux, args, false)
                }

                fn best_index(&self, info: &mut IndexInfo) -> Result<()> {
                    println!("VTabLog::best_index({})", self.i_inst);
                    info.set_estimated_cost(500.);
                    info.set_estimated_rows(500);
                    Ok(())
                }

                fn open(&'vtab mut self) -> Result<Self::Cursor> {
                    self.n_cursor += 1;
                    println!(
                        "VTabLog::open(tab={}, cursor={})",
                        self.i_inst, self.n_cursor
                    );
                    Ok(VTabLogCursor {
                        base: ffi::sqlite3_vtab_cursor::default(),
                        i_cursor: self.n_cursor,
                        row_id: 0,
                        phantom: PhantomData,
                    })
                }
            }

            impl<'vtab> CreateVTab<'vtab> for VTabLog {
                const KIND: VTabKind = VTabKind::Default;

                fn create(
                    db: &mut VTabConnection,
                    aux: Option<&Self::Aux>,
                    args: &[&[u8]],
                ) -> Result<(String, Self)> {
                    VTabLog::connect_create(db, aux, args, true)
                }

                fn destroy(&self) -> Result<()> {
                    println!("VTabLog::destroy({})", self.i_inst);
                    Ok(())
                }
            }

            impl<'vtab> UpdateVTab<'vtab> for VTabLog {
                fn delete(&mut self, arg: ValueRef<'_>) -> Result<()> {
                    println!("VTabLog::delete({}, {arg:?})", self.i_inst);
                    Ok(())
                }

                fn insert(&mut self, args: &Values<'_>) -> Result<i64> {
                    println!(
                        "VTabLog::insert({}, {:?})",
                        self.i_inst,
                        args.iter().collect::<Vec<ValueRef<'_>>>()
                    );
                    Ok(self.n_row)
                }

                fn update(&mut self, args: &Values<'_>) -> Result<()> {
                    println!(
                        "VTabLog::update({}, {:?})",
                        self.i_inst,
                        args.iter().collect::<Vec<ValueRef<'_>>>()
                    );
                    Ok(())
                }
            }
            /// A cursor for the Series virtual table
            #[repr(C)]
            struct VTabLogCursor<'vtab> {
                /// Base class. Must be first
                base: ffi::sqlite3_vtab_cursor,
                /// Cursor number
                i_cursor: usize,
                /// The rowid
                row_id: i64,
                phantom: PhantomData<&'vtab VTabLog>,
            }

            impl VTabLogCursor<'_> {
                fn vtab(&self) -> &VTabLog {
                    unsafe { &*(self.base.pVtab as *const VTabLog) }
                }
            }

            impl Drop for VTabLogCursor<'_> {
                fn drop(&mut self) {
                    println!(
                        "VTabLogCursor::drop(tab={}, cursor={})",
                        self.vtab().i_inst,
                        self.i_cursor
                    );
                }
            }

            unsafe impl VTabCursor for VTabLogCursor<'_> {
                fn filter(&mut self, _: c_int, _: Option<&str>, _: &Values<'_>) -> Result<()> {
                    println!(
                        "VTabLogCursor::filter(tab={}, cursor={})",
                        self.vtab().i_inst,
                        self.i_cursor
                    );
                    self.row_id = 0;
                    Ok(())
                }

                fn next(&mut self) -> Result<()> {
                    println!(
                        "VTabLogCursor::next(tab={}, cursor={}): rowid {} -> {}",
                        self.vtab().i_inst,
                        self.i_cursor,
                        self.row_id,
                        self.row_id + 1
                    );
                    self.row_id += 1;
                    Ok(())
                }

                fn eof(&self) -> bool {
                    let eof = self.row_id >= self.vtab().n_row;
                    println!(
                        "VTabLogCursor::eof(tab={}, cursor={}): {}",
                        self.vtab().i_inst,
                        self.i_cursor,
                        eof,
                    );
                    eof
                }

                fn column(&self, ctx: &mut Context, i: c_int) -> Result<()> {
                    let value = if i < 26 {
                        format!(
                            "{}{}",
                            "abcdefghijklmnopqrstuvwyz".chars().nth(i as usize).unwrap(),
                            self.row_id
                        )
                    } else {
                        format!("{i}{}", self.row_id)
                    };
                    println!(
                        "VTabLogCursor::column(tab={}, cursor={}, i={}): {}",
                        self.vtab().i_inst,
                        self.i_cursor,
                        i,
                        value,
                    );
                    ctx.set_result(&value)
                }

                fn rowid(&self) -> Result<i64> {
                    println!(
                        "VTabLogCursor::rowid(tab={}, cursor={}): {}",
                        self.vtab().i_inst,
                        self.i_cursor,
                        self.row_id,
                    );
                    Ok(self.row_id)
                }
            }
        }
    }

    pub mod util
    {
        use ::
        {
            *,
        };
        // Internal utilities
        pub mod param_cache
        {
            use ::
            {
                *,
            };
            use super::SmallCString;
            use std::cell::RefCell;
            use std::collections::BTreeMap;

            /// Maps parameter names to parameter indices.
            #[derive(Default, Clone, Debug)]
            // BTreeMap seems to do better here unless we want to pull in a custom hash
            // function.
            pub struct ParamIndexCache(RefCell<BTreeMap<SmallCString, usize>>);

            impl ParamIndexCache {
                pub fn get_or_insert_with<F>(&self, s: &str, func: F) -> Option<usize> where
                    F: FnOnce(&std::ffi::CStr) -> Option<usize>,
                {
                    let mut cache = self.0.borrow_mut();
                    // Avoid entry API, needs allocation to test membership.
                    if let Some(v) = cache.get(s) {
                        return Some(*v);
                    }
                    // If there's an internal nul in the name it couldn't have been a
                    // parameter, so early return here is ok.
                    let name = SmallCString::new(s).ok()?;
                    let val = func(&name)?;
                    cache.insert(name, val);
                    Some(val)
                }
            }
        } pub use param_cache::ParamIndexCache;

        pub mod small_cstr
        {
            use ::
            {
                *,
            };
            use smallvec::{smallvec, SmallVec};
            use std::ffi::{CStr, CString, NulError};

            /// Similar to `std::ffi::CString`, but avoids heap allocating if the string is
            /// small enough. Also guarantees it's input is UTF-8 -- used for cases where we
            /// need to pass a NUL-terminated string to SQLite, and we have a `&str`.
            #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
            pub struct SmallCString(SmallVec<[u8; 16]>);

            impl SmallCString {
                #[inline]
                pub fn new(s: &str) -> Result<Self, NulError> {
                    if s.as_bytes().contains(&0_u8) {
                        return Err(Self::fabricate_nul_error(s));
                    }
                    let mut buf = SmallVec::with_capacity(s.len() + 1);
                    buf.extend_from_slice(s.as_bytes());
                    buf.push(0);
                    let res = Self(buf);
                    res.debug_checks();
                    Ok(res)
                }

                #[inline]
                pub fn as_str(&self) -> &str {
                    self.debug_checks();
                    // Constructor takes a &str so this is safe.
                    unsafe { std::str::from_utf8_unchecked(self.as_bytes_without_nul()) }
                }
                /// Get the bytes not including the NUL terminator. E.g. the bytes which
                /// make up our `str`:
                /// - `SmallCString::new("foo").as_bytes_without_nul() == b"foo"`
                /// - `SmallCString::new("foo").as_bytes_with_nul() == b"foo\0"`
                #[inline]
                pub fn as_bytes_without_nul(&self) -> &[u8] {
                    self.debug_checks();
                    &self.0[..self.len()]
                }
                /// Get the bytes behind this str *including* the NUL terminator. This
                /// should never return an empty slice.
                #[inline]
                pub fn as_bytes_with_nul(&self) -> &[u8] {
                    self.debug_checks();
                    &self.0
                }

                #[inline]
                #[cfg(debug_assertions)]
                fn debug_checks(&self) {
                    debug_assert_ne!(self.0.len(), 0);
                    debug_assert_eq!(self.0[self.0.len() - 1], 0);
                    let strbytes = &self.0[..(self.0.len() - 1)];
                    debug_assert!(!strbytes.contains(&0));
                    debug_assert!(std::str::from_utf8(strbytes).is_ok());
                }

                #[inline]
                #[cfg(not(debug_assertions))]
                fn debug_checks(&self) {}

                #[inline]
                pub fn len(&self) -> usize {
                    debug_assert_ne!(self.0.len(), 0);
                    self.0.len() - 1
                }

                #[inline]
                #[allow(unused)] // clippy wants this function.
                pub fn is_empty(&self) -> bool {
                    self.len() == 0
                }

                #[inline]
                pub fn as_cstr(&self) -> &CStr {
                    let bytes = self.as_bytes_with_nul();
                    debug_assert!(CStr::from_bytes_with_nul(bytes).is_ok());
                    unsafe { CStr::from_bytes_with_nul_unchecked(bytes) }
                }

                #[cold]
                fn fabricate_nul_error(b: &str) -> NulError {
                    CString::new(b).unwrap_err()
                }
            }

            impl Default for SmallCString {
                #[inline]
                fn default() -> Self {
                    Self(smallvec![0])
                }
            }

            impl std::fmt::Debug for SmallCString {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.debug_tuple("SmallCString").field(&self.as_str()).finish()
                }
            }

            impl std::ops::Deref for SmallCString {
                type Target = CStr;

                #[inline]
                fn deref(&self) -> &CStr {
                    self.as_cstr()
                }
            }

            impl PartialEq<SmallCString> for str {
                #[inline]
                fn eq(&self, s: &SmallCString) -> bool {
                    s.as_bytes_without_nul() == self.as_bytes()
                }
            }

            impl PartialEq<str> for SmallCString {
                #[inline]
                fn eq(&self, s: &str) -> bool {
                    self.as_bytes_without_nul() == s.as_bytes()
                }
            }

            impl std::borrow::Borrow<str> for SmallCString {
                #[inline]
                fn borrow(&self) -> &str {
                    self.as_str()
                }
            }
        } pub use small_cstr::SmallCString;
        
        // Doesn't use any modern features or vtab stuff, but is only used by them.
        mod sqlite_string
        {
            use ::
            {
                *,
            };
            
            use crate::ffi;
            use std::marker::PhantomData;
            use std::os::raw::{c_char, c_int};
            use std::ptr::NonNull;

            // Space to hold this string must be obtained
            // from an SQLite memory allocation function
            pub fn alloc(s: &str) -> *mut c_char {
                SqliteMallocString::from_str(s).into_raw()
            }
            /// A string we own that's allocated on the SQLite heap. Automatically calls
            /// `sqlite3_free` when dropped, unless `into_raw` (or `into_inner`) is called
            /// on it. If constructed from a rust string, `sqlite3_malloc` is used.
            ///
            /// It has identical representation to a nonnull `*mut c_char`, so you can use
            /// it transparently as one. It's nonnull, so Option<SqliteMallocString> can be
            /// used for nullable ones (it's still just one pointer).
            ///
            /// Most strings shouldn't use this! Only places where the string needs to be
            /// freed with `sqlite3_free`. This includes `sqlite3_extended_sql` results,
            /// some error message pointers... Note that misuse is extremely dangerous!
            ///
            /// Note that this is *not* a lossless interface. Incoming strings with internal
            /// NULs are modified, and outgoing strings which are non-UTF8 are modified.
            /// This seems unavoidable -- it tries very hard to not panic.
            #[repr(transparent)]
            pub struct SqliteMallocString {
                ptr: NonNull<c_char>,
                _boo: PhantomData<Box<[c_char]>>,
            }
            // This is owned data for a primitive type, and thus it's safe to implement
            // these. That said, nothing needs them, and they make things easier to misuse.

            // unsafe impl Send for SqliteMallocString {}
            // unsafe impl Sync for SqliteMallocString {}

            impl SqliteMallocString {
                /// SAFETY: Caller must be certain that `m` a nul-terminated c string
                /// allocated by `sqlite3_malloc`, and that SQLite expects us to free it!
                #[inline]
                pub unsafe fn from_raw_nonnull(ptr: NonNull<c_char>) -> Self {
                    Self {
                        ptr,
                        _boo: PhantomData,
                    }
                }
                /// SAFETY: Caller must be certain that `m` a nul-terminated c string
                /// allocated by `sqlite3_malloc`, and that SQLite expects us to free it!
                #[inline]
                pub unsafe fn from_raw(ptr: *mut c_char) -> Option<Self> {
                    NonNull::new(ptr).map(|p| Self::from_raw_nonnull(p))
                }
                /// Get the pointer behind `self`. After this is called, we no longer manage
                /// it.
                #[inline]
                pub fn into_inner(self) -> NonNull<c_char> {
                    let p = self.ptr;
                    std::mem::forget(self);
                    p
                }
                /// Get the pointer behind `self`. After this is called, we no longer manage
                /// it.
                #[inline]
                pub fn into_raw(self) -> *mut c_char {
                    self.into_inner().as_ptr()
                }
                /// Borrow the pointer behind `self`. We still manage it when this function
                /// returns. If you want to relinquish ownership, use `into_raw`.
                #[inline]
                pub fn as_ptr(&self) -> *const c_char {
                    self.ptr.as_ptr()
                }

                #[inline]
                pub fn as_cstr(&self) -> &std::ffi::CStr {
                    unsafe { std::ffi::CStr::from_ptr(self.as_ptr()) }
                }

                #[inline]
                pub fn to_string_lossy(&self) -> std::borrow::Cow<'_, str> {
                    self.as_cstr().to_string_lossy()
                }
                /// Convert `s` into a SQLite string.
                ///
                /// This should almost never be done except for cases like error messages or
                /// other strings that SQLite frees.
                ///
                /// If `s` contains internal NULs, we'll replace them with
                /// `NUL_REPLACE_CHAR`.
                ///
                /// Except for `debug_assert`s which may trigger during testing, this
                /// function never panics. If we hit integer overflow or the allocation
                /// fails, we call `handle_alloc_error` which aborts the program after
                /// calling a global hook.
                ///
                /// This means it's safe to use in extern "C" functions even outside
                /// `catch_unwind`.
                pub fn from_str(s: &str) -> Self {
                    let s = if s.as_bytes().contains(&0) {
                        std::borrow::Cow::Owned(make_nonnull(s))
                    } else {
                        std::borrow::Cow::Borrowed(s)
                    };
                    debug_assert!(!s.as_bytes().contains(&0));
                    let bytes: &[u8] = s.as_ref().as_bytes();
                    let src_ptr: *const c_char = bytes.as_ptr().cast();
                    let src_len = bytes.len();
                    let maybe_len_plus_1 = s.len().checked_add(1).and_then(|v| c_int::try_from(v).ok());
                    unsafe {
                        let res_ptr = maybe_len_plus_1
                            .and_then(|len_to_alloc| {
                                // `>` because we added 1.
                                debug_assert!(len_to_alloc > 0);
                                debug_assert_eq!((len_to_alloc - 1) as usize, src_len);
                                NonNull::new(ffi::sqlite3_malloc(len_to_alloc).cast::<c_char>())
                            })
                            .unwrap_or_else(|| {
                                use std::alloc::{handle_alloc_error, Layout};
                                // Report via handle_alloc_error so that it can be handled with any
                                // other allocation errors and properly diagnosed.
                                //
                                // This is safe:
                                // - `align` is never 0
                                // - `align` is always a power of 2.
                                // - `size` needs no realignment because it's guaranteed to be aligned
                                //   (everything is aligned to 1)
                                // - `size` is also never zero, although this function doesn't actually require
                                //   it now.
                                let len = s.len().saturating_add(1).min(isize::MAX as usize);
                                let layout = Layout::from_size_align_unchecked(len, 1);
                                // Note: This call does not return.
                                handle_alloc_error(layout);
                            });
                        let buf: *mut c_char = res_ptr.as_ptr().cast::<c_char>();
                        src_ptr.copy_to_nonoverlapping(buf, src_len);
                        buf.add(src_len).write(0);
                        debug_assert_eq!(std::ffi::CStr::from_ptr(res_ptr.as_ptr()).to_bytes(), bytes);
                        Self::from_raw_nonnull(res_ptr)
                    }
                }
            }

            const NUL_REPLACE: &str = "";

            #[cold]
            fn make_nonnull(v: &str) -> String {
                v.replace('\0', NUL_REPLACE)
            }

            impl Drop for SqliteMallocString {
                #[inline]
                fn drop(&mut self) {
                    unsafe { ffi::sqlite3_free(self.ptr.as_ptr().cast()) };
                }
            }

            impl std::fmt::Debug for SqliteMallocString {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    self.to_string_lossy().fmt(f)
                }
            }

            impl std::fmt::Display for SqliteMallocString {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    self.to_string_lossy().fmt(f)
                }
            }
        } pub use sqlite_string::{alloc, SqliteMallocString};
    }
    pub use util::SmallCString;
    /// Number of cached prepared statements we'll hold on to.
    pub const STATEMENT_CACHE_DEFAULT_CAPACITY: usize = 16;
    /// A macro making it more convenient to longer lists of parameters as a `&[&dyn ToSql]`.
    #[macro_export] macro_rules! params 
    {
        () => {
            &[] as &[&dyn $crate::ToSql]
        };
        ($($param:expr),+ $(,)?) => {
            &[$(&$param as &dyn $crate::ToSql),+] as &[&dyn $crate::ToSql]
        };
    }
    /// A macro making it more convenient to pass lists of named parameters as a `&[(&str, &dyn ToSql)]`.
    #[macro_export] macro_rules! named_params 
    {
        () => {
            &[] as &[(&str, &dyn $crate::ToSql)]
        };
        // Note: It's a lot more work to support this as part of the same macro as
        // `params!`, unfortunately.
        ($($param_name:literal: $param_val:expr),+ $(,)?) => {
            &[$(($param_name, &$param_val as &dyn $crate::ToSql)),+] as &[(&str, &dyn $crate::ToSql)]
        };
    }
    /// Captured identifiers in SQL.
    #[macro_export] macro_rules! prepare_and_bind 
    {
        ($conn:expr, $sql:literal) => {{
            let mut stmt = $conn.prepare($sql)?;
            $crate::__bind!(stmt $sql);
            stmt
        }};
    }
    /// Captured identifiers in SQL
    #[macro_export] macro_rules! prepare_cached_and_bind 
    {
        ($conn:expr, $sql:literal) => {{
            let mut stmt = $conn.prepare_cached($sql)?;
            $crate::__bind!(stmt $sql);
            stmt
        }};
    }
    /// A typedef of the result returned by many methods.
    pub type Result<T, E = Error> = result::Result<T, E>;
    /// See the [method documentation](#tymethod.optional).
    pub trait OptionalExtension<T> 
    {
        /// Converts a `Result<T>` into a `Result<Option<T>>`.
        ///
        /// By default, Rusqlite treats 0 rows being returned from a query that is
        /// expected to return 1 row as an error. This method will
        /// handle that error, and give you back an `Option<T>` instead.
        fn optional(self) -> Result<Option<T>>;
    }

    impl<T> OptionalExtension<T> for Result<T> 
    {
        fn optional(self) -> Result<Option<T>> {
            match self {
                Ok(value) => Ok(Some(value)),
                Err(Error::QueryReturnedNoRows) => Ok(None),
                Err(e) => Err(e),
            }
        }
    }

    unsafe fn errmsg_to_string(errmsg: *const c_char) -> String 
    {
        CStr::from_ptr(errmsg).to_string_lossy().into_owned()
    }

    fn str_to_cstring(s: &str) -> Result<SmallCString> 
    {
        Ok(SmallCString::new(s)?)
    }
    /// Returns `Ok((string ptr, len as c_int, SQLITE_STATIC | SQLITE_TRANSIENT))` normally.
    fn str_for_sqlite(s: &[u8]) -> Result<(*const c_char, c_int, ffi::sqlite3_destructor_type)> 
    {
        let len = len_as_c_int(s.len())?;
        let (ptr, dtor_info) = if len != 0 {
            (s.as_ptr().cast::<c_char>(), ffi::SQLITE_TRANSIENT())
        } else {
            // Return a pointer guaranteed to live forever
            ("".as_ptr().cast::<c_char>(), ffi::SQLITE_STATIC())
        };
        Ok((ptr, len, dtor_info))
    }

    // Helper to cast to c_int safely, returning the correct error type if the cast failed.
    fn len_as_c_int(len: usize) -> Result<c_int> 
    {
        if len >= (c_int::MAX as usize) {
            Err(Error::SqliteFailure(
                ffi::Error::new(ffi::SQLITE_TOOBIG),
                None,
            ))
        } else {
            Ok(len as c_int)
        }
    }

    #[cfg(unix)]
    fn path_to_cstring(p: &Path) -> Result<CString> 
    {
        use std::os::unix::ffi::OsStrExt;
        Ok(CString::new(p.as_os_str().as_bytes())?)
    }

    #[cfg(not(unix))]
    fn path_to_cstring(p: &Path) -> Result<CString> 
    {
        let s = p.to_str().ok_or_else(|| Error::InvalidPath(p.to_owned()))?;
        Ok(CString::new(s)?)
    }
    /// Name for a database within a SQLite connection.
    #[derive(Copy, Clone, Debug)]
    pub enum DatabaseName<'a> 
    {
        /// The main database.
        Main,

        /// The temporary database (e.g., any "CREATE TEMPORARY TABLE" tables).
        Temp,

        /// A database that has been attached via "ATTACH DATABASE ...".
        Attached(&'a str),
    }
    /// Shorthand for [`DatabaseName::Main`].
    pub const MAIN_DB: DatabaseName<'static> = DatabaseName::Main;
    /// Shorthand for [`DatabaseName::Temp`].
    pub const TEMP_DB: DatabaseName<'static> = DatabaseName::Temp;
    
    impl DatabaseName<'_> 
    {
        #[inline]
        fn as_cstring(&self) -> Result<SmallCString> {
            use self::DatabaseName::{Attached, Main, Temp};
            match *self {
                Main => str_to_cstring("main"), // TODO C-string literals
                Temp => str_to_cstring("temp"),
                Attached(s) => str_to_cstring(s),
            }
        }
    }
    /// A connection to a SQLite database.
    pub struct Connection
    {
        db: RefCell<InnerConnection>,
        cache: StatementCache,
        transaction_behavior: TransactionBehavior,
    }

    unsafe impl Send for Connection {}

    impl Drop for Connection 
    {
        #[inline]
        fn drop(&mut self) {
            self.flush_prepared_statement_cache();
        }
    }

    impl Connection 
    {
        /// Open a new connection to a SQLite database.
        #[inline]
        pub fn open<P: AsRef<Path>>(path: P) -> Result<Connection> {
            let flags = OpenFlags::default();
            Connection::open_with_flags(path, flags)
        }
        /// Open a new connection to an in-memory SQLite database.
        #[inline]
        pub fn open_in_memory() -> Result<Connection> {
            let flags = OpenFlags::default();
            Connection::open_in_memory_with_flags(flags)
        }
        /// Open a new connection to a SQLite database.
        #[inline]
        pub fn open_with_flags<P: AsRef<Path>>(path: P, flags: OpenFlags) -> Result<Connection> {
            let c_path = path_to_cstring(path.as_ref())?;
            InnerConnection::open_with_flags(&c_path, flags, None).map(|db| Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
        /// Open a new connection to a SQLite database using the specific flags and vfs name.
        #[inline]
        pub fn open_with_flags_and_vfs<P: AsRef<Path>>(
            path: P,
            flags: OpenFlags,
            vfs: &str,
        ) -> Result<Connection> {
            let c_path = path_to_cstring(path.as_ref())?;
            let c_vfs = str_to_cstring(vfs)?;
            InnerConnection::open_with_flags(&c_path, flags, Some(&c_vfs)).map(|db| Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
        /// Open a new connection to an in-memory SQLite database.
        #[inline]
        pub fn open_in_memory_with_flags(flags: OpenFlags) -> Result<Connection> {
            Connection::open_with_flags(":memory:", flags)
        }
        /// Open a new connection to an in-memory SQLite database using the specific flags and vfs name.
        #[inline]
        pub fn open_in_memory_with_flags_and_vfs(flags: OpenFlags, vfs: &str) -> Result<Connection> {
            Connection::open_with_flags_and_vfs(":memory:", flags, vfs)
        }
        /// Convenience method to run multiple SQL statements (that cannot take any parameters).
        pub fn execute_batch(&self, sql: &str) -> Result<()> {
            let mut sql = sql;
            while !sql.is_empty() {
                let stmt = self.prepare(sql)?;
                if !stmt.stmt.is_null() && stmt.step()? && cfg!(feature = "extra_check") {
                    // Some PRAGMA may return rows
                    return Err(Error::ExecuteReturnedResults);
                }
                let tail = stmt.stmt.tail();
                if tail == 0 || tail >= sql.len() {
                    break;
                }
                sql = &sql[tail..];
            }
            Ok(())
        }
        /// Convenience method to prepare and execute a single SQL statement.
        #[inline]
        pub fn execute<P: Params>(&self, sql: &str, params: P) -> Result<usize> {
            self.prepare(sql)
                .and_then(|mut stmt| stmt.check_no_tail().and_then(|()| stmt.execute(params)))
        }
        /// Returns the path to the database file, if one exists and is known.
        #[inline]
        pub fn path(&self) -> Option<&str> {
            unsafe {
                let db = self.handle();
                let db_name = DatabaseName::Main.as_cstring().unwrap();
                let db_filename = ffi::sqlite3_db_filename(db, db_name.as_ptr());
                if db_filename.is_null() {
                    None
                } else {
                    CStr::from_ptr(db_filename).to_str().ok()
                }
            }
        }
        /// Attempts to free as much heap memory as possible from the database connection.
        #[inline]
        #[cfg(feature = "release_memory")]
        pub fn release_memory(&self) -> Result<()> {
            self.db.borrow_mut().release_memory()
        }
        /// Get the SQLite rowid of the most recent successful INSERT.
        #[inline]
        pub fn last_insert_rowid(&self) -> i64 {
            self.db.borrow_mut().last_insert_rowid()
        }
        /// Convenience method to execute a query that is expected to return a single row.
        #[inline]
        pub fn query_row<T, P, F>(&self, sql: &str, params: P, f: F) -> Result<T>
        where
            P: Params,
            F: FnOnce(&Row<'_>) -> Result<T>,
        {
            let mut stmt = self.prepare(sql)?;
            stmt.check_no_tail()?;
            stmt.query_row(params, f)
        }

        // https://sqlite.org/tclsqlite.html#onecolumn
        #[cfg(test)]
        pub fn one_column<T: types::FromSql>(&self, sql: &str) -> Result<T> {
            self.query_row(sql, [], |r| r.get(0))
        }
        /// Convenience method to execute a query that is expected to return a
        /// single row, and execute a mapping via `f` on that returned row with
        /// the possibility of failure.
        #[inline]
        pub fn query_row_and_then<T, E, P, F>(&self, sql: &str, params: P, f: F) -> Result<T, E>
        where
            P: Params,
            F: FnOnce(&Row<'_>) -> Result<T, E>,
            E: From<Error>,
        {
            let mut stmt = self.prepare(sql)?;
            stmt.check_no_tail()?;
            let mut rows = stmt.query(params)?;

            rows.get_expected_row().map_err(E::from).and_then(f)
        }
        /// Prepare a SQL statement for execution.
        #[inline]
        pub fn prepare(&self, sql: &str) -> Result<Statement<'_>> {
            self.prepare_with_flags(sql, PrepFlags::default())
        }
        /// Prepare a SQL statement for execution.
        #[inline]
        pub fn prepare_with_flags(&self, sql: &str, flags: PrepFlags) -> Result<Statement<'_>> {
            self.db.borrow_mut().prepare(self, sql, flags)
        }
        /// Close the SQLite connection.
        #[inline]
        pub fn close(self) -> Result<(), (Connection, Error)> {
            self.flush_prepared_statement_cache();
            let r = self.db.borrow_mut().close();
            r.map_err(move |err| (self, err))
        }
        /// Enable loading of SQLite extensions from both SQL queries and Rust.
        #[cfg(feature = "load_extension")]
        #[cfg_attr(docsrs, doc(cfg(feature = "load_extension")))]
        #[inline]
        pub unsafe fn load_extension_enable(&self) -> Result<()> {
            self.db.borrow_mut().enable_load_extension(1)
        }
        /// Disable loading of SQLite extensions.
        #[cfg(feature = "load_extension")]
        #[cfg_attr(docsrs, doc(cfg(feature = "load_extension")))]
        #[inline]
        pub fn load_extension_disable(&self) -> Result<()> {
            // It's always safe to turn off extension loading.
            unsafe { self.db.borrow_mut().enable_load_extension(0) }
        }
        /// Load the SQLite extension at `dylib_path`. `dylib_path` is passed
        /// through to `sqlite3_load_extension`, which may attempt OS-specific
        /// modifications if the file cannot be loaded directly.
        #[cfg(feature = "load_extension")]
        #[cfg_attr(docsrs, doc(cfg(feature = "load_extension")))]
        #[inline]
        pub unsafe fn load_extension<P: AsRef<Path>>(
            &self,
            dylib_path: P,
            entry_point: Option<&str>,
        ) -> Result<()> {
            self.db
                .borrow_mut()
                .load_extension(dylib_path.as_ref(), entry_point)
        }
        /// Get access to the underlying SQLite database connection handle.
        ///
        /// # Warning
        ///
        /// You should not need to use this function. If you do need to, please
        /// [open an issue on the rusqlite repository](https://github.com/rusqlite/rusqlite/issues) and describe
        /// your use case.
        ///
        /// # Safety
        ///
        /// This function is unsafe because it gives you raw access
        /// to the SQLite connection, and what you do with it could impact the
        /// safety of this `Connection`.
        #[inline]
        pub unsafe fn handle(&self) -> *mut ffi::sqlite3 {
            self.db.borrow().db()
        }
        /// Create a `Connection` from a raw handle.
        ///
        /// The underlying SQLite database connection handle will not be closed when
        /// the returned connection is dropped/closed.
        ///
        /// # Safety
        ///
        /// This function is unsafe because improper use may impact the Connection.
        #[inline]
        pub unsafe fn from_handle(db: *mut ffi::sqlite3) -> Result<Connection> {
            let db = InnerConnection::new(db, false);
            Ok(Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
        /// Helper to register an SQLite extension written in Rust.
        /// For [persistent](https://sqlite.org/loadext.html#persistent_loadable_extensions) extension,
        /// `init` should return `Ok(true)`.
        /// # Safety
        /// * Results are undefined if `init` does not just register features.
        #[cfg(feature = "loadable_extension")]
        #[cfg_attr(docsrs, doc(cfg(feature = "loadable_extension")))]
        pub unsafe fn extension_init2(
            db: *mut ffi::sqlite3,
            pz_err_msg: *mut *mut c_char,
            p_api: *mut ffi::sqlite3_api_routines,
            init: fn(Connection) -> Result<bool>,
        ) -> c_int {
            if p_api.is_null() {
                return ffi::SQLITE_ERROR;
            }
            match ffi::rusqlite_extension_init2(p_api)
                .map_err(Error::from)
                .and(Connection::from_handle(db))
                .and_then(init)
            {
                Err(err) => to_sqlite_error(&err, pz_err_msg),
                Ok(true) => ffi::SQLITE_OK_LOAD_PERMANENTLY,
                _ => ffi::SQLITE_OK,
            }
        }
        /// Create a `Connection` from a raw owned handle.
        ///
        /// The returned connection will attempt to close the inner connection
        /// when dropped/closed. This function should only be called on connections
        /// owned by the caller.
        ///
        /// # Safety
        ///
        /// This function is unsafe because improper use may impact the Connection.
        /// In particular, it should only be called on connections created
        /// and owned by the caller, e.g. as a result of calling
        /// `ffi::sqlite3_open`().
        #[inline]
        pub unsafe fn from_handle_owned(db: *mut ffi::sqlite3) -> Result<Connection> {
            let db = InnerConnection::new(db, true);
            Ok(Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
        /// Get access to a handle that can be used to interrupt long-running
        /// queries from another thread.
        #[inline]
        pub fn get_interrupt_handle(&self) -> InterruptHandle {
            self.db.borrow().get_interrupt_handle()
        }

        #[inline]
        fn decode_result(&self, code: c_int) -> Result<()> {
            self.db.borrow().decode_result(code)
        }
        /// Return the number of rows modified, inserted or deleted by the most
        /// recently completed INSERT, UPDATE or DELETE statement on the database
        /// connection.
        ///
        /// See <https://www.sqlite.org/c3ref/changes.html>
        #[inline]
        pub fn changes(&self) -> u64 {
            self.db.borrow().changes()
        }
        /// Return the total number of rows modified, inserted or deleted by all
        /// completed INSERT, UPDATE or DELETE statements since the database
        /// connection was opened, including those executed as part of trigger programs.
        ///
        /// See <https://www.sqlite.org/c3ref/total_changes.html>
        #[inline]
        pub fn total_changes(&self) -> u64 {
            self.db.borrow().total_changes()
        }
        /// Test for auto-commit mode.
        /// Autocommit mode is on by default.
        #[inline]
        pub fn is_autocommit(&self) -> bool {
            self.db.borrow().is_autocommit()
        }
        /// Determine if all associated prepared statements have been reset.
        #[inline]
        pub fn is_busy(&self) -> bool {
            self.db.borrow().is_busy()
        }
        /// Flush caches to disk mid-transaction
        pub fn cache_flush(&self) -> Result<()> {
            self.db.borrow_mut().cache_flush()
        }
        /// Determine if a database is read-only
        pub fn is_readonly(&self, db_name: DatabaseName<'_>) -> Result<bool> {
            self.db.borrow().db_readonly(db_name)
        }
        /// Return the schema name for a database connection
        ///
        /// ## Failure
        ///
        /// Return an `Error::InvalidDatabaseIndex` if `index` is out of range.
        #[cfg(feature = "modern_sqlite")] // 3.39.0
        #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
        pub fn db_name(&self, index: usize) -> Result<String> {
            unsafe {
                let db = self.handle();
                let name = ffi::sqlite3_db_name(db, index as c_int);
                if name.is_null() {
                    Err(Error::InvalidDatabaseIndex(index))
                } else {
                    Ok(CStr::from_ptr(name).to_str()?.to_owned())
                }
            }
        }
        /// Determine whether an interrupt is currently in effect
        #[cfg(feature = "modern_sqlite")] // 3.41.0
        #[cfg_attr(docsrs, doc(cfg(feature = "modern_sqlite")))]
        pub fn is_interrupted(&self) -> bool {
            self.db.borrow().is_interrupted()
        }
    }

    impl fmt::Debug for Connection 
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Connection")
                .field("path", &self.path())
                .finish()
        }
    }
    /// Batch iterator
    #[derive(Debug)]
    pub struct Batch<'conn, 'sql> 
    {
        conn: &'conn Connection,
        sql: &'sql str,
        tail: usize,
    }

    impl<'conn, 'sql> Batch<'conn, 'sql> 
    {
        /// Constructor
        pub fn new(conn: &'conn Connection, sql: &'sql str) -> Batch<'conn, 'sql> {
            Batch { conn, sql, tail: 0 }
        }
        /// Iterates on each batch statements.
        ///
        /// Returns `Ok(None)` when batch is completed.
         // fallible iterator
        pub fn next(&mut self) -> Result<Option<Statement<'conn>>> {
            while self.tail < self.sql.len() {
                let sql = &self.sql[self.tail..];
                let next = self.conn.prepare(sql)?;
                let tail = next.stmt.tail();
                if tail == 0 {
                    self.tail = self.sql.len();
                } else {
                    self.tail += tail;
                }
                if next.stmt.is_null() {
                    continue;
                }
                return Ok(Some(next));
            }
            Ok(None)
        }
    }

    impl<'conn> Iterator for Batch<'conn, '_> 
    {
        type Item = Result<Statement<'conn>>;

        fn next(&mut self) -> Option<Result<Statement<'conn>>> {
            self.next().transpose()
        }
    }

    bitflags::bitflags! 
    {
        /// Flags for opening SQLite database connections. See
        /// [sqlite3_open_v2](https://www.sqlite.org/c3ref/open.html) for details.
        ///
        /// The default open flags are `SQLITE_OPEN_READ_WRITE | SQLITE_OPEN_CREATE
        /// | SQLITE_OPEN_URI | SQLITE_OPEN_NO_MUTEX`. See [`Connection::open`] for
        /// some discussion about these flags.
        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
        #[repr(C)]
        pub struct OpenFlags: ::std::os::raw::c_int {
            /// The database is opened in read-only mode.
            /// If the database does not already exist, an error is returned.
            const SQLITE_OPEN_READ_ONLY = ffi::SQLITE_OPEN_READONLY;
            /// The database is opened for reading and writing if possible,
            /// or reading only if the file is write-protected by the operating system.
            /// In either case the database must already exist, otherwise an error is returned.
            const SQLITE_OPEN_READ_WRITE = ffi::SQLITE_OPEN_READWRITE;
            /// The database is created if it does not already exist
            const SQLITE_OPEN_CREATE = ffi::SQLITE_OPEN_CREATE;
            /// The filename can be interpreted as a URI if this flag is set.
            const SQLITE_OPEN_URI = ffi::SQLITE_OPEN_URI;
            /// The database will be opened as an in-memory database.
            const SQLITE_OPEN_MEMORY = ffi::SQLITE_OPEN_MEMORY;
            /// The new database connection will not use a per-connection mutex (the
            /// connection will use the "multi-thread" threading mode, in SQLite
            /// parlance).
            ///
            /// This is used by default, as proper `Send`/`Sync` usage (in
            /// particular, the fact that [`Connection`] does not implement `Sync`)
            /// ensures thread-safety without the need to perform locking around all
            /// calls.
            const SQLITE_OPEN_NO_MUTEX = ffi::SQLITE_OPEN_NOMUTEX;
            /// The new database connection will use a per-connection mutex -- the
            /// "serialized" threading mode, in SQLite parlance.
            ///
            /// # Caveats
            ///
            /// This flag should probably never be used with `rusqlite`, as we
            /// ensure thread-safety statically (we implement [`Send`] and not
            /// [`Sync`]). That said
            ///
            /// Critically, even if this flag is used, the [`Connection`] is not
            /// safe to use across multiple threads simultaneously. To access a
            /// database from multiple threads, you should either create multiple
            /// connections, one for each thread (if you have very many threads,
            /// wrapping the `rusqlite::Connection` in a mutex is also reasonable).
            ///
            /// This is both because of the additional per-connection state stored
            /// by `rusqlite` (for example, the prepared statement cache), and
            /// because not all of SQLites functions are fully thread safe, even in
            /// serialized/`SQLITE_OPEN_FULLMUTEX` mode.
            ///
            /// All that said, it's fairly harmless to enable this flag with
            /// `rusqlite`, it will just slow things down while providing no
            /// benefit.
            const SQLITE_OPEN_FULL_MUTEX = ffi::SQLITE_OPEN_FULLMUTEX;
            /// The database is opened with shared cache enabled.
            ///
            /// This is frequently useful for in-memory connections, but note that
            /// broadly speaking it's discouraged by SQLite itself, which states
            /// "Any use of shared cache is discouraged" in the official
            /// [documentation](https://www.sqlite.org/c3ref/enable_shared_cache.html).
            const SQLITE_OPEN_SHARED_CACHE = 0x0002_0000;
            /// The database is opened shared cache disabled.
            const SQLITE_OPEN_PRIVATE_CACHE = 0x0004_0000;
            /// The database filename is not allowed to be a symbolic link. (3.31.0)
            const SQLITE_OPEN_NOFOLLOW = 0x0100_0000;
            /// Extended result codes. (3.37.0)
            const SQLITE_OPEN_EXRESCODE = 0x0200_0000;
        }
    }

    impl Default for OpenFlags 
    {
        #[inline]
        fn default() -> OpenFlags {
            // Note: update the `Connection::open` and top-level `OpenFlags` docs if
            // you change these.
            OpenFlags::SQLITE_OPEN_READ_WRITE
                | OpenFlags::SQLITE_OPEN_CREATE
                | OpenFlags::SQLITE_OPEN_NO_MUTEX
                | OpenFlags::SQLITE_OPEN_URI
        }
    }

    bitflags::bitflags! 
    {
        /// Prepare flags. See
        /// [sqlite3_prepare_v3](https://sqlite.org/c3ref/c_prepare_normalize.html) for details.
        #[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]
        #[repr(C)]
        pub struct PrepFlags: ::std::os::raw::c_uint {
            /// A hint to the query planner that the prepared statement will be retained for a long time and probably reused many times.
            const SQLITE_PREPARE_PERSISTENT = 0x01;
            /// Causes the SQL compiler to return an error (error code SQLITE_ERROR) if the statement uses any virtual tables.
            const SQLITE_PREPARE_NO_VTAB = 0x04;
        }
    }
    /// Allows interrupting a long-running computation.
    pub struct InterruptHandle 
    {
        db_lock: Arc<Mutex<*mut ffi::sqlite3>>,
    }

    unsafe impl Send for InterruptHandle {}
    unsafe impl Sync for InterruptHandle {}

    impl InterruptHandle 
    {
        /// Interrupt the query currently executing on another thread. This will
        /// cause that query to fail with a `SQLITE3_INTERRUPT` error.
        pub fn interrupt(&self) {
            let db_handle = self.db_lock.lock().unwrap();
            if !db_handle.is_null() {
                unsafe { ffi::sqlite3_interrupt(*db_handle) }
            }
        }
    }
}

pub mod yaml_rust
{
    //! YAML 1.2 implementation in pure Rust.
    use ::
    {
        *,
    };

    pub mod emitter
    {
        use ::
        {
            *,
        };
        /*
        use std::convert::From;
        use std::error::Error;
        use std::fmt::{self, Display};
        use crate::yaml::{Hash, Yaml};
        */
        pub type EmitResult = Result<(), EmitError>;

        #[derive(Copy, Clone, Debug)]
        pub enum EmitError 
        {
            FmtError(fmt::Error),
            BadHashmapKey,
        }

        impl Error for EmitError 
        {
            fn cause(&self) -> Option<&dyn Error> {
                None
            }
        }

        impl Display for EmitError 
        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                match *self {
                    EmitError::FmtError(ref err) => Display::fmt(err, formatter),
                    EmitError::BadHashmapKey => formatter.write_str("bad hashmap key"),
                }
            }
        }

        impl From<fmt::Error> for EmitError 
        {
            fn from(f: fmt::Error) -> Self {
                EmitError::FmtError(f)
            }
        }

        pub struct YamlEmitter<'a> 
        {
            writer: &'a mut dyn fmt::Write,
            best_indent: usize,
            compact: bool,

            level: isize,
        }
        
        pub fn escape_str(wr: &mut dyn fmt::Write, v: &str) -> Result<(), fmt::Error> 
        {
            wr.write_str("\"")?;

            let mut start = 0;

            for (i, byte) in v.bytes().enumerate() {
                let escaped = match byte {
                    b'"' => "\\\"",
                    b'\\' => "\\\\",
                    b'\x00' => "\\u0000",
                    b'\x01' => "\\u0001",
                    b'\x02' => "\\u0002",
                    b'\x03' => "\\u0003",
                    b'\x04' => "\\u0004",
                    b'\x05' => "\\u0005",
                    b'\x06' => "\\u0006",
                    b'\x07' => "\\u0007",
                    b'\x08' => "\\b",
                    b'\t' => "\\t",
                    b'\n' => "\\n",
                    b'\x0b' => "\\u000b",
                    b'\x0c' => "\\f",
                    b'\r' => "\\r",
                    b'\x0e' => "\\u000e",
                    b'\x0f' => "\\u000f",
                    b'\x10' => "\\u0010",
                    b'\x11' => "\\u0011",
                    b'\x12' => "\\u0012",
                    b'\x13' => "\\u0013",
                    b'\x14' => "\\u0014",
                    b'\x15' => "\\u0015",
                    b'\x16' => "\\u0016",
                    b'\x17' => "\\u0017",
                    b'\x18' => "\\u0018",
                    b'\x19' => "\\u0019",
                    b'\x1a' => "\\u001a",
                    b'\x1b' => "\\u001b",
                    b'\x1c' => "\\u001c",
                    b'\x1d' => "\\u001d",
                    b'\x1e' => "\\u001e",
                    b'\x1f' => "\\u001f",
                    b'\x7f' => "\\u007f",
                    _ => continue,
                };

                if start < i {
                    wr.write_str(&v[start..i])?;
                }

                wr.write_str(escaped)?;

                start = i + 1;
            }

            if start != v.len() {
                wr.write_str(&v[start..])?;
            }

            wr.write_str("\"")?;
            Ok(())
        }

        impl<'a> YamlEmitter<'a> 
        {
            pub fn new(writer: &'a mut dyn fmt::Write) -> YamlEmitter {
                YamlEmitter {
                    writer,
                    best_indent: 2,
                    compact: true,
                    level: -1,
                }
            }
            /// Set 'compact inline notation' on or off, as described for block
            /// [sequences](http://www.yaml.org/spec/1.2/spec.html#id2797382)
            /// and
            /// [mappings](http://www.yaml.org/spec/1.2/spec.html#id2798057).
            ///
            /// In this form, blocks cannot have any properties (such as anchors
            /// or tags), which should be OK, because this emitter doesn't
            /// (currently) emit those anyways.
            pub fn compact(&mut self, compact: bool) {
                self.compact = compact;
            }
            /// Determine if this emitter is using 'compact inline notation'.
            pub fn is_compact(&self) -> bool {
                self.compact
            }

            pub fn dump(&mut self, doc: &Yaml) -> EmitResult {
                // write DocumentStart
                writeln!(self.writer, "---")?;
                self.level = -1;
                self.emit_node(doc)
            }

            fn write_indent(&mut self) -> EmitResult {
                if self.level <= 0 {
                    return Ok(());
                }
                for _ in 0..self.level {
                    for _ in 0..self.best_indent {
                        write!(self.writer, " ")?;
                    }
                }
                Ok(())
            }

            fn emit_node(&mut self, node: &Yaml) -> EmitResult {
                match *node {
                    Yaml::Array(ref v) => self.emit_array(v),
                    Yaml::Hash(ref h) => self.emit_hash(h),
                    Yaml::String(ref v) => {
                        if need_quotes(v) {
                            escape_str(self.writer, v)?;
                        } else {
                            write!(self.writer, "{}", v)?;
                        }
                        Ok(())
                    }
                    Yaml::Boolean(v) => {
                        if v {
                            self.writer.write_str("true")?;
                        } else {
                            self.writer.write_str("false")?;
                        }
                        Ok(())
                    }
                    Yaml::Integer(v) => {
                        write!(self.writer, "{}", v)?;
                        Ok(())
                    }
                    Yaml::Real(ref v) => {
                        write!(self.writer, "{}", v)?;
                        Ok(())
                    }
                    Yaml::Null | Yaml::BadValue => {
                        write!(self.writer, "~")?;
                        Ok(())
                    }
                    // XXX(chenyh) Alias
                    _ => Ok(()),
                }
            }

            fn emit_array(&mut self, v: &[Yaml]) -> EmitResult {
                if v.is_empty() {
                    write!(self.writer, "[]")?;
                } else {
                    self.level += 1;
                    for (cnt, x) in v.iter().enumerate() {
                        if cnt > 0 {
                            writeln!(self.writer)?;
                            self.write_indent()?;
                        }
                        write!(self.writer, "-")?;
                        self.emit_val(true, x)?;
                    }
                    self.level -= 1;
                }
                Ok(())
            }

            fn emit_hash(&mut self, h: &Hash) -> EmitResult {
                if h.is_empty() {
                    self.writer.write_str("{}")?;
                } else {
                    self.level += 1;
                    for (cnt, (k, v)) in h.iter().enumerate() {
                        let complex_key = match *k {
                            Yaml::Hash(_) | Yaml::Array(_) => true,
                            _ => false,
                        };
                        if cnt > 0 {
                            writeln!(self.writer)?;
                            self.write_indent()?;
                        }
                        if complex_key {
                            write!(self.writer, "?")?;
                            self.emit_val(true, k)?;
                            writeln!(self.writer)?;
                            self.write_indent()?;
                            write!(self.writer, ":")?;
                            self.emit_val(true, v)?;
                        } else {
                            self.emit_node(k)?;
                            write!(self.writer, ":")?;
                            self.emit_val(false, v)?;
                        }
                    }
                    self.level -= 1;
                }
                Ok(())
            }
            /// Emit a yaml as a hash or array value: i.e., which should appear
            /// following a ":" or "-", either after a space, or on a new line.
            /// If `inline` is true, then the preceding characters are distinct
            /// and short enough to respect the compact flag.
            fn emit_val(&mut self, inline: bool, val: &Yaml) -> EmitResult {
                match *val {
                    Yaml::Array(ref v) => {
                        if (inline && self.compact) || v.is_empty() {
                            write!(self.writer, " ")?;
                        } else {
                            writeln!(self.writer)?;
                            self.level += 1;
                            self.write_indent()?;
                            self.level -= 1;
                        }
                        self.emit_array(v)
                    }
                    Yaml::Hash(ref h) => {
                        if (inline && self.compact) || h.is_empty() {
                            write!(self.writer, " ")?;
                        } else {
                            writeln!(self.writer)?;
                            self.level += 1;
                            self.write_indent()?;
                            self.level -= 1;
                        }
                        self.emit_hash(h)
                    }
                    _ => {
                        write!(self.writer, " ")?;
                        self.emit_node(val)
                    }
                }
            }
        }
        /// Check if the string requires quoting.
        pub fn need_quotes(string: &str) -> bool {
            fn need_quotes_spaces(string: &str) -> bool {
                string.starts_with(' ') || string.ends_with(' ')
            }

            string == ""
                || need_quotes_spaces(string)
                || string.starts_with(|character: char| match character {
                    '&' | '*' | '?' | '|' | '-' | '<' | '>' | '=' | '!' | '%' | '@' => true,
                    _ => false,
                })
                || string.contains(|character: char| match character {
                    ':'
                    | '{'
                    | '}'
                    | '['
                    | ']'
                    | ','
                    | '#'
                    | '`'
                    | '\"'
                    | '\''
                    | '\\'
                    | '\0'..='\x06'
                    | '\t'
                    | '\n'
                    | '\r'
                    | '\x0e'..='\x1a'
                    | '\x1c'..='\x1f' => true,
                    _ => false,
                })
                || [
                    // http://yaml.org/type/bool.html
                    // Note: 'y', 'Y', 'n', 'N', is not quoted deliberately, as in libyaml. PyYAML also parse
                    // them as string, not booleans, although it is violating the YAML 1.1 specification.
                    // See https://github.com/dtolnay/serde-yaml/pull/83#discussion_r152628088.
                    "yes", "Yes", "YES", "no", "No", "NO", "True", "TRUE", "true", "False", "FALSE",
                    "false", "on", "On", "ON", "off", "Off", "OFF",
                    // http://yaml.org/type/null.html
                    "null", "Null", "NULL", "~",
                ]
                .contains(&string)
                || string.starts_with('.')
                || string.starts_with("0x")
                || string.parse::<i64>().is_ok()
                || string.parse::<f64>().is_ok()
        }
    }

    pub mod parser
    {
        use ::
        {
            *,
        };
        use crate::scanner::*;
        use std::collections::HashMap;

        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        enum State {
            StreamStart,
            ImplicitDocumentStart,
            DocumentStart,
            DocumentContent,
            DocumentEnd,
            BlockNode,
            // BlockNodeOrIndentlessSequence,
            // FlowNode,
            BlockSequenceFirstEntry,
            BlockSequenceEntry,
            IndentlessSequenceEntry,
            BlockMappingFirstKey,
            BlockMappingKey,
            BlockMappingValue,
            FlowSequenceFirstEntry,
            FlowSequenceEntry,
            FlowSequenceEntryMappingKey,
            FlowSequenceEntryMappingValue,
            FlowSequenceEntryMappingEnd,
            FlowMappingFirstKey,
            FlowMappingKey,
            FlowMappingValue,
            FlowMappingEmptyValue,
            End,
        }
        /// `Event` is used with the low-level event base parsing API,
        /// see `EventReceiver` trait.
        #[derive(Clone, PartialEq, Debug, Eq)]
        pub enum Event {
            /// Reserved for internal use
            Nothing,
            StreamStart,
            StreamEnd,
            DocumentStart,
            DocumentEnd,
            /// Refer to an anchor ID
            Alias(usize),
            /// Value, style, anchor_id, tag
            Scalar(String, TScalarStyle, usize, Option<TokenType>),
            /// Anchor ID
            SequenceStart(usize),
            SequenceEnd,
            /// Anchor ID
            MappingStart(usize),
            MappingEnd,
        }

        impl Event {
            fn empty_scalar() -> Event {
                // a null scalar
                Event::Scalar("~".to_owned(), TScalarStyle::Plain, 0, None)
            }

            fn empty_scalar_with_anchor(anchor: usize, tag: Option<TokenType>) -> Event {
                Event::Scalar("".to_owned(), TScalarStyle::Plain, anchor, tag)
            }
        }

        #[derive(Debug)]
        pub struct Parser<T> {
            scanner: Scanner<T>,
            states: Vec<State>,
            state: State,
            marks: Vec<Marker>,
            token: Option<Token>,
            current: Option<(Event, Marker)>,
            anchors: HashMap<String, usize>,
            anchor_id: usize,
        }

        pub trait EventReceiver {
            fn on_event(&mut self, ev: Event);
        }

        pub trait MarkedEventReceiver {
            fn on_event(&mut self, ev: Event, _mark: Marker);
        }

        impl<R: EventReceiver> MarkedEventReceiver for R {
            fn on_event(&mut self, ev: Event, _mark: Marker) {
                self.on_event(ev)
            }
        }

        pub type ParseResult = Result<(Event, Marker), ScanError>;

        impl<T: Iterator<Item = char>> Parser<T> {
            pub fn new(src: T) -> Parser<T> {
                Parser {
                    scanner: Scanner::new(src),
                    states: Vec::new(),
                    state: State::StreamStart,
                    marks: Vec::new(),
                    token: None,
                    current: None,

                    anchors: HashMap::new(),
                    // valid anchor_id starts from 1
                    anchor_id: 1,
                }
            }

            pub fn peek(&mut self) -> Result<&(Event, Marker), ScanError> {
                match self.current {
                    Some(ref x) => Ok(x),
                    None => {
                        self.current = Some(self.next()?);
                        self.peek()
                    }
                }
            }

            pub fn next(&mut self) -> ParseResult {
                match self.current {
                    None => self.parse(),
                    Some(_) => Ok(self.current.take().unwrap()),
                }
            }

            fn peek_token(&mut self) -> Result<&Token, ScanError> {
                match self.token {
                    None => {
                        self.token = Some(self.scan_next_token()?);
                        Ok(self.token.as_ref().unwrap())
                    }
                    Some(ref tok) => Ok(tok),
                }
            }

            fn scan_next_token(&mut self) -> Result<Token, ScanError> {
                let token = self.scanner.next();
                match token {
                    None => match self.scanner.get_error() {
                        None => Err(ScanError::new(self.scanner.mark(), "unexpected eof")),
                        Some(e) => Err(e),
                    },
                    Some(tok) => Ok(tok),
                }
            }

            fn fetch_token(&mut self) -> Token {
                self.token
                    .take()
                    .expect("fetch_token needs to be preceded by peek_token")
            }

            fn skip(&mut self) {
                self.token = None;
                //self.peek_token();
            }
            fn pop_state(&mut self) {
                self.state = self.states.pop().unwrap()
            }
            fn push_state(&mut self, state: State) {
                self.states.push(state);
            }

            fn parse(&mut self) -> ParseResult {
                if self.state == State::End {
                    return Ok((Event::StreamEnd, self.scanner.mark()));
                }
                let (ev, mark) = self.state_machine()?;
                // println!("EV {:?}", ev);
                Ok((ev, mark))
            }

            pub fn load<R: MarkedEventReceiver>(
                &mut self,
                recv: &mut R,
                multi: bool,
            ) -> Result<(), ScanError> {
                if !self.scanner.stream_started() {
                    let (ev, mark) = self.next()?;
                    assert_eq!(ev, Event::StreamStart);
                    recv.on_event(ev, mark);
                }

                if self.scanner.stream_ended() {
                    // XXX has parsed?
                    recv.on_event(Event::StreamEnd, self.scanner.mark());
                    return Ok(());
                }
                loop {
                    let (ev, mark) = self.next()?;
                    if ev == Event::StreamEnd {
                        recv.on_event(ev, mark);
                        return Ok(());
                    }
                    // clear anchors before a new document
                    self.anchors.clear();
                    self.load_document(ev, mark, recv)?;
                    if !multi {
                        break;
                    }
                }
                Ok(())
            }

            fn load_document<R: MarkedEventReceiver>(
                &mut self,
                first_ev: Event,
                mark: Marker,
                recv: &mut R,
            ) -> Result<(), ScanError> {
                assert_eq!(first_ev, Event::DocumentStart);
                recv.on_event(first_ev, mark);

                let (ev, mark) = self.next()?;
                self.load_node(ev, mark, recv)?;

                // DOCUMENT-END is expected.
                let (ev, mark) = self.next()?;
                assert_eq!(ev, Event::DocumentEnd);
                recv.on_event(ev, mark);

                Ok(())
            }

            fn load_node<R: MarkedEventReceiver>(
                &mut self,
                first_ev: Event,
                mark: Marker,
                recv: &mut R,
            ) -> Result<(), ScanError> {
                match first_ev {
                    Event::Alias(..) | Event::Scalar(..) => {
                        recv.on_event(first_ev, mark);
                        Ok(())
                    }
                    Event::SequenceStart(_) => {
                        recv.on_event(first_ev, mark);
                        self.load_sequence(recv)
                    }
                    Event::MappingStart(_) => {
                        recv.on_event(first_ev, mark);
                        self.load_mapping(recv)
                    }
                    _ => {
                        println!("UNREACHABLE EVENT: {:?}", first_ev);
                        unreachable!();
                    }
                }
            }

            fn load_mapping<R: MarkedEventReceiver>(&mut self, recv: &mut R) -> Result<(), ScanError> {
                let (mut key_ev, mut key_mark) = self.next()?;
                while key_ev != Event::MappingEnd {
                    // key
                    self.load_node(key_ev, key_mark, recv)?;

                    // value
                    let (ev, mark) = self.next()?;
                    self.load_node(ev, mark, recv)?;

                    // next event
                    let (ev, mark) = self.next()?;
                    key_ev = ev;
                    key_mark = mark;
                }
                recv.on_event(key_ev, key_mark);
                Ok(())
            }

            fn load_sequence<R: MarkedEventReceiver>(&mut self, recv: &mut R) -> Result<(), ScanError> {
                let (mut ev, mut mark) = self.next()?;
                while ev != Event::SequenceEnd {
                    self.load_node(ev, mark, recv)?;

                    // next event
                    let (next_ev, next_mark) = self.next()?;
                    ev = next_ev;
                    mark = next_mark;
                }
                recv.on_event(ev, mark);
                Ok(())
            }

            fn state_machine(&mut self) -> ParseResult {
                // let next_tok = self.peek_token()?;
                // println!("cur_state {:?}, next tok: {:?}", self.state, next_tok);
                match self.state {
                    State::StreamStart => self.stream_start(),

                    State::ImplicitDocumentStart => self.document_start(true),
                    State::DocumentStart => self.document_start(false),
                    State::DocumentContent => self.document_content(),
                    State::DocumentEnd => self.document_end(),

                    State::BlockNode => self.parse_node(true, false),
                    // State::BlockNodeOrIndentlessSequence => self.parse_node(true, true),
                    // State::FlowNode => self.parse_node(false, false),
                    State::BlockMappingFirstKey => self.block_mapping_key(true),
                    State::BlockMappingKey => self.block_mapping_key(false),
                    State::BlockMappingValue => self.block_mapping_value(),

                    State::BlockSequenceFirstEntry => self.block_sequence_entry(true),
                    State::BlockSequenceEntry => self.block_sequence_entry(false),

                    State::FlowSequenceFirstEntry => self.flow_sequence_entry(true),
                    State::FlowSequenceEntry => self.flow_sequence_entry(false),

                    State::FlowMappingFirstKey => self.flow_mapping_key(true),
                    State::FlowMappingKey => self.flow_mapping_key(false),
                    State::FlowMappingValue => self.flow_mapping_value(false),

                    State::IndentlessSequenceEntry => self.indentless_sequence_entry(),

                    State::FlowSequenceEntryMappingKey => self.flow_sequence_entry_mapping_key(),
                    State::FlowSequenceEntryMappingValue => self.flow_sequence_entry_mapping_value(),
                    State::FlowSequenceEntryMappingEnd => self.flow_sequence_entry_mapping_end(),
                    State::FlowMappingEmptyValue => self.flow_mapping_value(true),

                    /* impossible */
                    State::End => unreachable!(),
                }
            }

            fn stream_start(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(mark, TokenType::StreamStart(_)) => {
                        self.state = State::ImplicitDocumentStart;
                        self.skip();
                        Ok((Event::StreamStart, mark))
                    }
                    Token(mark, _) => Err(ScanError::new(mark, "did not find expected <stream-start>")),
                }
            }

            fn document_start(&mut self, implicit: bool) -> ParseResult {
                if !implicit {
                    while let TokenType::DocumentEnd = self.peek_token()?.1 {
                        self.skip();
                    }
                }

                match *self.peek_token()? {
                    Token(mark, TokenType::StreamEnd) => {
                        self.state = State::End;
                        self.skip();
                        Ok((Event::StreamEnd, mark))
                    }
                    Token(_, TokenType::VersionDirective(..))
                    | Token(_, TokenType::TagDirective(..))
                    | Token(_, TokenType::DocumentStart) => {
                        // explicit document
                        self._explicit_document_start()
                    }
                    Token(mark, _) if implicit => {
                        self.parser_process_directives()?;
                        self.push_state(State::DocumentEnd);
                        self.state = State::BlockNode;
                        Ok((Event::DocumentStart, mark))
                    }
                    _ => {
                        // explicit document
                        self._explicit_document_start()
                    }
                }
            }

            fn parser_process_directives(&mut self) -> Result<(), ScanError> {
                loop {
                    match self.peek_token()?.1 {
                        TokenType::VersionDirective(_, _) => {
                            // XXX parsing with warning according to spec
                            //if major != 1 || minor > 2 {
                            //    return Err(ScanError::new(tok.0,
                            //        "found incompatible YAML document"));
                            //}
                        }
                        TokenType::TagDirective(..) => {
                            // TODO add tag directive
                        }
                        _ => break,
                    }
                    self.skip();
                }
                // TODO tag directive
                Ok(())
            }

            fn _explicit_document_start(&mut self) -> ParseResult {
                self.parser_process_directives()?;
                match *self.peek_token()? {
                    Token(mark, TokenType::DocumentStart) => {
                        self.push_state(State::DocumentEnd);
                        self.state = State::DocumentContent;
                        self.skip();
                        Ok((Event::DocumentStart, mark))
                    }
                    Token(mark, _) => Err(ScanError::new(
                        mark,
                        "did not find expected <document start>",
                    )),
                }
            }

            fn document_content(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(mark, TokenType::VersionDirective(..))
                    | Token(mark, TokenType::TagDirective(..))
                    | Token(mark, TokenType::DocumentStart)
                    | Token(mark, TokenType::DocumentEnd)
                    | Token(mark, TokenType::StreamEnd) => {
                        self.pop_state();
                        // empty scalar
                        Ok((Event::empty_scalar(), mark))
                    }
                    _ => self.parse_node(true, false),
                }
            }

            fn document_end(&mut self) -> ParseResult {
                let mut _implicit = true;
                let marker: Marker = match *self.peek_token()? {
                    Token(mark, TokenType::DocumentEnd) => {
                        self.skip();
                        _implicit = false;
                        mark
                    }
                    Token(mark, _) => mark,
                };

                // TODO tag handling
                self.state = State::DocumentStart;
                Ok((Event::DocumentEnd, marker))
            }

            fn register_anchor(&mut self, name: String, _: &Marker) -> Result<usize, ScanError> {
                // anchors can be overridden/reused
                // if self.anchors.contains_key(name) {
                //     return Err(ScanError::new(*mark,
                //         "while parsing anchor, found duplicated anchor"));
                // }
                let new_id = self.anchor_id;
                self.anchor_id += 1;
                self.anchors.insert(name, new_id);
                Ok(new_id)
            }

            fn parse_node(&mut self, block: bool, indentless_sequence: bool) -> ParseResult {
                let mut anchor_id = 0;
                let mut tag = None;
                match *self.peek_token()? {
                    Token(_, TokenType::Alias(_)) => {
                        self.pop_state();
                        if let Token(mark, TokenType::Alias(name)) = self.fetch_token() {
                            match self.anchors.get(&name) {
                                None => {
                                    return Err(ScanError::new(
                                        mark,
                                        "while parsing node, found unknown anchor",
                                    ))
                                }
                                Some(id) => return Ok((Event::Alias(*id), mark)),
                            }
                        } else {
                            unreachable!()
                        }
                    }
                    Token(_, TokenType::Anchor(_)) => {
                        if let Token(mark, TokenType::Anchor(name)) = self.fetch_token() {
                            anchor_id = self.register_anchor(name, &mark)?;
                            if let TokenType::Tag(..) = self.peek_token()?.1 {
                                if let tg @ TokenType::Tag(..) = self.fetch_token().1 {
                                    tag = Some(tg);
                                } else {
                                    unreachable!()
                                }
                            }
                        } else {
                            unreachable!()
                        }
                    }
                    Token(_, TokenType::Tag(..)) => {
                        if let tg @ TokenType::Tag(..) = self.fetch_token().1 {
                            tag = Some(tg);
                            if let TokenType::Anchor(_) = self.peek_token()?.1 {
                                if let Token(mark, TokenType::Anchor(name)) = self.fetch_token() {
                                    anchor_id = self.register_anchor(name, &mark)?;
                                } else {
                                    unreachable!()
                                }
                            }
                        } else {
                            unreachable!()
                        }
                    }
                    _ => {}
                }
                match *self.peek_token()? {
                    Token(mark, TokenType::BlockEntry) if indentless_sequence => {
                        self.state = State::IndentlessSequenceEntry;
                        Ok((Event::SequenceStart(anchor_id), mark))
                    }
                    Token(_, TokenType::Scalar(..)) => {
                        self.pop_state();
                        if let Token(mark, TokenType::Scalar(style, v)) = self.fetch_token() {
                            Ok((Event::Scalar(v, style, anchor_id, tag), mark))
                        } else {
                            unreachable!()
                        }
                    }
                    Token(mark, TokenType::FlowSequenceStart) => {
                        self.state = State::FlowSequenceFirstEntry;
                        Ok((Event::SequenceStart(anchor_id), mark))
                    }
                    Token(mark, TokenType::FlowMappingStart) => {
                        self.state = State::FlowMappingFirstKey;
                        Ok((Event::MappingStart(anchor_id), mark))
                    }
                    Token(mark, TokenType::BlockSequenceStart) if block => {
                        self.state = State::BlockSequenceFirstEntry;
                        Ok((Event::SequenceStart(anchor_id), mark))
                    }
                    Token(mark, TokenType::BlockMappingStart) if block => {
                        self.state = State::BlockMappingFirstKey;
                        Ok((Event::MappingStart(anchor_id), mark))
                    }
                    // ex 7.2, an empty scalar can follow a secondary tag
                    Token(mark, _) if tag.is_some() || anchor_id > 0 => {
                        self.pop_state();
                        Ok((Event::empty_scalar_with_anchor(anchor_id, tag), mark))
                    }
                    Token(mark, _) => Err(ScanError::new(
                        mark,
                        "while parsing a node, did not find expected node content",
                    )),
                }
            }

            fn block_mapping_key(&mut self, first: bool) -> ParseResult {
                // skip BlockMappingStart
                if first {
                    let _ = self.peek_token()?;
                    //self.marks.push(tok.0);
                    self.skip();
                }
                match *self.peek_token()? {
                    Token(_, TokenType::Key) => {
                        self.skip();
                        match *self.peek_token()? {
                            Token(mark, TokenType::Key)
                            | Token(mark, TokenType::Value)
                            | Token(mark, TokenType::BlockEnd) => {
                                self.state = State::BlockMappingValue;
                                // empty scalar
                                Ok((Event::empty_scalar(), mark))
                            }
                            _ => {
                                self.push_state(State::BlockMappingValue);
                                self.parse_node(true, true)
                            }
                        }
                    }
                    // XXX(chenyh): libyaml failed to parse spec 1.2, ex8.18
                    Token(mark, TokenType::Value) => {
                        self.state = State::BlockMappingValue;
                        Ok((Event::empty_scalar(), mark))
                    }
                    Token(mark, TokenType::BlockEnd) => {
                        self.pop_state();
                        self.skip();
                        Ok((Event::MappingEnd, mark))
                    }
                    Token(mark, _) => Err(ScanError::new(
                        mark,
                        "while parsing a block mapping, did not find expected key",
                    )),
                }
            }

            fn block_mapping_value(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(_, TokenType::Value) => {
                        self.skip();
                        match *self.peek_token()? {
                            Token(mark, TokenType::Key)
                            | Token(mark, TokenType::Value)
                            | Token(mark, TokenType::BlockEnd) => {
                                self.state = State::BlockMappingKey;
                                // empty scalar
                                Ok((Event::empty_scalar(), mark))
                            }
                            _ => {
                                self.push_state(State::BlockMappingKey);
                                self.parse_node(true, true)
                            }
                        }
                    }
                    Token(mark, _) => {
                        self.state = State::BlockMappingKey;
                        // empty scalar
                        Ok((Event::empty_scalar(), mark))
                    }
                }
            }

            fn flow_mapping_key(&mut self, first: bool) -> ParseResult {
                if first {
                    let _ = self.peek_token()?;
                    self.skip();
                }
                let marker: Marker =
                    {
                        match *self.peek_token()? {
                            Token(mark, TokenType::FlowMappingEnd) => mark,
                            Token(mark, _) => {
                                if !first {
                                    match *self.peek_token()? {
                                    Token(_, TokenType::FlowEntry) => self.skip(),
                                    Token(mark, _) => return Err(ScanError::new(mark,
                                        "while parsing a flow mapping, did not find expected ',' or '}'"))
                                }
                                }

                                match *self.peek_token()? {
                                    Token(_, TokenType::Key) => {
                                        self.skip();
                                        match *self.peek_token()? {
                                            Token(mark, TokenType::Value)
                                            | Token(mark, TokenType::FlowEntry)
                                            | Token(mark, TokenType::FlowMappingEnd) => {
                                                self.state = State::FlowMappingValue;
                                                return Ok((Event::empty_scalar(), mark));
                                            }
                                            _ => {
                                                self.push_state(State::FlowMappingValue);
                                                return self.parse_node(false, false);
                                            }
                                        }
                                    }
                                    Token(marker, TokenType::Value) => {
                                        self.state = State::FlowMappingValue;
                                        return Ok((Event::empty_scalar(), marker));
                                    }
                                    Token(_, TokenType::FlowMappingEnd) => (),
                                    _ => {
                                        self.push_state(State::FlowMappingEmptyValue);
                                        return self.parse_node(false, false);
                                    }
                                }

                                mark
                            }
                        }
                    };

                self.pop_state();
                self.skip();
                Ok((Event::MappingEnd, marker))
            }

            fn flow_mapping_value(&mut self, empty: bool) -> ParseResult {
                let mark: Marker = {
                    if empty {
                        let Token(mark, _) = *self.peek_token()?;
                        self.state = State::FlowMappingKey;
                        return Ok((Event::empty_scalar(), mark));
                    } else {
                        match *self.peek_token()? {
                            Token(marker, TokenType::Value) => {
                                self.skip();
                                match self.peek_token()?.1 {
                                    TokenType::FlowEntry | TokenType::FlowMappingEnd => {}
                                    _ => {
                                        self.push_state(State::FlowMappingKey);
                                        return self.parse_node(false, false);
                                    }
                                }
                                marker
                            }
                            Token(marker, _) => marker,
                        }
                    }
                };

                self.state = State::FlowMappingKey;
                Ok((Event::empty_scalar(), mark))
            }

            fn flow_sequence_entry(&mut self, first: bool) -> ParseResult {
                // skip FlowMappingStart
                if first {
                    let _ = self.peek_token()?;
                    //self.marks.push(tok.0);
                    self.skip();
                }
                match *self.peek_token()? {
                    Token(mark, TokenType::FlowSequenceEnd) => {
                        self.pop_state();
                        self.skip();
                        return Ok((Event::SequenceEnd, mark));
                    }
                    Token(_, TokenType::FlowEntry) if !first => {
                        self.skip();
                    }
                    Token(mark, _) if !first => {
                        return Err(ScanError::new(
                            mark,
                            "while parsing a flow sequence, expected ',' or ']'",
                        ));
                    }
                    _ => { /* next */ }
                }
                match *self.peek_token()? {
                    Token(mark, TokenType::FlowSequenceEnd) => {
                        self.pop_state();
                        self.skip();
                        Ok((Event::SequenceEnd, mark))
                    }
                    Token(mark, TokenType::Key) => {
                        self.state = State::FlowSequenceEntryMappingKey;
                        self.skip();
                        Ok((Event::MappingStart(0), mark))
                    }
                    _ => {
                        self.push_state(State::FlowSequenceEntry);
                        self.parse_node(false, false)
                    }
                }
            }

            fn indentless_sequence_entry(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(_, TokenType::BlockEntry) => (),
                    Token(mark, _) => {
                        self.pop_state();
                        return Ok((Event::SequenceEnd, mark));
                    }
                }
                self.skip();
                match *self.peek_token()? {
                    Token(mark, TokenType::BlockEntry)
                    | Token(mark, TokenType::Key)
                    | Token(mark, TokenType::Value)
                    | Token(mark, TokenType::BlockEnd) => {
                        self.state = State::IndentlessSequenceEntry;
                        Ok((Event::empty_scalar(), mark))
                    }
                    _ => {
                        self.push_state(State::IndentlessSequenceEntry);
                        self.parse_node(true, false)
                    }
                }
            }

            fn block_sequence_entry(&mut self, first: bool) -> ParseResult {
                // BLOCK-SEQUENCE-START
                if first {
                    let _ = self.peek_token()?;
                    //self.marks.push(tok.0);
                    self.skip();
                }
                match *self.peek_token()? {
                    Token(mark, TokenType::BlockEnd) => {
                        self.pop_state();
                        self.skip();
                        Ok((Event::SequenceEnd, mark))
                    }
                    Token(_, TokenType::BlockEntry) => {
                        self.skip();
                        match *self.peek_token()? {
                            Token(mark, TokenType::BlockEntry) | Token(mark, TokenType::BlockEnd) => {
                                self.state = State::BlockSequenceEntry;
                                Ok((Event::empty_scalar(), mark))
                            }
                            _ => {
                                self.push_state(State::BlockSequenceEntry);
                                self.parse_node(true, false)
                            }
                        }
                    }
                    Token(mark, _) => Err(ScanError::new(
                        mark,
                        "while parsing a block collection, did not find expected '-' indicator",
                    )),
                }
            }

            fn flow_sequence_entry_mapping_key(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(mark, TokenType::Value)
                    | Token(mark, TokenType::FlowEntry)
                    | Token(mark, TokenType::FlowSequenceEnd) => {
                        self.skip();
                        self.state = State::FlowSequenceEntryMappingValue;
                        Ok((Event::empty_scalar(), mark))
                    }
                    _ => {
                        self.push_state(State::FlowSequenceEntryMappingValue);
                        self.parse_node(false, false)
                    }
                }
            }

            fn flow_sequence_entry_mapping_value(&mut self) -> ParseResult {
                match *self.peek_token()? {
                    Token(_, TokenType::Value) => {
                        self.skip();
                        self.state = State::FlowSequenceEntryMappingValue;
                        match *self.peek_token()? {
                            Token(mark, TokenType::FlowEntry) | Token(mark, TokenType::FlowSequenceEnd) => {
                                self.state = State::FlowSequenceEntryMappingEnd;
                                Ok((Event::empty_scalar(), mark))
                            }
                            _ => {
                                self.push_state(State::FlowSequenceEntryMappingEnd);
                                self.parse_node(false, false)
                            }
                        }
                    }
                    Token(mark, _) => {
                        self.state = State::FlowSequenceEntryMappingEnd;
                        Ok((Event::empty_scalar(), mark))
                    }
                }
            }

            fn flow_sequence_entry_mapping_end(&mut self) -> ParseResult {
                self.state = State::FlowSequenceEntry;
                Ok((Event::MappingEnd, self.scanner.mark()))
            }
        }
    }

    pub mod scanner
    {
        use ::
        {
            *,
        };
        use std::collections::VecDeque;
        use std::error::Error;
        use std::{char, fmt};

        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        pub enum TEncoding {
            Utf8,
        }

        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        pub enum TScalarStyle {
            Any,
            Plain,
            SingleQuoted,
            DoubleQuoted,

            Literal,
            Foled,
        }

        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        pub struct Marker {
            index: usize,
            line: usize,
            col: usize,
        }

        impl Marker {
            fn new(index: usize, line: usize, col: usize) -> Marker {
                Marker { index, line, col }
            }

            pub fn index(&self) -> usize {
                self.index
            }

            pub fn line(&self) -> usize {
                self.line
            }

            pub fn col(&self) -> usize {
                self.col
            }
        }

        #[derive(Clone, PartialEq, Debug, Eq)]
        pub struct ScanError {
            mark: Marker,
            info: String,
        }

        impl ScanError {
            pub fn new(loc: Marker, info: &str) -> ScanError {
                ScanError {
                    mark: loc,
                    info: info.to_owned(),
                }
            }

            pub fn marker(&self) -> &Marker {
                &self.mark
            }
        }

        impl Error for ScanError {
            fn description(&self) -> &str {
                self.info.as_ref()
            }

            fn cause(&self) -> Option<&dyn Error> {
                None
            }
        }

        impl fmt::Display for ScanError {
            // col starts from 0
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                write!(
                    formatter,
                    "{} at line {} column {}",
                    self.info,
                    self.mark.line,
                    self.mark.col + 1
                )
            }
        }

        #[derive(Clone, PartialEq, Debug, Eq)]
        pub enum TokenType {
            NoToken,
            StreamStart(TEncoding),
            StreamEnd,
            /// major, minor
            VersionDirective(u32, u32),
            /// handle, prefix
            TagDirective(String, String),
            DocumentStart,
            DocumentEnd,
            BlockSequenceStart,
            BlockMappingStart,
            BlockEnd,
            FlowSequenceStart,
            FlowSequenceEnd,
            FlowMappingStart,
            FlowMappingEnd,
            BlockEntry,
            FlowEntry,
            Key,
            Value,
            Alias(String),
            Anchor(String),
            /// handle, suffix
            Tag(String, String),
            Scalar(TScalarStyle, String),
        }

        #[derive(Clone, PartialEq, Debug, Eq)]
        pub struct Token(pub Marker, pub TokenType);

        #[derive(Clone, PartialEq, Debug, Eq)]
        struct SimpleKey {
            possible: bool,
            required: bool,
            token_number: usize,
            mark: Marker,
        }

        impl SimpleKey {
            fn new(mark: Marker) -> SimpleKey {
                SimpleKey {
                    possible: false,
                    required: false,
                    token_number: 0,
                    mark,
                }
            }
        }

        #[derive(Debug)]
        pub struct Scanner<T> {
            rdr: T,
            mark: Marker,
            tokens: VecDeque<Token>,
            buffer: VecDeque<char>,
            error: Option<ScanError>,

            stream_start_produced: bool,
            stream_end_produced: bool,
            adjacent_value_allowed_at: usize,
            simple_key_allowed: bool,
            simple_keys: Vec<SimpleKey>,
            indent: isize,
            indents: Vec<isize>,
            flow_level: u8,
            tokens_parsed: usize,
            token_available: bool,
        }

        impl<T: Iterator<Item = char>> Iterator for Scanner<T> {
            type Item = Token;
            fn next(&mut self) -> Option<Token> {
                if self.error.is_some() {
                    return None;
                }
                match self.next_token() {
                    Ok(tok) => tok,
                    Err(e) => {
                        self.error = Some(e);
                        None
                    }
                }
            }
        }

        #[inline]
        fn is_z(c: char) -> bool {
            c == '\0'
        }
        #[inline]
        fn is_break(c: char) -> bool {
            c == '\n' || c == '\r'
        }
        #[inline]
        fn is_breakz(c: char) -> bool {
            is_break(c) || is_z(c)
        }
        #[inline]
        fn is_blank(c: char) -> bool {
            c == ' ' || c == '\t'
        }
        #[inline]
        fn is_blankz(c: char) -> bool {
            is_blank(c) || is_breakz(c)
        }
        #[inline]
        fn is_digit(c: char) -> bool {
            c >= '0' && c <= '9'
        }
        #[inline]
        fn is_alpha(c: char) -> bool {
            match c {
                '0'..='9' | 'a'..='z' | 'A'..='Z' => true,
                '_' | '-' => true,
                _ => false,
            }
        }
        #[inline]
        fn is_hex(c: char) -> bool {
            (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')
        }
        #[inline]
        fn as_hex(c: char) -> u32 {
            match c {
                '0'..='9' => (c as u32) - ('0' as u32),
                'a'..='f' => (c as u32) - ('a' as u32) + 10,
                'A'..='F' => (c as u32) - ('A' as u32) + 10,
                _ => unreachable!(),
            }
        }
        #[inline]
        fn is_flow(c: char) -> bool {
            match c {
                ',' | '[' | ']' | '{' | '}' => true,
                _ => false,
            }
        }

        pub type ScanResult = Result<(), ScanError>;

        impl<T: Iterator<Item = char>> Scanner<T> {
            /// Creates the YAML tokenizer.
            pub fn new(rdr: T) -> Scanner<T> {
                Scanner {
                    rdr,
                    buffer: VecDeque::new(),
                    mark: Marker::new(0, 1, 0),
                    tokens: VecDeque::new(),
                    error: None,

                    stream_start_produced: false,
                    stream_end_produced: false,
                    adjacent_value_allowed_at: 0,
                    simple_key_allowed: true,
                    simple_keys: Vec::new(),
                    indent: -1,
                    indents: Vec::new(),
                    flow_level: 0,
                    tokens_parsed: 0,
                    token_available: false,
                }
            }
            #[inline]
            pub fn get_error(&self) -> Option<ScanError> {
                match self.error {
                    None => None,
                    Some(ref e) => Some(e.clone()),
                }
            }

            #[inline]
            fn lookahead(&mut self, count: usize) {
                if self.buffer.len() >= count {
                    return;
                }
                for _ in 0..(count - self.buffer.len()) {
                    self.buffer.push_back(self.rdr.next().unwrap_or('\0'));
                }
            }
            #[inline]
            fn skip(&mut self) {
                let c = self.buffer.pop_front().unwrap();

                self.mark.index += 1;
                if c == '\n' {
                    self.mark.line += 1;
                    self.mark.col = 0;
                } else {
                    self.mark.col += 1;
                }
            }
            #[inline]
            fn skip_line(&mut self) {
                if self.buffer[0] == '\r' && self.buffer[1] == '\n' {
                    self.skip();
                    self.skip();
                } else if is_break(self.buffer[0]) {
                    self.skip();
                }
            }
            #[inline]
            fn ch(&self) -> char {
                self.buffer[0]
            }
            #[inline]
            fn ch_is(&self, c: char) -> bool {
                self.buffer[0] == c
            }
            
            #[inline]
            fn eof(&self) -> bool {
                self.ch_is('\0')
            }
            #[inline]
            pub fn stream_started(&self) -> bool {
                self.stream_start_produced
            }
            #[inline]
            pub fn stream_ended(&self) -> bool {
                self.stream_end_produced
            }
            #[inline]
            pub fn mark(&self) -> Marker {
                self.mark
            }
            #[inline]
            fn read_break(&mut self, s: &mut String) {
                if self.buffer[0] == '\r' && self.buffer[1] == '\n' {
                    s.push('\n');
                    self.skip();
                    self.skip();
                } else if self.buffer[0] == '\r' || self.buffer[0] == '\n' {
                    s.push('\n');
                    self.skip();
                } else {
                    unreachable!();
                }
            }
            fn insert_token(&mut self, pos: usize, tok: Token) {
                let old_len = self.tokens.len();
                assert!(pos <= old_len);
                self.tokens.push_back(tok);
                for i in 0..old_len - pos {
                    self.tokens.swap(old_len - i, old_len - i - 1);
                }
            }
            fn allow_simple_key(&mut self) {
                self.simple_key_allowed = true;
            }
            fn disallow_simple_key(&mut self) {
                self.simple_key_allowed = false;
            }

            pub fn fetch_next_token(&mut self) -> ScanResult {
                self.lookahead(1);
                // println!("--> fetch_next_token Cur {:?} {:?}", self.mark, self.ch());

                if !self.stream_start_produced {
                    self.fetch_stream_start();
                    return Ok(());
                }
                self.skip_to_next_token();

                self.stale_simple_keys()?;

                let mark = self.mark;
                self.unroll_indent(mark.col as isize);

                self.lookahead(4);

                if is_z(self.ch()) {
                    self.fetch_stream_end()?;
                    return Ok(());
                }

                // Is it a directive?
                if self.mark.col == 0 && self.ch_is('%') {
                    return self.fetch_directive();
                }

                if self.mark.col == 0
                    && self.buffer[0] == '-'
                    && self.buffer[1] == '-'
                    && self.buffer[2] == '-'
                    && is_blankz(self.buffer[3])
                {
                    self.fetch_document_indicator(TokenType::DocumentStart)?;
                    return Ok(());
                }

                if self.mark.col == 0
                    && self.buffer[0] == '.'
                    && self.buffer[1] == '.'
                    && self.buffer[2] == '.'
                    && is_blankz(self.buffer[3])
                {
                    self.fetch_document_indicator(TokenType::DocumentEnd)?;
                    return Ok(());
                }

                let c = self.buffer[0];
                let nc = self.buffer[1];
                match c {
                    '[' => self.fetch_flow_collection_start(TokenType::FlowSequenceStart),
                    '{' => self.fetch_flow_collection_start(TokenType::FlowMappingStart),
                    ']' => self.fetch_flow_collection_end(TokenType::FlowSequenceEnd),
                    '}' => self.fetch_flow_collection_end(TokenType::FlowMappingEnd),
                    ',' => self.fetch_flow_entry(),
                    '-' if is_blankz(nc) => self.fetch_block_entry(),
                    '?' if is_blankz(nc) => self.fetch_key(),
                    ':' if is_blankz(nc)
                        || (self.flow_level > 0
                            && (is_flow(nc) || self.mark.index == self.adjacent_value_allowed_at)) =>
                    {
                        self.fetch_value()
                    }
                    // Is it an alias?
                    '*' => self.fetch_anchor(true),
                    // Is it an anchor?
                    '&' => self.fetch_anchor(false),
                    '!' => self.fetch_tag(),
                    // Is it a literal scalar?
                    '|' if self.flow_level == 0 => self.fetch_block_scalar(true),
                    // Is it a folded scalar?
                    '>' if self.flow_level == 0 => self.fetch_block_scalar(false),
                    '\'' => self.fetch_flow_scalar(true),
                    '"' => self.fetch_flow_scalar(false),
                    // plain scalar
                    '-' if !is_blankz(nc) => self.fetch_plain_scalar(),
                    ':' | '?' if !is_blankz(nc) && self.flow_level == 0 => self.fetch_plain_scalar(),
                    '%' | '@' | '`' => Err(ScanError::new(
                        self.mark,
                        &format!("unexpected character: `{}'", c),
                    )),
                    _ => self.fetch_plain_scalar(),
                }
            }

            pub fn next_token(&mut self) -> Result<Option<Token>, ScanError> {
                if self.stream_end_produced {
                    return Ok(None);
                }

                if !self.token_available {
                    self.fetch_more_tokens()?;
                }
                let t = self.tokens.pop_front().unwrap();
                self.token_available = false;
                self.tokens_parsed += 1;

                if let TokenType::StreamEnd = t.1 {
                    self.stream_end_produced = true;
                }
                Ok(Some(t))
            }

            pub fn fetch_more_tokens(&mut self) -> ScanResult {
                let mut need_more;
                loop {
                    need_more = false;
                    if self.tokens.is_empty() {
                        need_more = true;
                    } else {
                        self.stale_simple_keys()?;
                        for sk in &self.simple_keys {
                            if sk.possible && sk.token_number == self.tokens_parsed {
                                need_more = true;
                                break;
                            }
                        }
                    }

                    if !need_more {
                        break;
                    }
                    self.fetch_next_token()?;
                }
                self.token_available = true;

                Ok(())
            }

            fn stale_simple_keys(&mut self) -> ScanResult {
                for sk in &mut self.simple_keys {
                    if sk.possible
                        && (sk.mark.line < self.mark.line || sk.mark.index + 1024 < self.mark.index)
                    {
                        if sk.required {
                            return Err(ScanError::new(self.mark, "simple key expect ':'"));
                        }
                        sk.possible = false;
                    }
                }
                Ok(())
            }

            fn skip_to_next_token(&mut self) {
                loop {
                    self.lookahead(1);
                    // TODO(chenyh) BOM
                    match self.ch() {
                        ' ' => self.skip(),
                        '\t' if self.flow_level > 0 || !self.simple_key_allowed => self.skip(),
                        '\n' | '\r' => {
                            self.lookahead(2);
                            self.skip_line();
                            if self.flow_level == 0 {
                                self.allow_simple_key();
                            }
                        }
                        '#' => {
                            while !is_breakz(self.ch()) {
                                self.skip();
                                self.lookahead(1);
                            }
                        }
                        _ => break,
                    }
                }
            }

            fn fetch_stream_start(&mut self) {
                let mark = self.mark;
                self.indent = -1;
                self.stream_start_produced = true;
                self.allow_simple_key();
                self.tokens
                    .push_back(Token(mark, TokenType::StreamStart(TEncoding::Utf8)));
                self.simple_keys.push(SimpleKey::new(Marker::new(0, 0, 0)));
            }

            fn fetch_stream_end(&mut self) -> ScanResult {
                // force new line
                if self.mark.col != 0 {
                    self.mark.col = 0;
                    self.mark.line += 1;
                }

                self.unroll_indent(-1);
                self.remove_simple_key()?;
                self.disallow_simple_key();

                self.tokens
                    .push_back(Token(self.mark, TokenType::StreamEnd));
                Ok(())
            }

            fn fetch_directive(&mut self) -> ScanResult {
                self.unroll_indent(-1);
                self.remove_simple_key()?;

                self.disallow_simple_key();

                let tok = self.scan_directive()?;

                self.tokens.push_back(tok);

                Ok(())
            }

            fn scan_directive(&mut self) -> Result<Token, ScanError> {
                let start_mark = self.mark;
                self.skip();

                let name = self.scan_directive_name()?;
                let tok = match name.as_ref() {
                    "YAML" => self.scan_version_directive_value(&start_mark)?,
                    "TAG" => self.scan_tag_directive_value(&start_mark)?,
                    // XXX This should be a warning instead of an error
                    _ => {
                        // skip current line
                        self.lookahead(1);
                        while !is_breakz(self.ch()) {
                            self.skip();
                            self.lookahead(1);
                        }
                        // XXX return an empty TagDirective token
                        Token(
                            start_mark,
                            TokenType::TagDirective(String::new(), String::new()),
                        )
                        // return Err(ScanError::new(start_mark,
                        //     "while scanning a directive, found unknown directive name"))
                    }
                };
                self.lookahead(1);

                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }

                if self.ch() == '#' {
                    while !is_breakz(self.ch()) {
                        self.skip();
                        self.lookahead(1);
                    }
                }

                if !is_breakz(self.ch()) {
                    return Err(ScanError::new(
                        start_mark,
                        "while scanning a directive, did not find expected comment or line break",
                    ));
                }

                // Eat a line break
                if is_break(self.ch()) {
                    self.lookahead(2);
                    self.skip_line();
                }

                Ok(tok)
            }

            fn scan_version_directive_value(&mut self, mark: &Marker) -> Result<Token, ScanError> {
                self.lookahead(1);

                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }

                let major = self.scan_version_directive_number(mark)?;

                if self.ch() != '.' {
                    return Err(ScanError::new(
                        *mark,
                        "while scanning a YAML directive, did not find expected digit or '.' character",
                    ));
                }

                self.skip();

                let minor = self.scan_version_directive_number(mark)?;

                Ok(Token(*mark, TokenType::VersionDirective(major, minor)))
            }

            fn scan_directive_name(&mut self) -> Result<String, ScanError> {
                let start_mark = self.mark;
                let mut string = String::new();
                self.lookahead(1);
                while is_alpha(self.ch()) {
                    string.push(self.ch());
                    self.skip();
                    self.lookahead(1);
                }

                if string.is_empty() {
                    return Err(ScanError::new(
                        start_mark,
                        "while scanning a directive, could not find expected directive name",
                    ));
                }

                if !is_blankz(self.ch()) {
                    return Err(ScanError::new(
                        start_mark,
                        "while scanning a directive, found unexpected non-alphabetical character",
                    ));
                }

                Ok(string)
            }

            fn scan_version_directive_number(&mut self, mark: &Marker) -> Result<u32, ScanError> {
                let mut val = 0u32;
                let mut length = 0usize;
                self.lookahead(1);
                while is_digit(self.ch()) {
                    if length + 1 > 9 {
                        return Err(ScanError::new(
                            *mark,
                            "while scanning a YAML directive, found extremely long version number",
                        ));
                    }
                    length += 1;
                    val = val * 10 + ((self.ch() as u32) - ('0' as u32));
                    self.skip();
                    self.lookahead(1);
                }

                if length == 0 {
                    return Err(ScanError::new(
                        *mark,
                        "while scanning a YAML directive, did not find expected version number",
                    ));
                }

                Ok(val)
            }

            fn scan_tag_directive_value(&mut self, mark: &Marker) -> Result<Token, ScanError> {
                self.lookahead(1);
                /* Eat whitespaces. */
                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }
                let handle = self.scan_tag_handle(true, mark)?;

                self.lookahead(1);
                /* Eat whitespaces. */
                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }

                let is_secondary = handle == "!!";
                let prefix = self.scan_tag_uri(true, is_secondary, &String::new(), mark)?;

                self.lookahead(1);

                if is_blankz(self.ch()) {
                    Ok(Token(*mark, TokenType::TagDirective(handle, prefix)))
                } else {
                    Err(ScanError::new(
                        *mark,
                        "while scanning TAG, did not find expected whitespace or line break",
                    ))
                }
            }

            fn fetch_tag(&mut self) -> ScanResult {
                self.save_simple_key()?;
                self.disallow_simple_key();

                let tok = self.scan_tag()?;
                self.tokens.push_back(tok);
                Ok(())
            }

            fn scan_tag(&mut self) -> Result<Token, ScanError> {
                let start_mark = self.mark;
                let mut handle = String::new();
                let mut suffix;
                let mut secondary = false;

                // Check if the tag is in the canonical form (verbatim).
                self.lookahead(2);

                if self.buffer[1] == '<' {
                    // Eat '!<'
                    self.skip();
                    self.skip();
                    suffix = self.scan_tag_uri(false, false, &String::new(), &start_mark)?;

                    if self.ch() != '>' {
                        return Err(ScanError::new(
                            start_mark,
                            "while scanning a tag, did not find the expected '>'",
                        ));
                    }

                    self.skip();
                } else {
                    // The tag has either the '!suffix' or the '!handle!suffix'
                    handle = self.scan_tag_handle(false, &start_mark)?;
                    // Check if it is, indeed, handle.
                    if handle.len() >= 2 && handle.starts_with('!') && handle.ends_with('!') {
                        if handle == "!!" {
                            secondary = true;
                        }
                        suffix = self.scan_tag_uri(false, secondary, &String::new(), &start_mark)?;
                    } else {
                        suffix = self.scan_tag_uri(false, false, &handle, &start_mark)?;
                        handle = "!".to_owned();
                        // A special case: the '!' tag.  Set the handle to '' and the
                        // suffix to '!'.
                        if suffix.is_empty() {
                            handle.clear();
                            suffix = "!".to_owned();
                        }
                    }
                }

                self.lookahead(1);
                if is_blankz(self.ch()) {
                    // XXX: ex 7.2, an empty scalar can follow a secondary tag
                    Ok(Token(start_mark, TokenType::Tag(handle, suffix)))
                } else {
                    Err(ScanError::new(
                        start_mark,
                        "while scanning a tag, did not find expected whitespace or line break",
                    ))
                }
            }

            fn scan_tag_handle(&mut self, directive: bool, mark: &Marker) -> Result<String, ScanError> {
                let mut string = String::new();
                self.lookahead(1);
                if self.ch() != '!' {
                    return Err(ScanError::new(
                        *mark,
                        "while scanning a tag, did not find expected '!'",
                    ));
                }

                string.push(self.ch());
                self.skip();

                self.lookahead(1);
                while is_alpha(self.ch()) {
                    string.push(self.ch());
                    self.skip();
                    self.lookahead(1);
                }

                // Check if the trailing character is '!' and copy it.
                if self.ch() == '!' {
                    string.push(self.ch());
                    self.skip();
                } else if directive && string != "!" {
                    // It's either the '!' tag or not really a tag handle.  If it's a %TAG
                    // directive, it's an error.  If it's a tag token, it must be a part of
                    // URI.
                    return Err(ScanError::new(
                        *mark,
                        "while parsing a tag directive, did not find expected '!'",
                    ));
                }
                Ok(string)
            }

            fn scan_tag_uri(
                &mut self,
                directive: bool,
                _is_secondary: bool,
                head: &str,
                mark: &Marker,
            ) -> Result<String, ScanError> {
                let mut length = head.len();
                let mut string = String::new();

                // Copy the head if needed.
                // Note that we don't copy the leading '!' character.
                if length > 1 {
                    string.extend(head.chars().skip(1));
                }

                self.lookahead(1);
                /*
                * The set of characters that may appear in URI is as follows:
                *
                *      '0'-'9', 'A'-'Z', 'a'-'z', '_', '-', ';', '/', '?', ':', '@', '&',
                *      '=', '+', '$', ',', '.', '!', '~', '*', '\'', '(', ')', '[', ']',
                *      '%'.
                */
                while match self.ch() {
                    ';' | '/' | '?' | ':' | '@' | '&' => true,
                    '=' | '+' | '$' | ',' | '.' | '!' | '~' | '*' | '\'' | '(' | ')' | '[' | ']' => true,
                    '%' => true,
                    c if is_alpha(c) => true,
                    _ => false,
                } {
                    // Check if it is a URI-escape sequence.
                    if self.ch() == '%' {
                        string.push(self.scan_uri_escapes(directive, mark)?);
                    } else {
                        string.push(self.ch());
                        self.skip();
                    }

                    length += 1;
                    self.lookahead(1);
                }

                if length == 0 {
                    return Err(ScanError::new(
                        *mark,
                        "while parsing a tag, did not find expected tag URI",
                    ));
                }

                Ok(string)
            }

            fn scan_uri_escapes(&mut self, _directive: bool, mark: &Marker) -> Result<char, ScanError> {
                let mut width = 0usize;
                let mut code = 0u32;
                loop {
                    self.lookahead(3);

                    if !(self.ch() == '%' && is_hex(self.buffer[1]) && is_hex(self.buffer[2])) {
                        return Err(ScanError::new(
                            *mark,
                            "while parsing a tag, did not find URI escaped octet",
                        ));
                    }

                    let octet = (as_hex(self.buffer[1]) << 4) + as_hex(self.buffer[2]);
                    if width == 0 {
                        width = match octet {
                            _ if octet & 0x80 == 0x00 => 1,
                            _ if octet & 0xE0 == 0xC0 => 2,
                            _ if octet & 0xF0 == 0xE0 => 3,
                            _ if octet & 0xF8 == 0xF0 => 4,
                            _ => {
                                return Err(ScanError::new(
                                    *mark,
                                    "while parsing a tag, found an incorrect leading UTF-8 octet",
                                ));
                            }
                        };
                        code = octet;
                    } else {
                        if octet & 0xc0 != 0x80 {
                            return Err(ScanError::new(
                                *mark,
                                "while parsing a tag, found an incorrect trailing UTF-8 octet",
                            ));
                        }
                        code = (code << 8) + octet;
                    }

                    self.skip();
                    self.skip();
                    self.skip();

                    width -= 1;
                    if width == 0 {
                        break;
                    }
                }

                match char::from_u32(code) {
                    Some(ch) => Ok(ch),
                    None => Err(ScanError::new(
                        *mark,
                        "while parsing a tag, found an invalid UTF-8 codepoint",
                    )),
                }
            }

            fn fetch_anchor(&mut self, alias: bool) -> ScanResult {
                self.save_simple_key()?;
                self.disallow_simple_key();

                let tok = self.scan_anchor(alias)?;

                self.tokens.push_back(tok);

                Ok(())
            }

            fn scan_anchor(&mut self, alias: bool) -> Result<Token, ScanError> {
                let mut string = String::new();
                let start_mark = self.mark;

                self.skip();
                self.lookahead(1);
                while is_alpha(self.ch()) {
                    string.push(self.ch());
                    self.skip();
                    self.lookahead(1);
                }

                if string.is_empty()
                    || match self.ch() {
                        c if is_blankz(c) => false,
                        '?' | ':' | ',' | ']' | '}' | '%' | '@' | '`' => false,
                        _ => true,
                    }
                {
                    return Err(ScanError::new(start_mark, "while scanning an anchor or alias, did not find expected alphabetic or numeric character"));
                }

                if alias {
                    Ok(Token(start_mark, TokenType::Alias(string)))
                } else {
                    Ok(Token(start_mark, TokenType::Anchor(string)))
                }
            }

            fn fetch_flow_collection_start(&mut self, tok: TokenType) -> ScanResult {
                // The indicators '[' and '{' may start a simple key.
                self.save_simple_key()?;

                self.increase_flow_level()?;

                self.allow_simple_key();

                let start_mark = self.mark;
                self.skip();

                self.tokens.push_back(Token(start_mark, tok));
                Ok(())
            }

            fn fetch_flow_collection_end(&mut self, tok: TokenType) -> ScanResult {
                self.remove_simple_key()?;
                self.decrease_flow_level();

                self.disallow_simple_key();

                let start_mark = self.mark;
                self.skip();

                self.tokens.push_back(Token(start_mark, tok));
                Ok(())
            }

            fn fetch_flow_entry(&mut self) -> ScanResult {
                self.remove_simple_key()?;
                self.allow_simple_key();

                let start_mark = self.mark;
                self.skip();

                self.tokens
                    .push_back(Token(start_mark, TokenType::FlowEntry));
                Ok(())
            }

            fn increase_flow_level(&mut self) -> ScanResult {
                self.simple_keys.push(SimpleKey::new(Marker::new(0, 0, 0)));
                self.flow_level = self
                    .flow_level
                    .checked_add(1)
                    .ok_or_else(|| ScanError::new(self.mark, "recursion limit exceeded"))?;
                Ok(())
            }
            fn decrease_flow_level(&mut self) {
                if self.flow_level > 0 {
                    self.flow_level -= 1;
                    self.simple_keys.pop().unwrap();
                }
            }

            fn fetch_block_entry(&mut self) -> ScanResult {
                if self.flow_level == 0 {
                    // Check if we are allowed to start a new entry.
                    if !self.simple_key_allowed {
                        return Err(ScanError::new(
                            self.mark,
                            "block sequence entries are not allowed in this context",
                        ));
                    }

                    let mark = self.mark;
                    // generate BLOCK-SEQUENCE-START if indented
                    self.roll_indent(mark.col, None, TokenType::BlockSequenceStart, mark);
                } else {
                    // - * only allowed in block
                    return Err(ScanError::new(
                        self.mark,
                        r#""-" is only valid inside a block"#,
                    ));
                }
                self.remove_simple_key()?;
                self.allow_simple_key();

                let start_mark = self.mark;
                self.skip();

                self.tokens
                    .push_back(Token(start_mark, TokenType::BlockEntry));
                Ok(())
            }

            fn fetch_document_indicator(&mut self, t: TokenType) -> ScanResult {
                self.unroll_indent(-1);
                self.remove_simple_key()?;
                self.disallow_simple_key();

                let mark = self.mark;

                self.skip();
                self.skip();
                self.skip();

                self.tokens.push_back(Token(mark, t));
                Ok(())
            }

            fn fetch_block_scalar(&mut self, literal: bool) -> ScanResult {
                self.save_simple_key()?;
                self.allow_simple_key();
                let tok = self.scan_block_scalar(literal)?;

                self.tokens.push_back(tok);
                Ok(())
            }

            fn scan_block_scalar(&mut self, literal: bool) -> Result<Token, ScanError> {
                let start_mark = self.mark;
                let mut chomping: i32 = 0;
                let mut increment: usize = 0;
                let mut indent: usize = 0;
                let mut trailing_blank: bool;
                let mut leading_blank: bool = false;

                let mut string = String::new();
                let mut leading_break = String::new();
                let mut trailing_breaks = String::new();

                // skip '|' or '>'
                self.skip();
                self.lookahead(1);

                if self.ch() == '+' || self.ch() == '-' {
                    if self.ch() == '+' {
                        chomping = 1;
                    } else {
                        chomping = -1;
                    }
                    self.skip();
                    self.lookahead(1);
                    if is_digit(self.ch()) {
                        if self.ch() == '0' {
                            return Err(ScanError::new(
                                start_mark,
                                "while scanning a block scalar, found an indentation indicator equal to 0",
                            ));
                        }
                        increment = (self.ch() as usize) - ('0' as usize);
                        self.skip();
                    }
                } else if is_digit(self.ch()) {
                    if self.ch() == '0' {
                        return Err(ScanError::new(
                            start_mark,
                            "while scanning a block scalar, found an indentation indicator equal to 0",
                        ));
                    }

                    increment = (self.ch() as usize) - ('0' as usize);
                    self.skip();
                    self.lookahead(1);
                    if self.ch() == '+' || self.ch() == '-' {
                        if self.ch() == '+' {
                            chomping = 1;
                        } else {
                            chomping = -1;
                        }
                        self.skip();
                    }
                }

                // Eat whitespaces and comments to the end of the line.
                self.lookahead(1);

                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }

                if self.ch() == '#' {
                    while !is_breakz(self.ch()) {
                        self.skip();
                        self.lookahead(1);
                    }
                }

                // Check if we are at the end of the line.
                if !is_breakz(self.ch()) {
                    return Err(ScanError::new(
                        start_mark,
                        "while scanning a block scalar, did not find expected comment or line break",
                    ));
                }

                if is_break(self.ch()) {
                    self.lookahead(2);
                    self.skip_line();
                }

                if increment > 0 {
                    indent = if self.indent >= 0 {
                        (self.indent + increment as isize) as usize
                    } else {
                        increment
                    }
                }
                // Scan the leading line breaks and determine the indentation level if needed.
                self.block_scalar_breaks(&mut indent, &mut trailing_breaks)?;

                self.lookahead(1);

                let start_mark = self.mark;

                while self.mark.col == indent && !is_z(self.ch()) {
                    // We are at the beginning of a non-empty line.
                    trailing_blank = is_blank(self.ch());
                    if !literal && !leading_break.is_empty() && !leading_blank && !trailing_blank {
                        if trailing_breaks.is_empty() {
                            string.push(' ');
                        }
                        leading_break.clear();
                    } else {
                        string.push_str(&leading_break);
                        leading_break.clear();
                    }

                    string.push_str(&trailing_breaks);
                    trailing_breaks.clear();

                    leading_blank = is_blank(self.ch());

                    while !is_breakz(self.ch()) {
                        string.push(self.ch());
                        self.skip();
                        self.lookahead(1);
                    }
                    // break on EOF
                    if is_z(self.ch()) {
                        break;
                    }

                    self.lookahead(2);
                    self.read_break(&mut leading_break);

                    // Eat the following indentation spaces and line breaks.
                    self.block_scalar_breaks(&mut indent, &mut trailing_breaks)?;
                }

                // Chomp the tail.
                if chomping != -1 {
                    string.push_str(&leading_break);
                }

                if chomping == 1 {
                    string.push_str(&trailing_breaks);
                }

                if literal {
                    Ok(Token(
                        start_mark,
                        TokenType::Scalar(TScalarStyle::Literal, string),
                    ))
                } else {
                    Ok(Token(
                        start_mark,
                        TokenType::Scalar(TScalarStyle::Foled, string),
                    ))
                }
            }

            fn block_scalar_breaks(&mut self, indent: &mut usize, breaks: &mut String) -> ScanResult {
                let mut max_indent = 0;
                loop {
                    self.lookahead(1);
                    while (*indent == 0 || self.mark.col < *indent) && self.buffer[0] == ' ' {
                        self.skip();
                        self.lookahead(1);
                    }

                    if self.mark.col > max_indent {
                        max_indent = self.mark.col;
                    }

                    // Check for a tab character messing the indentation.
                    if (*indent == 0 || self.mark.col < *indent) && self.buffer[0] == '\t' {
                        return Err(ScanError::new(self.mark,
                                "while scanning a block scalar, found a tab character where an indentation space is expected"));
                    }

                    if !is_break(self.ch()) {
                        break;
                    }

                    self.lookahead(2);
                    // Consume the line break.
                    self.read_break(breaks);
                }

                if *indent == 0 {
                    *indent = max_indent;
                    if *indent < (self.indent + 1) as usize {
                        *indent = (self.indent + 1) as usize;
                    }
                    if *indent < 1 {
                        *indent = 1;
                    }
                }
                Ok(())
            }

            fn fetch_flow_scalar(&mut self, single: bool) -> ScanResult {
                self.save_simple_key()?;
                self.disallow_simple_key();

                let tok = self.scan_flow_scalar(single)?;

                // From spec: To ensure JSON compatibility, if a key inside a flow mapping is JSON-like,
                // YAML allows the following value to be specified adjacent to the :.
                self.adjacent_value_allowed_at = self.mark.index;

                self.tokens.push_back(tok);
                Ok(())
            }

            fn scan_flow_scalar(&mut self, single: bool) -> Result<Token, ScanError> {
                let start_mark = self.mark;

                let mut string = String::new();
                let mut leading_break = String::new();
                let mut trailing_breaks = String::new();
                let mut whitespaces = String::new();
                let mut leading_blanks;

                /* Eat the left quote. */
                self.skip();

                loop {
                    /* Check for a document indicator. */
                    self.lookahead(4);

                    if self.mark.col == 0
                        && (((self.buffer[0] == '-') && (self.buffer[1] == '-') && (self.buffer[2] == '-'))
                            || ((self.buffer[0] == '.')
                                && (self.buffer[1] == '.')
                                && (self.buffer[2] == '.')))
                        && is_blankz(self.buffer[3])
                    {
                        return Err(ScanError::new(
                            start_mark,
                            "while scanning a quoted scalar, found unexpected document indicator",
                        ));
                    }

                    if is_z(self.ch()) {
                        return Err(ScanError::new(
                            start_mark,
                            "while scanning a quoted scalar, found unexpected end of stream",
                        ));
                    }

                    self.lookahead(2);

                    leading_blanks = false;
                    // Consume non-blank characters.

                    while !is_blankz(self.ch()) {
                        match self.ch() {
                            // Check for an escaped single quote.
                            '\'' if self.buffer[1] == '\'' && single => {
                                string.push('\'');
                                self.skip();
                                self.skip();
                            }
                            // Check for the right quote.
                            '\'' if single => break,
                            '"' if !single => break,
                            // Check for an escaped line break.
                            '\\' if !single && is_break(self.buffer[1]) => {
                                self.lookahead(3);
                                self.skip();
                                self.skip_line();
                                leading_blanks = true;
                                break;
                            }
                            // Check for an escape sequence.
                            '\\' if !single => {
                                let mut code_length = 0usize;
                                match self.buffer[1] {
                                    '0' => string.push('\0'),
                                    'a' => string.push('\x07'),
                                    'b' => string.push('\x08'),
                                    't' | '\t' => string.push('\t'),
                                    'n' => string.push('\n'),
                                    'v' => string.push('\x0b'),
                                    'f' => string.push('\x0c'),
                                    'r' => string.push('\x0d'),
                                    'e' => string.push('\x1b'),
                                    ' ' => string.push('\x20'),
                                    '"' => string.push('"'),
                                    '\'' => string.push('\''),
                                    '\\' => string.push('\\'),
                                    // NEL (#x85)
                                    'N' => string.push(char::from_u32(0x85).unwrap()),
                                    // #xA0
                                    '_' => string.push(char::from_u32(0xA0).unwrap()),
                                    // LS (#x2028)
                                    'L' => string.push(char::from_u32(0x2028).unwrap()),
                                    // PS (#x2029)
                                    'P' => string.push(char::from_u32(0x2029).unwrap()),
                                    'x' => code_length = 2,
                                    'u' => code_length = 4,
                                    'U' => code_length = 8,
                                    _ => {
                                        return Err(ScanError::new(
                                            start_mark,
                                            "while parsing a quoted scalar, found unknown escape character",
                                        ))
                                    }
                                }
                                self.skip();
                                self.skip();
                                // Consume an arbitrary escape code.
                                if code_length > 0 {
                                    self.lookahead(code_length);
                                    let mut value = 0u32;
                                    for i in 0..code_length {
                                        if !is_hex(self.buffer[i]) {
                                            return Err(ScanError::new(start_mark,
                                                "while parsing a quoted scalar, did not find expected hexadecimal number"));
                                        }
                                        value = (value << 4) + as_hex(self.buffer[i]);
                                    }

                                    let ch = match char::from_u32(value) {
                                        Some(v) => v,
                                        None => {
                                            return Err(ScanError::new(start_mark,
                                                "while parsing a quoted scalar, found invalid Unicode character escape code"));
                                        }
                                    };
                                    string.push(ch);

                                    for _ in 0..code_length {
                                        self.skip();
                                    }
                                }
                            }
                            c => {
                                string.push(c);
                                self.skip();
                            }
                        }
                        self.lookahead(2);
                    }
                    self.lookahead(1);
                    match self.ch() {
                        '\'' if single => break,
                        '"' if !single => break,
                        _ => {}
                    }

                    // Consume blank characters.
                    while is_blank(self.ch()) || is_break(self.ch()) {
                        if is_blank(self.ch()) {
                            // Consume a space or a tab character.
                            if leading_blanks {
                                self.skip();
                            } else {
                                whitespaces.push(self.ch());
                                self.skip();
                            }
                        } else {
                            self.lookahead(2);
                            // Check if it is a first line break.
                            if leading_blanks {
                                self.read_break(&mut trailing_breaks);
                            } else {
                                whitespaces.clear();
                                self.read_break(&mut leading_break);
                                leading_blanks = true;
                            }
                        }
                        self.lookahead(1);
                    }
                    // Join the whitespaces or fold line breaks.
                    if leading_blanks {
                        if leading_break.is_empty() {
                            string.push_str(&leading_break);
                            string.push_str(&trailing_breaks);
                            trailing_breaks.clear();
                            leading_break.clear();
                        } else {
                            if trailing_breaks.is_empty() {
                                string.push(' ');
                            } else {
                                string.push_str(&trailing_breaks);
                                trailing_breaks.clear();
                            }
                            leading_break.clear();
                        }
                    } else {
                        string.push_str(&whitespaces);
                        whitespaces.clear();
                    }
                } // loop

                // Eat the right quote.
                self.skip();

                if single {
                    Ok(Token(
                        start_mark,
                        TokenType::Scalar(TScalarStyle::SingleQuoted, string),
                    ))
                } else {
                    Ok(Token(
                        start_mark,
                        TokenType::Scalar(TScalarStyle::DoubleQuoted, string),
                    ))
                }
            }

            fn fetch_plain_scalar(&mut self) -> ScanResult {
                self.save_simple_key()?;
                self.disallow_simple_key();

                let tok = self.scan_plain_scalar()?;

                self.tokens.push_back(tok);
                Ok(())
            }

            fn scan_plain_scalar(&mut self) -> Result<Token, ScanError> {
                let indent = self.indent + 1;
                let start_mark = self.mark;

                let mut string = String::new();
                let mut leading_break = String::new();
                let mut trailing_breaks = String::new();
                let mut whitespaces = String::new();
                let mut leading_blanks = false;

                loop {
                    /* Check for a document indicator. */
                    self.lookahead(4);

                    if self.mark.col == 0
                        && (((self.buffer[0] == '-') && (self.buffer[1] == '-') && (self.buffer[2] == '-'))
                            || ((self.buffer[0] == '.')
                                && (self.buffer[1] == '.')
                                && (self.buffer[2] == '.')))
                        && is_blankz(self.buffer[3])
                    {
                        break;
                    }

                    if self.ch() == '#' {
                        break;
                    }
                    while !is_blankz(self.ch()) {
                        // indicators can end a plain scalar, see 7.3.3. Plain Style
                        match self.ch() {
                            ':' if is_blankz(self.buffer[1])
                                || (self.flow_level > 0 && is_flow(self.buffer[1])) =>
                            {
                                break;
                            }
                            ',' | '[' | ']' | '{' | '}' if self.flow_level > 0 => break,
                            _ => {}
                        }

                        if leading_blanks || !whitespaces.is_empty() {
                            if leading_blanks {
                                if leading_break.is_empty() {
                                    string.push_str(&leading_break);
                                    string.push_str(&trailing_breaks);
                                    trailing_breaks.clear();
                                    leading_break.clear();
                                } else {
                                    if trailing_breaks.is_empty() {
                                        string.push(' ');
                                    } else {
                                        string.push_str(&trailing_breaks);
                                        trailing_breaks.clear();
                                    }
                                    leading_break.clear();
                                }
                                leading_blanks = false;
                            } else {
                                string.push_str(&whitespaces);
                                whitespaces.clear();
                            }
                        }

                        string.push(self.ch());
                        self.skip();
                        self.lookahead(2);
                    }
                    // is the end?
                    if !(is_blank(self.ch()) || is_break(self.ch())) {
                        break;
                    }
                    self.lookahead(1);

                    while is_blank(self.ch()) || is_break(self.ch()) {
                        if is_blank(self.ch()) {
                            if leading_blanks && (self.mark.col as isize) < indent && self.ch() == '\t' {
                                return Err(ScanError::new(
                                    start_mark,
                                    "while scanning a plain scalar, found a tab",
                                ));
                            }

                            if leading_blanks {
                                self.skip();
                            } else {
                                whitespaces.push(self.ch());
                                self.skip();
                            }
                        } else {
                            self.lookahead(2);
                            // Check if it is a first line break
                            if leading_blanks {
                                self.read_break(&mut trailing_breaks);
                            } else {
                                whitespaces.clear();
                                self.read_break(&mut leading_break);
                                leading_blanks = true;
                            }
                        }
                        self.lookahead(1);
                    }

                    // check indentation level
                    if self.flow_level == 0 && (self.mark.col as isize) < indent {
                        break;
                    }
                }

                if leading_blanks {
                    self.allow_simple_key();
                }

                Ok(Token(
                    start_mark,
                    TokenType::Scalar(TScalarStyle::Plain, string),
                ))
            }

            fn fetch_key(&mut self) -> ScanResult {
                let start_mark = self.mark;
                if self.flow_level == 0 {
                    // Check if we are allowed to start a new key (not necessarily simple).
                    if !self.simple_key_allowed {
                        return Err(ScanError::new(
                            self.mark,
                            "mapping keys are not allowed in this context",
                        ));
                    }
                    self.roll_indent(
                        start_mark.col,
                        None,
                        TokenType::BlockMappingStart,
                        start_mark,
                    );
                }

                self.remove_simple_key()?;

                if self.flow_level == 0 {
                    self.allow_simple_key();
                } else {
                    self.disallow_simple_key();
                }

                self.skip();
                self.tokens.push_back(Token(start_mark, TokenType::Key));
                Ok(())
            }

            fn fetch_value(&mut self) -> ScanResult {
                let sk = self.simple_keys.last().unwrap().clone();
                let start_mark = self.mark;
                if sk.possible {
                    // insert simple key
                    let tok = Token(sk.mark, TokenType::Key);
                    let tokens_parsed = self.tokens_parsed;
                    self.insert_token(sk.token_number - tokens_parsed, tok);

                    // Add the BLOCK-MAPPING-START token if needed.
                    self.roll_indent(
                        sk.mark.col,
                        Some(sk.token_number),
                        TokenType::BlockMappingStart,
                        start_mark,
                    );

                    self.simple_keys.last_mut().unwrap().possible = false;
                    self.disallow_simple_key();
                } else {
                    // The ':' indicator follows a complex key.
                    if self.flow_level == 0 {
                        if !self.simple_key_allowed {
                            return Err(ScanError::new(
                                start_mark,
                                "mapping values are not allowed in this context",
                            ));
                        }

                        self.roll_indent(
                            start_mark.col,
                            None,
                            TokenType::BlockMappingStart,
                            start_mark,
                        );
                    }

                    if self.flow_level == 0 {
                        self.allow_simple_key();
                    } else {
                        self.disallow_simple_key();
                    }
                }
                self.skip();
                self.tokens.push_back(Token(start_mark, TokenType::Value));

                Ok(())
            }

            fn roll_indent(&mut self, col: usize, number: Option<usize>, tok: TokenType, mark: Marker) {
                if self.flow_level > 0 {
                    return;
                }

                if self.indent < col as isize {
                    self.indents.push(self.indent);
                    self.indent = col as isize;
                    let tokens_parsed = self.tokens_parsed;
                    match number {
                        Some(n) => self.insert_token(n - tokens_parsed, Token(mark, tok)),
                        None => self.tokens.push_back(Token(mark, tok)),
                    }
                }
            }

            fn unroll_indent(&mut self, col: isize) {
                if self.flow_level > 0 {
                    return;
                }
                while self.indent > col {
                    self.tokens.push_back(Token(self.mark, TokenType::BlockEnd));
                    self.indent = self.indents.pop().unwrap();
                }
            }

            fn save_simple_key(&mut self) -> Result<(), ScanError> {
                let required = self.flow_level > 0 && self.indent == (self.mark.col as isize);
                if self.simple_key_allowed {
                    let mut sk = SimpleKey::new(self.mark);
                    sk.possible = true;
                    sk.required = required;
                    sk.token_number = self.tokens_parsed + self.tokens.len();

                    self.remove_simple_key()?;

                    self.simple_keys.pop();
                    self.simple_keys.push(sk);
                }
                Ok(())
            }

            fn remove_simple_key(&mut self) -> ScanResult {
                let last = self.simple_keys.last_mut().unwrap();
                if last.possible && last.required {
                    return Err(ScanError::new(self.mark, "simple key expected"));
                }

                last.possible = false;
                Ok(())
            }
        }
    }

    pub mod yaml
    {
        use ::
        {
            *,
        };
        use linked_hash_map::LinkedHashMap;
        use crate::parser::*;
        use crate::scanner::{Marker, ScanError, TScalarStyle, TokenType};
        use std::collections::BTreeMap;
        use std::f64;
        use std::i64;
        use std::mem;
        use std::ops::Index;
        use std::string;
        use std::vec;

        /// A YAML node is stored as this `Yaml` enumeration, which provides an easy way to access your YAML document.
        #[derive(Clone, PartialEq, PartialOrd, Debug, Eq, Ord, Hash)]
        pub enum Yaml {
            /// Float types are stored as String and parsed on demand.
            /// Note that f64 does NOT implement Eq trait and can NOT be stored in BTreeMap.
            Real(string::String),
            /// YAML int is stored as i64.
            Integer(i64),
            /// YAML scalar.
            String(string::String),
            /// YAML bool, e.g. `true` or `false`.
            Boolean(bool),
            /// YAML array, can be accessed as a `Vec`.
            Array(self::Array),
            /// YAML hash, can be accessed as a `LinkedHashMap`.
            ///
            /// Insertion order will match the order of insertion into the map.
            Hash(self::Hash),
            /// Alias, not fully supported yet.
            Alias(usize),
            /// YAML null, e.g. `null` or `~`.
            Null,
            /// Accessing a nonexistent node via the Index trait returns `BadValue`. This
            /// simplifies error handling in the calling code. Invalid type conversion also
            /// returns `BadValue`.
            BadValue,
        }

        pub type Array = Vec<Yaml>;
        pub type Hash = LinkedHashMap<Yaml, Yaml>;

        // parse f64 as Core schema
        // See: https://github.com/chyh1990/yaml-rust/issues/51
        fn parse_f64(v: &str) -> Option<f64> {
            match v {
                ".inf" | ".Inf" | ".INF" | "+.inf" | "+.Inf" | "+.INF" => Some(f64::INFINITY),
                "-.inf" | "-.Inf" | "-.INF" => Some(f64::NEG_INFINITY),
                ".nan" | "NaN" | ".NAN" => Some(f64::NAN),
                _ => v.parse::<f64>().ok(),
            }
        }

        pub struct YamlLoader {
            docs: Vec<Yaml>,
            // states
            // (current node, anchor_id) tuple
            doc_stack: Vec<(Yaml, usize)>,
            key_stack: Vec<Yaml>,
            anchor_map: BTreeMap<usize, Yaml>,
        }

        impl MarkedEventReceiver for YamlLoader {
            fn on_event(&mut self, ev: Event, _: Marker) {
                // println!("EV {:?}", ev);
                match ev {
                    Event::DocumentStart => {
                        // do nothing
                    }
                    Event::DocumentEnd => {
                        match self.doc_stack.len() {
                            // empty document
                            0 => self.docs.push(Yaml::BadValue),
                            1 => self.docs.push(self.doc_stack.pop().unwrap().0),
                            _ => unreachable!(),
                        }
                    }
                    Event::SequenceStart(aid) => {
                        self.doc_stack.push((Yaml::Array(Vec::new()), aid));
                    }
                    Event::SequenceEnd => {
                        let node = self.doc_stack.pop().unwrap();
                        self.insert_new_node(node);
                    }
                    Event::MappingStart(aid) => {
                        self.doc_stack.push((Yaml::Hash(Hash::new()), aid));
                        self.key_stack.push(Yaml::BadValue);
                    }
                    Event::MappingEnd => {
                        self.key_stack.pop().unwrap();
                        let node = self.doc_stack.pop().unwrap();
                        self.insert_new_node(node);
                    }
                    Event::Scalar(v, style, aid, tag) => {
                        let node = if style != TScalarStyle::Plain {
                            Yaml::String(v)
                        } else if let Some(TokenType::Tag(ref handle, ref suffix)) = tag {
                            // XXX tag:yaml.org,2002:
                            if handle == "!!" {
                                match suffix.as_ref() {
                                    "bool" => {
                                        // "true" or "false"
                                        match v.parse::<bool>() {
                                            Err(_) => Yaml::BadValue,
                                            Ok(v) => Yaml::Boolean(v),
                                        }
                                    }
                                    "int" => match v.parse::<i64>() {
                                        Err(_) => Yaml::BadValue,
                                        Ok(v) => Yaml::Integer(v),
                                    },
                                    "float" => match parse_f64(&v) {
                                        Some(_) => Yaml::Real(v),
                                        None => Yaml::BadValue,
                                    },
                                    "null" => match v.as_ref() {
                                        "~" | "null" => Yaml::Null,
                                        _ => Yaml::BadValue,
                                    },
                                    _ => Yaml::String(v),
                                }
                            } else {
                                Yaml::String(v)
                            }
                        } else {
                            // Datatype is not specified, or unrecognized
                            Yaml::from_str(&v)
                        };

                        self.insert_new_node((node, aid));
                    }
                    Event::Alias(id) => {
                        let n = match self.anchor_map.get(&id) {
                            Some(v) => v.clone(),
                            None => Yaml::BadValue,
                        };
                        self.insert_new_node((n, 0));
                    }
                    _ => { /* ignore */ }
                }
                // println!("DOC {:?}", self.doc_stack);
            }
        }

        impl YamlLoader {
            fn insert_new_node(&mut self, node: (Yaml, usize)) {
                // valid anchor id starts from 1
                if node.1 > 0 {
                    self.anchor_map.insert(node.1, node.0.clone());
                }
                if self.doc_stack.is_empty() {
                    self.doc_stack.push(node);
                } else {
                    let parent = self.doc_stack.last_mut().unwrap();
                    match *parent {
                        (Yaml::Array(ref mut v), _) => v.push(node.0),
                        (Yaml::Hash(ref mut h), _) => {
                            let cur_key = self.key_stack.last_mut().unwrap();
                            // current node is a key
                            if cur_key.is_badvalue() {
                                *cur_key = node.0;
                            // current node is a value
                            } else {
                                let mut newkey = Yaml::BadValue;
                                mem::swap(&mut newkey, cur_key);
                                h.insert(newkey, node.0);
                            }
                        }
                        _ => unreachable!(),
                    }
                }
            }

            pub fn load_from_str(source: &str) -> Result<Vec<Yaml>, ScanError> {
                let mut loader = YamlLoader {
                    docs: Vec::new(),
                    doc_stack: Vec::new(),
                    key_stack: Vec::new(),
                    anchor_map: BTreeMap::new(),
                };
                let mut parser = Parser::new(source.chars());
                parser.load(&mut loader, true)?;
                Ok(loader.docs)
            }
        }

        macro_rules! define_as (
            ($name:ident, $t:ident, $yt:ident) => (
        pub fn $name(&self) -> Option<$t> {
            match *self {
                Yaml::$yt(v) => Some(v),
                _ => None
            }
        }
            );
        );

        macro_rules! define_as_ref (
            ($name:ident, $t:ty, $yt:ident) => (
        pub fn $name(&self) -> Option<$t> {
            match *self {
                Yaml::$yt(ref v) => Some(v),
                _ => None
            }
        }
            );
        );

        macro_rules! define_into (
            ($name:ident, $t:ty, $yt:ident) => (
        pub fn $name(self) -> Option<$t> {
            match self {
                Yaml::$yt(v) => Some(v),
                _ => None
            }
        }
            );
        );

        impl Yaml {
            define_as!(as_bool, bool, Boolean);
            define_as!(as_i64, i64, Integer);

            define_as_ref!(as_str, &str, String);
            define_as_ref!(as_hash, &Hash, Hash);
            define_as_ref!(as_vec, &Array, Array);

            define_into!(into_bool, bool, Boolean);
            define_into!(into_i64, i64, Integer);
            define_into!(into_string, String, String);
            define_into!(into_hash, Hash, Hash);
            define_into!(into_vec, Array, Array);

            pub fn is_null(&self) -> bool {
                match *self {
                    Yaml::Null => true,
                    _ => false,
                }
            }

            pub fn is_badvalue(&self) -> bool {
                match *self {
                    Yaml::BadValue => true,
                    _ => false,
                }
            }

            pub fn is_array(&self) -> bool {
                match *self {
                    Yaml::Array(_) => true,
                    _ => false,
                }
            }

            pub fn as_f64(&self) -> Option<f64> {
                match *self {
                    Yaml::Real(ref v) => parse_f64(v),
                    _ => None,
                }
            }

            pub fn into_f64(self) -> Option<f64> {
                match self {
                    Yaml::Real(ref v) => parse_f64(v),
                    _ => None,
                }
            }
        }

        #[cfg_attr(feature = "cargo-clippy", allow(should_implement_trait))]
        impl Yaml {
            // Not implementing FromStr because there is no possibility of Error.
            // This function falls back to Yaml::String if nothing else matches.
            pub fn from_str(v: &str) -> Yaml {
                if v.starts_with("0x") {
                    if let Ok(i) = i64::from_str_radix(&v[2..], 16) {
                        return Yaml::Integer(i);
                    }
                }
                if v.starts_with("0o") {
                    if let Ok(i) = i64::from_str_radix(&v[2..], 8) {
                        return Yaml::Integer(i);
                    }
                }
                if v.starts_with('+') {
                    if let Ok(i) = v[1..].parse::<i64>() {
                        return Yaml::Integer(i);
                    }
                }
                match v {
                    "~" | "null" => Yaml::Null,
                    "true" => Yaml::Boolean(true),
                    "false" => Yaml::Boolean(false),
                    _ if v.parse::<i64>().is_ok() => Yaml::Integer(v.parse::<i64>().unwrap()),
                    // try parsing as f64
                    _ if parse_f64(v).is_some() => Yaml::Real(v.to_owned()),
                    _ => Yaml::String(v.to_owned()),
                }
            }
        }

        static BAD_VALUE: Yaml = Yaml::BadValue;
        impl<'a> Index<&'a str> for Yaml {
            type Output = Yaml;

            fn index(&self, idx: &'a str) -> &Yaml {
                let key = Yaml::String(idx.to_owned());
                match self.as_hash() {
                    Some(h) => h.get(&key).unwrap_or(&BAD_VALUE),
                    None => &BAD_VALUE,
                }
            }
        }

        impl Index<usize> for Yaml {
            type Output = Yaml;

            fn index(&self, idx: usize) -> &Yaml {
                if let Some(v) = self.as_vec() {
                    v.get(idx).unwrap_or(&BAD_VALUE)
                } else if let Some(v) = self.as_hash() {
                    let key = Yaml::Integer(idx as i64);
                    v.get(&key).unwrap_or(&BAD_VALUE)
                } else {
                    &BAD_VALUE
                }
            }
        }

        impl IntoIterator for Yaml {
            type Item = Yaml;
            type IntoIter = YamlIter;

            fn into_iter(self) -> Self::IntoIter {
                YamlIter {
                    yaml: self.into_vec().unwrap_or_else(Vec::new).into_iter(),
                }
            }
        }

        pub struct YamlIter {
            yaml: vec::IntoIter<Yaml>,
        }

        impl Iterator for YamlIter {
            type Item = Yaml;

            fn next(&mut self) -> Option<Yaml> {
                self.yaml.next()
            }
        }
    }
    
    pub use crate::emitter::{EmitError, YamlEmitter};
    pub use crate::parser::Event;
    pub use crate::scanner::ScanError;
    pub use crate::yaml::{Yaml, YamlLoader};
}

pub mod linked_hash_map
{
    //! A `HashMap` wrapper that holds key-value pairs in insertion order.
    use ::
    {
        *,
    };
    /*
    use std::borrow::Borrow;
    use std::cmp::Ordering;
    use std::collections::hash_map::{self, HashMap};
    use std::fmt;
    use std::hash::{BuildHasher, Hash, Hasher};
    use std::iter;
    use std::marker;
    use std::mem;
    use std::ops::{Index, IndexMut};
    use std::ptr::{self, addr_of_mut};
    */
    // Optional Serde support
    pub mod serde
    {
        //! An optional implementation of serialization/deserialization.
        use ::
        {
            *,
        };
        
        extern crate serde;

        use std::fmt::{Formatter, Result as FmtResult};
        use std::hash::{BuildHasher, Hash};
        use std::marker::PhantomData;

        use super::LinkedHashMap;

        use self::serde::de::{Error, MapAccess, Visitor};
        use self::serde::ser::SerializeMap;
        use self::serde::{Deserialize, Deserializer, Serialize, Serializer};

        impl<K, V, S> Serialize for LinkedHashMap<K, V, S>
        where
            K: Serialize + Eq + Hash,
            V: Serialize,
            S: BuildHasher,
        {
            #[inline]
            fn serialize<T>(&self, serializer: T) -> Result<T::Ok, T::Error>
            where
                T: Serializer,
            {
                let mut map_serializer = serializer.serialize_map(Some(self.len()))?;
                for (k, v) in self {
                    map_serializer.serialize_key(k)?;
                    map_serializer.serialize_value(v)?;
                }
                map_serializer.end()
            }
        }

        #[derive(Debug)]
        /// `serde::de::Visitor` for a linked hash map.
        pub struct LinkedHashMapVisitor<K, V> {
            marker: PhantomData<LinkedHashMap<K, V>>,
        }

        impl<K, V> LinkedHashMapVisitor<K, V> {
            /// Creates a new visitor for a linked hash map.
            pub fn new() -> Self {
                LinkedHashMapVisitor {
                    marker: PhantomData,
                }
            }
        }

        impl<K, V> Default for LinkedHashMapVisitor<K, V> {
            fn default() -> Self {
                LinkedHashMapVisitor::new()
            }
        }

        impl<'de, K, V> Visitor<'de> for LinkedHashMapVisitor<K, V>
        where
            K: Deserialize<'de> + Eq + Hash,
            V: Deserialize<'de>,
        {
            type Value = LinkedHashMap<K, V>;

            fn expecting(&self, formatter: &mut Formatter) -> FmtResult {
                write!(formatter, "a map")
            }

            #[inline]
            fn visit_unit<E>(self) -> Result<Self::Value, E>
            where
                E: Error,
            {
                Ok(LinkedHashMap::new())
            }

            #[inline]
            fn visit_map<M>(self, mut map: M) -> Result<Self::Value, M::Error>
            where
                M: MapAccess<'de>,
            {
                let mut values = LinkedHashMap::with_capacity(map.size_hint().unwrap_or(0));

                while let Some((key, value)) = map.next_entry()? {
                    values.insert(key, value);
                }

                Ok(values)
            }
        }

        impl<'de, K, V> Deserialize<'de> for LinkedHashMap<K, V>
        where
            K: Deserialize<'de> + Eq + Hash,
            V: Deserialize<'de>,
        {
            fn deserialize<D>(deserializer: D) -> Result<LinkedHashMap<K, V>, D::Error>
            where
                D: Deserializer<'de>,
            {
                deserializer.deserialize_map(LinkedHashMapVisitor::new())
            }
        }
    }
    // Optional Heapsize support
    mod heapsize
    {
        use ::
        {
            *,
        };

        extern crate heapsize;

        use self::heapsize::{heap_size_of, HeapSizeOf};
        use std::hash::{BuildHasher, Hash};

        use {KeyRef, LinkedHashMap, Node};

        impl<K> HeapSizeOf for KeyRef<K> {
            fn heap_size_of_children(&self) -> usize {
                0
            }
        }

        impl<K, V> HeapSizeOf for Node<K, V>
        where
            K: HeapSizeOf,
            V: HeapSizeOf,
        {
            fn heap_size_of_children(&self) -> usize {
                self.key.heap_size_of_children() + self.value.heap_size_of_children()
            }
        }

        impl<K, V, S> HeapSizeOf for LinkedHashMap<K, V, S>
        where
            K: HeapSizeOf + Hash + Eq,
            V: HeapSizeOf,
            S: BuildHasher,
        {
            fn heap_size_of_children(&self) -> usize {
                unsafe {
                    let mut size = self.map.heap_size_of_children();
                    for &value in self.map.values() {
                        size += (*value).heap_size_of_children();
                        size += heap_size_of(value as *const _ as *const _);
                    }

                    if !self.head.is_null() {
                        size += heap_size_of(self.head as *const _ as *const _);
                    }

                    let mut free = self.free;
                    while !free.is_null() {
                        size += heap_size_of(free as *const _ as *const _);
                        free = (*free).next
                    }

                    size
                }
            }
        }
    }

    struct KeyRef<K> {
        k: *const K,
    }

    struct Node<K, V> {
        next: *mut Node<K, V>,
        prev: *mut Node<K, V>,
        key: K,
        value: V,
    }
    /// A linked hash map.
    pub struct LinkedHashMap<K, V, S = hash_map::RandomState> {
        map: HashMap<KeyRef<K>, *mut Node<K, V>, S>,
        head: *mut Node<K, V>,
        free: *mut Node<K, V>,
    }

    impl<K: Hash> Hash for KeyRef<K> {
        fn hash<H: Hasher>(&self, state: &mut H) {
            unsafe { (*self.k).hash(state) }
        }
    }

    impl<K: PartialEq> PartialEq for KeyRef<K> {
        fn eq(&self, other: &Self) -> bool {
            unsafe { (*self.k).eq(&*other.k) }
        }
    }

    impl<K: Eq> Eq for KeyRef<K> {}

    // This type exists only to support borrowing `KeyRef`s, which cannot be borrowed to `Q` directly due to conflicting implementations of `Borrow`.
    #[derive(Hash, PartialEq, Eq)]
    #[repr(transparent)]
    struct Qey<Q: ?Sized>(Q);

    impl<Q: ?Sized> Qey<Q> {
        fn from_ref(q: &Q) -> &Self {
            unsafe { mem::transmute(q) }
        }
    }

    impl<K, Q: ?Sized> Borrow<Qey<Q>> for KeyRef<K> where
        K: Borrow<Q>,
    {
        fn borrow(&self) -> &Qey<Q> {
            Qey::from_ref(unsafe { (*self.k).borrow() })
        }
    }

    impl<K, V> Node<K, V> {
        fn new(k: K, v: V) -> Self {
            Node {
                key: k,
                value: v,
                next: ptr::null_mut(),
                prev: ptr::null_mut(),
            }
        }
    }

    // drop empty node without dropping its key and value
    unsafe fn drop_empty_node<K, V>(the_box: *mut Node<K, V>) {
        // Safety:
        // In this crate all `Node` is allocated via `Box` or `alloc`, and `Box` uses the
        // Global allocator for its allocation,
        // (https://doc.rust-lang.org/std/boxed/index.html#memory-layout) so we can safely
        // deallocate the pointer to `Node` by calling `dealloc` method
        let layout = std::alloc::Layout::new::<Node<K, V>>();
        std::alloc::dealloc(the_box as *mut u8, layout);
    }

    impl<K: Hash + Eq, V> LinkedHashMap<K, V> {
        /// Creates a linked hash map.
        pub fn new() -> Self {
            Self::with_map(HashMap::new())
        }
        /// Creates an empty linked hash map with the given initial capacity.
        pub fn with_capacity(capacity: usize) -> Self {
            Self::with_map(HashMap::with_capacity(capacity))
        }
    }

    impl<K, V, S> LinkedHashMap<K, V, S> {
        #[inline]
        fn detach(&mut self, node: *mut Node<K, V>) {
            unsafe {
                (*(*node).prev).next = (*node).next;
                (*(*node).next).prev = (*node).prev;
            }
        }

        #[inline]
        fn attach(&mut self, node: *mut Node<K, V>) {
            unsafe {
                (*node).next = (*self.head).next;
                (*node).prev = self.head;
                (*self.head).next = node;
                (*(*node).next).prev = node;
            }
        }

        // Caller must check `!self.head.is_null()`
        unsafe fn drop_entries(&mut self) {
            let mut cur = (*self.head).next;
            while cur != self.head {
                let next = (*cur).next;
                Box::from_raw(cur);
                cur = next;
            }
        }

        fn clear_free_list(&mut self) {
            unsafe {
                let mut free = self.free;
                while !free.is_null() {
                    let next_free = (*free).next;
                    drop_empty_node(free);
                    free = next_free;
                }
                self.free = ptr::null_mut();
            }
        }

        fn ensure_guard_node(&mut self) {
            if self.head.is_null() {
                // allocate the guard node if not present
                unsafe {
                    let node_layout = std::alloc::Layout::new::<Node<K, V>>();
                    self.head = std::alloc::alloc(node_layout) as *mut Node<K, V>;
                    (*self.head).next = self.head;
                    (*self.head).prev = self.head;
                }
            }
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher> LinkedHashMap<K, V, S> {
        fn with_map(map: HashMap<KeyRef<K>, *mut Node<K, V>, S>) -> Self {
            LinkedHashMap {
                map,
                head: ptr::null_mut(),
                free: ptr::null_mut(),
            }
        }
        /// Creates an empty linked hash map with the given initial hash builder.
        pub fn with_hasher(hash_builder: S) -> Self {
            Self::with_map(HashMap::with_hasher(hash_builder))
        }
        /// Creates an empty linked hash map with the given initial capacity and hash builder.
        pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> Self {
            Self::with_map(HashMap::with_capacity_and_hasher(capacity, hash_builder))
        }
        /// Reserves capacity for at least `additional` more elements to be inserted into the map.
        pub fn reserve(&mut self, additional: usize) {
            self.map.reserve(additional);
        }
        /// Shrinks the capacity of the map as much as possible.
        pub fn shrink_to_fit(&mut self) {
            self.map.shrink_to_fit();
            self.clear_free_list();
        }
        /// Gets the given key's corresponding entry in the map for in-place manipulation.
        pub fn entry(&mut self, k: K) -> Entry<K, V, S> {
            let self_ptr: *mut Self = self;

            if let Some(entry) = self.map.get_mut(&KeyRef { k: &k }) {
                return Entry::Occupied(OccupiedEntry {
                    entry: *entry,
                    map: self_ptr,
                    marker: marker::PhantomData,
                });
            }

            Entry::Vacant(VacantEntry { key: k, map: self })
        }
        /// Returns an iterator visiting all entries in insertion order.
        pub fn entries(&mut self) -> Entries<K, V, S> {
            let head = if !self.head.is_null() {
                unsafe { (*self.head).prev }
            } else {
                ptr::null_mut()
            };
            Entries {
                map: self,
                head,
                remaining: self.len(),
                marker: marker::PhantomData,
            }
        }
        /// Inserts a key-value pair into the map. If the key already existed, the old value is returned.
        pub fn insert(&mut self, k: K, v: V) -> Option<V> {
            self.ensure_guard_node();

            let (node, old_val) = match self.map.get(&KeyRef { k: &k }) {
                Some(node) => {
                    let old_val = unsafe { ptr::replace(&mut (**node).value, v) };
                    (*node, Some(old_val))
                }
                None => {
                    let node = if self.free.is_null() {
                        Box::into_raw(Box::new(Node::new(k, v)))
                    } else {
                        // use a recycled box
                        unsafe {
                            let free = self.free;
                            self.free = (*free).next;
                            ptr::write(free, Node::new(k, v));
                            free
                        }
                    };
                    (node, None)
                }
            };
            match old_val {
                Some(_) => {
                    // Existing node, just update LRU position
                    self.detach(node);
                    self.attach(node);
                }
                None => {
                    let keyref = unsafe { &(*node).key };
                    self.map.insert(KeyRef { k: keyref }, node);
                    self.attach(node);
                }
            }
            old_val
        }
        /// Checks if the map contains the given key.
        pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            self.map.contains_key(Qey::from_ref(k))
        }
        /// Returns the value corresponding to the key in the map.
        pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            self.map
                .get(Qey::from_ref(k))
                .map(|e| unsafe { &(**e).value })
        }
        /// Returns the mutable reference corresponding to the key in the map.
        pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            self.map
                .get(Qey::from_ref(k))
                .map(|e| unsafe { &mut (**e).value })
        }
        /// Returns the value corresponding to the key in the map.
        pub fn get_refresh<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            let (value, node_ptr_opt) = match self.map.get(Qey::from_ref(k)) {
                None => (None, None),
                Some(node) => (Some(unsafe { &mut (**node).value }), Some(*node)),
            };
            if let Some(node_ptr) = node_ptr_opt {
                self.detach(node_ptr);
                self.attach(node_ptr);
            }
            value
        }
        /// Removes and returns the value corresponding to the key from the map.
        pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
        where
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            let removed = self.map.remove(Qey::from_ref(k));
            removed.map(|node| {
                self.detach(node);
                unsafe {
                    // add to free list
                    (*node).next = self.free;
                    self.free = node;
                    // drop the key and return the value
                    drop(ptr::read(&(*node).key));
                    ptr::read(&(*node).value)
                }
            })
        }
        /// Returns the maximum number of key-value pairs the map can hold without reallocating.
        pub fn capacity(&self) -> usize {
            self.map.capacity()
        }
        /// Removes the first entry.
        #[inline]
        pub fn pop_front(&mut self) -> Option<(K, V)> {
            if self.is_empty() {
                return None;
            }
            let lru = unsafe { (*self.head).prev };
            self.detach(lru);
            self.map
                .remove(&KeyRef {
                    k: unsafe { &(*lru).key },
                })
                .map(|e| {
                    let e = *unsafe { Box::from_raw(e) };
                    (e.key, e.value)
                })
        }
        /// Gets the first entry.
        #[inline]
        pub fn front(&self) -> Option<(&K, &V)> {
            if self.is_empty() {
                return None;
            }
            let lru = unsafe { (*self.head).prev };
            self.map
                .get(&KeyRef {
                    k: unsafe { &(*lru).key },
                })
                .map(|e| unsafe { (&(**e).key, &(**e).value) })
        }
        /// Removes the last entry.
        #[inline]
        pub fn pop_back(&mut self) -> Option<(K, V)> {
            if self.is_empty() {
                return None;
            }
            let mru = unsafe { (*self.head).next };
            self.detach(mru);
            self.map
                .remove(&KeyRef {
                    k: unsafe { &(*mru).key },
                })
                .map(|e| {
                    let e = *unsafe { Box::from_raw(e) };
                    (e.key, e.value)
                })
        }
        /// Gets the last entry.
        #[inline]
        pub fn back(&self) -> Option<(&K, &V)> {
            if self.is_empty() {
                return None;
            }
            let mru = unsafe { (*self.head).next };
            self.map
                .get(&KeyRef {
                    k: unsafe { &(*mru).key },
                })
                .map(|e| unsafe { (&(**e).key, &(**e).value) })
        }
        /// Returns the number of key-value pairs in the map.
        pub fn len(&self) -> usize {
            self.map.len()
        }
        /// Returns whether the map is currently empty.
        pub fn is_empty(&self) -> bool {
            self.len() == 0
        }
        /// Returns a reference to the map's hasher.
        pub fn hasher(&self) -> &S {
            self.map.hasher()
        }
        /// Clears the map of all key-value pairs.
        pub fn clear(&mut self) {
            self.map.clear();
            // update the guard node if present
            if !self.head.is_null() {
                unsafe {
                    self.drop_entries();
                    (*self.head).prev = self.head;
                    (*self.head).next = self.head;
                }
            }
        }
        /// Returns a double-ended iterator visiting all key-value pairs in order of insertion.
        pub fn iter(&self) -> Iter<K, V> {
            let head = if self.head.is_null() {
                ptr::null_mut()
            } else {
                unsafe { (*self.head).prev }
            };
            Iter {
                head,
                tail: self.head,
                remaining: self.len(),
                marker: marker::PhantomData,
            }
        }
        /// Returns a double-ended iterator visiting all key-value pairs in order of insertion.
        pub fn iter_mut(&mut self) -> IterMut<K, V> {
            let head = if self.head.is_null() {
                ptr::null_mut()
            } else {
                unsafe { (*self.head).prev }
            };
            IterMut {
                head,
                tail: self.head,
                remaining: self.len(),
                marker: marker::PhantomData,
            }
        }
        /// Clears the map, returning all key-value pairs as an iterator.
        pub fn drain(&mut self) -> Drain<K, V> {
            let len = self.len();
            // Map should be empty now, regardless of current state
            self.map.clear();
            let (head, tail) = if len != 0 {
                // This is basically the same as IntoIter's impl, but we don't
                // deallocate/drop anything. Instead we make the sentinel head node
                // point at itself (same state you get from removing the last element from a map),
                // and then append the entire list to the free list. At this point all the entries
                // have essentially been fed into mem::forget. The Drain iterator will then iterate
                // over those nodes in the freelist (using  `len` to know where to stop) and `read`
                // the values out of the nodes, "unforgetting" them.
                //
                // This design results in no observable consequences for mem::forgetting the
                // drain iterator, because the drain iterator has no responsibility to "fix up"
                // things during iteration/destruction. That said, you will effectively mem::forget
                // any elements that weren't yielded yet.
                unsafe {
                    debug_assert!(!self.head.is_null());
                    debug_assert!(!(*self.head).prev.is_null());
                    debug_assert!((*self.head).prev != self.head);
                    let head = (*self.head).prev;
                    let tail = (*self.head).next;
                    (*self.head).prev = self.head;
                    (*self.head).next = self.head;
                    (*head).next = self.free;
                    (*tail).prev = ptr::null_mut();
                    self.free = tail;
                    (head, tail)
                }
            } else {
                (ptr::null_mut(), ptr::null_mut())
            };

            Drain {
                head,
                tail,
                remaining: len,
                marker: marker::PhantomData,
            }
        }
        /// Returns a double-ended iterator visiting all key in order of insertion.
        pub fn keys(&self) -> Keys<K, V> {
            Keys { inner: self.iter() }
        }
        /// Returns a double-ended iterator visiting all values in order of insertion.
        pub fn values(&self) -> Values<K, V> {
            Values { inner: self.iter() }
        }
    }

    impl<'a, K, V, S, Q: ?Sized> Index<&'a Q> for LinkedHashMap<K, V, S> where
        K: Hash + Eq + Borrow<Q>,
        S: BuildHasher,
        Q: Eq + Hash,
    {
        type Output = V;

        fn index(&self, index: &'a Q) -> &V {
            self.get(index).expect("no entry found for key")
        }
    }

    impl<'a, K, V, S, Q: ?Sized> IndexMut<&'a Q> for LinkedHashMap<K, V, S> where
        K: Hash + Eq + Borrow<Q>,
        S: BuildHasher,
        Q: Eq + Hash,
    {
        fn index_mut(&mut self, index: &'a Q) -> &mut V {
            self.get_mut(index).expect("no entry found for key")
        }
    }

    impl<K: Hash + Eq + Clone, V: Clone, S: BuildHasher + Clone> Clone for LinkedHashMap<K, V, S> {
        fn clone(&self) -> Self {
            let mut map = Self::with_hasher(self.map.hasher().clone());
            map.extend(self.iter().map(|(k, v)| (k.clone(), v.clone())));
            map
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher + Default> Default for LinkedHashMap<K, V, S> {
        fn default() -> Self {
            Self::with_hasher(S::default())
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher> Extend<(K, V)> for LinkedHashMap<K, V, S> {
        fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, iter: I) {
            for (k, v) in iter {
                self.insert(k, v);
            }
        }
    }

    impl<'a, K, V, S> Extend<(&'a K, &'a V)> for LinkedHashMap<K, V, S> where
        K: 'a + Hash + Eq + Copy,
        V: 'a + Copy,
        S: BuildHasher,
    {
        fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {
            for (&k, &v) in iter {
                self.insert(k, v);
            }
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher + Default> iter::FromIterator<(K, V)>
        for LinkedHashMap<K, V, S>
    {
        fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {
            let iter = iter.into_iter();
            let mut map = Self::with_capacity_and_hasher(iter.size_hint().0, S::default());
            map.extend(iter);
            map
        }
    }

    impl<A: fmt::Debug + Hash + Eq, B: fmt::Debug, S: BuildHasher> fmt::Debug
        for LinkedHashMap<A, B, S>
    {
        /// Returns a string that lists the key-value pairs in insertion order.
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_map().entries(self).finish()
        }
    }

    impl<K: Hash + Eq, V: PartialEq, S: BuildHasher> PartialEq for LinkedHashMap<K, V, S> {
        fn eq(&self, other: &Self) -> bool {
            self.len() == other.len() && self.iter().eq(other)
        }
    }

    impl<K: Hash + Eq, V: Eq, S: BuildHasher> Eq for LinkedHashMap<K, V, S> {}

    impl<K: Hash + Eq + PartialOrd, V: PartialOrd, S: BuildHasher> PartialOrd
        for LinkedHashMap<K, V, S>
    {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            self.iter().partial_cmp(other)
        }

        fn lt(&self, other: &Self) -> bool {
            self.iter().lt(other)
        }

        fn le(&self, other: &Self) -> bool {
            self.iter().le(other)
        }

        fn ge(&self, other: &Self) -> bool {
            self.iter().ge(other)
        }

        fn gt(&self, other: &Self) -> bool {
            self.iter().gt(other)
        }
    }

    impl<K: Hash + Eq + Ord, V: Ord, S: BuildHasher> Ord for LinkedHashMap<K, V, S> {
        fn cmp(&self, other: &Self) -> Ordering {
            self.iter().cmp(other)
        }
    }

    impl<K: Hash + Eq, V: Hash, S: BuildHasher> Hash for LinkedHashMap<K, V, S> {
        fn hash<H: Hasher>(&self, h: &mut H) {
            for e in self.iter() {
                e.hash(h);
            }
        }
    }

    unsafe impl<K: Send, V: Send, S: Send> Send for LinkedHashMap<K, V, S> {}

    unsafe impl<K: Sync, V: Sync, S: Sync> Sync for LinkedHashMap<K, V, S> {}

    impl<K, V, S> Drop for LinkedHashMap<K, V, S> {
        fn drop(&mut self) {
            if !self.head.is_null() {
                unsafe {
                    self.drop_entries();
                    drop_empty_node(self.head);
                }
            }
            self.clear_free_list();
        }
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s entries, with immutable references to the
    /// values.
    pub struct Iter<'a, K: 'a, V: 'a> {
        head: *const Node<K, V>,
        tail: *const Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(&'a K, &'a V)>,
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s entries, with mutable references to the
    /// values.
    pub struct IterMut<'a, K: 'a, V: 'a> {
        head: *mut Node<K, V>,
        tail: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(&'a K, &'a mut V)>,
    }
    /// A consuming insertion-order iterator over a `LinkedHashMap`'s entries.
    pub struct IntoIter<K, V> {
        head: *mut Node<K, V>,
        tail: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(K, V)>,
    }
    /// A draining insertion-order iterator over a `LinkedHashMap`'s entries.
    pub struct Drain<'a, K, V> {
        head: *mut Node<K, V>,
        tail: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<&'a mut (K, V)>,
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s entries represented as
    /// an `OccupiedEntry`.
    pub struct Entries<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> {
        map: *mut LinkedHashMap<K, V, S>,
        head: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(&'a K, &'a mut V, &'a S)>,
    }

    unsafe impl<'a, K, V> Send for Iter<'a, K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<'a, K, V> Send for IterMut<'a, K, V> where
    K: Send,
    V: Send,
    {
    }

    unsafe impl<'a, K, V> Send for Drain<'a, K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<K, V> Send for IntoIter<K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<'a, K, V, S> Send for Entries<'a, K, V, S> where
        K: Send,
        V: Send,
        S: Send,
    {
    }

    unsafe impl<'a, K, V> Sync for Iter<'a, K, V> where
        K: Sync,
        V: Sync,
    {
    }

    unsafe impl<'a, K, V> Sync for IterMut<'a, K, V> where
        K: Sync,
        V: Sync,
    {
    }

    unsafe impl<'a, K, V> Sync for Drain<'a, K, V> where
        K: Sync,
        V: Sync,
    {
    }
    unsafe impl<K, V> Sync for IntoIter<K, V> where
        K: Sync,
        V: Sync,
    {
    }

    unsafe impl<'a, K, V, S> Sync for Entries<'a, K, V, S> where
        K: Sync,
        V: Sync,
        S: Sync,
    {
    }

    impl<'a, K, V> Clone for Iter<'a, K, V> 
    {
        fn clone(&self) -> Self {
            Iter { ..*self }
        }
    }

    impl<K, V> Clone for IntoIter<K, V> where
        K: Clone,
        V: Clone,
    {
        fn clone(&self) -> Self {
            if self.remaining == 0 {
                return IntoIter { ..*self };
            }

            fn clone_node<K, V>(e: *mut Node<K, V>) -> *mut Node<K, V>
            where
                K: Clone,
                V: Clone,
            {
                Box::into_raw(Box::new(Node::new(unsafe { (*e).key.clone() }, unsafe {
                    (*e).value.clone()
                })))
            }

            let mut cur = self.head;
            let head = clone_node(cur);
            let mut tail = head;
            for _ in 1..self.remaining {
                unsafe {
                    (*tail).prev = clone_node((*cur).prev);
                    (*(*tail).prev).next = tail;
                    tail = (*tail).prev;
                    cur = (*cur).prev;
                }
            }

            IntoIter {
                head,
                tail,
                remaining: self.remaining,
                marker: marker::PhantomData,
            }
        }
    }

    impl<'a, K, V> Iterator for Iter<'a, K, V> 
    {
        type Item = (&'a K, &'a V);

        fn next(&mut self) -> Option<(&'a K, &'a V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    let r = Some((&(*self.head).key, &(*self.head).value));
                    self.head = (*self.head).prev;
                    r
                }
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> Iterator for IterMut<'a, K, V> 
    {
        type Item = (&'a K, &'a mut V);

        fn next(&mut self) -> Option<(&'a K, &'a mut V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    let r = Some((&(*self.head).key, &mut (*self.head).value));
                    self.head = (*self.head).prev;
                    r
                }
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<K, V> Iterator for IntoIter<K, V> 
    {
        type Item = (K, V);

        fn next(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let prev = (*self.head).prev;
                let e = *Box::from_raw(self.head);
                self.head = prev;
                Some((e.key, e.value))
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> Iterator for Drain<'a, K, V> 
    {
        type Item = (K, V);

        fn next(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let prev = (*self.head).prev;
                // Read the values out, the node is in the free-list already so these will
                // be treated as uninit memory.
                let k = addr_of_mut!((*self.head).key).read();
                let v = addr_of_mut!((*self.head).value).read();
                self.head = prev;
                Some((k, v))
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Drain<'a, K, V> 
    {
        fn next_back(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let next = (*self.tail).next;
                // Read the values out, the node is in the free-list already so these will
                // be treated as uninit memory.
                let k = addr_of_mut!((*self.tail).key).read();
                let v = addr_of_mut!((*self.tail).value).read();
                self.tail = next;
                Some((k, v))
            }
        }
    }

    impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<'a, K, V, S: BuildHasher> Iterator for Entries<'a, K, V, S> 
    {
        type Item = OccupiedEntry<'a, K, V, S>;

        fn next(&mut self) -> Option<OccupiedEntry<'a, K, V, S>> {
            if self.remaining == 0 {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    let r = Some(OccupiedEntry {
                        map: self.map,
                        entry: self.head,
                        marker: marker::PhantomData,
                    });

                    self.head = (*self.head).prev;
                    r
                }
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> 
    {
        fn next_back(&mut self) -> Option<(&'a K, &'a V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    self.tail = (*self.tail).next;
                    Some((&(*self.tail).key, &(*self.tail).value))
                }
            }
        }
    }

    impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> 
    {
        fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    self.tail = (*self.tail).next;
                    Some((&(*self.tail).key, &mut (*self.tail).value))
                }
            }
        }
    }

    impl<K, V> DoubleEndedIterator for IntoIter<K, V> 
    {
        fn next_back(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let next = (*self.tail).next;
                let e = *Box::from_raw(self.tail);
                self.tail = next;
                Some((e.key, e.value))
            }
        }
    }

    impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<K, V> ExactSizeIterator for IntoIter<K, V> 
    {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<K, V> Drop for IntoIter<K, V> 
    {
        fn drop(&mut self) {
            for _ in 0..self.remaining {
                unsafe {
                    let next = (*self.tail).next;
                    Box::from_raw(self.tail);
                    self.tail = next;
                }
            }
        }
    }

    impl<'a, K, V> Drop for Drain<'a, K, V> 
    {
        fn drop(&mut self) {
            for _ in self {}
        }
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s keys.
    pub struct Keys<'a, K: 'a, V: 'a> 
    {
        inner: Iter<'a, K, V>,
    }

    impl<'a, K, V> Clone for Keys<'a, K, V> 
    {
        fn clone(&self) -> Self {
            Keys {
                inner: self.inner.clone(),
            }
        }
    }

    impl<'a, K, V> Iterator for Keys<'a, K, V> 
    {
        type Item = &'a K;

        #[inline]
        fn next(&mut self) -> Option<&'a K> {
            self.inner.next().map(|e| e.0)
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> 
    {
        #[inline]
        fn next_back(&mut self) -> Option<&'a K> {
            self.inner.next_back().map(|e| e.0)
        }
    }

    impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.inner.len()
        }
    }
    /// An insertion-order iterator over a `LinkedHashMap`'s values.
    pub struct Values<'a, K: 'a, V: 'a> 
    {
        inner: Iter<'a, K, V>,
    }

    impl<'a, K, V> Clone for Values<'a, K, V> 
    {
        fn clone(&self) -> Self {
            Values {
                inner: self.inner.clone(),
            }
        }
    }

    impl<'a, K, V> Iterator for Values<'a, K, V> 
    {
        type Item = &'a V;

        #[inline]
        fn next(&mut self) -> Option<&'a V> {
            self.inner.next().map(|e| e.1)
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> 
    {
        #[inline]
        fn next_back(&mut self) -> Option<&'a V> {
            self.inner.next_back().map(|e| e.1)
        }
    }

    impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> 
    {
        fn len(&self) -> usize {
            self.inner.len()
        }
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> IntoIterator for &'a LinkedHashMap<K, V, S> 
    {
        type Item = (&'a K, &'a V);
        type IntoIter = Iter<'a, K, V>;
        fn into_iter(self) -> Iter<'a, K, V> {
            self.iter()
        }
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> IntoIterator for &'a mut LinkedHashMap<K, V, S> 
    {
        type Item = (&'a K, &'a mut V);
        type IntoIter = IterMut<'a, K, V>;
        fn into_iter(self) -> IterMut<'a, K, V> {
            self.iter_mut()
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher> IntoIterator for LinkedHashMap<K, V, S> 
    {
        type Item = (K, V);
        type IntoIter = IntoIter<K, V>;
        fn into_iter(mut self) -> IntoIter<K, V> {
            let (head, tail) = if !self.head.is_null() {
                unsafe { ((*self.head).prev, (*self.head).next) }
            } else {
                (ptr::null_mut(), ptr::null_mut())
            };
            let len = self.len();

            if !self.head.is_null() {
                unsafe { drop_empty_node(self.head) }
            }
            self.clear_free_list();
            // drop the HashMap but not the LinkedHashMap
            unsafe {
                ptr::drop_in_place(&mut self.map);
            }
            mem::forget(self);

            IntoIter {
                head,
                tail,
                remaining: len,
                marker: marker::PhantomData,
            }
        }
    }
    /// A view into a single location in a map, which may be vacant or occupied.
    pub enum Entry<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> 
    {
        /// An occupied Entry.
        Occupied(OccupiedEntry<'a, K, V, S>),
        /// A vacant Entry.
        Vacant(VacantEntry<'a, K, V, S>),
    }
    /// A view into a single occupied location in a `LinkedHashMap`.
    pub struct OccupiedEntry<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> 
    {
        entry: *mut Node<K, V>,
        map: *mut LinkedHashMap<K, V, S>,
        marker: marker::PhantomData<&'a K>,
    }
    /// A view into a single empty location in a `LinkedHashMap`.
    pub struct VacantEntry<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> 
    {
        key: K,
        map: &'a mut LinkedHashMap<K, V, S>,
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> Entry<'a, K, V, S> 
    {
        /// Returns the entry key.
        pub fn key(&self) -> &K {
            match *self {
                Entry::Occupied(ref e) => e.key(),
                Entry::Vacant(ref e) => e.key(),
            }
        }
        /// Ensures a value is in the entry by inserting the default if empty, and returns a mutable reference to the value in the entry.
        pub fn or_insert(self, default: V) -> &'a mut V {
            match self {
                Entry::Occupied(entry) => entry.into_mut(),
                Entry::Vacant(entry) => entry.insert(default),
            }
        }
        /// Ensures a value is in the entry by inserting the result of the default function if empty,
        /// and returns a mutable reference to the value in the entry.
        pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
            match self {
                Entry::Occupied(entry) => entry.into_mut(),
                Entry::Vacant(entry) => entry.insert(default()),
            }
        }
        /// Provides in-place mutable access to an occupied entry before any potential inserts into the map.
        pub fn and_modify<F>(self, f: F) -> Self
        where
            F: FnOnce(&mut V),
        {
            match self {
                Entry::Occupied(mut entry) => {
                    f(entry.get_mut());
                    Entry::Occupied(entry)
                }
                Entry::Vacant(entry) => Entry::Vacant(entry),
            }
        }
        /// Ensures a value is in the entry by inserting the default value if empty, and returns a mutable reference to the value in the entry.
        pub fn or_default(self) -> &'a mut V
        where
            V: Default,
        {
            match self {
                Entry::Occupied(entry) => entry.into_mut(),
                Entry::Vacant(entry) => entry.insert(V::default()),
            }
        }
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> OccupiedEntry<'a, K, V, S> 
    {
        /// Gets a reference to the entry key.
        pub fn key(&self) -> &K {
            unsafe { &(*self.entry).key }
        }
        /// Gets a reference to the value in the entry.
        pub fn get(&self) -> &V {
            unsafe { &(*self.entry).value }
        }
        /// Gets a mutable reference to the value in the entry.
        pub fn get_mut(&mut self) -> &mut V {
            unsafe { &mut (*self.entry).value }
        }
        /// Converts the OccupiedEntry into a mutable reference to the value in the entry
        /// with a lifetime bound to the map itself
        pub fn into_mut(self) -> &'a mut V {
            unsafe { &mut (*self.entry).value }
        }
        /// Sets the value of the entry, and returns the entry's old value
        pub fn insert(&mut self, value: V) -> V {
            unsafe {
                (*self.map).ensure_guard_node();

                let old_val = mem::replace(&mut (*self.entry).value, value);
                let node_ptr: *mut Node<K, V> = self.entry;

                // Existing node, just update LRU position
                (*self.map).detach(node_ptr);
                (*self.map).attach(node_ptr);

                old_val
            }
        }
        /// Takes the value out of the entry, and returns it
        pub fn remove(self) -> V {
            unsafe { (*self.map).remove(&(*self.entry).key) }.unwrap()
        }
    }

    impl<'a, K: 'a + Hash + Eq, V: 'a, S: BuildHasher> VacantEntry<'a, K, V, S> 
    {
        /// Gets a reference to the entry key.
        pub fn key(&self) -> &K {
            &self.key
        }
        /// Sets the value of the entry with the VacantEntry's key, and returns a mutable reference to it
        pub fn insert(self, value: V) -> &'a mut V {
            self.map.ensure_guard_node();

            let node = if self.map.free.is_null() {
                Box::into_raw(Box::new(Node::new(self.key, value)))
            } else {
                // use a recycled box
                unsafe {
                    let free = self.map.free;
                    self.map.free = (*free).next;
                    ptr::write(free, Node::new(self.key, value));
                    free
                }
            };

            let keyref = unsafe { &(*node).key };

            self.map.attach(node);

            let ret = self.map.map.entry(KeyRef { k: keyref }).or_insert(node);
            unsafe { &mut (**ret).value }
        }
    }
}

#[macro_use] pub mod tools
{
    use ::
    {
        *,
    };
    
    pub fn is_signal_handler_enabled() -> bool
    {
        env::var("CICADA_ENABLE_SIG_HANDLER").map_or(false, |x| x == "1")
    }

    pub fn get_user_name() -> String
    {
        match env::var("USER")
        {
            Ok(x) => { return x; }
            Err(e) => { log!("cicada: env USER error: {}", e); }
        }

        let cmd_result = execute::run("whoami");
        return cmd_result.stdout.trim().to_string();
    }

    pub fn get_user_home() -> String
    {
        match env::var("HOME")
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: env HOME error: {}", e);
                String::new()
            }
        }
    }

    pub fn get_config_dir() -> String
    {
        if let Ok(x) = env::var("XDG_CONFIG_HOME")
        {
            format!("{}/cicada", x)
        }
        else
        {
            let home = get_user_home();
            format!("{}/.config/cicada", home)
        }
    }

    pub fn get_user_completer_dir() -> String
    {
        let dir_config = get_config_dir();
        format!("{}/completers", dir_config)
    }

    pub fn unquote(s: &str) -> String
    {
        let args = parsers::parser_line::line_to_plain_tokens(s);
        if args.is_empty() { return String::new(); }

        args[0].clone()
    }

    pub fn is_env(line: &str) -> bool
    {
        re_contains(line, r"^[a-zA-Z_][a-zA-Z0-9_]*=.*$")
    }
    
    pub fn extend_bangbang(sh: &shell::Shell, line: &mut String)
    {
        if !re_contains(line, r"!!") { return; }
        if sh.previous_cmd.is_empty() { return; }

        let re = Regex::new(r"!!").unwrap();
        let mut replaced = false;
        let mut new_line = String::new();
        let linfo = parsers::parser_line::parse_line(line);
        for (sep, token) in linfo.tokens
        {
            if !sep.is_empty() { new_line.push_str(&sep); }

            if re_contains(&token, r"!!") && sep != "'"
            {
                let line2 = token.clone();
                let result = re.replace_all(&line2, sh.previous_cmd.as_str());
                new_line.push_str(&result);
                replaced = true;
            }
            else {
                new_line.push_str(&token);
            }

            if !sep.is_empty() {
                new_line.push_str(&sep);
            }
            new_line.push(' ');
        }

        *line = new_line.trim_end().to_string();
        // print full line after extending
        if replaced {
            println!("{}", line);
        }
    }

    pub fn wrap_sep_string(sep: &str, s: &str) -> String {
        let mut _token = String::new();
        let mut met_subsep = false;
        // let set previous_subsep to any char except '`' or '"'
        let mut previous_subsep = 'N';
        for c in s.chars() {
            // handle cmds like: export DIR=`brew --prefix openssl`/include
            // or like: export foo="hello world"
            if sep.is_empty() && (c == '`' || c == '"') {
                if !met_subsep {
                    met_subsep = true;
                    previous_subsep = c;
                } else if c == previous_subsep {
                    met_subsep = false;
                    previous_subsep = 'N';
                }
            }
            if c.to_string() == sep {
                _token.push('\\');
            }
            if c == ' ' && sep.is_empty() && !met_subsep {
                _token.push('\\');
            }
            _token.push(c);
        }
        format!("{}{}{}", sep, _token, sep)
    }

    pub fn env_args_to_command_line() -> String {
        let mut result = String::new();
        let env_args = env::args();
        if env_args.len() <= 1 {
            return result;
        }
        for (i, arg) in env_args.enumerate() {
            if i == 0 || arg == "-c" {
                continue;
            }
            result.push_str(arg.as_str());
        }
        result
    }

    extern "C" {
        fn gethostname(name: *mut libc::c_char, size: libc::size_t) -> libc::c_int;
    }

    /// via: https://gist.github.com/conradkleinespel/6c8174aee28fa22bfe26
    pub fn get_hostname() -> String {
        let len = 255;
        let mut buf = Vec::<u8>::with_capacity(len);

        let ptr = buf.as_mut_slice().as_mut_ptr();

        let err = unsafe { gethostname(ptr as *mut libc::c_char, len as libc::size_t) } as i32;

        match err {
            0 => {
                let real_len;
                let mut i = 0;
                loop {
                    let byte = unsafe { *(((ptr as u64) + (i as u64)) as *const u8) };
                    if byte == 0 {
                        real_len = i;
                        break;
                    }

                    i += 1;
                }
                unsafe { buf.set_len(real_len) }
                String::from_utf8_lossy(buf.as_slice()).into_owned()
            }
            _ => String::from("unknown"),
        }
    }

    pub fn is_arithmetic(line: &str) -> bool {
        if !re_contains(line, r"[0-9]+") {
            return false;
        }
        if !re_contains(line, r"\+|\-|\*|/|\^") {
            return false;
        }
        re_contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$")
    }

    pub fn create_raw_fd_from_file(file_name: &str, append: bool) -> Result<i32, String> {
        let mut oos = OpenOptions::new();
        if append {
            oos.append(true);
        } else {
            oos.write(true);
            oos.truncate(true);
        }
        match oos.create(true).open(file_name) {
            Ok(x) => {
                let fd = x.into_raw_fd();
                Ok(fd)
            }
            Err(e) => Err(format!("{}", e)),
        }
    }

    pub fn get_fd_from_file(file_name: &str) -> i32 {
        let path = Path::new(file_name);
        let display = path.display();
        let file = match File::open(path) {
            Err(why) => {
                println_stderr!("cicada: {}: {}", display, why);
                return -1;
            }
            Ok(file) => file,
        };
        file.into_raw_fd()
    }

    pub fn escape_path(path: &str) -> String {
        let re = Regex::new(r##"(?P<c>[!\(\)<>,\?\]\[\{\} \\'"`*\^#|$&;])"##).unwrap();
        return re.replace_all(path, "\\$c").to_string();
    }

    pub fn get_current_dir() -> String {
        let mut current_dir = PathBuf::new();
        match env::current_dir() {
            Ok(x) => current_dir = x,
            Err(e) => {
                println_stderr!("env current_dir() failed: {}", e);
            }
        }
        let mut str_current_dir = "";
        match current_dir.to_str() {
            Some(x) => str_current_dir = x,
            None => {
                println_stderr!("current_dir to str failed.");
            }
        }
        str_current_dir.to_string()
    }

    pub fn split_into_fields(
        sh: &shell::Shell,
        line: &str,
        envs: &HashMap<String, String>,
    ) -> Vec<String> {
        let ifs_chars;
        if envs.contains_key("IFS") {
            ifs_chars = envs[&"IFS".to_string()].chars().collect();
        } else if let Some(x) = sh.get_env("IFS") {
            ifs_chars = x.chars().collect();
        } else if let Ok(x) = env::var("IFS") {
            ifs_chars = x.chars().collect();
        } else {
            ifs_chars = vec![];
        }

        if ifs_chars.is_empty() {
            return line
                .split(&[' ', '\t', '\n'][..])
                .map(|x| x.to_string())
                .collect();
        } else {
            return line.split(&ifs_chars[..]).map(|x| x.to_string()).collect();
        }
    }

    pub fn is_builtin(s: &str) -> bool {
        let builtins = [
            "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg",
            "history", "jobs", "read", "source", "ulimit", "unalias", "vox",
            "minfd", "set", "unset", "unpath",
        ];
        builtins.contains(&s)
    }

    pub fn init_path_env() {
        // order matters. took from `runc spec`
        let mut paths: Vec<String> = vec![];
        for x in [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ] {
            if Path::new(x).exists() {
                paths.push(x.to_string());
            }
        }

        if let Ok(env_path) = env::var("PATH") {
            for x in env_path.split(":") {
                if !paths.contains(&x.to_string()) {
                    paths.push(x.to_string());
                }
            }
        }
        let paths = paths.join(":");
        env::set_var("PATH", paths);
    }

    pub fn is_shell_altering_command(line: &str) -> bool {
        let line = line.trim();
        if re_contains(line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$") {
            return true;
        }
        line.starts_with("alias ")
            || line.starts_with("export ")
            || line.starts_with("unalias ")
            || line.starts_with("unset ")
            || line.starts_with("source ")
    }
}

pub mod builtins
{
    use ::
    {
        *,
    };

    pub mod alias
    {
        use ::
        {
            *,
        };
        use regex::Regex;

        use crate::shell;
        use crate::tools;
        use crate::types::{Command, CommandLine, CommandResult};
        use crate::builtins::utils::print_stderr_with_capture;
        use crate::builtins::utils::print_stdout_with_capture;

        pub fn run(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();

            if tokens.len() == 1 {
                return show_alias_list(sh, cmd, cl, capture);
            }

            if tokens.len() > 2 {
                let info = "alias syntax error: usage: alias foo='echo foo'";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let input = &tokens[1].1;
            let re_single_read = Regex::new(r"^[a-zA-Z0-9_\.-]+$").unwrap();
            if re_single_read.is_match(input) {
                return show_single_alias(sh, input, cmd, cl, capture);
            }

            let re_to_add = Regex::new(r"^([a-zA-Z0-9_\.-]+)=(.*)$").unwrap();
            for cap in re_to_add.captures_iter(input) {
                let name = tools::unquote(&cap[1]);
                // due to limitation of `parses::parser_line`,
                // `alias foo-bar='foo bar'` will become 'foo-bar=foo bar'
                // while `alias foo_bar='foo bar'` keeps foo_bar='foo bar'
                let value = if cap[2].starts_with('"') || cap[2].starts_with('\'') {
                    tools::unquote(&cap[2])
                } else {
                    cap[2].to_string()
                };
                sh.add_alias(name.as_str(), value.as_str());
            }

            CommandResult::new()
        }

        fn show_alias_list(sh: &shell::Shell, cmd: &Command,
                        cl: &CommandLine, capture: bool) -> CommandResult {
            let mut lines = Vec::new();
            for (name, value) in sh.get_alias_list() {
                let line = format!("alias {}='{}'", name, value);
                lines.push(line);
            }
            let buffer = lines.join("\n");
            let mut cr = CommandResult::new();
            print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
            cr
        }

        fn show_single_alias(sh: &shell::Shell, name_to_find: &str, cmd: &Command,
                            cl: &CommandLine, capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            if let Some(content) = sh.get_alias_content(name_to_find) {
                let info = format!("alias {}='{}'", name_to_find, content);
                print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
            } else {
                let info = format!("cicada: alias: {}: not found", name_to_find);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            }
            cr
        }
    }

    pub mod bg
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::jobc;
        use crate::libc;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if sh.jobs.is_empty() {
                let info = "cicada: bg: no job found";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let mut job_id = -1;
            if tokens.len() == 1 {
                if let Some((gid, _)) = sh.jobs.iter().next() {
                    job_id = *gid;
                }
            }

            if tokens.len() >= 2 {
                let mut job_str = tokens[1].1.clone();
                if job_str.starts_with("%") {
                    job_str = job_str.trim_start_matches('%').to_string();
                }

                match job_str.parse::<i32>() {
                    Ok(n) => job_id = n,
                    Err(_) => {
                        let info = "cicada: bg: invalid job id";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }
            if job_id == -1 {
                let info = "cicada: bg: not such job";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let gid: i32;

            {
                let mut result = sh.get_job_by_id(job_id);
                // fall back to find job by using prcess group id
                if result.is_none() {
                    result = sh.get_job_by_gid(job_id);
                }

                match result {
                    Some(job) => {
                        unsafe {
                            libc::killpg(job.gid, libc::SIGCONT);
                            gid = job.gid;
                            if job.status == "Running" {
                                let info = format!("cicada: bg: job {} already in background", job.id);
                                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                                return cr;
                            }
                        }

                        let info_cmd = format!("[{}]  {} &", job.id, job.cmd);
                        print_stderr_with_capture(&info_cmd, &mut cr, cl, cmd, capture);
                        cr.status = 0;
                    }
                    None => {
                        let info = "cicada: bg: not such job";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            jobc::mark_job_as_running(sh, gid, true);
            cr
        }
    }

    pub mod cd
    {
        use ::
        {
            *,
        };
        use std::env;
        use std::path::Path;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::parsers;
        use crate::shell;
        use crate::tools;
        use crate::types::{Command, CommandLine, CommandResult};

        pub fn run(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();
            let args = parsers::parser_line::tokens_to_args(&tokens);

            if args.len() > 2 {
                let info = "cicada: cd: too many argument";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let str_current_dir = tools::get_current_dir();

            let mut dir_to = if args.len() == 1 {
                let home = tools::get_user_home();
                home.to_string()
            } else {
                args[1..].join("")
            };

            if dir_to == "-" {
                if sh.previous_dir.is_empty() {
                    let info = "no previous dir";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
                dir_to = sh.previous_dir.clone();
            } else if !dir_to.starts_with('/') {
                dir_to = format!("{}/{}", str_current_dir, dir_to);
            }

            if !Path::new(&dir_to).exists() {
                let info = format!("cicada: cd: {}: No such file or directory", &args[1]);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }

            match Path::new(&dir_to).canonicalize() {
                Ok(p) => {
                    dir_to = p.as_path().to_string_lossy().to_string();
                }
                Err(e) => {
                    let info = format!("cicada: cd: error: {}", e);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }

            match env::set_current_dir(&dir_to) {
                Ok(_) => {
                    sh.current_dir = dir_to.clone();
                    if str_current_dir != dir_to {
                        sh.previous_dir = str_current_dir.clone();
                        env::set_var("PWD", &sh.current_dir);
                    };
                    cr.status = 0;
                    cr
                }
                Err(e) => {
                    let info = format!("cicada: cd: {}", e);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    cr
                }
            }
        }
    }

    pub mod cinfo
    {
        use ::
        {
            *,
        };
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::history;
        use crate::libs;
        use crate::rcfile;
        use crate::shell::Shell;
        use crate::types::{Command, CommandLine, CommandResult};

        pub fn run(_sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut info = vec![];
            const VERSION: &str = env!("CARGO_PKG_VERSION");
            info.push(("version", VERSION));

            let os_name = libs::os_type::get_os_name();
            info.push(("os-name", &os_name));

            let hfile = history::get_history_file();
            info.push(("history-file", &hfile));

            let rcf = rcfile::get_rc_file();
            info.push(("rc-file", &rcf));

            let git_hash = env!("GIT_HASH");
            if !git_hash.is_empty() {
                info.push(("git-commit", env!("GIT_HASH")));
            }

            let git_branch = env!("GIT_BRANCH");
            let mut branch = String::new();
            if !git_branch.is_empty() {
                branch.push_str(git_branch);
                let git_status = env!("GIT_STATUS");
                if git_status != "0" {
                    branch.push_str(" (dirty)");
                }
                info.push(("git-branch", &branch));
            }

            info.push(("built-with", env!("BUILD_RUSTC_VERSION")));
            info.push(("built-at", env!("BUILD_DATE")));

            let mut lines = Vec::new();
            for (k, v) in &info {
                // longest key above is 12-char length
                lines.push(format!("{: >12}: {}", k, v));
            }
            let buffer = lines.join("\n");
            let mut cr = CommandResult::new();
            print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
            cr
        }
    }

    pub mod exec
    {
        use ::
        {
            *,
        };
        use exec;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::parsers;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(_sh: &Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();
            let args = parsers::parser_line::tokens_to_args(&tokens);
            let len = args.len();
            if len == 1 {
                print_stderr_with_capture("invalid usage", &mut cr, cl, cmd, capture);
                return cr;
            }

            let mut _cmd = exec::Command::new(&args[1]);
            let err = _cmd.args(&args[2..len]).exec();
            let info = format!("cicada: exec: {}", err);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            cr
        }
    }

    pub mod exit
    {
        use ::
        {
            *,
        };
        #![allow(unreachable_code)]
        use std::process;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();
            if tokens.len() > 2 {
                let info = "cicada: exit: too many arguments";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            if tokens.len() == 2 {
                let _code = &tokens[1].1;
                match _code.parse::<i32>() {
                    Ok(x) => {
                        process::exit(x);
                    }
                    Err(_) => {
                        let info = format!("cicada: exit: {}: numeric argument required", _code);
                        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                        process::exit(255);
                    }
                }
            }

            for (_i, job) in sh.jobs.iter() {
                if !job.cmd.starts_with("nohup ") {
                    let mut info = String::new();
                    info.push_str("There are background jobs.");
                    info.push_str("Run `jobs` to see details; `exit 1` to force quit.");
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }

            process::exit(0);
            cr
        }
    }

    pub mod export
    {
        use ::
        {
            *,
        };
        use regex::Regex;
        use std::env;

        use crate::libs;
        use crate::parsers;
        use crate::tools;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(_sh: &Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();

            let re_name_ptn = Regex::new(r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$").unwrap();
            for (_, text) in tokens.iter() {
                if text == "export" {
                    continue;
                }

                if !tools::is_env(text) {
                    let mut info = String::new();
                    info.push_str("export: invalid command\n");
                    info.push_str("usage: export XXX=YYY");
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }

                if !re_name_ptn.is_match(text) {
                    let mut info = String::new();
                    info.push_str("export: invalid command\n");
                    info.push_str("usage: export XXX=YYY ZZ=123");
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }

                for cap in re_name_ptn.captures_iter(text) {
                    let name = cap[1].to_string();
                    let token = parsers::parser_line::unquote(&cap[2]);
                    let value = libs::path::expand_home(&token);
                    env::set_var(name, &value);
                }
            }
            cr
        }
    }

    pub mod fg
    {
        use ::
        {
            *,
        };
        use libc;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::jobc;
        use crate::shell::{self, Shell};
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if sh.jobs.is_empty() {
                let info = "cicada: fg: no job found";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let mut job_id = -1;
            if tokens.len() == 1 {
                if let Some((gid, _)) = sh.jobs.iter().next() {
                    job_id = *gid;
                }
            }

            if tokens.len() >= 2 {
                let mut job_str = tokens[1].1.clone();
                if job_str.starts_with("%") {
                    job_str = job_str.trim_start_matches('%').to_string();
                }

                match job_str.parse::<i32>() {
                    Ok(n) => job_id = n,
                    Err(_) => {
                        let info = "cicada: fg: invalid job id";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            if job_id == -1 {
                let info = "cicada: not job id found";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let gid: i32;
            let pid_list: Vec<i32>;

            {
                let mut result = sh.get_job_by_id(job_id);
                // fall back to find job by using prcess group id
                if result.is_none() {
                    result = sh.get_job_by_gid(job_id);
                }

                match result {
                    Some(job) => {
                        print_stderr_with_capture(&job.cmd, &mut cr, cl, cmd, capture);
                        cr.status = 0;

                        unsafe {
                            if !shell::give_terminal_to(job.gid) {
                                return CommandResult::error();
                            }

                            libc::killpg(job.gid, libc::SIGCONT);
                            pid_list = job.pids.clone();
                            gid = job.gid;
                        }
                    }
                    None => {
                        let info = "cicada: fg: no such job";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            unsafe {
                jobc::mark_job_as_running(sh, gid, false);

                let cr = jobc::wait_fg_job(sh, gid, &pid_list);

                let gid_shell = libc::getpgid(0);
                if !shell::give_terminal_to(gid_shell) {
                    log!("failed to give term to back to shell : {}", gid_shell);
                }

                cr
            }
        }
    }

    pub mod history
    {
        use ::
        {
            *,
        };

        use std::path::Path;

        use rusqlite::Connection as Conn;
        use structopt::StructOpt;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::ctime;
        use crate::history;
        use crate::parsers;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        #[derive(Debug, StructOpt)]
        #[structopt(name = "history", about = "History in cicada shell")]
        struct OptMain {
            #[structopt(short, long, help = "For current session only")]
            session: bool,

            #[structopt(short, long, help = "Search old items first")]
            asc: bool,

            #[structopt(short, long, help = "For current directory only")]
            pwd: bool,

            #[structopt(short, long, help = "Only show ROWID")]
            only_id: bool,

            #[structopt(short, long, help = "Do not show ROWID")]
            no_id: bool,

            #[structopt(short="d", long, help = "Show date")]
            show_date: bool,

            #[structopt(short, long, default_value = "20")]
            limit: i32,

            #[structopt(name = "PATTERN", default_value = "", help = "You can use % to match anything")]
            pattern: String,

            #[structopt(subcommand)]
            cmd: Option<SubCommand>
        }

        #[derive(StructOpt, Debug)]
        enum SubCommand {
            #[structopt(about="Add new item into history")]
            Add {
                #[structopt(short="t", long, help = "Specify a timestamp for the new item")]
                timestamp: Option<f64>,

                #[structopt(name="INPUT", help = "input to be added into history")]
                input: String,
            },
            #[structopt(about="Delete item from history")]
            Delete {
                #[structopt(name="ROWID", help = "Row IDs of item to delete")]
                rowid: Vec<usize>,
            }
        }

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let hfile = history::get_history_file();
            let path = Path::new(hfile.as_str());
            if !path.exists() {
                let info = "no history file";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }
            let conn = match Conn::open(&hfile) {
                Ok(x) => x,
                Err(e) => {
                    let info = format!("history: sqlite error: {:?}", e);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            };

            let tokens = cmd.tokens.clone();
            let args = parsers::parser_line::tokens_to_args(&tokens);

            let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");
            let opt = OptMain::from_iter_safe(args);
            match opt {
                Ok(opt) => {
                    match opt.cmd {
                        Some(SubCommand::Delete {rowid: rowids}) => {
                            let mut _count = 0;
                            for rowid in rowids {
                                let _deleted = delete_history_item(&conn, rowid);
                                if _deleted {
                                    _count += 1;
                                }
                            }
                            if _count > 0 {
                                let info = format!("deleted {} items", _count);
                                print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                            }
                            cr
                        }
                        Some(SubCommand::Add {timestamp: ts, input}) => {
                            let ts = ts.unwrap_or(0 as f64);
                            add_history(sh, ts, &input);
                            cr
                        }
                        None => {
                            let (str_out, str_err) = list_current_history(sh, &conn, &opt);
                            if !str_out.is_empty() {
                                print_stdout_with_capture(&str_out, &mut cr, cl, cmd, capture);
                            }
                            if !str_err.is_empty() {
                                print_stderr_with_capture(&str_err, &mut cr, cl, cmd, capture);
                            }
                            cr
                        }
                    }
                }
                Err(e) => {
                    let info = format!("{}", e);
                    if show_usage {
                        print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                        cr.status = 0;
                    } else {
                        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                        cr.status = 1;
                    }
                    cr
                }
            }
        }

        fn add_history(sh: &Shell, ts: f64, input: &str) {
            let (tsb, tse) = (ts, ts + 1.0);
            history::add_raw(sh, input, 0, tsb, tse);
        }

        fn list_current_history(sh: &Shell, conn: &Conn,
                                opt: &OptMain) -> (String, String) {
            let mut result_stderr = String::new();
            let result_stdout = String::new();

            let history_table = history::get_history_table();
            let mut sql = format!("SELECT ROWID, inp, tsb FROM {} WHERE ROWID > 0",
                                history_table);
            if !opt.pattern.is_empty() {
                sql = format!("{} AND inp LIKE '%{}%'", sql, opt.pattern)
            }
            if opt.session {
                sql = format!("{} AND sessionid = '{}'", sql, sh.session_id)
            }
            if opt.pwd {
                sql = format!("{} AND info like '%dir:{}|%'", sql, sh.current_dir)
            }

            if opt.asc {
                sql = format!("{} ORDER BY tsb", sql);
            } else {
                sql = format!("{} order by tsb desc", sql);
            };
            sql = format!("{} limit {} ", sql, opt.limit);

            let mut stmt = match conn.prepare(&sql) {
                Ok(x) => x,
                Err(e) => {
                    let info = format!("history: prepare select error: {:?}", e);
                    result_stderr.push_str(&info);
                    return (result_stdout, result_stderr);
                }
            };

            let mut rows = match stmt.query([]) {
                Ok(x) => x,
                Err(e) => {
                    let info = format!("history: query error: {:?}", e);
                    result_stderr.push_str(&info);
                    return (result_stdout, result_stderr);
                }
            };

            let mut lines = Vec::new();
            loop {
                match rows.next() {
                    Ok(_rows) => {
                        if let Some(row) = _rows {
                            let row_id: i32 = match row.get(0) {
                                Ok(x) => x,
                                Err(e) => {
                                    let info = format!("history: error: {:?}", e);
                                    result_stderr.push_str(&info);
                                    return (result_stdout, result_stderr);
                                }
                            };
                            let inp: String = match row.get(1) {
                                Ok(x) => x,
                                Err(e) => {
                                    let info = format!("history: error: {:?}", e);
                                    result_stderr.push_str(&info);
                                    return (result_stdout, result_stderr);
                                }
                            };

                            if opt.no_id {
                                lines.push(inp.to_string());
                            } else if opt.only_id {
                                lines.push(row_id.to_string());
                            } else if opt.show_date {
                                let tsb: f64 = match row.get(2) {
                                    Ok(x) => x,
                                    Err(e) => {
                                        let info = format!("history: error: {:?}", e);
                                        result_stderr.push_str(&info);
                                        return (result_stdout, result_stderr);
                                    }
                                };
                                let dt = ctime::DateTime::from_timestamp(tsb);
                                lines.push(format!("{}: {}: {}", row_id, dt, inp));
                            } else {
                                lines.push(format!("{}: {}", row_id, inp));
                            }
                        } else {
                            break;
                        }
                    }
                    Err(e) => {
                        let info = format!("history: rows next error: {:?}", e);
                        result_stderr.push_str(&info);
                        return (result_stdout, result_stderr);
                    }
                }
            }

            if !opt.asc {
                lines.reverse();
            }

            let buffer = lines.join("\n");

            (buffer, result_stderr)
        }

        fn delete_history_item(conn: &Conn, rowid: usize) -> bool {
            let history_table = history::get_history_table();
            let sql = format!("DELETE from {} where rowid = {}", history_table, rowid);
            match conn.execute(&sql, []) {
                Ok(_) => true,
                Err(e) => {
                    log!("history: error when delete: {:?}", e);
                    false
                }
            }
        }
    }

    pub mod jobs
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stdout_with_capture;
        use crate::jobc;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            if sh.jobs.is_empty() {
                return cr;
            }

            // update status of jobs if any
            jobc::try_wait_bg_jobs(sh, false, false);

            let mut lines = Vec::new();
            let jobs = sh.jobs.clone();
            let no_trim = cmd.tokens.len() >= 2 && cmd.tokens[1].1 == "-f";
            for (_i, job) in jobs.iter() {
                let line = jobc::get_job_line(job, !no_trim);
                lines.push(line);
            }
            let buffer = lines.join("\n");

            print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
            cr
        }
    }

    pub mod read
    {
        use ::
        {
            *,
        };

        use std::io;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::libs::re::re_contains;
        use crate::types::{CommandResult, CommandLine, Command};
        use crate::tools;

        fn _find_invalid_identifier(name_list: &Vec<String>) -> Option<String> {
            for id_ in name_list {
                if !re_contains(id_, r"^[a-zA-Z_][a-zA-Z0-9_]*$") {
                    return Some(id_.to_string());
                }
            }
            None
        }

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();

            let name_list: Vec<String>;
            if tokens.len() <= 1 {
                name_list = vec!["REPLY".to_string()];
            } else {
                name_list = tokens[1..].iter().map(|x| x.1.clone()).collect();
                if let Some(id_) = _find_invalid_identifier(&name_list) {
                    let info = format!("cicada: read: `{}': not a valid identifier", id_);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }

            let mut buffer = String::new();

            if cmd.has_here_string() {
                if let Some(redirect_from) = &cmd.redirect_from {
                    buffer.push_str(&redirect_from.1);
                    buffer.push('\n');
                }
            } else {
                match io::stdin().read_line(&mut buffer) {
                    Ok(_) => {}
                    Err(e) => {
                        let info = format!("cicada: read: error in reading stdin: {:?}", e);
                        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            let envs = cl.envs.clone();
            let value_list = tools::split_into_fields(sh, buffer.trim(), &envs);

            let idx_2rd_last = name_list.len() - 1;
            for i in 0..idx_2rd_last {
                let name = name_list.get(i);
                if name.is_none() {
                    let info = "cicada: read: name index error";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
                let name = name.unwrap();

                let value = value_list.get(i).unwrap_or(&String::new()).clone();
                sh.set_env(name, &value);
            }

            let name_last = &name_list[idx_2rd_last];
            let value_left: String = if value_list.len() > idx_2rd_last {
                value_list[idx_2rd_last..].join(" ")
            } else {
                String::new()
            };
            sh.set_env(name_last, &value_left);
            cr
        }
    }

    pub mod source
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::parsers;
        use crate::scripting;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = &cmd.tokens;
            let args = parsers::parser_line::tokens_to_args(tokens);

            if args.len() < 2 {
                let info = "cicada: source: no file specified";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let status = scripting::run_script(sh, &args);
            cr.status = status;
            cr
        }
    }

    pub mod unalias
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if tokens.len() != 2 {
                let info = "cicada: unalias: syntax error";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let input = &tokens[1].1;
            if !sh.remove_alias(input) {
                let info = format!("cicada: unalias: {}: not found", input);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
            cr
        }
    }

    pub mod vox
    {
        use ::
        {
            *,
        };

        use std::env;
        use std::fs;
        use std::path::Path;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::execute;
        use crate::parsers;
        use crate::shell::{self, Shell};
        use crate::types::{self, CommandResult, CommandLine, Command};

        fn in_env() -> bool {
            env::var("VIRTUAL_ENV").map_or(false, |x| !x.is_empty())
        }

        fn get_envs_home() -> String {
            env::var("VIRTUALENV_HOME").unwrap_or_default()
        }

        fn get_all_venvs() -> Result<Vec<String>, String> {
            let home_envs = get_envs_home();
            if home_envs.is_empty() {
                let info = String::from("you need to set VIRTUALENV_HOME to use vox");
                return Err(info);
            }
            if !Path::new(home_envs.as_str()).exists() {
                match fs::create_dir_all(home_envs.as_str()) {
                    Ok(_) => {}
                    Err(e) => {
                        let info = format!("fs create_dir_all failed: {:?}", e);
                        return Err(info);
                    }
                }
            }

            let mut venvs = Vec::new();
            let pdir = home_envs.clone();
            if let Ok(list) = fs::read_dir(home_envs) {
                for ent in list.flatten() {
                    let ent_name = ent.file_name();
                    if let Ok(path) = ent_name.into_string() {
                        let full_path = format!("{}/{}/bin/activate", pdir, path);
                        if !Path::new(full_path.as_str()).exists() {
                            continue;
                        }
                        venvs.push(path);
                    }
                }
            }

            Ok(venvs)
        }

        fn enter_env(sh: &Shell, path: &str) -> String {
            if in_env() {
                return "vox: already in env".to_string();
            }

            let home_envs = get_envs_home();
            let full_path = format!("{}/{}/bin/activate", home_envs, path);
            if !Path::new(full_path.as_str()).exists() {
                return format!("no such env: {}", full_path);
            }

            let path_env = format!("{}/{}", home_envs, path);
            env::set_var("VIRTUAL_ENV", &path_env);
            let path_new = String::from("${VIRTUAL_ENV}/bin:$PATH");
            let mut tokens: types::Tokens = Vec::new();
            tokens.push((String::new(), path_new));
            shell::expand_env(sh, &mut tokens);
            env::set_var("PATH", &tokens[0].1);
            String::new()
        }

        fn exit_env(sh: &Shell) -> String {
            if !in_env() {
                return String::from("vox: not in an env");
            }

            let env_path = match env::var("PATH") {
                Ok(x) => x,
                Err(_) => {
                    return String::from("vox: cannot read PATH env");
                }
            };

            let mut _tokens: Vec<&str> = env_path.split(':').collect();
            let mut path_virtual_env = String::from("${VIRTUAL_ENV}/bin");
            // shell::extend_env(sh, &mut path_virtual_env);
            let mut tokens: types::Tokens = Vec::new();
            tokens.push((String::new(), path_virtual_env));
            shell::expand_env(sh, &mut tokens);
            path_virtual_env = tokens[0].1.clone();
            _tokens
                .iter()
                .position(|&n| n == path_virtual_env)
                .map(|e| _tokens.remove(e));
            let env_path_new = _tokens.join(":");
            env::set_var("PATH", &env_path_new);
            env::set_var("VIRTUAL_ENV", "");

            String::new()
        }

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();
            let args = parsers::parser_line::tokens_to_args(&tokens);
            let len = args.len();
            let subcmd = if len > 1 { &args[1] } else { "" };

            if len == 1 || (len == 2 && subcmd == "ls") {
                match get_all_venvs() {
                    Ok(venvs) => {
                        let info = venvs.join("\n");
                        print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                    Err(reason) => {
                        print_stderr_with_capture(&reason, &mut cr, cl, cmd, capture);
                        return cr;
                    }
                }
            }

            if len == 3 && subcmd == "create" {
                let pybin = match env::var("VIRTUALENV_PYBIN") {
                    Ok(x) => x,
                    Err(_) => "python3".to_string(),
                };
                let dir_venv = get_envs_home();
                let venv_name = args[2].to_string();
                let line = format!("{} -m venv \"{}/{}\"", pybin, dir_venv, venv_name);
                print_stderr_with_capture(&line, &mut cr, cl, cmd, capture);
                let cr_list = execute::run_command_line(sh, &line, false, false);
                return cr_list[0].clone();
            }

            if len == 3 && subcmd == "enter" {
                let _err = enter_env(sh, args[2].as_str());
                if !_err.is_empty() {
                    print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
                }
                cr
            } else if len == 2 && subcmd == "exit" {
                let _err = exit_env(sh);
                if !_err.is_empty() {
                    print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
                }
                cr
            } else {
                let info = "cicada: vox: invalid option";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                cr
            }
        }
    }

    pub mod ulimit
    {
        use ::
        {
            *,
        };

        use clap::{Parser, CommandFactory};
        use std::io::Error;
        use crate::builtins::utils::print_stderr_with_capture;
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::parsers;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        #[derive(Parser)]
        #[command(name = "ulimit", about = "show / modify shell resource limits")]
        #[allow(non_snake_case)]
        struct App {
            #[arg(short, help = "All current limits are reported.")]
            a: bool,
            #[arg(short, value_name = "NEW VALUE", help = "The maximum number of open file descriptors.")]
            n: Option<Option<u64>>,
            #[arg(short, value_name = "NEW VALUE", help = "The maximum size of core files created.")]
            c: Option<Option<u64>>,
            #[arg(short = 'S', help = "Set a soft limit for the given resource. (default)")]
            S: bool,
            #[arg(short = 'H', help = "Set a hard limit for the given resource.")]
            H: bool,
        }

        pub fn run(_sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = &cmd.tokens;
            let args = parsers::parser_line::tokens_to_args(tokens);

            if args.contains(&"--help".to_string()) || args.contains(&"-h".to_string()) {
                App::command().print_help().unwrap();
                println!();
                return cr;
            }

            let app = App::parse_from(args);

            if app.H && app.S {
                println!("cicada: ulimit: Cannot both hard and soft.");
                cr.status = 1;
                return cr;
            }

            let mut all_stdout = String::new();
            let mut all_stderr = String::new();

            if app.a {
                report_all(&app, &mut all_stdout, &mut all_stderr);
            } else if handle_limit(app.n, "open_files", app.H, &mut all_stdout, &mut all_stderr)
                || handle_limit(app.c, "core_file_size", app.H, &mut all_stdout, &mut all_stderr) {
            } else {
                report_all(&app, &mut all_stdout, &mut all_stderr);
            }

            if !all_stdout.is_empty() {
                print_stdout_with_capture(&all_stdout, &mut cr, cl, cmd, capture);
            }
            if !all_stderr.is_empty() {
                print_stderr_with_capture(&all_stderr, &mut cr, cl, cmd, capture);
            }

            cr
        }

        fn set_limit(limit_name: &str, value: u64, for_hard: bool) -> String {
            let limit_id = match limit_name {
                "open_files" => libc::RLIMIT_NOFILE,
                "core_file_size" => libc::RLIMIT_CORE,
                _ => return String::from("invalid limit name"),
            };

            let mut rlp = libc::rlimit { rlim_cur: 0, rlim_max: 0 };

            unsafe {
                if libc::getrlimit(limit_id, &mut rlp) != 0 {
                    return format!("cicada: ulimit: error getting limit: {}", Error::last_os_error());
                }
            }

            // to support armv7-linux-gnueabihf & 32-bit musl systems
            if for_hard {
                #[cfg(all(target_pointer_width = "32", target_env = "gnu"))]
                { rlp.rlim_max = value as u32; }
                #[cfg(not(all(target_pointer_width = "32", target_env = "gnu")))]
                { rlp.rlim_max = value; }
            } else {
                #[cfg(all(target_pointer_width = "32", target_env = "gnu"))]
                { rlp.rlim_cur = value as u32; }
                #[cfg(not(all(target_pointer_width = "32", target_env = "gnu")))]
                { rlp.rlim_cur = value; }
            }

            unsafe {
                if libc::setrlimit(limit_id, &rlp) != 0 {
                    return format!("cicada: ulimit: error setting limit: {}", Error::last_os_error());
                }
            }

            String::new()
        }

        fn get_limit(limit_name: &str, single_print: bool, for_hard: bool) -> (String, String) {
            let (desc, limit_id) = match limit_name {
                "open_files" => ("open files", libc::RLIMIT_NOFILE),
                "core_file_size" => ("core file size", libc::RLIMIT_CORE),
                _ => return (String::new(), String::from("ulimit: error: invalid limit name")),
            };

            let mut rlp = libc::rlimit { rlim_cur: 0, rlim_max: 0 };

            let mut result_stdout = String::new();
            let mut result_stderr = String::new();

            unsafe {
                if libc::getrlimit(limit_id, &mut rlp) != 0 {
                    result_stderr.push_str(&format!("error getting limit: {}", Error::last_os_error()));
                    return (result_stdout, result_stderr);
                }

                let to_print = if for_hard { rlp.rlim_max } else { rlp.rlim_cur };

                let info = if to_print == libc::RLIM_INFINITY {
                    if single_print { "unlimited\n".to_string() } else { format!("{}\t\tunlimited\n", desc) }
                } else if single_print {
                    format!("{}\n", to_print)
                } else {
                    format!("{}\t\t{}\n", desc, to_print)
                };

                result_stdout.push_str(&info);
            }

            (result_stdout, result_stderr)
        }

        fn report_all(app: &App, all_stdout: &mut String, all_stderr: &mut String) {
            for limit_name in &["open_files", "core_file_size"] {
                let (out, err) = get_limit(limit_name, false, app.H);
                all_stdout.push_str(&out);
                all_stderr.push_str(&err);
            }
        }

        fn handle_limit(
            limit_option: Option<Option<u64>>,
            limit_name: &str,
            for_hard: bool,
            all_stdout: &mut String,
            all_stderr: &mut String) -> bool {
            match limit_option {
                None => false,
                Some(None) => {
                    let (out, err) = get_limit(limit_name, true, for_hard);
                    all_stdout.push_str(&out);
                    all_stderr.push_str(&err);
                    true
                }
                Some(Some(value)) => {
                    let err = set_limit(limit_name, value, for_hard);
                    if !err.is_empty() {
                        all_stderr.push_str(&err);
                    }
                    true
                }
            }
        }
    }

    pub mod minfd
    {
        use ::
        {
            *,
        };

        use std::io::Write;

        use crate::shell::Shell;
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(_sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();

            let fd = nix::fcntl::open(
                "/dev/null",
                nix::fcntl::OFlag::empty(),
                nix::sys::stat::Mode::empty()
            );
            match fd {
                Ok(fd) => {
                    let info = format!("{}", fd);
                    print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                    unsafe { libc::close(fd); }
                }
                Err(e) => {
                    println_stderr!("cicada: minfd: error: {}", e);
                }
            }

            cr
        }
    }

    pub mod set
    {
        use ::
        {
            *,
        };

        use structopt::StructOpt;

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::builtins::utils::print_stdout_with_capture;
        use crate::parsers;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        #[derive(Debug, StructOpt)]
        #[structopt(name = "set", about = "Set shell options (BETA)")]
        struct OptMain {
            #[structopt(short, help = "exit on error status")]
            exit_on_error: bool,
        }

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let mut cr = CommandResult::new();
            let tokens = &cmd.tokens;
            let args = parsers::parser_line::tokens_to_args(tokens);
            let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");

            let opt = OptMain::from_iter_safe(args);
            match opt {
                Ok(opt) => {
                    if opt.exit_on_error {
                        sh.exit_on_error = true;
                        cr
                    } else {
                        let info = "cicada: set: option not implemented";
                        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                        cr
                    }
                }
                Err(e) => {
                    let info = format!("{}", e);
                    if show_usage {
                        print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                        cr.status = 0;
                    } else {
                        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                        cr.status = 1;
                    }
                    cr
                }
            }
        }
    }

    pub mod unpath
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if tokens.len() != 2 {
                let info = "cicada: unpath: syntax error";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let input = &tokens[1].1;
            sh.remove_path(input);
            cr
        }
    }

    pub mod unset
    {
        use ::
        {
            *,
        };

        use crate::builtins::utils::print_stderr_with_capture;
        use crate::shell::Shell;
        use crate::types::{CommandResult, CommandLine, Command};

        pub fn run(sh: &mut Shell, cl: &CommandLine, cmd: &Command,
                capture: bool) -> CommandResult {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if tokens.len() != 2 {
                let info = "cicada: unset: syntax error";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }

            let input = &tokens[1].1;
            if !sh.remove_env(input) {
                let info = format!("cicada: unset: invalid varname: {:?}", input);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
            cr
        }
    }

    pub mod utils
    {
        use ::
        {
            *,
        };

        use std::fs::File;
        use std::io::Write;
        use std::os::unix::io::{FromRawFd, RawFd};

        use errno::errno;

        use crate::tools;
        use crate::types::{Command, CommandLine, CommandResult, Redirection};

        /// Helper function to get (stdout, stderr) pairs for redirections,
        /// e.g. `alias foo 1>/dev/null 2>&1 > foo.txt`
        /// (i.e. [
        ///      ("1", ">", "/dev/null"),
        ///      ("2", ">", "&1"),
        ///      ("1", ">", "foo.txt"),
        ///  ])
        fn _get_std_fds(redirects: &[Redirection]) -> (Option<RawFd>, Option<RawFd>) {
            if redirects.is_empty() {
                return (None, None);
            }

            let mut fd_out = None;
            let mut fd_err = None;

            for i in 0..redirects.len() {
                let item = &redirects[i];
                if item.0 == "1" {
                    // 1>&2
                    let mut _fd_candidate = None;

                    if item.2 == "&2" {
                        let (_fd_out, _fd_err) = _get_std_fds(&redirects[i+1..]);
                        if let Some(fd) = _fd_err {
                            _fd_candidate = Some(fd);
                        } else {
                            _fd_candidate = unsafe { Some(libc::dup(2)) };
                        }
                    } else {  // 1> foo.log
                        let append = item.1 == ">>";
                        if let Ok(fd) = tools::create_raw_fd_from_file(&item.2, append) {
                            _fd_candidate = Some(fd);
                        }
                    }

                    // for command like this: `alias > a.txt > b.txt > c.txt`,
                    // we need to return the last one, but close the previous two.
                    if let Some(fd) = fd_out {
                        unsafe { libc::close(fd); }
                    }

                    fd_out = _fd_candidate;
                }

                if item.0 == "2" {
                    // 2>&1
                    let mut _fd_candidate = None;

                    if item.2 == "&1" {
                        if let Some(fd) = fd_out {
                            _fd_candidate = unsafe { Some(libc::dup(fd)) };
                        }
                    } else {  // 2>foo.log
                        let append = item.1 == ">>";
                        if let Ok(fd) = tools::create_raw_fd_from_file(&item.2, append) {
                            _fd_candidate = Some(fd);
                        }
                    }

                    if let Some(fd) = fd_err {
                        unsafe { libc::close(fd); }
                    }

                    fd_err = _fd_candidate;
                }
            }

            (fd_out, fd_err)
        }

        fn _get_dupped_stdout_fd(cmd: &Command, cl: &CommandLine) -> RawFd {
            // if with pipeline, e.g. `history | grep foo`, then we don't need to
            // dup stdout since it is running in a sperated process, whose fd can
            // be dropped after use.
            if cl.with_pipeline() {
                return 1;
            }

            let (_fd_out, _fd_err) = _get_std_fds(&cmd.redirects_to);
            if let Some(fd) = _fd_err {
                unsafe { libc::close(fd); }
            }
            if let Some(fd) = _fd_out {
                fd
            } else {
                let fd = unsafe { libc::dup(1) };
                if fd == -1 {
                    let eno = errno();
                    println_stderr!("cicada: dup: {}", eno);
                }
                fd
            }
        }

        fn _get_dupped_stderr_fd(cmd: &Command, cl: &CommandLine) -> RawFd {
            if cl.with_pipeline() {
                return 2;
            }

            let (_fd_out, _fd_err) = _get_std_fds(&cmd.redirects_to);
            if let Some(fd) = _fd_out {
                unsafe { libc::close(fd); }
            }

            if let Some(fd) = _fd_err {
                fd
            } else {
                let fd = unsafe { libc::dup(2) };
                if fd == -1 {
                    let eno = errno();
                    println_stderr!("cicada: dup: {}", eno);
                }
                fd
            }
        }

        pub fn print_stdout(info: &str, cmd: &Command, cl: &CommandLine) {
            let fd = _get_dupped_stdout_fd(cmd, cl);
            if fd == -1 {
                return;
            }

            unsafe {
                let mut f = File::from_raw_fd(fd);
                let info = info.trim_end_matches('\n');
                match f.write_all(info.as_bytes()) {
                    Ok(_) => {},
                    Err(e) => {
                        println_stderr!("write_all: error: {}", e);
                    }
                }
                if !info.is_empty() {
                    match f.write_all(b"\n") {
                        Ok(_) => {},
                        Err(e) => {
                            println_stderr!("write_all: error: {}", e);
                        }
                    }
                }
            }
        }

        pub fn print_stderr(info: &str, cmd: &Command, cl: &CommandLine) {
            let fd = _get_dupped_stderr_fd(cmd, cl);
            if fd == -1 {
                return;
            }

            unsafe {
                let mut f = File::from_raw_fd(fd);
                let info = info.trim_end_matches('\n');
                match f.write_all(info.as_bytes()) {
                    Ok(_) => (),
                    Err(e) => {
                        println_stderr!("write_all: error: {}", e);
                    }
                }

                if !info.is_empty() {
                    match f.write_all(b"\n") {
                        Ok(_) => (),
                        Err(e) => {
                            println_stderr!("write_all: error: {}", e);
                        }
                    }
                }
            }
        }

        pub fn print_stderr_with_capture(info: &str, cr: &mut CommandResult,
                                        cl: &CommandLine, cmd: &Command,
                                        capture: bool) {
            cr.status = 1;
            if capture {
                cr.stderr = info.to_string();
            } else {
                print_stderr(info, cmd, cl);
            }
        }

        pub fn print_stdout_with_capture(info: &str, cr: &mut CommandResult,
                                        cl: &CommandLine, cmd: &Command,
                                        capture: bool) {
            cr.status = 0;
            if capture {
                cr.stdout = info.to_string();
            } else {
                print_stdout(info, cmd, cl);
            }
        }
    }
}

pub mod calculator
{
    use ::
    {
        *,
    };

    /*
    num = @{ int ~ ("." ~ ASCII_DIGIT*)? ~ (^"e" ~ int)? }
    int = { ("+" | "-")? ~ ASCII_DIGIT+ }

    operation = _{ add | subtract | multiply | divide | power }
    add      = { "+" }
    subtract = { "-" }
    multiply = { "*" }
    divide   = { "/" }
    power    = { "^" }

    expr = { term ~ (operation ~ term)* }
    term = _{ num | "(" ~ expr ~ ")" }

    calculation = _{ SOI ~ expr ~ EOI }

    WHITESPACE = _{ " " | "\t" }
    */

    // via: https://github.com/pest-parser/book/blob/b6a42eb7/examples/calculator/src/main.rs
    use std::num::Wrapping as W;

    use pest::Parser;
    use pest::iterators::{Pair, Pairs};
    use pest::pratt_parser::{Assoc, Op, PrattParser};

    #[derive(Parser)]
    #[grammar = "calculator/grammar.pest"]
    struct Calculator;

    lazy_static! {
        static ref PRATT_PARSER: PrattParser<Rule> = {
            use Rule::*;
            use Assoc::*;

            PrattParser::new()
                .op(Op::infix(add, Left) | Op::infix(subtract, Left))
                .op(Op::infix(multiply, Left) | Op::infix(divide, Left))
                .op(Op::infix(power, Right))
        };
    }

    pub fn eval_int(expression: Pairs<Rule>) -> i64 {
        PRATT_PARSER
            .map_primary(|primary| match primary.as_rule() {
                Rule::num => primary.as_str().parse::<i64>().unwrap(),
                Rule::expr => eval_int(primary.into_inner()),
                _ => unreachable!(),
            })
            .map_infix(|lhs: i64, op: Pair<Rule>, rhs: i64| match op.as_rule() {
                Rule::add => (W(lhs) + W(rhs)).0,
                Rule::subtract => (W(lhs) - W(rhs)).0,
                Rule::multiply => (W(lhs) * W(rhs)).0,
                Rule::divide => {
                    if rhs == 0 {
                        (lhs as f64 / 0.0) as i64
                    } else {
                        (W(lhs) / W(rhs)).0
                    }
                }
                Rule::power => lhs.pow(rhs as u32),
                _ => unreachable!(),
            })
            .parse(expression)
    }

    pub fn eval_float(expression: Pairs<Rule>) -> f64 {
        PRATT_PARSER
            .map_primary(|primary| match primary.as_rule() {
                Rule::num => primary.as_str().parse::<f64>().unwrap(),
                Rule::expr => eval_float(primary.into_inner()),
                _ => unreachable!(),
            })
            .map_infix(|lhs, op, rhs| match op.as_rule() {
                Rule::add => lhs + rhs,
                Rule::subtract => lhs - rhs,
                Rule::multiply => lhs * rhs,
                Rule::divide => lhs / rhs,
                Rule::power => lhs.powf(rhs),
                _ => unreachable!(),
            })
            .parse(expression)
    }

    pub fn calculate(line: &str) -> Result<pest::iterators::Pairs<'_, Rule>, pest::error::Error<Rule>> {
        Calculator::parse(Rule::calculation, line)
    }
}

pub mod completers
{
    use ::
    {
        *,
    };

    use std::path::Path;
    use std::sync::Arc;

    use lineread::complete::{Completer, Completion};
    use lineread::prompter::Prompter;
    use lineread::terminal::Terminal;

    pub mod dots
    {
        use ::
        {
            *,
        };

        use std::borrow::Cow;
        use std::fs::File;
        use std::io::{Read, Write};
        use std::path::Path;

        use lineread::complete::escape;
        use lineread::complete::escaped_word_start;
        use lineread::complete::unescape;
        use lineread::complete::Suffix;
        use lineread::complete::{Completer, Completion};
        use lineread::prompter::Prompter;
        use lineread::terminal::Terminal;
        use yaml_rust::{Yaml, YamlLoader};
        use yaml_rust::yaml::Hash;

        use crate::execute;
        use crate::parsers;
        use crate::tools;

        /// Performs completion by searching dotfiles
        pub struct DotsCompleter;

        impl<Term: Terminal> Completer<Term> for DotsCompleter {
            fn complete(
                &self,
                word: &str,
                reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                let line = reader.buffer();
                Some(complete_dots(line, word))
            }

            fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
                escaped_word_start(&line[..end])
            }

            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                escape(word)
            }

            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                unescape(word)
            }
        }

        fn get_dot_file(line: &str) -> (String, String) {
            let args = parsers::parser_line::line_to_plain_tokens(line);
            let dir = tools::get_user_completer_dir();
            let dot_file = format!("{}/{}.yaml", dir, args[0]);
            if !Path::new(&dot_file).exists() {
                return (String::new(), String::new());
            }
            let sub_cmd = if (args.len() >= 3 && !args[1].starts_with('-'))
                || (args.len() >= 2 && !args[1].starts_with('-') && line.ends_with(' '))
            {
                args[1].as_str()
            } else {
                ""
            };

            (dot_file, sub_cmd.to_string())
        }

        fn handle_lv1_string(res: &mut Vec<Completion>,
                            value: &str, word: &str) {
            if !value.starts_with(word) && !value.starts_with('`') {
                return;
            }

            let linfo = parsers::parser_line::parse_line(value);
            let tokens = linfo.tokens;
            if tokens.len() == 1 && tokens[0].0 == "`" {
                log!("run subcmd: {:?}", &tokens[0].1);
                let cr = execute::run(&tokens[0].1);
                let v: Vec<&str> = cr.stdout.split(|c| c == '\n' || c == ' ').collect();
                for s in v {
                    if s.trim().is_empty() {
                        continue;
                    }
                    handle_lv1_string(res, s, word);
                }
                return;
            }

            let display = None;
            let suffix = Suffix::Default;
            res.push(Completion {
                completion: value.to_string(),
                display,
                suffix,
            });
        }

        fn handle_lv1_hash(res: &mut Vec<Completion>,
                        h: &Hash, word: &str) {
            for v in h.values() {
                if let Yaml::Array(ref arr) = v {
                    for s in arr {
                        if let Yaml::String(value) = s {
                            if !value.starts_with(word) && !value.starts_with('`') {
                                continue;
                            }
                            handle_lv1_string(res, value, word);
                        }
                    }
                }
            }
        }

        fn complete_dots(line: &str, word: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            if line.trim().is_empty() {
                return res;
            }
            let (dot_file, sub_cmd) = get_dot_file(line);
            if dot_file.is_empty() {
                return res;
            }

            let mut f;
            match File::open(&dot_file) {
                Ok(x) => f = x,
                Err(e) => {
                    println_stderr!("\ncicada: open dot_file error: {:?}", e);
                    return res;
                }
            }

            let mut s = String::new();
            match f.read_to_string(&mut s) {
                Ok(_) => {}
                Err(e) => {
                    println_stderr!("\ncicada: read_to_string error: {:?}", e);
                    return res;
                }
            }

            let docs = match YamlLoader::load_from_str(&s) {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("\ncicada: Bad Yaml file: {}: {:?}", dot_file, e);
                    return res;
                }
            };

            for doc in docs.iter() {
                match *doc {
                    Yaml::Array(ref v) => {
                        for x in v {
                            match *x {
                                Yaml::String(ref name) => {
                                    if !sub_cmd.is_empty() {
                                        continue;
                                    }
                                    handle_lv1_string(&mut res, name, word);
                                }
                                Yaml::Hash(ref h) => {
                                    if sub_cmd.is_empty() {
                                        for k in h.keys() {
                                            if let Yaml::String(value) = k {
                                                handle_lv1_string(&mut res, value, word);
                                            }
                                        }
                                    } else {
                                        let key = Yaml::from_str(&sub_cmd);
                                        if !h.contains_key(&key) {
                                            continue;
                                        }
                                        handle_lv1_hash(&mut res, h, word);
                                    }
                                }
                                _ => {
                                    println_stderr!("\nThis yaml file is in bad format: {}", dot_file);
                                }
                            }
                        }
                    }
                    _ => {
                        println_stderr!("\nThis yaml file is in bad format: {}", dot_file);
                    }
                }
            }
            res
        }
    }

    pub mod env
    {
        use ::
        {
            *,
        };

        use std::env;
        use std::sync::Arc;

        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::prompter::Prompter;
        use lineread::terminal::Terminal;

        use crate::shell;

        pub struct EnvCompleter {
            pub sh: Arc<shell::Shell>,
        }

        impl<Term: Terminal> Completer<Term> for EnvCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                let sh = Arc::try_unwrap(self.sh.clone());
                match sh {
                    Ok(x) => Some(complete_env(&x, word)),
                    Err(x) => Some(complete_env(&x, word)),
                }
            }
        }

        fn complete_env(sh: &shell::Shell, path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            if path.trim().is_empty() {
                return res;
            }
            let mut prefix = path.to_string();
            prefix.remove(0);

            for (key, _) in env::vars_os() {
                let env_name = key.to_string_lossy().to_string();
                if env_name.starts_with(&prefix) {
                    res.push(Completion {
                        completion: format!("${}", env_name),
                        display: None,
                        suffix: Suffix::Default,
                    });
                }
            }

            // sh.envs is a just clone here; see FIXME in main.rs
            for key in sh.envs.keys() {
                if key.starts_with(&prefix) {
                    res.push(Completion {
                        completion: format!("${}", key),
                        display: None,
                        suffix: Suffix::Default,
                    });
                }
            }

            res
        }
    }

    pub mod make
    {
        use ::
        {
            *,
        };
        use std::env;
        use std::fs::File;
        use std::io::{BufRead, BufReader, Write};

        use regex::Regex;

        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::prompter::Prompter;
        use lineread::terminal::Terminal;

        pub struct MakeCompleter;

        impl<Term: Terminal> Completer<Term> for MakeCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_make(word))
            }
        }

        fn handle_file(ci: &mut Vec<Completion>, path: &str, file_path: &str, current_dir: &str) {
            if let Ok(f) = File::open(file_path) {
                let file = BufReader::new(&f);
                let re_cmd = match Regex::new(r"^ *([^ ]+):") {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!("cicada: regex build error: {:?}", e);
                        return;
                    }
                };

                let re_include = match Regex::new(r"^ *include  *([^ ]+) *$") {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!("cicada: regex build error: {:?}", e);
                        return;
                    }
                };

                for line in file.lines().map_while(Result::ok) {
                    if re_cmd.is_match(&line) {
                        for cap in re_cmd.captures_iter(&line) {
                            if !cap[1].starts_with(path) {
                                continue;
                            }
                            ci.push(Completion {
                                completion: cap[1].to_string(),
                                display: None,
                                suffix: Suffix::Default,
                            });
                        }
                    }
                    if re_include.is_match(&line) {
                        for cap in re_include.captures_iter(&line) {
                            let _file = &cap[1];
                            if _file.contains('/') {
                                handle_file(ci, path, _file, current_dir);
                            } else {
                                let make_file = current_dir.to_owned() + "/" + _file;
                                handle_file(ci, path, &make_file, current_dir);
                            }
                        }
                    }
                }
            }
        }

        fn complete_make(path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            let current_dir = match env::current_dir() {
                Ok(dir) => match dir.to_str() {
                    Some(s) => s.to_string(),
                    None => {
                        println!("cicada: to_str error");
                        return res;
                    }
                },
                Err(e) => {
                    println!("cicada: get current_dir error: {:?}", e);
                    return res;
                }
            };

            let make_file = format!("{}/Makefile", current_dir);
            handle_file(&mut res, path, &make_file, &current_dir);
            res
        }
    }

    pub mod path
    {
        use ::
        {
            *,
        };

        use std::collections::HashSet;
        use std::env;
        use std::fs::read_dir;
        use std::io::Write;
        use std::iter::FromIterator;
        use std::os::unix::fs::PermissionsExt;
        use std::path::MAIN_SEPARATOR;
        use std::sync::Arc;

        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::terminal::Terminal;
        use lineread::Prompter;

        use crate::completers::utils;
        use crate::libs;
        use crate::parsers;
        use crate::shell;
        use crate::tools;

        pub struct BinCompleter {
            pub sh: Arc<shell::Shell>,
        }
        pub struct CdCompleter;
        pub struct PathCompleter;

        fn is_env_prefix(line: &str) -> bool {
            libs::re::re_contains(line, r" *\$[a-zA-Z_][A-Za-z0-9_]*")
        }

        fn is_pipelined(path: &str) -> bool {
            if !path.contains('|') {
                return false;
            }
            !path.starts_with('"') && !path.starts_with('\'')
        }

        impl<Term: Terminal> Completer<Term> for BinCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                let sh = Arc::try_unwrap(self.sh.clone());
                match sh {
                    Ok(x) => Some(complete_bin(&x, word)),
                    Err(x) => Some(complete_bin(&x, word)),
                }
            }
        }

        impl<Term: Terminal> Completer<Term> for PathCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_path(word, false))
            }
        }

        impl<Term: Terminal> Completer<Term> for CdCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_path(word, true))
            }
        }

        fn needs_expand_home(line: &str) -> bool {
            libs::re::re_contains(line, r"( +~ +)|( +~/)|(^ *~/)|( +~ *$)")
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path(word: &str, for_dir: bool) -> Vec<Completion> {
            let is_env = is_env_prefix(word);
            let mut res = Vec::new();
            let linfo = parsers::parser_line::parse_line(word);
            let tokens = linfo.tokens;
            let (path, path_sep) = if tokens.is_empty() {
                (String::new(), String::new())
            } else {
                let (ref _path_sep, ref _path) = tokens[tokens.len() - 1];
                (_path.clone(), _path_sep.clone())
            };

            let (_, _dir_orig, _f) = split_pathname(&path, "");
            let dir_orig = if _dir_orig.is_empty() {
                String::new()
            } else {
                _dir_orig.clone()
            };
            let mut path_extended = path.clone();
            if needs_expand_home(&path_extended) {
                utils::expand_home_string(&mut path_extended)
            }
            utils::expand_env_string(&mut path_extended);

            let (_, _dir_lookup, file_name) = split_pathname(&path_extended, "");
            let dir_lookup = if _dir_lookup.is_empty() {
                ".".to_string()
            } else {
                _dir_lookup.clone()
            };
            // let dir_lookup = _dir_lookup.unwrap_or(".");
            if let Ok(entries) = read_dir(dir_lookup) {
                for entry in entries.flatten() {
                    let pathbuf = entry.path();
                    let is_dir = pathbuf.is_dir();
                    if for_dir && !is_dir {
                        continue;
                    }

                    let entry_name = entry.file_name();
                    // TODO: Deal with non-UTF8 paths in some way
                    if let Ok(_path) = entry_name.into_string() {
                        if _path.starts_with(&file_name) {
                            let (name, display) = if !dir_orig.is_empty() {
                                (
                                    format!("{}{}{}", dir_orig, MAIN_SEPARATOR, _path),
                                    Some(_path),
                                )
                            } else {
                                (_path, None)
                            };
                            let mut name = str::replace(name.as_str(), "//", "/");
                            if path_sep.is_empty() && !is_env {
                                name = tools::escape_path(&name);
                            }
                            let mut quoted = false;
                            if !path_sep.is_empty() {
                                name = tools::wrap_sep_string(&path_sep, &name);
                                quoted = true;
                            }
                            let suffix = if is_dir {
                                if quoted {
                                    name.pop();
                                }
                                Suffix::Some(MAIN_SEPARATOR)
                            } else {
                                Suffix::Default
                            };
                            res.push(Completion {
                                completion: name,
                                display,
                                suffix,
                            });
                        }
                    }
                }
            }
            res.sort_by(|a, b| a.completion.cmp(&b.completion));
            res
        }

        // Split optional directory and prefix. (see its test cases for more details)
        fn split_pathname(path: &str, prefix: &str) -> (String, String, String) {
            if is_pipelined(path) {
                let tokens: Vec<&str> = path.rsplitn(2, '|').collect();
                let prefix = format!("{}|", tokens[1]);
                return split_pathname(tokens[0], &prefix);
            }
            match path.rfind('/') {
                Some(pos) => (
                    prefix.to_string(),
                    path[..=pos].to_string(),
                    path[pos + 1..].to_string(),
                ),
                None => (prefix.to_string(), String::new(), path.to_string()),
            }
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        fn complete_bin(sh: &shell::Shell, path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            let (prefix, _, fname) = split_pathname(path, "");
            let env_path = match env::var("PATH") {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: env error when complete_bin: {:?}", e);
                    return res;
                }
            };

            let mut checker: HashSet<String> = HashSet::new();

            // handle alias, builtins, and functions
            for func in sh.funcs.keys() {
                if !func.starts_with(&fname) {
                    continue;
                }
                if checker.contains(func) {
                    continue;
                }
                checker.insert(func.clone());
                res.push(Completion {
                    completion: func.to_owned(),
                    display: None,
                    suffix: Suffix::Default,
                });
            }
            for alias in sh.aliases.keys() {
                if !alias.starts_with(&fname) {
                    continue;
                }
                if checker.contains(alias) {
                    continue;
                }
                checker.insert(alias.clone());
                res.push(Completion {
                    completion: alias.to_owned(),
                    display: None,
                    suffix: Suffix::Default,
                });
            }

            let builtins = vec![
                "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg",
                "history", "jobs", "read", "source", "ulimit", "unalias", "vox",
                "minfd", "set", "unset", "unpath",
            ];
            for item in &builtins {
                if !item.starts_with(&fname) {
                    continue;
                }
                if checker.contains(*item) {
                    continue;
                }
                checker.insert(item.to_string());
                res.push(Completion {
                    completion: item.to_string(),
                    display: None,
                    suffix: Suffix::Default,
                });
            }

            let vec_path: Vec<&str> = env_path.split(':').collect();
            let path_list: HashSet<&str> = HashSet::from_iter(vec_path.iter().cloned());

            for p in &path_list {
                if let Ok(list) = read_dir(p) {
                    for entry in list.flatten() {
                        if let Ok(name) = entry.file_name().into_string() {
                            if name.starts_with(&fname) {
                                let _mode = match entry.metadata() {
                                    Ok(x) => x,
                                    Err(e) => {
                                        println_stderr!("cicada: metadata error: {:?}", e);
                                        continue;
                                    }
                                };
                                let mode = _mode.permissions().mode();
                                if mode & 0o111 == 0 {
                                    // not binary
                                    continue;
                                }
                                if checker.contains(&name) {
                                    continue;
                                }

                                let display = None;
                                let suffix = Suffix::Default;
                                checker.insert(name.clone());
                                // TODO: need to handle quoted: `$ "foo#bar"`
                                let name_e = tools::escape_path(&name);
                                let name_e = format!("{}{}", prefix, name_e);
                                res.push(Completion {
                                    completion: name_e,
                                    display,
                                    suffix,
                                });
                            }
                        }
                    }
                }
            }
            res
        }
    }

    pub mod ssh
    {
        use ::
        {
            *,
        };

        use std::fs::File;
        use std::io::{BufRead, BufReader};

        use regex::Regex;

        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::terminal::Terminal;
        use lineread::Prompter;

        use crate::tools;

        pub struct SshCompleter;

        impl<Term: Terminal> Completer<Term> for SshCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_ssh(word))
            }
        }

        fn complete_ssh(path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            let home = tools::get_user_home();
            let ssh_config = home + "/.ssh/config";
            if let Ok(f) = File::open(&ssh_config) {
                let file = BufReader::new(&f);
                let re = match Regex::new(r"^ *(?i)host +([^ ]+)") {
                    Ok(x) => x,
                    Err(e) => {
                        println!("Regex build error: {:?}", e);
                        return res;
                    }
                };
                for line in file.lines().map_while(Result::ok) {
                    if !re.is_match(&line) {
                        continue;
                    }
                    for cap in re.captures_iter(&line) {
                        if !cap[1].starts_with(path) {
                            continue;
                        }
                        res.push(Completion {
                            completion: cap[1].to_string(),
                            display: None,
                            suffix: Suffix::Default,
                        });
                    }
                }
            }
            res
        }
    }

    pub mod utils
    {
        use ::
        {
            *,
        };

        use regex::Regex;
        use std::env;

        use crate::libs;
        use crate::tools;

        pub fn expand_home_string(text: &mut String) {
            let v = vec![
                r"(?P<head> +)~(?P<tail> +)",
                r"(?P<head> +)~(?P<tail>/)",
                r"^(?P<head> *)~(?P<tail>/)",
                r"(?P<head> +)~(?P<tail> *$)",
            ];
            for item in &v {
                let re;
                if let Ok(x) = Regex::new(item) {
                    re = x;
                } else {
                    return;
                }
                let home = tools::get_user_home();
                let ss = text.clone();
                let to = format!("$head{}$tail", home);
                let result = re.replace_all(ss.as_str(), to.as_str());
                *text = result.to_string();
            }
        }

        pub fn expand_env_string(text: &mut String) {
            // expand "$HOME/.local/share" to "/home/tom/.local/share"
            if !text.starts_with('$') {
                return;
            }
            let ptn = r"^\$([A-Za-z_][A-Za-z0-9_]*)";
            let mut env_value = String::new();
            match libs::re::find_first_group(ptn, text) {
                Some(x) => {
                    if let Ok(val) = env::var(&x) {
                        env_value = val;
                    }
                }
                None => {
                    return;
                }
            }

            if env_value.is_empty() {
                return;
            }
            let t = text.clone();
            *text = libs::re::replace_all(&t, ptn, &env_value);
        }
    }
    
    use crate::libs;
    use crate::parsers;
    use crate::shell;
    use crate::tools;

    pub struct CicadaCompleter {
        pub sh: Arc<shell::Shell>,
    }

    fn for_make(line: &str) -> bool {
        libs::re::re_contains(line, r"^ *make ")
    }

    fn for_env(line: &str) -> bool {
        libs::re::re_contains(line, r" *\$[_a-zA-Z0-9]*$")
    }

    fn for_ssh(line: &str) -> bool {
        libs::re::re_contains(line, r"^ *(ssh|scp).* +[^ \./]+ *$")
    }

    fn for_cd(line: &str) -> bool {
        libs::re::re_contains(line, r"^ *cd +")
    }

    fn for_bin(line: &str) -> bool {
        let ptn = r"(^ *(sudo|which|nohup)? *[a-zA-Z0-9_\.-]+$)|(^.+\| *(sudo|which|nohup)? *[a-zA-Z0-9_\.-]+$)";
        libs::re::re_contains(line, ptn)
    }

    fn for_dots(line: &str) -> bool {
        let args = parsers::parser_line::line_to_plain_tokens(line);
        let len = args.len();
        if len == 0 {
            return false;
        }
        let dir = tools::get_user_completer_dir();
        let dot_file = format!("{}/{}.yaml", dir, args[0]);
        Path::new(dot_file.as_str()).exists()
    }

    impl<Term: Terminal> Completer<Term> for CicadaCompleter {
        fn complete(
            &self,
            word: &str,
            reader: &Prompter<Term>,
            start: usize,
            _end: usize,
        ) -> Option<Vec<Completion>> {
            let line = reader.buffer();

            let completions: Option<Vec<Completion>>;
            if for_dots(line) {
                let cpl = Arc::new(dots::DotsCompleter);
                completions = cpl.complete(word, reader, start, _end);
            } else if for_ssh(line) {
                let cpl = Arc::new(ssh::SshCompleter);
                completions = cpl.complete(word, reader, start, _end);
            } else if for_make(line) {
                let cpl = Arc::new(make::MakeCompleter);
                completions = cpl.complete(word, reader, start, _end);
            } else if for_bin(line) {
                let cpl = Arc::new(path::BinCompleter {
                    sh: self.sh.clone(),
                });
                completions = cpl.complete(word, reader, start, _end);
            } else if for_env(line) {
                let cpl = Arc::new(env::EnvCompleter {
                    sh: self.sh.clone(),
                });
                completions = cpl.complete(word, reader, start, _end);
            } else if for_cd(line) {
                // `for_cd` should be put a bottom position, so that
                // `cd $SOME_ENV_<TAB>` works as expected.
                let cpl = Arc::new(path::CdCompleter);
                // completions for `cd` should not fail back to path-completion
                return cpl.complete(word, reader, start, _end);
            } else {
                completions = None;
            }

            if let Some(x) = completions {
                if !x.is_empty() {
                    return Some(x);
                }
            }

            // empty completions should fail back to path-completion,
            // so that `$ make generate /path/to/fi<Tab>` still works.
            let cpl = Arc::new(path::PathCompleter);
            cpl.complete(word, reader, start, _end)
        }

        fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
            escaped_word_start(&line[..end])
        }
    }

    pub fn escaped_word_start(line: &str) -> usize {
        let mut start_position: usize = 0;
        let mut found_bs = false;
        let mut found_space = false;
        let mut with_quote = false;
        let mut ch_quote = '\0';
        let mut extra_bytes = 0;
        for (i, c) in line.chars().enumerate() {
            if found_space {
                found_space = false;
                start_position = i + extra_bytes;
            }

            if c == '\\' {
                found_bs = true;
                continue;
            }
            if c == ' ' && !found_bs && !with_quote {
                found_space = true;
                continue;
            }

            if !with_quote && !found_bs && (c == '"' || c == '\'') {
                with_quote = true;
                ch_quote = c;
            } else if with_quote && !found_bs && ch_quote == c {
                with_quote = false;
            }

            let bytes_c = c.len_utf8();
            if bytes_c > 1 {
                extra_bytes += bytes_c - 1;
            }
            found_bs = false;
        }
        if found_space {
            start_position = line.len();
        }
        start_position
    }
}

pub mod core
{
    use ::
    {
        *,
    };
    use std::env;
    use std::ffi::{CStr, CString};
    use std::fs::File;
    use std::io::{Read, Write};
    use std::os::unix::io::FromRawFd;
    use std::os::fd::RawFd;
    use std::process;

    use nix::unistd::{execve, ForkResult};
    use libs::pipes::pipe;

    use crate::builtins;
    use crate::calculator;
    use crate::jobc;
    use crate::libs;
    use crate::parsers;
    use crate::scripting;
    use crate::shell::{self, Shell};
    use crate::tools;
    use crate::types::{CommandLine, CommandOptions, CommandResult};

    fn try_run_builtin_in_subprocess(
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<i32> {
        if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) {
            return Some(cr.status);
        }
        None
    }

    fn try_run_builtin(
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<CommandResult> {
        // for builtin, only capture its outputs when it locates at the end
        let capture = capture && idx_cmd + 1 == cl.commands.len();

        if idx_cmd >= cl.commands.len() {
            println_stderr!("unexpected error in try_run_builtin");
            return None;
        }

        let cmd = &cl.commands[idx_cmd];
        let tokens = cmd.tokens.clone();
        let cname = tokens[0].1.clone();
        if cname == "alias" {
            let cr = builtins::alias::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "bg" {
            let cr = builtins::bg::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "cd" {
            let cr = builtins::cd::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "cinfo" {
            let cr = builtins::cinfo::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "exec" {
            let cr = builtins::exec::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "exit" {
            let cr = builtins::exit::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "export" {
            let cr = builtins::export::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "fg" {
            let cr = builtins::fg::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "history" {
            let cr = builtins::history::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "jobs" {
            let cr = builtins::jobs::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "minfd" {
            let cr = builtins::minfd::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "read" {
            let cr = builtins::read::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "set" {
            let cr = builtins::set::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "source" {
            let cr = builtins::source::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "ulimit" {
            let cr = builtins::ulimit::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "unalias" {
            let cr = builtins::unalias::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "unset" {
            let cr = builtins::unset::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "unpath" {
            let cr = builtins::unpath::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "vox" {
            let cr = builtins::vox::run(sh, cl, cmd, capture);
            return Some(cr);
        }
        None
    }
    /// Run a pipeline (e.g. `echo hi | wc -l`)
    /// returns: (is-terminal-given, command-result)
    pub fn run_pipeline(
        sh: &mut shell::Shell,
        cl: &CommandLine,
        tty: bool,
        capture: bool,
        log_cmd: bool,
    ) -> (bool, CommandResult) {
        let mut term_given = false;
        if cl.background && capture {
            println_stderr!("cicada: cannot capture output of background cmd");
            return (term_given, CommandResult::error());
        }

        if let Some(cr) = try_run_calculator(&cl.line, capture) {
            return (term_given, cr);
        }

        // FIXME: move func-run into run single command
        if let Some(cr) = try_run_func(sh, cl, capture, log_cmd) {
            return (term_given, cr);
        }

        if log_cmd {
            log!("run: {}", cl.line);
        }

        let length = cl.commands.len();
        if length == 0 {
            println!("cicada: invalid command: cmds with empty length");
            return (false, CommandResult::error());
        }

        let mut pipes = Vec::new();
        let mut errored_pipes = false;
        for _ in 0..length - 1 {
            match pipe() {
                Ok(fds) => pipes.push(fds),
                Err(e) => {
                    errored_pipes = true;
                    println_stderr!("cicada: pipeline1: {}", e);
                    break;
                }
            }
        }

        if errored_pipes {
            // release fds that already created when errors occurred
            for fds in pipes {
                libs::close(fds.0);
                libs::close(fds.1);
            }
            return (false, CommandResult::error());
        }

        if pipes.len() + 1 != length {
            println!("cicada: invalid command: unmatched pipes count");
            return (false, CommandResult::error());
        }

        let mut pgid: i32 = 0;
        let mut fg_pids: Vec<i32> = Vec::new();

        let isatty = if tty {
            unsafe { libc::isatty(1) == 1 }
        } else {
            false
        };
        let options = CommandOptions {
            isatty,
            capture_output: capture,
            background: cl.background,
            envs: cl.envs.clone(),
        };

        let mut fds_capture_stdout = None;
        let mut fds_capture_stderr = None;
        if capture {
            match pipe() {
                Ok(fds) => fds_capture_stdout = Some(fds),
                Err(e) => {
                    println_stderr!("cicada: pipeline2: {}", e);
                    return (false, CommandResult::error());
                }
            }
            match pipe() {
                Ok(fds) => fds_capture_stderr = Some(fds),
                Err(e) => {
                    if let Some(fds) = fds_capture_stdout {
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                    println_stderr!("cicada: pipeline3: {}", e);
                    return (false, CommandResult::error());
                }
            }
        }

        let mut cmd_result = CommandResult::new();
        for i in 0..length {
            let child_id: i32 = run_single_program(
                sh,
                cl,
                i,
                &options,
                &mut pgid,
                &mut term_given,
                &mut cmd_result,
                &pipes,
                &fds_capture_stdout,
                &fds_capture_stderr,
            );

            if child_id > 0 && !cl.background {
                fg_pids.push(child_id);
            }
        }

        if cl.is_single_and_builtin() {
            return (false, cmd_result);
        }

        if cl.background {
            if let Some(job) = sh.get_job_by_gid(pgid) {
                println_stderr!("[{}] {}", job.id, job.gid);
            }
        }

        if !fg_pids.is_empty() {
            let _cr = jobc::wait_fg_job(sh, pgid, &fg_pids);
            // for capture commands, e.g. `echo foo` in `echo "hello $(echo foo)"
            // the cmd_result is already built in loop calling run_single_program()
            // above.
            if !capture {
                cmd_result = _cr;
            }
        }
        (term_given, cmd_result)
    }
    /// Run a single command.
    /// e.g. the `sort -k2` part of `ps ax | sort -k2 | head`
    #[allow(clippy::needless_range_loop)]
    #[allow(clippy::too_many_arguments)]
    fn run_single_program(
        sh: &mut shell::Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        options: &CommandOptions,
        pgid: &mut i32,
        term_given: &mut bool,
        cmd_result: &mut CommandResult,
        pipes: &[(RawFd, RawFd)],
        fds_capture_stdout: &Option<(RawFd, RawFd)>,
        fds_capture_stderr: &Option<(RawFd, RawFd)>,
    ) -> i32 {
        let capture = options.capture_output;
        if cl.is_single_and_builtin() {
            if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) {
                *cmd_result = cr;
                return unsafe { libc::getpid() };
            }

            println_stderr!("cicada: error when run singler builtin");
            log!("error when run singler builtin: {:?}", cl);
            return 1;
        }

        let pipes_count = pipes.len();
        let mut fds_stdin = None;
        let cmd = cl.commands.get(idx_cmd).unwrap();

        if cmd.has_here_string() {
            match pipe() {
                Ok(fds) => fds_stdin = Some(fds),
                Err(e) => {
                    println_stderr!("cicada: pipeline4: {}", e);
                    return 1;
                }
            }
        }

        match libs::fork::fork() {
            Ok(ForkResult::Child) => {
                unsafe {
                    // child processes need to handle ctrl-Z
                    libc::signal(libc::SIGTSTP, libc::SIG_DFL);
                    libc::signal(libc::SIGQUIT, libc::SIG_DFL);
                }

                // close pipes unrelated to current child (left side)
                if idx_cmd > 0 {
                    for i in 0..idx_cmd - 1 {
                        let fds = pipes[i];
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                }
                // close pipes unrelated to current child (right side)
                for i in idx_cmd + 1..pipes_count {
                    let fds = pipes[i];
                    libs::close(fds.0);
                    libs::close(fds.1);
                }
                // close pipe fds for capturing stdout/stderr
                // (they're only used in last child)
                if idx_cmd < pipes_count {
                    if let Some(fds) = fds_capture_stdout {
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                    if let Some(fds) = fds_capture_stderr {
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                }

                if idx_cmd == 0 {
                    unsafe {
                        let pid = libc::getpid();
                        libc::setpgid(0, pid);
                    }
                } else {
                    unsafe {
                        libc::setpgid(0, *pgid);
                    }
                }

                // (in child) replace stdin/stdout with read/write ends of pipe
                if idx_cmd > 0 {
                    let fds_prev = pipes[idx_cmd - 1];
                    libs::dup2(fds_prev.0, 0);
                    libs::close(fds_prev.0);
                    libs::close(fds_prev.1);
                }
                if idx_cmd < pipes_count {
                    let fds = pipes[idx_cmd];
                    libs::dup2(fds.1, 1);
                    libs::close(fds.1);
                    libs::close(fds.0);
                }

                if cmd.has_redirect_from() {
                    if let Some(redirect_from) = &cmd.redirect_from {
                        let fd = tools::get_fd_from_file(&redirect_from.clone().1);
                        if fd == -1 {
                            process::exit(1);
                        }

                        libs::dup2(fd, 0);
                        libs::close(fd);
                    }
                }

                if cmd.has_here_string() {
                    if let Some(fds) = fds_stdin {
                        libs::close(fds.1);
                        libs::dup2(fds.0, 0);
                        libs::close(fds.0);
                    }
                }

                let mut stdout_redirected = false;
                let mut stderr_redirected = false;
                for item in &cmd.redirects_to {
                    let from_ = &item.0;
                    let op_ = &item.1;
                    let to_ = &item.2;
                    if to_ == "&1" && from_ == "2" {
                        if idx_cmd < pipes_count {
                            libs::dup2(1, 2);
                        } else if !options.capture_output {
                            let fd = libs::dup(1);
                            if fd == -1 {
                                println_stderr!("cicada: dup error");
                                process::exit(1);
                            }
                            libs::dup2(fd, 2);
                        } else {
                            // note: capture output with redirections does not
                            // make much sense
                        }
                    } else if to_ == "&2" && from_ == "1" {
                        if idx_cmd < pipes_count || !options.capture_output {
                            let fd = libs::dup(2);
                            if fd == -1 {
                                println_stderr!("cicada: dup error");
                                process::exit(1);
                            }
                            libs::dup2(fd, 1);
                        } else {
                            // note: capture output with redirections does not
                            // make much sense
                        }
                    } else {
                        let append = op_ == ">>";
                        match tools::create_raw_fd_from_file(to_, append) {
                            Ok(fd) => {
                                if fd == -1 {
                                    println_stderr!("cicada: fork: fd error");
                                    process::exit(1);
                                }

                                if from_ == "1" {
                                    libs::dup2(fd, 1);
                                    stdout_redirected = true;
                                } else {
                                    libs::dup2(fd, 2);
                                    stderr_redirected = true;
                                }
                            }
                            Err(e) => {
                                println_stderr!("cicada: fork: {}", e);
                                process::exit(1);
                            }
                        }
                    }
                }

                // capture output of last process if needed.
                if idx_cmd == pipes_count && options.capture_output {
                    if !stdout_redirected {
                        if let Some(fds) = fds_capture_stdout {
                            libs::close(fds.0);
                            libs::dup2(fds.1, 1);
                            libs::close(fds.1);
                        }
                    }
                    if !stderr_redirected {
                        if let Some(fds) = fds_capture_stderr {
                            libs::close(fds.0);
                            libs::dup2(fds.1, 2);
                            libs::close(fds.1);
                        }
                    }
                }

                if cmd.is_builtin() {
                    if let Some(status) = try_run_builtin_in_subprocess(sh, cl, idx_cmd, capture) {
                        process::exit(status);
                    }
                }

                // our strings do not have '\x00' bytes in them,
                // we can use CString::new().expect() safely.
                let mut c_envs: Vec<_> = env::vars()
                    .map(|(k, v)| {
                        CString::new(format!("{}={}", k, v).as_str()).expect("CString error")
                    })
                    .collect();
                for (key, value) in cl.envs.iter() {
                    c_envs.push(
                        CString::new(format!("{}={}", key, value).as_str()).expect("CString error"),
                    );
                }

                let program = &cmd.tokens[0].1;
                let path = if program.contains('/') {
                    program.clone()
                } else {
                    libs::path::find_file_in_path(program, true)
                };
                if path.is_empty() {
                    println_stderr!("cicada: {}: command not found", program);
                    process::exit(127);
                }

                let c_program = CString::new(path.as_str()).expect("CString::new failed");
                let c_args: Vec<_> = cmd
                    .tokens
                    .iter()
                    .map(|x| CString::new(x.1.as_str()).expect("CString error"))
                    .collect();

                let c_args: Vec<&CStr> = c_args.iter().map(|x| x.as_c_str()).collect();
                let c_envs: Vec<&CStr> = c_envs.iter().map(|x| x.as_c_str()).collect();
                match execve(&c_program, &c_args, &c_envs) {
                    Ok(_) => {}
                    Err(e) => match e {
                        nix::Error::ENOEXEC => {
                            println_stderr!("cicada: {}: exec format error (ENOEXEC)", program);
                        }
                        nix::Error::ENOENT => {
                            println_stderr!("cicada: {}: file does not exist", program);
                        }
                        nix::Error::EACCES => {
                            println_stderr!("cicada: {}: Permission denied", program);
                        }
                        _ => {
                            println_stderr!("cicada: {}: {:?}", program, e);
                        }
                    },
                }

                process::exit(1);
            }
            Ok(ForkResult::Parent { child, .. }) => {
                let pid: i32 = child.into();
                if idx_cmd == 0 {
                    *pgid = pid;
                    unsafe {
                        // we need to wait pgid of child set to itself,
                        // before give terminal to it (for macos).
                        // 1. this loop causes `bash`, `htop` etc to go `T` status
                        //    immediate after start on linux (ubuntu).
                        // 2. but on mac, we need this loop, otherwise commands
                        //    like `vim` will go to `T` status after start.
                        if cfg!(target_os = "macos") {
                            loop {
                                let _pgid = libc::getpgid(pid);
                                if _pgid == pid {
                                    break;
                                }
                            }
                        }

                        if sh.has_terminal
                            && options.isatty
                            && !cl.background
                        {
                            *term_given = shell::give_terminal_to(pid);
                        }
                    }
                }

                if options.isatty && !options.capture_output {
                    let _cmd = parsers::parser_line::tokens_to_line(&cmd.tokens);
                    sh.insert_job(*pgid, pid, &_cmd, "Running", cl.background);
                }

                if let Some(redirect_from) = &cmd.redirect_from {
                    if redirect_from.0 == "<<<" {
                        if let Some(fds) = fds_stdin {
                            unsafe {
                                libs::close(fds.0);

                                let mut f = File::from_raw_fd(fds.1);
                                match f.write_all(redirect_from.1.clone().as_bytes()) {
                                    Ok(_) => {}
                                    Err(e) => println_stderr!("cicada: write_all: {}", e),
                                }
                                match f.write_all(b"\n") {
                                    Ok(_) => {}
                                    Err(e) => println_stderr!("cicada: write_all: {}", e),
                                }
                            }
                        }
                    }
                }

                // (in parent) close unused pipe ends
                if idx_cmd < pipes_count {
                    let fds = pipes[idx_cmd];
                    libs::close(fds.1);
                }
                if idx_cmd > 0 {
                    // close pipe end only after dupped in the child
                    let fds = pipes[idx_cmd - 1];
                    libs::close(fds.0);
                }

                if idx_cmd == pipes_count && options.capture_output {
                    let mut s_out = String::new();
                    let mut s_err = String::new();

                    unsafe {
                        if let Some(fds) = fds_capture_stdout {
                            libs::close(fds.1);

                            let mut f = File::from_raw_fd(fds.0);
                            match f.read_to_string(&mut s_out) {
                                Ok(_) => {}
                                Err(e) => println_stderr!("cicada: readstr: {}", e),
                            }
                        }
                        if let Some(fds) = fds_capture_stderr {
                            libs::close(fds.1);
                            let mut f_err = File::from_raw_fd(fds.0);
                            match f_err.read_to_string(&mut s_err) {
                                Ok(_) => {}
                                Err(e) => println_stderr!("cicada: readstr: {}", e),
                            }
                        }
                    }

                    *cmd_result = CommandResult {
                        gid: *pgid,
                        status: 0,
                        stdout: s_out.clone(),
                        stderr: s_err.clone(),
                    };
                }

                pid
            }

            Err(_) => {
                println_stderr!("Fork failed");
                *cmd_result = CommandResult::error();
                0
            }
        }
    }

    fn try_run_func(
        sh: &mut Shell,
        cl: &CommandLine,
        capture: bool,
        log_cmd: bool,
    ) -> Option<CommandResult> {
        if cl.is_empty() {
            return None;
        }

        let command = &cl.commands[0];
        if let Some(func_body) = sh.get_func(&command.tokens[0].1) {
            let mut args = vec!["cicada".to_string()];
            for token in &command.tokens {
                args.push(token.1.to_string());
            }
            if log_cmd {
                log!("run func: {:?}", &args);
            }
            let cr_list = scripting::run_lines(sh, &func_body, &args, capture);
            let mut stdout = String::new();
            let mut stderr = String::new();
            for cr in cr_list {
                stdout.push_str(cr.stdout.trim());
                stdout.push(' ');
                stderr.push_str(cr.stderr.trim());
                stderr.push(' ');
            }
            let mut cr = CommandResult::new();
            cr.stdout = stdout;
            cr.stderr = stderr;
            return Some(cr);
        }
        None
    }

    fn try_run_calculator(line: &str, capture: bool) -> Option<CommandResult> {
        if tools::is_arithmetic(line) {
            match run_calculator(line) {
                Ok(result) => {
                    let mut cr = CommandResult::new();
                    if capture {
                        cr.stdout = result.clone();
                    } else {
                        println!("{}", result);
                    }
                    return Some(cr);
                }
                Err(e) => {
                    let mut cr = CommandResult::from_status(0, 1);
                    if capture {
                        cr.stderr = e.to_string();
                    } else {
                        println_stderr!("cicada: calculator: {}", e);
                    }
                    return Some(cr);
                }
            }
        }
        None
    }

    pub fn run_calculator(line: &str) -> Result<String, &str> {
        let parse_result = calculator::calculate(line);
        match parse_result {
            Ok(mut calc) => {
                let expr = calc.next().unwrap().into_inner();

                if line.contains('.') {
                    Ok(format!("{}", calculator::eval_float(expr)))
                } else {
                    Ok(format!("{}", calculator::eval_int(expr)))
                }
            }
            Err(_) => {
                Err("syntax error")
            }
        }
    }
}

pub mod ctime
{
    use ::
    {
        *,
    };
    use std::fmt;
    use time::OffsetDateTime;

    #[derive(Debug, PartialEq, Eq)]
    pub struct DateTime {
        odt: OffsetDateTime,
    }

    impl DateTime {
        pub fn now() -> Self {
            let odt: OffsetDateTime = match OffsetDateTime::now_local() {
                Ok(dt) => dt,
                Err(_) => OffsetDateTime::now_utc(),
            };
            DateTime { odt }
        }

        pub fn from_timestamp(ts: f64) -> Self {
            let dummy_now = Self::now();
            let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
            let ts_nano = (ts + offset_seconds as f64) * 1000000000.0;
            let odt: OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos(ts_nano as i128) {
                Ok(x) => x,
                Err(_) => OffsetDateTime::now_utc(),
            };
            DateTime { odt }
        }

        pub fn unix_timestamp(&self) -> f64 {
            self.odt.unix_timestamp_nanos() as f64 / 1000000000.0
        }
    }

    impl fmt::Display for DateTime {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                self.odt.year(),
                self.odt.month() as u8,
                self.odt.day(),
                self.odt.hour(),
                self.odt.minute(),
                self.odt.second(),
                self.odt.millisecond(),
            )
        }
    }
}

pub mod execute
{
    use ::
    {
        *,
    };
    use std::collections::HashMap;
    use std::io::{self, Read, Write};

    use regex::Regex;

    use crate::core;
    use crate::libs;
    use crate::parsers;
    use crate::shell::{self, Shell};
    use crate::types::{CommandLine, CommandResult, Tokens};
    /// Entry point for non-ttys (e.g. Cmd-N on MacVim)
    pub fn run_procs_for_non_tty(sh: &mut Shell) {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();
        match handle.read_to_string(&mut buffer) {
            Ok(_) => {
                log!("run non tty command: {}", &buffer);
                run_command_line(sh, &buffer, false, false);
            }
            Err(e) => {
                println!("cicada: stdin.read_to_string() failed: {:?}", e);
            }
        }
    }

    pub fn run_command_line(sh: &mut Shell, line: &str, tty: bool,
                            capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();
        for token in parsers::parser_line::line_to_cmds(line) {
            if token == ";" || token == "&&" || token == "||" {
                sep = token.clone();
                continue;
            }
            if sep == "&&" && status != 0 {
                break;
            }
            if sep == "||" && status == 0 {
                break;
            }
            let cmd = token.clone();
            let cr = run_proc(sh, &cmd, tty, capture);
            status = cr.status;
            sh.previous_status = status;
            cr_list.push(cr);
        }
        cr_list
    }

    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String> {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let ptn_env_exp = r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$";
        let re = Regex::new(ptn_env_exp).unwrap();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !libs::re::re_contains(text, ptn_env_exp) {
                break;
            }

            for cap in re.captures_iter(text) {
                let name = cap[1].to_string();
                let value = parsers::parser_line::unquote(&cap[2]);
                envs.insert(name, value);
            }

            n += 1;
        }
        if n > 0 {
            tokens.drain(0..n);
        }
        envs
    }

    fn line_to_tokens(sh: &mut Shell, line: &str) -> (Tokens, HashMap<String, String>) {
        let linfo = parsers::parser_line::parse_line(line);
        let mut tokens = linfo.tokens;
        shell::do_expansion(sh, &mut tokens);
        let envs = drain_env_tokens(&mut tokens);
        (tokens, envs)
    }

    fn set_shell_vars(sh: &mut Shell, envs: &HashMap<String, String>) {
        for (name, value) in envs.iter() {
            sh.set_env(name, value);
        }
    }
    /// Run simple command or pipeline without using `&&`, `||`, `;`.
    /// example 1: `ls`
    /// example 2: `ls | wc`
    fn run_proc(sh: &mut Shell, line: &str, tty: bool,
                capture: bool) -> CommandResult {
        let log_cmd = !sh.cmd.starts_with(' ');
        match CommandLine::from_line(line, sh) {
            Ok(cl) => {
                if cl.is_empty() {
                    // for commands with only envs, e.g.
                    // $ FOO=1 BAR=2
                    // we need to define these **Shell Variables**.
                    if !cl.envs.is_empty() {
                        set_shell_vars(sh, &cl.envs);
                    }
                    return CommandResult::new();
                }

                let (term_given, cr) = core::run_pipeline(sh, &cl, tty, capture, log_cmd);
                if term_given {
                    unsafe {
                        let gid = libc::getpgid(0);
                        shell::give_terminal_to(gid);
                    }
                }

                cr
            }
            Err(e) => {
                println_stderr!("cicada: {}", e);
                CommandResult::from_status(0, 1)
            }
        }
    }

    fn run_with_shell(sh: &mut Shell, line: &str) -> CommandResult {
        let (tokens, envs) = line_to_tokens(sh, line);
        if tokens.is_empty() {
            set_shell_vars(sh, &envs);
            return CommandResult::new();
        }

        match CommandLine::from_line(line, sh) {
            Ok(c) => {
                let (term_given, cr) = core::run_pipeline(sh, &c, false, true, false);
                if term_given {
                    unsafe {
                        let gid = libc::getpgid(0);
                        shell::give_terminal_to(gid);
                    }
                }

                cr
            }
            Err(e) => {
                println_stderr!("cicada: {}", e);
                CommandResult::from_status(0, 1)
            }
        }
    }

    pub fn run(line: &str) -> CommandResult {
        let mut sh = Shell::new();
        run_with_shell(&mut sh, line)
    }

    #[cfg(test)]
    mod tests {
        use super::core::run_calculator;
        use super::run_with_shell;
        use super::shell;
        use super::libs;

        #[test]
        fn test_run_calculator() {
            assert_eq!(
                run_calculator("(1 + 2 * 3.0 - 1.5) / 0.2"),
                Ok("27.5".to_string())
            );
            assert_eq!(
                run_calculator("(5 + 2 * 3 - 4) / 3"),
                Ok("2".to_string())
            );
            assert_eq!(
                run_calculator("((2 ^ 35) + (3^7) - 9740555) / 10000000"),
                Ok("3435".to_string())
            );
        }

        #[test]
        fn test_run_itself() {
            use std::fs::File;
            use std::io::BufRead;
            use std::io::BufReader;

            let f = File::open("./tests/run_procs.txt").expect("file not found");
            let file = BufReader::new(&f);
            let mut input = String::new();
            let mut expected_stdout = String::new();
            let mut sh = shell::Shell::new();
            for (num, l) in file.lines().enumerate() {
                let line = l.unwrap();
                match num % 3 {
                    0 => {
                        input = line.clone();
                    }
                    1 => {
                        expected_stdout = line.clone();
                    }
                    2 => match run_with_shell(&mut sh, &input) {
                        cr => {
                            let ptn = if expected_stdout.is_empty() {
                                r"^$"
                            } else {
                                expected_stdout.as_str()
                            };
                            let matched = libs::re::re_contains(&cr.stdout.trim(), &ptn);
                            if !matched {
                                println!("\nSTDOUT Check Failed:");
                                println!("input: {}", &input);
                                println!("stdout: {:?}", &cr.stdout.trim());
                                println!("expected: {:?}", &expected_stdout);
                                println!("line number: {}\n", num);
                            }
                            assert!(matched);

                            let ptn = if line.is_empty() {
                                r"^$"
                            } else {
                                line.as_str()
                            };
                            let matched = libs::re::re_contains(&cr.stderr.trim(), &ptn);
                            if !matched {
                                println!("\nSTDERR Check Failed:");
                                println!("input: {}", &input);
                                println!("stderr: {:?}", &cr.stderr);
                                println!("expected: {}", &ptn);
                                println!("line number: {}\n", num + 1);
                            }
                            assert!(matched);
                        }
                    },
                    _ => {
                        assert!(false);
                    }
                }
            }
        }
    }
}

pub mod history
{
    use ::
    {
        *,
    };
    use std::collections::HashMap;
    use std::env;
    use std::fs;
    use std::io::Write;
    use std::path::Path;

    use lineread::terminal::DefaultTerminal;
    use lineread::Interface;
    use rusqlite::Connection as Conn;
    use rusqlite::Error::SqliteFailure;

    use crate::shell;
    use crate::tools;

    fn init_db(hfile: &str, htable: &str) {
        let path = Path::new(hfile);
        if !path.exists() {
            let _parent = match path.parent() {
                Some(x) => x,
                None => {
                    println_stderr!("cicada: history init - no parent found");
                    return;
                }
            };
            let parent = match _parent.to_str() {
                Some(x) => x,
                None => {
                    println_stderr!("cicada: parent to_str is None");
                    return;
                }
            };
            match fs::create_dir_all(parent) {
                Ok(_) => {}
                Err(e) => {
                    println_stderr!("cicada: histdir create error: {}", e);
                    return;
                }
            }
            match fs::File::create(hfile) {
                Ok(_) => {
                    println!("cicada: created history file: {}", hfile);
                }
                Err(e) => {
                    println_stderr!("cicada: history: file create failed: {}", e);
                }
            }
        }

        let conn = match Conn::open(hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: open db error: {}", e);
                return;
            }
        };
        let sql = format!(
            "
            CREATE TABLE IF NOT EXISTS {}
                (inp TEXT,
                rtn INTEGER,
                tsb REAL,
                tse REAL,
                sessionid TEXT,
                out TEXT,
                info TEXT
                );
        ",
            htable
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => println_stderr!("cicada: history: query error: {}", e),
        }
    }

    pub fn init(rl: &mut Interface<DefaultTerminal>) {
        let mut hist_size: usize = 99999;
        if let Ok(x) = env::var("HISTORY_SIZE") {
            if let Ok(y) = x.parse::<usize>() {
                hist_size = y;
            }
        }
        rl.set_history_size(hist_size);

        let history_table = get_history_table();
        let hfile = get_history_file();

        if !Path::new(&hfile).exists() {
            init_db(&hfile, &history_table);
        }

        let mut delete_dups = true;
        if let Ok(x) = env::var("HISTORY_DELETE_DUPS") {
            if x == "0" {
                delete_dups = false;
            }
        }
        if delete_dups {
            delete_duplicated_histories();
        }

        let conn = match Conn::open(&hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };
        let sql = format!("SELECT inp FROM {} ORDER BY tsb;", history_table);
        let mut stmt = match conn.prepare(&sql) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: prepare select error: {}", e);
                return;
            }
        };

        let rows = match stmt.query_map([], |row| row.get(0)) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: query select error: {}", e);
                return;
            }
        };

        let mut dict_helper: HashMap<String, bool> = HashMap::new();
        for x in rows.flatten() {
            let inp: String = x;
            if dict_helper.contains_key(&inp) {
                continue;
            }
            dict_helper.insert(inp.clone(), true);
            rl.add_history(inp.trim().to_string());
        }
    }

    pub fn get_history_file() -> String {
        if let Ok(hfile) = env::var("HISTORY_FILE") {
            hfile
        } else if let Ok(d) = env::var("XDG_DATA_HOME") {
            format!("{}/{}", d, "cicada/history.sqlite")
        } else {
            let home = tools::get_user_home();
            format!("{}/{}", home, ".local/share/cicada/history.sqlite")
        }
    }

    pub fn get_history_table() -> String {
        if let Ok(hfile) = env::var("HISTORY_TABLE") {
            hfile
        } else {
            String::from("cicada_history")
        }
    }

    fn delete_duplicated_histories() {
        let hfile = get_history_file();
        let history_table = get_history_table();
        let conn = match Conn::open(&hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };
        let sql = format!(
            "DELETE FROM {} WHERE rowid NOT IN (
            SELECT MAX(rowid) FROM {} GROUP BY inp)",
            history_table, history_table
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => match e {
                SqliteFailure(ee, msg) => {
                    if ee.extended_code == 5 {
                        log!(
                            "failed to delete dup histories: {}",
                            msg.unwrap_or("db is locked?".to_owned()),
                        );
                        return;
                    }
                    println_stderr!(
                        "cicada: history: delete dups error: {}: {:?}",
                        &ee,
                        &msg
                    );
                }
                _ => {
                    println_stderr!("cicada: history: delete dup error: {}", e);
                }
            },
        }
    }

    pub fn add_raw(sh: &shell::Shell, line: &str, status: i32,
                tsb: f64, tse: f64) {
        let hfile = get_history_file();
        let history_table = get_history_table();
        if !Path::new(&hfile).exists() {
            init_db(&hfile, &history_table);
        }

        let conn = match Conn::open(&hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };
        let sql = format!(
            "INSERT INTO \
            {} (inp, rtn, tsb, tse, sessionid, info) \
            VALUES('{}', {}, {}, {}, '{}', 'dir:{}|');",
            history_table,
            str::replace(line.trim(), "'", "''"),
            status,
            tsb,
            tse,
            sh.session_id,
            sh.current_dir,
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => println_stderr!("cicada: history: save error: {}", e),
        }
    }

    pub fn add(sh: &shell::Shell, rl: &mut Interface<DefaultTerminal>, line: &str,
            status: i32, tsb: f64, tse: f64) {
        add_raw(sh, line, status, tsb, tse);
        rl.add_history(line.to_string());
    }
}

pub mod highlight
{
    use ::
    {
        *,
    };
    use std::ops::Range;
    use std::sync::Arc;
    use std::collections::HashSet;
    use std::path::Path;
    use std::env;
    use std::fs;
    use std::sync::Mutex;
    use std::os::unix::fs::PermissionsExt;

    use lineread::highlighting::{Highlighter, Style};

    use crate::tools;
    use crate::shell;
    use crate::parsers::parser_line;

    #[derive(Clone)]
    pub struct CicadaHighlighter;

    // ANSI color codes wrapped with \x01 and \x02 for lineread
    const GREEN: &str = "\x01\x1b[0;32m\x02";

    lazy_static! {
        static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
        static ref ALIASES: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
    }
    /// Initialize the available commands cache by scanning PATH directories
    pub fn init_command_cache() {
        let commands = scan_available_commands();
        if let Ok(mut cache) = AVAILABLE_COMMANDS.lock() {
            *cache = commands;
        }
    }
    /// Update aliases in the highlighter's cache
    pub fn update_aliases(sh: &shell::Shell) {
        if let Ok(mut aliases) = ALIASES.lock() {
            aliases.clear();
            for alias_name in sh.aliases.keys() {
                aliases.insert(alias_name.clone());
            }
        }
    }

    fn scan_available_commands() -> HashSet<String> {
        let mut commands = HashSet::new();

        if let Ok(path_var) = env::var("PATH") {
            for path in path_var.split(':') {
                if path.is_empty() {
                    continue;
                }

                let dir_path = Path::new(path);
                if !dir_path.is_dir() {
                    continue;
                }

                if let Ok(entries) = fs::read_dir(dir_path) {
                    for entry in entries.filter_map(Result::ok) {
                        if let Ok(file_type) = entry.file_type() {
                            if file_type.is_file() || file_type.is_symlink() {
                                if let Ok(metadata) = entry.metadata() {
                                    // Check if file is executable
                                    if metadata.permissions().mode() & 0o111 != 0 {
                                        if let Some(name) = entry.file_name().to_str() {
                                            commands.insert(name.to_string());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        commands
    }

    fn is_command(word: &str) -> bool {
        if tools::is_builtin(word) {
            return true;
        }
        if let Ok(aliases) = ALIASES.lock() {
            if aliases.contains(word) {
                return true;
            }
        }
        if let Ok(commands) = AVAILABLE_COMMANDS.lock() {
            if commands.contains(word) {
                return true;
            }
        }
        false
    }

    fn find_token_range_heuristic(line: &str, start_byte: usize, token: &(String, String)) -> Option<Range<usize>> {
        let (sep, word) = token;

        // Find the start of the token, skipping leading whitespace from the search start position
        let mut search_area = &line[start_byte..];
        let token_start_byte = if let Some(non_ws_offset) = search_area.find(|c: char| !c.is_whitespace()) {
            // Calculate the actual byte index of the first non-whitespace character
            start_byte + search_area.char_indices().nth(non_ws_offset).map_or(0, |(idx, _)| idx)
        } else {
            return None; // Only whitespace left
        };

        search_area = &line[token_start_byte..];

        // Estimate the end byte based on the token structure
        let mut estimated_len = 0;
        let mut current_search_offset = 0;

        // Match separator prefix if needed (e.g., `"` or `'`)
        if !sep.is_empty() && search_area.starts_with(sep) {
            estimated_len += sep.len();
            current_search_offset += sep.len();
        }

        // Match the word content
        // Use starts_with for a basic check, assuming the word appears next
        if search_area[current_search_offset..].starts_with(word) {
            estimated_len += word.len();
            current_search_offset += word.len();

            // Match separator suffix if needed
            if !sep.is_empty() && search_area[current_search_offset..].starts_with(sep) {
                estimated_len += sep.len();
            }

            Some(token_start_byte..(token_start_byte + estimated_len))

        } else if word.is_empty() && !sep.is_empty() && search_area.starts_with(sep) && search_area[sep.len()..].starts_with(sep) {
            // Handle empty quoted string like "" or ''
            estimated_len += sep.len() * 2;
            Some(token_start_byte..(token_start_byte + estimated_len))
        }
        else {
            // Fallback: Maybe it's just the word without quotes, or a separator like `|`
            if search_area.starts_with(word) {
                Some(token_start_byte..(token_start_byte + word.len()))
            } else {
                // Could not reliably map the token back to the original string segment
                // This might happen with complex escapes or parser ambiguities
                // As a basic fallback, consume up to the next space or end of line? Unsafe.
                // Return None to signal failure for this token.
                None
            }
        }
    }

    impl Highlighter for CicadaHighlighter {
        fn highlight(&self, line: &str) -> Vec<(Range<usize>, Style)> {
            let mut styles = Vec::new();
            if line.is_empty() {
                return styles;
            }

            let line_info = parser_line::parse_line(line);
            if line_info.tokens.is_empty() {
                // If parser returns no tokens, style whole line as default
                styles.push((0..line.len(), Style::Default));
                return styles;
            }

            let mut current_byte_idx = 0;
            let mut is_start_of_segment = true;

            for token in &line_info.tokens {
                // Find the range in the original line for this token
                match find_token_range_heuristic(line, current_byte_idx, token) {
                    Some(token_range) => {
                        // Style potential whitespace before the token
                        if token_range.start > current_byte_idx {
                            styles.push((current_byte_idx..token_range.start, Style::Default));
                        }

                        let (_sep, word) = token;
                        let mut current_token_style = Style::Default;

                        if is_start_of_segment && !word.is_empty() {
                            if is_command(word) {
                                current_token_style = Style::AnsiColor(GREEN.to_string());
                            }
                            // Only the first non-empty token in a segment can be a command
                            is_start_of_segment = false;
                        }

                        styles.push((token_range.clone(), current_token_style));

                        // Check if this token marks the end of a command segment
                        if ["|", "&&", "||", ";"].contains(&word.as_str()) {
                            is_start_of_segment = true;
                        }

                        current_byte_idx = token_range.end;
                    }
                    None => {
                        // If we can't map a token, style the rest of the line as default and stop.
                        if current_byte_idx < line.len() {
                        styles.push((current_byte_idx..line.len(), Style::Default));
                        }
                        current_byte_idx = line.len(); // Mark as done
                        break; // Stop processing further tokens
                    }
                }
            }

            // Style any remaining characters after the last processed token
            if current_byte_idx < line.len() {
                styles.push((current_byte_idx..line.len(), Style::Default));
            }

            styles
        }
    }

    pub fn create_highlighter() -> Arc<CicadaHighlighter> {
        Arc::new(CicadaHighlighter)
    }
}

pub mod jobc
{
    use ::
    {
        *,
    };
    use std::io::Write;

    use nix::sys::signal::Signal;
    use nix::sys::wait::waitpid;
    use nix::sys::wait::WaitPidFlag as WF;
    use nix::sys::wait::WaitStatus as WS;
    use nix::unistd::Pid;

    use crate::shell;
    use crate::signals;
    use crate::types::{self, CommandResult};

    pub fn get_job_line(job: &types::Job, trim: bool) -> String {
        let mut cmd = job.cmd.clone();
        if trim && cmd.len() > 50 {
            cmd.truncate(50);
            cmd.push_str(" ...");
        }
        let _cmd = if job.is_bg && job.status == "Running" {
            format!("{} &", cmd)
        } else {
            cmd
        };
        format!("[{}] {}  {}   {}", job.id, job.gid, job.status, _cmd)
    }

    pub fn print_job(job: &types::Job) {
        let line = get_job_line(job, true);
        println_stderr!("{}", line);
    }

    pub fn mark_job_as_done(sh: &mut shell::Shell, gid: i32, pid: i32, reason: &str) {
        if let Some(mut job) = sh.remove_pid_from_job(gid, pid) {
            job.status = reason.to_string();
            if job.is_bg {
                println_stderr!("");
                print_job(&job);
            }
        }
    }

    pub fn mark_job_as_stopped(sh: &mut shell::Shell, gid: i32, report: bool) {
        sh.mark_job_as_stopped(gid);
        if !report {
            return;
        }

        // add an extra line to separate output of fg commands if any.
        if let Some(job) = sh.get_job_by_gid(gid) {
            println_stderr!("");
            print_job(job);
        }
    }

    pub fn mark_job_member_stopped(sh: &mut shell::Shell, pid: i32, gid: i32, report: bool) {
        let _gid = if gid == 0 {
            unsafe { libc::getpgid(pid) }
        } else {
            gid
        };

        if let Some(job) = sh.mark_job_member_stopped(pid, gid) {
            if job.all_members_stopped() {
                mark_job_as_stopped(sh, gid, report);
            }
        }
    }

    pub fn mark_job_member_continued(sh: &mut shell::Shell, pid: i32, gid: i32) {
        let _gid = if gid == 0 {
            unsafe { libc::getpgid(pid) }
        } else {
            gid
        };

        if let Some(job) = sh.mark_job_member_continued(pid, gid) {
            if job.all_members_running() {
                mark_job_as_running(sh, gid, true);
            }
        }
    }

    pub fn mark_job_as_running(sh: &mut shell::Shell, gid: i32, bg: bool) {
        sh.mark_job_as_running(gid, bg);
    }

    #[allow(unreachable_patterns)]
    pub fn waitpidx(wpid: i32, block: bool) -> types::WaitStatus {
        let options = if block {
            Some(WF::WUNTRACED | WF::WCONTINUED)
        } else {
            Some(WF::WUNTRACED | WF::WCONTINUED | WF::WNOHANG)
        };
        match waitpid(Pid::from_raw(wpid), options) {
            Ok(WS::Exited(pid, status)) => {
                let pid = i32::from(pid);
                types::WaitStatus::from_exited(pid, status)
            }
            Ok(WS::Stopped(pid, sig)) => {
                let pid = i32::from(pid);
                types::WaitStatus::from_stopped(pid, sig as i32)
            }
            Ok(WS::Continued(pid)) => {
                let pid = i32::from(pid);
                types::WaitStatus::from_continuted(pid)
            }
            Ok(WS::Signaled(pid, sig, _core_dumped)) => {
                let pid = i32::from(pid);
                types::WaitStatus::from_signaled(pid, sig as i32)
            }
            Ok(WS::StillAlive) => {
                types::WaitStatus::empty()
            }
            Ok(_others) => {
                // this is for PtraceEvent and PtraceSyscall on Linux,
                // unreachable on other platforms.
                types::WaitStatus::from_others()
            }
            Err(e) => {
                types::WaitStatus::from_error(e as i32)
            }
        }
    }

    pub fn wait_fg_job(sh: &mut shell::Shell, gid: i32, pids: &[i32]) -> CommandResult {
        let mut cmd_result = CommandResult::new();
        let mut count_waited = 0;
        let count_child = pids.len();
        if count_child == 0 {
            return cmd_result;
        }
        let pid_last = pids.last().unwrap();

        loop {
            let ws = waitpidx(-1, true);
            // here when we calling waitpidx(), all signals should have
            // been masked. There should no errors (ECHILD/EINTR etc) happen.
            if ws.is_error() {
                let err = ws.get_errno();
                if err == nix::Error::ECHILD {
                    break;
                }

                log!("jobc unexpected waitpid error: {}", err);
                cmd_result = CommandResult::from_status(gid, err as i32);
                break;
            }

            let pid = ws.get_pid();
            let is_a_fg_child = pids.contains(&pid);
            if is_a_fg_child && !ws.is_continued() {
                count_waited += 1;
            }

            if ws.is_exited() {
                if is_a_fg_child {
                    mark_job_as_done(sh, gid, pid, "Done");
                } else {
                    let status = ws.get_status();
                    signals::insert_reap_map(pid, status);
                }
            } else if ws.is_stopped() {
                if is_a_fg_child {
                    // for stop signal of fg job (current job)
                    // i.e. Ctrl-Z is pressed on the fg job
                    mark_job_member_stopped(sh, pid, gid, true);
                } else {
                    // for stop signal of bg jobs
                    signals::insert_stopped_map(pid);
                    mark_job_member_stopped(sh, pid, 0, false);
                }
            } else if ws.is_continued() {
                if !is_a_fg_child {
                    signals::insert_cont_map(pid);
                }
                continue;
            } else if ws.is_signaled() {
                if is_a_fg_child {
                    mark_job_as_done(sh, gid, pid, "Killed");
                } else {
                    signals::killed_map_insert(pid, ws.get_signal());
                }
            }

            if is_a_fg_child && pid == *pid_last {
                let status = ws.get_status();
                cmd_result.status = status;
            }

            if count_waited >= count_child {
                break;
            }
        }
        cmd_result
    }

    pub fn try_wait_bg_jobs(sh: &mut shell::Shell, report: bool, sig_handler_enabled: bool) {
        if sh.jobs.is_empty() {
            return;
        }

        if !sig_handler_enabled {
            // we need to wait pids in case CICADA_ENABLE_SIG_HANDLER=0
            signals::handle_sigchld(Signal::SIGCHLD as i32);
        }

        let jobs = sh.jobs.clone();
        for (_i, job) in jobs.iter() {
            for pid in job.pids.iter() {
                if let Some(_status) = signals::pop_reap_map(*pid) {
                    mark_job_as_done(sh, job.gid, *pid, "Done");
                    continue;
                }

                if let Some(sig) = signals::killed_map_pop(*pid) {
                    let reason = if sig == Signal::SIGQUIT as i32 {
                        format!("Quit: {}", sig)
                    } else if sig == Signal::SIGINT as i32 {
                        format!("Interrupt: {}", sig)
                    } else if sig == Signal::SIGKILL as i32 {
                        format!("Killed: {}", sig)
                    } else if sig == Signal::SIGTERM as i32 {
                        format!("Terminated: {}", sig)
                    } else {
                        format!("Killed: {}", sig)
                    };
                    mark_job_as_done(sh, job.gid, *pid, &reason);
                    continue;
                }

                if signals::pop_stopped_map(*pid) {
                    mark_job_member_stopped(sh, *pid, job.gid, report);
                } else if signals::pop_cont_map(*pid) {
                    mark_job_member_continued(sh, *pid, job.gid);
                }
            }
        }
    }
}

pub mod libs
{
    use ::
    {
        *,
    };

    pub mod colored
    {
        use ::
        {
            *,
        };
        // setting prompt in crate lineread needs wrap every SEQ chars
        // with prefixing with '\x01' and suffix with '\x02'.
        // Color Reference: https://misc.flogisoft.com/bash/tip_colors_and_formatting

        // cicada special
        pub const SEQ: &str = "\x01";
        pub const END_SEQ: &str = "\x02";
        pub const ESC: &str = "\x1B";

        // Set
        pub const BOLD: &str = "\x01\x1B[1m\x02";
        pub const DIM: &str = "\x01\x1B[2m\x02";
        pub const UNDERLINED: &str = "\x01\x1B[4m\x02";
        pub const BLINK: &str = "\x01\x1B[5m\x02";
        pub const REVERSE: &str = "\x01\x1B[7m\x02";
        pub const HIDDEN: &str = "\x01\x1B[8m\x02";

        // Reset
        pub const RESET: &str = "\x01\x1B[0m\x02";
        pub const RESET_BOLD: &str = "\x01\x1B[21m\x02";
        pub const RESET_DIM: &str = "\x01\x1B[22m\x02";
        pub const RESET_UNDERLINED: &str = "\x01\x1B[24m\x02";
        pub const RESET_BLINK: &str = "\x01\x1B[25m\x02";
        pub const RESET_REVERSE: &str = "\x01\x1B[27m\x02";
        pub const RESET_HIDDEN: &str = "\x01\x1B[28m\x02";

        // Foreground (text)
        pub const DEFAULT: &str = "\x01\x1B[39m\x02";
        pub const BLACK: &str = "\x01\x1B[30m\x02";
        pub const RED: &str = "\x01\x1B[31m\x02";
        pub const GREEN: &str = "\x01\x1B[32m\x02";
        pub const YELLOW: &str = "\x01\x1B[33m\x02";
        pub const BLUE: &str = "\x01\x1B[34m\x02";
        pub const MAGENTA: &str = "\x01\x1B[35m\x02";
        pub const CYAN: &str = "\x01\x1B[36m\x02";
        pub const GRAY_L: &str = "\x01\x1B[37m\x02";

        pub const GRAY_D: &str = "\x01\x1B[90m\x02";
        pub const RED_L: &str = "\x01\x1B[91m\x02";
        pub const GREEN_L: &str = "\x01\x1B[92m\x02";
        pub const YELLOW_L: &str = "\x01\x1B[93m\x02";
        pub const BLUE_L: &str = "\x01\x1B[94m\x02";
        pub const MAGENTA_L: &str = "\x01\x1B[95m\x02";
        pub const CYAN_L: &str = "\x01\x1B[96m\x02";
        pub const WHITE: &str = "\x01\x1B[97m\x02";

        pub const BLUE_B: &str = "\x01\x1B[34m\x1B[1m\x02";
        pub const BLACK_B: &str = "\x01\x1B[30m\x1B[1m\x02";
        pub const WHITE_B: &str = "\x01\x1B[97m\x1B[1m\x02";
        pub const RED_B: &str = "\x01\x1B[31m\x1B[1m\x02";
        pub const GREEN_B: &str = "\x01\x1B[32m\x1B[1m\x02";

        // Background
        pub const DEFAULT_BG: &str = "\x01\x1B[49m\x02";
        pub const BLACK_BG: &str   = "\x01\x1B[40m\x02";
        pub const RED_BG: &str     = "\x01\x1B[41m\x02";
        pub const GREEN_BG: &str   = "\x01\x1B[42m\x02";
        pub const YELLOW_BG: &str   = "\x01\x1B[43m\x02";
        pub const BLUE_BG: &str    = "\x01\x1B[44m\x02";
        pub const MAGENTA_BG: &str    = "\x01\x1B[45m\x02";
        pub const CYAN_BG: &str    = "\x01\x1B[46m\x02";
        pub const GRAY_L_BG: &str    = "\x01\x1B[47m\x02";

        pub const GRAY_D_BG: &str   = "\x01\x1B[100m\x02";
        pub const RED_L_BG: &str   = "\x01\x1B[101m\x02";
        pub const GREEN_L_BG: &str   = "\x01\x1B[102m\x02";
        pub const YELLOW_L_BG: &str   = "\x01\x1B[103m\x02";
        pub const BLUE_L_BG: &str   = "\x01\x1B[104m\x02";
        pub const MAGENTA_L_BG: &str   = "\x01\x1B[105m\x02";
        pub const CYAN_L_BG: &str   = "\x01\x1B[106m\x02";
        pub const WHITE_BG: &str   = "\x01\x1B[107m\x02";
    }

    pub mod fork
    {
        use ::
        {
            *,
        };
        use nix::Result;
        use nix::unistd::{fork as nix_fork, ForkResult};

        // make fork "safe again", in order not to touch the code in core.rs,
        // see https://github.com/nix-rust/nix/issues/586
        // we can have refactorings any time needed.
        pub fn fork() -> Result<ForkResult> {
            unsafe{ nix_fork() }
        }
    }

    pub mod os_type
    {
        use ::
        {
            *,
        };
        use crate::execute;

        pub fn get_os_name() -> String {
            let uname = get_uname();
            if uname.to_lowercase() == "darwin" {
                get_macos_name()
            } else {
                get_other_os_name()
            }
        }

        fn get_other_os_name() -> String {
            let mut name = get_release_value("PRETTY_NAME");
            if !name.is_empty() {
                return name;
            }
            name = get_release_value("DISTRIB_DESCRIPTION");
            if !name.is_empty() {
                return name;
            }
            name = get_release_value("IMAGE_DESCRIPTION");
            if !name.is_empty() {
                return name;
            }
            get_uname_mo()
        }

        fn get_release_value(ptn: &str) -> String {
            let line = format!(
                "grep -i '{}' /etc/*release* 2>&1 | grep -o '=.*' | tr '\"=' ' '",
                ptn
            );
            let cr = execute::run(&line);
            return cr.stdout.trim().to_string();
        }

        fn get_uname() -> String {
            let cr = execute::run("uname");
            return cr.stdout.trim().to_string();
        }

        fn get_uname_mo() -> String {
            let cr = execute::run("uname -m -o");
            return cr.stdout.trim().to_string();
        }

        fn get_macos_name() -> String {
            let mut os_name = get_osx_codename();
            let ver = get_osx_version();
            if !ver.is_empty() {
                os_name.push(' ');
                os_name.push_str(&ver);
            }
            os_name
        }

        fn get_osx_codename() -> String {
            let cr = execute::run("grep -o 'SOFTWARE LICENSE AGREEMENT FOR .*[a-zA-Z]' '/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf' | sed 's/SOFTWARE LICENSE AGREEMENT FOR *//'");
            return cr.stdout.trim().to_string();
        }

        fn get_osx_version() -> String {
            let cr = execute::run("sw_vers -productVersion");
            return cr.stdout.trim().to_string();
        }
    }

    pub mod path
    {
        use ::
        {
            *,
        };

        use std::borrow::Cow;
        use std::env;
        use std::fs::read_dir;
        use std::io::{ErrorKind, Write};
        use std::os::unix::fs::PermissionsExt;

        use regex::Regex;

        use crate::tools;

        pub fn basename(path: &str) -> Cow<'_, str> {
            let mut pieces = path.rsplit('/');
            match pieces.next() {
                Some(p) => p.into(),
                None => path.into(),
            }
        }

        pub fn expand_home(text: &str) -> String {
            let mut s: String = text.to_string();
            let v = vec![
                r"(?P<head> +)~(?P<tail> +)",
                r"(?P<head> +)~(?P<tail>/)",
                r"^(?P<head> *)~(?P<tail>/)",
                r"(?P<head> +)~(?P<tail> *$)",
            ];
            for item in &v {
                let re;
                if let Ok(x) = Regex::new(item) {
                    re = x;
                } else {
                    return String::new();
                }
                let home = tools::get_user_home();
                let ss = s.clone();
                let to = format!("$head{}$tail", home);
                let result = re.replace_all(ss.as_str(), to.as_str());
                s = result.to_string();
            }
            s
        }

        pub fn find_file_in_path(filename: &str, exec: bool) -> String {
            let env_path = match env::var("PATH") {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: error with env PATH: {:?}", e);
                    return String::new();
                }
            };
            let vec_path: Vec<&str> = env_path.split(':').collect();
            for p in &vec_path {
                match read_dir(p) {
                    Ok(list) => {
                        for entry in list.flatten() {
                            if let Ok(name) = entry.file_name().into_string() {
                                if name != filename {
                                    continue;
                                }

                                if exec {
                                    let _mode = match entry.metadata() {
                                        Ok(x) => x,
                                        Err(e) => {
                                            println_stderr!("cicada: metadata error: {:?}", e);
                                            continue;
                                        }
                                    };
                                    let mode = _mode.permissions().mode();
                                    if mode & 0o111 == 0 {
                                        // not binary
                                        continue;
                                    }
                                }

                                return entry.path().to_string_lossy().to_string();
                            }
                        }
                    }
                    Err(e) => {
                        if e.kind() == ErrorKind::NotFound {
                            continue;
                        }
                        log!("cicada: fs read_dir error: {}: {}", p, e);
                    }
                }
            }
            String::new()
        }

        pub fn current_dir() -> String {
            let _current_dir = match env::current_dir() {
                Ok(x) => x,
                Err(e) => {
                    log!("cicada: PROMPT: env current_dir error: {}", e);
                    return String::new();
                }
            };
            let current_dir = match _current_dir.to_str() {
                Some(x) => x,
                None => {
                    log!("cicada: PROMPT: to_str error");
                    return String::new();
                }
            };

            current_dir.to_string()
        }
    }

    pub mod re
    {
        use ::
        {
            *,
        };
        use regex;

        pub fn find_first_group(ptn: &str, text: &str) -> Option<String> {
            let re = match regex::Regex::new(ptn) {
                Ok(x) => x,
                Err(_) => return None,
            };
            match re.captures(text) {
                Some(caps) => {
                    if let Some(x) = caps.get(1) {
                        return Some(x.as_str().to_owned());
                    }
                }
                None => {
                    return None;
                }
            }
            None
        }

        pub fn re_contains(text: &str, ptn: &str) -> bool {
            let re = match regex::Regex::new(ptn) {
                Ok(x) => x,
                Err(e) => {
                    println!("Regex new error: {:?}", e);
                    return false;
                }
            };
            re.is_match(text)
        }

        pub fn replace_all(text: &str, ptn: &str, ptn_to: &str) -> String {
            let re = regex::Regex::new(ptn).unwrap();
            let result = re.replace_all(text, ptn_to);
            result.to_string()
        }

        #[cfg(test)]
        mod tests {
            use super::find_first_group;

            #[test]
            fn test_find_first_group() {
                let s = find_first_group(r"", "");
                assert_eq!(s, None);

                let s = find_first_group(r"abc", "123");
                assert_eq!(s, None);

                let s = find_first_group(r"\$\((.+)\)", "ls -l $(find x) -h");
                assert_eq!(s, Some("find x".to_string()));

                let s = find_first_group(r"(\d+)-(\d+)-(\d+)", "2017-09-16");
                assert_eq!(s, Some("2017".to_string()));
            }
        }
    }

    pub mod term_size
    {
        use ::
        {
            *,
        };
        // via: https://github.com/clap-rs/term_size-rs/blob/644f28c3a8811e56edcf42036b5e754dbb24a0d7/src/platform/unix.rs
        use libc::{c_int, c_ulong, winsize, STDERR_FILENO, STDIN_FILENO, STDOUT_FILENO};
        use std::mem::zeroed;

        // Unfortunately the actual command is not standardised...
        #[cfg(any(target_os = "linux", target_os = "android"))]
        static TIOCGWINSZ: c_ulong = 0x5413;

        #[cfg(any(
            target_os = "macos",
            target_os = "ios",
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
        ))]
        static TIOCGWINSZ: c_ulong = 0x40087468;

        #[cfg(target_os = "solaris")]
        static TIOCGWINSZ: c_ulong = 0x5468;

        extern "C" {
            fn ioctl(fd: c_int, request: c_ulong, ...) -> c_int;
        }
        /// Runs the ioctl command. Returns (0, 0) if all of the streams are not to a terminal, or
        /// there is an error. (0, 0) is an invalid size to have anyway, which is why
        /// it can be used as a nil value.
        unsafe fn get_dimensions_any() -> winsize {
            let mut window: winsize = zeroed();
            let mut result = ioctl(STDOUT_FILENO, TIOCGWINSZ, &mut window);

            if result == -1 {
                window = zeroed();
                result = ioctl(STDIN_FILENO, TIOCGWINSZ, &mut window);
                if result == -1 {
                    window = zeroed();
                    result = ioctl(STDERR_FILENO, TIOCGWINSZ, &mut window);
                    if result == -1 {
                        return zeroed();
                    }
                }
            }
            window
        }
        /// Query the current processes's output (`stdout`), input (`stdin`), and error (`stderr`) in that order, 
        ///in the attempt to dtermine terminal width.
        pub fn dimensions() -> Option<(usize, usize)> {
            let w = unsafe { get_dimensions_any() };

            if w.ws_col == 0 || w.ws_row == 0 {
                None
            } else {
                Some((w.ws_col as usize, w.ws_row as usize))
            }
        }
    }

    pub mod progopts
    {
        use ::
        {
            *,
        };
        pub fn is_login(args: &[String]) -> bool 
        {
            if !args.is_empty() && args[0].starts_with("-") {
                return true;
            }

            if args.len() > 1 && (args[1] == "--login" || args[1] == "-l") {
                return true;
            }

            if let Ok(term_program) = std::env::var("TERM_PROGRAM") {
                if term_program == "vscode" {
                    return true;
                }
            }

            false
        }

        pub fn is_script(args: &[String]) -> bool {
            args.len() > 1 && !args[1].starts_with("-")
        }

        pub fn is_command_string(args: &[String]) -> bool {
            args.len() > 1 && args[1] == "-c"
        }

        pub fn is_non_tty() -> bool {
            unsafe { libc::isatty(0) == 0 }
        }
    }

    pub mod pipes
    {
        use ::
        {
            *,
        };
        // via: nix v0.26.4. We do not want to use OwnedFd in newer version nix.
        use std::os::fd::RawFd;
        use nix::Error;
        use std::mem;
        use libc::c_int;

        pub fn pipe() -> std::result::Result<(RawFd, RawFd), Error> {
            let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
            let res = unsafe { libc::pipe(fds.as_mut_ptr() as *mut c_int) };
            Error::result(res)?;
            unsafe { Ok((fds.assume_init()[0], fds.assume_init()[1])) }
        }
    }
    
    pub fn close(fd: i32) {
        unsafe { libc::close(fd); }
    }

    pub fn dup(fd: i32) -> i32 {
        unsafe { libc::dup(fd) }
    }

    pub fn dup2(src: i32, dst: i32) {
        unsafe { libc::dup2(src, dst); }
    }
}

pub mod parsers
{
    use ::
    {
        *,
    };

    pub mod parser_line
    {
        /*
        WHITESPACE = _{ " " | "\t" }

        KW_IF = _{ "if " }
        KW_FI = _{ "fi" ~ (NEWLINE | EOI) }
        KW_FOR = _{ "for " }
        KW_ELSE = { "else" ~ NEWLINE }
        KW_ELSEIF = _{ "else if " }
        KW_WHILE = _{ "while " }
        KW_DONE = _{ "done" ~ (NEWLINE | EOI) }
        KW_LIST = _{ KW_IF | KW_FOR | KW_ELSEIF | KW_ELSE | KW_FI | KW_WHILE | KW_DONE }

        DUMMY_DO = _{ ";" ~ "do" ~ NEWLINE }
        DUMMY_THEN = _{ ";" ~ "then" ~ NEWLINE }

        TEST = {(!(NEWLINE|DUMMY_THEN|DUMMY_DO) ~ ANY)+}

        CMD_END = _{ !KW_LIST ~ (!NEWLINE ~ ANY)+ ~ EOI}
        CMD_NORMAL = _{ !KW_LIST ~ (!NEWLINE ~ ANY)* ~ NEWLINE}
        CMD = { CMD_NORMAL | CMD_END }

        IF_HEAD = { KW_IF ~ TEST ~ (DUMMY_THEN|NEWLINE) }
        EXP_BODY = { (CMD | EXP_IF | EXP_WHILE | EXP_FOR)+ }
        IF_ELSEIF_HEAD = { KW_ELSEIF ~ TEST ~ (DUMMY_THEN|NEWLINE) }
        IF_IF_BR = { IF_HEAD ~ EXP_BODY }
        IF_ELSEIF_BR = { IF_ELSEIF_HEAD ~ EXP_BODY }
        IF_ELSE_BR = { KW_ELSE ~ EXP_BODY }

        EXP_IF = {
            (SOI)? ~
            IF_IF_BR ~
            IF_ELSEIF_BR* ~
            IF_ELSE_BR? ~
            KW_FI
        }

        FOR_VAR = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
        FOR_INIT = { FOR_VAR ~ "in" ~ TEST ~ (DUMMY_DO|NEWLINE) }
        FOR_HEAD = { KW_FOR ~ FOR_INIT }

        EXP_FOR = {
            (SOI)? ~
            FOR_HEAD ~
                EXP_BODY ~
            KW_DONE
        }

        WHILE_HEAD = { KW_WHILE ~ TEST ~ (DUMMY_DO|NEWLINE) }

        EXP_WHILE = {
            (SOI)? ~
            WHILE_HEAD ~
                EXP_BODY ~
            KW_DONE
        }

        EXP = { (EXP_IF | EXP_FOR | EXP_WHILE | CMD)* }
        */
        use ::
        {
            *,
        };
        use regex::Regex;

        use crate::libs;
        use crate::tools;
        use crate::types::{LineInfo, Redirection, Tokens};

        pub fn line_to_plain_tokens(line: &str) -> Vec<String> {
            let mut result = Vec::new();
            let linfo = parse_line(line);
            for (_, r) in linfo.tokens {
                result.push(r.clone());
            }
            result
        }

        pub fn tokens_to_args(tokens: &Tokens) -> Vec<String> {
            let mut result = Vec::new();
            for s in tokens {
                result.push(s.1.clone());
            }
            result
        }

        pub fn tokens_to_line(tokens: &Tokens) -> String {
            let mut result = String::new();
            for t in tokens {
                if t.0.is_empty() {
                    result.push_str(&t.1);
                } else {
                    let s = tools::wrap_sep_string(&t.0, &t.1);
                    result.push_str(&s);
                }
                result.push(' ');
            }
            if result.ends_with(' ') {
                let len = result.len();
                result.truncate(len - 1);
            }
            result
        }
        /// Parse command line for multiple commands. Examples:
        /// >>> line_to_cmds("echo foo && echo bar; echo end");
        /// vec!["echo foo", "&&", "echo bar", ";", "echo end"]
        /// >>> line_to_cmds("man awk | grep version");
        /// vec!["man awk | grep version"]
        pub fn line_to_cmds(line: &str) -> Vec<String> {
            // Special characters: http://tldp.org/LDP/abs/html/special-chars.html
            let mut result = Vec::new();
            let mut sep = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let len = line.chars().count();
            for (i, c) in line.chars().enumerate() {
                if has_backslash {
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if c == '\\' && sep != "'" {
                    has_backslash = true;
                    continue;
                }

                if c == '#' {
                    if sep.is_empty() {
                        break;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '\'' || c == '"' || c == '`' {
                    if sep.is_empty() {
                        sep.push(c);
                        token.push(c);
                        continue;
                    } else if sep == c.to_string() {
                        token.push(c);
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '&' || c == '|' {
                    // needs watch ahead here
                    if sep.is_empty() {
                        if i + 1 == len {
                            // for bg commands, e.g. `ls &`
                            token.push(c);
                            continue;
                        } else {
                            let c_next = match line.chars().nth(i + 1) {
                                Some(x) => x,
                                None => {
                                    println!("chars nth error - should never happen");
                                    continue;
                                }
                            };

                            if c_next != c {
                                token.push(c);
                                continue;
                            }
                        }
                    }

                    if sep.is_empty() {
                        sep.push(c);
                        continue;
                    } else if c.to_string() == sep {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        token = String::new();
                        result.push(format!("{}{}", sep, sep));
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == ';' {
                    if sep.is_empty() {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        result.push(String::from(";"));
                        token = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                token.push(c);
            }
            if !token.is_empty() {
                result.push(token.trim().to_string());
            }
            result
        }
        /// parse command line to tokens
        /// >>> parse_line("echo 'hi yoo' | grep \"hi\"");
        /// LineInfo {
        ///    tokens: vec![
        ///        ("", "echo"),
        ///        ("'", "hi yoo"),
        ///        ("", "|"),
        ///        ("", "grep"),
        ///        ("\"", "hi"),
        ///    ],
        ///    is_complete: true
        /// }
        // #[allow(clippy::cyclomatic_complexity)]
        pub fn parse_line(line: &str) -> LineInfo {
            // FIXME: let rewrite this parse part and make it a separated lib
            let mut result = Vec::new();
            if tools::is_arithmetic(line) {
                for x in line.split(' ') {
                    result.push((String::from(""), x.to_string()));
                }
                return LineInfo::new(result);
            }

            let mut sep = String::new();
            // `sep_second` is for commands like this:
            //    export DIR=`brew --prefix openssl`/include
            // it only could have non-empty value when sep is empty.
            let mut sep_second = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let mut met_parenthesis = false;
            let mut new_round = true;
            let mut skip_next = false;
            let mut has_dollar = false;
            let mut parens_left_ignored = false;

            // for cmds like: `ll foo\>bar end` -> `ll 'foo>bar' end`
            let mut sep_made = String::new();

            // using semi_ok makes quite dirty here
            // it is mainly for path completion like:
            // $ ls "foo b<TAB>
            // # then got `"foo bar"/`, then hit tab again:
            // $ ls "foo bar"/<TAB>
            // # should got:
            // $ ls "foo bar/the-single-file.txt"
            // also using semi_ok makes the following command works as expected:
            // $ touch "foo"/bar.txt  # create bar.txt under ./foo directory
            let mut semi_ok = false;
            let count_chars = line.chars().count();
            for (i, c) in line.chars().enumerate() {
                if skip_next {
                    skip_next = false;
                    continue;
                }

                if has_backslash && sep.is_empty() && (c == '>' || c == '<') {
                    sep_made = String::from("'");
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash && sep == "\"" && c != '\"' {
                    // constant with bash: "\"" --> "; "\a" --> \a
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash {
                    if new_round && sep.is_empty() && (c == '|' || c == '$') && token.is_empty() {
                        sep = String::from("\\");
                        token = format!("{}", c);
                    } else {
                        token.push(c);
                    }
                    new_round = false;
                    has_backslash = false;
                    continue;
                }

                if c == '$' {
                    has_dollar = true;
                }

                // for cases like: echo $(foo bar)
                if c == '(' && sep.is_empty() {
                    if !has_dollar && token.is_empty() {
                        // temp solution for cmd like `(ls)`, `(ls -lh)`
                        parens_left_ignored = true;
                        continue;
                    }
                    met_parenthesis = true;
                }
                if c == ')' {
                    if parens_left_ignored && !has_dollar {
                        // temp solution for cmd like `(ls)`, `(ls -lh)`
                        if i == count_chars - 1 ||
                                (i + 1 < count_chars &&
                                line.chars().nth(i + 1).unwrap() == ' ') {
                            continue;
                        }
                    }
                    if sep.is_empty() {
                        met_parenthesis = false;
                    }
                }

                if c == '\\' {
                    if sep == "'" || !sep_second.is_empty() {
                        token.push(c)
                    } else {
                        has_backslash = true;
                    }
                    continue;
                }

                if new_round {
                    if c == ' ' {
                        continue;
                    } else if c == '"' || c == '\'' || c == '`' {
                        sep = c.to_string();
                        new_round = false;
                        continue;
                    }

                    sep = String::new();

                    if c == '#' {
                        // handle inline comments
                        break;
                    }

                    if c == '|' {
                        if i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == '|' {
                            result.push((String::from(""), "||".to_string()));
                            skip_next = true;
                        } else {
                            result.push((String::from(""), "|".to_string()));
                        }
                        new_round = true;
                        continue;
                    }

                    token.push(c);
                    new_round = false;
                    continue;
                }

                if c == '|' && !has_backslash {
                    if semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((sep.to_string(), token));
                        }
                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    } else if !met_parenthesis && sep_second.is_empty() && sep.is_empty() {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((String::from(""), token));
                        }
                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        continue;
                    }
                }

                if c == ' ' {
                    if semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((sep.to_string(), token));
                        }
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }

                    if has_backslash {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if met_parenthesis {
                        token.push(c);
                        continue;
                    }

                    if sep == "\\" {
                        result.push((String::from("\\"), token));
                        token = String::new();
                        new_round = true;
                        continue;
                    }

                    if sep.is_empty() {
                        if sep_second.is_empty() {
                            if sep.is_empty() && !sep_made.is_empty() {
                                result.push((sep_made.clone(), token));
                                sep_made = String::new();
                            } else {
                                result.push((String::from(""), token));
                            }
                            token = String::new();
                            new_round = true;
                            continue;
                        } else {
                            token.push(c);
                            continue;
                        }
                    } else {
                        token.push(c);
                        continue;
                    }
                }

                if c == '\'' || c == '"' || c == '`' {
                    if has_backslash {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if sep != c.to_string() && semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((sep.to_string(), token));
                        }
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        // do not use continue here!
                    }

                    if sep != c.to_string() && met_parenthesis {
                        token.push(c);
                        continue;
                    }
                    if sep.is_empty() && !sep_second.is_empty() && sep_second != c.to_string() {
                        token.push(c);
                        continue;
                    }

                    if sep.is_empty() {
                        let is_an_env = libs::re::re_contains(&token, r"^[a-zA-Z0-9_]+=.*$");
                        if !is_an_env && (c == '\'' || c == '"') {
                            sep = c.to_string();
                            continue;
                        }

                        token.push(c);
                        if sep_second.is_empty() {
                            sep_second = c.to_string();
                        } else if sep_second == c.to_string() {
                            sep_second = String::new();
                        }
                        continue;
                    } else if sep == c.to_string() {
                        semi_ok = true;
                        continue;
                    } else {
                        token.push(c);
                    }
                } else {
                    if has_backslash {
                        has_backslash = false;
                        if sep == "\"" || sep == "'" {
                            token.push('\\');
                        }
                    }
                    token.push(c);
                }
            }
            if !token.is_empty() || semi_ok {
                if sep.is_empty() && !sep_made.is_empty() {
                    result.push((sep_made.clone(), token));
                } else {
                    result.push((sep.clone(), token));
                }
            }

            let mut is_line_complete = true;
            if !result.is_empty() {
                let token_last = result[result.len() - 1].clone();
                if token_last.0.is_empty() && token_last.1 == "|" {
                    is_line_complete = false;
                }
            }

            if !sep.is_empty() {
                is_line_complete = semi_ok;
            }
            if has_backslash {
                is_line_complete = false;
            }

            LineInfo { tokens: result, is_complete: is_line_complete }
        }

        pub fn tokens_to_redirections(tokens: &Tokens) -> Result<(Tokens, Vec<Redirection>), String> {
            let mut tokens_new = Vec::new();
            let mut redirects = Vec::new();
            let mut to_be_continued = false;
            let mut to_be_continued_s1 = String::new();
            let mut to_be_continued_s2 = String::new();

            for token in tokens {
                let sep = &token.0;
                if !sep.is_empty() && !to_be_continued {
                    tokens_new.push(token.clone());
                    continue;
                }
                let word = &token.1;

                if to_be_continued {
                    if sep.is_empty() && word.starts_with('&') {
                        return Err(String::from("bad redirection syntax near &"));
                    }

                    let s3 = word.to_string();
                    if libs::re::re_contains(&to_be_continued_s1, r"^\d+$") {
                        if to_be_continued_s1 != "1" && to_be_continued_s1 != "2" {
                            return Err(String::from("Bad file descriptor #3"));
                        }
                        let s1 = to_be_continued_s1.clone();
                        let s2 = to_be_continued_s2.clone();
                        redirects.push((s1, s2, s3));
                    } else {
                        if !to_be_continued_s1.is_empty() {
                            tokens_new.push((sep.clone(), to_be_continued_s1.to_string()));
                        }
                        redirects.push(("1".to_string(), to_be_continued_s2.clone(), s3));
                    }

                    to_be_continued = false;
                    continue;
                }

                let ptn1 = r"^([^>]*)(>>?)([^>]+)$";
                let ptn2 = r"^([^>]*)(>>?)$";
                if !libs::re::re_contains(word, r">") {
                    tokens_new.push(token.clone());
                } else if libs::re::re_contains(word, ptn1) {
                    let re;
                    if let Ok(x) = Regex::new(ptn1) {
                        re = x;
                    } else {
                        return Err(String::from("Failed to build Regex"));
                    }

                    if let Some(caps) = re.captures(word) {
                        let s1 = caps.get(1).unwrap().as_str();
                        let s2 = caps.get(2).unwrap().as_str();
                        let s3 = caps.get(3).unwrap().as_str();
                        if s3.starts_with('&') && s3 != "&1" && s3 != "&2" {
                            return Err(String::from("Bad file descriptor #1"));
                        }

                        if libs::re::re_contains(s1, r"^\d+$") {
                            if s1 != "1" && s1 != "2" {
                                return Err(String::from("Bad file descriptor #2"));
                            }
                            redirects.push((s1.to_string(), s2.to_string(), s3.to_string()));
                        } else {
                            if !s1.is_empty() {
                                tokens_new.push((sep.clone(), s1.to_string()));
                            }
                            redirects.push((String::from("1"), s2.to_string(), s3.to_string()));
                        }
                    }
                } else if libs::re::re_contains(word, ptn2) {
                    let re;
                    if let Ok(x) = Regex::new(ptn2) {
                        re = x;
                    } else {
                        return Err(String::from("Failed to build Regex"));
                    }

                    if let Some(caps) = re.captures(word) {
                        let s1 = caps.get(1).unwrap().as_str();
                        let s2 = caps.get(2).unwrap().as_str();

                        to_be_continued = true;
                        to_be_continued_s1 = s1.to_string();
                        to_be_continued_s2 = s2.to_string();
                    }
                }
            }

            if to_be_continued {
                return Err(String::from("redirection syntax error"));
            }

            Ok((tokens_new, redirects))
        }

        pub fn unquote(text: &str) -> String {
            let mut new_str = String::from(text);
            for &c in ['"', '\''].iter() {
                if text.starts_with(c) && text.ends_with(c) {
                    new_str.remove(0);
                    new_str.pop();
                    break;
                }
            }
            new_str
        }
    }

    pub mod locust
    {
        use ::
        {
            *,
        };
        use pest::Parser;
        use pest::iterators::Pairs;
        use pest::error::Error;

        #[derive(Parser)]
        #[grammar = "parsers/grammar.pest"]
        struct Locust;

        pub fn parse_lines(lines: &str) -> Result<Pairs<crate::parsers::locust::Rule>, Error<crate::parsers::locust::Rule>> {
            Locust::parse(Rule::EXP, lines)
        }
    }
}

pub mod prompt
{
    use ::
    {
        *,
    };

    pub mod main
    {
        use ::
        {
            *
        };

        use std::env;

        use crate::execute;
        use crate::libs;
        use crate::shell;

        const DEFAULT_PROMPT: &str = "${COLOR_STATUS}$USER${RESET}\
            @${COLOR_STATUS}$HOSTNAME${RESET}: \
            ${COLOR_STATUS}$CWD${RESET}$ ";
        use super::preset::apply_preset_item;
        use super::preset::apply_pyenv;

        fn is_prefix_char(c: char) -> bool {
            c == '[' || c == '{'
        }

        fn is_suffix_char(c: char) -> bool {
            c == ']' || c == '}'
        }

        fn is_prompt_item_char(c: char, token: &str) -> bool {
            let s = c.to_string();
            if token.is_empty() {
                libs::re::re_contains(&s, r#"^[a-zA-Z_]$"#)
            } else {
                libs::re::re_contains(&s, r#"^[a-zA-Z0-9_]$"#)
            }
        }

        pub fn get_prompt_string() -> String {
            if let Ok(x) = env::var("PROMPT") {
                return x;
            }
            DEFAULT_PROMPT.to_string()
        }

        fn apply_prompt_item(sh: &shell::Shell, result: &mut String, token: &str) {
            if let Some(x) = sh.get_env(token) {
                result.push_str(&x);
                return;
            }
            apply_preset_item(sh, result, token);
        }

        fn apply_command(result: &mut String, token: &str, prefix: &str, suffix: &str) {
            let cr = execute::run(token);
            let output = cr.stdout.trim();
            if !output.is_empty() {
                result.push_str(prefix);
                result.push_str(output);
                result.push_str(suffix);
            }
        }

        pub fn render_prompt(sh: &shell::Shell, ps: &str) -> String {
            let mut prompt = String::new();
            apply_pyenv(&mut prompt);

            let mut met_dollar = false;
            let mut met_brace = false;
            let mut met_paren = false;
            let mut token = String::new();
            let mut prefix = String::new();
            let mut suffix = String::new();
            for c in ps.chars() {
                if met_dollar {
                    if c == '(' && !met_brace && !met_paren {
                        met_paren = true;
                        continue;
                    }
                    if c == ')' && met_paren {
                        apply_command(&mut prompt, &token, &prefix, &suffix);
                        token.clear();
                        prefix.clear();
                        suffix.clear();
                        met_dollar = false;
                        met_paren = false;
                        continue;
                    }
                    if c == '{' && !met_brace && !met_paren {
                        met_brace = true;
                        continue;
                    } else if c == '}' && met_brace {
                        apply_prompt_item(sh, &mut prompt, &token);
                        token.clear();
                        met_dollar = false;
                        met_brace = false;
                        continue;
                    } else if c == '$' {
                        if token.is_empty() {
                            // to make single $ as a plain $
                            prompt.push('$');
                            met_dollar = true;
                            continue;
                        } else {
                            apply_prompt_item(sh, &mut prompt, &token);
                            token.clear();
                            // met_dollar is still true
                            continue;
                        }
                    } else if met_paren {
                        if is_prefix_char(c) {
                            prefix.push(c);
                        } else if is_suffix_char(c) {
                            suffix.push(c);
                        } else {
                            token.push(c);
                        }
                        continue;
                    } else if is_prompt_item_char(c, &token) {
                        token.push(c);
                        continue;
                    } else if token.is_empty() {
                        prompt.push('$');
                        prompt.push(c);
                        met_dollar = false;
                        continue;
                    }
                }

                if c == '$' {
                    met_dollar = true;
                    continue;
                }

                if !token.is_empty() {
                    apply_prompt_item(sh, &mut prompt, &token);
                    token.clear();
                }
                prompt.push(c);
                met_dollar = false;
            }

            if !token.is_empty() {
                apply_prompt_item(sh, &mut prompt, &token);
                met_dollar = false;
            }

            if met_dollar {
                // for cases like PROMPT='$$'
                prompt.push('$');
            }

            if prompt.trim().is_empty() {
                return format!("cicada-{} >> ", env!("CARGO_PKG_VERSION"));
            }
            prompt
        }
    }

    pub mod preset
    {
        use ::
        {
            *
        };

        use std::env;
        use std::fs::File;
        use std::io::{Read, Write};
        use std::path::Path;

        use crate::libs;
        use crate::shell;
        use crate::tools;

        fn apply_seq(prompt: &mut String) {
            prompt.push_str(libs::colored::SEQ);
        }

        fn apply_end_seq(prompt: &mut String) {
            prompt.push_str(libs::colored::END_SEQ);
        }

        fn apply_esc(prompt: &mut String) {
            prompt.push_str(libs::colored::ESC);
        }

        fn apply_underlined(prompt: &mut String) {
            prompt.push_str(libs::colored::UNDERLINED);
        }

        fn apply_user(prompt: &mut String) {
            let username = tools::get_user_name();
            prompt.push_str(&username);
        }

        fn apply_black(prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK);
        }

        fn apply_black_b(prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_B);
        }

        fn apply_black_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_BG);
        }

        fn apply_blue(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE);
        }

        fn apply_blue_b(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_B);
        }

        fn apply_blue_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_BG);
        }

        fn apply_bold(prompt: &mut String) {
            prompt.push_str(libs::colored::BOLD);
        }

        fn apply_green(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN);
        }

        fn apply_green_b(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_B);
        }

        fn apply_green_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_BG);
        }

        fn apply_red(prompt: &mut String) {
            prompt.push_str(libs::colored::RED);
        }

        fn apply_red_b(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_B);
        }

        fn apply_red_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_BG);
        }

        fn apply_white(prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE);
        }

        fn apply_white_b(prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_B);
        }

        fn apply_white_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_BG);
        }

        fn apply_hidden(prompt: &mut String) {
            prompt.push_str(libs::colored::HIDDEN);
        }

        fn apply_reset(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET);
        }

        fn apply_reverse(prompt: &mut String) {
            prompt.push_str(libs::colored::REVERSE);
        }

        fn apply_dim(prompt: &mut String) {
            prompt.push_str(libs::colored::DIM);
        }

        fn apply_blink(prompt: &mut String) {
            prompt.push_str(libs::colored::BLINK);
        }

        fn apply_reset_underlined(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_UNDERLINED);
        }

        fn apply_reset_dim(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_DIM);
        }

        fn apply_reset_reverse(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_REVERSE);
        }

        fn apply_reset_hidden(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_HIDDEN);
        }

        fn apply_reset_blink(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BLINK);
        }

        fn apply_reset_bold(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BOLD);
        }

        fn apply_default(prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULT);
        }

        fn apply_default_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULT_BG);
        }

        fn apply_cyan(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN);
        }

        fn apply_cyan_l(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L);
        }

        fn apply_cyan_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_BG);
        }

        fn apply_cyan_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L_BG);
        }

        fn apply_red_l(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L);
        }

        fn apply_red_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L_BG);
        }

        fn apply_green_l(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L);
        }

        fn apply_green_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L_BG);
        }

        fn apply_gray_l(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L);
        }

        fn apply_gray_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L_BG);
        }

        fn apply_gray_d(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D);
        }

        fn apply_gray_d_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D_BG);
        }

        fn apply_magenta(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA);
        }

        fn apply_magenta_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_BG);
        }

        fn apply_magenta_l(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L);
        }

        fn apply_magenta_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L_BG);
        }

        fn apply_yellow(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW);
        }

        fn apply_yellow_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_BG);
        }

        fn apply_yellow_l(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L);
        }

        fn apply_yellow_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L_BG);
        }

        fn apply_blue_l(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L);
        }

        fn apply_blue_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L_BG);
        }

        fn apply_color_status(sh: &shell::Shell, prompt: &mut String) {
            if sh.previous_status == 0 {
                prompt.push_str(libs::colored::GREEN_B);
            } else {
                prompt.push_str(libs::colored::RED_B);
            }
        }

        fn _find_git_root() -> String {
            let current_dir = libs::path::current_dir();
            let dir_git = format!("{}/.git", current_dir);
            if Path::new(&dir_git).exists() {
                return current_dir;
            }

            let mut _dir = current_dir.clone();
            while Path::new(&_dir).parent().is_some() {
                match Path::new(&_dir).parent() {
                    Some(p) => {
                        _dir = p.to_string_lossy().to_string();
                        let dir_git = format!("{}/.git", _dir);
                        if Path::new(&dir_git).exists() {
                            return _dir;
                        }
                    }
                    None => {
                        break;
                    }
                }
            }

            String::new()
        }

        fn apply_gitbr(prompt: &mut String) {
            let git_root = _find_git_root();
            if git_root.is_empty() {
                return;
            }

            let file_head = format!("{}/.git/HEAD", git_root);
            if !Path::new(&file_head).exists() {
                return;
            }

            let mut file;
            match File::open(&file_head) {
                Ok(x) => file = x,
                Err(e) => {
                    println!("cicada: .git/HEAD err: {:?}", e);
                    return;
                }
            }
            let mut text = String::new();
            match file.read_to_string(&mut text) {
                Ok(_) => {}
                Err(e) => {
                    println!("cicada: read_to_string error: {:?}", e);
                    return;
                }
            }

            if let Some(branch) = libs::re::find_first_group(r"^[a-z]+: ?[a-z]+/[a-z]+/(.+)$", text.trim())
            {
                apply_blue_b(prompt);
                if let Ok(x) = env::var("CICADA_GITBR_PREFIX") {
                    prompt.push_str(&x);
                }

                let _len_default: i32 = 32;
                let mut len_max = if let Ok(x) = env::var("CICADA_GITBR_MAX_LEN") {
                    match x.parse::<i32>() {
                        Ok(n) => n,
                        Err(_) => _len_default,
                    }
                } else {
                    _len_default
                };
                if len_max <= 0 {
                    len_max = _len_default;
                }

                if branch.len() as i32 <= len_max {
                    prompt.push_str(&branch);
                } else {
                    let len = branch.len() as i32;
                    let offset = (len - len_max + 2) as usize;
                    let branch_short = format!("..{}", &branch[offset..]);
                    prompt.push_str(&branch_short);
                }
                if let Ok(x) = env::var("CICADA_GITBR_SUFFIX") {
                    prompt.push_str(&x);
                }
                apply_reset(prompt);
            }
        }

        fn apply_cwd(prompt: &mut String) {
            let _current_dir = match env::current_dir() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: PROMPT: env current_dir error: {}", e);
                    return;
                }
            };
            let current_dir = match _current_dir.to_str() {
                Some(x) => x,
                None => {
                    println_stderr!("cicada: PROMPT: to_str error");
                    return;
                }
            };
            let _tokens: Vec<&str> = current_dir.split('/').collect();

            let last = match _tokens.last() {
                Some(x) => x,
                None => {
                    log!("cicada: PROMPT: token last error");
                    return;
                }
            };

            let home = tools::get_user_home();
            let pwd = if last.is_empty() {
                "/"
            } else if current_dir == home {
                "~"
            } else {
                last
            };
            prompt.push_str(pwd);
        }

        fn apply_hostname(prompt: &mut String) {
            let hostname = tools::get_hostname();
            prompt.push_str(&hostname);
        }

        fn apply_newline(prompt: &mut String) {
            prompt.push('\n');
        }

        pub fn apply_pyenv(prompt: &mut String) {
            if let Ok(x) = env::var("VIRTUAL_ENV") {
                if !x.is_empty() {
                    let _tokens: Vec<&str> = x.split('/').collect();
                    let env_name = match _tokens.last() {
                        Some(x) => x,
                        None => {
                            log!("prompt token last error");
                            return;
                        }
                    };

                    apply_blue_b(prompt);
                    prompt.push('(');
                    prompt.push_str(env_name);
                    prompt.push(')');
                    apply_reset(prompt);
                }
            }
        }

        pub fn apply_preset_item(sh: &shell::Shell, prompt: &mut String, token: &str) {
            match token.to_ascii_lowercase().as_ref() {
                "black" => apply_black(prompt),
                "black_b" => apply_black_b(prompt),
                "black_bg" => apply_black_bg(prompt),
                "blink" => apply_blink(prompt),
                "blue" => apply_blue(prompt),
                "blue_b" => apply_blue_b(prompt),
                "blue_bg" => apply_blue_bg(prompt),
                "blue_l" => apply_blue_l(prompt),
                "blue_l_bg" => apply_blue_l_bg(prompt),
                "bold" => apply_bold(prompt),
                "color_status" => apply_color_status(sh, prompt),
                "cwd" => apply_cwd(prompt),
                "cyan" => apply_cyan(prompt),
                "cyan_bg" => apply_cyan_bg(prompt),
                "cyan_l" => apply_cyan_l(prompt),
                "cyan_l_bg" => apply_cyan_l_bg(prompt),
                "default" => apply_default(prompt),
                "default_bg" => apply_default_bg(prompt),
                "dim" => apply_dim(prompt),
                "end_seq" => apply_end_seq(prompt),
                "esc" => apply_esc(prompt),
                "gitbr" => apply_gitbr(prompt),
                "gray_d" => apply_gray_d(prompt),
                "gray_d_bg" => apply_gray_d_bg(prompt),
                "gray_l" => apply_gray_l(prompt),
                "gray_l_bg" => apply_gray_l_bg(prompt),
                "green" => apply_green(prompt),
                "green_b" => apply_green_b(prompt),
                "green_bg" => apply_green_bg(prompt),
                "green_l" => apply_green_l(prompt),
                "green_l_bg" => apply_green_l_bg(prompt),
                "hidden" => apply_hidden(prompt),
                "hostname" => apply_hostname(prompt),
                "magenta" => apply_magenta(prompt),
                "magenta_bg" => apply_magenta_bg(prompt),
                "magenta_l" => apply_magenta_l(prompt),
                "magenta_l_bg" => apply_magenta_l_bg(prompt),
                "newline" => apply_newline(prompt),
                "red" => apply_red(prompt),
                "red_b" => apply_red_b(prompt),
                "red_bg" => apply_red_bg(prompt),
                "red_l" => apply_red_l(prompt),
                "red_l_bg" => apply_red_l_bg(prompt),
                "reset" => apply_reset(prompt),
                "reset_blink" => apply_reset_blink(prompt),
                "reset_bold" => apply_reset_bold(prompt),
                "reset_dim" => apply_reset_dim(prompt),
                "reset_hidden" => apply_reset_hidden(prompt),
                "reset_reverse" => apply_reset_reverse(prompt),
                "reset_underlined" => apply_reset_underlined(prompt),
                "reverse" => apply_reverse(prompt),
                "seq" => apply_seq(prompt),
                "underlined" => apply_underlined(prompt),
                "user" => apply_user(prompt),
                "white" => apply_white(prompt),
                "white_b" => apply_white_b(prompt),
                "white_bg" => apply_white_bg(prompt),
                "yellow" => apply_yellow(prompt),
                "yellow_bg" => apply_yellow_bg(prompt),
                "yellow_l" => apply_yellow_l(prompt),
                "yellow_l_bg" => apply_yellow_l_bg(prompt),
                _ => (),
            }
        }
    }

    pub mod multilines
    {
        use ::
        {
            *
        };

        use std::io;
        use lineread::{Function, Prompter, Terminal};

        use crate::parsers::parser_line;

        pub struct EnterFunction;

        impl<T: Terminal> Function<T> for EnterFunction {
            fn execute(&self, prompter: &mut Prompter<T>, count: i32, _ch: char) -> io::Result<()> {
                let buf = prompter.buffer();
                let linfo = parser_line::parse_line(buf);
                if linfo.is_complete {
                    prompter.accept_input()
                } else if count > 0 {
                    match prompter.insert(count as usize, '\n') {
                        Ok(_) => {},
                        Err(e) => {
                            println!("sub-prompt error: {}", e);
                        }
                    }
                    prompter.insert_str(">> ")
                } else {
                    Ok(())
                }
            }
        }
    }


    use crate::libs;
    use crate::shell;

    use self::main::get_prompt_string;
    use self::main::render_prompt;
    pub use self::multilines::EnterFunction;

    fn get_prompt_len(prompt: &str) -> i32 {
        let mut count = 0;
        let mut met_x01 = false;
        for c in prompt.chars() {
            if c == '\x01' {
                met_x01 = true;
                continue;
            } else if c == '\x02' {
                met_x01 = false;
                continue;
            }
            if !met_x01 {
                count += 1;
            }
        }
        count
    }

    pub fn get_prompt(sh: &shell::Shell) -> String {
        let ps = get_prompt_string();
        let mut prompt = render_prompt(sh, &ps);
        if let Some((w, _h)) = libs::term_size::dimensions() {
            if get_prompt_len(&prompt) > (w / 2) as i32
                && !libs::re::re_contains(&ps, r#"(?i)\$\{?newline.\}?"#)
            {
                prompt.push_str("\n$ ");
            }
        } else {
            log!("ERROR: Failed to get term size");
        }
        prompt
    }
}

pub mod rcfile
{
    use ::
    {
        *,
    };
    use std::path::Path;

    use crate::scripting;
    use crate::shell;
    use crate::tools;

    pub fn get_rc_file() -> String {
        let dir_config = tools::get_config_dir();
        let rc_file = format!("{}/cicadarc", dir_config);
        if Path::new(&rc_file).exists() {
            return rc_file;
        }

        // fail back to $HOME/.cicadarc
        let home = tools::get_user_home();
        let rc_file_home = format!("{}/{}", home, ".cicadarc");
        if Path::new(&rc_file_home).exists() {
            return rc_file_home;
        }

        // use std path if both absent
        rc_file
    }

    pub fn load_rc_files(sh: &mut shell::Shell) {
        let rc_file = get_rc_file();
        if !Path::new(&rc_file).exists() {
            return;
        }

        let args = vec!["source".to_string(), rc_file];
        scripting::run_script(sh, &args);
    }
}

pub mod scripting
{
    use ::
    {
        *,
    };
    use std::fs::File;
    use std::io::{Read, Write, ErrorKind};
    use std::path::Path;

    use pest::iterators::Pair;
    use regex::{Regex, RegexBuilder};

    use crate::execute;
    use crate::libs;
    use crate::parsers;
    use crate::shell;
    use crate::types;
    use crate::types::CommandResult;

    pub fn run_script(sh: &mut shell::Shell, args: &Vec<String>) -> i32 {
        let src_file = &args[1];
        let full_src_file: String;
        if src_file.contains('/') {
            full_src_file = src_file.clone();
        } else {
            let full_path = libs::path::find_file_in_path(src_file, false);
            if full_path.is_empty() {
                // not in PATH and not in current work directory
                if !Path::new(src_file).exists() {
                    println_stderr!("cicada: {}: no such file", src_file);
                    return 1;
                }
                full_src_file = format!("./{}", src_file);
            } else {
                full_src_file = full_path.clone();
            }
        }

        if !Path::new(&full_src_file).exists() {
            println_stderr!("cicada: {}: no such file", src_file);
            return 1;
        }
        if Path::new(&full_src_file).is_dir() {
            println_stderr!("cicada: {}: is a directory", src_file);
            return 1;
        }

        let mut file;
        match File::open(&full_src_file) {
            Ok(x) => file = x,
            Err(e) => {
                println_stderr!("cicada: {}: failed to open file - {:?}", &full_src_file, e.kind());
                return 1;
            }
        }
        let mut text = String::new();
        match file.read_to_string(&mut text) {
            Ok(_) => {}
            Err(e) => {
                match e.kind() {
                    ErrorKind::InvalidData => {
                        println_stderr!("cicada: {}: not a valid script file", &full_src_file);
                    }
                    _ => {
                        println_stderr!("cicada: {}: error: {:?}", &full_src_file, e);
                    }
                }
                return 1;
            }
        }

        if text.contains("\\\n") {
            let re = RegexBuilder::new(r#"([ \t]*\\\n[ \t]+)|([ \t]+\\\n[ \t]*)"#)
                .multi_line(true).build().unwrap();
            text = re.replace_all(&text, " ").to_string();

            let re = RegexBuilder::new(r#"\\\n"#).multi_line(true).build().unwrap();
            text = re.replace_all(&text, "").to_string();
        }

        let re_func_head = Regex::new(r"^function ([a-zA-Z_-][a-zA-Z0-9_-]*) *(?:\(\))? *\{$").unwrap();
        let re_func_tail = Regex::new(r"^\}$").unwrap();
        let mut text_new = String::new();
        let mut enter_func = false;
        let mut func_name = String::new();
        let mut func_body = String::new();
        for line in text.clone().lines() {
            if re_func_head.is_match(line.trim()) {
                enter_func = true;
                let cap = re_func_head.captures(line.trim()).unwrap();
                func_name = cap[1].to_string();
                func_body = String::new();
                continue;
            }
            if re_func_tail.is_match(line.trim()) {
                sh.set_func(&func_name, &func_body);
                enter_func = false;
                continue;
            }
            if enter_func {
                func_body.push_str(line);
                func_body.push('\n');
            } else {
                text_new.push_str(line);
                text_new.push('\n');
            }
        }

        let mut status = 0;
        let cr_list = run_lines(sh, &text_new, args, false);
        if let Some(last) = cr_list.last() {
            status = last.status;
        }

        // FIXME: We probably need to fix the issue in the `set` builtin,
        // which currently set `exit_on_error` at the shell session level,
        // we should instead set in a script-level.
        // Here is a work-around ugly fix.
        sh.exit_on_error = false;

        status
    }

    pub fn run_lines(sh: &mut shell::Shell,
                    lines: &str,
                    args: &Vec<String>,
                    capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        match parsers::locust::parse_lines(lines) {
            Ok(pairs_exp) => {
                for pair in pairs_exp {
                    let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, false, capture);
                    cr_list.append(&mut _cr_list);
                }
            }
            Err(e) => {
                println_stderr!("syntax error: {:?}", e);
                return cr_list;
            }
        }
        cr_list
    }

    fn expand_args(line: &str, args: &[String]) -> String {
        let linfo = parsers::parser_line::parse_line(line);
        let mut tokens = linfo.tokens;
        expand_args_in_tokens(&mut tokens, args);
        parsers::parser_line::tokens_to_line(&tokens)
    }

    fn expand_line_to_toknes(line: &str,
                            args: &[String],
                            sh: &mut shell::Shell) -> types::Tokens {
        let linfo = parsers::parser_line::parse_line(line);
        let mut tokens = linfo.tokens;
        expand_args_in_tokens(&mut tokens, args);
        shell::do_expansion(sh, &mut tokens);
        tokens
    }

    fn is_args_in_token(token: &str) -> bool {
        libs::re::re_contains(token, r"\$\{?[0-9@]+\}?")
    }

    fn expand_args_for_single_token(token: &str, args: &[String]) -> String {
        let re = Regex::new(r"^(.*?)\$\{?([0-9]+|@)\}?(.*)$").unwrap();
        if !re.is_match(token) {
            return token.to_string();
        }

        let mut result = String::new();
        let mut _token = token.to_string();
        let mut _head = String::new();
        let mut _output = String::new();
        let mut _tail = String::new();
        loop {
            if !re.is_match(&_token) {
                if !_token.is_empty() {
                    result.push_str(&_token);
                }
                break;
            }
            for cap in re.captures_iter(&_token) {
                _head = cap[1].to_string();
                _tail = cap[3].to_string();
                let _key = cap[2].to_string();
                if _key == "@" {
                    result.push_str(format!("{}{}", _head, args[1..].join(" ")).as_str());
                } else if let Ok(arg_idx) = _key.parse::<usize>() {
                    if arg_idx < args.len() {
                        result.push_str(format!("{}{}", _head, args[arg_idx]).as_str());
                    } else {
                        result.push_str(&_head);
                    }
                } else {
                    result.push_str(&_head);
                }
            }

            if _tail.is_empty() {
                break;
            }
            _token = _tail.clone();
        }
        result
    }

    fn expand_args_in_tokens(tokens: &mut types::Tokens, args: &[String]) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for (sep, token) in tokens.iter() {
            if sep == "`" || sep == "'" || !is_args_in_token(token) {
                idx += 1;
                continue;
            }

            let _token = expand_args_for_single_token(token, args);
            buff.push((idx, _token));
            idx += 1;
        }

        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn run_exp_test_br(sh: &mut shell::Shell,
                    pair_br: Pair<parsers::locust::Rule>,
                    args: &Vec<String>,
                    in_loop: bool,
                    capture: bool) -> (Vec<CommandResult>, bool, bool, bool) {
        let mut cr_list = Vec::new();
        let pairs = pair_br.into_inner();
        let mut test_pass = false;
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::IF_HEAD ||
                    rule == parsers::locust::Rule::IF_ELSEIF_HEAD ||
                    rule == parsers::locust::Rule::WHILE_HEAD {
                let pairs_test: Vec<Pair<parsers::locust::Rule>> =
                    pair.into_inner().collect();
                let pair_test = &pairs_test[0];
                let line = pair_test.as_str().trim();
                let line_new = expand_args(line, &args[1..]);
                let mut _cr_list = execute::run_command_line(sh, &line_new, true, capture);
                if let Some(last) = _cr_list.last() {
                    if last.status == 0 {
                        test_pass = true;
                    }
                }
                continue;
            }

            if rule == parsers::locust::Rule::KW_ELSE {
                test_pass = true;
                continue;
            }

            if rule == parsers::locust::Rule::EXP_BODY {
                if !test_pass {
                    return (cr_list, false, false, false);
                }
                let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, in_loop, capture);
                cr_list.append(&mut _cr_list);
                // branch executed successfully
                return (cr_list, true, _cont, _brk);
            }

            unreachable!();
        }
        (cr_list, test_pass, false, false)
    }

    fn run_exp_if(sh: &mut shell::Shell,
                pair_if: Pair<parsers::locust::Rule>,
                args: &Vec<String>,
                in_loop: bool,
                capture: bool) -> (Vec<CommandResult>, bool, bool) {
        let mut cr_list = Vec::new();
        let pairs = pair_if.into_inner();
        let mut met_continue = false;
        let mut met_break = false;
        for pair in pairs {
            let (mut _cr_list, passed, _cont, _brk) = run_exp_test_br(sh, pair, args, in_loop, capture);
            met_continue = _cont;
            met_break = _brk;
            cr_list.append(&mut _cr_list);
            // break at first successful branch
            if passed {
                break;
            }
        }
        (cr_list, met_continue, met_break)
    }

    fn get_for_result_from_init(sh: &mut shell::Shell,
                                pair_init: Pair<parsers::locust::Rule>,
                                args: &[String]) -> Vec<String> {
        let mut result: Vec<String> = Vec::new();
        let pairs = pair_init.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::TEST {
                let line = pair.as_str().trim();
                let tokens = expand_line_to_toknes(line, &args[1..], sh);
                for (sep, token) in tokens {
                    if sep.is_empty() {
                        for x in token.split_whitespace() {
                            result.push(x.to_string());
                        }
                    } else {
                        result.push(token.clone());
                    }
                }
            }
        }
        result
    }

    fn get_for_result_list(sh: &mut shell::Shell,
                        pair_head: Pair<parsers::locust::Rule>,
                        args: &[String]) -> Vec<String> {
        let pairs = pair_head.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_INIT {
                return get_for_result_from_init(sh, pair, args);
            }
        }
        Vec::new()
    }

    fn get_for_var_name(pair_head: Pair<parsers::locust::Rule>) -> String {
        let pairs = pair_head.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_INIT {
                let pairs_init = pair.into_inner();
                for pair_init in pairs_init {
                    let rule_init = pair_init.as_rule();
                    if rule_init == parsers::locust::Rule::FOR_VAR {
                        let line = pair_init.as_str().trim();
                        return line.to_string();
                    }
                }
            }
        }
        String::new()
    }

    fn run_exp_for(sh: &mut shell::Shell,
                pair_for: Pair<parsers::locust::Rule>,
                args: &Vec<String>,
                capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        let pairs = pair_for.into_inner();
        let mut result_list: Vec<String> = Vec::new();
        let mut var_name: String = String::new();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_HEAD {
                var_name = get_for_var_name(pair.clone());
                result_list = get_for_result_list(sh, pair.clone(), args);
                continue;
            }
            if rule == parsers::locust::Rule::EXP_BODY {
                for value in &result_list {
                    sh.set_env(&var_name, value);
                    let (mut _cr_list, _cont, _brk) = run_exp(
                        sh, pair.clone(), args, true, capture);
                    cr_list.append(&mut _cr_list);
                    if _brk {
                        break;
                    }
                }
            }
        }
        cr_list
    }

    fn run_exp_while(sh: &mut shell::Shell,
                    pair_while: Pair<parsers::locust::Rule>,
                    args: &Vec<String>,
                    capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        loop {
            let (mut _cr_list, passed, _cont, _brk) = run_exp_test_br(sh, pair_while.clone(), args, true, capture);
            cr_list.append(&mut _cr_list);
            if !passed || _brk {
                break;
            }
        }
        cr_list
    }

    fn run_exp(sh: &mut shell::Shell,
            pair_in: Pair<parsers::locust::Rule>,
            args: &Vec<String>,
            in_loop: bool,
            capture: bool) -> (Vec<CommandResult>, bool, bool) {
        let mut cr_list = Vec::new();
        let pairs = pair_in.into_inner();
        for pair in pairs {
            let line = pair.as_str().trim();
            if line.is_empty() {
                continue;
            }

            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::CMD {
                if line == "continue" {
                    if in_loop {
                        return (cr_list, true, false);
                    } else {
                        println_stderr!("cicada: continue: only meaningful in loops");
                        continue;
                    }
                }
                if line == "break" {
                    if in_loop {
                        return (cr_list, false, true);
                    } else {
                        println_stderr!("cicada: break: only meaningful in loops");
                        continue;
                    }
                }

                let line_new = expand_args(line, &args[1..]);
                let mut _cr_list = execute::run_command_line(sh, &line_new, true, capture);
                cr_list.append(&mut _cr_list);
                if let Some(last) = cr_list.last() {
                    let status = last.status;
                    if status != 0 && sh.exit_on_error {
                        return (cr_list, false, false);
                    }
                }
            } else if rule == parsers::locust::Rule::EXP_IF {
                let (mut _cr_list, _cont, _brk) = run_exp_if(sh, pair, args, in_loop, capture);
                cr_list.append(&mut _cr_list);
                if _cont {
                    return (cr_list, true, false);
                }
                if _brk {
                    return (cr_list, false, true);
                }
            } else if rule == parsers::locust::Rule::EXP_FOR {
                let mut _cr_list = run_exp_for(sh, pair, args, capture);
                cr_list.append(&mut _cr_list);
            } else if rule == parsers::locust::Rule::EXP_WHILE {
                let mut _cr_list = run_exp_while(sh, pair, args, capture);
                cr_list.append(&mut _cr_list);
            }
        }
        (cr_list, false, false)
    }
}

pub mod shell
{
    use ::
    {
        *,
    };

    use errno::errno;
    use std::collections::{HashMap, HashSet};
    use std::env;
    use std::io::Write;
    use std::mem;

    use regex::Regex;
    use uuid::Uuid;

    use crate::core;
    use crate::libs;
    use crate::parsers;
    use crate::tools;
    use crate::types::{self, CommandLine};

    #[derive(Debug, Clone)]
    pub struct Shell {
        pub jobs: HashMap<i32, types::Job>,
        pub aliases: HashMap<String, String>,
        pub envs: HashMap<String, String>,
        pub funcs: HashMap<String, String>,
        pub cmd: String,
        pub current_dir: String,
        pub previous_dir: String,
        pub previous_cmd: String,
        pub previous_status: i32,
        pub is_login: bool,
        pub exit_on_error: bool,
        pub has_terminal: bool,
        pub session_id: String,
    }

    impl Shell {
        pub fn new() -> Shell {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = tools::get_current_dir();
            // TODO: the shell proc may have terminal later
            // e.g. $ cicada foo.sh &
            // then with a $ fg
            let has_terminal = proc_has_terminal();
            let (session_id, _) = uuid.split_at(13);
            Shell {
                jobs: HashMap::new(),
                aliases: HashMap::new(),
                envs: HashMap::new(),
                funcs: HashMap::new(),
                cmd: String::new(),
                current_dir: current_dir.clone(),
                previous_dir: String::new(),
                previous_cmd: String::new(),
                previous_status: 0,
                is_login: false,
                exit_on_error: false,
                has_terminal,
                session_id: session_id.to_string(),
            }
        }

        pub fn insert_job(&mut self, gid: i32, pid: i32, cmd: &str, status: &str, bg: bool) {
            let mut i = 1;
            loop {
                let mut indexed_job_missing = false;
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        x.pids.push(pid);
                        x.cmd = format!("{} | {}", x.cmd, cmd);
                        return;
                    }
                } else {
                    indexed_job_missing = true;
                }

                if indexed_job_missing {
                    self.jobs.insert(
                        i,
                        types::Job {
                            cmd: cmd.to_string(),
                            id: i,
                            gid,
                            pids: vec![pid],
                            pids_stopped: HashSet::new(),
                            status: status.to_string(),
                            is_bg: bg,
                        },
                    );
                    return;
                }
                i += 1;
            }
        }

        pub fn get_job_by_id(&self, job_id: i32) -> Option<&types::Job> {
            self.jobs.get(&job_id)
        }

        pub fn mark_job_member_continued(&mut self, pid: i32,
                                        gid: i32) -> Option<&types::Job> {
            if self.jobs.is_empty() {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.pids_stopped.remove(&pid);
                        idx_found = i;
                        break;
                    }
                }


                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            self.jobs.get(&idx_found)
        }

        pub fn mark_job_member_stopped(&mut self, pid: i32,
                                    gid: i32) -> Option<&types::Job> {
            if self.jobs.is_empty() {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.pids_stopped.insert(pid);
                        idx_found = i;
                        break;
                    }
                }


                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            self.jobs.get(&idx_found)
        }

        pub fn get_job_by_gid(&self, gid: i32) -> Option<&types::Job> {
            if self.jobs.is_empty() {
                return None;
            }

            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get(&i) {
                    if x.gid == gid {
                        return Some(x);
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
            None
        }

        pub fn mark_job_as_running(&mut self, gid: i32, bg: bool) {
            if self.jobs.is_empty() {
                return;
            }

            let mut i = 1;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.status = "Running".to_string();
                        job.pids_stopped.clear();
                        job.is_bg = bg;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }

        pub fn mark_job_as_stopped(&mut self, gid: i32) {
            if self.jobs.is_empty() {
                return;
            }

            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        x.status = "Stopped".to_string();
                        x.is_bg = true;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }

        pub fn remove_pid_from_job(&mut self, gid: i32, pid: i32) -> Option<types::Job> {
            if self.jobs.is_empty() {
                return None;
            }

            let mut empty_pids = false;
            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        if let Ok(i_pid) = x.pids.binary_search(&pid) {
                            x.pids.remove(i_pid);
                        }
                        empty_pids = x.pids.is_empty();
                        break;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            if empty_pids {
                return self.jobs.remove(&i);
            }
            None
        }
        /// Update existing *ENV Variable* if such name exists in ENVs,
        /// otherwise, we define a local *Shell Variable*, which would not
        /// be exported into child processes.
        pub fn set_env(&mut self, name: &str, value: &str) {
            if env::var(name).is_ok() {
                env::set_var(name, value);
            } else {
                self.envs.insert(name.to_string(), value.to_string());
            }
        }
        /// get *Shell Variable*, or *ENV Variable*.
        pub fn get_env(&self, name: &str) -> Option<String> {
            match self.envs.get(name) {
                Some(x) => Some(x.to_string()),
                None => {
                    match env::var(name) {
                        Ok(x) => Some(x),
                        Err(_) => None,
                    }
                }
            }
        }
        /// Remove environment variable, function from the environment of
        /// the currently running process
        pub fn remove_env(&mut self, name: &str) -> bool {
            // function names can contain the `-` char.
            let ptn_env = Regex::new(r"^[a-zA-Z_][a-zA-Z0-9_-]*$").unwrap();
            if !ptn_env.is_match(name) {
                return false;
            }

            env::remove_var(name);
            self.envs.remove(name);
            self.remove_func(name);
            true
        }

        pub fn remove_path(&mut self, path: &str) {
            if let Ok(paths) = env::var("PATH") {
                let mut paths_new: Vec<&str> = paths.split(":").collect();
                paths_new.retain(|&x| x != path);
                env::set_var("PATH", paths_new.join(":").as_str());
            }
        }

        fn remove_func(&mut self, name: &str) {
            self.funcs.remove(name);
        }

        pub fn set_func(&mut self, name: &str, value: &str) {
            self.funcs.insert(name.to_string(), value.to_string());
        }

        pub fn get_func(&self, name: &str) -> Option<String> {
            self.funcs.get(name).map(|x| x.to_string())
        }

        pub fn get_alias_list(&self) -> Vec<(String, String)> {
            let mut result = Vec::new();
            for (name, value) in &self.aliases {
                result.push((name.clone(), value.clone()));
            }
            result
        }

        pub fn add_alias(&mut self, name: &str, value: &str) {
            self.aliases.insert(name.to_string(), value.to_string());
        }

        pub fn is_alias(&self, name: &str) -> bool {
            self.aliases.contains_key(name)
        }

        pub fn remove_alias(&mut self, name: &str) -> bool {
            let opt = self.aliases.remove(name);
            opt.is_some()
        }

        pub fn get_alias_content(&self, name: &str) -> Option<String> {
            let result = match self.aliases.get(name) {
                Some(x) => x.to_string(),
                None => String::new(),
            };
            if result.is_empty() {
                None
            } else {
                Some(result)
            }
        }
    }

    pub unsafe fn give_terminal_to(gid: i32) -> bool {
        let mut mask: libc::sigset_t = mem::zeroed();
        let mut old_mask: libc::sigset_t = mem::zeroed();

        libc::sigemptyset(&mut mask);
        libc::sigaddset(&mut mask, libc::SIGTSTP);
        libc::sigaddset(&mut mask, libc::SIGTTIN);
        libc::sigaddset(&mut mask, libc::SIGTTOU);
        libc::sigaddset(&mut mask, libc::SIGCHLD);

        let rcode = libc::pthread_sigmask(libc::SIG_BLOCK, &mask, &mut old_mask);
        if rcode != 0 {
            log!("failed to call pthread_sigmask");
        }
        let rcode = libc::tcsetpgrp(1, gid);
        let given;
        if rcode == -1 {
            given = false;
            let e = errno();
            let code = e.0;
            log!("error in give_terminal_to() {}: {}", code, e);
        } else {
            given = true;
        }
        let rcode = libc::pthread_sigmask(libc::SIG_SETMASK, &old_mask, &mut mask);
        if rcode != 0 {
            log!("failed to call pthread_sigmask");
        }
        given
    }

    fn needs_globbing(line: &str) -> bool {
        let re = Regex::new(r"\*+").expect("Invalid regex ptn");
        re.is_match(line)
    }

    pub fn expand_glob(tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !needs_globbing(text) {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let item = text.as_str();

            if !item.contains('*') || item.trim().starts_with('\'') || item.trim().starts_with('"') {
                result.push(item.to_string());
            } else {
                let _basename = libs::path::basename(item);
                let show_hidden = _basename.starts_with(".*");

                match glob::glob(item) {
                    Ok(paths) => {
                        let mut is_empty = true;
                        for entry in paths {
                            match entry {
                                Ok(path) => {
                                    let file_path = path.to_string_lossy();
                                    let _basename = libs::path::basename(&file_path);
                                    if _basename == ".." || _basename == "." {
                                        continue;
                                    }
                                    if _basename.starts_with('.') && !show_hidden {
                                        // skip hidden files, you may need to
                                        // type `ls .*rc` instead of `ls *rc`
                                        continue;
                                    }
                                    result.push(file_path.to_string());
                                    is_empty = false;
                                }
                                Err(e) => {
                                    log!("glob error: {:?}", e);
                                }
                            }
                        }
                        if is_empty {
                            result.push(item.to_string());
                        }
                    }
                    Err(e) => {
                        println!("glob error: {:?}", e);
                        result.push(item.to_string());
                        return;
                    }
                }
            }

            buff.push((idx, result));
            idx += 1;
        }

        for (i, result) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in result.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }

    fn expand_one_env(sh: &Shell, token: &str) -> String {
        // do not combine these two into one: `\{?..\}?`,
        // otherwize `}` in `{print $NF}` would gone.
        let re1 = Regex::new(r"^(.*?)\$([A-Za-z0-9_]+|\$|\?)(.*)$").unwrap();
        let re2 = Regex::new(r"(.*?)\$\{([A-Za-z0-9_]+|\$|\?)\}(.*)$").unwrap();
        if !re1.is_match(token) && !re2.is_match(token) {
            return token.to_string();
        }

        let mut result = String::new();
        let match_re1 = re1.is_match(token);
        let match_re2 = re2.is_match(token);
        if !match_re1 && !match_re2 {
            return token.to_string();
        }

        let cap_results = if match_re1 {
            re1.captures_iter(token)
        } else {
            re2.captures_iter(token)
        };

        for cap in cap_results {
            let head = cap[1].to_string();
            let tail = cap[3].to_string();
            let key = cap[2].to_string();
            if key == "?" {
                result.push_str(format!("{}{}", head, sh.previous_status).as_str());
            } else if key == "$" {
                unsafe {
                    let val = libc::getpid();
                    result.push_str(format!("{}{}", head, val).as_str());
                }
            } else if let Ok(val) = env::var(&key) {
                result.push_str(format!("{}{}", head, val).as_str());
            } else if let Some(val) = sh.get_env(&key) {
                result.push_str(format!("{}{}", head, val).as_str());
            } else {
                result.push_str(&head);
            }
            result.push_str(&tail);
        }

        result
    }

    fn need_expand_brace(line: &str) -> bool {
        libs::re::re_contains(line, r#"\{[^ "']*,[^ "']*,?[^ "']*\}"#)
    }

    fn brace_getitem(s: &str, depth: i32) -> (Vec<String>, String) {
        let mut out: Vec<String> = vec![String::new()];
        let mut ss = s.to_string();
        let mut tmp;
        while !ss.is_empty() {
            let c = match ss.chars().next() {
                Some(x) => x,
                None => {
                    return (out, ss);
                }
            };
            if depth > 0 && (c == ',' || c == '}') {
                return (out, ss);
            }
            if c == '{' {
                let mut sss = ss.clone();
                sss.remove(0);
                let result_groups = brace_getgroup(&sss, depth + 1);
                if let Some((out_group, s_group)) = result_groups {
                    let mut tmp_out = Vec::new();
                    for x in out.iter() {
                        for y in out_group.iter() {
                            let item = format!("{}{}", x, y);
                            tmp_out.push(item);
                        }
                    }
                    out = tmp_out;
                    ss = s_group.clone();
                    continue;
                }
            }
            // FIXME: here we mean more than one char.
            if c == '\\' && ss.len() > 1 {
                ss.remove(0);
                let c;
                match ss.chars().next() {
                    Some(x) => c = x,
                    None => {
                        return (out, ss)
                    }
                }

                tmp = format!("\\{}", c);
            } else {
                tmp = c.to_string();
            }
            let mut result = Vec::new();
            for x in out.iter() {
                let item = format!("{}{}", x, tmp);
                result.push(item);
            }
            out = result;
            ss.remove(0);
        }
        (out, ss)
    }

    fn brace_getgroup(s: &str, depth: i32) -> Option<(Vec<String>, String)> {
        let mut out: Vec<String> = Vec::new();
        let mut comma = false;
        let mut ss = s.to_string();
        while !ss.is_empty() {
            let (g, sss) = brace_getitem(ss.as_str(), depth);
            ss = sss.clone();
            if ss.is_empty() {
                break;
            }
            for x in g.iter() {
                out.push(x.clone());
            }

            let c = match ss.chars().next() {
                Some(x) => x,
                None => {
                    break;
                }
            };
            if c == '}' {
                let mut sss = ss.clone();
                sss.remove(0);
                if comma {
                    return Some((out, sss));
                }
                let mut result = Vec::new();
                for x in out.iter() {
                    let item = format!("{{{}}}", x);
                    result.push(item);
                }
                return Some((result, ss));
            }
            if c == ',' {
                comma = true;
                ss.remove(0);
            }
        }

        None
    }

    fn expand_brace(tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, token) in tokens.iter() {
            if !sep.is_empty() || !need_expand_brace(token) {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let items = brace_getitem(token, 0);
            for x in items.0 {
                result.push(x.clone());
            }
            buff.push((idx, result));
            idx += 1;
        }

        for (i, items) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in items.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }

    fn expand_brace_range(tokens: &mut types::Tokens) {
        let re;
        if let Ok(x) = Regex::new(r#"\{(-?[0-9]+)\.\.(-?[0-9]+)(\.\.)?([0-9]+)?\}"#) {
            re = x;
        } else {
            println_stderr!("cicada: re new error");
            return;
        }

        let mut idx: usize = 0;
        let mut buff: Vec<(usize, Vec<String>)> = Vec::new();
        for (sep, token) in tokens.iter() {
            if !sep.is_empty() || !re.is_match(token) {
                idx += 1;
                continue;
            }

            // safe to unwrap here, since the `is_match` above already validated
            let caps = re.captures(token).unwrap();

            let start = match caps[1].to_string().parse::<i32>() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: {}", e);
                    return;
                }
            };

            let end = match caps[2].to_string().parse::<i32>() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: {}", e);
                    return;
                }
            };

            // incr is always positive
            let mut incr = if caps.get(4).is_none() {
                1
            } else {
                match caps[4].to_string().parse::<i32>() {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!("cicada: {}", e);
                        return;
                    }
                }
            };
            if incr <= 1 {
                incr = 1;
            }

            let mut result: Vec<String> = Vec::new();
            let mut n = start;
            if start > end {
                while n >= end {
                    result.push(format!("{}", n));
                    n -= incr;
                }
            } else {
                while n <= end {
                    result.push(format!("{}", n));
                    n += incr;
                }
            }

            buff.push((idx, result));
            idx += 1;
        }

        for (i, items) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in items.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }

    fn expand_alias(sh: &Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        let mut is_head = true;
        for (sep, text) in tokens.iter() {
            if sep.is_empty() && text == "|" {
                is_head = true;
                idx += 1;
                continue;
            }
            if is_head && text == "xargs" {
                idx += 1;
                continue;
            }

            if !is_head || !sh.is_alias(text) {
                idx += 1;
                is_head = false;
                continue;
            }

            if let Some(value) = sh.get_alias_content(text) {
                buff.push((idx, value.clone()));
            }

            idx += 1;
            is_head = false;
        }

        for (i, text) in buff.iter().rev() {
            let linfo = parsers::parser_line::parse_line(text);
            let tokens_ = linfo.tokens;
            tokens.remove(*i);
            for item in tokens_.iter().rev() {
                tokens.insert(*i, item.clone());
            }
        }
    }

    fn expand_home(tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !text.starts_with("~") {
                idx += 1;
                continue;
            }

            let mut s: String = text.clone();
            let ptn = r"^~(?P<tail>.*)";
            let re = Regex::new(ptn).expect("invalid re ptn");
            let home = tools::get_user_home();
            let ss = s.clone();
            let to = format!("{}$tail", home);
            let result = re.replace_all(ss.as_str(), to.as_str());
            s = result.to_string();

            buff.push((idx, s.clone()));
            idx += 1;
        }

        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn env_in_token(token: &str) -> bool {
        if libs::re::re_contains(token, r"\$\{?[\$\?]\}?") {
            return true;
        }

        let ptn_env_name = r"[a-zA-Z_][a-zA-Z0-9_]*";
        let ptn_env = format!(r"\$\{{?{}\}}?", ptn_env_name);
        if !libs::re::re_contains(token, &ptn_env) {
            return false;
        }

        // do not expand env in a command substitution, e.g.:
        // - echo $(echo '$HOME')
        // - VERSION=$(foobar -h | grep 'version: v' | awk '{print $NF}')
        let ptn_cmd_sub1 = format!(r"^{}=`.*`$", ptn_env_name);
        let ptn_cmd_sub2 = format!(r"^{}=\$\(.*\)$", ptn_env_name);
        if libs::re::re_contains(token, &ptn_cmd_sub1)
            || libs::re::re_contains(token, &ptn_cmd_sub2)
            || libs::re::re_contains(token, r"^\$\(.+\)$")
        {
            return false;
        }

        // for cmd-line like `alias foo='echo $PWD'`
        let ptn_env = format!(r"='.*\$\{{?{}\}}?.*'$", ptn_env_name);
        !libs::re::re_contains(token, &ptn_env)
    }

    pub fn expand_env(sh: &Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for (sep, token) in tokens.iter() {
            if sep == "`" || sep == "'" {
                idx += 1;
                continue;
            }

            if !env_in_token(token) {
                idx += 1;
                continue;
            }

            let mut _token = token.clone();
            while env_in_token(&_token) {
                _token = expand_one_env(sh, &_token);
            }
            buff.push((idx, _token));
            idx += 1;
        }

        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn should_do_dollar_command_extension(line: &str) -> bool {
        libs::re::re_contains(line, r"\$\([^\)]+\)") &&
        !libs::re::re_contains(line, r"='.*\$\([^\)]+\).*'$")
    }

    fn do_command_substitution_for_dollar(sh: &mut Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();

        for (sep, token) in tokens.iter() {
            if sep == "'" || sep == "\\" || !should_do_dollar_command_extension(token) {
                idx += 1;
                continue;
            }

            let mut line = token.to_string();
            loop {
                if !should_do_dollar_command_extension(&line) {
                    break;
                }

                let ptn_cmd = r"\$\((.+)\)";
                let cmd = match libs::re::find_first_group(ptn_cmd, &line) {
                    Some(x) => x,
                    None => {
                        println_stderr!("cicada: calculator: no first group");
                        return;
                    }
                };

                let cmd_result = match CommandLine::from_line(&cmd, sh) {
                    Ok(c) => {
                        log!("run subcmd dollar: {:?}", &cmd);
                        let (term_given, cr) = core::run_pipeline(sh, &c, true, true, false);
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid(0);
                                give_terminal_to(gid);
                            }
                        }

                        cr
                    }
                    Err(e) => {
                        println_stderr!("cicada: {}", e);
                        continue;
                    }
                };

                let output_txt = cmd_result.stdout.trim();

                let ptn = r"(?P<head>[^\$]*)\$\(.+\)(?P<tail>.*)";
                let re;
                if let Ok(x) = Regex::new(ptn) {
                    re = x;
                } else {
                    return;
                }

                let to = format!("${{head}}{}${{tail}}", output_txt);
                let line_ = line.clone();
                let result = re.replace(&line_, to.as_str());
                line = result.to_string();
            }

            buff.insert(idx, line.clone());
            idx += 1;
        }

        for (i, text) in buff.iter() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn do_command_substitution_for_dot(sh: &mut Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();
        for (sep, token) in tokens.iter() {
            let new_token: String;
            if sep == "`" {
                log!("run subcmd dot1: {:?}", token);
                let cr = match CommandLine::from_line(token, sh) {
                    Ok(c) => {
                        let (term_given, _cr) = core::run_pipeline(sh, &c, true, true, false);
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid(0);
                                give_terminal_to(gid);
                            }
                        }

                        _cr
                    }
                    Err(e) => {
                        println_stderr!("cicada: {}", e);
                        continue;
                    }
                };

                new_token = cr.stdout.trim().to_string();
            } else if sep == "\"" || sep.is_empty() {
                let re;
                if let Ok(x) = Regex::new(r"^([^`]*)`([^`]+)`(.*)$") {
                    re = x;
                } else {
                    println_stderr!("cicada: re new error");
                    return;
                }
                if !re.is_match(token) {
                    idx += 1;
                    continue;
                }
                let mut _token = token.clone();
                let mut _item = String::new();
                let mut _head = String::new();
                let mut _output = String::new();
                let mut _tail = String::new();
                loop {
                    if !re.is_match(&_token) {
                        if !_token.is_empty() {
                            _item = format!("{}{}", _item, _token);
                        }
                        break;
                    }
                    for cap in re.captures_iter(&_token) {
                        _head = cap[1].to_string();
                        _tail = cap[3].to_string();
                        log!("run subcmd dot2: {:?}", &cap[2]);

                        let cr = match CommandLine::from_line(&cap[2], sh) {
                            Ok(c) => {
                                let (term_given, _cr) = core::run_pipeline(sh, &c, true, true, false);
                                if term_given {
                                    unsafe {
                                        let gid = libc::getpgid(0);
                                        give_terminal_to(gid);
                                    }
                                }

                                _cr
                            }
                            Err(e) => {
                                println_stderr!("cicada: {}", e);
                                continue;
                            }
                        };

                        _output = cr.stdout.trim().to_string();
                    }
                    _item = format!("{}{}{}", _item, _head, _output);
                    if _tail.is_empty() {
                        break;
                    }
                    _token = _tail.clone();
                }
                new_token = _item;
            } else {
                idx += 1;
                continue;
            }

            buff.insert(idx, new_token.clone());
            idx += 1;
        }

        for (i, text) in buff.iter() {
            tokens[*i].1 = text.to_string();
        }
    }

    fn do_command_substitution(sh: &mut Shell, tokens: &mut types::Tokens) {
        do_command_substitution_for_dot(sh, tokens);
        do_command_substitution_for_dollar(sh, tokens);
    }

    pub fn do_expansion(sh: &mut Shell, tokens: &mut types::Tokens) {
        let line = parsers::parser_line::tokens_to_line(tokens);
        if tools::is_arithmetic(&line) {
            return;
        }

        if tokens.len() >= 2 && tokens[0].1 == "export" && tokens[1].1.starts_with("PROMPT=") {
            return;
        }

        expand_alias(sh, tokens);
        expand_home(tokens);
        expand_env(sh, tokens);
        expand_brace(tokens);
        expand_glob(tokens);
        do_command_substitution(sh, tokens);
        expand_brace_range(tokens);
    }

    pub fn trim_multiline_prompts(line: &str) -> String {
        // remove sub-prompts from multiple line mode
        // 1. assuming '\n' char cannot be typed manually?
        // 2. `>>` is defined as `src/prompt/multilines.rs`
        let line_new = libs::re::replace_all(line, r"\\\n>> ", "");
        let line_new = libs::re::replace_all(&line_new, r"\| *\n>> ", "| ");
        libs::re::replace_all(&line_new, r"(?P<NEWLINE>\n)>> ", "$NEWLINE")
    }

    fn proc_has_terminal() -> bool {
        unsafe {
            let tgid = libc::tcgetpgrp(0);
            let pgid = libc::getpgid(0);
            tgid == pgid
        }
    }
}

pub mod signals
{
    use ::
    {
        *,
    };

    use errno::{errno, set_errno};
    use nix::sys::signal;
    use nix::sys::wait::{WaitPidFlag as WF, WaitStatus as WS, waitpid};
    use nix::unistd::Pid;
    use std::sync::Mutex;
    use std::collections::{HashMap, HashSet};

    lazy_static! {
        static ref REAP_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
        static ref STOP_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
        static ref CONT_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
        static ref KILL_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
    }

    pub fn killed_map_insert(pid: i32, sig: i32) {
        if let Ok(mut m) = KILL_MAP.try_lock() {
            m.insert(pid, sig);
        }
    }

    pub fn killed_map_pop(pid: i32) -> Option<i32> {
        if let Ok(mut m) = KILL_MAP.try_lock() {
            m.remove(&pid)
        } else {
            None
        }
    }

    pub fn insert_cont_map(pid: i32) {
        if let Ok(mut m) = CONT_MAP.try_lock() {
            m.insert(pid);
        }
    }

    pub fn pop_cont_map(pid: i32) -> bool {
        match CONT_MAP.try_lock() {
            Ok(mut m) => m.remove(&pid),
            Err(_) => false,
        }
    }

    pub fn insert_stopped_map(pid: i32) {
        if let Ok(mut m) = STOP_MAP.try_lock() {
            m.insert(pid);
        }
    }

    pub fn pop_stopped_map(pid: i32) -> bool {
        match STOP_MAP.try_lock() {
            Ok(mut m) => m.remove(&pid),
            Err(_) => false,
        }
    }

    pub fn insert_reap_map(pid: i32, status: i32) {
        if let Ok(mut m) = REAP_MAP.try_lock() {
            m.insert(pid, status);
        }
    }

    pub fn pop_reap_map(pid: i32) -> Option<i32> {
        match REAP_MAP.try_lock() {
            Ok(mut m) => m.remove(&pid),
            Err(_) => None,
        }
    }

    pub fn block_signals() {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        match signal::sigprocmask(signal::SigmaskHow::SIG_BLOCK, Some(&sigset), None) {
            Ok(_) => {},
            Err(e) => {
                log!("sigprocmask block error: {:?}", e);
            }
        }
    }

    pub fn unblock_signals() {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        match signal::sigprocmask(signal::SigmaskHow::SIG_UNBLOCK, Some(&sigset), None) {
            Ok(_) => {},
            Err(e) => {
                log!("sigprocmask unblock error: {:?}", e);
            }
        }
    }

    #[allow(unreachable_patterns)]
    pub extern "C" fn handle_sigchld(_sig: i32) {
        let saved_errno = errno();
        let options = Some(WF::WUNTRACED | WF::WNOHANG | WF::WCONTINUED);
        loop {
            match waitpid(Pid::from_raw(-1), options) {
                Ok(WS::Exited(pid, status)) => {
                    insert_reap_map(i32::from(pid), status);
                }
                Ok(WS::Stopped(pid, _sig)) => {
                    insert_stopped_map(i32::from(pid));
                }
                Ok(WS::Continued(pid)) => {
                    // NOTE: SIGCHLD generated by SIGCONT is not reliable
                    // on Mac (both for signal handler or sync waitpid).
                    insert_cont_map(i32::from(pid));
                }
                Ok(WS::Signaled(pid, sig, _core_dumped)) => {
                    killed_map_insert(i32::from(pid), sig as i32);
                }
                Ok(WS::StillAlive) => {
                    break;
                }
                Ok(_others) => {
                    // log!("sigchld others: {:?}", _others);
                }
                Err(e) => {
                    if e == nix::Error::ECHILD {
                        break;
                    }

                    log!("chld waitpid error: {:?}", e);
                    break;
                }
            }
        }

        set_errno(saved_errno);
    }

    pub fn setup_sigchld_handler() {
        let sigset = signal::SigSet::empty();
        let handler = signal::SigHandler::Handler(handle_sigchld);
        // automatically restart system calls interrupted by this signal handler
        let flags = signal::SaFlags::SA_RESTART;
        let sa = signal::SigAction::new(handler, flags, sigset);
        unsafe {
            match signal::sigaction(signal::SIGCHLD, &sa) {
                Ok(_) => {},
                Err(e) => {
                    log!("sigaction error: {:?}", e);
                }
            }
        }
    }
}

pub mod types
{
    use ::
    {
        *,
    };
    use regex::Regex;
    use std::collections::{HashMap, HashSet};
    use std::fmt;

    use crate::parsers;
    use crate::parsers::parser_line::tokens_to_redirections;
    use crate::shell;
    use crate::libs;
    use crate::tools;

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct WaitStatus(i32, i32, i32);

    impl WaitStatus {
        pub fn from_exited(pid: i32, status: i32) -> Self {
            WaitStatus(pid, 0, status)
        }

        pub fn from_signaled(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 1, sig)
        }

        pub fn from_stopped(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 2, sig)
        }

        pub fn from_continuted(pid: i32) -> Self {
            WaitStatus(pid, 3, 0)
        }

        pub fn from_others() -> Self {
            WaitStatus(0, 9, 9)
        }

        pub fn from_error(errno: i32) -> Self {
            WaitStatus(0, 255, errno)
        }

        pub fn empty() -> Self {
            WaitStatus(0, 0, 0)
        }

        pub fn is_error(&self) -> bool {
            self.1 == 255
        }

        pub fn is_others(&self) -> bool {
            self.1 == 9
        }

        pub fn is_signaled(&self) -> bool {
            self.1 == 1
        }

        pub fn get_errno(&self) -> nix::Error {
            nix::Error::from_raw(self.2)
        }

        pub fn is_exited(&self) -> bool {
            self.0 != 0 && self.1 == 0
        }

        pub fn is_stopped(&self) -> bool {
            self.1 == 2
        }

        pub fn is_continued(&self) -> bool {
            self.1 == 3
        }

        pub fn get_pid(&self) -> i32 {
            self.0
        }

        fn _get_signaled_status(&self) -> i32 {
            self.2 + 128
        }

        pub fn get_signal(&self) -> i32 {
            self.2
        }

        pub fn get_name(&self) -> String {
            if self.is_exited() {
                "Exited".to_string()
            } else if self.is_stopped() {
                "Stopped".to_string()
            } else if self.is_continued() {
                "Continued".to_string()
            } else if self.is_signaled() {
                "Signaled".to_string()
            } else if self.is_others() {
                "Others".to_string()
            } else if self.is_error() {
                "Error".to_string()
            } else {
                format!("unknown: {}", self.2)
            }
        }

        pub fn get_status(&self) -> i32 {
            if self.is_exited() {
                self.2
            } else {
                self._get_signaled_status()
            }
        }
    }

    impl fmt::Debug for WaitStatus {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let mut formatter = f.debug_struct("WaitStatus");
            formatter.field("pid", &self.0);
            let name = self.get_name();
            formatter.field("name", &name);
            formatter.field("ext", &self.2);
            formatter.finish()
        }
    }

    pub type Token = (String, String);
    pub type Tokens = Vec<Token>;
    pub type Redirection = (String, String, String);

    #[derive(Debug)]
    pub struct LineInfo {
        // e.g. echo 'foo
        // is not a completed line, need to turn to multiple-line mode.
        pub tokens: Tokens,
        pub is_complete: bool,
    }

    impl LineInfo {
        pub fn new(tokens: Tokens) -> Self {
            LineInfo { tokens, is_complete: true }
        }
    }

    ///
    /// command line: `ls 'foo bar' 2>&1 > /dev/null < one-file` would be:
    /// Command {
    ///     tokens: [("", "ls"), ("", "-G"), ("\'", "foo bar")],
    ///     redirects_to: [
    ///         ("2", ">", "&1"),
    ///         ("1", ">", "/dev/null"),
    ///     ],
    ///     redirect_from: Some(("<", "one-file")),
    /// }
    ///
    #[derive(Debug)]
    pub struct Command {
        pub tokens: Tokens,
        pub redirects_to: Vec<Redirection>,
        pub redirect_from: Option<Token>,
    }

    #[derive(Debug)]
    pub struct CommandLine {
        pub line: String,
        pub commands: Vec<Command>,
        pub envs: HashMap<String, String>,
        pub background: bool,
    }

    impl Command {
        pub fn from_tokens(tokens: Tokens) -> Result<Command, String> {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");

            let mut len = tokens_new.len();
            while has_redirect_from {
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<") {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<<<") {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }

                has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");
            }

            let tokens_final;
            let redirects_to;
            match tokens_to_redirections(&tokens_new) {
                Ok((_tokens, _redirects_to)) => {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }
                Err(e) => {
                    return Err(e);
                }
            }

            let redirect_from = if redirects_from_type.is_empty() {
                None
            } else {
                Some((redirects_from_type, redirects_from_value))
            };

            Ok(Command{
                tokens: tokens_final,
                redirects_to,
                redirect_from,
            })
        }

        pub fn has_redirect_from(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<"
        }

        pub fn has_here_string(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<<<"
        }

        pub fn is_builtin(&self) -> bool {
            tools::is_builtin(&self.tokens[0].1)
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Job {
        pub cmd: String,
        pub id: i32,
        pub gid: i32,
        pub pids: Vec<i32>,
        pub pids_stopped: HashSet<i32>,
        pub status: String,
        pub is_bg: bool,
    }

    impl Job {
        pub fn all_members_stopped(&self) -> bool {
            for pid in &self.pids {
                if !self.pids_stopped.contains(pid) {
                    return false;
                }
            }
            true
        }

        pub fn all_members_running(&self) -> bool {
            self.pids_stopped.is_empty()
        }
    }

    
    #[derive(Clone, Debug, Default)]
    pub struct CommandResult {
        pub gid: i32,
        pub status: i32,
        pub stdout: String,
        pub stderr: String,
    }

    impl CommandResult {
        pub fn new() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 0,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn from_status(gid: i32, status: i32) -> CommandResult {
            CommandResult {
                gid,
                status,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn error() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 1,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    }

    
    #[derive(Clone, Debug, Default)]
    pub struct CommandOptions {
        pub background: bool,
        pub isatty: bool,
        pub capture_output: bool,
        pub envs: HashMap<String, String>,
    }

    fn split_tokens_by_pipes(tokens: &[Token]) -> Vec<Tokens> {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();
        for token in tokens {
            let sep = &token.0;
            let value = &token.1;
            if sep.is_empty() && value == "|" {
                if cmd.is_empty() {
                    return Vec::new();
                }
                cmds.push(cmd.clone());
                cmd = Vec::new();
            } else {
                cmd.push(token.clone());
            }
        }
        if cmd.is_empty() {
            return Vec::new();
        }
        cmds.push(cmd.clone());
        cmds
    }

    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String> {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new(r"^([a-zA-Z0-9_]+)=(.*)$").unwrap();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !libs::re::re_contains(text, r"^([a-zA-Z0-9_]+)=(.*)$") {
                break;
            }

            for cap in re.captures_iter(text) {
                let name = cap[1].to_string();
                let value = parsers::parser_line::unquote(&cap[2]);
                envs.insert(name, value);
            }

            n += 1;
        }
        if n > 0 {
            tokens.drain(0..n);
        }
        envs
    }

    impl CommandLine {
        pub fn from_line(line: &str, sh: &mut shell::Shell) -> Result<CommandLine, String> {
            let linfo = parsers::parser_line::parse_line(line);
            let mut tokens = linfo.tokens;
            shell::do_expansion(sh, &mut tokens);
            let envs = drain_env_tokens(&mut tokens);

            let mut background = false;
            let len = tokens.len();
            if len > 1 && tokens[len - 1].1 == "&" {
                background = true;
                tokens.pop();
            }

            let mut commands = Vec::new();
            for sub_tokens in split_tokens_by_pipes(&tokens) {
                match Command::from_tokens(sub_tokens) {
                    Ok(c) => {
                        commands.push(c);
                    }
                    Err(e) => {
                        return Err(e);
                    }
                }
            }

            Ok(CommandLine{
                line: line.to_string(),
                commands,
                envs,
                background,
            })
        }

        pub fn is_empty(&self) -> bool {
            self.commands.is_empty()
        }

        pub fn with_pipeline(&self) -> bool {
            self.commands.len() > 1
        }

        pub fn is_single_and_builtin(&self) -> bool {
            self.commands.len() == 1 && self.commands[0].is_builtin()
        }
    }
}

fn main()
{
    unsafe
    {
        libc::signal(libc::SIGPIPE, libc::SIG_DFL);

        // ignore SIGTSTP (ctrl-Z) for the shell itself
        libc::signal(libc::SIGTSTP, libc::SIG_IGN);
        libc::signal(libc::SIGQUIT, libc::SIG_IGN);
    }

    tools::init_path_env();

    let mut sh = shell::Shell::new();
    let args: Vec<String> = env::args().collect();

    if libs::progopts::is_login(&args) {
        rcfile::load_rc_files(&mut sh);
        sh.is_login = true;
    }

    // Initialize command cache for highlighting
    highlight::init_command_cache();
    highlight::update_aliases(&sh);

    if libs::progopts::is_script(&args) {
        log!("run script: {:?} ", &args);
        let status = scripting::run_script(&mut sh, &args);
        std::process::exit(status);
    }

    if libs::progopts::is_command_string(&args) {
        // handles `cicada -c 'echo hi && echo yoo'`,
        // e.g. it could be triggered from Vim (`:!ls` etc).
        let line = tools::env_args_to_command_line();
        log!("run with -c args: {}", &line);
        execute::run_command_line(&mut sh, &line, false, false);
        std::process::exit(sh.previous_status);
    }

    if libs::progopts::is_non_tty() {
        // cases like open a new MacVim window,
        // (i.e. CMD+N) on an existing one
        execute::run_procs_for_non_tty(&mut sh);
        return;
    }

    let mut rl;
    match Interface::new("cicada") {
        Ok(x) => rl = x,
        Err(e) => {
            // non-tty will raise errors here
            println!("cicada: lineread error: {}", e);
            return;
        }
    }

    rl.define_function("enter-function", Arc::new(prompt::EnterFunction));
    rl.bind_sequence("\r", Command::from_str("enter-function"));

    let highlighter = highlight::create_highlighter();
    rl.set_highlighter(highlighter);

    history::init(&mut rl);
    rl.set_completer(Arc::new(completers::CicadaCompleter {
        sh: Arc::new(sh.clone()),
    }));

    let sig_handler_enabled = tools::is_signal_handler_enabled();
    if sig_handler_enabled {
        signals::setup_sigchld_handler();
        // block the signals at most of time, since Rust is not "async-signal-safe"
        // yet. see https://github.com/rust-lang/rfcs/issues/1368
        // we'll unblock them when necessary only.
        signals::block_signals();
    }

    loop {
        let prompt = prompt::get_prompt(&sh);
        match rl.set_prompt(&prompt) {
            Ok(_) => {}
            Err(e) => {
                println_stderr!("cicada: prompt error: {}", e);
            }
        }

        if sig_handler_enabled {
            // FIXME: in `rl.read_line()` below, there is lots of Rust code,
            // which may not be async-signal-safe. see follow links for details:
            // - https://ldpreload.com/blog/signalfd-is-useless
            // - https://man7.org/linux/man-pages/man7/signal-safety.7.html
            signals::unblock_signals();
        }
        match rl.read_line() {
            Ok(ReadResult::Input(line)) => {
                if sig_handler_enabled {
                    signals::block_signals();
                }

                let line = shell::trim_multiline_prompts(&line);
                if line.trim() == "" {
                    jobc::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                    continue;
                }
                sh.cmd = line.clone();

                let tsb = ctime::DateTime::now().unix_timestamp();
                let mut line = line.clone();

                // since `!!` expansion is only meaningful in an interactive
                // shell we extend it here, instead of in `run_command_line()`.
                tools::extend_bangbang(&sh, &mut line);

                let mut status = 0;
                let cr_list = execute::run_command_line(&mut sh, &line, true, false);
                if let Some(last) = cr_list.last() {
                    status = last.status;
                }
                let tse = ctime::DateTime::now().unix_timestamp();

                if !sh.cmd.starts_with(' ') && line != sh.previous_cmd {
                    history::add(&sh, &mut rl, &line, status, tsb, tse);
                    sh.previous_cmd = line.clone();
                }

                if tools::is_shell_altering_command(&line) {
                    // since our shell object need to be passed into
                    // `lineread::Completer` with an Arc.
                    // I currently do not know how to share the same sh
                    // instance at hand with it.

                    // update the Arc clone when alias/function/env changes
                    rl.set_completer(Arc::new(completers::CicadaCompleter {
                        sh: Arc::new(sh.clone()),
                    }));

                    // Update aliases in the highlighter when they might have changed
                    highlight::update_aliases(&sh);
                }

                jobc::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                continue;
            }
            Ok(ReadResult::Eof) => {
                if let Ok(x) = env::var("NO_EXIT_ON_CTRL_D") {
                    if x == "1" {
                        println!();
                    }
                } else {
                    println!("exit");
                    break;
                }
            }
            Ok(ReadResult::Signal(s)) => {
                println_stderr!("readline signal: {:?}", s);
            }
            Err(e) => {
                println_stderr!("readline error: {}", e);
                // There maybe other reason of this Err, but possibly it occurs
                // in cases we give term to a child, and it stops, and we
                // didn't have term back to shell in waitpid places. Here
                // it's a last resort.
                // FIXME: we only need this trick when job-control has issues
                unsafe {
                    let gid = libc::getpgid(0);
                    shell::give_terminal_to(gid);
                }
            }
        }
        if sig_handler_enabled {
            signals::block_signals();
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 79530
