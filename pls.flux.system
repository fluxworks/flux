#![feature
(
    tool_lints
)]

#![allow
(
    non_camel_case_types,
    unknown_lints,
    unused_imports,
    unused_macros,
)]
/**/
#[macro_use] extern crate lazy_static;
/**/
extern crate libc;
extern crate nix;
extern crate regex as re;
extern crate time as timed;
extern crate unicode_normalization;
extern crate unicode_width;

#[macro_use] pub mod macros
{
    use ::
    {
        *,
    };

    #[macro_export] macro_rules! log
    {
        ($fmt:expr) => 
        (
            let log_file = if let Ok(x) = ::env::var("CICADA_LOG_FILE") { x.clone() } else { String::new() };

            if !log_file.is_empty()
            {
                use ::io::Write as _;

                let msg = $fmt;

                match std::fs::OpenOptions::new().append(true).create(true).open(&log_file)
                {
                    Ok(mut cfile) =>
                    {
                        let pid = ::process::getpid();
                        let now = ::time::c::DateTime::now();
                        let msg = format!("[{}][{}] {}", now, pid, msg);
                        let msg = if msg.ends_with('\n') { msg } else { format!("{}\n", msg) };
                        match cfile.write_all(msg.as_bytes())
                        {
                            Ok(_) => {}
                            Err(_) => println!("tlog: write_all error")
                        }
                    }
                    Err(_) => println!("tlog: open file error"),
                }
            }
        );

        ($fmt:expr, $($arg:tt)*) => 
        (
            let msg = format!($fmt, $($arg)*);
            log!(&msg);
        );
    }

    #[macro_export] macro_rules! println_stderr
    {
        ($fmt:expr) =>
        (
            match writeln!( &mut ::io::stderr(), $fmt )
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );

        ($fmt:expr, $($arg:tt)*) =>
        (
            match writeln!( &mut ::io::stderr(), $fmt, $($arg)* )
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );
    }
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod char
{
    //! Provides utilities for manipulating character values
    pub use std::char::{ * };
    /// Character value indicating end-of-file
    pub const EOF: char = '\x04';
    /// Character value generated by the Escape key
    pub const ESCAPE: char = '\x1b';
    /// Character value generated by the Backspace key
    ///
    /// On Unix systems, this is equivalent to `RUBOUT`
    #[cfg(unix)] pub const DELETE: char = RUBOUT;
    /// Character value generated by the Backspace key
    ///
    /// On Windows systems, this character is Ctrl-H
    #[cfg(windows)] pub const DELETE: char = '\x08';
    /// Character value generated by the Backspace key on some systems
    pub const RUBOUT: char = '\x7f';
    /// Returns a character name as a key sequence, e.g. `Control-x` or `Meta-x`.
    pub fn parse_char_name(name: &str) -> Option<String> {
        let name_lc = name.to_lowercase();

        let is_ctrl = contains_any(&name_lc, &["c-", "ctrl-", "control-"]);
        let is_meta = contains_any(&name_lc, &["m-", "meta-"]);

        let name = match name_lc.rfind('-') {
            Some(pos) => &name_lc[pos + 1..],
            None => &name_lc[..]
        };

        let ch = match name {
            "del" | "rubout"  => DELETE,
            "esc" | "escape"  => ESCAPE,
            "lfd" | "newline" => '\n',
            "ret" | "return"  => '\r',
            "spc" | "space"   => ' ',
            "tab"             => '\t',
            s if !s.is_empty() => s.chars().next().unwrap(),
            _ => return None
        };

        let ch = match (is_ctrl, is_meta) {
            (true,  true)  => meta(ctrl(ch)),
            (true,  false) => ctrl(ch).to_string(),
            (false, true)  => meta(ch),
            (false, false) => ch.to_string(),
        };

        Some(ch)
    }
    /// Returns a character sequence escaped for user-facing display.
    pub fn escape_sequence(s: &str) -> String {
        let mut res = String::with_capacity(s.len());

        for ch in s.chars() {
            match ch {
                ESCAPE => res.push_str(r"\e"),
                RUBOUT => res.push_str(r"\C-?"),
                '\\' => res.push_str(r"\\"),
                '\'' => res.push_str(r"\'"),
                '"' => res.push_str(r#"\""#),
                ch if is_ctrl(ch) => {
                    res.push_str(r"\C-");
                    res.push(unctrl_lower(ch));
                }
                ch => res.push(ch)
            }
        }

        res
    }
    /// Returns a meta sequence for the given character.
    pub fn meta(ch: char) -> String {
        let mut s = String::with_capacity(ch.len_utf8() + 1);
        s.push(ESCAPE);
        s.push(ch);
        s
    }

    fn contains_any(s: &str, strs: &[&str]) -> bool {
        strs.iter().any(|a| s.contains(a))
    }
    /// Returns whether the character is printable.
    pub fn is_printable(c: char) -> bool
    {
        c == '\t' || c == '\n' || !(c == '\0' || is_ctrl(c))
    }

    const CTRL_BIT: u8 = 0x40;
    const CTRL_MASK: u8 = 0x1f;
    /// Returns whether the given character is a control character.
    pub fn is_ctrl(c: char) -> bool {
        const CTRL_MAX: u32 = 0x1f;

        c != '\0' && c as u32 <= CTRL_MAX
    }
    /// Returns a control character for the given character.
    pub fn ctrl(c: char) -> char {
        ((c as u8) & CTRL_MASK) as char
    }
    /// Returns the printable character corresponding to the given control character.
    pub fn unctrl(c: char) -> char {
        ((c as u8) | CTRL_BIT) as char
    }
    /// Returns the lowercase character corresponding to the given control character.
    pub fn unctrl_lower(c: char) -> char
    {
        unctrl(c).to_ascii_lowercase()
    }
    /*
    pub fn backward_char(...) -> usize */
    pub fn backward(n: usize, s: &str, cur: usize) -> usize
    {
        let mut chars = s[..cur].char_indices().filter(|&(_, ch)| !::is::combining_mark(ch));
        let mut res = cur;

        for _ in 0..n {
            match chars.next_back() {
                Some((idx, _)) => res = idx,
                None => return 0
            }
        }

        res
    }
    /*
    pub fn forward_char(...) -> usize */
    pub fn forward(n: usize, s: &str, cur: usize) -> usize
    {
        let mut chars = s[cur..].char_indices()
            .filter(|&(_, ch)| !::is::combining_mark(ch));

        for _ in 0..n {
            match chars.next() {
                Some(_) => (),
                None => return s.len()
            }
        }

        match chars.next() {
            Some((idx, _)) => cur + idx,
            None => s.len()
        }
    }
    /*
    pub fn backward_search_char(...) -> Option<usize> */
    pub fn backward_search(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n {
            match buf[..cur].rfind(ch) {
                Some(p) => {
                    cur = p;
                    pos = Some(cur);
                }
                None => break
            }
        }

        pos
    }
    /*
    pub fn forward_search_char(...) -> Option<usize> */
    pub fn forward_search(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n
        {
            let off = match buf[cur..].chars().next() {
                Some(ch) => ch.len_utf8(),
                None => break
            };

            match buf[cur + off..].find(ch) {
                Some(p) => {
                    cur += off + p;
                    pos = Some(cur);
                }
                None => break
            }
        }

        pos
    }
    /// Returns the width of a character in the terminal.
    #[inline] pub fn width(ch: char) -> Option<usize>
    {
        use unicode_width::UnicodeWidthChar;
        ch.width()
    }
}

pub mod collections
{
    pub use std::collections::{ * };

    use ::
    { 
        iter::{ FromIterator },
        *,
    };
    /// Utilities for manipulating raw input sequences representing the result of a `SequenceMap::find` operation.
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum FindResult<V>
    {
        /// No contained sequences begin with the provided input sequence.
        NotFound,
        /// One or more sequences begin with the provided input sequence,
        /// but the sequence does not represent a complete sequence.
        Incomplete,
        /// A sequence was found exactly matching the input sequence;
        /// additionally, one or more sequences begin with the input sequence.
        Undecided(V),
        /// A sequence was found exactly matching the input sequence;
        /// no additional partially-matching sequences exist.
        Found(V),
    }

    impl<'a, V: Clone> FindResult<&'a V>
    {
        /// Maps `FindResult<&V>` to `FindResult<V>` by cloning the contents of the result value.
        pub fn cloned(self) -> FindResult<V>
        {
            match self {
                FindResult::NotFound => FindResult::NotFound,
                FindResult::Incomplete => FindResult::Incomplete,
                FindResult::Undecided(v) => FindResult::Undecided(v.clone()),
                FindResult::Found(v) => FindResult::Found(v.clone()),
            }
        }
    }
    /// A view into an occupied entry in a `SequenceMap`.
    pub struct OccupiedEntry<'a, K: 'a, V: 'a>
    {
        map: &'a mut SequenceMap<K, V>,
        index: usize,
    }

    impl<'a, K, V> OccupiedEntry<'a, K, V>
    {
        /// Returns a borrowed reference to the entry key.
        pub fn key(&self) -> &K 
        {
            &self.map.sequences[self.index].0
        
        }
        /// Returns a borrowed reference to the entry value.
        pub fn get(&self) -> &V 
        {
            &self.map.sequences[self.index].1
        }
        /// Returns a mutable reference to the entry value.
        pub fn get_mut(&mut self) -> &mut V 
        {
            &mut self.map.sequences[self.index].1
        }
        /// Converts the `OccupiedEntry` into a mutable reference whose lifetime is bound to the `SequenceMap`.
        pub fn into_mut(self) -> &'a mut V 
        {
            &mut self.map.sequences[self.index].1
        }
        /// Replaces the entry value with the given value, returning the previous value.
        pub fn insert(&mut self, value: V) -> V { ::mem::replace(self.get_mut(), value) }
        /// Removes the entry and returns the value.
        pub fn remove(self) -> V 
        {
            self.map.sequences.remove(self.index).1
        }
        /// Removes the entry and returns the key-value pair.
        pub fn remove_entry(self) -> (K, V) 
        {
            self.map.sequences.remove(self.index)
        }
    }

    impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for OccupiedEntry<'a, K, V>
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("OccupiedEntry")
                .field("key", self.key())
                .field("value", self.get())
                .finish()
        }
    }
    /// A view into a vacant entry in a `SequenceMap`.
    pub struct VacantEntry<'a, K: 'a, V: 'a>
    {
        map: &'a mut SequenceMap<K, V>,
        key: K,
        index: usize,
    }

    impl<'a, K, V> VacantEntry<'a, K, V>
    {
        /// Returns a borrowed reference to the entry key.
        pub fn key(&self) -> &K {
            &self.key
        }

        /// Consumes the `VacantEntry` and returns ownership of the key.
        pub fn into_key(self) -> K {
            self.key
        }

        /// Consumes the `VacantEntry` and inserts a value, returning a mutable
        /// reference to its place in the `SequenceMap`.
        pub fn insert(self, value: V) -> &'a mut V {
            self.map.sequences.insert(self.index, (self.key, value));
            &mut self.map.sequences[self.index].1
        }
    }

    impl<'a, K: fmt::Debug, V> fmt::Debug for VacantEntry<'a, K, V>
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_tuple("VacantEntry")
                .field(self.key())
                .finish()
        }
    }
    /// A view into a single entry of a `SequenceMap`, which may be either occupied or vacant.
    pub enum Entry<'a, K: 'a, V: 'a>
    {
        /// An occupied entry
        Occupied(OccupiedEntry<'a, K, V>),
        /// A vacant entry
        Vacant(VacantEntry<'a, K, V>),
    }

    impl<'a, K, V> Entry<'a, K, V>
    {
        /// Provides in-place mutable access to an occupied entry before any
        /// potential inserts into the map.
        pub fn and_modify<F: FnOnce(&mut V)>(self, f: F) -> Self {
            match self {
                Entry::Occupied(mut ent) => {
                    f(ent.get_mut());
                    Entry::Occupied(ent)
                }
                Entry::Vacant(ent) => Entry::Vacant(ent)
            }
        }

        /// Returns a mutable reference to the entry value,
        /// inserting the provided default if the entry is vacant.
        pub fn or_insert(self, default: V) -> &'a mut V {
            match self {
                Entry::Occupied(ent) => ent.into_mut(),
                Entry::Vacant(ent) => ent.insert(default)
            }
        }

        /// Returns a mutable reference to the entry value,
        /// inserting a value using the provided closure if the entry is vacant.
        pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
            match self {
                Entry::Occupied(ent) => ent.into_mut(),
                Entry::Vacant(ent) => ent.insert(default())
            }
        }

        /// Returns a borrowed reference to the entry key.
        pub fn key(&self) -> &K {
            match *self {
                Entry::Occupied(ref ent) => ent.key(),
                Entry::Vacant(ref ent) => ent.key(),
            }
        }
    }

    impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for Entry<'a, K, V>
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match *self {
                Entry::Occupied(ref ent) =>
                    f.debug_tuple("Entry")
                        .field(ent)
                        .finish(),
                Entry::Vacant(ref ent) =>
                    f.debug_tuple("Entry")
                        .field(ent)
                        .finish()
            }
        }
    }
    /// Contains a set of string sequences, mapped to a value.
    #[derive(Clone, Debug, Default)]
    pub struct SequenceMap<K, V>
    {
        sequences: Vec<(K, V)>,
    }

    impl<K: AsRef<str>, V> SequenceMap<K, V>
    {
        /// Creates an empty `SequenceMap`.
        pub fn new() -> SequenceMap<K, V> 
        {
            SequenceMap::with_capacity(0)
        }
        /// Creates an empty `SequenceMap` with allocated capacity for `n` elements.
        pub fn with_capacity(n: usize) -> SequenceMap<K, V> 
        {
            SequenceMap{
                sequences: Vec::with_capacity(n),
            }
        }
        /// Returns a slice of all contained sequences, sorted by key.
        pub fn sequences(&self) -> &[(K, V)] 
        {
            &self.sequences
        }
        /// Returns a mutable slice of all contained sequences, sorted by key.
        pub fn sequences_mut(&mut self) -> &mut [(K, V)] 
        {
            &mut self.sequences
        }
        /// Returns an `Entry` for the given key.
        pub fn entry(&mut self, key: K) -> Entry<K, V> 
        {
            match self.search(key.as_ref()) {
                Ok(n) => Entry::Occupied(OccupiedEntry{
                    map: self,
                    index: n,
                }),
                Err(n) => Entry::Vacant(VacantEntry{
                    map: self,
                    key,
                    index: n,
                })
            }
        }
        /// Performs a search for a partial or complete sequence match.
        pub fn find(&self, key: &str) -> FindResult<&V> 
        {
            let (n, found) = match self.search(key) {
                Ok(n) => (n, true),
                Err(n) => (n, false)
            };

            let incomplete = self.sequences.get(n + (found as usize))
                .map_or(false, |&(ref next, _)| next.as_ref().starts_with(key));

            match (found, incomplete) {
                (false, false) => FindResult::NotFound,
                (false, true) => FindResult::Incomplete,
                (true, false) => FindResult::Found(&self.sequences[n].1),
                (true, true) => FindResult::Undecided(&self.sequences[n].1),
            }
        }
        /// Returns the corresponding value for the given sequence.
        pub fn get(&self, key: &str) -> Option<&V> 
        {
            match self.search(key) {
                Ok(n) => Some(&self.sequences[n].1),
                Err(_) => None
            }
        }
        /// Returns a mutable reference to the corresponding value for the given sequence.
        pub fn get_mut(&mut self, key: &str) -> Option<&mut V> 
        {
            match self.search(key) {
                Ok(n) => Some(&mut self.sequences[n].1),
                Err(_) => None
            }
        }
        /// Inserts a key-value pair into the map.
        pub fn insert(&mut self, key: K, value: V) -> Option<V> 
        {
            match self.search(key.as_ref()) 
            {
                Ok(n) => Some( ::mem::replace(&mut self.sequences[n], (key, value)).1),
                Err(n) =>
                {
                    self.sequences.insert(n, (key, value));
                    None
                }
            }
        }
        /// Removes a key-value pair from the map.
        pub fn remove(&mut self, key: &str) -> Option<(K, V)> 
        {
            match self.search(key) {
                Ok(n) => Some(self.sequences.remove(n)),
                Err(_) => None
            }
        }

        fn search(&self, key: &str) -> Result<usize, usize> 
        {
            self.sequences.binary_search_by_key(&key, |&(ref k, _)| &k.as_ref())
        }
    }

    impl<K: AsRef<str>, V> From<Vec<(K, V)>> for SequenceMap<K, V>
    {
        /// Creates a `SequenceMap` from a `Vec` of key-value pairs.
        fn from(mut sequences: Vec<(K, V)>) -> SequenceMap<K, V>
        {
            sequences.sort_by(|a, b| a.0.as_ref().cmp(b.0.as_ref()));
            sequences.dedup_by(|a, b| a.0.as_ref() == b.0.as_ref());
            SequenceMap{sequences}
        }
    }

    impl<K: AsRef<str>, V> FromIterator<(K, V)> for SequenceMap<K, V>
    {
        /// Creates a `SequenceMap` from an iterator of key-value pairs.
        fn from_iter<I: IntoIterator<Item=(K, V)>>(iter: I) -> Self
        {
            let iter = iter.into_iter();
            let mut map = SequenceMap::with_capacity(iter.size_hint().0);

            for (k, v) in iter
            {
                map.insert(k, v);
            }

            map
        }
    }
}

pub mod command
{
    //! Defines the set of line editing commands
    use ::
    {
        borrow::Cow::{ self, Borrowed, Owned },
        char::{ escape_sequence },
        *,
    };
    
    macro_rules! define_commands
    {
        ( $( #[$meta:meta] $name:ident => $str:expr , )+ ) => {
            /// Represents a command to modify `Reader` state
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum Command {
                $( #[$meta] $name , )+
                /// Custom application-defined command
                Custom(Cow<'static, str>),
                /// Execute a given key sequence
                Macro(Cow<'static, str>),
            }

            /// List of all command names
            pub static COMMANDS: &[&str] = &[ $( $str ),+ ];

            impl fmt::Display for Command {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                    match *self {
                        $( Command::$name => f.write_str($str) , )+
                        Command::Custom(ref s) => f.write_str(s),
                        Command::Macro(ref s) => write!(f, "\"{}\"",
                            escape_sequence(s))
                    }
                }
            }

            impl Command {
                /// Constructs a command from a `'static str` reference.
                ///
                /// If the string does not refer to a built-in command, a value
                /// of `Command::Custom(Borrowed(name))` will be returned.
                pub fn from_str(name: &'static str) -> Command {
                    Command::opt_from_str(name)
                        .unwrap_or_else(|| Command::Custom(Borrowed(name)))
                }

                /// Constructs a command from a non-`'static` string-like type.
                ///
                /// If the string does not refer to a built-in command, a value
                /// of `Command::Custom(Owned(name.into()))` will be returned.
                pub fn from_string<T>(name: T) -> Command
                        where T: AsRef<str> + Into<String> {
                    Command::opt_from_str(name.as_ref())
                        .unwrap_or_else(|| Command::Custom(Owned(name.into())))
                }

                fn opt_from_str(s: &str) -> Option<Command> {
                    match s {
                        $( $str => Some(Command::$name), )+
                        _ => None
                    }
                }
            }
        }
    }

    define_commands!
    {
        /// Abort history search
        Abort => "abort",
        /// Accepts the current input line
        AcceptLine => "accept-line",
        /// Perform completion
        Complete => "complete",
        /// Insert all completions into the input buffer
        InsertCompletions => "insert-completions",
        /// Show possible completions
        PossibleCompletions => "possible-completions",
        /// Insert the next possible completion
        MenuComplete => "menu-complete",
        /// Insert the previous possible completion
        MenuCompleteBackward => "menu-complete-backward",
        /// Begin numeric argument input
        DigitArgument => "digit-argument",
        /// Insert character or sequence at the cursor
        SelfInsert => "self-insert",
        /// Inserts a tab character
        TabInsert => "tab-insert",
        /// Toggles insert/overwrite mode
        OverwriteMode => "overwrite-mode",
        /// Insert a comment and accept input
        InsertComment => "insert-comment",
        /// Move the cursor backward one character
        BackwardChar => "backward-char",
        /// Move the cursor forward one character
        ForwardChar => "forward-char",
        /// Search for a given character
        CharacterSearch => "character-search",
        /// Search backward for a given character
        CharacterSearchBackward => "character-search-backward",
        /// Move the cursor backward one word
        BackwardWord => "backward-word",
        /// Move the cursor forward one word
        ForwardWord => "forward-word",
        /// Kill all characters before the cursor
        BackwardKillLine => "backward-kill-line",
        /// Kill all characters after the cursor
        KillLine => "kill-line",
        /// Kill a word before the cursor
        BackwardKillWord => "backward-kill-word",
        /// Kill a word after the cursor
        KillWord => "kill-word",
        /// Kill a word before the cursor, delimited by whitespace
        UnixWordRubout => "unix-word-rubout",
        /// Clear the screen
        ClearScreen => "clear-screen",
        /// Move the cursor to the beginning of the line
        BeginningOfLine => "beginning-of-line",
        /// Move the cursor to the end of the line
        EndOfLine => "end-of-line",
        /// Delete one character before the cursor
        BackwardDeleteChar => "backward-delete-char",
        /// Delete one character after the cursor
        DeleteChar => "delete-char",
        /// Drag the character before the cursor forward
        TransposeChars => "transpose-chars",
        /// Drag the word before the cursor forward
        TransposeWords => "transpose-words",
        /// Move to the first line of history
        BeginningOfHistory => "beginning-of-history",
        /// Move to the last line of history
        EndOfHistory => "end-of-history",
        /// Select next line in history
        NextHistory => "next-history",
        /// Select previous line in history
        PreviousHistory => "previous-history",
        /// Incremental search in history
        ForwardSearchHistory => "forward-search-history",
        /// Incremental reverse search in history
        ReverseSearchHistory => "reverse-search-history",
        /// Non-incremental forward history search using input up to the cursor
        HistorySearchForward => "history-search-forward",
        /// Non-incremental backward history search using input up to the cursor
        HistorySearchBackward => "history-search-backward",
        /// Insert literal character
        QuotedInsert => "quoted-insert",
        /// Insert text into buffer from the kill ring
        Yank => "yank",
        /// Rotate the kill ring and yank the new top
        YankPop => "yank-pop",
    }
    /// Describes the category of a command.
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum Category
    {
        /// Completion command
        Complete,
        /// Kill command
        Kill,
        /// Non-incremental search command
        Search,
        /// Incremental search command
        IncrementalSearch,
        /// Yank command
        Yank,
        /// Digit argument command
        Digit,
        /// Other command
        Other,
    }

    impl Command
    {
        /// Returns the category of the command
        pub fn category(&self) -> Category
        {
            use self::Command::*;

            match *self
            {
                DigitArgument => Category::Digit,
                
                Complete | InsertCompletions | PossibleCompletions | MenuComplete | MenuCompleteBackward => 
                Category::Complete,

                BackwardKillLine | KillLine | BackwardKillWord | KillWord | UnixWordRubout => Category::Kill,
                
                ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                HistorySearchForward | HistorySearchBackward => Category::Search,

                Yank | YankPop => Category::Yank,
                _ => Category::Other
            }
        }
    }
}

pub mod complete
{
    //! Provides utilities for implementing word completion
    use ::
    {
        borrow::{ Cow::{ self, Borrowed, Owned }, },
        fs::{ read_dir },
        path::{ is_separator, MAIN_SEPARATOR },
        prompt::{ Prompter },
        terminal::{ Terminals },
        *,
    };

    pub struct ShellCompleter
    {
        pub sh: Arc<shell::Shell>,
    }
    /// Represents a single possible completion
    #[derive(Clone, Debug)]
    pub struct Completion
    {
        /// Whole completion text
        pub completion: String,
        /// Listing display string; `None` if matches completion
        pub display: Option<String>,
        /// Completion suffix; replaces append character
        pub suffix: Suffix,
    }
    /// Specifies an optional suffix to override the default value
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum Suffix
    {
        /// Use the default suffix
        Default,
        /// Use no suffix
        None,
        /// Use the given suffix
        Some(char),
    }

    impl Completion
    {
        /// Returns a simple `Completion` value, 
        /// with display string matching completion and using the default completion suffix.
        pub fn simple(s: String) -> Completion
        {
            Completion
            {
                completion: s,
                display: None,
                suffix: Suffix::default(),
            }
        }
        /// Returns the full completion string, including suffix,
        /// using the given default suffix if one is not assigned to this completion.
        pub fn completion(&self, def_suffix: Option<char>) -> Cow<str>
        {
            let mut s = Borrowed(&self.completion[..]);
            if let Some(suffix) = self.suffix.with_default(def_suffix)
            {
                s.to_mut().push(suffix);
            }

            s
        }
        /// Returns the display string, including suffix
        pub fn display(&self) -> Cow<str>
        {
            let mut s = Borrowed(self.display_str());

            if let Suffix::Some(suffix) = self.suffix { s.to_mut().push(suffix); }

            s
        }
        /// Returns the number of characters displayed
        pub fn display_chars(&self) -> usize
        {
            let n = self.display_str().chars().count();
            n + if self.suffix.is_some() { 1 } else { 0 }
        }

        fn display_str(&self) -> &str
        {
            match self.display
            {
                Some(ref dis) => dis,
                None => &self.completion
            }
        }
    }

    impl Suffix
    {
        /// Returns whether the `Suffix` value is the `Default` variant.
        pub fn is_default(&self) -> bool
        {
            match *self
            {
                Suffix::Default => true,
                _ => false
            }
        }
        /// Returns whether the `Suffix` value is the `Some(_)` variant.
        pub fn is_some(&self) -> bool
        {
            match *self
            {
                Suffix::Some(_) => true,
                _ => false
            }
        }
        /// Returns whether the `Suffix` value is the `None` variant.
        pub fn is_none(&self) -> bool
        {
            match *self
            {
                Suffix::None => true,
                _ => false
            }
        }
        /// Returns an `Option<char>`, using the given value in place of `Default`.
        pub fn with_default(self, default: Option<char>) -> Option<char>
        {
            match self
            {
                Suffix::None => None,
                Suffix::Some(ch) => Some(ch),
                Suffix::Default => default
            }
        }
    }

    impl Default for Suffix
    {
        fn default() -> Suffix
        {
            Suffix::Default
        }
    }
    /// Performs completion for `Prompter` when triggered by a user input sequence
    pub trait Completer<Term: Terminals>: Send + Sync
    {
        /// Returns the set of possible completions for the prefix `word`.
        fn complete(&self, word: &str, prompter: &Prompter<Term>, start: usize, end: usize) -> Option<Vec<Completion>>;
        /// Returns the starting position of the word under the cursor.
        fn word_start(&self, line: &str, end: usize, prompter: &Prompter<Term>) -> usize
        { word_break_start(&line[..end], prompter.word_break_chars()) }
        /// Quotes a possible completion for insertion into input.
        fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
        /// Unquotes a piece of user input before searching for completions.
        fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
    }
    /// `Completer` type that performs no completion.
    pub struct DummyCompleter;

    impl<T: Terminals> Completer<T> for DummyCompleter
    {
        fn complete( &self, _word: &str, _reader: &Prompter<T>, _start: usize, _end: usize) -> Option<Vec<Completion>>
        { None }
    }
    /// Performs completion by searching for filenames matching the word prefix.
    pub struct PathCompleter;

    impl<T:Terminals> Completer<T> for PathCompleter
    {
        fn complete(&self, word: &str, _reader: &Prompter<T>, _start: usize, _end: usize) -> Option<Vec<Completion>>
        { Some(complete_path(word)) }

        fn word_start(&self, line: &str, end: usize, _reader: &Prompter<T>) -> usize 
        { escaped_word_start(&line[..end]) }

        fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { escape(word) }

        fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { unescape(word) }
    }
    /// Returns a sorted list of paths whose prefix matches the given path.
    pub fn complete_path(path: &str) -> Vec<Completion>
    {
        let (base_dir, fname) = split_path(path);
        let mut res = Vec::new();

        let lookup_dir = base_dir.unwrap_or(".");

        if let Ok(list) = read_dir(lookup_dir)
        {
            for ent in list {
                if let Ok(ent) = ent {
                    let ent_name = ent.file_name();

                    // TODO: Deal with non-UTF8 paths in some way
                    if let Ok(path) = ent_name.into_string() {
                        if path.starts_with(fname) {
                            let (name, display) = if let Some(dir) = base_dir {
                                (format!("{}{}{}", dir, MAIN_SEPARATOR, path),
                                    Some(path))
                            } else {
                                (path, None)
                            };

                            let is_dir = ent.metadata().ok()
                                .map_or(false, |m| m.is_dir());

                            let suffix = if is_dir {
                                Suffix::Some(MAIN_SEPARATOR)
                            } else {
                                Suffix::Default
                            };

                            res.push(Completion{
                                completion: name,
                                display: display,
                                suffix: suffix,
                            });
                        }
                    }
                }
            }
        }

        res.sort_by(|a, b| a.display_str().cmp(b.display_str()));
        res
    }
    /// Returns the start position of the word that ends at the end of the string.
    pub fn word_break_start(s: &str, word_break: &str) -> usize
    {
        let mut start = s.len();

        for (idx, ch) in s.char_indices().rev()
        {
            if word_break.contains(ch) { break; }
            start = idx;
        }

        start
    }
    /// Returns the start position of a word with non-word characters escaped by backslash (`\\`).
    pub fn escaped_word_start(s: &str) -> usize
    {
        let mut chars = s.char_indices().rev();
        let mut start = s.len();

        while let Some((idx, ch)) = chars.next()
        {
            if needs_escape(ch) {
                let n = {
                    let mut n = 0;

                    loop {
                        let mut clone = chars.clone();

                        let ch = match clone.next() {
                            Some((_, ch)) => ch,
                            None => break
                        };

                        if ch == '\\' {
                            chars = clone;
                            n += 1;
                        } else {
                            break;
                        }
                    }

                    n
                };

                if n % 2 == 0 {
                    break;
                }
            }

            start = idx;
        }

        start
    }
    /// Escapes a word by prefixing a backslash (`\\`) to non-word characters.
    pub fn escape(s: &str) -> Cow<str>
    {
        let n = s.chars().filter(|&ch| needs_escape(ch)).count();

        if n == 0 {
            Borrowed(s)
        } else {
            let mut res = String::with_capacity(s.len() + n);

            for ch in s.chars() {
                if needs_escape(ch) {
                    res.push('\\');
                }
                res.push(ch);
            }

            Owned(res)
        }
    }
    /// Unescapes a word by removing the backslash (`\\`) from escaped characters.
    pub fn unescape(s: &str) -> Cow<str>
    {
        if s.contains('\\') {
            let mut res = String::with_capacity(s.len());
            let mut chars = s.chars();

            while let Some(ch) = chars.next() {
                if ch == '\\' {
                    if let Some(ch) = chars.next() {
                        res.push(ch);
                    }
                } else {
                    res.push(ch);
                }
            }

            Owned(res)
        } else {
            Borrowed(s)
        }
    }

    fn needs_escape(ch: char) -> bool
    {
        match ch {
            ' ' | '\t' | '\n' | '\\' => true,
            _ => false
        }
    }

    fn split_path(path: &str) -> (Option<&str>, &str)
    {
        match path.rfind(is_separator)
        {
            Some(pos) => (Some(&path[..pos]), &path[pos + 1..]),
            None => (None, path)
        }
    }
}

pub mod database
{
    use ::
    {
        path::{ Path },
        *,
    };

    pub fn initialize(hfile: &str, htable: &str)
    {
        let path = Path::new(hfile);
        
        if !path.exists()
        {
            let _parent = match path.parent()
            {
                Some(x) => x,
                None =>
                {
                    println_stderr!("cicada: history init - no parent found");
                    return;
                }
            };

            let parent = match _parent.to_str()
            {
                Some(x) => x,
                None =>
                {
                    println_stderr!("cicada: parent to_str is None");
                    return;
                }
            };

            match fs::create_dir_all(parent)
            {
                Ok(_) => {}
                Err(e) =>
                {
                    println_stderr!("cicada: histdir create error: {}", e);
                    return;
                }
            }
            
            match fs::File::create(hfile)
            {
                Ok(_) => { println!("cicada: created history file: {}", hfile); }
                Err(e) => { println_stderr!("cicada: history: file create failed: {}", e); }
            }
        }

        let conn = match Conn::open(hfile)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: history: open db error: {}", e);
                return;
            }
        };
        
        let sql = format!
        (
        "
            CREATE TABLE IF NOT EXISTS {}
            (
                inp TEXT,
                rtn INTEGER,
                tsb REAL,
                tse REAL,
                sessionid TEXT,
                out TEXT,
                info TEXT
            );
        ",
            htable
        );

        match conn.execute(&sql, [])
        {
            Ok(_) => {}
            Err(e) => println_stderr!("cicada: history: query error: {}", e),
        }
    }
}

pub mod env
{
    pub use std::env::{ * };

    use ::
    {
        path::{ Path },
        *,
    };

    pub fn initialize_paths()
    {
        let mut paths: Vec<String> = vec![];
        
        for x in
        [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ]
        {
            if Path::new(x).exists(){ paths.push(x.to_string()); }
        }

        if let Ok(env_path) = var("PATH")
        {
            for x in env_path.split(":")
            {
                if !paths.contains(&x.to_string())
                {
                    paths.push(x.to_string());
                }
            }
        }

        let paths = paths.join(":");
        set_var("PATH", paths);
    }
    /*
    pub fn env_args_to_command_line() -> String */
    pub fn args_to_command_line() -> String
    {
        let mut result = String::new();
        let env_args = args();
        
        if env_args.len() <= 1 { return result; }

        for (i, arg) in env_args.enumerate()
        {
            if i == 0 || arg == "-c" { continue; }

            result.push_str(arg.as_str());
        }

        result
    }

    pub fn get_user_home() -> String
    {
        match var("HOME")
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("pls: env HOME error: {}", e);
                String::new()
            }
        }
    }
}

pub mod expand
{
    use ::
    {
        regex::{ contains, Regex },
        *,
    };
    /*
    pub fn extend_bangbang(sh: &shell::Shell, line: &mut String) */
    pub fn bangbang(sh: &shell::Shell, line: &mut String)
    {
        if !contains(line, r"!!") { return; }
        
        if sh.previous_cmd.is_empty() { return; }

        let re = Regex::new(r"!!").unwrap();
        let mut replaced = false;
        let mut new_line = String::new();
        let linfo = parsers::line::parse(line);

        for (sep, token) in linfo.tokens
        {
            if !sep.is_empty() { new_line.push_str(&sep); }

            if re_contains(&token, r"!!") && sep != "'"
            {
                let line2 = token.clone();
                let result = re.replace_all(&line2, sh.previous_cmd.as_str());
                new_line.push_str(&result);
                replaced = true;
            }
            else { new_line.push_str(&token); }

            if !sep.is_empty() { new_line.push_str(&sep); }

            new_line.push(' ');
        }

        *line = new_line.trim_end().to_string();
        
        if replaced { println!("{}", line); }
    }
}

pub mod ffi
{
    pub use std::ffi::{ * };
    use ::
    {
        command::{ Category },
        io::{ self, BufRead, BufReader, BufWriter, Read as _, Seek, SeekFrom, Write as _, },
        prompt::{ Prompter },
        reader::{ Read, Reader },
        writer::{ Write, Writer },
        terminal::{ Terminals },
        sync::{ Mutex },
        *,
    };
    /// The main interface to input reading and other terminal operations.
    pub struct Interface<Term:Terminals>
    {
        term: Term,
        write: Mutex<Write>,
        read: Mutex<Read<Term>>,
    }
    /// Implements custom functionality for a `Prompter` command
    pub trait Function<Term: Terminals>: Send + Sync
    {
        /// Executes the function.
        fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()>;
        /// Returns the command category.
        fn category(&self) -> Category { Category::Other }
    }

    impl<F, Term:Terminals> Function<Term> for F where
    F: Send + Sync,
    F: Fn(&mut Prompter<Term>, i32, char) -> io::Result<()>
    {
        fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()>
        { 
            self(prompter, count, ch)
        }
    }

    pub struct EnterFunction;

    impl<T:Terminals> Function<T> for EnterFunction
    {
        fn execute(&self, prompter: &mut Prompter<T>, count: i32, _ch: char) -> ::io::Result<()>
        {
            let buf = prompter.buffer();
            let linfo = ::parsers::line::parse(buf);

            if linfo.is_complete { prompter.accept_input() }
            else if count > 0
            {
                match prompter.insert(count as usize, '\n')
                {
                    Ok(_) => {},
                    Err(e) => { println!("sub-prompt error: {}", e); }
                }

                prompter.insert_str(">> ")
            }
            else { Ok(()) }
        }
    }
}

pub mod filter
{
    use ::
    {
        borrow::{ Cow },
        reader::{START_INVISIBLE, END_INVISIBLE},
        *,
    };

    pub fn visible(s: &str) -> Cow<str>
    {
        if !s.contains(START_INVISIBLE) { return Cow::Borrowed(s); }

        let mut virt = String::new();
        let mut ignore = false;

        for ch in s.chars()
        {
            if ch == START_INVISIBLE { ignore = true; }
            else if ch == END_INVISIBLE { ignore = false; }
            else if !ignore { virt.push(ch); }
        }

        Cow::Owned(virt)
    }
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod fs
{
    pub use std::fs::{ * };
    use ::
    {
        path::{ Path },
        *,
    };
    /*
    use crate::scripting;
    use crate::shell;
    use crate::tools;
    */
    pub fn get_rc_file() -> String 
    {
        let dir_config = tools::get_config_dir();
        let rc_file = format!("{}/cicadarc", dir_config);
        if Path::new(&rc_file).exists() {
            return rc_file;
        }

        // fail back to $HOME/.cicadarc
        let home = tools::get_user_home();
        let rc_file_home = format!("{}/{}", home, ".cicadarc");
        if Path::new(&rc_file_home).exists() {
            return rc_file_home;
        }

        // use std path if both absent
        rc_file
    }

    pub fn load_rc_files(sh: &mut shell::Shell)
    {
        let rc_file = get_rc_file();

        if !Path::new(&rc_file).exists() { return; }

        let args = vec!["source".to_string(), rc_file];
        scripts::run(sh, &args);
    }
}

pub mod history
{
    use ::
    {
        collections::{ HashMap },
        ffi::{ Interface },
        path::{ Path },
        *,
    };

    pub fn add(sh: &shell::Shell, rl: &mut Interface<DefaultTerminal>, line: &str, status: i32, tsb: f64, tse: f64)
    {
        add_raw(sh, line, status, tsb, tse);
        rl.add_history(line.to_string());
    }

    pub fn initialize(rl: &mut Interface<DefaultTerminal>)
    {
        let mut hist_size: usize = 99999;
        
        if let Ok(x) = env::var("HISTORY_SIZE")
        {
            if let Ok(y) = x.parse::<usize>() { hist_size = y; }
        }

        rl.set_history_size(hist_size);

        let history_table = get_history_table();
        let hfile = get_history_file();

        if !Path::new(&hfile).exists() { ::database::initialize(&hfile, &history_table); }

        let mut delete_dups = true;

        if let Ok(x) = env::var("HISTORY_DELETE_DUPS")
        {
            if x == "0" { delete_dups = false; }
        }

        if delete_dups { delete_duplicated_histories(); }

        let conn = match Conn::open(&hfile)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };

        let sql = format!("SELECT inp FROM {} ORDER BY tsb;", history_table);
        let mut stmt = match conn.prepare(&sql)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: prepare select error: {}", e);
                return;
            }
        };

        let rows = match stmt.query_map([], |row| row.get(0))
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: query select error: {}", e);
                return;
            }
        };

        let mut dict_helper: HashMap<String, bool> = HashMap::new();

        for x in rows.flatten()
        {
            let inp: String = x;
            
            if dict_helper.contains_key(&inp) { continue; }

            dict_helper.insert(inp.clone(), true);
            rl.add_history(inp.trim().to_string());
        }
    }
}

pub mod io
{
    pub use std::io::{ * };
} use std::io::Write as _;

pub mod is
{
    use ::
    {
        regex::{ contains },
        *,
    };
    /*
    pub fn is_shell_altering_command(...) -> bool */
    pub fn shell_altering_command( line: &str ) -> bool
    {
        let line = line.trim();
        
        if ::regex::contains(line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$") { return true; }

        line.starts_with("alias ")
        || line.starts_with("export ")
        || line.starts_with("unalias ")
        || line.starts_with("unset ")
        || line.starts_with("source ")
    }
    /*
    pub fn is_signal_handler_enabled() -> bool */
    pub fn signal_handler_enabled() -> bool
    {
        ::env::var("CICADA_ENABLE_SIG_HANDLER").map_or(false, |x| x == "1")
    }
    /*
    pub fn is_non_tty() -> bool */
    pub fn non_tty() -> bool { unsafe { libc::isatty(0) == 0 } }
    /*
    pub fn is_command_string(...) -> bool */
    pub fn command_string(args: &[String]) -> bool { args.len() > 1 && args[1] == "-c" }
    /*
    pub fn is_script(...) -> bool */
    pub fn script(args: &[String]) -> bool { args.len() > 1 && !args[1].starts_with("-") }
    /*
    pub fn is_login(...) -> bool */
    pub fn login(args: &[String]) -> bool
    {
        if !args.is_empty() && args[0].starts_with("-") {
            return true;
        }

        if args.len() > 1 && (args[1] == "--login" || args[1] == "-l") {
            return true;
        }

        if let Ok(term_program) = std::env::var("TERM_PROGRAM") {
            if term_program == "vscode" {
                return true;
            }
        }

        false
    }
    /*
    pub fn is_combining_mark(...) -> bool */
    /// Returns whether the given character is a combining mark.
    #[inline] pub fn combining_mark(ch: char) -> bool
    {
        use unicode_normalization::char::is_combining_mark;
        is_combining_mark(ch)
    }
    /*
    pub fn is_wide( ... ) -> bool */
    pub fn wide(ch: char) -> bool
    {
        ::char::width(ch) == Some(2)
    }
    /*
    pub fn is_arithmetic( ... ) -> bool */
    pub fn arithmetic(line: &str) -> bool
    {
        if !contains(line, r"[0-9]+") { return false; }

        if !contains(line, r"\+|\-|\*|/|\^") { return false; }
        
        contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$")
    }
}

pub mod iter
{
    pub use std::iter::{ * };
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod net
{
    pub use std::net::{ * };
}

pub mod now
{
    use ::
    {
        shell::{ Shell },
        types::{ CommandResult },
        *,
    };
    
    pub fn run_command_line(sh: &mut Shell, line: &str, tty: bool, capture: bool) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();

        for token in parsers::line::to_cmds(line)
        {
            if token == ";" || token == "&&" || token == "||"
            {
                sep = token.clone();
                continue;
            }

            if sep == "&&" && status != 0 { break; }

            if sep == "||" && status == 0 { break; }

            let cmd = token.clone();
            let cr = ::process::run(sh, &cmd, tty, capture);
            status = cr.status;
            sh.previous_status = status;
            cr_list.push(cr);
        }

        cr_list
    }
    /// Entry point for non-ttys (e.g. Cmd-N on MacVim)
    pub fn run_procs_for_non_tty(sh: &mut Shell)
    {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();
        match handle.read_to_string(&mut buffer)
        {
            Ok(_) =>
            {
                log!("run non tty command: {}", &buffer);
                run_command_line(sh, &buffer, false, false);
            }

            Err(e) => { println!("cicada: stdin.read_to_string() failed: {:?}", e); }
        }
    }
}

pub mod num
{
    pub use std::num::{ * };

    pub trait NotAllOnesHelper
    {
        type Type;
    }

    pub type NotAllOnes<T> = <T as NotAllOnesHelper>::Type;

    impl NotAllOnesHelper for u32 { type Type = U32NotAllOnes; }

    impl NotAllOnesHelper for i32 { type Type = I32NotAllOnes; }
    
    impl NotAllOnesHelper for u64 { type Type = U64NotAllOnes; }
    
    impl NotAllOnesHelper for i64 { type Type = I64NotAllOnes; }
}

pub mod ops 
{
    pub use std::ops::{ * };
}

pub mod os
{
    pub mod raw
    {
        pub use std::os::raw::{ * };
    }

    pub mod fd
    {
        //! Owned and borrowed Unix-like file descriptors.
        /// Implementations for `AsRawFd` etc. for network types.
        pub mod net
        {
            use ::
            {
                os::fd::
                {
                    owned::{ OwnedFd },
                    raw::{ AsRawFd, FromRawFd, IntoRawFd, RawFd },
                },
                sys::common::{ AsInner, FromInner, IntoInner },
                *,
            };

            macro_rules! impl_as_raw_fd
            {
                ($($t:ident)*) => {$
                (
                    impl AsRawFd for net::$t 
                    {
                        #[inline] fn as_raw_fd(&self) -> RawFd { self.as_inner().socket().as_raw_fd() }
                    }
                )*};
            }
            impl_as_raw_fd! { TcpStream TcpListener UdpSocket }

            macro_rules! impl_from_raw_fd 
            {
                ($($t:ident)*) => {$(
                    impl FromRawFd for net::$t {
                        #[inline]
                        unsafe fn from_raw_fd(fd: RawFd) -> net::$t {
                            unsafe {
                                let socket = sys::net::Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd)));
                                net::$t::from_inner(sys::net::$t::from_inner(socket))
                            }
                        }
                    }
                )*};
            }
            impl_from_raw_fd! { TcpStream TcpListener UdpSocket }

            macro_rules! impl_into_raw_fd
            {
                ($($t:ident)*) => {$(
                    impl IntoRawFd for net::$t {
                        #[inline]
                        fn into_raw_fd(self) -> RawFd {
                            self.into_inner().into_socket().into_inner().into_inner().into_raw_fd()
                        }
                    }
                )*};
            }
            impl_into_raw_fd! { TcpStream TcpListener UdpSocket }
        }
        /// `OwnedFd`, `AsFd`, etc.
        pub mod owned
        {
            use ::
            {
                marker::PhantomData,
                mem::ManuallyDrop,
                sys::common::{AsInner, FromInner, IntoInner},
                *,
            };
            
            type ValidRawFd = num::NotAllOnes<RawFd>;

            /// A borrowed file descriptor.
            #[repr( transparent )] #[derive( Copy, Clone )]
            pub struct BorrowedFd<'fd>
            {
                fd: ValidRawFd,
                _phantom: PhantomData<&'fd OwnedFd>,
            }
            /// An owned file descriptor.
            #[repr(transparent)]
            pub struct OwnedFd
            {
                fd: ValidRawFd,
            }

            impl BorrowedFd<'_>
            {
                /// Returns a `BorrowedFd` holding the given raw file descriptor.
                #[inline] #[track_caller] pub const unsafe fn borrow_raw(fd: RawFd) -> Self
                {
                    Self { fd: ValidRawFd::new(fd).expect("fd != -1"), _phantom: PhantomData }
                }
            }

            impl OwnedFd
            {
                /// Creates a new `OwnedFd` instance that shares the same underlying file description as the existing `OwnedFd` instance.
                pub fn try_clone(&self) -> crte::io::Result<Self> { self.as_fd().try_clone_to_owned() }
            }

            impl BorrowedFd<'_>
            {
                /// Creates a new `OwnedFd` instance that shares the same underlying file description as the existing `BorrowedFd` instance.
                pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedFd>
                {
                    let cmd = libc::F_DUPFD_CLOEXEC;
                    let cmd = libc::F_DUPFD;
                    let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 3) })?;
                    Ok(unsafe { OwnedFd::from_raw_fd(fd) })
                }
            }
            
            impl AsRawFd for BorrowedFd<'_>
            {
                #[inline] fn as_raw_fd(&self) -> RawFd { self.fd.as_inner() }
            }
            
            impl AsRawFd for OwnedFd
            {
                 fn as_raw_fd(&self) -> RawFd { self.fd.as_inner() }
            }
            
            impl IntoRawFd for OwnedFd
            {
                #[inline] fn into_raw_fd(self) -> RawFd { ManuallyDrop::new(self).fd.as_inner() }
            }
            
            impl FromRawFd for OwnedFd
            {
                /// Constructs a new instance of `Self` from the given raw file descriptor.
                #[inline] #[track_caller]
                unsafe fn from_raw_fd(fd: RawFd) -> Self { Self { fd: ValidRawFd::new(fd).expect("fd != -1") } }
            }
            
            impl Drop for OwnedFd
            {
                #[inline] fn drop(&mut self)
                {
                    unsafe
                    {
                        ::sys::fs::debug_assert_fd_is_open(self.fd.as_inner());
                        let _ = libc::close(self.fd.as_inner());
                    }
                }
            }
            
            impl fmt::Debug for BorrowedFd<'_>
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    f.debug_struct("BorrowedFd").field("fd", &self.fd).finish()
                }
            }
            
            impl fmt::Debug for OwnedFd
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    f.debug_struct("OwnedFd").field("fd", &self.fd).finish()
                }
            }

            macro_rules! impl_is_terminal
            {
                ($($t:ty),*$(,)?) => {$
                (
                    impl ::sealed::Sealed for $t {}
                    
                    impl ::io::IsTerminal for $t
                    {
                        #[inline] fn is_terminal(&self) -> bool { ::sys::io::is_terminal(self) }
                    }
                )*}
            }

            impl_is_terminal!(BorrowedFd<'_>, OwnedFd);
            /// A trait to borrow the file descriptor from an underlying object.
            pub trait AsFd
            {
                /// Borrows the file descriptor.
                fn as_fd(&self) -> BorrowedFd<'_>;
            }
            
            impl<T: AsFd + ?Sized> AsFd for &T
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> { T::as_fd(self) }
            }
            
            impl<T: AsFd + ?Sized> AsFd for &mut T
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> { T::as_fd(self) }
            }
            
            impl AsFd for BorrowedFd<'_>
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> { *self }
            }

            impl AsFd for OwnedFd
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> { unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) } }
            }
            
            impl AsFd for fs::File
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_>
                {
                    self.as_inner().as_fd()
                }
            }
            
            impl From<fs::File> for OwnedFd
            {
                /// Takes ownership of a [`File`](fs::File)'s underlying file descriptor.
                #[inline] fn from(file: fs::File) -> OwnedFd
                {
                    file.into_inner().into_inner().into_inner()
                }
            }
            
            impl From<OwnedFd> for fs::File
            {
                /// Returns a [`File`](fs::File) that takes ownership of the given file descriptor.
                #[inline] fn from(owned_fd: OwnedFd) -> Self
                {
                    Self::from_inner(FromInner::from_inner(FromInner::from_inner(owned_fd)))
                }
            }
            
            impl AsFd for ::net::TcpStream
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_>
                {
                    self.as_inner().socket().as_fd()
                }
            }
            
            impl From<::net::TcpStream> for OwnedFd
            {
                /// Takes ownership of a [`TcpStream`](::net::TcpStream)'s socket file descriptor.
                #[inline] fn from(tcp_stream: ::net::TcpStream) -> OwnedFd
                {
                    tcp_stream.into_inner().into_socket().into_inner().into_inner().into()
                }
            }
            
            impl From<OwnedFd> for ::net::TcpStream
            {
                #[inline] fn from(owned_fd: OwnedFd) -> Self
                {
                    Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(
                        owned_fd,
                    ))))
                }
            }
            
            impl AsFd for ::net::TcpListener
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_>
                {
                    self.as_inner().socket().as_fd()
                }
            }
            
            impl From<::net::TcpListener> for OwnedFd
            {
                /// Takes ownership of a [`TcpListener`](::net::TcpListener)'s socket file descriptor.
                #[inline] fn from(tcp_listener: ::net::TcpListener) -> OwnedFd
                {
                    tcp_listener.into_inner().into_socket().into_inner().into_inner().into()
                }
            }
            
            impl From<OwnedFd> for ::net::TcpListener
            {
                #[inline] fn from(owned_fd: OwnedFd) -> Self
                {
                    Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(
                        owned_fd,
                    ))))
                }
            }
            
            impl AsFd for ::net::UdpSocket
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_>
                {
                    self.as_inner().socket().as_fd()
                }
            }
            
            impl From<::net::UdpSocket> for OwnedFd
            {
                /// Takes ownership of a [`UdpSocket`](::net::UdpSocket)'s file descriptor.
                #[inline] fn from(udp_socket: ::net::UdpSocket) -> OwnedFd
                {
                    udp_socket.into_inner().into_socket().into_inner().into_inner().into()
                }
            }
            
            impl From<OwnedFd> for ::net::UdpSocket
            {
                #[inline] fn from(owned_fd: OwnedFd) -> Self
                {
                    Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(
                        owned_fd,
                    ))))
                }
            }
            /// This impl allows implementing traits that require `AsFd` on Arc.
            impl<T: AsFd + ?Sized> AsFd for ::sync::Arc<T>
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    (**self).as_fd()
                }
            }
            
            impl<T: AsFd + ?Sized> AsFd for ::rc::Rc<T> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    (**self).as_fd()
                }
            }
            
            impl<T: AsFd + ?Sized> AsFd for ::rc::UniqueRc<T> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    (**self).as_fd()
                }
            }
            
            impl<T: AsFd + ?Sized> AsFd for Box<T> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    (**self).as_fd()
                }
            }
            
            impl AsFd for io::Stdin 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    unsafe { BorrowedFd::borrow_raw(0) }
                }
            }
            
            impl<'a> AsFd for io::StdinLock<'a> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    // SAFETY: user code should not close stdin out from under the standard library
                    unsafe { BorrowedFd::borrow_raw(0) }
                }
            }
            
            impl AsFd for io::Stdout 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    unsafe { BorrowedFd::borrow_raw(1) }
                }
            }
            
            impl<'a> AsFd for io::StdoutLock<'a> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    // SAFETY: user code should not close stdout out from under the standard library
                    unsafe { BorrowedFd::borrow_raw(1) }
                }
            }
            
            impl AsFd for io::Stderr 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    unsafe { BorrowedFd::borrow_raw(2) }
                }
            }
            
            impl<'a> AsFd for io::StderrLock<'a> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    // SAFETY: user code should not close stderr out from under the standard library
                    unsafe { BorrowedFd::borrow_raw(2) }
                }
            }
            
            impl AsFd for io::PipeReader 
            {
                fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    self.0.as_fd()
                }
            }
            
            impl From<io::PipeReader> for OwnedFd 
            {
                fn from(pipe: io::PipeReader) -> Self 
                {
                    pipe.0.into_inner()
                }
            }
            
            impl AsFd for io::PipeWriter 
            {
                fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    self.0.as_fd()
                }
            }
            
            impl From<io::PipeWriter> for OwnedFd 
            {
                fn from(pipe: io::PipeWriter) -> Self 
                {
                    pipe.0.into_inner()
                }
            }
            
            impl From<OwnedFd> for io::PipeReader
            {
                fn from(owned_fd: OwnedFd) -> Self {
                    Self(FromInner::from_inner(owned_fd))
                }
            }
            
            impl From<OwnedFd> for io::PipeWriter
            {
                fn from(owned_fd: OwnedFd) -> Self
                {
                    Self(FromInner::from_inner(owned_fd))
                }
            }
        } pub use  self::owned::*;
        /// `RawFd`, `AsRawFd`, etc.
        pub mod raw
        {
            use ::
            {
                os::
                {
                    raw,
                    unix::
                    {
                        io::{ AsFd, OwnedFd },
                    },
                }
                sys::common::{AsInner, FromInner, IntoInner},
                *,
            };
            /// Raw file descriptors.
            pub type RawFd = raw::c_int;
            /// A trait to extract the raw file descriptor from an underlying object.
            pub trait AsRawFd
            {
                /// Extracts the raw file descriptor.
                fn as_raw_fd(&self) -> RawFd;
            }
            /// A trait to express the ability to construct an object from a raw file descriptor.
            pub trait FromRawFd
            {
                /// Constructs a new instance of `Self` from the given raw file descriptor.
                unsafe fn from_raw_fd(fd: RawFd) -> Self;
            }
            /// A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.
            pub trait IntoRawFd
            {
                /// Consumes this object, returning the raw underlying file descriptor.
                fn into_raw_fd(self) -> RawFd;
            }
            
            impl AsRawFd for RawFd 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    *self
                }
            }
            
            impl IntoRawFd for RawFd 
            {
                #[inline] fn into_raw_fd(self) -> RawFd 
                {
                    self
                }
            }
            
            impl FromRawFd for RawFd 
            {
                #[inline] unsafe fn from_raw_fd(fd: RawFd) -> RawFd 
                {
                    fd
                }
            }
            
            impl AsRawFd for fs::File 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    self.as_inner().as_raw_fd()
                }
            }
            
            impl FromRawFd for fs::File 
            {
                #[inline] unsafe fn from_raw_fd(fd: RawFd) -> fs::File 
                {
                    unsafe { fs::File::from(OwnedFd::from_raw_fd(fd)) }
                }
            }
            
            impl IntoRawFd for fs::File 
            {
                #[inline] fn into_raw_fd(self) -> RawFd 
                {
                    self.into_inner().into_inner().into_raw_fd()
                }
            }
            
            impl AsRawFd for io::Stdin 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDIN_FILENO
                }
            }
            
            impl AsRawFd for io::Stdout 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDOUT_FILENO
                }
            }
            
            impl AsRawFd for io::Stderr 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDERR_FILENO
                }
            }
            
            impl<'a> AsRawFd for io::StdinLock<'a> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDIN_FILENO
                }
            }
            
            impl<'a> AsRawFd for io::StdoutLock<'a> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDOUT_FILENO
                }
            }
            
            impl<'a> AsRawFd for io::StderrLock<'a> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDERR_FILENO
                }
            }
            /// This impl allows implementing traits that require `AsRawFd` on Arc.
            impl<T: AsRawFd> AsRawFd for ::sync::Arc<T> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    (**self).as_raw_fd()
                }
            }
            
            impl<T: AsRawFd> AsRawFd for ::rc::Rc<T> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    (**self).as_raw_fd()
                }
            }
            
            impl<T: AsRawFd + ?Sized> AsRawFd for ::rc::UniqueRc<T> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    (**self).as_raw_fd()
                }
            }
            
            impl<T: AsRawFd> AsRawFd for Box<T> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    (**self).as_raw_fd()
                }
            }
            
            impl AsRawFd for io::PipeReader 
            {
                fn as_raw_fd(&self) -> RawFd 
                {
                    self.0.as_raw_fd()
                }
            }
            
            impl FromRawFd for io::PipeReader 
            {
                unsafe fn from_raw_fd(raw_fd: RawFd) -> Self 
                {
                    Self::from_inner(unsafe { FromRawFd::from_raw_fd(raw_fd) })
                }
            }
            
            impl IntoRawFd for io::PipeReader 
            {
                fn into_raw_fd(self) -> RawFd 
                {
                    self.0.into_raw_fd()
                }
            }
            
            impl AsRawFd for io::PipeWriter 
            {
                fn as_raw_fd(&self) -> RawFd 
                {
                    self.0.as_raw_fd()
                }
            }
            
            impl FromRawFd for io::PipeWriter 
            {
                unsafe fn from_raw_fd(raw_fd: RawFd) -> Self 
                {
                    Self::from_inner(unsafe { FromRawFd::from_raw_fd(raw_fd) })
                }
            }
            
            impl IntoRawFd for io::PipeWriter 
            {
                fn into_raw_fd(self) -> RawFd 
                {
                    self.0.into_raw_fd()
                }
            }
        } pub use self::raw::*;
    }

    pub mod net
    {
        //! Linux and Android-specific networking functionality.
        pub mod addr
        {
            //! Linux and Android-specific extensions to socket addresses.
            use ::
            {
                os::unix::net::{ SocketAddr },
                sealed::{ Sealed },
                *,
            };
            /// Platform-specific extensions to [`SocketAddr`].
            pub trait SocketAddrExt: Sealed
            {
                /// Creates a Unix socket address in the abstract namespace.
                fn from_abstract_name<N>(name: N) -> ::io::Result<SocketAddr> where N: AsRef<[u8]>;

                /// Returns the contents of this address if it is in the abstract namespace.
                fn as_abstract_name(&self) -> Option<&[u8]>;
            }
        }
        
        pub mod socket
        {
            //! Linux and Android-specific socket functionality.
            use ::
            {
                os::unix::net,
                sealed::{ Sealed },
                sys::common::{ AsInner },
                *,
            };
            /// Linux-specific functionality for `AF_UNIX` sockets [`UnixDatagram`] and [`UnixStream`].
            pub trait UnixSocketExt: Sealed
            {
                /// Query the current setting of socket option `SO_PASSCRED`.
                fn passcred(&self) -> io::Result<bool>;
                /// Enable or disable socket option `SO_PASSCRED`.
                fn set_passcred(&self, passcred: bool) -> io::Result<()>;
            }
            
            impl UnixSocketExt for net::UnixDatagram
            {
                fn passcred(&self) -> io::Result<bool> { self.as_inner().passcred() }
                fn set_passcred(&self, passcred: bool) -> io::Result<()> { self.as_inner().set_passcred(passcred) }
            }
            
            impl UnixSocketExt for net::UnixStream
            {
                fn passcred(&self) -> io::Result<bool> { self.as_inner().passcred() }
                fn set_passcred(&self, passcred: bool) -> io::Result<()> { self.as_inner().set_passcred(passcred) }
            }
        }
        
        pub mod tcp
        {
            //! Linux and Android-specific tcp extensions to primitives in the [`std::net`] module.
            use ::
            {
                sealed::{ Sealed },
                sys::common::{ AsInner },
                *,
            };
            /// Os-specific extensions for [`TcpStream`]
            pub trait TcpStreamExt: Sealed
            {
                /// Enable or disable `TCP_QUICKACK`.
                fn set_quickack(&self, quickack: bool) -> io::Result<()>;
                /// Gets the value of the `TCP_QUICKACK` option on this socket.
                fn quickack(&self) -> io::Result<bool>;
                /// A socket listener will be awakened solely when data arrives.
                fn set_deferaccept(&self, accept: u32) -> io::Result<()>;
                /// Gets the accept delay value (in seconds) of the `TCP_DEFER_ACCEPT` option.
                fn deferaccept(&self) -> io::Result<u32>;
            }
            
            impl Sealed for net::TcpStream {}
            
            impl TcpStreamExt for net::TcpStream
            {
                fn set_quickack(&self, quickack: bool) -> io::Result<()> { self.as_inner().as_inner().set_quickack(quickack) }

                fn quickack(&self) -> io::Result<bool> { self.as_inner().as_inner().quickack() }
                
                fn set_deferaccept(&self, accept: u32) -> io::Result<()> { self.as_inner().as_inner().set_deferaccept(accept) }
                
                fn deferaccept(&self) -> io::Result<u32> { self.as_inner().as_inner().deferaccept() }
            }
        }
    }

    pub mod uefi
    {
        pub mod env
        {
            //! UEFI-specific extensions to the primitives in `std::env` module
            use ::
            {
                ffi::{ c_void },
                ptr::{ NonNull },
                sync::atomic::{ Atomic, AtomicBool, AtomicPtr, Ordering },
                *,
            };
            
            use crate::ffi::c_void;
            use crate::ptr::NonNull;
            use crate::sync::atomic::{Atomic, AtomicBool, AtomicPtr, Ordering};

            static mut SYSTEM_TABLE:Option<()> = None;
            static mut IMAGE_HANDLE:Option<()> = None;
            static mut BOOT_SERVICES_FLAG:Option<bool> = None;
            /*
            static SYSTEM_TABLE: Atomic<*mut c_void> = AtomicPtr::new(crate::ptr::null_mut());
            static IMAGE_HANDLE: Atomic<*mut c_void> = AtomicPtr::new(crate::ptr::null_mut());
            // Flag to check if BootServices are still valid.
            // Start with assuming that they are not available
            static BOOT_SERVICES_FLAG: Atomic<bool> = AtomicBool::new(false);
            */
            /// Initializes the global System Table and Image Handle pointers.
            pub(crate) unsafe fn init_globals(handle: NonNull<()>, system_table: NonNull<()>) {}
            /// Gets the SystemTable Pointer.
            pub fn system_table() -> NonNull<()>
            {
                unsafe
                {
                    NonNull( () )
                }
            }
            /// Gets the ImageHandle Pointer.
            pub fn image_handle() -> NonNull<()>
            {
                unsafe
                {
                    NonNull( () )
                }
            }

            /// Gets the BootServices Pointer.
            pub fn boot_services() -> Option<NonNull<()>>
            {
                None
            }
            /// Gets the SystemTable Pointer.
            pub(crate) fn try_system_table() -> Option<NonNull<()>>
            {
                None
            }
            /// Gets the SystemHandle Pointer.
            pub(crate) fn try_image_handle() -> Option<NonNull<()>>
            {
                None
            }

            pub(crate) fn disable_boot_services() {}
        }

        pub mod ffi
        {
            use ::
            {
                *,
            };
        }
    }

    pub mod unix
    {
        //! Platform-specific extensions to `std` for Unix platforms.
        use ::
        {
            *,
        };
        
        mod platform 
        {
            
        }

        pub mod ffi
        {
            use ::
            {
                *,
            };
        }

        pub mod fs
        {
            use ::
            {
                *,
            };
        }

        pub mod io
        {
            use ::
            {
                *,
            };
        }

        pub mod net
        {
            use ::
            {
                *,
            };
        }

        pub mod process
        {
            use ::
            {
                *,
            };
        }

        pub mod raw
        {
            use ::
            {
                *,
            };
        }

        pub mod thread
        {
            use ::
            {
                *,
            };
        }
        /// A prelude for conveniently writing platform-specific code.
        pub mod prelude
        {
            pub use super::ffi::{OsStrExt, OsStringExt};
            pub use super::fs::DirEntryExt;
            pub use super::fs::FileExt;
            pub use super::fs::{FileTypeExt, MetadataExt, OpenOptionsExt, PermissionsExt};
            pub use super::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};
            pub use super::process::{CommandExt, ExitStatusExt};
            pub use super::thread::JoinHandleExt;
        }
    }
    
    pub mod windows
    {
        use ::
        {
            *
        };
        //! Platform-specific extensions to `std` for Windows.
        
        
        mod platform 
        {
            
        }

        pub mod ffi
        {
            use ::
            {
                *,
            };
        }

        pub mod fs
        {
            use ::
            {
                *,
            };
        }

        pub mod io
        {
            use ::
            {
                *,
            };
        }

        pub mod net
        {
            use ::
            {
                *,
            };
        }

        pub mod process
        {
            use ::
            {
                *,
            };
        }

        pub mod raw
        {
            use ::
            {
                *,
            };
        }

        pub mod thread
        {
            use ::
            {
                *,
            };
        }
        /// A prelude for conveniently writing platform-specific code.
        pub mod prelude
        {
            pub use super::ffi::{OsStrExt, OsStringExt};
            pub use super::fs::FileExt;
            pub use super::fs::{MetadataExt, OpenOptionsExt};
            pub use super::io::
            {
                AsHandle, AsSocket, BorrowedHandle, BorrowedSocket, FromRawHandle, FromRawSocket,
                HandleOrInvalid, IntoRawHandle, IntoRawSocket, OwnedHandle, OwnedSocket,
            };
            pub use super::io::{AsRawHandle, AsRawSocket, RawHandle, RawSocket};
        }
    }
}

pub mod parsers
{
    pub mod line
    {
        use ::
        {
            types::{ LineInfo },
            *,
        };
        /*
        pub fn line_to_cmds(line: &str) -> Vec<String> */
        /// Parse command line for multiple commands.
        pub fn to_cmds(line: &str) -> Vec<String>
        {
            let mut result = Vec::new();
            let mut sep = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let len = line.chars().count();
            for (i, c) in line.chars().enumerate() {
                if has_backslash {
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if c == '\\' && sep != "'" {
                    has_backslash = true;
                    continue;
                }

                if c == '#' {
                    if sep.is_empty() {
                        break;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '\'' || c == '"' || c == '`' {
                    if sep.is_empty() {
                        sep.push(c);
                        token.push(c);
                        continue;
                    } else if sep == c.to_string() {
                        token.push(c);
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '&' || c == '|' {
                    // needs watch ahead here
                    if sep.is_empty() {
                        if i + 1 == len {
                            // for bg commands, e.g. `ls &`
                            token.push(c);
                            continue;
                        } else {
                            let c_next = match line.chars().nth(i + 1) {
                                Some(x) => x,
                                None => {
                                    println!("chars nth error - should never happen");
                                    continue;
                                }
                            };

                            if c_next != c {
                                token.push(c);
                                continue;
                            }
                        }
                    }

                    if sep.is_empty() {
                        sep.push(c);
                        continue;
                    } else if c.to_string() == sep {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        token = String::new();
                        result.push(format!("{}{}", sep, sep));
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == ';' {
                    if sep.is_empty() {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        result.push(String::from(";"));
                        token = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                token.push(c);
            }
            if !token.is_empty() {
                result.push(token.trim().to_string());
            }
            result
        }
        /*
        pub fn parse_line(line: &str) -> LineInfo*/
        pub fn parse(line: &str) -> LineInfo
        {
            let mut result = Vec::new();

            if ::is::arithmetic(line)
            {
                for x in line.split(' ')
                {
                    result.push((String::from(""), x.to_string()));
                }

                return LineInfo::new(result);
            }

            let mut sep = String::new();
            let mut sep_second = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let mut met_parenthesis = false;
            let mut new_round = true;
            let mut skip_next = false;
            let mut has_dollar = false;
            let mut parens_left_ignored = false;
            let mut sep_made = String::new();
            let mut semi_ok = false;
            let count_chars = line.chars().count();

            for (i, c) in line.chars().enumerate()
            {
                if skip_next
                {
                    skip_next = false;
                    continue;
                }

                if has_backslash && sep.is_empty() && (c == '>' || c == '<')
                {
                    sep_made = String::from("'");
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash && sep == "\"" && c != '\"'
                {
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash
                {
                    if new_round && sep.is_empty() && (c == '|' || c == '$') && token.is_empty()
                    {
                        sep = String::from("\\");
                        token = format!("{}", c);
                    }
                    else { token.push(c); }

                    new_round = false;
                    has_backslash = false;
                    continue;
                }

                if c == '$' { has_dollar = true; }
                
                if c == '(' && sep.is_empty()
                {
                    if !has_dollar && token.is_empty()
                    {
                        parens_left_ignored = true;
                        continue;
                    }

                    met_parenthesis = true;
                }

                if c == ')'
                {
                    if parens_left_ignored && !has_dollar
                    {
                        if i == count_chars - 1 || (i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == ' ')
                        { continue; }
                    }

                    if sep.is_empty() { met_parenthesis = false; }
                }

                if c == '\\'
                {
                    if sep == "'" || !sep_second.is_empty() { token.push(c) } else { has_backslash = true; }
                    continue;
                }

                if new_round
                {
                    if c == ' ' { continue; }
                    else if c == '"' || c == '\'' || c == '`'
                    {
                        sep = c.to_string();
                        new_round = false;
                        continue;
                    }

                    sep = String::new();

                    if c == '#' { break; }

                    if c == '|'
                    {
                        if i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == '|'
                        {
                            result.push((String::from(""), "||".to_string()));
                            skip_next = true;
                        }
                        else { result.push((String::from(""), "|".to_string())); }

                        new_round = true;
                        continue;
                    }

                    token.push(c);
                    new_round = false;
                    continue;
                }

                if c == '|' && !has_backslash
                {
                    if semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((sep.to_string(), token)); }

                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }
                    
                    else if !met_parenthesis && sep_second.is_empty() && sep.is_empty()
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((String::from(""), token)); }

                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        continue;
                    }
                }

                if c == ' '
                {
                    if semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((sep.to_string(), token)); }

                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }

                    if has_backslash
                    {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if met_parenthesis
                    {
                        token.push(c);
                        continue;
                    }

                    if sep == "\\"
                    {
                        result.push((String::from("\\"), token));
                        token = String::new();
                        new_round = true;
                        continue;
                    }

                    if sep.is_empty()
                    {
                        if sep_second.is_empty()
                        {
                            if sep.is_empty() && !sep_made.is_empty()
                            {
                                result.push((sep_made.clone(), token));
                                sep_made = String::new();
                            }
                            else { result.push((String::from(""), token)); }

                            token = String::new();
                            new_round = true;
                            continue;
                        }

                        else
                        {
                            token.push(c);
                            continue;
                        }
                    }
                    
                    else
                    {
                        token.push(c);
                        continue;
                    }
                }

                if c == '\'' || c == '"' || c == '`'
                {
                    if has_backslash
                    {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if sep != c.to_string() && semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((sep.to_string(), token)); }

                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                    }

                    if sep != c.to_string() && met_parenthesis
                    {
                        token.push(c);
                        continue;
                    }

                    if sep.is_empty() && !sep_second.is_empty() && sep_second != c.to_string()
                    {
                        token.push(c);
                        continue;
                    }

                    if sep.is_empty()
                    {
                        let is_an_env = ::regex::contains(&token, r"^[a-zA-Z0-9_]+=.*$");
                        
                        if !is_an_env && (c == '\'' || c == '"')
                        {
                            sep = c.to_string();
                            continue;
                        }

                        token.push(c);
                        
                        if sep_second.is_empty() { sep_second = c.to_string(); }
                        else if sep_second == c.to_string() { sep_second = String::new(); }

                        continue;
                    }

                    else if sep == c.to_string()
                    {
                        semi_ok = true;
                        continue;
                    }

                    else { token.push(c); }
                }
                
                else
                {
                    if has_backslash
                    {
                        has_backslash = false;
                        if sep == "\"" || sep == "'" { token.push('\\'); }
                    }

                    token.push(c);
                }
            }

            if !token.is_empty() || semi_ok
            {
                if sep.is_empty() && !sep_made.is_empty() { result.push((sep_made.clone(), token)); }
                else { result.push((sep.clone(), token)); }
            }

            let mut is_line_complete = true;

            if !result.is_empty()
            {
                let token_last = result[result.len() - 1].clone();
                if token_last.0.is_empty() && token_last.1 == "|" { is_line_complete = false; }
            }

            if !sep.is_empty() { is_line_complete = semi_ok; }

            if has_backslash { is_line_complete = false; }

            LineInfo { tokens: result, is_complete: is_line_complete }
        }
    }
}

pub mod path
{
    pub use std::path::{ * };

    use ::
    {
        *,
    };
    /*
    use std::borrow::Cow;
    use std::env;
    use std::fs::read_dir;
    use std::io::{ErrorKind, Write};
    use std::os::unix::fs::PermissionsExt;

    use regex::Regex;

    use crate::tools;
    */
    
    pub fn get_current_dir() -> String 
    {
        let mut current_dir = PathBuf::new();
        match env::current_dir() {
            Ok(x) => current_dir = x,
            Err(e) => {
                println_stderr!("env current_dir() failed: {}", e);
            }
        }
        let mut str_current_dir = "";
        match current_dir.to_str() {
            Some(x) => str_current_dir = x,
            None => {
                println_stderr!("current_dir to str failed.");
            }
        }
        str_current_dir.to_string()
    }

    pub fn basename(path: &str) -> Cow<'_, str>
    {
        let mut pieces = path.rsplit('/');
        
        match pieces.next()
        {
            Some(p) => p.into(),
            None => path.into(),
        }
    }

    pub fn expand_home(text: &str) -> String
    {
        let mut s: String = text.to_string();
        let v = vec![
            r"(?P<head> +)~(?P<tail> +)",
            r"(?P<head> +)~(?P<tail>/)",
            r"^(?P<head> *)~(?P<tail>/)",
            r"(?P<head> +)~(?P<tail> *$)",
        ];

        for item in &v
        {
            let re;
            if let Ok(x) = Regex::new(item) {
                re = x;
            } else {
                return String::new();
            }
            let home = tools::get_user_home();
            let ss = s.clone();
            let to = format!("$head{}$tail", home);
            let result = re.replace_all(ss.as_str(), to.as_str());
            s = result.to_string();
        }
        s
    }

    pub fn find_file_in_path(filename: &str, exec: bool) -> String
    {
        let env_path = match env::var("PATH") {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: error with env PATH: {:?}", e);
                return String::new();
            }
        };
        let vec_path: Vec<&str> = env_path.split(':').collect();
        for p in &vec_path {
            match read_dir(p) {
                Ok(list) => {
                    for entry in list.flatten() {
                        if let Ok(name) = entry.file_name().into_string() {
                            if name != filename {
                                continue;
                            }

                            if exec {
                                let _mode = match entry.metadata() {
                                    Ok(x) => x,
                                    Err(e) => {
                                        println_stderr!("cicada: metadata error: {:?}", e);
                                        continue;
                                    }
                                };
                                let mode = _mode.permissions().mode();
                                if mode & 0o111 == 0 {
                                    // not binary
                                    continue;
                                }
                            }

                            return entry.path().to_string_lossy().to_string();
                        }
                    }
                }
                Err(e) => {
                    if e.kind() == ErrorKind::NotFound {
                        continue;
                    }
                    log!("cicada: fs read_dir error: {}: {}", p, e);
                }
            }
        }
        String::new()
    }

    pub fn current_dir() -> String
    {
        let _current_dir = match env::current_dir() {
            Ok(x) => x,
            Err(e) => {
                log!("cicada: PROMPT: env current_dir error: {}", e);
                return String::new();
            }
        };
        let current_dir = match _current_dir.to_str() {
            Some(x) => x,
            None => {
                log!("cicada: PROMPT: to_str error");
                return String::new();
            }
        };

        current_dir.to_string()
    }
}

pub mod process
{
    pub use std::process::{ * };
    pub fn getpid() -> i32 { unsafe { ::libc::getpid() } }
    pub fn has_terminal() -> bool
    {
        unsafe
        {
            let tgid = libc::tcgetpgrp(0);
            let pgid = libc::getpgid(0);
            tgid == pgid
        }
    }
}

pub mod prompt
{
    //! Provides access to prompt input state
    use ::
    {
        char::{is_ctrl, is_printable, DELETE, EOF},
        collections::{ HashSet },
        command::{ Category, Command },
        complete::{ Completion },
        ffi::{ Function },
        mem::{ replace },
        ops::{ Range },
        reader::{ BindingIter, InputState, ReadLock, ReadResult },
        sync::{ Arc, Mutex },
        time::{ Instant },
        writer::{ BLINK_DURATION, display_str, Digit, Display, HistoryIter, PromptType, Writer, WriteLock },
        *,
    };
    /*

    use mortal::FindResult;
    
    use crate::table::{format_columns, Line, Table};
    use crate::terminal::{CursorMode, Signal, Size, Terminal};
    use crate::util::{
        get_open_paren, find_matching_paren, first_word,
        longest_common_prefix, repeat_char,
        back_n_words, forward_n_words,
        backward_char, forward_char, backward_word, forward_word,
        word_start, word_end, RangeArgument,
    };
    use crate::variables::VariableIter;
    */

    /// ANSI color codes wrapped with \x01 and \x02 for lineread
    pub const GREEN: &str = "\x01\x1b[0;32m\x02";

    lazy_static!
    {
        pub static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
        pub static ref ALIASES: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
    }
    /// Initialize the available commands cache by scanning PATH directories
    pub fn initialize_cache()
    {
        let commands = scan_available_commands();
        if let Ok(mut cache) = AVAILABLE_COMMANDS.lock() { *cache = commands; }
    }
    /// Update aliases in the prompts highlight's cache
    pub fn update_aliases(sh: &shell::Shell)
    {
        if let Ok(mut aliases) = ALIASES.lock()
        {
            aliases.clear();
            
            for alias_name in sh.aliases.keys()
            {
                aliases.insert(alias_name.clone());
            }
        }
    }
    /*
    pub fn get_prompt(...) -> String*/
    pub fn get(sh: &shell::Shell) -> String
    {
        let ps = get_prompt_string();
        let mut prompt = render_prompt(sh, &ps);
        
        if let Some((w, _h)) = ::terminal::size::dimensions()
        {
            if get_prompt_len(&prompt) > (w / 2) as i32 && !::regex::contains(&ps, r#"(?i)\$\{?newline.\}?"#)
            {
                prompt.push_str("\n$ ");
            }
        }

        else {  log!("ERROR: Failed to get term size"); }
        prompt
    }

    pub fn trim_multiline_prompts( line:&str ) -> String
    {
        let line_new = replace_all( line, r"\\\n>> ", "" );
        let line_new = replace_all( &line_new, r"\| *\n>> ", "| " );
        replace_all( &line_new, r"(?P<NEWLINE>\n)>> ", "$NEWLINE" )
    }

    pub fn create_highlighter() -> Arc<ShellHighlighter>
    {
        Arc::new(ShellHighlighter)
    }
    /// Provides access to the current state of input while a `read_line` call is in progress.
    pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminals>
    {
        pub read: &'a mut ReadLock<'b, Term>,
        write: WriteLock<'b, Term>,
    }

    impl<'a, 'b: 'a, Term: 'b + Terminals> Prompter<'a, 'b, Term>
    {
        pub fn new(read: &'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term>) -> Prompter<'a, 'b, Term>
        {
            Prompter{read, write}
        }

        /// Returns a `Writer` instance using the currently held write lock.
        pub fn writer_append<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>>
        {
            Writer::with_ref(&mut self.write, false)
        }
        /// Returns a `Writer` instance using the currently held write lock.
        pub fn writer_erase<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>>
        {
            Writer::with_ref(&mut self.write, true)
        }

        pub fn start_read_line(&mut self) -> io::Result<()>
        {
            self.read.state = InputState::NewSequence;
            self.write.is_prompt_drawn = true;
            self.write.update_size()?;
            self.write.draw_prompt()
        }

        pub fn end_read_line(&mut self) -> io::Result<()>
        {
            self.write.expire_blink()?;

            if self.read.overwrite_mode { self.write.set_cursor_mode(CursorMode::Normal)?; }

            if self.write.is_prompt_drawn
            {
                self.write.move_to_end()?;
                self.write.write_str("\n")?;
                self.write.is_prompt_drawn = false;
            }

            self.reset_input();
            self.read.state = InputState::Inactive;

            Ok(())
        }

        pub fn handle_input(&mut self, ch: char) -> io::Result<Option<ReadResult>>
        {
            self.write.expire_blink()?;

            match self.read.state
            {
                InputState::Inactive => panic!("input received in inactive state"),
                InputState::NewSequence => {
                    if ch == EOF && self.write.buffer.is_empty() {
                        self.write.write_str("\n")?;
                        self.write.is_prompt_drawn = false;
                        return Ok(Some(ReadResult::Eof));
                    } else {
                        self.read.sequence.push(ch);
                        self.execute_sequence()?;

                        if self.read.input_accepted {
                            let s = replace(&mut self.write.buffer, String::new());
                            return Ok(Some(ReadResult::Input(s)));
                        }
                    }
                }
                InputState::ContinueSequence{expiry: _} => {
                    self.read.sequence.push(ch);

                    self.execute_sequence()?;

                    if self.read.input_accepted {
                        let s = replace(&mut self.write.buffer, String::new());
                        return Ok(Some(ReadResult::Input(s)));
                    }
                }
                InputState::Number => {
                    if let Some(digit) = ch.to_digit(10) {
                        self.write.input_arg.input(digit as i32);

                        if self.write.input_arg.is_out_of_bounds() {
                            self.read.state = InputState::NewSequence;
                            self.write.input_arg = Digit::None;
                            self.write.explicit_arg = false;
                            self.write.redraw_prompt(PromptType::Normal)?;
                        } else {
                            self.write.redraw_prompt(PromptType::Number)?;
                        }
                    } else {
                        self.read.state = InputState::NewSequence;
                        self.write.redraw_prompt(PromptType::Normal)?;
                        self.read.macro_buffer.insert(0, ch);
                    }
                }
                InputState::CharSearch{n, backward} => {
                    if n != 0 {
                        if backward {
                            self.write.backward_search_char(n, ch)?;
                        } else {
                            self.write.forward_search_char(n, ch)?;
                        }
                    }
                    self.read.state = InputState::NewSequence;
                }
                InputState::TextSearch => {
                    if ch == DELETE {
                        {
                            let write = &mut *self.write;
                            write.search_buffer.pop();
                            write.last_search.clone_from(&write.search_buffer);
                        }
                        self.write.search_history_update()?;
                    } else if self.is_abort(ch) {
                        self.abort_search_history()?;
                    } else if is_ctrl(ch) {
                        // End search, handle input after cancelling
                        self.end_search_history()?;
                        self.read.macro_buffer.insert(0, ch);
                    } else {
                        {
                            let write = &mut *self.write;
                            write.search_buffer.push(ch);
                            write.last_search.clone_from(&write.search_buffer);
                        }
                        self.write.search_history_update()?;
                    }
                }
                InputState::CompleteIntro => {
                    match ch {
                        'y' | 'Y' | ' ' => {
                            self.write.write_str("\n")?;
                            self.show_completions_page(0)?;
                        }
                        '\r' | '\n' => {
                            self.write.write_str("\n")?;
                            self.show_completions_line(0)?;
                        }
                        'q' | 'Q' |
                        'n' | 'N' | DELETE => {
                            self.write.write_str("\n")?;
                            self.end_page_completions()?;
                        }
                        _ => ()
                    }
                }
                InputState::CompleteMore(offset) => {
                    match ch {
                        'y' | 'Y' | ' ' => {
                            self.write.clear_prompt()?;
                            self.show_completions_page(offset)?;
                        }
                        '\r' | '\n' => {
                            self.write.clear_prompt()?;
                            self.show_completions_line(offset)?;
                        }
                        'q' | 'Q' |
                        'n' | 'N' | DELETE => {
                            self.write.clear_prompt()?;
                            self.end_page_completions()?;
                        }
                        _ => ()
                    }
                }
                InputState::QuotedInsert(n) => {
                    if n != 0 {
                        self.insert(n, ch)?;
                    }
                    self.read.state = InputState::NewSequence;
                }
            }

            Ok(None)
        }
        /// Returns the current buffer.
        pub fn buffer(&self) -> &str { &self.write.buffer }
        /// Returns the "backup" buffer.
        pub fn backup_buffer(&self) -> &str { &self.write.backup_buffer }
        /// Returns the command `Category` of the most recently executed command.
        pub fn last_command_category(&self) -> Category { self.read.last_cmd }
        /// Returns the set of characters that indicate a word break.
        pub fn word_break_chars(&self) -> &str { &self.read.word_break }
        /// Sets the buffer to the given value.
        pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> { self.write.set_buffer(buf) }
        /// Returns the current position of the cursor.
        pub fn cursor(&self) -> usize { self.write.cursor }
        /// Sets the cursor to the given position within the buffer.
        pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> { self.write.set_cursor(pos) }
        /// Sets the prompt that will be displayed when `read_line` is called.
        pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> { self.write.set_prompt(prompt) }
        /// Returns the size of the terminal at the last draw operation.
        pub fn screen_size(&self) -> Size { self.write.screen_size }
        /// Returns whether a numerical argument was explicitly supplied by the user.
        pub fn explicit_arg(&self) -> bool { self.write.explicit_arg }
        /// Returns the current input sequence.
        pub fn sequence(&self) -> &str { &self.read.sequence }
        /// Returns an iterator over bound sequences
        pub fn bindings(&self) -> BindingIter { self.read.bindings() }
        /// Returns an iterator over variable values.
        pub fn variables(&self) -> VariableIter { self.read.variables() }
        /// Returns an iterator over history entries
        pub fn history(&self) -> HistoryIter { self.write.history() }
        /// Returns the index into history currently being edited.
        pub fn history_index(&self) -> Option<usize> { self.write.history_index }
        /// Returns the current number of history entries.
        pub fn history_len(&self) -> usize { self.write.history.len() }
        /// Selects the history entry currently being edited by the user.
        pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()>
        { self.write.select_history_entry(new) }
        /// Returns the current set of completions.
        pub fn completions(&self) -> Option<&[Completion]> { self.read.completions.as_ref().map(|v| &v[..]) }
        /// Sets the current set of completions.
        pub fn set_completions(&mut self, completions: Option<Vec<Completion>>)
        { self.read.completions = completions; }
        /// Accepts the current input buffer as user input.
        pub fn accept_input(&mut self) -> io::Result<()>
        {
            self.write.move_to_end()?;
            self.write.write_str("\n")?;
            self.read.input_accepted = true;
            self.write.is_prompt_drawn = false;
            Ok(())
        }
        /// Moves the cursor to the given position, waits for 500 milliseconds, 
        /// then restores the original cursor position.
        pub fn blink(&mut self, pos: usize) -> io::Result<()>
        {
            self.write.blink(pos)?;

            self.read.max_wait_duration = Some(BLINK_DURATION);

            Ok(())
        }

        pub fn check_expire_timeout(&mut self) -> io::Result<()> 
        {
            let now = Instant::now();

            self.check_expire_blink(now)?;
            self.check_expire_sequence(now)
        }

        pub fn handle_resize(&mut self, size: Size) -> io::Result<()> 
        {
            self.expire_blink()?;

            if self.is_paging_completions() 
            {
                self.end_page_completions()?;
            }

            self.write.screen_size = size;

            let p = self.write.prompt_type;
            self.write.redraw_prompt(p)
        }

        pub fn handle_signal(&mut self, signal: Signal) -> io::Result<()> 
        {
            self.expire_blink()?;

            match signal 
            {
                Signal::Continue => 
                {
                    self.write.draw_prompt()?;
                }
                Signal::Interrupt => 
                {
                    self.read.macro_buffer.clear();
                    self.write.move_to_end()?;

                    if self.read.echo_control_characters 
                    {
                        self.write.write_str("^C")?;
                    }

                    self.write.write_str("\n")?;
                    self.reset_input();
                    self.write.draw_prompt()?;
                }
                _ => ()
            }

            Ok(())
        }
        /// Deletes a range of text from the input buffer.
        pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> 
        {
            self.write.delete_range(range)
        }
        /// Deletes a range from the buffer and adds the removed text to the kill ring.
        pub fn kill_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> 
        {
            let start = range.start().cloned().unwrap_or(0);
            let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
            let len = end - start;

            if len != 0 
            {
                let buf = self.write.buffer[start..end].to_owned();

                if self.read.last_cmd != Category::Kill 
                {
                    self.push_kill_ring(buf);
                } else if end == self.write.cursor 
                {
                    self.prepend_kill_ring(buf);
                } else {
                    self.append_kill_ring(buf);
                }

                self.delete_range(start..end)?;
            }

            Ok(())
        }
        /// Transposes two regions of the buffer, `src` and `dest`.
        pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>) -> io::Result<()>
        {
            self.write.transpose_range(src, dest)
        }
        /// Insert text from the front of the kill ring at the current cursor position.
        pub fn yank(&mut self) -> io::Result<()>
        {
            if let Some(kill) = self.read.kill_ring.front().cloned()
            {
                let start = self.write.cursor;
                self.read.last_yank = Some((start, start + kill.len()));
                self.insert_str(&kill)?;
            }

            Ok(())
        }
        /// Rotates the kill ring and replaces yanked text with the new front.
        pub fn yank_pop(&mut self) -> io::Result<()>
        {
            if let Some((start, end)) = self.read.last_yank
            {
                self.rotate_kill_ring();

                if let Some(kill) = self.read.kill_ring.front().cloned()
                {
                    self.read.last_yank = Some((start, start + kill.len()));
                    self.write.move_to(start)?;
                    self.replace_str_forward(start..end, &kill)?;
                }
            }

            Ok(())
        }
        /// Insert a given character at the current cursor position `n` times.
        pub fn insert(&mut self, n: usize, ch: char) -> io::Result<()>
        {
            if n != 0
            {
                let s = repeat_char(ch, n);
                self.insert_str(&s)?;
            }

            Ok(())
        }
        /// Insert a string at the current cursor position.
        pub fn insert_str(&mut self, s: &str) -> io::Result<()> { self.write.insert_str(s) }
        /// Replaces a range in the buffer and redraws.
        pub fn replace_str_backward<R: RangeArgument<usize>>(&mut self, range: R, s: &str) -> io::Result<()>
        {
            self.replace_str_impl(range, s)?;
            let len = self.write.buffer.len();
            self.write.move_from(len)
        }
        /// Replaces a range in the buffer and redraws.
        pub fn replace_str_forward<R: RangeArgument<usize>>(&mut self, range: R, s: &str) -> io::Result<()>
        {
            self.replace_str_impl(range, s)?;
            self.write.cursor += s.len();
            let len = self.write.buffer.len();
            self.write.move_from(len)
        }
        /// Replaces a range in the buffer and redraws.
        fn replace_str_impl<R: RangeArgument<usize>>(&mut self, range: R, s: &str) -> io::Result<()>
        {
            let start = range.start().cloned().unwrap_or(0);
            let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
            self.write.move_to(start)?;
            let _ = self.write.buffer.drain(start..end);
            let cursor = self.write.cursor;
            self.write.buffer.insert_str(cursor, s);
            self.write.draw_buffer(cursor)?;
            self.write.clear_to_screen_end()
        }
        /// Overwrite `n` characters; assumes `n >= 1`
        fn overwrite(&mut self, n: usize, ch: char) -> io::Result<()>
        {
            let start = self.write.cursor;
            let end = forward_char(n, &self.write.buffer, start);
            {
                let over = &self.write.buffer[start..end];
                let n_chars = over.chars().count();

                if n > n_chars { self.read.overwritten_append += n - n_chars; }

                if !over.is_empty() { self.read.overwritten_chars.push_str(&over); }
            }
            let s = repeat_char(ch, n);
            self.replace_str_forward(start..end, &s)
        }

        fn overwrite_back(&mut self, mut n: usize) -> io::Result<()>
        {
            if self.read.overwritten_append != 0
            {
                let n_del = n.min(self.read.overwritten_append);
                let pos = backward_char(n_del, &self.write.buffer, self.write.cursor);
                let r = pos..self.write.cursor;
                self.delete_range(r)?;
                self.read.overwritten_append -= n_del;
                n -= n_del;
            }

            if n != 0 && !self.read.overwritten_chars.is_empty()
            {
                let n_repl = n.min(self.read.overwritten_chars.chars().count());
                let pos = backward_char(n_repl, &self.write.buffer, self.write.cursor);
                let over_pos = backward_char(n_repl, &self.read.overwritten_chars, self.read.overwritten_chars.len());
                let over = self.read.overwritten_chars.drain(over_pos..).collect::<String>();
                let r = pos..self.write.cursor;
                self.replace_str_backward(r, &over)?;
                n -= n_repl;
            }

            if n != 0 { self.write.backward_char(n)?; }

            Ok(())
        }

        fn push_kill_ring(&mut self, s: String) 
        {
            if self.read.kill_ring.len() == self.read.kill_ring.capacity() 
            {
                self.read.kill_ring.pop_back();
            }
            self.read.kill_ring.push_front(s);
        }

        fn rotate_kill_ring(&mut self) 
        {
            if let Some(kill) = self.read.kill_ring.pop_front() 
            {
                self.read.kill_ring.push_back(kill);
            }
        }

        fn append_kill_ring(&mut self, s: String) 
        {
            if let Some(kill) = self.read.kill_ring.front_mut() 
            {
                kill.push_str(&s);
                return;
            }
            self.push_kill_ring(s);
        }

        fn prepend_kill_ring(&mut self, s: String)
        {
            if let Some(kill) = self.read.kill_ring.front_mut()
            {
                kill.insert_str(0, &s);
                return;
            }

            self.push_kill_ring(s);
        }

        fn backward_word(&mut self, n: usize) -> io::Result<()> 
        {
            let pos = backward_word(n, &self.write.buffer, self.write.cursor, &self.read.word_break);
            self.write.move_to(pos)
        }

        fn forward_word(&mut self, n: usize) -> io::Result<()> 
        {
            let pos = forward_word(n, &self.write.buffer, self.write.cursor, &self.read.word_break);
            self.write.move_to(pos)
        }

        fn expire_blink(&mut self) -> io::Result<()> 
        {
            self.read.max_wait_duration = None;
            self.write.expire_blink()
        }

        fn build_completions(&mut self) 
        {
            let compl = self.read.completer.clone();
            let end = self.write.cursor;
            let start = compl.word_start(&self.write.buffer, end, self);

            if start > end 
            {
                panic!("Completer::word_start returned invalid index; \
                    start > end ({} > {})", start, end);
            }

            let unquoted = compl.unquote(&self.write.buffer[start..end]).into_owned();

            let completions = compl.complete(&unquoted, self, start, end);
            let n_completions = completions.as_ref().map_or(0, |c| c.len());

            self.read.completions = completions;
            self.read.completion_index = n_completions;
            self.read.completion_start = start;
            self.read.completion_prefix = end;
        }

        fn complete_word(&mut self) -> io::Result<()> 
        {
            if let Some(completions) = self.read.completions.take() 
            {
                if completions.len() == 1 {
                    self.substitute_completion(&completions[0])?;
                } else {
                    self.show_completions(&completions)?;
                    self.read.completions = Some(completions);
                }
            } else 
            {
                self.build_completions();
                let completions = self.read.completions.take().unwrap_or_default();

                if completions.len() == 1 
                {
                    self.substitute_completion(&completions[0])?;
                } else if !completions.is_empty() 
                {
                    let start = self.read.completion_start;
                    let end = self.write.cursor;

                    {
                        let pfx = longest_common_prefix(completions.iter()
                            .map(|compl| &compl.completion[..]))
                            .unwrap_or_default();
                        self.replace_str_forward(start..end, &pfx)?;
                    }

                    self.read.completions = Some(completions);
                }
            }

            Ok(())
        }

        fn substitute_completion(&mut self, compl: &Completion) -> io::Result<()> 
        {
            let mut s = self.read.completer.quote(&compl.completion);

            if let Some(suffix) = compl.suffix.with_default(self.read.completion_append_character) 
            {
                s.to_mut().push(suffix);
            }

            let start = self.read.completion_start;
            let end = self.write.cursor;
            self.replace_str_forward(start..end, &s)
        }

        fn insert_completions(&mut self, completions: &[Completion]) -> io::Result<()> 
        {
            let mut words = String::new();

            for compl in completions 
            {
                words.push_str(&self.read.completer.unquote(&compl.completion));
                words.push(' ');
            }

            let start = self.read.completion_start;
            let end = self.write.cursor;

            self.replace_str_forward(start..end, &words)
        }

        fn show_completions(&mut self, completions: &[Completion]) -> io::Result<()> 
        {
            if completions.is_empty() 
            {
                return Ok(());
            }

            let eff_width = self.write.screen_size.columns
                .min(self.read.completion_display_width);

            let completions = completions.iter()
                .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                .collect::<Vec<_>>();

            let cols = format_columns(&completions, eff_width,
                self.read.print_completions_horizontally);
            let table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                self.read.print_completions_horizontally);

            self.write.write_str("\n")?;

            let n_completions = completions.len();

            if self.read.page_completions && n_completions >= self.read.completion_query_items 
            {
                self.start_page_completions(n_completions)
            } else 
            {
                self.show_list_completions(table)?;
                self.write.draw_prompt()
            }
        }

        fn start_page_completions(&mut self, n_completions: usize) -> io::Result<()> 
        {
            self.read.state = InputState::CompleteIntro;
            self.write.redraw_prompt(PromptType::CompleteIntro(n_completions))
        }

        fn end_page_completions(&mut self) -> io::Result<()> 
        {
            self.read.state = InputState::NewSequence;
            self.write.prompt_type = PromptType::Normal;
            self.write.draw_prompt()
        }

        fn is_paging_completions(&self) -> bool 
        {
            match self.read.state 
            {
                InputState::CompleteMore(_) => true,
                _ => false
            }
        }

        fn show_completions_page(&mut self, offset: usize) -> io::Result<()> 
        {
            if let Some(compl) = self.read.completions.take() 
            {
                let width = self.write.screen_size.columns
                    .min(self.read.completion_display_width);
                let n_lines = self.write.screen_size.lines - 1;

                let completions = compl.iter()
                    .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                    .collect::<Vec<_>>();

                let cols = format_columns(&completions, width,
                    self.read.print_completions_horizontally);
                let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                    self.read.print_completions_horizontally);

                for row in table.by_ref().skip(offset).take(n_lines) 
                {
                    self.show_completion_line(row)?;
                }

                if table.has_more() 
                {
                    self.read.completions = Some(compl);
                    self.read.state = InputState::CompleteMore(offset + n_lines);
                    self.write.prompt_type = PromptType::CompleteMore;
                    self.write.draw_prompt()?;
                } else 
                {
                    self.end_page_completions()?;
                }
            }

            Ok(())
        }

        fn show_completions_line(&mut self, offset: usize) -> io::Result<()> 
        {
            if let Some(compl) = self.read.completions.take() 
            {
                let width = self.write.screen_size.columns
                    .min(self.read.completion_display_width);
                let completions = compl.iter()
                    .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                    .collect::<Vec<_>>();

                let cols = format_columns(&completions, width,
                    self.read.print_completions_horizontally);
                let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                    self.read.print_completions_horizontally);

                if let Some(row) = table.by_ref().skip(offset).next() 
                {
                    self.show_completion_line(row)?;
                }

                if table.has_more() 
                {
                    self.read.completions = Some(compl);
                    self.read.state = InputState::CompleteMore(offset + 1);
                    self.write.prompt_type = PromptType::CompleteMore;
                    self.write.draw_prompt()?;
                } else 
                {
                    self.end_page_completions()?;
                }
            }

            Ok(())
        }

        fn show_completion_line<S: AsRef<str>>(&mut self, line: Line<S>) -> io::Result<()> 
        {
            let mut space = 0;

            for (width, name) in line 
            {
                self.write.move_right(space)?;
                self.write.write_str(name)?;
                space = width - name.chars().count();
            }

            self.write.write_str("\n")
        }

        fn show_list_completions<S: AsRef<str>>(&mut self, table: Table<S>) -> io::Result<()> 
        {
            for line in table 
            {
                let mut space = 0;

                for (width, name) in line 
                {
                    self.write.move_right(space)?;
                    self.write.write_str(name)?;
                    space = width - name.chars().count();
                }
                self.write.write_str("\n")?;
            }

            Ok(())
        }

        fn next_completion(&mut self, n: usize) -> io::Result<()> 
        {
            let len = self.read.completions.as_ref().map_or(0, |c| c.len());
            let max = len + 1;

            let old = self.read.completion_index;
            let new = (old + n) % max;

            if old != new 
            {
                self.set_completion(new)?;
            }

            Ok(())
        }

        fn prev_completion(&mut self, n: usize) -> io::Result<()> 
        {
            let len = self.read.completions.as_ref().map_or(0, |c| c.len());
            let max = len + 1;

            let old = self.read.completion_index;
            let new = if n <= old 
            {
                max - old - n
            } else 
            {
                old - n
            };

            self.set_completion(new)
        }

        fn set_completion(&mut self, new: usize) -> io::Result<()> 
        {
            let len = self.read.completions.as_ref().map_or(0, |c| c.len());
            let old = self.read.completion_index;

            if old != new 
            {
                self.read.completion_index = new;

                if new == len 
                {
                    let start = self.read.completion_prefix;
                    let end = self.write.cursor;

                    self.delete_range(start..end)?;
                } else 
                {
                    let start = self.read.completion_start;
                    let end = self.write.cursor;
                    let s = self.read.completions.as_ref().unwrap()[new]
                        .completion(self.read.completion_append_character).into_owned();

                    self.replace_str_forward(start..end, &s)?;
                }
            }

            Ok(())
        }

        fn abort_search_history(&mut self) -> io::Result<()> 
        {
            self.read.state = InputState::NewSequence;
            self.read.last_cmd = Category::Other;
            self.write.abort_search_history()
        }

        fn end_search_history(&mut self) -> io::Result<()> 
        {
            self.read.state = InputState::NewSequence;
            self.write.end_search_history()
        }

        fn check_expire_blink(&mut self, now: Instant) -> io::Result<()>
        {
            if self.write.check_expire_blink(now)? { self.read.max_wait_duration = None; }
            Ok(())
        }

        fn check_expire_sequence(&mut self, now: Instant) -> io::Result<()> 
        {
            if let InputState::ContinueSequence{expiry: Some(expiry)} = self.read.state 
            {
                if now >= expiry 
                {
                    self.read.max_wait_duration = None;
                    self.force_execute_sequence()?;
                }
            }

            Ok(())
        }

        fn keyseq_expiry(&mut self) -> Option<Instant> 
        {
            if let Some(t) = self.read.keyseq_timeout 
            {
                self.read.max_wait_duration = Some(t);
                Some(Instant::now() + t)
            } else {
                None
            }
        }
        /// Attempts to execute the current sequence.
        fn execute_sequence(&mut self) -> io::Result<()>
        {
            match self.find_binding(&self.read.sequence)
            {
                FindResult::Found(cmd) => {
                    let ch = self.read.sequence.chars().last().unwrap();
                    let n = self.write.input_arg.to_i32();

                    self.read.state = InputState::NewSequence;
                    self.execute_command(cmd, n, ch)?;
                    self.read.sequence.clear();
                }
                FindResult::NotFound => {
                    self.read.state = InputState::NewSequence;
                    self.insert_first_char()?;
                }
                FindResult::Incomplete => {
                    let expiry = None;
                    self.read.state = InputState::ContinueSequence{expiry};
                }
                FindResult::Undecided(_) => {
                    let expiry = self.keyseq_expiry();
                    self.read.state = InputState::ContinueSequence{expiry};
                }
            }

            Ok(())
        }

        fn force_execute_sequence(&mut self) -> io::Result<()>
        {
            self.read.state = InputState::NewSequence;

            match self.find_binding(&self.read.sequence) {
                FindResult::Found(cmd) |
                FindResult::Undecided(cmd) => {
                    let ch = self.read.sequence.chars().last().unwrap();
                    let n = self.write.input_arg.to_i32();

                    self.execute_command(cmd, n, ch)?;
                    self.read.sequence.clear();
                }
                FindResult::NotFound => {
                    self.insert_first_char()?;
                }
                FindResult::Incomplete => unreachable!(),
            }

            Ok(())
        }
        /// Execute the command `SelfInsert` on the first character in the input sequence, if it is printable.
        fn insert_first_char(&mut self) -> io::Result<()>
        {
            let (first, rest) = {
                let mut chars = self.read.sequence.chars();

                (chars.next().unwrap(), chars.as_str().to_owned())
            };

            self.read.sequence.clear();

            if is_printable(first) {
                let n = self.write.input_arg.to_i32();
                self.execute_command(Command::SelfInsert, n, first)?;
            }

            if !rest.is_empty() {
                self.read.queue_input(&rest);
            }

            Ok(())
        }

        fn find_binding(&self, seq: &str) -> FindResult<Command> { self.read.bindings.find(seq).cloned() }

        fn get_function(&self, name: &str) -> Option<&Arc<dyn Function<Term>>> { self.read.functions.get(name) }

        fn is_abort(&self, ch: char) -> bool
        {
            let mut buf = [0; 4];
            let s = ch.encode_utf8(&mut buf);
            self.find_binding(&s) == FindResult::Found(Command::Abort)
        }

        fn execute_command(&mut self, cmd: Command, n: i32, ch: char) -> io::Result<()>
        {
            use ::command::Command::*;

            let mut category = cmd.category();

            if self.read.overwrite_mode
            {
                match cmd
                {
                    DigitArgument | SelfInsert => (),
                    BackwardDeleteChar if n >= 0 => (),
                    _ => self.read.overwritten_chars.clear()
                }
            }

            match cmd
            {
                Abort => (),
                AcceptLine => {
                    self.accept_input()?;
                }
                Complete => {
                    if !self.read.disable_completion {
                        self.complete_word()?;
                    } else if is_printable(ch) {
                        self.execute_command(SelfInsert, n, ch)?;
                    }
                }
                InsertCompletions => {
                    if self.read.completions.is_none() {
                        self.build_completions();
                    }

                    if let Some(completions) = self.read.completions.take() {
                        self.insert_completions(&completions)?;
                        self.read.completions = Some(completions);
                    }
                }
                PossibleCompletions => {
                    if self.read.completions.is_none() {
                        self.build_completions();
                    }

                    if let Some(completions) = self.read.completions.take() {
                        self.show_completions(&completions)?;
                        self.read.completions = Some(completions);
                    }
                }
                MenuComplete => {
                    if self.read.completions.is_none() {
                        self.build_completions();
                    }

                    if n > 0 {
                        self.next_completion(n as usize)?;
                    } else {
                        self.prev_completion((-n) as usize)?;
                    }
                }
                MenuCompleteBackward => {
                    if self.read.completions.is_none() {
                        self.build_completions();
                    }

                    if n > 0 {
                        self.prev_completion(n as usize)?;
                    } else {
                        self.next_completion((-n) as usize)?;
                    }
                }
                DigitArgument => {
                    self.read.state = InputState::Number;
                    self.write.set_digit_from_char(ch);
                    self.write.redraw_prompt(PromptType::Number)?;
                }
                SelfInsert => {
                    if n > 0 {
                        let n = n as usize;

                        if self.read.overwrite_mode {
                            self.overwrite(n, ch)?;
                        } else {
                            self.insert(n, ch)?;
                        }

                        if self.read.blink_matching_paren {
                            if let Some(open) = get_open_paren(ch) {
                                if let Some(pos) = find_matching_paren(
                                        &self.write.buffer[..self.write.cursor],
                                        &self.read.string_chars, open, ch) {
                                    self.blink(pos)?;
                                }
                            }
                        }
                    }
                }
                TabInsert => {
                    if n > 0 {
                        self.insert(n as usize, '\t')?;
                    }
                }
                InsertComment => {
                    if self.explicit_arg() &&
                            self.write.buffer.starts_with(&self.read.comment_begin[..]) {
                        self.write.move_to(0)?;
                        let n = self.read.comment_begin.len();

                        self.delete_range(..n)?;
                        self.accept_input()?;
                    } else {
                        self.write.move_to(0)?;
                        let s = self.read.comment_begin.clone();
                        self.insert_str(&s)?;
                        self.accept_input()?;
                    }
                }
                BackwardChar => {
                    if n > 0 {
                        self.write.backward_char(n as usize)?;
                    } else if n < 0 {
                        self.write.forward_char((-n) as usize)?;
                    }
                }
                ForwardChar => {
                    if n > 0 {
                        self.write.forward_char(n as usize)?;
                    } else if n < 0 {
                        self.write.backward_char((-n) as usize)?;
                    }
                }
                CharacterSearch => {
                    if n >= 0 {
                        self.read.state = InputState::CharSearch{
                            n: n as usize,
                            backward: false,
                        }
                    } else {
                        self.read.state = InputState::CharSearch{
                            n: (-n) as usize,
                            backward: true,
                        };
                    }
                }
                CharacterSearchBackward => {
                    if n >= 0 {
                        self.read.state = InputState::CharSearch{
                            n: n as usize,
                            backward: true,
                        }
                    } else {
                        self.read.state = InputState::CharSearch{
                            n: (-n) as usize,
                            backward: false,
                        };
                    }
                }
                BackwardWord => {
                    if n > 0 {
                        self.backward_word(n as usize)?;
                    } else if n < 0 {
                        self.forward_word((-n) as usize)?;
                    }
                }
                ForwardWord => {
                    if n > 0 {
                        let pos = forward_word(n as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        self.write.move_to(pos)?;
                    } else if n < 0 {
                        let pos = forward_word((-n) as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        self.write.move_to(pos)?;
                    }
                }
                BackwardKillLine => {
                    let r = ..self.write.cursor;
                    self.kill_range(r)?;
                }
                KillLine => {
                    let r = self.write.cursor..;
                    self.kill_range(r)?;
                }
                BackwardKillWord => {
                    if n > 0 {
                        let pos = backward_word(n as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        let r = pos..self.write.cursor;
                        self.kill_range(r)?;
                    } else if n < 0 {
                        let pos = forward_word((-n) as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        let r = self.write.cursor..pos;
                        self.kill_range(r)?;
                    }
                }
                KillWord => {
                    if n > 0 {
                        let pos = forward_word(n as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        let r = self.write.cursor..pos;
                        self.kill_range(r)?;
                    } else if n < 0 {
                        let pos = backward_word((-n) as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        let r = pos..self.write.cursor;
                        self.kill_range(r)?;
                    }
                }
                UnixWordRubout => {
                    if n > 0 {
                        let pos = backward_word(n as usize,
                            &self.write.buffer, self.write.cursor, " \t\n");
                        let r = pos..self.write.cursor;
                        self.kill_range(r)?;
                    } else if n < 0 {
                        let pos = forward_word((-n) as usize,
                            &self.write.buffer, self.write.cursor, " \t\n");
                        let r = self.write.cursor..pos;
                        self.kill_range(r)?;
                    }
                }
                ClearScreen => {
                    self.write.clear_screen()?;
                }
                BeginningOfLine => self.write.move_to(0)?,
                EndOfLine => self.write.move_to_end()?,
                BackwardDeleteChar => {
                    if n > 0 {
                        if self.read.overwrite_mode {
                            self.overwrite_back(n as usize)?;
                        } else {
                            let pos = backward_char(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = pos..self.write.cursor;
                            self.delete_range(r)?;
                        }
                    } else if n < 0 {
                        let pos = forward_char((-n) as usize,
                            &self.write.buffer, self.write.cursor);
                        let r = self.write.cursor..pos;
                        self.delete_range(r)?;
                    }
                }
                DeleteChar => {
                    if n > 0 {
                        let pos = forward_char(n as usize,
                            &self.write.buffer, self.write.cursor);
                        let r = self.write.cursor..pos;
                        self.delete_range(r)?;
                    } else if n < 0 {
                        let pos = backward_char(n as usize,
                            &self.write.buffer, self.write.cursor);
                        let r = pos..self.write.cursor;
                        self.delete_range(r)?;
                    }
                }
                TransposeChars => {
                    if n != 0 && self.write.cursor != 0 {
                        let (src, dest);

                        if !self.explicit_arg() && self.write.cursor == self.write.buffer.len() {
                            let end = backward_char(1, &self.write.buffer, self.write.cursor);
                            let start = backward_char(1, &self.write.buffer, end);

                            src = start..end;
                            dest = end..self.write.cursor;
                        } else {
                            let start = backward_char(1, &self.write.buffer, self.write.cursor);
                            let end = self.write.cursor;

                            src = start..end;

                            dest = if n < 0 {
                                let back = backward_char((-n) as usize, &self.write.buffer, start);
                                back..start
                            } else {
                                let fwd = forward_char(n as usize + 1, &self.write.buffer, start);
                                end..fwd
                            };
                        }

                        self.transpose_range(src, dest)?;
                    }
                }
                TransposeWords => {
                    if n != 0 {
                        if let Some(first) = first_word(&self.write.buffer[..self.write.cursor], &self.read.word_break) {
                            let start = word_start(&self.write.buffer, self.write.cursor, &self.read.word_break);

                            if first != start {
                                let (src, dest);

                                if !self.explicit_arg() && start == self.write.buffer.len() {
                                    let dest_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                    let dest_end = word_end(&self.write.buffer, dest_start, &self.read.word_break);

                                    let src_start = backward_word(1, &self.write.buffer, dest_start, &self.read.word_break);
                                    let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                    src = src_start..src_end;
                                    dest = dest_start..dest_end;
                                } else {
                                    let src_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                    let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                    src = src_start..src_end;

                                    dest = if n < 0 {
                                        back_n_words((-n) as usize, &self.write.buffer, src_start, &self.read.word_break)
                                    } else {
                                        forward_n_words(n as usize, &self.write.buffer, src_start, &self.read.word_break)
                                    };
                                }

                                self.transpose_range(src, dest)?;
                            }
                        }
                    }
                }
                BeginningOfHistory => {
                    self.select_history_entry(Some(0))?;
                }
                EndOfHistory => {
                    self.select_history_entry(None)?;
                }
                NextHistory => {
                    if n > 0 {
                        self.next_history(n as usize)?;
                    } else if n < 0 {
                        self.prev_history((-n) as usize)?;
                    }
                }
                PreviousHistory => {
                    if n > 0 {
                        self.prev_history(n as usize)?;
                    } else if n < 0 {
                        self.next_history((-n) as usize)?;
                    }
                }
                ForwardSearchHistory => {
                    self.read.state = InputState::TextSearch;
                    if self.read.last_cmd == Category::IncrementalSearch {
                        self.write.continue_search_history(false)?;
                    } else {
                        self.write.start_search_history(false)?;
                    }
                }
                ReverseSearchHistory => {
                    self.read.state = InputState::TextSearch;
                    if self.read.last_cmd == Category::IncrementalSearch {
                        self.write.continue_search_history(true)?;
                    } else {
                        self.write.start_search_history(true)?;
                    }
                }
                HistorySearchForward => {
                    if self.read.last_cmd == Category::Search {
                        self.write.continue_history_search(false)?;
                    } else {
                        self.write.start_history_search(false)?;
                    }
                }
                HistorySearchBackward => {
                    if self.read.last_cmd == Category::Search {
                        self.write.continue_history_search(true)?;
                    } else {
                        self.write.start_history_search(true)?;
                    }
                }
                QuotedInsert => {
                    self.read.state = InputState::QuotedInsert(
                        if n >= 0 { n as usize } else { 0 });
                }
                OverwriteMode => {
                    self.read.overwrite_mode = !self.read.overwrite_mode;

                    if !self.read.overwrite_mode {
                        self.read.overwritten_append = 0;
                        self.read.overwritten_chars.clear();
                    }

                    let mode = if self.read.overwrite_mode {
                        CursorMode::Overwrite
                    } else {
                        CursorMode::Normal
                    };

                    self.write.set_cursor_mode(mode)?;
                }
                Yank => {
                    self.yank()?;
                }
                YankPop => {
                    self.yank_pop()?;
                }
                Custom(ref name) => {
                    if let Some(fun) = self.get_function(name).cloned() {
                        fun.execute(self, n, ch)?;

                        category = fun.category();
                    }
                }
                Macro(ref seq) => {
                    self.read.queue_input(seq);
                }
            }

            if category != Category::Digit
            {
                self.write.input_arg = Digit::None;
                self.write.explicit_arg = false;

                self.read.last_cmd = category;

                if category != Category::Complete { self.read.completions = None; }

                if category != Category::Yank { self.read.last_yank = None; }
            }

            Ok(())
        }

        fn next_history(&mut self, n: usize) -> io::Result<()> { self.write.next_history(n) }

        fn prev_history(&mut self, n: usize) -> io::Result<()> { self.write.prev_history(n) }
        /// Resets input state at the start of `read_line`
        fn reset_input(&mut self)
        {
            self.read.reset_data();
            self.write.reset_data();
        }
    }
}

pub mod reader
{
    //! Provides access to terminal read operations
    use ::
    {
        borrow::{ Cow },
        collections::{ HashMap, SequenceMap, VecDeque },
        complete::{ Completer, Completion, DummyCompleter },
        command::{ Category, Command },
        mem::{ replace },
        ops::{ Deref, DerefMut },
        path::{ Path, PathBuf },
        signals::{ Signal },
        sync::{ Arc, MutexGuard },
        time::{ Duration, Instant },
        *,
    };
    /*
    use crate::command::{Category, Command};
    use crate::complete::{Completer, Completion, DummyCompleter};
    use crate::function::Function;
    use crate::inputrc::{parse_file, Directive};
    use crate::interface::Interface;
    use crate::prompter::Prompter;
    use crate::sys::path::{env_init_file, system_init_file, user_init_file};
    use crate::terminal::{
        RawRead, Signal, SignalSet, Size,
        Terminal, TerminalReader,
    };
    use crate::util::{first_char, match_name};
    use crate::variables::{Variable, Variables, VariableIter};
    */
    /// Default set of string characters
    pub const STRING_CHARS: &str = "\"'";

    /// Default set of word break characters
    pub const WORD_BREAK_CHARS: &str = " \t\n\"\\'`@$><=;|&{(";

    /// Indicates the start of a series of invisible characters in the prompt
    pub const START_INVISIBLE: char = '\x01';

    /// Indicates the end of a series of invisible characters in the prompt
    pub const END_INVISIBLE: char = '\x02';

    /// Maximum size of kill ring
    const MAX_KILLS: usize = 10;

    /// Provides access to data related to reading and processing user input.
    ///
    /// Holds a lock on terminal read operations.
    /// See [`Interface`] for more information about concurrent operations.
    ///
    /// An instance of this type can be constructed using the
    /// [`Interface::lock_reader`] method.
    ///
    /// [`Interface`]: ../interface/struct.Interface.html
    /// [`Interface::lock_reader`]: ../interface/struct.Interface.html#method.lock_reader
    pub struct Reader<'a, Term: 'a + Terminals> {
        iface: &'a Interface<Term>,
        lock: ReadLock<'a, Term>,
    }

    pub struct Read<Term:Terminals> {
        /// Application name
        pub application: Cow<'static, str>,

        /// Pending input
        pub input_buffer: Vec<u8>,
        /// Pending macro sequence
        pub macro_buffer: String,

        pub bindings: SequenceMap<Cow<'static, str>, Command>,
        pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,

        /// Current input sequence
        pub sequence: String,
        /// Whether newline has been received
        pub input_accepted: bool,

        /// Whether overwrite mode is currently active
        pub overwrite_mode: bool,
        /// Characters appended while in overwrite mode
        pub overwritten_append: usize,
        /// Characters overwritten in overwrite mode
        pub overwritten_chars: String,

        /// Configured completer
        pub completer: Arc<dyn Completer<Term>>,
        /// Character appended to completions
        pub completion_append_character: Option<char>,
        /// Current set of possible completions
        pub completions: Option<Vec<Completion>>,
        /// Current "menu-complete" entry being viewed:
        pub completion_index: usize,
        /// Start of the completed word
        pub completion_start: usize,
        /// Start of the inserted prefix of a completed word
        pub completion_prefix: usize,

        pub string_chars: Cow<'static, str>,
        pub word_break: Cow<'static, str>,

        pub last_cmd: Category,
        pub last_yank: Option<(usize, usize)>,
        pub kill_ring: VecDeque<String>,

        pub catch_signals: bool,
        pub ignore_signals: SignalSet,
        pub report_signals: SignalSet,
        pub last_resize: Option<Size>,
        pub last_signal: Option<Signal>,

        variables: Variables,

        pub state: InputState,
        pub max_wait_duration: Option<Duration>,
    }

    pub struct ReadLock<'a, Term: 'a + Terminals> {
        term: Box<dyn TerminalReader<Term> + 'a>,
        data: MutexGuard<'a, Read<Term>>,
    }

    /// Returned from [`read_line`] to indicate user input
    ///
    /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
    #[derive(Debug)]
    pub enum ReadResult {
        /// User issued end-of-file
        Eof,
        /// User input received
        Input(String),
        /// Reported signal was received
        Signal(Signal),
    }

    #[derive(Copy, Clone, Debug)]
    pub enum InputState {
        Inactive,
        NewSequence,
        ContinueSequence{
            expiry: Option<Instant>,
        },
        Number,
        CharSearch{
            n: usize,
            backward: bool,
        },
        TextSearch,
        CompleteIntro,
        CompleteMore(usize),
        QuotedInsert(usize),
    }

    impl<'a, Term: 'a + Terminals> Reader<'a, Term> 
    {
        pub fn new(iface: &'a Interface<Term>, lock: ReadLock<'a, Term>)
                -> Reader<'a, Term> {
            Reader{iface, lock}
        }

        /// Interactively reads a line from the terminal device.
        pub fn read_line(&mut self) -> io::Result<ReadResult> {
            loop {
                if let Some(res) = self.read_line_step(None)? {
                    return Ok(res);
                }
            }
        }
        /// Performs one step of the interactive `read_line` loop.
        pub fn read_line_step(&mut self, timeout: Option<Duration>)
                -> io::Result<Option<ReadResult>> {
            self.initialize_read_line()?;

            let state = self.prepare_term()?;
            let res = self.read_line_step_impl(timeout);
            self.lock.term.restore(state)?;

            res
        }
        /// Cancels an in-progress `read_line` operation.
        pub fn cancel_read_line(&mut self) -> io::Result<()> {
            self.end_read_line()
        }

        fn initialize_read_line(&mut self) -> io::Result<()> {
            if !self.lock.is_active() {
                self.prompter().start_read_line()?;
            }
            Ok(())
        }

        fn read_line_step_impl(&mut self, timeout: Option<Duration>)
                -> io::Result<Option<ReadResult>> {
            let do_read = if self.lock.is_input_available() {
                // This branch will be taken only if a macro has buffered some input.
                // We check for input with a zero duration to see if the user has
                // entered Ctrl-C, e.g. to interrupt an infinitely recursive macro.
                self.lock.term.wait_for_input(Some(Duration::from_secs(0)))?
            } else {
                let timeout = limit_duration(timeout, self.lock.max_wait_duration);
                self.lock.term.wait_for_input(timeout)?
            };

            if do_read {
                self.lock.read_input()?;
            }

            if let Some(size) = self.lock.take_resize() {
                self.handle_resize(size)?;
            }

            if let Some(sig) = self.lock.take_signal() {
                if self.lock.report_signals.contains(sig) {
                    return Ok(Some(ReadResult::Signal(sig)));
                }
                if !self.lock.ignore_signals.contains(sig) {
                    self.handle_signal(sig)?;
                }
            }

            // Acquire the write lock and process all available input
            {
                let mut prompter = self.prompter();

                prompter.check_expire_timeout()?;

                // If the macro buffer grows in size while input is being processed,
                // we end this step and let the caller try again. This is to allow
                // reading Ctrl-C to interrupt (perhaps infinite) macro execution.
                let mut macro_len = prompter.read.data.macro_buffer.len();

                while prompter.read.is_input_available() {
                    if let Some(ch) = prompter.read.read_char()? {
                        if let Some(r) = prompter.handle_input(ch)? {
                            prompter.end_read_line()?;
                            return Ok(Some(r));
                        }
                    }

                    let new_macro_len = prompter.read.data.macro_buffer.len();

                    if new_macro_len != 0 && new_macro_len >= macro_len {
                        break;
                    }

                    macro_len = new_macro_len;
                }
            }

            Ok(None)
        }

        fn end_read_line(&mut self) -> io::Result<()> {
            if self.lock.is_active() {
                self.prompter().end_read_line()?;
            }
            Ok(())
        }

        fn prepare_term(&mut self) -> io::Result<Term::PrepareState> {
            if self.read_next_raw() {
                self.lock.term.prepare(true, SignalSet::new())
            } else {
                let mut signals = self.lock.report_signals.union(self.lock.ignore_signals);

                if self.lock.catch_signals {
                    // Ctrl-C is always intercepted (unless we're catching no signals).
                    // By default, linefeed handles it by clearing the current input state.
                    signals.insert(Signal::Interrupt);
                }

                let block_signals = !self.lock.catch_signals;

                self.lock.term.prepare(block_signals, signals)
            }
        }

        fn read_next_raw(&self) -> bool {
            match self.lock.state {
                InputState::QuotedInsert(_) => true,
                _ => false
            }
        }
        /// Sets the input buffer to the given string.
        pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
            if self.lock.is_active() {
                self.prompter().set_buffer(buf)
            } else {
                self.iface.lock_write_data().set_buffer(buf);
                Ok(())
            }
        }
        /// Sets the cursor position in the input buffer.
        pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
            if self.lock.is_active() {
                self.prompter().set_cursor(pos)
            } else {
                self.iface.lock_write_data().set_cursor(pos);
                Ok(())
            }
        }
        /// Sets the prompt that will be displayed when `read_line` is called.
        pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
            self.prompter().set_prompt(prompt)
        }
        /// Adds a line to history.
        pub fn add_history(&self, line: String) {
            if !self.lock.is_active() {
                self.iface.lock_write().add_history(line);
            }
        }
        /// Adds a line to history, unless it is identical to the most recent entry.
        pub fn add_history_unique(&self, line: String) {
            if !self.lock.is_active() {
                self.iface.lock_write().add_history_unique(line);
            }
        }
        /// Removes all history entries.
        pub fn clear_history(&self) {
            if !self.lock.is_active() {
                self.iface.lock_write().clear_history();
            }
        }
        /// Removes the history entry at the given index.
        pub fn remove_history(&self, idx: usize) {
            if !self.lock.is_active() {
                self.iface.lock_write().remove_history(idx);
            }
        }
        /// Sets the maximum number of history entries.
        pub fn set_history_size(&self, n: usize) {
            if !self.lock.is_active() {
                self.iface.lock_write().set_history_size(n);
            }
        }
        /// Truncates history to the only the most recent `n` entries.
        pub fn truncate_history(&self, n: usize) {
            if !self.lock.is_active() {
                self.iface.lock_write().truncate_history(n);
            }
        }
        /// Returns the application name
        pub fn application(&self) -> &str {
            &self.lock.application
        }
        /// Sets the application name
        pub fn set_application<T>(&mut self, application: T)
                where T: Into<Cow<'static, str>> {
            self.lock.application = application.into();
        }
        /// Returns a reference to the current completer instance.
        pub fn completer(&self) -> &Arc<dyn Completer<Term>> {
            &self.lock.completer
        }
        /// Replaces the current completer, returning the previous instance.
        pub fn set_completer(&mut self, completer: Arc<dyn Completer<Term>>)
                -> Arc<dyn Completer<Term>> {
            replace(&mut self.lock.completer, completer)
        }
        /// Returns the value of the named variable or `None` if no such variable exists.
        pub fn get_variable(&self, name: &str) -> Option<Variable> {
            self.lock.get_variable(name)
        }
        /// Sets the value of the named variable and returns the previous value.
        pub fn set_variable(&mut self, name: &str, value: &str) -> Option<Variable> {
            self.lock.set_variable(name, value)
        }
        /// Returns an iterator over stored variables.
        pub fn variables(&self) -> VariableIter {
            self.lock.variables.iter()
        }
        /// Returns whether to "blink" matching opening parenthesis character 
        /// when a closing parenthesis character is entered.
        pub fn blink_matching_paren(&self) -> bool {
            self.lock.blink_matching_paren
        }
        /// Sets the `blink-matching-paren` variable.
        pub fn set_blink_matching_paren(&mut self, set: bool) {
            self.lock.blink_matching_paren = set;
        }
        /// Returns whether `linefeed` will catch certain signals.
        pub fn catch_signals(&self) -> bool {
            self.lock.catch_signals
        }
        /// Sets whether `linefeed` will catch certain signals.
        pub fn set_catch_signals(&mut self, enabled: bool) {
            self.lock.catch_signals = enabled;
        }
        /// Returns whether the given `Signal` is ignored.
        pub fn ignore_signal(&self, signal: Signal) -> bool {
            self.lock.ignore_signals.contains(signal)
        }
        /// Sets whether the given `Signal` will be ignored.
        pub fn set_ignore_signal(&mut self, signal: Signal, set: bool) {
            if set {
                self.lock.ignore_signals.insert(signal);
                self.lock.report_signals.remove(signal);
            } else {
                self.lock.ignore_signals.remove(signal);
            }
        }
        /// Returns whether the given `Signal` is to be reported.
        pub fn report_signal(&self, signal: Signal) -> bool {
            self.lock.report_signals.contains(signal)
        }
        /// Sets whether to report the given `Signal`.
        pub fn set_report_signal(&mut self, signal: Signal, set: bool) {
            if set {
                self.lock.report_signals.insert(signal);
                self.lock.ignore_signals.remove(signal);
            } else {
                self.lock.report_signals.remove(signal);
            }
        }
        /// Returns whether Tab completion is disabled.
        pub fn disable_completion(&self) -> bool {
            self.lock.disable_completion
        }
        /// Sets the `disable-completion` variable.
        pub fn set_disable_completion(&mut self, disable: bool) {
            self.lock.disable_completion = disable;
        }
        /// When certain control characters are pressed, 
        /// a character sequence equivalent to this character will be echoed.
        pub fn echo_control_characters(&self) -> bool {
            self.lock.echo_control_characters
        }
        /// Sets the `echo-control-characters` variable.
        pub fn set_echo_control_characters(&mut self, echo: bool) {
            self.lock.echo_control_characters = echo;
        }
        /// Returns the character, if any, that is appended to a successful completion.
        pub fn completion_append_character(&self) -> Option<char> {
            self.lock.completion_append_character
        }
        /// Sets the character, if any, that is appended to a successful completion.
        pub fn set_completion_append_character(&mut self, ch: Option<char>) {
            self.lock.completion_append_character = ch;
        }
        /// Returns the width of completion listing display.
        pub fn completion_display_width(&self) -> usize {
            self.lock.completion_display_width
        }
        /// Sets the `completion-display-width` variable.
        pub fn set_completion_display_width(&mut self, n: usize) {
            self.lock.completion_display_width = n;
        }
        /// Returns the minimum number of completion items that require user confirmation before listing.
        pub fn completion_query_items(&self) -> usize {
            self.lock.completion_query_items
        }
        /// Sets the `completion-query-items` variable.
        pub fn set_completion_query_items(&mut self, n: usize) {
            self.lock.completion_query_items = n;
        }
        /// Returns the timeout to wait for further user input when an ambiguous sequence has been entered.
        pub fn keyseq_timeout(&self) -> Option<Duration> {
            self.lock.keyseq_timeout
        }
        /// Sets the `keyseq-timeout` variable.
        pub fn set_keyseq_timeout(&mut self, timeout: Option<Duration>) {
            self.lock.keyseq_timeout = timeout;
        }
        /// Returns whether to list possible completions one page at a time.
        pub fn page_completions(&self) -> bool {
            self.lock.page_completions
        }
        /// Sets the `page-completions` variable.
        pub fn set_page_completions(&mut self, set: bool) {
            self.lock.page_completions = set;
        }
        /// Returns whether to list completions horizontally, rather than down the screen.
        pub fn print_completions_horizontally(&self) -> bool {
            self.lock.print_completions_horizontally
        }
        /// Sets the `print-completions-horizontally` variable.
        pub fn set_print_completions_horizontally(&mut self, set: bool) {
            self.lock.print_completions_horizontally = set;
        }
        /// Returns the set of characters that delimit strings.
        pub fn string_chars(&self) -> &str {
            &self.lock.string_chars
        }
        /// Sets the set of characters that delimit strings.
        pub fn set_string_chars<T>(&mut self, chars: T)
                where T: Into<Cow<'static, str>> {
            self.lock.string_chars = chars.into();
        }
        /// Returns the set of characters that indicate a word break.
        pub fn word_break_chars(&self) -> &str {
            &self.lock.word_break
        }
        /// Sets the set of characters that indicate a word break.
        pub fn set_word_break_chars<T>(&mut self, chars: T)
                where T: Into<Cow<'static, str>> {
            self.lock.word_break = chars.into();
        }
        /// Returns an iterator over bound sequences
        pub fn bindings(&self) -> BindingIter {
            self.lock.bindings()
        }
        /// Binds a sequence to a command.
        pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                where T: Into<Cow<'static, str>> {
            self.lock.bind_sequence(seq, cmd)
        }
        /// Binds a sequence to a command, if and only if the given sequence is not already bound to a command.
        pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool
                where T: Into<Cow<'static, str>> {
            self.lock.bind_sequence_if_unbound(seq, cmd)
        }
        /// Removes a binding for the given sequence.
        pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
            self.lock.unbind_sequence(seq)
        }
        /// Defines a named function to which sequences may be bound.
        pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
            self.lock.define_function(name, cmd)
        }
        /// Removes a function defined with the given name.
        pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
            self.lock.remove_function(name)
        }

        pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
            self.lock.data.evaluate_directives(term, dirs)
        }

        pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
            self.lock.data.evaluate_directive(term, dir)
        }

        fn prompter<'b>(&'b mut self) -> Prompter<'b, 'a, Term> {
            Prompter::new(
                &mut self.lock,
                self.iface.lock_write())
        }

        fn handle_resize(&mut self, size: Size) -> io::Result<()> {
            self.prompter().handle_resize(size)
        }

        fn handle_signal(&mut self, sig: Signal) -> io::Result<()> {
            self.prompter().handle_signal(sig)
        }
    }

    impl<'a, Term: 'a + Terminals> ReadLock<'a, Term> {
        pub fn new(term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>>)
                -> ReadLock<'a, Term> {
            ReadLock{term, data}
        }

        /// Reads the next character of input.
        ///
        /// Performs a non-blocking read from the terminal, if necessary.
        ///
        /// If non-input data was received (e.g. a signal) or insufficient input
        /// is available, `Ok(None)` is returned.
        pub fn read_char(&mut self) -> io::Result<Option<char>> {
            if let Some(ch) = self.macro_pop() {
                Ok(Some(ch))
            } else if let Some(ch) = self.decode_input()? {
                Ok(Some(ch))
            } else {
                Ok(None)
            }
        }

        fn read_input(&mut self) -> io::Result<()> {
            match self.term.read(&mut self.data.input_buffer)? {
                RawRead::Bytes(_) => (),
                RawRead::Resize(new_size) => {
                    self.last_resize = Some(new_size);
                }
                RawRead::Signal(sig) => {
                    self.last_signal = Some(sig);
                }
            }

            Ok(())
        }

        fn is_input_available(&self) -> bool {
            !self.data.macro_buffer.is_empty() || match self.peek_input() {
                Ok(Some(_)) | Err(_) => true,
                Ok(None) => false
            }
        }

        fn macro_pop(&mut self) -> Option<char> {
            if self.data.macro_buffer.is_empty() {
                None
            } else {
                Some(self.data.macro_buffer.remove(0))
            }
        }

        fn decode_input(&mut self) -> io::Result<Option<char>> {
            let res = self.peek_input();

            if let Ok(Some(ch)) = res {
                self.data.input_buffer.drain(..ch.len_utf8());
            }

            res
        }

        fn peek_input(&self) -> io::Result<Option<char>> {
            if self.data.input_buffer.is_empty() {
                Ok(None)
            } else {
                first_char(&self.data.input_buffer)
            }
        }

        pub fn reset_data(&mut self) {
            self.data.reset_data();
        }
    }

    impl<'a, Term: 'a + Terminals> Deref for ReadLock<'a, Term> {
        type Target = Read<Term>;

        fn deref(&self) -> &Read<Term> {
            &self.data
        }
    }

    impl<'a, Term: 'a + Terminals> DerefMut for ReadLock<'a, Term> {
        fn deref_mut(&mut self) -> &mut Read<Term> {
            &mut self.data
        }
    }

    impl<Term:Terminals> Deref for Read<Term> {
        type Target = Variables;

        fn deref(&self) -> &Variables {
            &self.variables
        }
    }

    impl<Term:Terminals> DerefMut for Read<Term> {
        fn deref_mut(&mut self) -> &mut Variables {
            &mut self.variables
        }
    }

    impl<Term:Terminals> Read<Term>
    {
        pub fn new(term: &Term, application: Cow<'static, str>) -> Read<Term> {
            let mut r = Read{
                application,

                bindings: default_bindings(),
                functions: HashMap::new(),

                input_buffer: Vec::new(),
                macro_buffer: String::new(),

                sequence: String::new(),
                input_accepted: false,

                overwrite_mode: false,
                overwritten_append: 0,
                overwritten_chars: String::new(),

                completer: Arc::new(DummyCompleter),
                completion_append_character: Some(' '),
                completions: None,
                completion_index: 0,
                completion_start: 0,
                completion_prefix: 0,

                string_chars: STRING_CHARS.into(),
                word_break: WORD_BREAK_CHARS.into(),

                last_cmd: Category::Other,
                last_yank: None,
                kill_ring: VecDeque::with_capacity(MAX_KILLS),

                catch_signals: true,
                ignore_signals: SignalSet::new(),
                report_signals: SignalSet::new(),
                last_resize: None,
                last_signal: None,

                variables: Variables::default(),

                state: InputState::Inactive,
                max_wait_duration: None,
            };

            r.read_init(term);
            r
        }

        pub fn bindings(&self) -> BindingIter {
            BindingIter(self.bindings.sequences().iter())
        }

        pub fn variables(&self) -> VariableIter {
            self.variables.iter()
        }

        fn take_resize(&mut self) -> Option<Size> {
            self.last_resize.take()
        }

        fn take_signal(&mut self) -> Option<Signal> {
            self.last_signal.take()
        }

        pub fn queue_input(&mut self, seq: &str) {
            self.macro_buffer.insert_str(0, seq);
        }

        pub fn is_active(&self) -> bool {
            match self.state {
                InputState::Inactive => false,
                _ => true
            }
        }

        pub fn reset_data(&mut self) {
            self.state = InputState::NewSequence;
            self.input_accepted = false;
            self.overwrite_mode = false;
            self.overwritten_append = 0;
            self.overwritten_chars.clear();
            self.sequence.clear();

            self.completions = None;

            self.last_cmd = Category::Other;
            self.last_yank = None;

            self.last_resize = None;
            self.last_signal = None;
        }

        pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                where T: Into<Cow<'static, str>> {
            self.bindings.insert(seq.into(), cmd)
        }

        pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool where
        T: Into<Cow<'static, str>>
        {
            match self.bindings.entry(seq.into())
            {
                Entry::Occupied(_) => false,
                Entry::Vacant(ent) => {
                    ent.insert(cmd);
                    true
                }
            }
        }

        pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
            self.bindings.remove(seq)
                .map(|(_, cmd)| cmd)
        }

        pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
            self.functions.insert(name.into(), cmd)
        }

        pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
            self.functions.remove(name)
        }

        fn read_init(&mut self, term: &Term) {
            if let Some(path) = env_init_file() {
                // If `INPUTRC` is present, even if invalid, parse nothing else.
                // Thus, an empty `INPUTRC` will inhibit loading configuration.
                self.read_init_file_if_exists(term, Some(path));
            } else {
                if !self.read_init_file_if_exists(term, user_init_file()) {
                    self.read_init_file_if_exists(term, system_init_file());
                }
            }
        }

        fn read_init_file_if_exists(&mut self, term: &Term, path: Option<PathBuf>) -> bool {
            match path {
                Some(ref path) if path.exists() => {
                    self.read_init_file(term, path);
                    true
                }
                _ => false
            }
        }

        fn read_init_file(&mut self, term: &Term, path: &Path) {
            if let Some(dirs) = parse_file(path) {
                self.evaluate_directives(term, dirs);
            }
        }

        /// Evaluates a series of configuration directives.
        pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
            for dir in dirs {
                self.evaluate_directive(term, dir);
            }
        }

        /// Evaluates a single configuration directive.
        pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
            match dir {
                Directive::Bind(seq, cmd) => {
                    self.bind_sequence(seq, cmd);
                }
                Directive::Conditional{name, value, then_group, else_group} => {
                    let name = name.as_ref().map(|s| &s[..]);

                    if self.eval_condition(term, name, &value) {
                        self.evaluate_directives(term, then_group);
                    } else {
                        self.evaluate_directives(term, else_group);
                    }
                }
                Directive::SetVariable(name, value) => {
                    self.set_variable(&name, &value);
                }
            }
        }

        fn eval_condition(&self, term: &Term, name: Option<&str>, value: &str) -> bool {
            match name {
                None => self.application == value,
                Some("lib") => value == "linefeed",
                Some("mode") => value == "emacs",
                Some("term") => self.term_matches(term, value),
                _ => false
            }
        }

        fn term_matches(&self, term: &Term, value: &str) -> bool {
            match_name(term.name(), value)
        }
    }

    /// Iterator over `Reader` bindings
    pub struct BindingIter<'a>(slice::Iter<'a, (Cow<'static, str>, Command)>);

    impl<'a> ExactSizeIterator for BindingIter<'a> {}

    impl<'a> Iterator for BindingIter<'a> {
        type Item = (&'a str, &'a Command);

        #[inline] fn next(&mut self) -> Option<Self::Item> {
            self.0.next().map(|&(ref s, ref cmd)| (&s[..], cmd))
        }

        #[inline] fn nth(&mut self, n: usize) -> Option<Self::Item> {
            self.0.nth(n).map(|&(ref s, ref cmd)| (&s[..], cmd))
        }

        #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
            self.0.size_hint()
        }
    }

    impl<'a> DoubleEndedIterator for BindingIter<'a> {
        #[inline] fn next_back(&mut self) -> Option<Self::Item> {
            self.0.next_back().map(|&(ref s, ref cmd)| (&s[..], cmd))
        }
    }

    fn default_bindings() -> SequenceMap<Cow<'static, str>, Command> {
        use crate::command::Command::*;

        SequenceMap::from(vec![
            // Carriage return and line feed
            ("\r".into(), AcceptLine),
            ("\n".into(), AcceptLine),

            // Possible sequences for arrow keys, Home, End
            ("\x1b[A".into(), PreviousHistory),
            ("\x1b[B".into(), NextHistory),
            ("\x1b[C".into(), ForwardChar),
            ("\x1b[D".into(), BackwardChar),
            ("\x1b[H".into(), BeginningOfLine),
            ("\x1b[F".into(), EndOfLine),

            // More possible sequences for arrow keys, Home, End
            ("\x1bOA".into(), PreviousHistory),
            ("\x1bOB".into(), NextHistory),
            ("\x1bOC".into(), ForwardChar),
            ("\x1bOD".into(), BackwardChar),
            ("\x1bOH".into(), BeginningOfLine),
            ("\x1bOF".into(), EndOfLine),

            // Possible sequences for Insert, Delete
            ("\x1b[2~".into(), OverwriteMode),
            ("\x1b[3~".into(), DeleteChar),

            // Basic commands
            ("\x01"    .into(), BeginningOfLine),           // Ctrl-A
            ("\x02"    .into(), BackwardChar),              // Ctrl-B
            ("\x04"    .into(), DeleteChar),                // Ctrl-D
            ("\x05"    .into(), EndOfLine),                 // Ctrl-E
            ("\x06"    .into(), ForwardChar),               // Ctrl-F
            ("\x07"    .into(), Abort),                     // Ctrl-G
            ("\x08"    .into(), BackwardDeleteChar),        // Ctrl-H
            ("\x0b"    .into(), KillLine),                  // Ctrl-K
            ("\x0c"    .into(), ClearScreen),               // Ctrl-L
            ("\x0e"    .into(), NextHistory),               // Ctrl-N
            ("\x10"    .into(), PreviousHistory),           // Ctrl-P
            ("\x12"    .into(), ReverseSearchHistory),      // Ctrl-R
            ("\x14"    .into(), TransposeChars),            // Ctrl-T
            ("\x15"    .into(), BackwardKillLine),          // Ctrl-U
            ("\x16"    .into(), QuotedInsert),              // Ctrl-V
            ("\x17"    .into(), UnixWordRubout),            // Ctrl-W
            ("\x19"    .into(), Yank),                      // Ctrl-Y
            ("\x1d"    .into(), CharacterSearch),           // Ctrl-]
            ("\x7f"    .into(), BackwardDeleteChar),        // Rubout
            ("\x1b\x08".into(), BackwardKillWord),          // Escape, Ctrl-H
            ("\x1b\x1d".into(), CharacterSearchBackward),   // Escape, Ctrl-]
            ("\x1b\x7f".into(), BackwardKillWord),          // Escape, Rubout
            ("\x1bb"   .into(), BackwardWord),              // Escape, b
            ("\x1bd"   .into(), KillWord),                  // Escape, d
            ("\x1bf"   .into(), ForwardWord),               // Escape, f
            ("\x1bt"   .into(), TransposeWords),            // Escape, t
            ("\x1by"   .into(), YankPop),                   // Escape, y
            ("\x1b#"   .into(), InsertComment),             // Escape, #
            ("\x1b<"   .into(), BeginningOfHistory),        // Escape, <
            ("\x1b>"   .into(), EndOfHistory),              // Escape, >

            // Completion commands
            ("\t"   .into(), Complete),             // Tab
            ("\x1b?".into(), PossibleCompletions),  // Escape, ?
            ("\x1b*".into(), InsertCompletions),    // Escape, *

            // Digit commands
            ("\x1b-".into(), DigitArgument),    // Escape, -
            ("\x1b0".into(), DigitArgument),    // Escape, 0
            ("\x1b1".into(), DigitArgument),    // Escape, 1
            ("\x1b2".into(), DigitArgument),    // Escape, 2
            ("\x1b3".into(), DigitArgument),    // Escape, 3
            ("\x1b4".into(), DigitArgument),    // Escape, 4
            ("\x1b5".into(), DigitArgument),    // Escape, 5
            ("\x1b6".into(), DigitArgument),    // Escape, 6
            ("\x1b7".into(), DigitArgument),    // Escape, 7
            ("\x1b8".into(), DigitArgument),    // Escape, 8
            ("\x1b9".into(), DigitArgument),    // Escape, 9
        ])
    }

    fn limit_duration(dur: Option<Duration>, max: Option<Duration>) -> Option<Duration> {
        match (dur, max) {
            (dur, None) | (None, dur) => dur,
            (Some(dur), Some(max)) => Some(dur.min(max)),
        }
    }
}

pub mod regex
{
    pub use ::re::{ * };

    pub fn contains( text: &str, ptn: &str ) -> bool
    {
        let re = match regex::Regex::new(ptn)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println!("Regex new error: {:?}", e);
                return false;
            }
        };
        
        re.is_match(text)
    }

    pub fn find_first_group(ptn: &str, text: &str) -> Option<String>
    {
        let re = match regex::Regex::new(ptn) {
            Ok(x) => x,
            Err(_) => return None,
        };
        match re.captures(text) {
            Some(caps) => {
                if let Some(x) = caps.get(1) {
                    return Some(x.as_str().to_owned());
                }
            }
            None => {
                return None;
            }
        }
        None
    }

    pub fn replace_all(text: &str, ptn: &str, ptn_to: &str) -> String
    {
        let re = regex::Regex::new(ptn).unwrap();
        let result = re.replace_all(text, ptn_to);
        result.to_string()
    }
}

pub mod scripts
{
    use ::
    {
        *,
    };

    pub fn run(sh: &mut shell::Shell, args: &Vec<String>) -> i32
    {
        let src_file = &args[1];
        let full_src_file: String;
        
        if src_file.contains('/')
        {
            full_src_file = src_file.clone();
        }

        else
        {
            let full_path = libs::path::find_file_in_path(src_file, false);
            if full_path.is_empty()
            {
                if !Path::new(src_file).exists()
                {
                    println_stderr!("cicada: {}: no such file", src_file);
                    return 1;
                }

                full_src_file = format!("./{}", src_file);
            }
            else { full_src_file = full_path.clone(); }
        }

        if !Path::new(&full_src_file).exists() 
        {
            println_stderr!("cicada: {}: no such file", src_file);
            return 1;
        }

        if Path::new(&full_src_file).is_dir() 
        {
            println_stderr!("cicada: {}: is a directory", src_file);
            return 1;
        }

        let mut file;
        match File::open(&full_src_file)
        {
            Ok(x) => file = x,
            Err(e) => {
                println_stderr!("cicada: {}: failed to open file - {:?}", &full_src_file, e.kind());
                return 1;
            }
        }

        let mut text = String::new();
        match file.read_to_string(&mut text) 
        {
            Ok(_) => {}
            Err(e) => 
            {
                match e.kind() 
                {
                    ErrorKind::InvalidData => 
                    {
                        println_stderr!("cicada: {}: not a valid script file", &full_src_file);
                    }
                    _ => 
                    {
                        println_stderr!("cicada: {}: error: {:?}", &full_src_file, e);
                    }
                }
                return 1;
            }
        }

        if text.contains("\\\n") 
        {
            let re = RegexBuilder::new(r#"([ \t]*\\\n[ \t]+)|([ \t]+\\\n[ \t]*)"#).multi_line(true).build().unwrap();
            text = re.replace_all(&text, " ").to_string();

            let re = RegexBuilder::new(r#"\\\n"#).multi_line(true).build().unwrap();
            text = re.replace_all(&text, "").to_string();
        }

        let re_func_head = Regex::new(r"^function ([a-zA-Z_-][a-zA-Z0-9_-]*) *(?:\(\))? *\{$").unwrap();
        let re_func_tail = Regex::new(r"^\}$").unwrap();
        let mut text_new = String::new();
        let mut enter_func = false;
        let mut func_name = String::new();
        let mut func_body = String::new();

        for line in text.clone().lines()
        {
            if re_func_head.is_match(line.trim())
            {
                enter_func = true;
                let cap = re_func_head.captures(line.trim()).unwrap();
                func_name = cap[1].to_string();
                func_body = String::new();
                continue;
            }

            if re_func_tail.is_match(line.trim())
            {
                sh.set_func(&func_name, &func_body);
                enter_func = false;
                continue;
            }

            if enter_func
            {
                func_body.push_str(line);
                func_body.push('\n');
            }

            else
            {
                text_new.push_str(line);
                text_new.push('\n');
            }
        }

        let mut status = 0;
        let cr_list = run_lines(sh, &text_new, args, false);

        if let Some(last) = cr_list.last() { status = last.status; }
        
        sh.exit_on_error = false;

        status
    }
}

pub mod sealed
{
    /// This trait being unreachable from outside the crate prevents outside implementations of our extension traits.
    pub trait Sealed {}
}

pub mod shell
{
    use ::
    {
        collections::{ HashMap },
        regex::{ replace_all },
        uuid::{ Uuid },
        *,
    };

    #[derive(Debug, Clone)]
    pub struct Shell
    {
        pub jobs: HashMap<i32, types::Job>,
        pub aliases: HashMap<String, String>,
        pub envs: HashMap<String, String>,
        pub funcs: HashMap<String, String>,
        pub cmd: String,
        pub current_dir: String,
        pub previous_dir: String,
        pub previous_cmd: String,
        pub previous_status: i32,
        pub is_login: bool,
        pub exit_on_error: bool,
        pub has_terminal: bool,
        pub session_id: String,
    }

    impl Shell
    {
        pub fn new() -> Shell
        {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = ::path::get_current_dir();
            let has_terminal = ::process::has_terminal();
            let (session_id, _) = uuid.split_at(13);
            Shell
            {
                jobs: HashMap::new(),
                aliases: HashMap::new(),
                envs: HashMap::new(),
                funcs: HashMap::new(),
                cmd: String::new(),
                current_dir: current_dir.clone(),
                previous_dir: String::new(),
                previous_cmd: String::new(),
                previous_status: 0,
                is_login: false,
                exit_on_error: false,
                has_terminal,
                session_id: session_id.to_string(),
            }
        }
    }
}

pub mod signals
{
    use ::
    {
        iter::{ FromIterator },
        nix::
        {
            sys::
            {
                signal,
                wait::{WaitPidFlag as WF, WaitStatus as WS, waitpid}
            },
            unistd::{ Pid },
        },
        *,
    };
    /*
    use errno::{errno, set_errno};
    use std::sync::Mutex;
    use std::collections::{HashMap, HashSet};
    */
    pub const NUM_SIGNALS: u8 = 6;
    /// Signal received through a terminal device
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum Signal
    {
        /// Break signal (`CTRL_BREAK_EVENT`); Windows only
        Break,
        /// Continue signal (`SIGCONT`); Unix only
        Continue,
        /// Interrupt signal (`SIGINT` on Unix, `CTRL_C_EVENT` on Windows)
        Interrupt,
        /// Terminal window resize (`SIGWINCH` on Unix, `WINDOW_BUFFER_SIZE_EVENT` on Windows)
        Resize,
        /// Suspend signal (`SIGTSTP`); Unix only
        Suspend,
        /// Quit signal (`SIGQUIT`); Unix only
        Quit,
    }
    
    pub fn block()
    {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        
        match signal::sigprocmask( signal::SigmaskHow::SIG_BLOCK, Some(&sigset), None )
        {
            Ok(_) => {},
            Err(e) =>
            {
                log!("sigprocmask block error: {:?}", e);
            }
        }
    }

    pub fn unblock()
    {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        match signal::sigprocmask(signal::SigmaskHow::SIG_UNBLOCK, Some(&sigset), None)
        {
            Ok(_) => {},
            Err(e) =>
            {
                log!("sigprocmask unblock error: {:?}", e);
            }
        }
    }

    pub fn setup_sigchld_handler()
    {
        unsafe
        {
            let sigset = signal::SigSet::empty();
            let handler = signal::SigHandler::Handler(handle_sigchld);
            let flags = signal::SaFlags::SA_RESTART;
            let sa = signal::SigAction::new(handler, flags, sigset);
            match signal::sigaction(signal::SIGCHLD, &sa)
            {
                Ok(_) => {},
                Err(e) => { log!("sigaction error: {:?}", e); }
            }
        }
    }
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };
} use std::sync::Arc;

pub mod system
{
    pub mod common
    {
        use ::
        {
            *,
        };
        /// A trait for viewing representations from std types.
        pub trait AsInner<Inner: ?Sized> { fn as_inner(&self) -> &Inner; }
        /// A trait for viewing representations from std types.
        pub trait AsInnerMut<Inner: ?Sized> { fn as_inner_mut(&mut self) -> &mut Inner; }
        /// A trait for extracting representations from std types.
        pub trait IntoInner<Inner> { fn into_inner(self) -> Inner; }
        /// A trait for creating std types from internal representations.
        pub trait FromInner<Inner> { fn from_inner(inner: Inner) -> Self; }
        /// Computes (value*numer)/denom without overflow,
        /// as long as both (numer*denom) and the overall result fit into i64.
        pub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64
        {
            let q = value / denom;
            let r = value % denom;
            q * numer + r * numer / denom
        }

        pub fn ignore_notfound<T>(result: ::io::Result<T>) -> ::io::Result<()>
        {
            match result
            {
                Err(err) if err.kind() == ::io::ErrorKind::NotFound => Ok(()),
                Ok(_) => Ok(()),
                Err(err) => Err(err),
            }
        }
    }

} pub use self::system as sys;

pub mod task
{
    pub use std::task::{ * };

    pub mod c
    {
        use ::
        {
            *,
        };

        pub fn mark_job_as_done(sh: &mut shell::Shell, gid: i32, pid: i32, reason: &str)
        {
            if let Some(mut job) = sh.remove_pid_from_job(gid, pid) {
                job.status = reason.to_string();
                if job.is_bg {
                    println_stderr!("");
                    print_job(&job);
                }
            }
        }

        pub fn try_wait_bg_jobs(sh: &mut shell::Shell, report: bool, sig_handler_enabled: bool)
        {
            if sh.jobs.is_empty() {
                return;
            }

            if !sig_handler_enabled {
                // we need to wait pids in case CICADA_ENABLE_SIG_HANDLER=0
                signals::handle_sigchld(Signal::SIGCHLD as i32);
            }

            let jobs = sh.jobs.clone();

            for (_i, job) in jobs.iter()
            {
                for pid in job.pids.iter()
                {
                    if let Some(_status) = signals::pop_reap_map(*pid)
                    {
                        mark_job_as_done(sh, job.gid, *pid, "Done");
                        continue;
                    }

                    if let Some(sig) = signals::killed_map_pop(*pid)
                    {
                        let reason = if sig == Signal::SIGQUIT as i32
                        {
                            format!("Quit: {}", sig)
                        }
                        else if sig == Signal::SIGINT as i32
                        {
                            format!("Interrupt: {}", sig)
                        }
                        else if sig == Signal::SIGKILL as i32
                        {
                            format!("Killed: {}", sig)
                        }
                        else if sig == Signal::SIGTERM as i32
                        {
                            format!("Terminated: {}", sig)
                        }
                        else
                        {
                            format!("Killed: {}", sig)
                        };

                        mark_job_as_done(sh, job.gid, *pid, &reason);
                        continue;
                    }

                    if signals::pop_stopped_map(*pid) {
                        mark_job_member_stopped(sh, *pid, job.gid, report);
                    } else if signals::pop_cont_map(*pid) {
                        mark_job_member_continued(sh, *pid, job.gid);
                    }
                }
            }
        }
    }
}

pub mod terminal
{
    use ::
    {
        *,
    };

    pub mod size
    {
        use ::
        {
            *,
        };
        /// Query the current processes's stdout, stdin, and stderr, to determine terminal width.
        pub fn dimensions() -> Option<(usize, usize)>
        {
            let w = unsafe { get_dimensions_any() };

            if w.ws_col == 0 || w.ws_row == 0 { None } else { Some((w.ws_col as usize, w.ws_row as usize)) }
        } 
    }
    /// Defines a low-level interface to the terminal
    pub trait Terminals: Sized + Send + Sync
    {
        /// Returned by `prepare`; passed to `restore` to restore state.
        type PrepareState;
        /*
        /// Holds an exclusive read lock and provides read operations
        type Reader: TerminalReader;
        /// Holds an exclusive write lock and provides write operations
        type Writer: TerminalWriter;
        */
        /// Returns the name of the terminal.
        fn name(&self) -> &str;
        /// Acquires a lock on terminal read operations 
        /// and returns a value holding that lock and granting access to such operations.
        fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a>;
        /// Acquires a lock on terminal write operations
        /// and returns a value holding that lock and granting access to such operations.
        fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a>;
    }
    /// Holds a lock on `Terminal` read operations
    pub trait TerminalReader<Term: Terminals>
    {
        /// Prepares the terminal for line reading and editing operations.
        fn prepare(&mut self, block_signals: bool, report_signals: SignalSet) -> io::Result<Term::PrepareState>;
        /// Like `prepare`, but called when the write lock is already held.
        unsafe fn prepare_with_lock
        (
            &mut self, 
            lock: &mut dyn TerminalWriter<Term>,
            block_signals: bool,
            report_signals: SignalSet
        ) -> io::Result<Term::PrepareState>;
        /// Restores the terminal state using the given state data.
        fn restore(&mut self, state: Term::PrepareState) -> io::Result<()>;
        /// Like `restore`, but called when the write lock is already held.
        unsafe fn restore_with_lock
        (
            &mut self,
            lock: &mut dyn TerminalWriter<Term>,
            state: Term::PrepareState
        ) -> io::Result<()>;
        /// Reads some input from the terminal and appends it to the given buffer.
        fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead>;
        /// Waits `timeout` for user input. If `timeout` is `None`, waits indefinitely.
        fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool>;
    }
    /// Holds a lock on `Terminal` write operations
    pub trait TerminalWriter<Term: Terminals>
    {
        /// Returns the size of the terminal window
        fn size(&self) -> io::Result<Size>;
        /// Presents a clear terminal screen, with cursor at first row, first column.
        fn clear_screen(&mut self) -> io::Result<()>;
        /// Clears characters on the line occupied by the cursor,
        /// beginning with the cursor and ending at the end of the line.
        fn clear_to_screen_end(&mut self) -> io::Result<()>;
        /// Moves the cursor up `n` cells; `n` may be zero.
        fn move_up(&mut self, n: usize) -> io::Result<()>;
        /// Moves the cursor down `n` cells; `n` may be zero.
        fn move_down(&mut self, n: usize) -> io::Result<()>;
        /// Moves the cursor left `n` cells; `n` may be zero.
        fn move_left(&mut self, n: usize) -> io::Result<()>;
        /// Moves the cursor right `n` cells; `n` may be zero.
        fn move_right(&mut self, n: usize) -> io::Result<()>;
        /// Moves the cursor to the first column of the current line
        fn move_to_first_column(&mut self) -> io::Result<()>;
        /// Set the current cursor mode
        fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>;
        /// Writes output to the terminal.
        fn write(&mut self, s: &str) -> io::Result<()>;
        /// Flushes any currently buffered output data.
        fn flush(&mut self) -> io::Result<()>;
    }
}

pub mod time
{
    pub use std::time::{ * };

    pub mod c
    {
        pub use ::timed::{ * };
        use ::
        {
            *,
        };

        #[derive(Debug, PartialEq, Eq)]
        pub struct DateTime
        {
            odt: OffsetDateTime,
        }

        impl DateTime
        {
            pub fn now() -> Self
            {
                let odt: OffsetDateTime = match OffsetDateTime::now_local()
                {
                    Ok(dt) => dt,
                    Err(_) => OffsetDateTime::now_utc(),
                };

                DateTime { odt }
            }

            pub fn from_timestamp(ts: f64) -> Self
            {
                let dummy_now = Self::now();
                let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
                let ts_nano = (ts + offset_seconds as f64) * 1000000000.0;
                let odt: OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos(ts_nano as i128)
                {
                    Ok(x) => x,
                    Err(_) => OffsetDateTime::now_utc(),
                };

                DateTime { odt }
            }

            pub fn unix_timestamp(&self) -> f64 { self.odt.unix_timestamp_nanos() as f64 / 1000000000.0 }
        }

        impl fmt::Display for DateTime
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            {
                write!
                (
                    f, "{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                    self.odt.year(),
                    self.odt.month() as u8,
                    self.odt.day(),
                    self.odt.hour(),
                    self.odt.minute(),
                    self.odt.second(),
                    self.odt.millisecond(),
                )
            }
        }
    }
}

pub mod types
{
    pub use std::primitive::{ * };

    use ::
    {
        collections::{ HashMap, HashSet },
        regex::{ Regex },
        *,
    };
    /*
    use crate::parsers::parser_line::tokens_to_redirections;
    */
    pub type Token = (String, String);
    pub type Tokens = Vec<Token>;
    pub type Redirection = (String, String, String);

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct WaitStatus(i32, i32, i32);

    impl WaitStatus
    {
        pub fn from_exited(pid: i32, status: i32) -> Self {
            WaitStatus(pid, 0, status)
        }

        pub fn from_signaled(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 1, sig)
        }

        pub fn from_stopped(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 2, sig)
        }

        pub fn from_continuted(pid: i32) -> Self {
            WaitStatus(pid, 3, 0)
        }

        pub fn from_others() -> Self {
            WaitStatus(0, 9, 9)
        }

        pub fn from_error(errno: i32) -> Self {
            WaitStatus(0, 255, errno)
        }

        pub fn empty() -> Self {
            WaitStatus(0, 0, 0)
        }

        pub fn is_error(&self) -> bool {
            self.1 == 255
        }

        pub fn is_others(&self) -> bool {
            self.1 == 9
        }

        pub fn is_signaled(&self) -> bool {
            self.1 == 1
        }

        pub fn get_errno(&self) -> nix::Error {
            nix::Error::from_raw(self.2)
        }

        pub fn is_exited(&self) -> bool {
            self.0 != 0 && self.1 == 0
        }

        pub fn is_stopped(&self) -> bool {
            self.1 == 2
        }

        pub fn is_continued(&self) -> bool {
            self.1 == 3
        }

        pub fn get_pid(&self) -> i32 {
            self.0
        }

        fn _get_signaled_status(&self) -> i32 {
            self.2 + 128
        }

        pub fn get_signal(&self) -> i32 {
            self.2
        }

        pub fn get_name(&self) -> String {
            if self.is_exited() {
                "Exited".to_string()
            } else if self.is_stopped() {
                "Stopped".to_string()
            } else if self.is_continued() {
                "Continued".to_string()
            } else if self.is_signaled() {
                "Signaled".to_string()
            } else if self.is_others() {
                "Others".to_string()
            } else if self.is_error() {
                "Error".to_string()
            } else {
                format!("unknown: {}", self.2)
            }
        }

        pub fn get_status(&self) -> i32 {
            if self.is_exited() {
                self.2
            } else {
                self._get_signaled_status()
            }
        }
    }

    impl fmt::Debug for WaitStatus
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let mut formatter = f.debug_struct("WaitStatus");
            formatter.field("pid", &self.0);
            let name = self.get_name();
            formatter.field("name", &name);
            formatter.field("ext", &self.2);
            formatter.finish()
        }
    }

    #[derive(Debug)]
    pub struct LineInfo
    {
        pub tokens: Tokens,
        pub is_complete: bool,
    }

    impl LineInfo
    {
        pub fn new(tokens: Tokens) -> Self { LineInfo { tokens, is_complete: true } }
    }
    
    #[derive(Debug)]
    pub struct Command
    {
        pub tokens: Tokens,
        pub redirects_to: Vec<Redirection>,
        pub redirect_from: Option<Token>,
    }

    impl Command
    {
        pub fn from_tokens(tokens: Tokens) -> Result<Command, String> {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");

            let mut len = tokens_new.len();
            while has_redirect_from {
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<") {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<<<") {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }

                has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");
            }

            let tokens_final;
            let redirects_to;
            match tokens_to_redirections(&tokens_new) {
                Ok((_tokens, _redirects_to)) => {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }
                Err(e) => {
                    return Err(e);
                }
            }

            let redirect_from = if redirects_from_type.is_empty() {
                None
            } else {
                Some((redirects_from_type, redirects_from_value))
            };

            Ok(Command{
                tokens: tokens_final,
                redirects_to,
                redirect_from,
            })
        }

        pub fn has_redirect_from(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<"
        }

        pub fn has_here_string(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<<<"
        }

        pub fn is_builtin(&self) -> bool {
            tools::is_builtin(&self.tokens[0].1)
        }
    }

    #[derive(Debug)]
    pub struct CommandLine
    {
        pub line: String,
        pub commands: Vec<Command>,
        pub envs: HashMap<String, String>,
        pub background: bool,
    }

    impl CommandLine
    {
        pub fn from_line(line: &str, sh: &mut shell::Shell) -> Result<CommandLine, String> {
            let linfo = parsers::line::parse(line);
            let mut tokens = linfo.tokens;
            shell::do_expansion(sh, &mut tokens);
            let envs = drain_env_tokens(&mut tokens);

            let mut background = false;
            let len = tokens.len();
            if len > 1 && tokens[len - 1].1 == "&" {
                background = true;
                tokens.pop();
            }

            let mut commands = Vec::new();
            for sub_tokens in split_tokens_by_pipes(&tokens) {
                match Command::from_tokens(sub_tokens) {
                    Ok(c) => {
                        commands.push(c);
                    }
                    Err(e) => {
                        return Err(e);
                    }
                }
            }

            Ok(CommandLine{
                line: line.to_string(),
                commands,
                envs,
                background,
            })
        }

        pub fn is_empty(&self) -> bool {
            self.commands.is_empty()
        }

        pub fn with_pipeline(&self) -> bool {
            self.commands.len() > 1
        }

        pub fn is_single_and_builtin(&self) -> bool {
            self.commands.len() == 1 && self.commands[0].is_builtin()
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Job
    {
        pub cmd: String,
        pub id: i32,
        pub gid: i32,
        pub pids: Vec<i32>,
        pub pids_stopped: HashSet<i32>,
        pub status: String,
        pub is_bg: bool,
    }

    impl Job
    {
        pub fn all_members_stopped(&self) -> bool {
            for pid in &self.pids {
                if !self.pids_stopped.contains(pid) {
                    return false;
                }
            }
            true
        }

        pub fn all_members_running(&self) -> bool {
            self.pids_stopped.is_empty()
        }
    }
    
    #[derive(Clone, Debug, Default)]
    pub struct CommandResult 
    {
        pub gid: i32,
        pub status: i32,
        pub stdout: String,
        pub stderr: String,
    }

    impl CommandResult
    {
        pub fn new() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 0,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn from_status(gid: i32, status: i32) -> CommandResult {
            CommandResult {
                gid,
                status,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn error() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 1,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    }
    
    #[derive(Clone, Debug, Default)]
    pub struct CommandOptions
    {
        pub background: bool,
        pub isatty: bool,
        pub capture_output: bool,
        pub envs: HashMap<String, String>,
    }

    fn split_tokens_by_pipes(tokens: &[Token]) -> Vec<Tokens>
    {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();
        for token in tokens {
            let sep = &token.0;
            let value = &token.1;
            if sep.is_empty() && value == "|" {
                if cmd.is_empty() {
                    return Vec::new();
                }
                cmds.push(cmd.clone());
                cmd = Vec::new();
            } else {
                cmd.push(token.clone());
            }
        }
        if cmd.is_empty() {
            return Vec::new();
        }
        cmds.push(cmd.clone());
        cmds
    }

    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String>
    {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new(r"^([a-zA-Z0-9_]+)=(.*)$").unwrap();
        for (sep, text) in tokens.iter()
        {
            if !sep.is_empty() || !::regex::contains(text, r"^([a-zA-Z0-9_]+)=(.*)$"){ break; }

            for cap in re.captures_iter(text)
            {
                let name = cap[1].to_string();
                let value = parsers::line::unquote(&cap[2]);
                envs.insert(name, value);
            }

            n += 1;
        }
        if n > 0 {
            tokens.drain(0..n);
        }
        envs
    }
}

pub mod uuid
{
    use ::
    {
        *,
    };
    /// A 128-bit (16 byte) buffer containing the UUID.
    pub type Bytes = [u8; 16];
    /// A Universally Unique Identifier (UUID).
    #[repr( transparent )] #[derive( Clone, Copy, Eq, Ord, PartialEq, PartialOrd )]
    pub struct Uuid( Bytes );

    impl Uuid
    {
        /// Creates a random UUID.
        pub fn new_v4() -> Uuid
        {
            Uuid::from_u128
            (
                //crate::rng::u128() & 0xFFFFFFFFFFFF4FFFBFFFFFFFFFFFFFFF | 0x40008000000000000000,
                128 & 0xFFFFFFFFFFFF4FFFBFFFFFFFFFFFFFFF | 0x40008000000000000000,
            )
        }

        #[inline] pub const fn from_bytes(bytes: Bytes) -> Uuid { Uuid(bytes) }

        pub const fn from_u128(v: u128) -> Self { Uuid::from_bytes(v.to_be_bytes()) }
    }
}

pub mod writer
{
    //! Provides access to terminal write operations
    use ::
    {
        borrow::{ Cow::{ self, Borrowed, Owned } },
        char::{is_ctrl, unctrl, ESCAPE, RUBOUT},
        collections::{ vec_deque, VecDeque },
        iter::{ repeat, Skip },
        mem::{ swap },
        ops::{ Deref, DerefMut, Range },
        reader::{ START_INVISIBLE, END_INVISIBLE },
        sync::{ MutexGuard },
        terminal::{ Terminals, TerminalWriter },
        time::{ Duration, Instant },
        *,
    };    
    /*
    use crate::terminal::{CursorMode, Size, Terminal, TerminalWriter};
    use crate::util::{
        backward_char, forward_char, backward_search_char, forward_search_char,
        filter_visible, is_combining_mark, is_wide, RangeArgument,
    };
    */
    /// Duration to wait for input when "blinking"
    pub const BLINK_DURATION: Duration = Duration::from_millis(500);
    /// Maximum value of digit input
    pub const NUMBER_MAX: i32 = 1_000_000;
    pub const COMPLETE_MORE: &'static str = "--More--";
    /// Default maximum history size
    pub const MAX_HISTORY: usize = !0;
    /// Tab column interval
    pub const TAB_STOP: usize = 8;
    // Length of "(arg: "
    pub const PROMPT_NUM_PREFIX: usize = 6;
    // Length of ") "
    pub const PROMPT_NUM_SUFFIX: usize = 2;
    // Length of "(i-search)`"
    pub const PROMPT_SEARCH_PREFIX: usize = 11;
    // Length of "failed "
    pub const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
    // Length of "reverse-"
    pub const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
    // Length of "': "
    pub const PROMPT_SEARCH_SUFFIX: usize = 3;
    /// Provides an interface to write line-by-line output to the terminal device.
    pub struct Writer<'a, 'b: 'a, Term: 'b + Terminals>
    {
        write: WriterImpl<'a, 'b, Term>,
    }

    pub enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminals>
    {
        Mutex(WriteLock<'b, Term>),
        MutRef(&'a mut WriteLock<'b, Term>),
    }

    pub struct Write
    {
        /// Input buffer
        pub buffer: String,
        /// Original buffer entered before searching through history
        pub backup_buffer: String,
        /// Position of the cursor
        pub cursor: usize,
        /// Position of the cursor if currently performing a blink
        blink: Option<Blink>,

        /// Stored history entries
        pub history: VecDeque<String>,
        /// History entry currently being edited;
        /// `None` if the new buffer is being edited
        pub history_index: Option<usize>,
        /// Maximum size of history
        history_size: usize,
        /// Number of history entries added since last loading history
        history_new_entries: usize,

        /// Whether the prompt is drawn; i.e. a `read_line` operation is in progress
        pub is_prompt_drawn: bool,

        /// Portion of prompt up to and including the final newline
        pub prompt_prefix: String,
        prompt_prefix_len: usize,
        /// Portion of prompt after the final newline
        pub prompt_suffix: String,
        prompt_suffix_len: usize,

        /// Current type of prompt
        pub prompt_type: PromptType,

        /// Whether a search in progress is a reverse search
        pub reverse_search: bool,
        /// Whether a search in progress has failed to find a match
        pub search_failed: bool,
        /// Current search string
        pub search_buffer: String,
        /// Last search string
        pub last_search: String,
        /// Selected history entry prior to a history search
        pub prev_history: Option<usize>,
        /// Position of the cursor prior to a history search
        pub prev_cursor: usize,

        /// Numerical argument
        pub input_arg: Digit,
        /// Whether a numerical argument was supplied
        pub explicit_arg: bool,

        /// Terminal size as of last draw operation
        pub screen_size: Size,
    }

    impl Write
    {
        pub fn new(screen_size: Size) -> Write {
            Write{
                buffer: String::new(),
                backup_buffer: String::new(),
                cursor: 0,
                blink: None,

                history: VecDeque::new(),
                history_index: None,
                history_size: MAX_HISTORY,
                history_new_entries: 0,

                is_prompt_drawn: false,

                prompt_prefix: String::new(),
                prompt_prefix_len: 0,
                prompt_suffix: String::new(),
                prompt_suffix_len: 0,

                prompt_type: PromptType::Normal,

                reverse_search: false,
                search_failed: false,
                search_buffer: String::new(),
                last_search: String::new(),
                prev_history: None,
                prev_cursor: !0,

                input_arg: Digit::None,
                explicit_arg: false,

                screen_size,
            }
        }

        pub fn history(&self) -> HistoryIter {
            HistoryIter(self.history.iter())
        }

        pub fn new_history(&self) -> Skip<HistoryIter> {
            let first_new = self.history.len() - self.history_new_entries;
            self.history().skip(first_new)
        }

        pub fn new_history_entries(&self) -> usize {
            self.history_new_entries
        }

        pub fn reset_data(&mut self) {
            self.buffer.clear();
            self.backup_buffer.clear();
            self.cursor = 0;
            self.history_index = None;

            self.prompt_type = PromptType::Normal;

            self.input_arg = Digit::None;
            self.explicit_arg = false;
        }

        pub fn reset_new_history(&mut self) {
            self.history_new_entries = 0;
        }

        pub fn set_buffer(&mut self, buf: &str) {
            self.buffer.clear();
            self.buffer.push_str(buf);
            self.cursor = buf.len();
        }

        pub fn set_cursor(&mut self, pos: usize) {
            if !self.buffer.is_char_boundary(pos) {
                panic!("invalid cursor position {} in buffer {:?}",
                    pos, self.buffer);
            }

            self.cursor = pos;
        }

        pub fn set_prompt(&mut self, prompt: &str) {
            let (pre, suf) = match prompt.rfind('\n') {
                Some(pos) => (&prompt[..pos + 1], &prompt[pos + 1..]),
                None => (&prompt[..0], prompt)
            };

            self.prompt_prefix = pre.to_owned();
            self.prompt_suffix = suf.to_owned();

            let pre_virt = ::filter::visible(pre);
            self.prompt_prefix_len = self.display_size(&pre_virt, 0);

            let suf_virt = ::filter::visible(suf);
            self.prompt_suffix_len = self.display_size(&suf_virt, 0);
        }

        pub fn display_size(&self, s: &str, start_col: usize) -> usize {
            let width = self.screen_size.columns;
            let mut col = start_col;

            let disp = Display{
                allow_tab: true,
                allow_newline: true,
                .. Display::default()
            };

            for ch in s.chars().flat_map(|ch| display(ch, disp)) {
                let n = match ch {
                    '\n' => width - (col % width),
                    '\t' => TAB_STOP - (col % TAB_STOP),
                    ch if ::is::combining_mark(ch) => 0,
                    ch if ::is::wide(ch) => {
                        if col % width == width - 1 {
                            // Can't render a fullwidth character into last column
                            3
                        } else {
                            2
                        }
                    }
                    _ => 1
                };

                col += n;
            }

            col - start_col
        }
    }

    pub struct WriteLock<'a, Term: 'a + Terminals>
    {
        term: Box<dyn TerminalWriter<Term> + 'a>,
        data: MutexGuard<'a, Write>,
    }

    impl<'a, Term: Terminals> WriteLock<'a, Term>
    {
        pub fn new(term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write>) -> WriteLock<'a, Term>
        {
            WriteLock{term, data}
        }

        pub fn size(&self) -> io::Result<Size> 
        {
            self.term.size()
        }

        pub fn flush(&mut self) -> io::Result<()> 
        {
            self.term.flush()
        }

        pub fn update_size(&mut self) -> io::Result<()> 
        {
            let size = self.size()?;
            self.screen_size = size;
            Ok(())
        }

        pub fn blink(&mut self, pos: usize) -> io::Result<()> 
        {
            self.expire_blink()?;

            let orig = self.cursor;
            self.move_to(pos)?;
            self.cursor = orig;

            let expiry = Instant::now() + BLINK_DURATION;

            self.blink = Some(Blink{
                pos,
                expiry,
            });

            Ok(())
        }

        pub fn check_expire_blink(&mut self, now: Instant) -> io::Result<bool> 
        {
            if let Some(blink) = self.data.blink {
                if now >= blink.expiry {
                    self.expire_blink()?;
                }
            }

            Ok(self.blink.is_none())
        }

        pub fn expire_blink(&mut self) -> io::Result<()> 
        {
            if let Some(blink) = self.data.blink.take() {
                self.move_from(blink.pos)?;
            }

            Ok(())
        }

        pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> 
        {
            self.expire_blink()?;

            let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

            if redraw {
                self.clear_full_prompt()?;
            }

            self.data.set_prompt(prompt);

            if redraw {
                self.draw_prompt()?;
            }

            Ok(())
        }
        /// Draws the prompt and current input, assuming the cursor is at column 0
        pub fn draw_prompt(&mut self) -> io::Result<()> 
        {
            self.draw_prompt_prefix()?;
            self.draw_prompt_suffix()
        }

        pub fn draw_prompt_prefix(&mut self) -> io::Result<()> 
        {
            match self.prompt_type {
                // Prefix is not drawn when completions are shown
                PromptType::CompleteMore => Ok(()),
                _ => {
                    let pfx = self.prompt_prefix.clone();
                    self.draw_raw_prompt(&pfx)
                }
            }
        }

        pub fn draw_prompt_suffix(&mut self) -> io::Result<()> 
        {
            match self.prompt_type {
                PromptType::Normal => {
                    let sfx = self.prompt_suffix.clone();
                    self.draw_raw_prompt(&sfx)?;
                }
                PromptType::Number => {
                    let n = self.input_arg.to_i32();
                    let s = format!("(arg: {}) ", n);
                    self.draw_text(0, &s)?;
                }
                PromptType::Search => {
                    let pre = match (self.reverse_search, self.search_failed) {
                        (false, false) => "(i-search)",
                        (false, true)  => "(failed i-search)",
                        (true,  false) => "(reverse-i-search)",
                        (true,  true)  => "(failed reverse-i-search)",
                    };

                    let ent = self.get_history(self.history_index).to_owned();
                    let s = format!("{}`{}': {}", pre, self.search_buffer, ent);

                    self.draw_text(0, &s)?;
                    let pos = self.cursor;

                    let (lines, cols) = self.move_delta(ent.len(), pos, &ent);
                    return self.move_rel(lines, cols);
                }
                PromptType::CompleteIntro(n) => {
                    return self.term.write(&complete_intro(n));
                }
                PromptType::CompleteMore => {
                    return self.term.write(COMPLETE_MORE);
                }
            }

            self.draw_buffer(0)?;
            let len = self.buffer.len();
            self.move_from(len)
        }

        pub fn redraw_prompt(&mut self, new_prompt: PromptType) -> io::Result<()> 
        {
            self.clear_prompt()?;
            self.prompt_type = new_prompt;
            self.draw_prompt_suffix()
        }

        /// Draws a portion of the buffer, starting from the given cursor position
        pub fn draw_buffer(&mut self, pos: usize) -> io::Result<()> 
        {
            let (_, col) = self.line_col(pos);

            let buf = self.buffer[pos..].to_owned();
            self.draw_text(col, &buf)?;
            Ok(())
        }

        /// Draw some text with the cursor beginning at the given column.
        fn draw_text(&mut self, start_col: usize, text: &str) -> io::Result<()> 
        {
            self.draw_text_impl(start_col, text, Display{
                allow_tab: true,
                allow_newline: true,
                .. Display::default()
            }, false)
        }

        fn draw_raw_prompt(&mut self, text: &str) -> io::Result<()> 
        {
            self.draw_text_impl(0, text, Display{
                allow_tab: true,
                allow_newline: true,
                allow_escape: true,
            }, true)
        }

        fn draw_text_impl(&mut self, start_col: usize, text: &str, disp: Display, handle_invisible: bool) 
        -> io::Result<()>
        {
            let width = self.screen_size.columns;
            let mut col = start_col;
            let mut out = String::with_capacity(text.len());

            let mut clear = false;
            let mut hidden = false;

            for ch in text.chars() {
                if handle_invisible && ch == START_INVISIBLE {
                    hidden = true;
                } else if handle_invisible && ch == END_INVISIBLE {
                    hidden = false;
                } else if hidden {
                    // Render the character, but assume it has 0 width.
                    out.push(ch);
                } else {
                    for ch in display(ch, disp) {
                        if ch == '\t' {
                            let n = TAB_STOP - (col % TAB_STOP);

                            if col + n > width {
                                let pre = width - col;
                                out.extend(repeat(' ').take(pre));
                                out.push_str(" \r");
                                out.extend(repeat(' ').take(n - pre));
                                col = n - pre;
                            } else {
                                out.extend(repeat(' ').take(n));
                                col += n;

                                if col == width {
                                    out.push_str(" \r");
                                    col = 0;
                                }
                            }
                        } else if ch == '\n' {
                            if !clear {
                                self.term.write(&out)?;
                                out.clear();
                                self.term.clear_to_screen_end()?;
                                clear = true;
                            }

                            out.push('\n');
                            col = 0;
                        } else if ::is::combining_mark(ch) {
                            out.push(ch);
                        } else if ::is::wide(ch) {
                            if col == width - 1 {
                                out.push_str("  \r");
                                out.push(ch);
                                col = 2;
                            } else {
                                out.push(ch);
                                col += 2;
                            }
                        } else {
                            out.push(ch);
                            col += 1;

                            if col == width {
                                // Space pushes the cursor to the next line,
                                // CR brings back to the start of the line.
                                out.push_str(" \r");
                                col = 0;
                            }
                        }
                    }
                }
            }

            if col == width {
                out.push_str(" \r");
            }

            self.term.write(&out)
        }

        pub fn set_buffer(&mut self, buf: &str) -> io::Result<()>
        {
            self.expire_blink()?;

            self.move_to(0)?;
            self.buffer.clear();
            self.buffer.push_str(buf);
            self.new_buffer()
        }

        pub fn set_cursor(&mut self, pos: usize) -> io::Result<()>
        {
            self.expire_blink()?;

            if !self.buffer.is_char_boundary(pos) {
                panic!("invalid cursor position {} in buffer {:?}",
                    pos, self.buffer);
            }

            self.move_to(pos)
        }

        pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
        {
            self.term.set_cursor_mode(mode)
        }

        pub fn history_len(&self) -> usize
        {
            self.history.len()
        }

        pub fn history_size(&self) -> usize
        {
            self.history_size
        }

        pub fn set_history_size(&mut self, n: usize)
        {
            self.history_size = n;
            self.truncate_history(n);
        }

        pub fn write_str(&mut self, s: &str) -> io::Result<()>
        {
            self.term.write(s)
        }

        pub fn start_history_search(&mut self, reverse: bool) -> io::Result<()>
        {
            self.search_buffer = self.buffer[..self.cursor].to_owned();

            self.continue_history_search(reverse)
        }

        pub fn continue_history_search(&mut self, reverse: bool) -> io::Result<()> 
        {
            if let Some(idx) = self.find_history_search(reverse) {
                self.set_history_entry(Some(idx));

                let pos = self.cursor;
                let end = self.buffer.len();

                self.draw_buffer(pos)?;
                self.clear_to_screen_end()?;
                self.move_from(end)?;
            }

            Ok(())
        }

        fn find_history_search(&self, reverse: bool) -> Option<usize> 
        {
            let len = self.history.len();
            let idx = self.history_index.unwrap_or(len);

            if reverse {
                self.history.iter().rev().skip(len - idx)
                    .position(|ent| ent.starts_with(&self.search_buffer))
                    .map(|pos| idx - (pos + 1))
            } else {
                self.history.iter().skip(idx + 1)
                    .position(|ent| ent.starts_with(&self.search_buffer))
                    .map(|pos| idx + (pos + 1))
            }
        }

        pub fn start_search_history(&mut self, reverse: bool) -> io::Result<()> 
        {
            self.reverse_search = reverse;
            self.search_failed = false;
            self.search_buffer.clear();
            self.prev_history = self.history_index;
            self.prev_cursor = self.cursor;

            self.redraw_prompt(PromptType::Search)
        }

        pub fn continue_search_history(&mut self, reverse: bool) -> io::Result<()> 
        {
            self.reverse_search = reverse;
            self.search_failed = false;

            {
                let data = &mut *self.data;
                data.search_buffer.clone_from(&data.last_search);
            }

            self.search_history_step()
        }

        pub fn end_search_history(&mut self) -> io::Result<()> 
        {
            self.redraw_prompt(PromptType::Normal)
        }

        pub fn abort_search_history(&mut self) -> io::Result<()> 
        {
            self.clear_prompt()?;

            let ent = self.prev_history;
            self.set_history_entry(ent);
            self.cursor = self.prev_cursor;

            self.prompt_type = PromptType::Normal;
            self.draw_prompt_suffix()
        }

        fn show_search_match(&mut self, next_match: Option<(Option<usize>, usize)>) -> io::Result<()>
        {
            self.clear_prompt()?;

            if let Some((idx, pos)) = next_match {
                self.search_failed = false;
                self.set_history_entry(idx);
                self.cursor = pos;
            } else {
                self.search_failed = true;
            }

            self.prompt_type = PromptType::Search;
            self.draw_prompt_suffix()
        }

        pub fn search_history_update(&mut self) -> io::Result<()>
        {
            // Search for the next match, perhaps including the current position
            let next_match = if self.reverse_search {
                self.search_history_backward(&self.search_buffer, true)
            } else {
                self.search_history_forward(&self.search_buffer, true)
            };

            self.show_search_match(next_match)
        }

        fn search_history_step(&mut self) -> io::Result<()>
        {
            if self.search_buffer.is_empty() {
                return self.redraw_prompt(PromptType::Search);
            }

            // Search for the next match
            let next_match = if self.reverse_search {
                self.search_history_backward(&self.search_buffer, false)
            } else {
                self.search_history_forward(&self.search_buffer, false)
            };

            self.show_search_match(next_match)
        }

        fn search_history_backward(&self, s: &str, include_cur: bool) -> Option<(Option<usize>, usize)>
        {
            let mut idx = self.history_index;
            let mut pos = Some(self.cursor);

            if include_cur && !self.search_failed {
                if let Some(p) = pos {
                    if self.get_history(idx).is_char_boundary(p + s.len()) {
                        pos = Some(p + s.len());
                    }
                }
            }

            loop {
                let line = self.get_history(idx);

                match line[..pos.unwrap_or(line.len())].rfind(s) {
                    Some(found) => {
                        pos = Some(found);
                        break;
                    }
                    None => {
                        match idx {
                            Some(0) => return None,
                            Some(n) => {
                                idx = Some(n - 1);
                                pos = None;
                            }
                            None => {
                                if self.history.is_empty() {
                                    return None;
                                } else {
                                    idx = Some(self.history.len() - 1);
                                    pos = None;
                                }
                            }
                        }
                    }
                }
            }

            pos.map(|pos| (idx, pos))
        }

        fn search_history_forward(&self, s: &str, include_cur: bool) -> Option<(Option<usize>, usize)>
        {
            let mut idx = self.history_index;
            let mut pos = Some(self.cursor);

            if !include_cur {
                if let Some(p) = pos {
                    pos = Some( ::char::forward(1, self.get_history(idx), p));
                }
            }

            loop {
                let line = self.get_history(idx);

                match line[pos.unwrap_or(0)..].find(s) {
                    Some(found) => {
                        pos = pos.map(|n| n + found).or(Some(found));
                        break;
                    }
                    None => {
                        if let Some(n) = idx {
                            if n + 1 == self.history.len() {
                                idx = None;
                            } else {
                                idx = Some(n + 1);
                            }
                            pos = None;
                        } else {
                            return None;
                        }
                    }
                }
            }

            pos.map(|pos| (idx, pos))
        }

        pub fn add_history(&mut self, line: String) 
        {
            if self.history.len() == self.history_size {
                self.history.pop_front();
            }

            self.history.push_back(line);
            self.history_new_entries = self.history.len()
                .min(self.history_new_entries + 1);
        }

        pub fn add_history_unique(&mut self, line: String) 
        {
            let is_duplicate = self.history.back().map_or(false, |ent| *ent == line);

            if !is_duplicate {
                self.add_history(line);
            }
        }

        pub fn clear_history(&mut self) 
        {
            self.truncate_history(0);
            self.history_new_entries = 0;
        }

        pub fn remove_history(&mut self, n: usize) 
        {
            if n < self.history.len() {
                let first_new = self.history.len() - self.history_new_entries;

                if n >= first_new {
                    self.history_new_entries -= 1;
                }

                self.history.remove(n);
            }
        }

        pub fn truncate_history(&mut self, n: usize) 
        {
            let len = self.history.len();

            if n < len {
                let _ = self.history.drain(..len - n);
                self.history_new_entries = self.history_new_entries.max(n);
            }
        }

        pub fn next_history(&mut self, n: usize) -> io::Result<()> 
        {
            if let Some(old) = self.history_index {
                let new = old.saturating_add(n);

                if new >= self.history.len() {
                    self.select_history_entry(None)?;
                } else {
                    self.select_history_entry(Some(new))?;
                }
            }

            Ok(())
        }

        pub fn prev_history(&mut self, n: usize) -> io::Result<()> 
        {
            if !self.history.is_empty() && self.history_index != Some(0) {
                let new = if let Some(old) = self.history_index {
                    old.saturating_sub(n)
                } else {
                    self.history.len().saturating_sub(n)
                };

                self.select_history_entry(Some(new))?;
            }

            Ok(())
        }

        pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
            if new != self.history_index {
                self.move_to(0)?;
                self.set_history_entry(new);
                self.new_buffer()?;
            }

            Ok(())
        }

        pub fn set_history_entry(&mut self, new: Option<usize>) 
        {
            let old = self.history_index;

            if old != new {
                let data = &mut *self.data;
                data.history_index = new;

                if let Some(old) = old {
                    data.history[old].clone_from(&data.buffer);
                } else {
                    swap(&mut data.buffer, &mut data.backup_buffer);
                }

                if let Some(new) = new {
                    data.buffer.clone_from(&data.history[new]);
                } else {
                    data.buffer.clear();
                    swap(&mut data.buffer, &mut data.backup_buffer);
                }
            }
        }

        fn get_history(&self, n: Option<usize>) -> &str 
        {
            if self.history_index == n {
                &self.buffer
            } else if let Some(n) = n {
                &self.history[n]
            } else {
                &self.backup_buffer
            }
        }

        pub fn backward_char(&mut self, n: usize) -> io::Result<()> 
        {
            let pos = ::char::backward(n, &self.buffer, self.cursor);
            self.move_to(pos)
        }

        pub fn forward_char(&mut self, n: usize) -> io::Result<()>
        {
            let pos = ::char::forward(n, &self.buffer, self.cursor);
            self.move_to(pos)
        }

        pub fn backward_search_char(&mut self, n: usize, ch: char) -> io::Result<()>
        {
            if let Some(pos) = ::char::backward_search(n, &self.buffer, self.cursor, ch)
            {
                self.move_to(pos)?;
            }

            Ok(())
        }

        pub fn forward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> 
        {
            if let Some(pos) = ::char::forward_search(n, &self.buffer, self.cursor, ch)
            {
                self.move_to(pos)?;
            }

            Ok(())
        }

        /// Deletes a range from the buffer; the cursor is moved to the end
        /// of the given range.
        pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
            let start = range.start().cloned().unwrap_or(0);
            let end = range.end().cloned().unwrap_or_else(|| self.buffer.len());

            self.move_to(start)?;

            let _ = self.buffer.drain(start..end);

            self.draw_buffer(start)?;
            self.term.clear_to_screen_end()?;
            let len = self.buffer.len();
            self.move_from(len)?;

            Ok(())
        }

        pub fn insert_str(&mut self, s: &str) -> io::Result<()>
        {
            let moves_combining = match self.buffer[self.cursor..].chars().next()
            {
                Some(ch) if ::is::combining_mark(ch) => true,
                _ => false
            };

            let cursor = self.cursor;
            self.buffer.insert_str(cursor, s);

            if moves_combining && cursor != 0
            {
                let pos = ::char::backward(1, &self.buffer, self.cursor);
                let (lines, cols) = self.move_delta(cursor, pos, &self.buffer);
                self.move_rel(lines, cols)?;
                self.draw_buffer(pos)?;
            }
            else { self.draw_buffer(cursor)?; }

            self.cursor += s.len();
            let len = self.buffer.len();
            self.move_from(len)
        }

        pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                -> io::Result<()> {
            // Ranges must not overlap
            assert!(src.end <= dest.start || src.start >= dest.end);

            // Final cursor position
            let final_cur = if src.start < dest.start {
                dest.end
            } else {
                dest.start + (src.end - src.start)
            };

            let (left, right) = if src.start < dest.start {
                (src, dest)
            } else {
                (dest, src)
            };

            self.move_to(left.start)?;

            let a = self.buffer[left.clone()].to_owned();
            let b = self.buffer[right.clone()].to_owned();

            let _ = self.buffer.drain(right.clone());
            self.buffer.insert_str(right.start, &a);

            let _ = self.buffer.drain(left.clone());
            self.buffer.insert_str(left.start, &b);

            let cursor = self.cursor;
            self.draw_buffer(cursor)?;
            self.term.clear_to_screen_end()?;

            self.cursor = final_cur;
            let len = self.buffer.len();
            self.move_from(len)
        }

        fn prompt_suffix_length(&self) -> usize {
            match self.prompt_type {
                PromptType::Normal => self.prompt_suffix_len,
                PromptType::Number => {
                    let n = number_len(self.input_arg.to_i32());
                    PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                }
                PromptType::Search => {
                    let mut prefix = PROMPT_SEARCH_PREFIX;

                    if self.reverse_search {
                        prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                    }
                    if self.search_failed {
                        prefix += PROMPT_SEARCH_FAILED_PREFIX;
                    }

                    let n = self.display_size(&self.search_buffer, prefix);
                    prefix + n + PROMPT_SEARCH_SUFFIX
                }
                PromptType::CompleteIntro(n) => complete_intro(n).len(),
                PromptType::CompleteMore => COMPLETE_MORE.len(),
            }
        }

        fn line_col(&self, pos: usize) -> (usize, usize) {
            let prompt_len = self.prompt_suffix_length();

            match self.prompt_type {
                PromptType::CompleteIntro(_) |
                PromptType::CompleteMore => {
                    let width = self.screen_size.columns;
                    (prompt_len / width, prompt_len % width)
                }
                _ => self.line_col_with(pos, &self.buffer, prompt_len)
            }
        }

        fn line_col_with(&self, pos: usize, buf: &str, start_col: usize) -> (usize, usize) {
            let width = self.screen_size.columns;
            if width == 0 {
                return (0, 0);
            }

            let n = start_col + self.display_size(&buf[..pos], start_col);

            (n / width, n % width)
        }

        pub fn clear_screen(&mut self) -> io::Result<()> {
            self.term.clear_screen()?;
            self.draw_prompt()?;

            Ok(())
        }

        pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
            self.term.clear_to_screen_end()
        }

        /// Draws a new buffer on the screen. Cursor position is assumed to be `0`.
        pub fn new_buffer(&mut self) -> io::Result<()> {
            self.draw_buffer(0)?;
            self.cursor = self.buffer.len();

            self.term.clear_to_screen_end()?;

            Ok(())
        }

        pub fn clear_full_prompt(&mut self) -> io::Result<()> {
            let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
            let (line, _) = self.line_col(self.cursor);
            self.term.move_up(prefix_lines + line)?;
            self.term.move_to_first_column()?;
            self.term.clear_to_screen_end()
        }

        pub fn clear_prompt(&mut self) -> io::Result<()> {
            let (line, _) = self.line_col(self.cursor);

            self.term.move_up(line)?;
            self.term.move_to_first_column()?;
            self.term.clear_to_screen_end()
        }

        /// Move back to true cursor position from some other position
        pub fn move_from(&mut self, pos: usize) -> io::Result<()> {
            let (lines, cols) = self.move_delta(pos, self.cursor, &self.buffer);
            self.move_rel(lines, cols)
        }

        pub fn move_to(&mut self, pos: usize) -> io::Result<()> {
            if pos != self.cursor {
                let (lines, cols) = self.move_delta(self.cursor, pos, &self.buffer);
                self.move_rel(lines, cols)?;
                self.cursor = pos;
            }

            Ok(())
        }

        pub fn move_to_end(&mut self) -> io::Result<()> {
            let pos = self.buffer.len();
            self.move_to(pos)
        }

        pub fn move_right(&mut self, n: usize) -> io::Result<()> {
            self.term.move_right(n)
        }

        /// Moves from `old` to `new` cursor position, using the given buffer
        /// as current input.
        fn move_delta(&self, old: usize, new: usize, buf: &str) -> (isize, isize) {
            let prompt_len = self.prompt_suffix_length();
            let (old_line, old_col) = self.line_col_with(old, buf, prompt_len);
            let (new_line, new_col) = self.line_col_with(new, buf, prompt_len);

            (new_line as isize - old_line as isize,
            new_col as isize - old_col as isize)
        }

        fn move_rel(&mut self, lines: isize, cols: isize) -> io::Result<()> {
            if lines > 0 {
                self.term.move_down(lines as usize)?;
            } else if lines < 0 {
                self.term.move_up((-lines) as usize)?;
            }

            if cols > 0 {
                self.term.move_right(cols as usize)?;
            } else if cols < 0 {
                self.term.move_left((-cols) as usize)?;
            }

            Ok(())
        }

        pub fn reset_data(&mut self) {
            self.data.reset_data();
        }

        pub fn set_digit_from_char(&mut self, ch: char) {
            let digit = match ch {
                '-' => Digit::NegNone,
                '0' ..= '9' => Digit::from(ch),
                _ => Digit::None
            };

            self.input_arg = digit;
            self.explicit_arg = true;
        }
    }

    #[derive(Copy, Clone)]
    struct Blink
    {
        pos: usize,
        expiry: Instant,
    }

    impl<'a, 'b: 'a, Term: 'b + Terminals> Writer<'a, 'b, Term>
    {
        fn new(mut write: WriterImpl<'a, 'b, Term>, clear: bool) -> io::Result<Self> {
            write.expire_blink()?;

            if write.is_prompt_drawn {
                if clear {
                    write.clear_full_prompt()?;
                } else {
                    write.move_to_end()?;
                    write.write_str("\n")?;
                }
            }

            Ok(Writer{write})
        }

        pub fn with_lock(write: WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
            Writer::new(WriterImpl::Mutex(write), clear)
        }

        pub fn with_ref(write: &'a mut WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
            Writer::new(WriterImpl::MutRef(write), clear)
        }

        /// Returns an iterator over history entries.
        pub fn history(&self) -> HistoryIter {
            self.write.history()
        }

        /// Writes some text to the terminal device.
        ///
        /// Before the `Writer` is dropped, any output written should be followed
        /// by a newline. A newline is automatically written if the `writeln!`
        /// macro is used.
        pub fn write_str(&mut self, s: &str) -> io::Result<()> {
            self.write.write_str(s)
        }

        /// Writes formatted text to the terminal display.
        ///
        /// This method enables `Interface` to be used as the receiver to
        /// the [`writeln!`] macro.
        ///
        /// If the text contains any unprintable characters (e.g. escape sequences),
        /// those characters will be escaped before printing.
        ///
        /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
        /// [`writeln!`]: https://doc.rust-lang.org/std/macro.writeln.html
        pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {
            let s = args.to_string();
            self.write_str(&s)
        }
    }

    impl<'a, 'b: 'a, Term: 'b + Terminals> Drop for Writer<'a, 'b, Term>
    {
        fn drop(&mut self) {
            if self.write.is_prompt_drawn {
                // There's not really anything useful to be done with this error.
                let _ = self.write.draw_prompt();
            }
        }
    }

    impl<'a, Term: 'a + Terminals> Deref for WriteLock<'a, Term>
    {
        type Target = Write;

        fn deref(&self) -> &Write {
            &self.data
        }
    }

    impl<'a, Term: 'a + Terminals> DerefMut for WriteLock<'a, Term>
    {
        fn deref_mut(&mut self) -> &mut Write {
            &mut self.data
        }
    }
    
    #[derive(Copy, Clone, Debug)]
    pub enum Digit
    {
        None,
        NegNone,
        Num(i32),
        NegNum(i32),
    }

    impl Digit
    {
        pub fn input(&mut self, n: i32)
        {
            match *self
            {
                Digit::None => *self = Digit::Num(n),
                Digit::NegNone => *self = Digit::NegNum(n),
                Digit::Num(ref mut m) | Digit::NegNum(ref mut m) =>
                {
                    *m *= 10;
                    *m += n;
                }
            }
        }

        pub fn is_out_of_bounds(&self) -> bool
        {
            match *self
            {
                Digit::Num(n) | Digit::NegNum(n) if n > NUMBER_MAX => true,
                _ => false
            }
        }

        pub fn to_i32(&self) -> i32
        {
            match *self
            {
                Digit::None => 1,
                Digit::NegNone => -1,
                Digit::Num(n) => n,
                Digit::NegNum(n) => -n,
            }
        }
    }

    impl From<char> for Digit
    {
        /// Convert a decimal digit character to a `Digit` value.
        fn from(ch: char) -> Digit
        {
            let n = (ch as u8) - b'0';
            Digit::Num(n as i32)
        }
    }

    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum PromptType
    {
        Normal,
        Number,
        Search,
        CompleteIntro(usize),
        CompleteMore,
    }

    impl PromptType
    {
        pub fn is_normal(&self) -> bool { *self == PromptType::Normal }
    }

    impl<'a, 'b, Term: 'b + Terminals> Deref for WriterImpl<'a, 'b, Term>
    {
        type Target = WriteLock<'b, Term>;
        fn deref(&self) -> &WriteLock<'b, Term>
        {
            match *self
            {
                WriterImpl::Mutex(ref m) => m,
                WriterImpl::MutRef(ref m) => m,
            }
        }
    }

    impl<'a, 'b: 'a, Term: 'b + Terminals> DerefMut for WriterImpl<'a, 'b, Term>
    {
        fn deref_mut(&mut self) -> &mut WriteLock<'b, Term>
        {
            match *self
            {
                WriterImpl::Mutex(ref mut m) => m,
                WriterImpl::MutRef(ref mut m) => m,
            }
        }
    }
    /// Iterator over `Interface` history entries
    pub struct HistoryIter<'a>(vec_deque::Iter<'a, String>);

    impl<'a> ExactSizeIterator for HistoryIter<'a> {}

    impl<'a> Iterator for HistoryIter<'a>
    {
        type Item = &'a str;

        #[inline] fn next(&mut self) -> Option<&'a str> { self.0.next().map(|s| &s[..]) }

        #[inline] fn nth(&mut self, n: usize) -> Option<&'a str> { self.0.nth(n).map(|s| &s[..]) }

        #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }
    }

    impl<'a> DoubleEndedIterator for HistoryIter<'a>
    {
        #[inline] fn next_back(&mut self) -> Option<&'a str> { self.0.next_back().map(|s| &s[..]) }
    }

    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum DisplaySequence
    {
        Char(char),
        Escape(char),
        End,
    }

    impl Iterator for DisplaySequence
    {
        type Item = char;

        fn next(&mut self) -> Option<char>
        {
            use self::DisplaySequence::*;

            let (res, next) = match *self
            {
                Char(ch) => (ch, End),
                Escape(ch) => ('^', Char(ch)),
                End => return None
            };

            *self = next;
            Some(res)
        }

        fn size_hint(&self) -> (usize, Option<usize>)
        {
            use self::DisplaySequence::*;

            let n = match *self
            {
                Char(_) => 1,
                Escape(_) => 2,
                End => 0,
            };

            (n, Some(n))
        }
    }

    #[derive(Copy, Clone, Debug, Default)]
    pub struct Display
    {
        allow_tab: bool,
        allow_newline: bool,
        allow_escape: bool,
    }

    pub fn display(ch: char, style: Display) -> DisplaySequence
    {
        match ch
        {
            '\t' if style.allow_tab => DisplaySequence::Char(ch),
            '\n' if style.allow_newline => DisplaySequence::Char(ch),
            ESCAPE if style.allow_escape => DisplaySequence::Char(ch),
            '\0' => DisplaySequence::Escape('@'),
            RUBOUT => DisplaySequence::Escape('?'),
            ch if is_ctrl(ch) => DisplaySequence::Escape(unctrl(ch)),
            ch => DisplaySequence::Char(ch)
        }
    }

    pub fn display_str<'a>(s: &'a str, style: Display) -> Cow<'a, str>
    {
        if s.chars().all(|ch| display(ch, style) == DisplaySequence::Char(ch))
        {
            Borrowed(s)
        } else {
            Owned(s.chars().flat_map(|ch| display(ch, style)).collect())
        }
    }

    fn complete_intro(n: usize) -> String { format!("Display all {} possibilities? (y/n)", n) }

    fn number_len(n: i32) -> usize
    {
        match n
        {
            -1_000_000              => 8,
            -  999_999 ..= -100_000 => 7,
            -   99_999 ..= - 10_000 => 6,
            -    9_999 ..= -  1_000 => 5,
            -      999 ..= -    100 => 4,
            -       99 ..= -     10 => 3,
            -        9 ..= -      1 => 2,
                    0 ..=        9 => 1,
                    10 ..=       99 => 2,
                100 ..=      999 => 3,
                1_000 ..=    9_999 => 4,
                10_000 ..=   99_999 => 5,
            100_000 ..=  999_999 => 6,
            1_000_000              => 7,
            _ => unreachable!()
        }
    }
}

fn main()
{
    unsafe
    {
        libc::signal(libc::SIGPIPE, libc::SIG_DFL);

        // ignore SIGTSTP (ctrl-Z) for the shell itself
        libc::signal(libc::SIGTSTP, libc::SIG_IGN);
        libc::signal(libc::SIGQUIT, libc::SIG_IGN);
    }

    ::env::initialize_paths();

    let mut sh = ::shell::Shell::new();
    let args: Vec<String> = ::env::args().collect();

    if ::is::login(&args)
    {
        ::fs::load_rc_files(&mut sh);
        sh.is_login = true;
    }
    
    ::prompt::initialize_cache();
    ::prompt::update_aliases( &sh );

    if ::is::script(&args)
    {
        log!("run script: {:?} ", &args);
        let status = ::scripts::run(&mut sh, &args);
        ::process::exit(status);
    }

    if ::is::command_string(&args)
    {
        let line = ::env::args_to_command_line();
        log!("run with -c args: {}", &line);
        now::run_command_line(&mut sh, &line, false, false);
        ::process::exit(sh.previous_status);
    }

    if ::is::non_tty()
    {
        now::run_procs_for_non_tty(&mut sh);
        return;
    }

    let mut rl;
    match ::ffi::Interface::new("pls")
    {
        Ok(x) => rl = x,
        Err(e) =>
        {
            println!(":: lineread error: {}", e);
            return;
        }
    }

    rl.define_function("enter-function", Arc::new( ffi::EnterFunction ));
    rl.bind_sequence("\r", ::command::Command::from_str("enter-function"));

    let highlighter = prompt::create_highlighter();
    rl.set_highlighter(highlighter);

    history::initialize(&mut rl);
    rl.set_completer(Arc::new(complete::ShellCompleter
    {
        sh: Arc::new(sh.clone()),
    }));

    let sig_handler_enabled = ::is::signal_handler_enabled();
    
    if sig_handler_enabled
    {
        signals::setup_sigchld_handler();
        signals::block();
    }

    loop
    {
        let prompt = prompt::get(&sh);
        match rl.set_prompt(&prompt)
        {
            Ok(_) => {}
            Err(e) =>
            {
                println_stderr!(":: prompt error: {}", e);
            }
        }

        if sig_handler_enabled  { signals::unblock(); }
        
        match rl.read_line() 
        {
            Ok( ::reader::ReadResult::Input( line ) ) => 
            {
                if sig_handler_enabled { signals::block(); }

                let line = shell::trim_multiline_prompts(&line);
                
                if line.trim() == ""
                {
                    task::c::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                    continue;
                }

                sh.cmd = line.clone();

                let tsb = ::time::c::DateTime::now().unix_timestamp();
                let mut line = line.clone();
                
                ::expand::bangbang(&sh, &mut line);

                let mut status = 0;
                let cr_list = ::now::run_command_line(&mut sh, &line, true, false);

                if let Some(last) = cr_list.last() { status = last.status; }

                let tse = ::time::c::DateTime::now().unix_timestamp();

                if !sh.cmd.starts_with(' ') && line != sh.previous_cmd
                {
                    ::history::add(&sh, &mut rl, &line, status, tsb, tse);
                    sh.previous_cmd = line.clone();
                }

                if ::is::shell_altering_command( &line )
                {
                    rl.set_completer(Arc::new( ::complete::ShellCompleter
                    {
                        sh: Arc::new(sh.clone()),
                    }));
                    
                    ::prompt::update_aliases(&sh);
                }

                task::c::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                continue;
            }
            
            Ok( ::reader::ReadResult::Eof ) => 
            {
                if let Ok(x) = ::env::var("NO_EXIT_ON_CTRL_D") { if x == "1" { println!(); } }
                else
                {
                    println!("exit");
                    break;
                }
            }

            Ok( ::reader::ReadResult::Signal( s ) ) => 
            {
                println_stderr!("readline signal: {:?}", s);
            }

            Err(e) => 
            {
                println_stderr!("readline error: {}", e);
                unsafe
                {
                    let gid = ::libc::getpgid(0);
                    ::terminal::give_to(gid);
                }
            }
        }

        if sig_handler_enabled { signals::block(); }
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 8478
