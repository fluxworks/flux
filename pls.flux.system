#![feature
(
    tool_lints
)]

#![allow
(
    non_camel_case_types,
    unknown_lints,
    unused_imports,
    unused_macros,
)]
/**/
#[macro_use] extern crate lazy_static;
/**/
extern crate libc;
extern crate nix;
extern crate regex as re;
extern crate time as timed;

#[macro_use] pub mod macros
{
    use ::
    {
        *,
    };

    #[macro_export] macro_rules! log
    {
        ($fmt:expr) => 
        (
            let log_file = if let Ok(x) = ::env::var("CICADA_LOG_FILE") { x.clone() } else { String::new() };

            if !log_file.is_empty()
            {
                use ::io::Write as _;

                let msg = $fmt;

                match std::fs::OpenOptions::new().append(true).create(true).open(&log_file)
                {
                    Ok(mut cfile) =>
                    {
                        let pid = ::process::getpid();
                        let now = ::time::c::DateTime::now();
                        let msg = format!("[{}][{}] {}", now, pid, msg);
                        let msg = if msg.ends_with('\n') { msg } else { format!("{}\n", msg) };
                        match cfile.write_all(msg.as_bytes())
                        {
                            Ok(_) => {}
                            Err(_) => println!("tlog: write_all error")
                        }
                    }
                    Err(_) => println!("tlog: open file error"),
                }
            }
        );

        ($fmt:expr, $($arg:tt)*) => 
        (
            let msg = format!($fmt, $($arg)*);
            log!(&msg);
        );
    }

    #[macro_export] macro_rules! println_stderr
    {
        ($fmt:expr) =>
        (
            match writeln!( &mut ::io::stderr(), $fmt )
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );

        ($fmt:expr, $($arg:tt)*) =>
        (
            match writeln!( &mut ::io::stderr(), $fmt, $($arg)* )
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );
    }
}

pub mod collections
{
    pub use std::collections::{ * };
}

pub mod complete
{
    use ::
    {
        *,
    };

    pub struct ShellCompleter
    {
        pub sh: Arc<shell::Shell>,
    }
}

pub mod env
{
    pub use std::env::{ * };

    use ::
    {
        path::{ Path },
        *,
    };

    pub fn init_path_env()
    {
        let mut paths: Vec<String> = vec![];
        
        for x in
        [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ]
        {
            if Path::new(x).exists(){ paths.push(x.to_string()); }
        }

        if let Ok(env_path) = var("PATH")
        {
            for x in env_path.split(":")
            {
                if !paths.contains(&x.to_string())
                {
                    paths.push(x.to_string());
                }
            }
        }

        let paths = paths.join(":");
        set_var("PATH", paths);
    }

}

pub mod expand
{
    use ::
    {
        regex::{ contains },
        *,
    };
    /*
    pub fn extend_bangbang(sh: &shell::Shell, line: &mut String) */
    pub fn bangbang(sh: &shell::Shell, line: &mut String)
    {
        if !contains(line, r"!!") { return; }
        
        if sh.previous_cmd.is_empty() { return; }

        let re = Regex::new(r"!!").unwrap();
        let mut replaced = false;
        let mut new_line = String::new();
        let linfo = parsers::parser_line::parse_line(line);

        for (sep, token) in linfo.tokens
        {
            if !sep.is_empty() { new_line.push_str(&sep); }

            if re_contains(&token, r"!!") && sep != "'"
            {
                let line2 = token.clone();
                let result = re.replace_all(&line2, sh.previous_cmd.as_str());
                new_line.push_str(&result);
                replaced = true;
            }
            else { new_line.push_str(&token); }

            if !sep.is_empty() { new_line.push_str(&sep); }

            new_line.push(' ');
        }

        *line = new_line.trim_end().to_string();
        
        if replaced { println!("{}", line); }
    }
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod fs
{
    pub use std::fs::{ * };
}

pub mod history
{
    use ::
    {
        *,
    };

    pub fn add(sh: &shell::Shell, rl: &mut Interface<DefaultTerminal>, line: &str, status: i32, tsb: f64, tse: f64)
    {
        add_raw(sh, line, status, tsb, tse);
        rl.add_history(line.to_string());
    }
}

pub mod io
{
    pub use std::io::{ * };
} use std::io::Write as _;

pub mod is
{
    use ::
    {
        *,
    };
    /*
    pub fn is_shell_altering_command(...) -> bool */
    pub fn shell_altering_command( line: &str ) -> bool
    {
        let line = line.trim();
        
        if ::regex::contains(line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$") { return true; }

        line.starts_with("alias ")
        || line.starts_with("export ")
        || line.starts_with("unalias ")
        || line.starts_with("unset ")
        || line.starts_with("source ")
    }
    /*
    pub fn is_signal_handler_enabled() -> bool */
    pub fn signal_handler_enabled() -> bool
    {
        ::env::var("CICADA_ENABLE_SIG_HANDLER").map_or(false, |x| x == "1")
    }
}

pub mod iter
{
    pub use std::iter::{ * };
}

pub mod now
{
    use ::
    {
        *,
    };

    pub fn run_command_line(sh: &mut Shell, line: &str, tty: bool, capture: bool) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();

        for token in parsers::parser_line::line_to_cmds(line)
        {
            if token == ";" || token == "&&" || token == "||"
            {
                sep = token.clone();
                continue;
            }

            if sep == "&&" && status != 0 { break; }

            if sep == "||" && status == 0 { break; }

            let cmd = token.clone();
            let cr = run_proc(sh, &cmd, tty, capture);
            status = cr.status;
            sh.previous_status = status;
            cr_list.push(cr);
        }

        cr_list
    }
}

pub mod path
{
    pub use std::path::{ * };
}

pub mod process
{
    pub use std::process::{ * };
    pub fn getpid() -> i32 { unsafe { ::libc::getpid() } }
}

pub mod prompt
{
    use ::
    {
        collections::{ HashSet },
        sync::{ Mutex },
        *,
    };

    /// ANSI color codes wrapped with \x01 and \x02 for lineread
    pub const GREEN: &str = "\x01\x1b[0;32m\x02";

    lazy_static!
    {
        pub static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
        pub static ref ALIASES: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
    }
    /// Update aliases in the prompts highlight's cache
    pub fn update_aliases(sh: &shell::Shell)
    {
        if let Ok(mut aliases) = ALIASES.lock()
        {
            aliases.clear();
            
            for alias_name in sh.aliases.keys()
            {
                aliases.insert(alias_name.clone());
            }
        }
    }
    /*
    pub fn get_prompt(...) -> String*/
    pub fn get(sh: &shell::Shell) -> String
    {
        let ps = get_prompt_string();
        let mut prompt = render_prompt(sh, &ps);
        
        if let Some((w, _h)) = ::terminal::size::dimensions()
        {
            if get_prompt_len(&prompt) > (w / 2) as i32 && !::regex::contains(&ps, r#"(?i)\$\{?newline.\}?"#)
            {
                prompt.push_str("\n$ ");
            }
        }

        else {  log!("ERROR: Failed to get term size"); }
        prompt
    }

    pub fn trim_multiline_prompts( line:&str ) -> String
    {
        let line_new = replace_all( line, r"\\\n>> ", "" );
        let line_new = replace_all( &line_new, r"\| *\n>> ", "| " );
        replace_all( &line_new, r"(?P<NEWLINE>\n)>> ", "$NEWLINE" )
    }
}

pub mod reader
{
    use ::
    {
        signals::{ Signal },
        *,
    };
    /// Returned from [`read_line`] to indicate user input
    #[derive( Debug )]
    pub enum ReadResult
    {
        /// User issued end-of-file
        Eof,
        /// User input received
        Input( String ),
        /// Reported signal was received
        Signal( Signal ),
    }
}

pub mod regex
{
    pub use ::re::{ * };

    pub fn contains( text: &str, ptn: &str ) -> bool
    {
        let re = match regex::Regex::new(ptn)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println!("Regex new error: {:?}", e);
                return false;
            }
        };
        
        re.is_match(text)
    }

    pub fn find_first_group(ptn: &str, text: &str) -> Option<String>
    {
        let re = match regex::Regex::new(ptn) {
            Ok(x) => x,
            Err(_) => return None,
        };
        match re.captures(text) {
            Some(caps) => {
                if let Some(x) = caps.get(1) {
                    return Some(x.as_str().to_owned());
                }
            }
            None => {
                return None;
            }
        }
        None
    }

    pub fn replace_all(text: &str, ptn: &str, ptn_to: &str) -> String
    {
        let re = regex::Regex::new(ptn).unwrap();
        let result = re.replace_all(text, ptn_to);
        result.to_string()
    }
}

pub mod shell
{
    use ::
    {
        regex::{ replace_all },
        *,
    };
}

pub mod signals
{
    use ::
    {
        iter::{ FromIterator },
        nix::
        {
            sys::
            {
                signal,
                wait::{WaitPidFlag as WF, WaitStatus as WS, waitpid}
            },
            unistd::{ Pid },
        },
        *,
    };
    /*
    use errno::{errno, set_errno};
    use std::sync::Mutex;
    use std::collections::{HashMap, HashSet};
    */
    pub const NUM_SIGNALS: u8 = 6;
    /// Signal received through a terminal device
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum Signal
    {
        /// Break signal (`CTRL_BREAK_EVENT`); Windows only
        Break,
        /// Continue signal (`SIGCONT`); Unix only
        Continue,
        /// Interrupt signal (`SIGINT` on Unix, `CTRL_C_EVENT` on Windows)
        Interrupt,
        /// Terminal window resize (`SIGWINCH` on Unix, `WINDOW_BUFFER_SIZE_EVENT` on Windows)
        Resize,
        /// Suspend signal (`SIGTSTP`); Unix only
        Suspend,
        /// Quit signal (`SIGQUIT`); Unix only
        Quit,
    }
    
    pub fn block()
    {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        
        match signal::sigprocmask( signal::SigmaskHow::SIG_BLOCK, Some(&sigset), None )
        {
            Ok(_) => {},
            Err(e) =>
            {
                log!("sigprocmask block error: {:?}", e);
            }
        }
    }

    pub fn unblock()
    {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        match signal::sigprocmask(signal::SigmaskHow::SIG_UNBLOCK, Some(&sigset), None)
        {
            Ok(_) => {},
            Err(e) =>
            {
                log!("sigprocmask unblock error: {:?}", e);
            }
        }
    }

    pub fn setup_sigchld_handler()
    {
        unsafe
        {
            let sigset = signal::SigSet::empty();
            let handler = signal::SigHandler::Handler(handle_sigchld);
            let flags = signal::SaFlags::SA_RESTART;
            let sa = signal::SigAction::new(handler, flags, sigset);
            match signal::sigaction(signal::SIGCHLD, &sa)
            {
                Ok(_) => {},
                Err(e) => { log!("sigaction error: {:?}", e); }
            }
        }
    }
}

pub mod sync
{
    pub use std::sync::{ * };
} use std::sync::Arc;

pub mod task
{
    pub use std::task::{ * };

    pub mod c
    {
        use ::
        {
            *,
        };

        pub fn mark_job_as_done(sh: &mut shell::Shell, gid: i32, pid: i32, reason: &str)
        {
            if let Some(mut job) = sh.remove_pid_from_job(gid, pid) {
                job.status = reason.to_string();
                if job.is_bg {
                    println_stderr!("");
                    print_job(&job);
                }
            }
        }

        pub fn try_wait_bg_jobs(sh: &mut shell::Shell, report: bool, sig_handler_enabled: bool)
        {
            if sh.jobs.is_empty() {
                return;
            }

            if !sig_handler_enabled {
                // we need to wait pids in case CICADA_ENABLE_SIG_HANDLER=0
                signals::handle_sigchld(Signal::SIGCHLD as i32);
            }

            let jobs = sh.jobs.clone();

            for (_i, job) in jobs.iter()
            {
                for pid in job.pids.iter()
                {
                    if let Some(_status) = signals::pop_reap_map(*pid)
                    {
                        mark_job_as_done(sh, job.gid, *pid, "Done");
                        continue;
                    }

                    if let Some(sig) = signals::killed_map_pop(*pid)
                    {
                        let reason = if sig == Signal::SIGQUIT as i32
                        {
                            format!("Quit: {}", sig)
                        }
                        else if sig == Signal::SIGINT as i32
                        {
                            format!("Interrupt: {}", sig)
                        }
                        else if sig == Signal::SIGKILL as i32
                        {
                            format!("Killed: {}", sig)
                        }
                        else if sig == Signal::SIGTERM as i32
                        {
                            format!("Terminated: {}", sig)
                        }
                        else
                        {
                            format!("Killed: {}", sig)
                        };

                        mark_job_as_done(sh, job.gid, *pid, &reason);
                        continue;
                    }

                    if signals::pop_stopped_map(*pid) {
                        mark_job_member_stopped(sh, *pid, job.gid, report);
                    } else if signals::pop_cont_map(*pid) {
                        mark_job_member_continued(sh, *pid, job.gid);
                    }
                }
            }
        }
    }
}

pub mod terminal
{
    use ::
    {
        *,
    };

    pub mod size
    {
        use ::
        {
            *,
        };
        /// Query the current processes's stdout, stdin, and stderr, to determine terminal width.
        pub fn dimensions() -> Option<(usize, usize)>
        {
            let w = unsafe { get_dimensions_any() };

            if w.ws_col == 0 || w.ws_row == 0 { None } else { Some((w.ws_col as usize, w.ws_row as usize)) }
        } 
    }
}

pub mod time
{
    use std::time::{ * };

    pub mod c
    {
        pub use ::timed::{ * };
        use ::
        {
            *,
        };

        #[derive(Debug, PartialEq, Eq)]
        pub struct DateTime
        {
            odt: OffsetDateTime,
        }

        impl DateTime
        {
            pub fn now() -> Self
            {
                let odt: OffsetDateTime = match OffsetDateTime::now_local()
                {
                    Ok(dt) => dt,
                    Err(_) => OffsetDateTime::now_utc(),
                };

                DateTime { odt }
            }

            pub fn from_timestamp(ts: f64) -> Self
            {
                let dummy_now = Self::now();
                let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
                let ts_nano = (ts + offset_seconds as f64) * 1000000000.0;
                let odt: OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos(ts_nano as i128)
                {
                    Ok(x) => x,
                    Err(_) => OffsetDateTime::now_utc(),
                };

                DateTime { odt }
            }

            pub fn unix_timestamp(&self) -> f64 { self.odt.unix_timestamp_nanos() as f64 / 1000000000.0 }
        }

        impl fmt::Display for DateTime
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            {
                write!
                (
                    f, "{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                    self.odt.year(),
                    self.odt.month() as u8,
                    self.odt.day(),
                    self.odt.hour(),
                    self.odt.minute(),
                    self.odt.second(),
                    self.odt.millisecond(),
                )
            }
        }
    }
}

fn main()
{
    unsafe
    {
        libc::signal(libc::SIGPIPE, libc::SIG_DFL);

        // ignore SIGTSTP (ctrl-Z) for the shell itself
        libc::signal(libc::SIGTSTP, libc::SIG_IGN);
        libc::signal(libc::SIGQUIT, libc::SIG_IGN);
    }

    env::init_path_env();

    let mut sh = shell::Shell::new();
    let args: Vec<String> = env::args().collect();

    if libs::progopts::is_login(&args)
    {
        rcfile::load_rc_files(&mut sh);
        sh.is_login = true;
    }
    
    highlight::init_command_cache();
    highlight::update_aliases(&sh);

    if libs::progopts::is_script(&args)
    {
        log!("run script: {:?} ", &args);
        let status = scripting::run_script(&mut sh, &args);
        std::process::exit(status);
    }

    if libs::progopts::is_command_string(&args)
    {
        // handles `cicada -c 'echo hi && echo yoo'`,
        // e.g. it could be triggered from Vim (`:!ls` etc).
        let line = tools::env_args_to_command_line();
        log!("run with -c args: {}", &line);
        execute::run_command_line(&mut sh, &line, false, false);
        std::process::exit(sh.previous_status);
    }

    if libs::progopts::is_non_tty()
    {
        // cases like open a new MacVim window,
        // (i.e. CMD+N) on an existing one
        execute::run_procs_for_non_tty(&mut sh);
        return;
    }

    let mut rl;
    match Interface::new("cicada")
    {
        Ok(x) => rl = x,
        Err(e) => {
            // non-tty will raise errors here
            println!(":: lineread error: {}", e);
            return;
        }
    }

    rl.define_function("enter-function", Arc::new(prompt::EnterFunction));
    rl.bind_sequence("\r", Command::from_str("enter-function"));

    let highlighter = highlight::create_highlighter();
    rl.set_highlighter(highlighter);

    history::init(&mut rl);
    rl.set_completer(Arc::new(completers::CicadaCompleter
    {
        sh: Arc::new(sh.clone()),
    }));

    let sig_handler_enabled = ::is::signal_handler_enabled();
    
    if sig_handler_enabled
    {
        signals::setup_sigchld_handler();
        // block the signals at most of time, since Rust is not "async-signal-safe"
        // yet. see https://github.com/rust-lang/rfcs/issues/1368
        // we'll unblock them when necessary only.
        signals::block();
    }

    loop
    {
        let prompt = prompt::get(&sh);
        match rl.set_prompt(&prompt)
        {
            Ok(_) => {}
            Err(e) =>
            {
                println_stderr!(":: prompt error: {}", e);
            }
        }

        if sig_handler_enabled  { signals::unblock(); }
        
        match rl.read_line() 
        {
            Ok( ::reader::ReadResult::Input( line ) ) => 
            {
                if sig_handler_enabled { signals::block(); }

                let line = shell::trim_multiline_prompts(&line);
                
                if line.trim() == ""
                {
                    task::c::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                    continue;
                }

                sh.cmd = line.clone();

                let tsb = ::time::c::DateTime::now().unix_timestamp();
                let mut line = line.clone();
                
                ::expand::bangbang(&sh, &mut line);

                let mut status = 0;
                let cr_list = ::now::run_command_line(&mut sh, &line, true, false);

                if let Some(last) = cr_list.last() { status = last.status; }

                let tse = ::time::c::DateTime::now().unix_timestamp();

                if !sh.cmd.starts_with(' ') && line != sh.previous_cmd
                {
                    ::history::add(&sh, &mut rl, &line, status, tsb, tse);
                    sh.previous_cmd = line.clone();
                }

                if ::is::shell_altering_command( &line )
                {
                    rl.set_completer(Arc::new( ::complete::ShellCompleter
                    {
                        sh: Arc::new(sh.clone()),
                    }));
                    
                    ::prompt::update_aliases(&sh);
                }

                task::c::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                continue;
            }
            
            Ok( ::reader::ReadResult::Eof ) => 
            {
                if let Ok(x) = ::env::var("NO_EXIT_ON_CTRL_D") { if x == "1" { println!(); } }
                else
                {
                    println!("exit");
                    break;
                }
            }

            Ok( ::reader::ReadResult::Signal( s ) ) => 
            {
                println_stderr!("readline signal: {:?}", s);
            }

            Err(e) => 
            {
                println_stderr!("readline error: {}", e);
                unsafe
                {
                    let gid = ::libc::getpgid(0);
                    ::terminal::give_to(gid);
                }
            }
        }

        if sig_handler_enabled { signals::block(); }
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 876
