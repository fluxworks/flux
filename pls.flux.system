#![feature
(
    tool_lints
)]

#![allow
(
    non_camel_case_types,
    unknown_lints,
    unused_imports,
    unused_macros,
)]
/**/
#[macro_use] extern crate lazy_static;
/**/
extern crate libc;
extern crate nix;
extern crate regex as re;
extern crate time as timed;
extern crate unicode_normalization;
extern crate unicode_width;

#[macro_use] pub mod macros
{
    use ::
    {
        *,
    };

    #[macro_export] macro_rules! log
    {
        ($fmt:expr) => 
        (
            let log_file = if let Ok(x) = ::env::var("CICADA_LOG_FILE") { x.clone() } else { String::new() };

            if !log_file.is_empty()
            {
                use ::io::Write as _;

                let msg = $fmt;

                match std::fs::OpenOptions::new().append(true).create(true).open(&log_file)
                {
                    Ok(mut cfile) =>
                    {
                        let pid = ::process::getpid();
                        let now = ::time::c::DateTime::now();
                        let msg = format!("[{}][{}] {}", now, pid, msg);
                        let msg = if msg.ends_with('\n') { msg } else { format!("{}\n", msg) };
                        match cfile.write_all(msg.as_bytes())
                        {
                            Ok(_) => {}
                            Err(_) => println!("tlog: write_all error")
                        }
                    }
                    Err(_) => println!("tlog: open file error"),
                }
            }
        );

        ($fmt:expr, $($arg:tt)*) => 
        (
            let msg = format!($fmt, $($arg)*);
            log!(&msg);
        );
    }

    #[macro_export] macro_rules! println_stderr
    {
        ($fmt:expr) =>
        (
            match writeln!( &mut ::io::stderr(), $fmt )
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );

        ($fmt:expr, $($arg:tt)*) =>
        (
            match writeln!( &mut ::io::stderr(), $fmt, $($arg)* )
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );
    }

    #[macro_export] macro_rules! constant_error
    {
        ($kind:expr, $message:expr $(,)?) => 
        {
            ::hint::must_use( ::io::Error::from_static_message
            (
                const { & ::io::SimpleMessage { kind: $kind, message: $message } },
            ))
        };
    }
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod char
{
    //! Provides utilities for manipulating character values
    pub use std::char::{ * };
    /// Character value indicating end-of-file
    pub const EOF: char = '\x04';
    /// Character value generated by the Escape key
    pub const ESCAPE: char = '\x1b';
    /// Character value generated by the Backspace key
    ///
    /// On Unix systems, this is equivalent to `RUBOUT`
    #[cfg(unix)] pub const DELETE: char = RUBOUT;
    /// Character value generated by the Backspace key
    ///
    /// On Windows systems, this character is Ctrl-H
    #[cfg(windows)] pub const DELETE: char = '\x08';
    /// Character value generated by the Backspace key on some systems
    pub const RUBOUT: char = '\x7f';
    /// Returns a character name as a key sequence, e.g. `Control-x` or `Meta-x`.
    pub fn parse_char_name(name: &str) -> Option<String> {
        let name_lc = name.to_lowercase();

        let is_ctrl = contains_any(&name_lc, &["c-", "ctrl-", "control-"]);
        let is_meta = contains_any(&name_lc, &["m-", "meta-"]);

        let name = match name_lc.rfind('-') {
            Some(pos) => &name_lc[pos + 1..],
            None => &name_lc[..]
        };

        let ch = match name {
            "del" | "rubout"  => DELETE,
            "esc" | "escape"  => ESCAPE,
            "lfd" | "newline" => '\n',
            "ret" | "return"  => '\r',
            "spc" | "space"   => ' ',
            "tab"             => '\t',
            s if !s.is_empty() => s.chars().next().unwrap(),
            _ => return None
        };

        let ch = match (is_ctrl, is_meta) {
            (true,  true)  => meta(ctrl(ch)),
            (true,  false) => ctrl(ch).to_string(),
            (false, true)  => meta(ch),
            (false, false) => ch.to_string(),
        };

        Some(ch)
    }
    /// Returns a character sequence escaped for user-facing display.
    pub fn escape_sequence(s: &str) -> String {
        let mut res = String::with_capacity(s.len());

        for ch in s.chars() {
            match ch {
                ESCAPE => res.push_str(r"\e"),
                RUBOUT => res.push_str(r"\C-?"),
                '\\' => res.push_str(r"\\"),
                '\'' => res.push_str(r"\'"),
                '"' => res.push_str(r#"\""#),
                ch if is_ctrl(ch) => {
                    res.push_str(r"\C-");
                    res.push(unctrl_lower(ch));
                }
                ch => res.push(ch)
            }
        }

        res
    }
    /// Returns a meta sequence for the given character.
    pub fn meta(ch: char) -> String {
        let mut s = String::with_capacity(ch.len_utf8() + 1);
        s.push(ESCAPE);
        s.push(ch);
        s
    }

    fn contains_any(s: &str, strs: &[&str]) -> bool {
        strs.iter().any(|a| s.contains(a))
    }
    /// Returns whether the character is printable.
    pub fn is_printable(c: char) -> bool
    {
        c == '\t' || c == '\n' || !(c == '\0' || is_ctrl(c))
    }

    const CTRL_BIT: u8 = 0x40;
    const CTRL_MASK: u8 = 0x1f;
    /// Returns whether the given character is a control character.
    pub fn is_ctrl(c: char) -> bool {
        const CTRL_MAX: u32 = 0x1f;

        c != '\0' && c as u32 <= CTRL_MAX
    }
    /// Returns a control character for the given character.
    pub fn ctrl(c: char) -> char {
        ((c as u8) & CTRL_MASK) as char
    }
    /// Returns the printable character corresponding to the given control character.
    pub fn unctrl(c: char) -> char {
        ((c as u8) | CTRL_BIT) as char
    }
    /// Returns the lowercase character corresponding to the given control character.
    pub fn unctrl_lower(c: char) -> char
    {
        unctrl(c).to_ascii_lowercase()
    }
    /*
    pub fn backward_char(...) -> usize */
    pub fn backward(n: usize, s: &str, cur: usize) -> usize
    {
        let mut chars = s[..cur].char_indices().filter(|&(_, ch)| !::is::combining_mark(ch));
        let mut res = cur;

        for _ in 0..n {
            match chars.next_back() {
                Some((idx, _)) => res = idx,
                None => return 0
            }
        }

        res
    }
    /*
    pub fn forward_char(...) -> usize */
    pub fn forward(n: usize, s: &str, cur: usize) -> usize
    {
        let mut chars = s[cur..].char_indices()
            .filter(|&(_, ch)| !::is::combining_mark(ch));

        for _ in 0..n {
            match chars.next() {
                Some(_) => (),
                None => return s.len()
            }
        }

        match chars.next() {
            Some((idx, _)) => cur + idx,
            None => s.len()
        }
    }
    /*
    pub fn backward_search_char(...) -> Option<usize> */
    pub fn backward_search(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n {
            match buf[..cur].rfind(ch) {
                Some(p) => {
                    cur = p;
                    pos = Some(cur);
                }
                None => break
            }
        }

        pos
    }
    /*
    pub fn forward_search_char(...) -> Option<usize> */
    pub fn forward_search(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n
        {
            let off = match buf[cur..].chars().next() {
                Some(ch) => ch.len_utf8(),
                None => break
            };

            match buf[cur + off..].find(ch) {
                Some(p) => {
                    cur += off + p;
                    pos = Some(cur);
                }
                None => break
            }
        }

        pos
    }
    /// Returns the width of a character in the terminal.
    #[inline] pub fn width(ch: char) -> Option<usize>
    {
        use unicode_width::UnicodeWidthChar;
        ch.width()
    }
    /// Returns a string consisting of a `char`, repeated `n` times.
    // pub fn repeat_char(ch: char, n: usize) -> String
    pub fn repeat(ch: char, n: usize) -> String
    {
        let mut buf = [0; 4];
        let s = ch.encode_utf8(&mut buf);

        s.repeat(n)
    }
}

pub mod collections
{
    pub use std::collections::{ * };

    use ::
    { 
        iter::{ FromIterator },
        *,
    };
    /// Utilities for manipulating raw input sequences representing the result of a `SequenceMap::find` operation.
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum FindResult<V>
    {
        /// No contained sequences begin with the provided input sequence.
        NotFound,
        /// One or more sequences begin with the provided input sequence,
        /// but the sequence does not represent a complete sequence.
        Incomplete,
        /// A sequence was found exactly matching the input sequence;
        /// additionally, one or more sequences begin with the input sequence.
        Undecided(V),
        /// A sequence was found exactly matching the input sequence;
        /// no additional partially-matching sequences exist.
        Found(V),
    }

    impl<'a, V: Clone> FindResult<&'a V>
    {
        /// Maps `FindResult<&V>` to `FindResult<V>` by cloning the contents of the result value.
        pub fn cloned(self) -> FindResult<V>
        {
            match self {
                FindResult::NotFound => FindResult::NotFound,
                FindResult::Incomplete => FindResult::Incomplete,
                FindResult::Undecided(v) => FindResult::Undecided(v.clone()),
                FindResult::Found(v) => FindResult::Found(v.clone()),
            }
        }
    }
    /// A view into an occupied entry in a `SequenceMap`.
    pub struct OccupiedEntry<'a, K: 'a, V: 'a>
    {
        map: &'a mut SequenceMap<K, V>,
        index: usize,
    }

    impl<'a, K, V> OccupiedEntry<'a, K, V>
    {
        /// Returns a borrowed reference to the entry key.
        pub fn key(&self) -> &K 
        {
            &self.map.sequences[self.index].0
        
        }
        /// Returns a borrowed reference to the entry value.
        pub fn get(&self) -> &V 
        {
            &self.map.sequences[self.index].1
        }
        /// Returns a mutable reference to the entry value.
        pub fn get_mut(&mut self) -> &mut V 
        {
            &mut self.map.sequences[self.index].1
        }
        /// Converts the `OccupiedEntry` into a mutable reference whose lifetime is bound to the `SequenceMap`.
        pub fn into_mut(self) -> &'a mut V 
        {
            &mut self.map.sequences[self.index].1
        }
        /// Replaces the entry value with the given value, returning the previous value.
        pub fn insert(&mut self, value: V) -> V { ::mem::replace(self.get_mut(), value) }
        /// Removes the entry and returns the value.
        pub fn remove(self) -> V 
        {
            self.map.sequences.remove(self.index).1
        }
        /// Removes the entry and returns the key-value pair.
        pub fn remove_entry(self) -> (K, V) 
        {
            self.map.sequences.remove(self.index)
        }
    }

    impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for OccupiedEntry<'a, K, V>
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("OccupiedEntry")
                .field("key", self.key())
                .field("value", self.get())
                .finish()
        }
    }
    /// A view into a vacant entry in a `SequenceMap`.
    pub struct VacantEntry<'a, K: 'a, V: 'a>
    {
        map: &'a mut SequenceMap<K, V>,
        key: K,
        index: usize,
    }

    impl<'a, K, V> VacantEntry<'a, K, V>
    {
        /// Returns a borrowed reference to the entry key.
        pub fn key(&self) -> &K {
            &self.key
        }

        /// Consumes the `VacantEntry` and returns ownership of the key.
        pub fn into_key(self) -> K {
            self.key
        }

        /// Consumes the `VacantEntry` and inserts a value, returning a mutable
        /// reference to its place in the `SequenceMap`.
        pub fn insert(self, value: V) -> &'a mut V {
            self.map.sequences.insert(self.index, (self.key, value));
            &mut self.map.sequences[self.index].1
        }
    }

    impl<'a, K: fmt::Debug, V> fmt::Debug for VacantEntry<'a, K, V>
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_tuple("VacantEntry")
                .field(self.key())
                .finish()
        }
    }
    /// A view into a single entry of a `SequenceMap`, which may be either occupied or vacant.
    pub enum Entry<'a, K: 'a, V: 'a>
    {
        /// An occupied entry
        Occupied(OccupiedEntry<'a, K, V>),
        /// A vacant entry
        Vacant(VacantEntry<'a, K, V>),
    }

    impl<'a, K, V> Entry<'a, K, V>
    {
        /// Provides in-place mutable access to an occupied entry before any
        /// potential inserts into the map.
        pub fn and_modify<F: FnOnce(&mut V)>(self, f: F) -> Self {
            match self {
                Entry::Occupied(mut ent) => {
                    f(ent.get_mut());
                    Entry::Occupied(ent)
                }
                Entry::Vacant(ent) => Entry::Vacant(ent)
            }
        }

        /// Returns a mutable reference to the entry value,
        /// inserting the provided default if the entry is vacant.
        pub fn or_insert(self, default: V) -> &'a mut V {
            match self {
                Entry::Occupied(ent) => ent.into_mut(),
                Entry::Vacant(ent) => ent.insert(default)
            }
        }

        /// Returns a mutable reference to the entry value,
        /// inserting a value using the provided closure if the entry is vacant.
        pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
            match self {
                Entry::Occupied(ent) => ent.into_mut(),
                Entry::Vacant(ent) => ent.insert(default())
            }
        }

        /// Returns a borrowed reference to the entry key.
        pub fn key(&self) -> &K {
            match *self {
                Entry::Occupied(ref ent) => ent.key(),
                Entry::Vacant(ref ent) => ent.key(),
            }
        }
    }

    impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for Entry<'a, K, V>
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match *self {
                Entry::Occupied(ref ent) =>
                    f.debug_tuple("Entry")
                        .field(ent)
                        .finish(),
                Entry::Vacant(ref ent) =>
                    f.debug_tuple("Entry")
                        .field(ent)
                        .finish()
            }
        }
    }
    /// Contains a set of string sequences, mapped to a value.
    #[derive(Clone, Debug, Default)]
    pub struct SequenceMap<K, V>
    {
        sequences: Vec<(K, V)>,
    }

    impl<K: AsRef<str>, V> SequenceMap<K, V>
    {
        /// Creates an empty `SequenceMap`.
        pub fn new() -> SequenceMap<K, V> 
        {
            SequenceMap::with_capacity(0)
        }
        /// Creates an empty `SequenceMap` with allocated capacity for `n` elements.
        pub fn with_capacity(n: usize) -> SequenceMap<K, V> 
        {
            SequenceMap{
                sequences: Vec::with_capacity(n),
            }
        }
        /// Returns a slice of all contained sequences, sorted by key.
        pub fn sequences(&self) -> &[(K, V)] 
        {
            &self.sequences
        }
        /// Returns a mutable slice of all contained sequences, sorted by key.
        pub fn sequences_mut(&mut self) -> &mut [(K, V)] 
        {
            &mut self.sequences
        }
        /// Returns an `Entry` for the given key.
        pub fn entry(&mut self, key: K) -> Entry<K, V> 
        {
            match self.search(key.as_ref()) {
                Ok(n) => Entry::Occupied(OccupiedEntry{
                    map: self,
                    index: n,
                }),
                Err(n) => Entry::Vacant(VacantEntry{
                    map: self,
                    key,
                    index: n,
                })
            }
        }
        /// Performs a search for a partial or complete sequence match.
        pub fn find(&self, key: &str) -> FindResult<&V> 
        {
            let (n, found) = match self.search(key) {
                Ok(n) => (n, true),
                Err(n) => (n, false)
            };

            let incomplete = self.sequences.get(n + (found as usize))
                .map_or(false, |&(ref next, _)| next.as_ref().starts_with(key));

            match (found, incomplete) {
                (false, false) => FindResult::NotFound,
                (false, true) => FindResult::Incomplete,
                (true, false) => FindResult::Found(&self.sequences[n].1),
                (true, true) => FindResult::Undecided(&self.sequences[n].1),
            }
        }
        /// Returns the corresponding value for the given sequence.
        pub fn get(&self, key: &str) -> Option<&V> 
        {
            match self.search(key) {
                Ok(n) => Some(&self.sequences[n].1),
                Err(_) => None
            }
        }
        /// Returns a mutable reference to the corresponding value for the given sequence.
        pub fn get_mut(&mut self, key: &str) -> Option<&mut V> 
        {
            match self.search(key) {
                Ok(n) => Some(&mut self.sequences[n].1),
                Err(_) => None
            }
        }
        /// Inserts a key-value pair into the map.
        pub fn insert(&mut self, key: K, value: V) -> Option<V> 
        {
            match self.search(key.as_ref()) 
            {
                Ok(n) => Some( ::mem::replace(&mut self.sequences[n], (key, value)).1),
                Err(n) =>
                {
                    self.sequences.insert(n, (key, value));
                    None
                }
            }
        }
        /// Removes a key-value pair from the map.
        pub fn remove(&mut self, key: &str) -> Option<(K, V)> 
        {
            match self.search(key) {
                Ok(n) => Some(self.sequences.remove(n)),
                Err(_) => None
            }
        }

        fn search(&self, key: &str) -> Result<usize, usize> 
        {
            self.sequences.binary_search_by_key(&key, |&(ref k, _)| &k.as_ref())
        }
    }

    impl<K: AsRef<str>, V> From<Vec<(K, V)>> for SequenceMap<K, V>
    {
        /// Creates a `SequenceMap` from a `Vec` of key-value pairs.
        fn from(mut sequences: Vec<(K, V)>) -> SequenceMap<K, V>
        {
            sequences.sort_by(|a, b| a.0.as_ref().cmp(b.0.as_ref()));
            sequences.dedup_by(|a, b| a.0.as_ref() == b.0.as_ref());
            SequenceMap{sequences}
        }
    }

    impl<K: AsRef<str>, V> FromIterator<(K, V)> for SequenceMap<K, V>
    {
        /// Creates a `SequenceMap` from an iterator of key-value pairs.
        fn from_iter<I: IntoIterator<Item=(K, V)>>(iter: I) -> Self
        {
            let iter = iter.into_iter();
            let mut map = SequenceMap::with_capacity(iter.size_hint().0);

            for (k, v) in iter
            {
                map.insert(k, v);
            }

            map
        }
    }
}

pub mod command
{
    //! Defines the set of line editing commands
    use ::
    {
        borrow::Cow::{ self, Borrowed, Owned },
        char::{ escape_sequence },
        *,
    };
    
    macro_rules! define_commands
    {
        ( $( #[$meta:meta] $name:ident => $str:expr , )+ ) => {
            /// Represents a command to modify `Reader` state
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum Command {
                $( #[$meta] $name , )+
                /// Custom application-defined command
                Custom(Cow<'static, str>),
                /// Execute a given key sequence
                Macro(Cow<'static, str>),
            }

            /// List of all command names
            pub static COMMANDS: &[&str] = &[ $( $str ),+ ];

            impl fmt::Display for Command {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                    match *self {
                        $( Command::$name => f.write_str($str) , )+
                        Command::Custom(ref s) => f.write_str(s),
                        Command::Macro(ref s) => write!(f, "\"{}\"",
                            escape_sequence(s))
                    }
                }
            }

            impl Command {
                /// Constructs a command from a `'static str` reference.
                ///
                /// If the string does not refer to a built-in command, a value
                /// of `Command::Custom(Borrowed(name))` will be returned.
                pub fn from_str(name: &'static str) -> Command {
                    Command::opt_from_str(name)
                        .unwrap_or_else(|| Command::Custom(Borrowed(name)))
                }
                /// Constructs a command from a non-`'static` string-like type.
                ///
                /// If the string does not refer to a built-in command, a value
                /// of `Command::Custom(Owned(name.into()))` will be returned.
                pub fn from_string<T>(name: T) -> Command
                        where T: AsRef<str> + Into<String> {
                    Command::opt_from_str(name.as_ref())
                        .unwrap_or_else(|| Command::Custom(Owned(name.into())))
                }

                fn opt_from_str(s: &str) -> Option<Command> {
                    match s {
                        $( $str => Some(Command::$name), )+
                        _ => None
                    }
                }
            }
        }
    }

    define_commands!
    {
        /// Abort history search
        Abort => "abort",
        /// Accepts the current input line
        AcceptLine => "accept-line",
        /// Perform completion
        Complete => "complete",
        /// Insert all completions into the input buffer
        InsertCompletions => "insert-completions",
        /// Show possible completions
        PossibleCompletions => "possible-completions",
        /// Insert the next possible completion
        MenuComplete => "menu-complete",
        /// Insert the previous possible completion
        MenuCompleteBackward => "menu-complete-backward",
        /// Begin numeric argument input
        DigitArgument => "digit-argument",
        /// Insert character or sequence at the cursor
        SelfInsert => "self-insert",
        /// Inserts a tab character
        TabInsert => "tab-insert",
        /// Toggles insert/overwrite mode
        OverwriteMode => "overwrite-mode",
        /// Insert a comment and accept input
        InsertComment => "insert-comment",
        /// Move the cursor backward one character
        BackwardChar => "backward-char",
        /// Move the cursor forward one character
        ForwardChar => "forward-char",
        /// Search for a given character
        CharacterSearch => "character-search",
        /// Search backward for a given character
        CharacterSearchBackward => "character-search-backward",
        /// Move the cursor backward one word
        BackwardWord => "backward-word",
        /// Move the cursor forward one word
        ForwardWord => "forward-word",
        /// Kill all characters before the cursor
        BackwardKillLine => "backward-kill-line",
        /// Kill all characters after the cursor
        KillLine => "kill-line",
        /// Kill a word before the cursor
        BackwardKillWord => "backward-kill-word",
        /// Kill a word after the cursor
        KillWord => "kill-word",
        /// Kill a word before the cursor, delimited by whitespace
        UnixWordRubout => "unix-word-rubout",
        /// Clear the screen
        ClearScreen => "clear-screen",
        /// Move the cursor to the beginning of the line
        BeginningOfLine => "beginning-of-line",
        /// Move the cursor to the end of the line
        EndOfLine => "end-of-line",
        /// Delete one character before the cursor
        BackwardDeleteChar => "backward-delete-char",
        /// Delete one character after the cursor
        DeleteChar => "delete-char",
        /// Drag the character before the cursor forward
        TransposeChars => "transpose-chars",
        /// Drag the word before the cursor forward
        TransposeWords => "transpose-words",
        /// Move to the first line of history
        BeginningOfHistory => "beginning-of-history",
        /// Move to the last line of history
        EndOfHistory => "end-of-history",
        /// Select next line in history
        NextHistory => "next-history",
        /// Select previous line in history
        PreviousHistory => "previous-history",
        /// Incremental search in history
        ForwardSearchHistory => "forward-search-history",
        /// Incremental reverse search in history
        ReverseSearchHistory => "reverse-search-history",
        /// Non-incremental forward history search using input up to the cursor
        HistorySearchForward => "history-search-forward",
        /// Non-incremental backward history search using input up to the cursor
        HistorySearchBackward => "history-search-backward",
        /// Insert literal character
        QuotedInsert => "quoted-insert",
        /// Insert text into buffer from the kill ring
        Yank => "yank",
        /// Rotate the kill ring and yank the new top
        YankPop => "yank-pop",
    }
    /// Describes the category of a command.
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum Category
    {
        /// Completion command
        Complete,
        /// Kill command
        Kill,
        /// Non-incremental search command
        Search,
        /// Incremental search command
        IncrementalSearch,
        /// Yank command
        Yank,
        /// Digit argument command
        Digit,
        /// Other command
        Other,
    }

    impl Command
    {
        /// Returns the category of the command
        pub fn category(&self) -> Category
        {
            use self::Command::*;

            match *self
            {
                DigitArgument => Category::Digit,
                
                Complete | InsertCompletions | PossibleCompletions | MenuComplete | MenuCompleteBackward => 
                Category::Complete,

                BackwardKillLine | KillLine | BackwardKillWord | KillWord | UnixWordRubout => Category::Kill,
                
                ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                HistorySearchForward | HistorySearchBackward => Category::Search,

                Yank | YankPop => Category::Yank,
                _ => Category::Other
            }
        }
    }
}

pub mod complete
{
    //! Provides utilities for implementing word completion
    use ::
    {
        borrow::{ Cow::{ self, Borrowed, Owned }, },
        fs::{ read_dir },
        path::{ is_separator, MAIN_SEPARATOR },
        prompt::{ Prompter },
        terminal::{ Terminals },
        *,
    };

    pub struct ShellCompleter
    {
        pub sh: Arc<shell::Shell>,
    }
    /// Represents a single possible completion
    #[derive(Clone, Debug)]
    pub struct Completion
    {
        /// Whole completion text
        pub completion: String,
        /// Listing display string; `None` if matches completion
        pub display: Option<String>,
        /// Completion suffix; replaces append character
        pub suffix: Suffix,
    }
    /// Specifies an optional suffix to override the default value
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum Suffix
    {
        /// Use the default suffix
        Default,
        /// Use no suffix
        None,
        /// Use the given suffix
        Some(char),
    }

    impl Completion
    {
        /// Returns a simple `Completion` value, 
        /// with display string matching completion and using the default completion suffix.
        pub fn simple(s: String) -> Completion
        {
            Completion
            {
                completion: s,
                display: None,
                suffix: Suffix::default(),
            }
        }
        /// Returns the full completion string, including suffix,
        /// using the given default suffix if one is not assigned to this completion.
        pub fn completion(&self, def_suffix: Option<char>) -> Cow<str>
        {
            let mut s = Borrowed(&self.completion[..]);
            if let Some(suffix) = self.suffix.with_default(def_suffix)
            {
                s.to_mut().push(suffix);
            }

            s
        }
        /// Returns the display string, including suffix
        pub fn display(&self) -> Cow<str>
        {
            let mut s = Borrowed(self.display_str());

            if let Suffix::Some(suffix) = self.suffix { s.to_mut().push(suffix); }

            s
        }
        /// Returns the number of characters displayed
        pub fn display_chars(&self) -> usize
        {
            let n = self.display_str().chars().count();
            n + if self.suffix.is_some() { 1 } else { 0 }
        }

        fn display_str(&self) -> &str
        {
            match self.display
            {
                Some(ref dis) => dis,
                None => &self.completion
            }
        }
    }

    impl Suffix
    {
        /// Returns whether the `Suffix` value is the `Default` variant.
        pub fn is_default(&self) -> bool
        {
            match *self
            {
                Suffix::Default => true,
                _ => false
            }
        }
        /// Returns whether the `Suffix` value is the `Some(_)` variant.
        pub fn is_some(&self) -> bool
        {
            match *self
            {
                Suffix::Some(_) => true,
                _ => false
            }
        }
        /// Returns whether the `Suffix` value is the `None` variant.
        pub fn is_none(&self) -> bool
        {
            match *self
            {
                Suffix::None => true,
                _ => false
            }
        }
        /// Returns an `Option<char>`, using the given value in place of `Default`.
        pub fn with_default(self, default: Option<char>) -> Option<char>
        {
            match self
            {
                Suffix::None => None,
                Suffix::Some(ch) => Some(ch),
                Suffix::Default => default
            }
        }
    }

    impl Default for Suffix
    {
        fn default() -> Suffix
        {
            Suffix::Default
        }
    }
    /// Performs completion for `Prompter` when triggered by a user input sequence
    pub trait Completer<Term: Terminals>: Send + Sync
    {
        /// Returns the set of possible completions for the prefix `word`.
        fn complete(&self, word: &str, prompter: &Prompter<Term>, start: usize, end: usize) -> Option<Vec<Completion>>;
        /// Returns the starting position of the word under the cursor.
        fn word_start(&self, line: &str, end: usize, prompter: &Prompter<Term>) -> usize
        { word_break_start(&line[..end], prompter.word_break_chars()) }
        /// Quotes a possible completion for insertion into input.
        fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
        /// Unquotes a piece of user input before searching for completions.
        fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
    }
    /// `Completer` type that performs no completion.
    pub struct DummyCompleter;

    impl<T: Terminals> Completer<T> for DummyCompleter
    {
        fn complete( &self, _word: &str, _reader: &Prompter<T>, _start: usize, _end: usize) -> Option<Vec<Completion>>
        { None }
    }
    /// Performs completion by searching for filenames matching the word prefix.
    pub struct PathCompleter;

    impl<T:Terminals> Completer<T> for PathCompleter
    {
        fn complete(&self, word: &str, _reader: &Prompter<T>, _start: usize, _end: usize) -> Option<Vec<Completion>>
        { Some(complete_path(word)) }

        fn word_start(&self, line: &str, end: usize, _reader: &Prompter<T>) -> usize 
        { escaped_word_start(&line[..end]) }

        fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { escape(word) }

        fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { unescape(word) }
    }
    /// Returns a sorted list of paths whose prefix matches the given path.
    pub fn complete_path(path: &str) -> Vec<Completion>
    {
        let (base_dir, fname) = split_path(path);
        let mut res = Vec::new();

        let lookup_dir = base_dir.unwrap_or(".");

        if let Ok(list) = read_dir(lookup_dir)
        {
            for ent in list {
                if let Ok(ent) = ent {
                    let ent_name = ent.file_name();

                    // TODO: Deal with non-UTF8 paths in some way
                    if let Ok(path) = ent_name.into_string() {
                        if path.starts_with(fname) {
                            let (name, display) = if let Some(dir) = base_dir {
                                (format!("{}{}{}", dir, MAIN_SEPARATOR, path),
                                    Some(path))
                            } else {
                                (path, None)
                            };

                            let is_dir = ent.metadata().ok()
                                .map_or(false, |m| m.is_dir());

                            let suffix = if is_dir {
                                Suffix::Some(MAIN_SEPARATOR)
                            } else {
                                Suffix::Default
                            };

                            res.push(Completion{
                                completion: name,
                                display: display,
                                suffix: suffix,
                            });
                        }
                    }
                }
            }
        }

        res.sort_by(|a, b| a.display_str().cmp(b.display_str()));
        res
    }
    /// Returns the start position of the word that ends at the end of the string.
    pub fn word_break_start(s: &str, word_break: &str) -> usize
    {
        let mut start = s.len();

        for (idx, ch) in s.char_indices().rev()
        {
            if word_break.contains(ch) { break; }
            start = idx;
        }

        start
    }
    /// Returns the start position of a word with non-word characters escaped by backslash (`\\`).
    pub fn escaped_word_start(s: &str) -> usize
    {
        let mut chars = s.char_indices().rev();
        let mut start = s.len();

        while let Some((idx, ch)) = chars.next()
        {
            if needs_escape(ch) {
                let n = {
                    let mut n = 0;

                    loop {
                        let mut clone = chars.clone();

                        let ch = match clone.next() {
                            Some((_, ch)) => ch,
                            None => break
                        };

                        if ch == '\\' {
                            chars = clone;
                            n += 1;
                        } else {
                            break;
                        }
                    }

                    n
                };

                if n % 2 == 0 {
                    break;
                }
            }

            start = idx;
        }

        start
    }
    /// Escapes a word by prefixing a backslash (`\\`) to non-word characters.
    pub fn escape(s: &str) -> Cow<str>
    {
        let n = s.chars().filter(|&ch| needs_escape(ch)).count();

        if n == 0 {
            Borrowed(s)
        } else {
            let mut res = String::with_capacity(s.len() + n);

            for ch in s.chars() {
                if needs_escape(ch) {
                    res.push('\\');
                }
                res.push(ch);
            }

            Owned(res)
        }
    }
    /// Unescapes a word by removing the backslash (`\\`) from escaped characters.
    pub fn unescape(s: &str) -> Cow<str>
    {
        if s.contains('\\') {
            let mut res = String::with_capacity(s.len());
            let mut chars = s.chars();

            while let Some(ch) = chars.next() {
                if ch == '\\' {
                    if let Some(ch) = chars.next() {
                        res.push(ch);
                    }
                } else {
                    res.push(ch);
                }
            }

            Owned(res)
        } else {
            Borrowed(s)
        }
    }

    fn needs_escape(ch: char) -> bool
    {
        match ch {
            ' ' | '\t' | '\n' | '\\' => true,
            _ => false
        }
    }

    fn split_path(path: &str) -> (Option<&str>, &str)
    {
        match path.rfind(is_separator)
        {
            Some(pos) => (Some(&path[..pos]), &path[pos + 1..]),
            None => (None, path)
        }
    }
}

pub mod database
{
    use ::
    {
        path::{ Path },
        *,
    };

    pub fn initialize(hfile: &str, htable: &str)
    {
        let path = Path::new(hfile);
        
        if !path.exists()
        {
            let _parent = match path.parent()
            {
                Some(x) => x,
                None =>
                {
                    println_stderr!("cicada: history init - no parent found");
                    return;
                }
            };

            let parent = match _parent.to_str()
            {
                Some(x) => x,
                None =>
                {
                    println_stderr!("cicada: parent to_str is None");
                    return;
                }
            };

            match fs::create_dir_all(parent)
            {
                Ok(_) => {}
                Err(e) =>
                {
                    println_stderr!("cicada: histdir create error: {}", e);
                    return;
                }
            }
            
            match fs::File::create(hfile)
            {
                Ok(_) => { println!("cicada: created history file: {}", hfile); }
                Err(e) => { println_stderr!("cicada: history: file create failed: {}", e); }
            }
        }

        let conn = match Conn::open(hfile)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: history: open db error: {}", e);
                return;
            }
        };
        
        let sql = format!
        (
        "
            CREATE TABLE IF NOT EXISTS {}
            (
                inp TEXT,
                rtn INTEGER,
                tsb REAL,
                tse REAL,
                sessionid TEXT,
                out TEXT,
                info TEXT
            );
        ",
            htable
        );

        match conn.execute(&sql, [])
        {
            Ok(_) => {}
            Err(e) => println_stderr!("cicada: history: query error: {}", e),
        }
    }
}

pub mod env
{
    pub use std::env::{ * };

    use ::
    {
        path::{ Path },
        *,
    };

    pub fn initialize_paths()
    {
        let mut paths: Vec<String> = vec![];
        
        for x in
        [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ]
        {
            if Path::new(x).exists(){ paths.push(x.to_string()); }
        }

        if let Ok(env_path) = var("PATH")
        {
            for x in env_path.split(":")
            {
                if !paths.contains(&x.to_string())
                {
                    paths.push(x.to_string());
                }
            }
        }

        let paths = paths.join(":");
        set_var("PATH", paths);
    }
    /*
    pub fn env_args_to_command_line() -> String */
    pub fn args_to_command_line() -> String
    {
        let mut result = String::new();
        let env_args = args();
        
        if env_args.len() <= 1 { return result; }

        for (i, arg) in env_args.enumerate()
        {
            if i == 0 || arg == "-c" { continue; }

            result.push_str(arg.as_str());
        }

        result
    }

    pub fn get_user_home() -> String
    {
        match var("HOME")
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("pls: env HOME error: {}", e);
                String::new()
            }
        }
    }
}

pub mod expand
{
    use ::
    {
        regex::{ contains, Regex },
        *,
    };
    /*
    pub fn extend_bangbang(sh: &shell::Shell, line: &mut String) */
    pub fn bangbang(sh: &shell::Shell, line: &mut String)
    {
        if !contains(line, r"!!") { return; }
        
        if sh.previous_cmd.is_empty() { return; }

        let re = Regex::new(r"!!").unwrap();
        let mut replaced = false;
        let mut new_line = String::new();
        let linfo = parsers::line::parse(line);

        for (sep, token) in linfo.tokens
        {
            if !sep.is_empty() { new_line.push_str(&sep); }

            if re_contains(&token, r"!!") && sep != "'"
            {
                let line2 = token.clone();
                let result = re.replace_all(&line2, sh.previous_cmd.as_str());
                new_line.push_str(&result);
                replaced = true;
            }
            else { new_line.push_str(&token); }

            if !sep.is_empty() { new_line.push_str(&sep); }

            new_line.push(' ');
        }

        *line = new_line.trim_end().to_string();
        
        if replaced { println!("{}", line); }
    }
}

pub mod ffi
{
    pub use std::ffi::{ * };
    use ::
    {
        command::{ Category },
        io::{ self, BufRead, BufReader, BufWriter, Read as _, Seek, SeekFrom, Write as _, },
        prompt::{ Prompter },
        reader::{ Read, Reader },
        writer::{ Write, Writer },
        terminal::{ Terminals },
        sync::{ Mutex },
        *,
    };
    /// The main interface to input reading and other terminal operations.
    pub struct Interface<Term:Terminals>
    {
        term: Term,
        write: Mutex<Write>,
        read: Mutex<Read<Term>>,
    }
    /// Implements custom functionality for a `Prompter` command
    pub trait Function<Term: Terminals>: Send + Sync
    {
        /// Executes the function.
        fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()>;
        /// Returns the command category.
        fn category(&self) -> Category { Category::Other }
    }

    impl<F, Term:Terminals> Function<Term> for F where
    F: Send + Sync,
    F: Fn(&mut Prompter<Term>, i32, char) -> io::Result<()>
    {
        fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()>
        { 
            self(prompter, count, ch)
        }
    }

    pub struct EnterFunction;

    impl<T:Terminals> Function<T> for EnterFunction
    {
        fn execute(&self, prompter: &mut Prompter<T>, count: i32, _ch: char) -> ::io::Result<()>
        {
            let buf = prompter.buffer();
            let linfo = ::parsers::line::parse(buf);

            if linfo.is_complete { prompter.accept_input() }
            else if count > 0
            {
                match prompter.insert(count as usize, '\n')
                {
                    Ok(_) => {},
                    Err(e) => { println!("sub-prompt error: {}", e); }
                }

                prompter.insert_str(">> ")
            }
            else { Ok(()) }
        }
    }
}

pub mod filter
{
    use ::
    {
        borrow::{ Cow },
        reader::{START_INVISIBLE, END_INVISIBLE},
        *,
    };

    pub fn visible(s: &str) -> Cow<str>
    {
        if !s.contains(START_INVISIBLE) { return Cow::Borrowed(s); }

        let mut virt = String::new();
        let mut ignore = false;

        for ch in s.chars()
        {
            if ch == START_INVISIBLE { ignore = true; }
            else if ch == END_INVISIBLE { ignore = false; }
            else if !ignore { virt.push(ch); }
        }

        Cow::Owned(virt)
    }
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod fs
{
    pub use std::fs::{ * };
    use ::
    {
        path::{ Path },
        *,
    };
    /*
    use crate::scripting;
    use crate::shell;
    use crate::tools;
    */
    pub fn get_rc_file() -> String 
    {
        let dir_config = tools::get_config_dir();
        let rc_file = format!("{}/cicadarc", dir_config);
        if Path::new(&rc_file).exists() {
            return rc_file;
        }

        // fail back to $HOME/.cicadarc
        let home = tools::get_user_home();
        let rc_file_home = format!("{}/{}", home, ".cicadarc");
        if Path::new(&rc_file_home).exists() {
            return rc_file_home;
        }

        // use std path if both absent
        rc_file
    }

    pub fn load_rc_files(sh: &mut shell::Shell)
    {
        let rc_file = get_rc_file();

        if !Path::new(&rc_file).exists() { return; }

        let args = vec!["source".to_string(), rc_file];
        scripts::run(sh, &args);
    }
}

pub mod history
{
    use ::
    {
        collections::{ HashMap },
        ffi::{ Interface },
        path::{ Path },
        *,
    };

    pub fn add(sh: &shell::Shell, rl: &mut Interface<DefaultTerminal>, line: &str, status: i32, tsb: f64, tse: f64)
    {
        add_raw(sh, line, status, tsb, tse);
        rl.add_history(line.to_string());
    }

    pub fn initialize(rl: &mut Interface<DefaultTerminal>)
    {
        let mut hist_size: usize = 99999;
        
        if let Ok(x) = env::var("HISTORY_SIZE")
        {
            if let Ok(y) = x.parse::<usize>() { hist_size = y; }
        }

        rl.set_history_size(hist_size);

        let history_table = get_history_table();
        let hfile = get_history_file();

        if !Path::new(&hfile).exists() { ::database::initialize(&hfile, &history_table); }

        let mut delete_dups = true;

        if let Ok(x) = env::var("HISTORY_DELETE_DUPS")
        {
            if x == "0" { delete_dups = false; }
        }

        if delete_dups { delete_duplicated_histories(); }

        let conn = match Conn::open(&hfile)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };

        let sql = format!("SELECT inp FROM {} ORDER BY tsb;", history_table);
        let mut stmt = match conn.prepare(&sql)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: prepare select error: {}", e);
                return;
            }
        };

        let rows = match stmt.query_map([], |row| row.get(0))
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: query select error: {}", e);
                return;
            }
        };

        let mut dict_helper: HashMap<String, bool> = HashMap::new();

        for x in rows.flatten()
        {
            let inp: String = x;
            
            if dict_helper.contains_key(&inp) { continue; }

            dict_helper.insert(inp.clone(), true);
            rl.add_history(inp.trim().to_string());
        }
    }
}

pub mod io
{
    pub use std::io::{ * };

    pub fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize> where
    F: FnOnce(&mut [u8]) -> Result<usize>,
    {
        let buf = bufs.iter_mut().find(|b| !b.is_empty()).map_or(&mut [][..], |b| &mut **b);
        read(buf)
    }

} use std::io::Write as _;

pub mod is
{
    use ::
    {
        regex::{ contains },
        *,
    };
    /*
    pub fn is_shell_altering_command(...) -> bool */
    pub fn shell_altering_command( line: &str ) -> bool
    {
        let line = line.trim();
        
        if ::regex::contains(line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$") { return true; }

        line.starts_with("alias ")
        || line.starts_with("export ")
        || line.starts_with("unalias ")
        || line.starts_with("unset ")
        || line.starts_with("source ")
    }
    /*
    pub fn is_signal_handler_enabled() -> bool */
    pub fn signal_handler_enabled() -> bool
    {
        ::env::var("CICADA_ENABLE_SIG_HANDLER").map_or(false, |x| x == "1")
    }
    /*
    pub fn is_non_tty() -> bool */
    pub fn non_tty() -> bool { unsafe { libc::isatty(0) == 0 } }
    /*
    pub fn is_command_string(...) -> bool */
    pub fn command_string(args: &[String]) -> bool { args.len() > 1 && args[1] == "-c" }
    /*
    pub fn is_script(...) -> bool */
    pub fn script(args: &[String]) -> bool { args.len() > 1 && !args[1].starts_with("-") }
    /*
    pub fn is_login(...) -> bool */
    pub fn login(args: &[String]) -> bool
    {
        if !args.is_empty() && args[0].starts_with("-") {
            return true;
        }

        if args.len() > 1 && (args[1] == "--login" || args[1] == "-l") {
            return true;
        }

        if let Ok(term_program) = std::env::var("TERM_PROGRAM") {
            if term_program == "vscode" {
                return true;
            }
        }

        false
    }
    /*
    pub fn is_combining_mark(...) -> bool */
    /// Returns whether the given character is a combining mark.
    #[inline] pub fn combining_mark(ch: char) -> bool
    {
        use unicode_normalization::char::is_combining_mark;
        is_combining_mark(ch)
    }
    /*
    pub fn is_wide( ... ) -> bool */
    pub fn wide(ch: char) -> bool
    {
        ::char::width(ch) == Some(2)
    }
    /*
    pub fn is_arithmetic( ... ) -> bool */
    pub fn arithmetic(line: &str) -> bool
    {
        if !contains(line, r"[0-9]+") { return false; }

        if !contains(line, r"\+|\-|\*|/|\^") { return false; }
        
        contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$")
    }
}

pub mod iter
{
    pub use std::iter::{ * };

    pub fn drop_while<I, T, F>(iter: &mut I, mut f: F) where I: Iterator<Item=T> + Clone, F: FnMut(T) -> bool
    {
        loop
        {
            let mut clone = iter.clone();

            match clone.next()
            {
                None => break,
                Some(t) =>
                {
                    if f(t) { *iter = clone; } else { break; }
                }
            }
        }
    }
}

pub mod lines
{
    use ::
    {
        parsers::locust::{ self },
        types::{ CommandResult },
        *,
    };
    /*
    pub fn run_lines(sh: &mut shell::Shell, lines: &str, args: &Vec<String>, capture: bool) -> Vec<CommandResult> */
    pub fn run(sh: &mut shell::Shell, lines: &str, args: &Vec<String>, capture: bool) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        match locust::parse(lines)
       {
            Ok(pairs_exp) =>
            {
                for pair in pairs_exp
                {
                    let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, false, capture);
                    cr_list.append(&mut _cr_list);
                }
            }

            Err(e) =>
            {
                println_stderr!("syntax error: {:?}", e);
                return cr_list;
            }
        }
        cr_list
    }
}

pub mod marker
{
    pub use std::marker::{ * };
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod net
{
    pub use std::net::{ * };
}

pub mod now
{
    use ::
    {
        shell::{ Shell },
        types::{ CommandResult },
        *,
    };
    
    pub fn run_command_line(sh: &mut Shell, line: &str, tty: bool, capture: bool) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();

        for token in parsers::line::to_cmds(line)
        {
            if token == ";" || token == "&&" || token == "||"
            {
                sep = token.clone();
                continue;
            }

            if sep == "&&" && status != 0 { break; }

            if sep == "||" && status == 0 { break; }

            let cmd = token.clone();
            let cr = ::process::run(sh, &cmd, tty, capture);
            status = cr.status;
            sh.previous_status = status;
            cr_list.push(cr);
        }

        cr_list
    }
    /// Entry point for non-ttys (e.g. Cmd-N on MacVim)
    pub fn run_procs_for_non_tty(sh: &mut Shell)
    {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();
        match handle.read_to_string(&mut buffer)
        {
            Ok(_) =>
            {
                log!("run non tty command: {}", &buffer);
                run_command_line(sh, &buffer, false, false);
            }

            Err(e) => { println!("cicada: stdin.read_to_string() failed: {:?}", e); }
        }
    }
}

pub mod num
{
    pub use std::num::{ * };

    pub trait NotAllOnesHelper
    {
        type Type;
    }

    pub type NotAllOnes<T> = <T as NotAllOnesHelper>::Type;

    impl NotAllOnesHelper for u32 { type Type = U32NotAllOnes; }

    impl NotAllOnesHelper for i32 { type Type = I32NotAllOnes; }
    
    impl NotAllOnesHelper for u64 { type Type = U64NotAllOnes; }
    
    impl NotAllOnesHelper for i64 { type Type = I64NotAllOnes; }
}

pub mod ops 
{
    pub use std::ops::{ * };
}

pub mod os
{
    pub mod raw
    {
        pub use std::os::raw::{ * };
    }

    pub mod fd
    {
        //! Owned and borrowed Unix-like file descriptors.
        /// Implementations for `AsRawFd` etc. for network types.
        pub mod net
        {
            use ::
            {
                os::fd::
                {
                    owned::{ OwnedFd },
                    raw::{ AsRawFd, FromRawFd, IntoRawFd, RawFd },
                },
                sys::common::{ AsInner, FromInner, IntoInner },
                *,
            };

            macro_rules! impl_as_raw_fd
            {
                ($($t:ident)*) => {$
                (
                    impl AsRawFd for net::$t 
                    {
                        #[inline] fn as_raw_fd(&self) -> RawFd { self.as_inner().socket().as_raw_fd() }
                    }
                )*};
            }
            impl_as_raw_fd! { TcpStream TcpListener UdpSocket }

            macro_rules! impl_from_raw_fd 
            {
                ($($t:ident)*) => {$(
                    impl FromRawFd for net::$t {
                        #[inline]
                        unsafe fn from_raw_fd(fd: RawFd) -> net::$t {
                            unsafe {
                                let socket = sys::net::Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd)));
                                net::$t::from_inner(sys::net::$t::from_inner(socket))
                            }
                        }
                    }
                )*};
            }
            impl_from_raw_fd! { TcpStream TcpListener UdpSocket }

            macro_rules! impl_into_raw_fd
            {
                ($($t:ident)*) => {$(
                    impl IntoRawFd for net::$t {
                        #[inline]
                        fn into_raw_fd(self) -> RawFd {
                            self.into_inner().into_socket().into_inner().into_inner().into_raw_fd()
                        }
                    }
                )*};
            }
            impl_into_raw_fd! { TcpStream TcpListener UdpSocket }
        }
        /// `OwnedFd`, `AsFd`, etc.
        pub mod owned
        {
            use ::
            {
                marker::PhantomData,
                mem::ManuallyDrop,
                sys::common::{AsInner, FromInner, IntoInner},
                *,
            };
            
            type ValidRawFd = num::NotAllOnes<RawFd>;

            /// A borrowed file descriptor.
            #[repr( transparent )] #[derive( Copy, Clone )]
            pub struct BorrowedFd<'fd>
            {
                fd: ValidRawFd,
                _phantom: PhantomData<&'fd OwnedFd>,
            }
            /// An owned file descriptor.
            #[repr(transparent)]
            pub struct OwnedFd
            {
                fd: ValidRawFd,
            }

            impl BorrowedFd<'_>
            {
                /// Returns a `BorrowedFd` holding the given raw file descriptor.
                #[inline] #[track_caller] pub const unsafe fn borrow_raw(fd: RawFd) -> Self
                {
                    Self { fd: ValidRawFd::new(fd).expect("fd != -1"), _phantom: PhantomData }
                }
            }

            impl OwnedFd
            {
                /// Creates a new `OwnedFd` instance that shares the same underlying file description as the existing `OwnedFd` instance.
                pub fn try_clone(&self) -> crte::io::Result<Self> { self.as_fd().try_clone_to_owned() }
            }

            impl BorrowedFd<'_>
            {
                /// Creates a new `OwnedFd` instance that shares the same underlying file description as the existing `BorrowedFd` instance.
                pub fn try_clone_to_owned(&self) -> ::io::Result<OwnedFd>
                {
                    let cmd = libc::F_DUPFD_CLOEXEC;
                    let cmd = libc::F_DUPFD;
                    let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 3) })?;
                    Ok(unsafe { OwnedFd::from_raw_fd(fd) })
                }
            }
            
            impl AsRawFd for BorrowedFd<'_>
            {
                #[inline] fn as_raw_fd(&self) -> RawFd { self.fd.as_inner() }
            }
            
            impl AsRawFd for OwnedFd
            {
                 fn as_raw_fd(&self) -> RawFd { self.fd.as_inner() }
            }
            
            impl IntoRawFd for OwnedFd
            {
                #[inline] fn into_raw_fd(self) -> RawFd { ManuallyDrop::new(self).fd.as_inner() }
            }
            
            impl FromRawFd for OwnedFd
            {
                /// Constructs a new instance of `Self` from the given raw file descriptor.
                #[inline] #[track_caller]
                unsafe fn from_raw_fd(fd: RawFd) -> Self { Self { fd: ValidRawFd::new(fd).expect("fd != -1") } }
            }
            
            impl Drop for OwnedFd
            {
                #[inline] fn drop(&mut self)
                {
                    unsafe
                    {
                        ::sys::fs::debug_assert_fd_is_open(self.fd.as_inner());
                        let _ = libc::close(self.fd.as_inner());
                    }
                }
            }
            
            impl fmt::Debug for BorrowedFd<'_>
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    f.debug_struct("BorrowedFd").field("fd", &self.fd).finish()
                }
            }
            
            impl fmt::Debug for OwnedFd
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    f.debug_struct("OwnedFd").field("fd", &self.fd).finish()
                }
            }

            macro_rules! impl_is_terminal
            {
                ($($t:ty),*$(,)?) => {$
                (
                    impl ::sealed::Sealed for $t {}
                    
                    impl ::io::IsTerminal for $t
                    {
                        #[inline] fn is_terminal(&self) -> bool { ::sys::io::is_terminal(self) }
                    }
                )*}
            }

            impl_is_terminal!(BorrowedFd<'_>, OwnedFd);
            /// A trait to borrow the file descriptor from an underlying object.
            pub trait AsFd
            {
                /// Borrows the file descriptor.
                fn as_fd(&self) -> BorrowedFd<'_>;
            }
            
            impl<T: AsFd + ?Sized> AsFd for &T
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> { T::as_fd(self) }
            }
            
            impl<T: AsFd + ?Sized> AsFd for &mut T
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> { T::as_fd(self) }
            }
            
            impl AsFd for BorrowedFd<'_>
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> { *self }
            }

            impl AsFd for OwnedFd
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> { unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) } }
            }
            
            impl AsFd for fs::File
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_>
                {
                    self.as_inner().as_fd()
                }
            }
            
            impl From<fs::File> for OwnedFd
            {
                /// Takes ownership of a [`File`](fs::File)'s underlying file descriptor.
                #[inline] fn from(file: fs::File) -> OwnedFd
                {
                    file.into_inner().into_inner().into_inner()
                }
            }
            
            impl From<OwnedFd> for fs::File
            {
                /// Returns a [`File`](fs::File) that takes ownership of the given file descriptor.
                #[inline] fn from(owned_fd: OwnedFd) -> Self
                {
                    Self::from_inner(FromInner::from_inner(FromInner::from_inner(owned_fd)))
                }
            }
            
            impl AsFd for ::net::TcpStream
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_>
                {
                    self.as_inner().socket().as_fd()
                }
            }
            
            impl From<::net::TcpStream> for OwnedFd
            {
                /// Takes ownership of a [`TcpStream`](::net::TcpStream)'s socket file descriptor.
                #[inline] fn from(tcp_stream: ::net::TcpStream) -> OwnedFd
                {
                    tcp_stream.into_inner().into_socket().into_inner().into_inner().into()
                }
            }
            
            impl From<OwnedFd> for ::net::TcpStream
            {
                #[inline] fn from(owned_fd: OwnedFd) -> Self
                {
                    Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(
                        owned_fd,
                    ))))
                }
            }
            
            impl AsFd for ::net::TcpListener
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_>
                {
                    self.as_inner().socket().as_fd()
                }
            }
            
            impl From<::net::TcpListener> for OwnedFd
            {
                /// Takes ownership of a [`TcpListener`](::net::TcpListener)'s socket file descriptor.
                #[inline] fn from(tcp_listener: ::net::TcpListener) -> OwnedFd
                {
                    tcp_listener.into_inner().into_socket().into_inner().into_inner().into()
                }
            }
            
            impl From<OwnedFd> for ::net::TcpListener
            {
                #[inline] fn from(owned_fd: OwnedFd) -> Self
                {
                    Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(
                        owned_fd,
                    ))))
                }
            }
            
            impl AsFd for ::net::UdpSocket
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_>
                {
                    self.as_inner().socket().as_fd()
                }
            }
            
            impl From<::net::UdpSocket> for OwnedFd
            {
                /// Takes ownership of a [`UdpSocket`](::net::UdpSocket)'s file descriptor.
                #[inline] fn from(udp_socket: ::net::UdpSocket) -> OwnedFd
                {
                    udp_socket.into_inner().into_socket().into_inner().into_inner().into()
                }
            }
            
            impl From<OwnedFd> for ::net::UdpSocket
            {
                #[inline] fn from(owned_fd: OwnedFd) -> Self
                {
                    Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(
                        owned_fd,
                    ))))
                }
            }
            /// This impl allows implementing traits that require `AsFd` on Arc.
            impl<T: AsFd + ?Sized> AsFd for ::sync::Arc<T>
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    (**self).as_fd()
                }
            }
            
            impl<T: AsFd + ?Sized> AsFd for ::rc::Rc<T> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    (**self).as_fd()
                }
            }
            
            impl<T: AsFd + ?Sized> AsFd for ::rc::UniqueRc<T> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    (**self).as_fd()
                }
            }
            
            impl<T: AsFd + ?Sized> AsFd for Box<T> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    (**self).as_fd()
                }
            }
            
            impl AsFd for io::Stdin 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    unsafe { BorrowedFd::borrow_raw(0) }
                }
            }
            
            impl<'a> AsFd for io::StdinLock<'a> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    // SAFETY: user code should not close stdin out from under the standard library
                    unsafe { BorrowedFd::borrow_raw(0) }
                }
            }
            
            impl AsFd for io::Stdout 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    unsafe { BorrowedFd::borrow_raw(1) }
                }
            }
            
            impl<'a> AsFd for io::StdoutLock<'a> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    // SAFETY: user code should not close stdout out from under the standard library
                    unsafe { BorrowedFd::borrow_raw(1) }
                }
            }
            
            impl AsFd for io::Stderr 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    unsafe { BorrowedFd::borrow_raw(2) }
                }
            }
            
            impl<'a> AsFd for io::StderrLock<'a> 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    // SAFETY: user code should not close stderr out from under the standard library
                    unsafe { BorrowedFd::borrow_raw(2) }
                }
            }
            
            impl AsFd for io::PipeReader 
            {
                fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    self.0.as_fd()
                }
            }
            
            impl From<io::PipeReader> for OwnedFd 
            {
                fn from(pipe: io::PipeReader) -> Self 
                {
                    pipe.0.into_inner()
                }
            }
            
            impl AsFd for io::PipeWriter 
            {
                fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    self.0.as_fd()
                }
            }
            
            impl From<io::PipeWriter> for OwnedFd 
            {
                fn from(pipe: io::PipeWriter) -> Self 
                {
                    pipe.0.into_inner()
                }
            }
            
            impl From<OwnedFd> for io::PipeReader
            {
                fn from(owned_fd: OwnedFd) -> Self {
                    Self(FromInner::from_inner(owned_fd))
                }
            }
            
            impl From<OwnedFd> for io::PipeWriter
            {
                fn from(owned_fd: OwnedFd) -> Self
                {
                    Self(FromInner::from_inner(owned_fd))
                }
            }
        } pub use  self::owned::*;
        /// `RawFd`, `AsRawFd`, etc.
        pub mod raw
        {
            use ::
            {
                os::
                {
                    raw,
                    unix::
                    {
                        io::{ AsFd, OwnedFd },
                    },
                },
                sys::common::{AsInner, FromInner, IntoInner},
                *,
            };
            /// Raw file descriptors.
            pub type RawFd = raw::c_int;
            /// A trait to extract the raw file descriptor from an underlying object.
            pub trait AsRawFd
            {
                /// Extracts the raw file descriptor.
                fn as_raw_fd(&self) -> RawFd;
            }
            /// A trait to express the ability to construct an object from a raw file descriptor.
            pub trait FromRawFd
            {
                /// Constructs a new instance of `Self` from the given raw file descriptor.
                unsafe fn from_raw_fd(fd: RawFd) -> Self;
            }
            /// A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.
            pub trait IntoRawFd
            {
                /// Consumes this object, returning the raw underlying file descriptor.
                fn into_raw_fd(self) -> RawFd;
            }
            
            impl AsRawFd for RawFd 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    *self
                }
            }
            
            impl IntoRawFd for RawFd 
            {
                #[inline] fn into_raw_fd(self) -> RawFd 
                {
                    self
                }
            }
            
            impl FromRawFd for RawFd 
            {
                #[inline] unsafe fn from_raw_fd(fd: RawFd) -> RawFd 
                {
                    fd
                }
            }
            
            impl AsRawFd for fs::File 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    self.as_inner().as_raw_fd()
                }
            }
            
            impl FromRawFd for fs::File 
            {
                #[inline] unsafe fn from_raw_fd(fd: RawFd) -> fs::File 
                {
                    unsafe { fs::File::from(OwnedFd::from_raw_fd(fd)) }
                }
            }
            
            impl IntoRawFd for fs::File 
            {
                #[inline] fn into_raw_fd(self) -> RawFd 
                {
                    self.into_inner().into_inner().into_raw_fd()
                }
            }
            
            impl AsRawFd for io::Stdin 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDIN_FILENO
                }
            }
            
            impl AsRawFd for io::Stdout 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDOUT_FILENO
                }
            }
            
            impl AsRawFd for io::Stderr 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDERR_FILENO
                }
            }
            
            impl<'a> AsRawFd for io::StdinLock<'a> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDIN_FILENO
                }
            }
            
            impl<'a> AsRawFd for io::StdoutLock<'a> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDOUT_FILENO
                }
            }
            
            impl<'a> AsRawFd for io::StderrLock<'a> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    libc::STDERR_FILENO
                }
            }
            /// This impl allows implementing traits that require `AsRawFd` on Arc.
            impl<T: AsRawFd> AsRawFd for ::sync::Arc<T> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    (**self).as_raw_fd()
                }
            }
            
            impl<T: AsRawFd> AsRawFd for ::rc::Rc<T> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    (**self).as_raw_fd()
                }
            }
            
            impl<T: AsRawFd + ?Sized> AsRawFd for ::rc::UniqueRc<T> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    (**self).as_raw_fd()
                }
            }
            
            impl<T: AsRawFd> AsRawFd for Box<T> 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    (**self).as_raw_fd()
                }
            }
            
            impl AsRawFd for io::PipeReader 
            {
                fn as_raw_fd(&self) -> RawFd 
                {
                    self.0.as_raw_fd()
                }
            }
            
            impl FromRawFd for io::PipeReader 
            {
                unsafe fn from_raw_fd(raw_fd: RawFd) -> Self 
                {
                    Self::from_inner(unsafe { FromRawFd::from_raw_fd(raw_fd) })
                }
            }
            
            impl IntoRawFd for io::PipeReader 
            {
                fn into_raw_fd(self) -> RawFd 
                {
                    self.0.into_raw_fd()
                }
            }
            
            impl AsRawFd for io::PipeWriter 
            {
                fn as_raw_fd(&self) -> RawFd 
                {
                    self.0.as_raw_fd()
                }
            }
            
            impl FromRawFd for io::PipeWriter 
            {
                unsafe fn from_raw_fd(raw_fd: RawFd) -> Self 
                {
                    Self::from_inner(unsafe { FromRawFd::from_raw_fd(raw_fd) })
                }
            }
            
            impl IntoRawFd for io::PipeWriter 
            {
                fn into_raw_fd(self) -> RawFd 
                {
                    self.0.into_raw_fd()
                }
            }
        } pub use self::raw::*;
    }

    pub mod net
    {
        //! Linux and Android-specific networking functionality.
        pub mod addr
        {
            //! Linux and Android-specific extensions to socket addresses.
            use ::
            {
                os::unix::net::{ SocketAddr },
                sealed::{ Sealed },
                *,
            };
            /// Platform-specific extensions to [`SocketAddr`].
            pub trait SocketAddrExt: Sealed
            {
                /// Creates a Unix socket address in the abstract namespace.
                fn from_abstract_name<N>(name: N) -> ::io::Result<SocketAddr> where N: AsRef<[u8]>;

                /// Returns the contents of this address if it is in the abstract namespace.
                fn as_abstract_name(&self) -> Option<&[u8]>;
            }
        }
        
        pub mod socket
        {
            //! Linux and Android-specific socket functionality.
            use ::
            {
                os::unix::net,
                sealed::{ Sealed },
                sys::common::{ AsInner },
                *,
            };
            /// Linux-specific functionality for `AF_UNIX` sockets [`UnixDatagram`] and [`UnixStream`].
            pub trait UnixSocketExt: Sealed
            {
                /// Query the current setting of socket option `SO_PASSCRED`.
                fn passcred(&self) -> io::Result<bool>;
                /// Enable or disable socket option `SO_PASSCRED`.
                fn set_passcred(&self, passcred: bool) -> io::Result<()>;
            }
            
            impl UnixSocketExt for net::UnixDatagram
            {
                fn passcred(&self) -> io::Result<bool> { self.as_inner().passcred() }
                
                fn set_passcred(&self, passcred: bool) -> io::Result<()> { self.as_inner().set_passcred(passcred) }
            }
            
            impl UnixSocketExt for net::UnixStream
            {
                fn passcred(&self) -> io::Result<bool> { self.as_inner().passcred() }
                
                fn set_passcred(&self, passcred: bool) -> io::Result<()> { self.as_inner().set_passcred(passcred) }
            }
        }
        
        pub mod tcp
        {
            //! Linux and Android-specific tcp extensions to primitives in the [`std::net`] module.
            use ::
            {
                sealed::{ Sealed },
                sys::common::{ AsInner },
                *,
            };
            /// Os-specific extensions for [`TcpStream`]
            pub trait TcpStreamExt: Sealed
            {
                /// Enable or disable `TCP_QUICKACK`.
                fn set_quickack(&self, quickack: bool) -> io::Result<()>;
                /// Gets the value of the `TCP_QUICKACK` option on this socket.
                fn quickack(&self) -> io::Result<bool>;
                /// A socket listener will be awakened solely when data arrives.
                fn set_deferaccept(&self, accept: u32) -> io::Result<()>;
                /// Gets the accept delay value (in seconds) of the `TCP_DEFER_ACCEPT` option.
                fn deferaccept(&self) -> io::Result<u32>;
            }
            
            impl Sealed for net::TcpStream {}
            
            impl TcpStreamExt for net::TcpStream
            {
                fn set_quickack(&self, quickack: bool) -> io::Result<()> { self.as_inner().as_inner().set_quickack(quickack) }

                fn quickack(&self) -> io::Result<bool> { self.as_inner().as_inner().quickack() }
                
                fn set_deferaccept(&self, accept: u32) -> io::Result<()> { self.as_inner().as_inner().set_deferaccept(accept) }
                
                fn deferaccept(&self) -> io::Result<u32> { self.as_inner().as_inner().deferaccept() }
            }
        }
    }

    pub mod uefi
    {
        pub mod env
        {
            //! UEFI-specific extensions to the primitives in `std::env` module
            use ::
            {
                ffi::{ c_void },
                ptr::{ NonNull },
                sync::atomic::{ AtomicBool, AtomicPtr, Ordering },
                *,
            };

            static mut SYSTEM_TABLE:Option<()> = None;
            static mut IMAGE_HANDLE:Option<()> = None;
            static mut BOOT_SERVICES_FLAG:Option<bool> = None;
            /*
            static SYSTEM_TABLE: Atomic<*mut c_void> = AtomicPtr::new(crate::ptr::null_mut());
            static IMAGE_HANDLE: Atomic<*mut c_void> = AtomicPtr::new(crate::ptr::null_mut());
            // Flag to check if BootServices are still valid.
            // Start with assuming that they are not available
            static BOOT_SERVICES_FLAG: Atomic<bool> = AtomicBool::new(false);
            */
            /// Initializes the global System Table and Image Handle pointers.
            pub unsafe fn init_globals(handle: NonNull<()>, system_table: NonNull<()>) {}
            /// Gets the SystemTable Pointer.
            pub fn system_table() -> NonNull<()>
            {
                unsafe
                {
                    NonNull( () )
                }
            }
            /// Gets the ImageHandle Pointer.
            pub fn image_handle() -> NonNull<()>
            {
                unsafe
                {
                    NonNull( () )
                }
            }

            /// Gets the BootServices Pointer.
            pub fn boot_services() -> Option<NonNull<()>>
            {
                None
            }
            /// Gets the SystemTable Pointer.
            pub fn try_system_table() -> Option<NonNull<()>>
            {
                None
            }
            /// Gets the SystemHandle Pointer.
            pub fn try_image_handle() -> Option<NonNull<()>>
            {
                None
            }

            pub fn disable_boot_services() {}
        }

        pub mod ffi
        {
            use ::
            {
                *,
            };
        }
    }

    pub mod unix
    {
        //! Platform-specific extensions to `std` for Unix platforms.
        use ::
        {
            *,
        };
        
        mod platform 
        {
            
        }

        pub mod ffi
        {
            use ::
            {
                *,
            };
        }

        pub mod fs
        {
            //! Unix-specific extensions to primitives in the [`std::fs`] module.
            use ::
            {
                ffi::OsStr,
                fs::{self, OpenOptions, Permissions},
                os::unix::io::{AsFd, AsRawFd},
                path::Path,
                sealed::Sealed,
                sys::common::{AsInner, AsInnerMut, FromInner},
                io::{ Read, Write},
                *,
            }; 
            use super::platform::fs::MetadataExt as _;
            /// Unix-specific extensions to [`fs::File`].
            pub trait FileExt
            {
                /// Reads a number of bytes starting from a given offset.
                fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;

                /// Like `read_at`, except that it reads into a slice of buffers.
                fn read_vectored_at(&self, bufs: &mut [io::IoSliceMut<'_>], offset: u64) -> io::Result<usize> {
                    io::default_read_vectored(|b| self.read_at(b, offset), bufs)
                }

                /// Reads the exact number of bytes required to fill `buf` from the given offset.
                fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {
                    while !buf.is_empty() {
                        match self.read_at(buf, offset) {
                            Ok(0) => break,
                            Ok(n) => {
                                let tmp = buf;
                                buf = &mut tmp[n..];
                                offset += n as u64;
                            }
                            Err(ref e) if e.is_interrupted() => {}
                            Err(e) => return Err(e),
                        }
                    }
                    if !buf.is_empty() { Err(io::Error::READ_EXACT_EOF) } else { Ok(()) }
                }

                /// Writes a number of bytes starting from a given offset.
                fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;

                /// Like `write_at`, except that it writes from a slice of buffers.
                
                fn write_vectored_at(&self, bufs: &[io::IoSlice<'_>], offset: u64) -> io::Result<usize> {
                    ::io::default_write_vectored(|b| self.write_at(b, offset), bufs)
                }

                /// Attempts to write an entire buffer starting from a given offset.
                fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {
                    while !buf.is_empty() {
                        match self.write_at(buf, offset) {
                            Ok(0) => {
                                return Err(io::Error::WRITE_ALL_EOF);
                            }
                            Ok(n) => {
                                buf = &buf[n..];
                                offset += n as u64
                            }
                            Err(ref e) if e.is_interrupted() => {}
                            Err(e) => return Err(e),
                        }
                    }
                    Ok(())
                }
            }
            
            impl FileExt for fs::File 
            {
                fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {
                    self.as_inner().read_at(buf, offset)
                }
                
                fn read_vectored_at(&self, bufs: &mut [io::IoSliceMut<'_>], offset: u64) -> io::Result<usize> {
                    self.as_inner().read_vectored_at(bufs, offset)
                }
                
                fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {
                    self.as_inner().write_at(buf, offset)
                }
                
                fn write_vectored_at(&self, bufs: &[io::IoSlice<'_>], offset: u64) -> io::Result<usize> {
                    self.as_inner().write_vectored_at(bufs, offset)
                }
            }

            /// Unix-specific extensions to [`fs::Permissions`].
            pub trait PermissionsExt {
                /// Returns the mode permission bits
                
                fn mode(&self) -> u32;

                /// Sets the mode permission bits.
                
                fn set_mode(&mut self, mode: u32);

                /// Creates a new instance from the given mode permission bits.
                fn from_mode(mode: u32) -> Self;
            }
            
            impl PermissionsExt for Permissions {
                fn mode(&self) -> u32 {
                    self.as_inner().mode()
                }

                fn set_mode(&mut self, mode: u32) {
                    *self = Permissions::from_inner(FromInner::from_inner(mode));
                }

                fn from_mode(mode: u32) -> Permissions {
                    Permissions::from_inner(FromInner::from_inner(mode))
                }
            }

            /// Unix-specific extensions to [`fs::OpenOptions`]. 
            pub trait OpenOptionsExt {
                /// Sets the mode bits that a new file will be created with.
                fn mode(&mut self, mode: u32) -> &mut Self;

                /// Pass custom flags to the `flags` argument of `open`.
                fn custom_flags(&mut self, flags: i32) -> &mut Self;
            }
            
            impl OpenOptionsExt for OpenOptions 
            {
                fn mode(&mut self, mode: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().mode(mode);
                    self
                }

                fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().custom_flags(flags);
                    self
                }
            }

            /// Unix-specific extensions to [`fs::Metadata`].            
            pub trait MetadataExt 
            {
                /// Returns the ID of the device containing the file.
                fn dev(&self) -> u64;
                /// Returns the inode number.
                fn ino(&self) -> u64;
                /// Returns the rights applied to this file.
                fn mode(&self) -> u32;
                /// Returns the number of hard links pointing to this file.
                fn nlink(&self) -> u64;
                /// Returns the user ID of the owner of this file.
                fn uid(&self) -> u32;
                /// Returns the group ID of the owner of this file.
                fn gid(&self) -> u32;
                /// Returns the device ID of this file (if it is a special one).
                fn rdev(&self) -> u64;
                /// Returns the total size of this file in bytes.
                fn size(&self) -> u64;
                /// Returns the last access time of the file, in seconds since Unix Epoch.
                fn atime(&self) -> i64;
                /// Returns the last access time of the file, in nanoseconds since [`atime`].
                fn atime_nsec(&self) -> i64;
                /// Returns the last modification time of the file, in seconds since Unix Epoch.
                fn mtime(&self) -> i64;
                /// Returns the last modification time of the file, in nanoseconds since [`mtime`].
                fn mtime_nsec(&self) -> i64;
                /// Returns the last status change time of the file, in seconds since Unix Epoch.
                fn ctime(&self) -> i64;
                /// Returns the last status change time of the file, in nanoseconds since [`ctime`].
                fn ctime_nsec(&self) -> i64;
                /// Returns the block size for filesystem I/O.
                fn blksize(&self) -> u64;
                /// Returns the number of blocks allocated to the file, in 512-byte units.
                fn blocks(&self) -> u64;
            }
            
            impl MetadataExt for fs::Metadata {
                fn dev(&self) -> u64 {
                    self.st_dev()
                }
                
                fn ino(&self) -> u64 {
                    self.st_ino()
                }
                
                fn mode(&self) -> u32 {
                    self.st_mode()
                }
                
                fn nlink(&self) -> u64 {
                    self.st_nlink()
                }
                
                fn uid(&self) -> u32 {
                    self.st_uid()
                }
                
                fn gid(&self) -> u32 {
                    self.st_gid()
                }
                
                fn rdev(&self) -> u64 {
                    self.st_rdev()
                }
                
                fn size(&self) -> u64 {
                    self.st_size()
                }
                
                fn atime(&self) -> i64 {
                    self.st_atime()
                }
                
                fn atime_nsec(&self) -> i64 {
                    self.st_atime_nsec()
                }
                
                fn mtime(&self) -> i64 {
                    self.st_mtime()
                }
                
                fn mtime_nsec(&self) -> i64 {
                    self.st_mtime_nsec()
                }
                
                fn ctime(&self) -> i64 {
                    self.st_ctime()
                }
                
                fn ctime_nsec(&self) -> i64 {
                    self.st_ctime_nsec()
                }
                
                fn blksize(&self) -> u64 {
                    self.st_blksize()
                }
                
                fn blocks(&self) -> u64 {
                    self.st_blocks()
                }
            }

            /// Unix-specific extensions for [`fs::FileType`].
            pub trait FileTypeExt {
                /// Returns `true` if this file type is a block device.
                fn is_block_device(&self) -> bool;
                /// Returns `true` if this file type is a char device.
                fn is_char_device(&self) -> bool;
                /// Returns `true` if this file type is a fifo.
                fn is_fifo(&self) -> bool;
                /// Returns `true` if this file type is a socket.
                fn is_socket(&self) -> bool;
            }
            
            impl FileTypeExt for fs::FileType {
                fn is_block_device(&self) -> bool {
                    self.as_inner().is(libc::S_IFBLK)
                }
                
                fn is_char_device(&self) -> bool {
                    self.as_inner().is(libc::S_IFCHR)
                }
                
                fn is_fifo(&self) -> bool {
                    self.as_inner().is(libc::S_IFIFO)
                }
                
                fn is_socket(&self) -> bool {
                    self.as_inner().is(libc::S_IFSOCK)
                }
            }

            /// Unix-specific extension methods for [`fs::DirEntry`].            
            pub trait DirEntryExt {
                /// Returns the underlying `d_ino` field in the contained `dirent`
                /// structure.
                fn ino(&self) -> u64;
            }
            
            impl DirEntryExt for fs::DirEntry {
                fn ino(&self) -> u64 {
                    self.as_inner().ino()
                }
            }

            /// Sealed Unix-specific extension methods for [`fs::DirEntry`]. 
            pub trait DirEntryExt2: Sealed {
                /// Returns a reference to the underlying `OsStr` of this entry's filename.
                fn file_name_ref(&self) -> &OsStr;
            }

            /// Allows extension traits within `std`.            
            impl Sealed for fs::DirEntry {}
            
            impl DirEntryExt2 for fs::DirEntry {
                fn file_name_ref(&self) -> &OsStr {
                    self.as_inner().file_name_os_str()
                }
            }

            /// Creates a new symbolic link on the filesystem.
            pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {
                sys::fs::symlink(original.as_ref(), link.as_ref())
            }

            /// Unix-specific extensions to [`fs::DirBuilder`].            
            pub trait DirBuilderExt {
                fn mode(&mut self, mode: u32) -> &mut Self;
            }
            
            impl DirBuilderExt for fs::DirBuilder {
                fn mode(&mut self, mode: u32) -> &mut fs::DirBuilder {
                    self.as_inner_mut().set_mode(mode);
                    self
                }
            }

            /// Change the owner and group of the specified path.
            
            pub fn chown<P: AsRef<Path>>(dir: P, uid: Option<u32>, gid: Option<u32>) -> io::Result<()> {
                sys::fs::chown(dir.as_ref(), uid.unwrap_or(u32::MAX), gid.unwrap_or(u32::MAX))
            }

            /// Change the owner and group of the file referenced by the specified open file descriptor.
            
            pub fn fchown<F: AsFd>(fd: F, uid: Option<u32>, gid: Option<u32>) -> io::Result<()> {
                sys::fs::fchown(fd.as_fd().as_raw_fd(), uid.unwrap_or(u32::MAX), gid.unwrap_or(u32::MAX))
            }

            /// Change the owner and group of the specified path, without dereferencing symbolic links.
            pub fn lchown<P: AsRef<Path>>(dir: P, uid: Option<u32>, gid: Option<u32>) -> io::Result<()> {
                sys::fs::lchown(dir.as_ref(), uid.unwrap_or(u32::MAX), gid.unwrap_or(u32::MAX))
            }

            /// Change the root directory of the current process to the specified path.
            pub fn chroot<P: AsRef<Path>>(dir: P) -> io::Result<()> {
                sys::fs::chroot(dir.as_ref())
            }

            /// Create a FIFO special file at the specified path with the specified mode.
            pub fn mkfifo<P: AsRef<Path>>(path: P, permissions: Permissions) -> io::Result<()> {
                sys::fs::mkfifo(path.as_ref(), permissions.mode())
            }
        }

        pub mod io
        {
            //! Unix-specific extensions to general I/O primitives.
            use ::
            {
                *,
            };

            pub use ::os::fd::*;
        }

        pub mod net
        {
            //! Unix-specific networking functionality.
            use ::
            {
                *,
            };
            
            pub mod addr
            {
                use ::
                {
                    ffi::OsStr, 
                    os::net::linux_ext, 
                    os::unix::ffi::OsStrExt, 
                    path::Path, 
                    sealed::Sealed, 
                    sys::cvt, 
                    *,
                };

                mod libc
                {
                    pub use ::ffi::c_int;
                    pub type socklen_t = u32;
                    pub struct sockaddr;
                    #[derive(Clone)]
                    pub struct sockaddr_un
                    {
                        pub sun_path: [u8; 1],
                    }
                }

                const SUN_PATH_OFFSET: usize = mem::offset_of!(libc::sockaddr_un, sun_path);
                
                pub(super) fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> 
                {
                    let mut addr: libc::sockaddr_un = unsafe { mem::zeroed() };
                    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;

                    let bytes = path.as_os_str().as_bytes();

                    if bytes.contains(&0) 
                    {
                        return Err( constant_error!(
                            io::ErrorKind::InvalidInput,
                            "paths must not contain interior null bytes",
                        ));
                    }

                    if bytes.len() >= addr.sun_path.len() 
                    {
                        return Err( constant_error!(
                            io::ErrorKind::InvalidInput,
                            "path must be shorter than SUN_LEN",
                        ));
                    }
                    
                    unsafe 
                    {
                        ::ptr::copy_nonoverlapping(bytes.as_ptr(), addr.sun_path.as_mut_ptr().cast(), bytes.len())
                    };

                    let mut len = SUN_PATH_OFFSET + bytes.len();
                    match bytes.get(0) {
                        Some(&0) | None => {}
                        Some(_) => len += 1,
                    }

                    Ok((addr, len as libc::socklen_t))
                }

                enum AddressKind<'a>
                {
                    Unnamed,
                    Pathname(&'a Path),
                    Abstract(&'a [u8]),
                }
                /// An address associated with a Unix socket.
                #[derive(Clone)]
                pub struct SocketAddr
                {
                    pub(super) addr: libc::sockaddr_un,
                    pub(super) len: libc::socklen_t,
                }

                impl SocketAddr
                {
                    pub(super) fn new<F>(f: F) -> io::Result<SocketAddr> where
                    F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int,
                    {
                        unsafe 
                        {
                            let mut addr: libc::sockaddr_un = mem::zeroed();
                            let mut len = size_of::<libc::sockaddr_un>() as libc::socklen_t;
                            cvt(f((&raw mut addr) as *mut _, &mut len))?;
                            SocketAddr::from_parts(addr, len)
                        }
                    }

                    pub(super) fn from_parts
                    (
                        addr: libc::sockaddr_un,
                        mut len: libc::socklen_t,
                    ) -> io::Result<SocketAddr> 
                    {
                        if cfg!(target_os = "openbsd")
                        {
                            let sun_path: &[u8] =
                                unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&addr.sun_path) };
                            len = core::slice::memchr::memchr(0, sun_path)
                                .map_or(len, |new_len| (new_len + SUN_PATH_OFFSET) as libc::socklen_t);
                        }

                        if len == 0 {
                            len = SUN_PATH_OFFSET as libc::socklen_t;
                        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {
                            return Err( constant_error!(
                                io::ErrorKind::InvalidInput,
                                "file descriptor did not correspond to a Unix socket",
                            ));
                        }

                        Ok(SocketAddr { addr, len })
                    }
                    /// Constructs a `SockAddr` with the family `AF_UNIX` and the provided path.
                    pub fn from_pathname<P>(path: P) -> io::Result<SocketAddr> where
                    P: AsRef<Path>,
                    {
                        sockaddr_un(path.as_ref()).map(|(addr, len)| SocketAddr { addr, len })
                    }
                    /// Returns `true` if the address is unnamed.
                    #[must_use]                    
                    pub fn is_unnamed(&self) -> bool 
                    {
                        matches!(self.address(), AddressKind::Unnamed)
                    }
                    /// Returns the contents of this address if it is a `pathname` address.                    
                    #[must_use]
                    pub fn as_pathname(&self) -> Option<&Path> 
                    {
                        if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }
                    }

                    fn address(&self) -> AddressKind<'_> 
                    {
                        let len = self.len as usize - SUN_PATH_OFFSET;
                        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };
                        
                        if len == 0
                            || (cfg!(not(any(target_os = "linux", target_os = "android")))
                                && self.addr.sun_path[0] == 0)
                        {
                            AddressKind::Unnamed
                        } else if self.addr.sun_path[0] == 0 {
                            AddressKind::Abstract(&path[1..len])
                        } else {
                            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())
                        }
                    }
                }
                
                impl Sealed for SocketAddr {}
                
                impl linux_ext::addr::SocketAddrExt for SocketAddr 
                {
                    fn as_abstract_name(&self) -> Option<&[u8]>
                    {
                        if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }
                    }

                    fn from_abstract_name<N>(name: N) -> crate::io::Result<Self> where
                    N: AsRef<[u8]>
                    {
                        let name = name.as_ref();
                        unsafe
                        {
                            let mut addr: libc::sockaddr_un = mem::zeroed();
                            addr.sun_family = libc::AF_UNIX as libc::sa_family_t;

                            if name.len() + 1 > addr.sun_path.len() {
                                return Err( constant_error!(
                                    io::ErrorKind::InvalidInput,
                                    "abstract socket name must be shorter than SUN_LEN",
                                ));
                            }

                            crate::ptr::copy_nonoverlapping(
                                name.as_ptr(),
                                addr.sun_path.as_mut_ptr().add(1) as *mut u8,
                                name.len(),
                            );
                            let len = (SUN_PATH_OFFSET + 1 + name.len()) as libc::socklen_t;
                            SocketAddr::from_parts(addr, len)
                        }
                    }
                }
                
                impl fmt::Debug for SocketAddr 
                {
                    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result 
                    {
                        match self.address() 
                        {
                            AddressKind::Unnamed => write!(fmt, "(unnamed)"),
                            AddressKind::Abstract(name) => write!(fmt, "\"{}\" (abstract)", name.escape_ascii()),
                            AddressKind::Pathname(path) => write!(fmt, "{path:?} (pathname)"),
                        }
                    }
                }
            } pub use self::addr::*;

            pub mod ancillary
            {
                use ::
                {
                    io::{self, IoSlice, IoSliceMut},
                    marker::PhantomData,
                    mem::zeroed,
                    os::unix::io::RawFd,
                    path::Path,
                    ptr::{eq, read_unaligned},
                    slice::from_raw_parts,
                    sys::net::Socket,
                    *,
                }; use super::{SocketAddr, sockaddr_un};
                
                pub(super) fn recv_vectored_with_ancillary_from
                (
                    socket: &Socket,
                    bufs: &mut [IoSliceMut<'_>],
                    ancillary: &mut SocketAncillary<'_>,
                ) -> io::Result<(usize, bool, io::Result<SocketAddr>)> 
                {
                    unsafe
                    {
                        let mut msg_name: libc::sockaddr_un = zeroed();
                        let mut msg: libc::msghdr = zeroed();
                        msg.msg_name = (&raw mut msg_name) as *mut _;
                        msg.msg_namelen = size_of::<libc::sockaddr_un>() as libc::socklen_t;
                        msg.msg_iov = bufs.as_mut_ptr().cast();
                        msg.msg_iovlen = bufs.len() as _;
                        msg.msg_controllen = ancillary.buffer.len() as _;
                        // macos requires that the control pointer is null when the len is 0.
                        if msg.msg_controllen > 0 {
                            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();
                        }

                        let count = socket.recv_msg(&mut msg)?;

                        ancillary.length = msg.msg_controllen as usize;
                        ancillary.truncated = msg.msg_flags & libc::MSG_CTRUNC == libc::MSG_CTRUNC;

                        let truncated = msg.msg_flags & libc::MSG_TRUNC == libc::MSG_TRUNC;
                        let addr = SocketAddr::from_parts(msg_name, msg.msg_namelen);

                        Ok((count, truncated, addr))
                    }
                }

                pub(super) fn send_vectored_with_ancillary_to
                (
                    socket: &Socket,
                    path: Option<&Path>,
                    bufs: &[IoSlice<'_>],
                    ancillary: &mut SocketAncillary<'_>,
                ) -> io::Result<usize> 
                {
                    unsafe 
                    {
                        let (mut msg_name, msg_namelen) = if let Some(path) = path { sockaddr_un(path)? } else { (zeroed(), 0) };

                        let mut msg: libc::msghdr = zeroed();
                        msg.msg_name = (&raw mut msg_name) as *mut _;
                        msg.msg_namelen = msg_namelen;
                        msg.msg_iov = bufs.as_ptr() as *mut _;
                        msg.msg_iovlen = bufs.len() as _;
                        msg.msg_controllen = ancillary.length as _;
                        // macos requires that the control pointer is null when the len is 0.
                        if msg.msg_controllen > 0 {
                            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();
                        }

                        ancillary.truncated = false;

                        socket.send_msg(&mut msg)
                    }
                }

                fn add_to_ancillary_data<T>
                (
                    buffer: &mut [u8],
                    length: &mut usize,
                    source: &[T],
                    cmsg_level: libc::c_int,
                    cmsg_type: libc::c_int,
                ) -> bool 
                {
                    let cmsg_size = source.len().checked_mul(size_of::<T>());
                    let source_len = if let Some(source_len) = cmsg_size {
                        if let Ok(source_len) = u32::try_from(source_len) {
                            source_len
                        } else {
                            return false;
                        }
                    } else {
                        return false;
                    };

                    unsafe {
                        let additional_space = libc::CMSG_SPACE(source_len) as usize;

                        let new_length = if let Some(new_length) = additional_space.checked_add(*length) {
                            new_length
                        } else {
                            return false;
                        };

                        if new_length > buffer.len() {
                            return false;
                        }

                        buffer[*length..new_length].fill(0);

                        *length = new_length;

                        let mut msg: libc::msghdr = zeroed();
                        msg.msg_control = buffer.as_mut_ptr().cast();
                        msg.msg_controllen = *length as _;

                        let mut cmsg = libc::CMSG_FIRSTHDR(&msg);
                        let mut previous_cmsg = cmsg;
                        while !cmsg.is_null() 
                        {
                            previous_cmsg = cmsg;
                            cmsg = libc::CMSG_NXTHDR(&msg, cmsg);
                            if eq(cmsg, previous_cmsg) {
                                break;
                            }
                        }

                        if previous_cmsg.is_null() { return false; }

                        (*previous_cmsg).cmsg_level = cmsg_level;
                        (*previous_cmsg).cmsg_type = cmsg_type;
                        (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as _;

                        let data = libc::CMSG_DATA(previous_cmsg).cast();

                        libc::memcpy(data, source.as_ptr().cast(), source_len as usize);
                    }
                    true
                }

                struct AncillaryDataIter<'a, T>
                {
                    data: &'a [u8],
                    phantom: PhantomData<T>,
                }

                impl<'a, T> AncillaryDataIter<'a, T>
                {
                    /// Creates `AncillaryDataIter` struct to iterate through the data unit in the control message.
                    unsafe fn new(data: &'a [u8]) -> AncillaryDataIter<'a, T>
                    {
                        AncillaryDataIter { data, phantom: PhantomData }
                    }
                }

                impl<'a, T> Iterator for AncillaryDataIter<'a, T>
                {
                    type Item = T;

                    fn next(&mut self) -> Option<T> 
                    {
                        if size_of::<T>() <= self.data.len() 
                        {
                            unsafe
                            {
                                let unit = read_unaligned(self.data.as_ptr().cast());
                                self.data = &self.data[size_of::<T>()..];
                                Some(unit)
                            }
                        }
                        else { None }
                    }
                }
                /// Unix credential.
                #[derive(Clone)]
                pub struct SocketCred(libc::ucred);
                
                impl SocketCred
                {
                    /// Creates a Unix credential struct.
                    #[must_use] pub fn new() -> SocketCred
                    {
                        SocketCred(libc::ucred { pid: 0, uid: 0, gid: 0 })
                    }

                    /// Set the PID.
                    pub fn set_pid(&mut self, pid: libc::pid_t)
                    {
                        self.0.pid = pid;
                    }

                    /// Gets the current PID.
                    #[must_use]
                    pub fn get_pid(&self) -> libc::pid_t
                    {
                        self.0.pid
                    }

                    /// Set the UID.
                    pub fn set_uid(&mut self, uid: libc::uid_t)
                    {
                        self.0.uid = uid;
                    }

                    /// Gets the current UID.
                    #[must_use] pub fn get_uid(&self) -> libc::uid_t
                    {
                        self.0.uid
                    }
                    /// Set the GID.                    
                    pub fn set_gid(&mut self, gid: libc::gid_t)
                    {
                        self.0.gid = gid;
                    }
                    /// Gets the current GID.
                    #[must_use] pub fn get_gid(&self) -> libc::gid_t
                    {
                        self.0.gid
                    }
                }
                
                impl SocketCred
                {
                    /// Creates a Unix credential struct.
                    #[must_use] pub fn new() -> SocketCred
                    {
                        SocketCred(libc::sockcred2
                        {
                            sc_version: 0,
                            sc_pid: 0,
                            sc_uid: 0,
                            sc_euid: 0,
                            sc_gid: 0,
                            sc_egid: 0,
                            sc_ngroups: 0,
                            sc_groups: [0; 1],
                        })
                    }
                    /// Set the PID.
                    pub fn set_pid(&mut self, pid: libc::pid_t) { self.0.sc_pid = pid; }
                    /// Gets the current PID.
                    #[must_use] pub fn get_pid(&self) -> libc::pid_t { self.0.sc_pid }
                    /// Set the UID.                    
                    pub fn set_uid(&mut self, uid: libc::uid_t) { self.0.sc_euid = uid; }
                    /// Gets the current UID.
                    #[must_use] pub fn get_uid(&self) -> libc::uid_t
                    { self.0.sc_euid }
                    /// Set the GID.
                    pub fn set_gid(&mut self, gid: libc::gid_t)
                    { self.0.sc_egid = gid; }
                    /// Gets the current GID.
                    #[must_use]
                    pub fn get_gid(&self) -> libc::gid_t { self.0.sc_egid }
                }
                
                impl SocketCred
                {
                    /// Creates a Unix credential struct.    
                    pub fn new() -> SocketCred
                    {
                        SocketCred(libc::sockcred
                        {
                            sc_pid: 0,
                            sc_uid: 0,
                            sc_euid: 0,
                            sc_gid: 0,
                            sc_egid: 0,
                            sc_ngroups: 0,
                            sc_groups: [0u32; 1],
                        })
                    }

                    /// Set the PID.
                    pub fn set_pid(&mut self, pid: libc::pid_t) { self.0.sc_pid = pid; }
                    /// Gets the current PID.
                    #[must_use]
                    pub fn get_pid(&self) -> libc::pid_t { self.0.sc_pid }
                    /// Set the UID.
                    pub fn set_uid(&mut self, uid: libc::uid_t) { self.0.sc_uid = uid; }
                    /// Gets the current UID.
                    #[must_use]
                    pub fn get_uid(&self) -> libc::uid_t { self.0.sc_uid }
                    /// Set the GID.
                    pub fn set_gid(&mut self, gid: libc::gid_t) { self.0.sc_gid = gid; }
                    /// Gets the current GID.
                    #[must_use]
                    pub fn get_gid(&self) -> libc::gid_t { self.0.sc_gid }
                }
                /// This control message contains file descriptors.
                pub struct ScmRights<'a>(AncillaryDataIter<'a, RawFd>);
                
                impl<'a> Iterator for ScmRights<'a>
                {
                    type Item = RawFd;

                    fn next(&mut self) -> Option<RawFd>
                    {
                        self.0.next()
                    }
                }
                
                /// This control message contains unix credentials.
                pub struct ScmCredentials<'a>(AncillaryDataIter<'a, libc::ucred>);
                
                impl<'a> Iterator for ScmCredentials<'a>
                {
                    type Item = SocketCred;

                    fn next(&mut self) -> Option<SocketCred>
                    {
                        Some(SocketCred(self.0.next()?))
                    }
                }
                /// The error type which is returned from parsing the type a control message.
                #[non_exhaustive] #[derive(Debug)]
                pub enum AncillaryError
                {
                    Unknown { cmsg_level: i32, cmsg_type: i32 },
                }
                /// This enum represent one control message of variable type.
                pub enum AncillaryData<'a>
                {
                    ScmRights(ScmRights<'a>),
                    ScmCredentials(ScmCredentials<'a>),
                }

                impl<'a> AncillaryData<'a>
                {
                    /// Creates an `AncillaryData::ScmRights` variant.
                    unsafe fn as_rights(data: &'a [u8]) -> Self
                    {
                        let ancillary_data_iter = AncillaryDataIter::new(data);
                        let scm_rights = ScmRights(ancillary_data_iter);
                        AncillaryData::ScmRights(scm_rights)
                    }

                    /// Creates an `AncillaryData::ScmCredentials` variant.
                    unsafe fn as_credentials(data: &'a [u8]) -> Self
                    {
                        let ancillary_data_iter = AncillaryDataIter::new(data);
                        let scm_credentials = ScmCredentials(ancillary_data_iter);
                        AncillaryData::ScmCredentials(scm_credentials)
                    }

                    fn try_from_cmsghdr(cmsg: &'a libc::cmsghdr) -> Result<Self, AncillaryError>
                    {
                        unsafe
                        {
                            let cmsg_len_zero = libc::CMSG_LEN(0) as usize;
                            let data_len = (*cmsg).cmsg_len as usize - cmsg_len_zero;
                            let data = libc::CMSG_DATA(cmsg).cast();
                            let data = from_raw_parts(data, data_len);

                            match (*cmsg).cmsg_level
                            {
                                libc::SOL_SOCKET => match (*cmsg).cmsg_type
                                {
                                    libc::SCM_RIGHTS => Ok(AncillaryData::as_rights(data)),
                                    libc::SCM_CREDENTIALS => Ok(AncillaryData::as_credentials(data)),
                                    cmsg_type =>
                                    {
                                        Err(AncillaryError::Unknown { cmsg_level: libc::SOL_SOCKET, cmsg_type })
                                    }
                                },
                                
                                cmsg_level => 
                                {
                                    Err(AncillaryError::Unknown { cmsg_level, cmsg_type: (*cmsg).cmsg_type })
                                }
                            }
                        }
                    }
                }
                /// This struct is used to iterate through the control messages.
                #[must_use = "iterators are lazy and do nothing unless consumed"]
                pub struct Messages<'a>
                {
                    buffer: &'a [u8],
                    current: Option<&'a libc::cmsghdr>,
                }
                
                impl<'a> Iterator for Messages<'a>
                {
                    type Item = Result<AncillaryData<'a>, AncillaryError>;

                    fn next(&mut self) -> Option<Self::Item>
                    {
                        unsafe
                        {
                            let mut msg: libc::msghdr = zeroed();
                            msg.msg_control = self.buffer.as_ptr() as *mut _;
                            msg.msg_controllen = self.buffer.len() as _;

                            let cmsg = if let Some(current) = self.current
                            {
                                libc::CMSG_NXTHDR(&msg, current)
                            }
                            else { libc::CMSG_FIRSTHDR(&msg) };

                            let cmsg = cmsg.as_ref()?;
                            
                            if let Some(current) = self.current
                            {
                                if eq(current, cmsg) { return None; }
                            }

                            self.current = Some(cmsg);
                            let ancillary_result = AncillaryData::try_from_cmsghdr(cmsg);
                            Some(ancillary_result)
                        }
                    }
                }
                /// A Unix socket Ancillary data struct.
                #[derive(Debug)]
                pub struct SocketAncillary<'a>
                {
                    buffer: &'a mut [u8],
                    length: usize,
                    truncated: bool,
                }

                impl<'a> SocketAncillary<'a>
                {
                    /// Creates an ancillary data with the given buffer.
                    pub fn new(buffer: &'a mut [u8]) -> Self
                    {
                        SocketAncillary { buffer, length: 0, truncated: false }
                    }

                    /// Returns the capacity of the buffer.
                    #[must_use] pub fn capacity(&self) -> usize
                    {
                        self.buffer.len()
                    }
                    /// Returns `true` if the ancillary data is empty.
                    #[must_use] pub fn is_empty(&self) -> bool
                    {
                        self.length == 0
                    }
                    /// Returns the number of used bytes.
                    #[must_use] pub fn len(&self) -> usize
                    {
                        self.length
                    }
                    /// Returns the iterator of the control messages.
                    pub fn messages(&self) -> Messages<'_>
                    {
                        Messages { buffer: &self.buffer[..self.length], current: None }
                    }
                    /// Is `true` if during a recv operation the ancillary was truncated.
                    #[must_use]
                    pub fn truncated(&self) -> bool
                    {
                        self.truncated
                    }
                    /// Add file descriptors to the ancillary data.
                    pub fn add_fds(&mut self, fds: &[RawFd]) -> bool
                    {
                        self.truncated = false;
                        add_to_ancillary_data(
                            &mut self.buffer,
                            &mut self.length,
                            fds,
                            libc::SOL_SOCKET,
                            libc::SCM_RIGHTS,
                        )
                    }
                    /// Add credentials to the ancillary data.
                    pub fn add_creds(&mut self, creds: &[SocketCred]) -> bool
                    {
                        self.truncated = false;
                        add_to_ancillary_data
                        (
                            &mut self.buffer,
                            &mut self.length,
                            creds,
                            libc::SOL_SOCKET,
                        )
                    }
                    /// Clears the ancillary data, removing all values.
                    pub fn clear(&mut self)
                    {
                        self.length = 0;
                        self.truncated = false;
                    }
                }
            } pub use self::ancillary::*;

            pub mod datagram
            {
                use ::
                {
                    io::{IoSlice, IoSliceMut},
                    net::Shutdown,
                    os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd},
                    path::Path,
                    sealed::Sealed,
                    sys::cvt,
                    sys::net::Socket,
                    sys::common::{AsInner, FromInner, IntoInner},
                    time::Duration
                    ,
                    *,
                };
                #[cfg(any(
                    target_os = "linux",
                    target_os = "android",
                    target_os = "dragonfly",
                    target_os = "freebsd",
                    target_os = "openbsd",
                    target_os = "netbsd",
                    target_os = "solaris",
                    target_os = "illumos",
                    target_os = "haiku",
                    target_os = "nto",
                    target_os = "cygwin"
                ))]
                use libc::MSG_NOSIGNAL;
                
                use super::{ sockaddr_un, SocketAddr, SocketAncillary, recv_vectored_with_ancillary_from, send_vectored_with_ancillary_to};
                /// A Unix datagram socket.
                pub struct UnixDatagram(Socket);
                /// Allows extension traits within `std`.                
                impl Sealed for UnixDatagram {}
                
                impl fmt::Debug for UnixDatagram
                {
                    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result
                    {
                        let mut builder = fmt.debug_struct("UnixDatagram");
                        builder.field("fd", self.0.as_inner());
                        if let Ok(addr) = self.local_addr() {
                            builder.field("local", &addr);
                        }
                        if let Ok(addr) = self.peer_addr() {
                            builder.field("peer", &addr);
                        }
                        builder.finish()
                    }
                }

                impl UnixDatagram 
                {
                    /// Creates a Unix datagram socket bound to the given path.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// let sock = match UnixDatagram::bind("/path/to/the/socket") {
                    ///     Ok(sock) => sock,
                    ///     Err(e) => {
                    ///         println!("Couldn't bind: {e:?}");
                    ///         return
                    ///     }
                    /// };
                    /// ```
                    
                    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {
                        unsafe {
                            let socket = UnixDatagram::unbound()?;
                            let (addr, len) = sockaddr_un(path.as_ref())?;

                            cvt(libc::bind(socket.as_raw_fd(), (&raw const addr) as *const _, len as _))?;

                            Ok(socket)
                        }
                    }

                    /// Creates a Unix datagram socket bound to an address.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::{UnixDatagram};
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock1 = UnixDatagram::bind("path/to/socket")?;
                    ///     let addr = sock1.local_addr()?;
                    ///
                    ///     let sock2 = match UnixDatagram::bind_addr(&addr) {
                    ///         Ok(sock) => sock,
                    ///         Err(err) => {
                    ///             println!("Couldn't bind: {err:?}");
                    ///             return Err(err);
                    ///         }
                    ///     };
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn bind_addr(socket_addr: &SocketAddr) -> io::Result<UnixDatagram> {
                        unsafe {
                            let socket = UnixDatagram::unbound()?;
                            cvt(libc::bind(
                                socket.as_raw_fd(),
                                (&raw const socket_addr.addr) as *const _,
                                socket_addr.len as _,
                            ))?;
                            Ok(socket)
                        }
                    }

                    /// Creates a Unix Datagram socket which is not bound to any address.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// let sock = match UnixDatagram::unbound() {
                    ///     Ok(sock) => sock,
                    ///     Err(e) => {
                    ///         println!("Couldn't unbound: {e:?}");
                    ///         return
                    ///     }
                    /// };
                    /// ```
                    
                    pub fn unbound() -> io::Result<UnixDatagram> {
                        let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;
                        Ok(UnixDatagram(inner))
                    }

                    /// Creates an unnamed pair of connected sockets.
                    ///
                    /// Returns two `UnixDatagrams`s which are connected to each other.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// let (sock1, sock2) = match UnixDatagram::pair() {
                    ///     Ok((sock1, sock2)) => (sock1, sock2),
                    ///     Err(e) => {
                    ///         println!("Couldn't unbound: {e:?}");
                    ///         return
                    ///     }
                    /// };
                    /// ```
                    
                    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {
                        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;
                        Ok((UnixDatagram(i1), UnixDatagram(i2)))
                    }

                    /// Connects the socket to the specified path address.
                    ///
                    /// The [`send`] method may be used to send data to the specified address.
                    /// [`recv`] and [`recv_from`] will only receive data from that address.
                    ///
                    /// [`send`]: UnixDatagram::send
                    /// [`recv`]: UnixDatagram::recv
                    /// [`recv_from`]: UnixDatagram::recv_from
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     match sock.connect("/path/to/the/socket") {
                    ///         Ok(sock) => sock,
                    ///         Err(e) => {
                    ///             println!("Couldn't connect: {e:?}");
                    ///             return Err(e)
                    ///         }
                    ///     };
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
                        unsafe {
                            let (addr, len) = sockaddr_un(path.as_ref())?;

                            cvt(libc::connect(self.as_raw_fd(), (&raw const addr) as *const _, len))?;
                        }
                        Ok(())
                    }

                    /// Connects the socket to an address.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::{UnixDatagram};
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let bound = UnixDatagram::bind("/path/to/socket")?;
                    ///     let addr = bound.local_addr()?;
                    ///
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     match sock.connect_addr(&addr) {
                    ///         Ok(sock) => sock,
                    ///         Err(e) => {
                    ///             println!("Couldn't connect: {e:?}");
                    ///             return Err(e)
                    ///         }
                    ///     };
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn connect_addr(&self, socket_addr: &SocketAddr) -> io::Result<()> {
                        unsafe {
                            cvt(libc::connect(
                                self.as_raw_fd(),
                                (&raw const socket_addr.addr) as *const _,
                                socket_addr.len,
                            ))?;
                        }
                        Ok(())
                    }

                    /// Creates a new independently owned handle to the underlying socket.
                    ///
                    /// The returned `UnixDatagram` is a reference to the same socket that this
                    /// object references. Both handles can be used to accept incoming
                    /// connections and options set on one side will affect the other.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::bind("/path/to/the/socket")?;
                    ///     let sock_copy = sock.try_clone().expect("try_clone failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn try_clone(&self) -> io::Result<UnixDatagram> {
                        self.0.duplicate().map(UnixDatagram)
                    }

                    /// Returns the address of this socket.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::bind("/path/to/the/socket")?;
                    ///     let addr = sock.local_addr().expect("Couldn't get local address");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn local_addr(&self) -> io::Result<SocketAddr> {
                        SocketAddr::new(|addr, len| unsafe { libc::getsockname(self.as_raw_fd(), addr, len) })
                    }

                    /// Returns the address of this socket's peer.
                    ///
                    /// The [`connect`] method will connect the socket to a peer.
                    ///
                    /// [`connect`]: UnixDatagram::connect
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.connect("/path/to/the/socket")?;
                    ///
                    ///     let addr = sock.peer_addr().expect("Couldn't get peer address");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
                        SocketAddr::new(|addr, len| unsafe { libc::getpeername(self.as_raw_fd(), addr, len) })
                    }

                    fn recv_from_flags(
                        &self,
                        buf: &mut [u8],
                        flags: core::ffi::c_int,
                    ) -> io::Result<(usize, SocketAddr)> {
                        let mut count = 0;
                        let addr = SocketAddr::new(|addr, len| unsafe {
                            count = libc::recvfrom(
                                self.as_raw_fd(),
                                buf.as_mut_ptr() as *mut _,
                                buf.len(),
                                flags,
                                addr,
                                len,
                            );
                            if count > 0 {
                                1
                            } else if count == 0 {
                                0
                            } else {
                                -1
                            }
                        })?;

                        Ok((count as usize, addr))
                    }

                    /// Receives data from the socket.
                    ///
                    /// On success, returns the number of bytes read and the address from
                    /// whence the data came.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     let mut buf = vec![0; 10];
                    ///     let (size, sender) = sock.recv_from(buf.as_mut_slice())?;
                    ///     println!("received {size} bytes from {sender:?}");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
                        self.recv_from_flags(buf, 0)
                    }

                    /// Receives data from the socket.
                    ///
                    /// On success, returns the number of bytes read.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::bind("/path/to/the/socket")?;
                    ///     let mut buf = vec![0; 10];
                    ///     sock.recv(buf.as_mut_slice()).expect("recv function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {
                        self.0.read(buf)
                    }

                    /// Receives data and ancillary data from socket.
                    ///
                    /// On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.
                    ///
                    /// # Examples
                    ///
                    #[cfg_attr(any(target_os = "android", target_os = "linux"), doc = "```no_run")]
                    #[cfg_attr(not(any(target_os = "android", target_os = "linux")), doc = "```ignore")]
                    /// #![feature(unix_socket_ancillary_data)]
                    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};
                    /// use std::io::IoSliceMut;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     let mut buf1 = [1; 8];
                    ///     let mut buf2 = [2; 16];
                    ///     let mut buf3 = [3; 8];
                    ///     let mut bufs = &mut [
                    ///         IoSliceMut::new(&mut buf1),
                    ///         IoSliceMut::new(&mut buf2),
                    ///         IoSliceMut::new(&mut buf3),
                    ///     ][..];
                    ///     let mut fds = [0; 8];
                    ///     let mut ancillary_buffer = [0; 128];
                    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);
                    ///     let (size, _truncated, sender) = sock.recv_vectored_with_ancillary_from(bufs, &mut ancillary)?;
                    ///     println!("received {size}");
                    ///     for ancillary_result in ancillary.messages() {
                    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {
                    ///             for fd in scm_rights {
                    ///                 println!("receive file descriptor: {fd}");
                    ///             }
                    ///         }
                    ///     }
                    ///     Ok(())
                    /// }
                    /// ```
                    #[cfg(any(doc, target_os = "android", target_os = "linux"))]
                    
                    pub fn recv_vectored_with_ancillary_from(
                        &self,
                        bufs: &mut [IoSliceMut<'_>],
                        ancillary: &mut SocketAncillary<'_>,
                    ) -> io::Result<(usize, bool, SocketAddr)> {
                        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;
                        let addr = addr?;

                        Ok((count, truncated, addr))
                    }

                    /// Receives data and ancillary data from socket.
                    ///
                    /// On success, returns the number of bytes read and if the data was truncated.
                    ///
                    /// # Examples
                    ///
                    #[cfg_attr(any(target_os = "android", target_os = "linux"), doc = "```no_run")]
                    #[cfg_attr(not(any(target_os = "android", target_os = "linux")), doc = "```ignore")]
                    /// #![feature(unix_socket_ancillary_data)]
                    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};
                    /// use std::io::IoSliceMut;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     let mut buf1 = [1; 8];
                    ///     let mut buf2 = [2; 16];
                    ///     let mut buf3 = [3; 8];
                    ///     let mut bufs = &mut [
                    ///         IoSliceMut::new(&mut buf1),
                    ///         IoSliceMut::new(&mut buf2),
                    ///         IoSliceMut::new(&mut buf3),
                    ///     ][..];
                    ///     let mut fds = [0; 8];
                    ///     let mut ancillary_buffer = [0; 128];
                    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);
                    ///     let (size, _truncated) = sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;
                    ///     println!("received {size}");
                    ///     for ancillary_result in ancillary.messages() {
                    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {
                    ///             for fd in scm_rights {
                    ///                 println!("receive file descriptor: {fd}");
                    ///             }
                    ///         }
                    ///     }
                    ///     Ok(())
                    /// }
                    /// ```
                    #[cfg(any(doc, target_os = "android", target_os = "linux"))]
                    
                    pub fn recv_vectored_with_ancillary(
                        &self,
                        bufs: &mut [IoSliceMut<'_>],
                        ancillary: &mut SocketAncillary<'_>,
                    ) -> io::Result<(usize, bool)> {
                        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;
                        addr?;

                        Ok((count, truncated))
                    }

                    /// Sends data on the socket to the specified address.
                    ///
                    /// On success, returns the number of bytes written.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.send_to(b"omelette au fromage", "/some/sock").expect("send_to function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {
                        unsafe {
                            let (addr, len) = sockaddr_un(path.as_ref())?;

                            let count = cvt(libc::sendto(
                                self.as_raw_fd(),
                                buf.as_ptr() as *const _,
                                buf.len(),
                                MSG_NOSIGNAL,
                                (&raw const addr) as *const _,
                                len,
                            ))?;
                            Ok(count as usize)
                        }
                    }

                    /// Sends data on the socket to the specified [SocketAddr].
                    ///
                    /// On success, returns the number of bytes written.
                    ///
                    /// [SocketAddr]: crate::os::unix::net::SocketAddr
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::{UnixDatagram};
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let bound = UnixDatagram::bind("/path/to/socket")?;
                    ///     let addr = bound.local_addr()?;
                    ///
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.send_to_addr(b"bacon egg and cheese", &addr).expect("send_to_addr function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn send_to_addr(&self, buf: &[u8], socket_addr: &SocketAddr) -> io::Result<usize> {
                        unsafe {
                            let count = cvt(libc::sendto(
                                self.as_raw_fd(),
                                buf.as_ptr() as *const _,
                                buf.len(),
                                MSG_NOSIGNAL,
                                (&raw const socket_addr.addr) as *const _,
                                socket_addr.len,
                            ))?;
                            Ok(count as usize)
                        }
                    }

                    /// Sends data on the socket to the socket's peer.
                    ///
                    /// The peer address may be set by the `connect` method, and this method
                    /// will return an error if the socket has not already been connected.
                    ///
                    /// On success, returns the number of bytes written.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.connect("/some/sock").expect("Couldn't connect");
                    ///     sock.send(b"omelette au fromage").expect("send_to function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {
                        self.0.write(buf)
                    }

                    /// Sends data and ancillary data on the socket to the specified address.
                    ///
                    /// On success, returns the number of bytes written.
                    ///
                    /// # Examples
                    ///
                    #[cfg_attr(any(target_os = "android", target_os = "linux"), doc = "```no_run")]
                    #[cfg_attr(not(any(target_os = "android", target_os = "linux")), doc = "```ignore")]
                    /// #![feature(unix_socket_ancillary_data)]
                    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};
                    /// use std::io::IoSlice;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     let buf1 = [1; 8];
                    ///     let buf2 = [2; 16];
                    ///     let buf3 = [3; 8];
                    ///     let bufs = &[
                    ///         IoSlice::new(&buf1),
                    ///         IoSlice::new(&buf2),
                    ///         IoSlice::new(&buf3),
                    ///     ][..];
                    ///     let fds = [0, 1, 2];
                    ///     let mut ancillary_buffer = [0; 128];
                    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);
                    ///     ancillary.add_fds(&fds[..]);
                    ///     sock.send_vectored_with_ancillary_to(bufs, &mut ancillary, "/some/sock")
                    ///         .expect("send_vectored_with_ancillary_to function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    #[cfg(any(doc, target_os = "android", target_os = "linux"))]
                    
                    pub fn send_vectored_with_ancillary_to<P: AsRef<Path>>(
                        &self,
                        bufs: &[IoSlice<'_>],
                        ancillary: &mut SocketAncillary<'_>,
                        path: P,
                    ) -> io::Result<usize> {
                        send_vectored_with_ancillary_to(&self.0, Some(path.as_ref()), bufs, ancillary)
                    }

                    /// Sends data and ancillary data on the socket.
                    ///
                    /// On success, returns the number of bytes written.
                    ///
                    /// # Examples
                    ///
                    #[cfg_attr(any(target_os = "android", target_os = "linux"), doc = "```no_run")]
                    #[cfg_attr(not(any(target_os = "android", target_os = "linux")), doc = "```ignore")]
                    /// #![feature(unix_socket_ancillary_data)]
                    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};
                    /// use std::io::IoSlice;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     let buf1 = [1; 8];
                    ///     let buf2 = [2; 16];
                    ///     let buf3 = [3; 8];
                    ///     let bufs = &[
                    ///         IoSlice::new(&buf1),
                    ///         IoSlice::new(&buf2),
                    ///         IoSlice::new(&buf3),
                    ///     ][..];
                    ///     let fds = [0, 1, 2];
                    ///     let mut ancillary_buffer = [0; 128];
                    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);
                    ///     ancillary.add_fds(&fds[..]);
                    ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary)
                    ///         .expect("send_vectored_with_ancillary function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    #[cfg(any(doc, target_os = "android", target_os = "linux"))]
                    
                    pub fn send_vectored_with_ancillary(
                        &self,
                        bufs: &[IoSlice<'_>],
                        ancillary: &mut SocketAncillary<'_>,
                    ) -> io::Result<usize> {
                        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)
                    }

                    /// Sets the read timeout for the socket.
                    ///
                    /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will
                    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]
                    /// is passed to this method.
                    ///
                    /// [`recv`]: UnixDatagram::recv
                    /// [`recv_from`]: UnixDatagram::recv_from
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use std::os::unix::net::UnixDatagram;
                    /// use std::time::Duration;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))
                    ///         .expect("set_read_timeout function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    ///
                    /// An [`Err`] is returned if the zero [`Duration`] is passed to this
                    /// method:
                    ///
                    /// ```no_run
                    /// use std::io;
                    /// use std::os::unix::net::UnixDatagram;
                    /// use std::time::Duration;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let socket = UnixDatagram::unbound()?;
                    ///     let result = socket.set_read_timeout(Some(Duration::new(0, 0)));
                    ///     let err = result.unwrap_err();
                    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
                        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)
                    }

                    /// Sets the write timeout for the socket.
                    ///
                    /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will
                    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this
                    /// method.
                    ///
                    /// [`send`]: UnixDatagram::send
                    /// [`send_to`]: UnixDatagram::send_to
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use std::os::unix::net::UnixDatagram;
                    /// use std::time::Duration;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))
                    ///         .expect("set_write_timeout function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    ///
                    /// An [`Err`] is returned if the zero [`Duration`] is passed to this
                    /// method:
                    ///
                    /// ```no_run
                    /// use std::io;
                    /// use std::os::unix::net::UnixDatagram;
                    /// use std::time::Duration;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let socket = UnixDatagram::unbound()?;
                    ///     let result = socket.set_write_timeout(Some(Duration::new(0, 0)));
                    ///     let err = result.unwrap_err();
                    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
                        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)
                    }

                    /// Returns the read timeout of this socket.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use std::os::unix::net::UnixDatagram;
                    /// use std::time::Duration;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))
                    ///         .expect("set_read_timeout function failed");
                    ///     assert_eq!(sock.read_timeout()?, Some(Duration::new(1, 0)));
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
                        self.0.timeout(libc::SO_RCVTIMEO)
                    }

                    /// Returns the write timeout of this socket.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use std::os::unix::net::UnixDatagram;
                    /// use std::time::Duration;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))
                    ///         .expect("set_write_timeout function failed");
                    ///     assert_eq!(sock.write_timeout()?, Some(Duration::new(1, 0)));
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
                        self.0.timeout(libc::SO_SNDTIMEO)
                    }

                    /// Moves the socket into or out of nonblocking mode.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.set_nonblocking(true).expect("set_nonblocking function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
                        self.0.set_nonblocking(nonblocking)
                    }

                    /// Set the id of the socket for network filtering purpose
                    ///
                    #[cfg_attr(
                        any(target_os = "linux", target_os = "freebsd", target_os = "openbsd"),
                        doc = "```no_run"
                    )]
                    #[cfg_attr(
                        not(any(target_os = "linux", target_os = "freebsd", target_os = "openbsd")),
                        doc = "```ignore"
                    )]
                    /// #![feature(unix_set_mark)]
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.set_mark(32)?;
                    ///     Ok(())
                    /// }
                    /// ```
                    #[cfg(any(doc, target_os = "linux", target_os = "freebsd", target_os = "openbsd",))]
                    
                    pub fn set_mark(&self, mark: u32) -> io::Result<()> {
                        self.0.set_mark(mark)
                    }

                    /// Returns the value of the `SO_ERROR` option.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     if let Ok(Some(err)) = sock.take_error() {
                    ///         println!("Got error: {err:?}");
                    ///     }
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
                        self.0.take_error()
                    }

                    /// Shut down the read, write, or both halves of this connection.
                    ///
                    /// This function will cause all pending and future I/O calls on the
                    /// specified portions to immediately return with an appropriate value
                    /// (see the documentation of [`Shutdown`]).
                    ///
                    /// ```no_run
                    /// use std::os::unix::net::UnixDatagram;
                    /// use std::net::Shutdown;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let sock = UnixDatagram::unbound()?;
                    ///     sock.shutdown(Shutdown::Both).expect("shutdown function failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
                        self.0.shutdown(how)
                    }

                    /// Receives data on the socket from the remote address to which it is
                    /// connected, without removing that data from the queue. On success,
                    /// returns the number of bytes peeked.
                    ///
                    /// Successive calls return the same data. This is accomplished by passing
                    /// `MSG_PEEK` as a flag to the underlying `recv` system call.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// #![feature(unix_socket_peek)]
                    ///
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let socket = UnixDatagram::bind("/tmp/sock")?;
                    ///     let mut buf = [0; 10];
                    ///     let len = socket.peek(&mut buf).expect("peek failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
                        self.0.peek(buf)
                    }

                    /// Receives a single datagram message on the socket, without removing it from the
                    /// queue. On success, returns the number of bytes read and the origin.
                    ///
                    /// The function must be called with valid byte array `buf` of sufficient size to
                    /// hold the message bytes. If a message is too long to fit in the supplied buffer,
                    /// excess bytes may be discarded.
                    ///
                    /// Successive calls return the same data. This is accomplished by passing
                    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.
                    ///
                    /// Do not use this function to implement busy waiting, instead use `libc::poll` to
                    /// synchronize IO events on one or more sockets.
                    ///
                    /// # Examples
                    ///
                    /// ```no_run
                    /// #![feature(unix_socket_peek)]
                    ///
                    /// use std::os::unix::net::UnixDatagram;
                    ///
                    /// fn main() -> std::io::Result<()> {
                    ///     let socket = UnixDatagram::bind("/tmp/sock")?;
                    ///     let mut buf = [0; 10];
                    ///     let (len, addr) = socket.peek_from(&mut buf).expect("peek failed");
                    ///     Ok(())
                    /// }
                    /// ```
                    
                    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
                        self.recv_from_flags(buf, libc::MSG_PEEK)
                    }
                }
                
                impl AsRawFd for UnixDatagram 
                {
                    #[inline] fn as_raw_fd(&self) -> RawFd 
                    {
                        self.0.as_inner().as_raw_fd()
                    }
                }
                
                impl FromRawFd for UnixDatagram 
                {
                    #[inline] unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram 
                    {
                        UnixDatagram(Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd))))
                    }
                }
                
                impl IntoRawFd for UnixDatagram 
                {
                    #[inline] fn into_raw_fd(self) -> RawFd 
                    {
                        self.0.into_inner().into_inner().into_raw_fd()
                    }
                }
                
                impl AsFd for UnixDatagram 
                {
                    #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                    {
                        self.0.as_inner().as_fd()
                    }
                }
                
                impl From<UnixDatagram> for OwnedFd 
                {
                    /// Takes ownership of a [`UnixDatagram`]'s socket file descriptor.
                    #[inline] fn from(unix_datagram: UnixDatagram) -> OwnedFd 
                    {
                        unsafe { OwnedFd::from_raw_fd(unix_datagram.into_raw_fd()) }
                    }
                }
                
                impl From<OwnedFd> for UnixDatagram 
                {
                    #[inline] fn from(owned: OwnedFd) -> Self 
                    {
                        unsafe { Self::from_raw_fd(owned.into_raw_fd()) }
                    }
                }

                impl AsInner<Socket> for UnixDatagram 
                {
                    #[inline] fn as_inner(&self) -> &Socket 
                    {
                        &self.0
                    }
                }
            } pub use self::datagram::*;

            pub mod listener
            {
                use ::
                {
                    os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd},
                    path::Path,
                    sys::cvt,
                    sys::net::Socket,
                    sys::common::{AsInner, FromInner, IntoInner},
                    *,
                };

                use super::{SocketAddr, UnixStream, sockaddr_un};
                /// A structure representing a Unix domain socket server.
                pub struct UnixListener(Socket);

                
                impl fmt::Debug for UnixListener 
                {
                    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result 
                    {
                        let mut builder = fmt.debug_struct("UnixListener");
                        builder.field("fd", self.0.as_inner());
                        if let Ok(addr) = self.local_addr() {
                            builder.field("local", &addr);
                        }
                        builder.finish()
                    }
                }

                impl UnixListener 
                {
                    /// Creates a new `UnixListener` bound to the specified socket.                    
                    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> 
                    {
                        unsafe 
                        {
                            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;
                            let (addr, len) = sockaddr_un(path.as_ref())?;
                            #[cfg(any(
                                target_os = "windows",
                                target_os = "redox",
                                target_os = "espidf",
                                target_os = "horizon"
                            ))]
                            const backlog: core::ffi::c_int = 128;
                            #[cfg(any(
                                target_os = "linux",
                                target_os = "freebsd",
                                target_os = "openbsd",
                                target_vendor = "apple",
                            ))]
                            const backlog: core::ffi::c_int = -1;

                            cvt(libc::bind(inner.as_inner().as_raw_fd(), (&raw const addr) as *const _, len as _))?;
                            cvt(libc::listen(inner.as_inner().as_raw_fd(), backlog))?;

                            Ok(UnixListener(inner))
                        }
                    }

                    /// Creates a new `UnixListener` bound to the specified [`socket address`].
                    
                    pub fn bind_addr(socket_addr: &SocketAddr) -> io::Result<UnixListener> 
                    {
                        unsafe {
                            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;
                            #[cfg(target_os = "linux")]
                            const backlog: core::ffi::c_int = -1;
                            #[cfg(not(target_os = "linux"))]
                            const backlog: core::ffi::c_int = 128;
                            cvt(libc::bind(
                                inner.as_raw_fd(),
                                (&raw const socket_addr.addr) as *const _,
                                socket_addr.len as _,
                            ))?;
                            cvt(libc::listen(inner.as_raw_fd(), backlog))?;
                            Ok(UnixListener(inner))
                        }
                    }

                    /// Accepts a new incoming connection to this listener.
                    
                    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> 
                    {
                        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };
                        let mut len = size_of_val(&storage) as libc::socklen_t;
                        let sock = self.0.accept((&raw mut storage) as *mut _, &mut len)?;
                        let addr = SocketAddr::from_parts(storage, len)?;
                        Ok((UnixStream(sock), addr))
                    }

                    /// Creates a new independently owned handle to the underlying socket.
                    
                    pub fn try_clone(&self) -> io::Result<UnixListener> 
                    {
                        self.0.duplicate().map(UnixListener)
                    }

                    /// Returns the local socket address of this listener.
                    
                    pub fn local_addr(&self) -> io::Result<SocketAddr> 
                    {
                        SocketAddr::new(|addr, len| unsafe { libc::getsockname(self.as_raw_fd(), addr, len) })
                    }

                    /// Moves the socket into or out of nonblocking mode.
                    
                    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> 
                    {
                        self.0.set_nonblocking(nonblocking)
                    }

                    /// Returns the value of the `SO_ERROR` option.
                    /// # Platform specific
                    /// On Redox this always returns `None`.
                    
                    pub fn take_error(&self) -> io::Result<Option<io::Error>> 
                    {
                        self.0.take_error()
                    }

                    /// Returns an iterator over incoming connections.
                    
                    pub fn incoming(&self) -> Incoming<'_> 
                    {
                        Incoming { listener: self }
                    }
                }

                
                impl AsRawFd for UnixListener 
                {
                    #[inline] fn as_raw_fd(&self) -> RawFd 
                    {
                        self.0.as_inner().as_raw_fd()
                    }
                }

                
                impl FromRawFd for UnixListener 
                {
                    #[inline] unsafe fn from_raw_fd(fd: RawFd) -> UnixListener 
                    {
                        UnixListener(Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd))))
                    }
                }

                
                impl IntoRawFd for UnixListener 
                {
                    #[inline] fn into_raw_fd(self) -> RawFd 
                    {
                        self.0.into_inner().into_inner().into_raw_fd()
                    }
                }

                
                impl AsFd for UnixListener 
                {
                    #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                    {
                        self.0.as_inner().as_fd()
                    }
                }

                
                impl From<OwnedFd> for UnixListener 
                {
                    #[inline] fn from(fd: OwnedFd) -> UnixListener 
                    {
                        UnixListener(Socket::from_inner(FromInner::from_inner(fd)))
                    }
                }

                
                impl From<UnixListener> for OwnedFd 
                {
                    /// Takes ownership of a [`UnixListener`]'s socket file descriptor.
                    #[inline] fn from(listener: UnixListener) -> OwnedFd 
                    {
                        listener.0.into_inner().into_inner()
                    }
                }
                
                impl<'a> IntoIterator for &'a UnixListener 
                {
                    type Item = io::Result<UnixStream>;
                    type IntoIter = Incoming<'a>;

                    fn into_iter(self) -> Incoming<'a> 
                    {
                        self.incoming()
                    }
                }

                /// An iterator over incoming connections to a [`UnixListener`].
                #[derive(Debug)]
                #[must_use = "iterators are lazy and do nothing unless consumed"]
                
                pub struct Incoming<'a> 
                {
                    listener: &'a UnixListener,
                }
                
                impl<'a> Iterator for Incoming<'a> 
                {
                    type Item = io::Result<UnixStream>;

                    fn next(&mut self) -> Option<io::Result<UnixStream>> 
                    {
                        Some(self.listener.accept().map(|s| s.0))
                    }

                    fn size_hint(&self) -> (usize, Option<usize>) 
                    {
                        (usize::MAX, None)
                    }
                }
            } pub use self::listener::*;

            pub mod stream
            {
                use ::
                {
                    fmt,
                    io::{self, IoSlice, IoSliceMut},
                    net::Shutdown,
                    os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd},
                    path::Path,
                    sealed::Sealed,
                    sys::cvt,
                    sys::net::Socket,
                    sys_common::{AsInner, FromInner},
                    time::Duration,
                    *,
                };

                use super::
                {
                    SocketAddr, sockaddr_un, SocketAncillary, recv_vectored_with_ancillary_from, 
                    send_vectored_with_ancillary_to, UCred, peer_cred
                };
                /// A Unix stream socket.
                pub struct UnixStream(pub(super) Socket);

                /// Allows extension traits within `std`.
                impl Sealed for UnixStream {}
                
                impl fmt::Debug for UnixStream 
                {
                    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let mut builder = fmt.debug_struct("UnixStream");
                        builder.field("fd", self.0.as_inner());
                        if let Ok(addr) = self.local_addr() {
                            builder.field("local", &addr);
                        }
                        if let Ok(addr) = self.peer_addr() {
                            builder.field("peer", &addr);
                        }
                        builder.finish()
                    }
                }

                impl UnixStream 
                {
                    /// Connects to the socket named by `path`.
                    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {
                        unsafe {
                            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;
                            let (addr, len) = sockaddr_un(path.as_ref())?;

                            cvt(libc::connect(inner.as_raw_fd(), (&raw const addr) as *const _, len))?;
                            Ok(UnixStream(inner))
                        }
                    }

                    /// Connects to the socket specified by [`address`].
                    pub fn connect_addr(socket_addr: &SocketAddr) -> io::Result<UnixStream> {
                        unsafe {
                            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;
                            cvt(libc::connect(
                                inner.as_raw_fd(),
                                (&raw const socket_addr.addr) as *const _,
                                socket_addr.len,
                            ))?;
                            Ok(UnixStream(inner))
                        }
                    }

                    /// Creates an unnamed pair of connected sockets.
                    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {
                        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;
                        Ok((UnixStream(i1), UnixStream(i2)))
                    }

                    /// Creates a new independently owned handle to the underlying socket.
                    pub fn try_clone(&self) -> io::Result<UnixStream> {
                        self.0.duplicate().map(UnixStream)
                    }

                    /// Returns the socket address of the local half of this connection.
                    pub fn local_addr(&self) -> io::Result<SocketAddr> {
                        SocketAddr::new(|addr, len| unsafe { libc::getsockname(self.as_raw_fd(), addr, len) })
                    }

                    /// Returns the socket address of the remote half of this connection.
                    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
                        SocketAddr::new(|addr, len| unsafe { libc::getpeername(self.as_raw_fd(), addr, len) })
                    }

                    /// Gets the peer credentials for this Unix domain socket.
                    pub fn peer_cred(&self) -> io::Result<UCred> {
                        peer_cred(self)
                    }

                    /// Sets the read timeout for the socket.
                    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
                        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)
                    }

                    /// Sets the write timeout for the socket.
                    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
                        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)
                    }

                    /// Returns the read timeout of this socket.
                    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
                        self.0.timeout(libc::SO_RCVTIMEO)
                    }

                    /// Returns the write timeout of this socket.
                    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
                        self.0.timeout(libc::SO_SNDTIMEO)
                    }

                    /// Moves the socket into or out of nonblocking mode.
                    
                    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
                        self.0.set_nonblocking(nonblocking)
                    }

                    /// Set the id of the socket for network filtering purpose.
                    pub fn set_mark(&self, mark: u32) -> io::Result<()> {
                        self.0.set_mark(mark)
                    }

                    /// Returns the value of the `SO_ERROR` option.
                    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
                        self.0.take_error()
                    }

                    /// Shuts down the read, write, or both halves of this connection.
                    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
                        self.0.shutdown(how)
                    }

                    /// Receives data on the socket from the remote address to which it is
                    /// connected, without removing that data from the queue.
                    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
                        self.0.peek(buf)
                    }

                    /// Receives data and ancillary data from socket.
                    pub fn recv_vectored_with_ancillary(
                        &self,
                        bufs: &mut [IoSliceMut<'_>],
                        ancillary: &mut SocketAncillary<'_>,
                    ) -> io::Result<usize> {
                        let (count, _, _) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;

                        Ok(count)
                    }

                    /// Sends data and ancillary data on the socket.
                    pub fn send_vectored_with_ancillary(
                        &self,
                        bufs: &[IoSlice<'_>],
                        ancillary: &mut SocketAncillary<'_>,
                    ) -> io::Result<usize> {
                        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)
                    }
                }

                
                impl io::Read for UnixStream
                {
                    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
                        io::Read::read(&mut &*self, buf)
                    }

                    fn read_buf(&mut self, buf: io::BorrowedCursor<'_>) -> io::Result<()> {
                        io::Read::read_buf(&mut &*self, buf)
                    }

                    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
                        io::Read::read_vectored(&mut &*self, bufs)
                    }

                    #[inline] fn is_read_vectored(&self) -> bool {
                        io::Read::is_read_vectored(&&*self)
                    }
                }
                
                impl<'a> io::Read for &'a UnixStream
                {
                    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
                        self.0.read(buf)
                    }

                    fn read_buf(&mut self, buf: io::BorrowedCursor<'_>) -> io::Result<()> {
                        self.0.read_buf(buf)
                    }

                    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
                        self.0.read_vectored(bufs)
                    }

                    #[inline] fn is_read_vectored(&self) -> bool {
                        self.0.is_read_vectored()
                    }
                }

                
                impl io::Write for UnixStream 
                {
                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
                        io::Write::write(&mut &*self, buf)
                    }

                    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
                        io::Write::write_vectored(&mut &*self, bufs)
                    }

                    #[inline] fn is_write_vectored(&self) -> bool {
                        /*io::Write::is_write_vectored(&&*self) */
                        false
                    }

                    fn flush(&mut self) -> io::Result<()> {
                        io::Write::flush(&mut &*self)
                    }
                }
                
                impl<'a> io::Write for &'a UnixStream 
                {
                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
                        self.0.write(buf)
                    }

                    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
                        self.0.write_vectored(bufs)
                    }

                    #[inline] fn is_write_vectored(&self) -> bool {
                        //self.0.is_write_vectored()
                        false
                    }

                    #[inline] fn flush(&mut self) -> io::Result<()> {
                        Ok(())
                    }
                }

                
                impl AsRawFd for UnixStream 
                {
                    #[inline] fn as_raw_fd(&self) -> RawFd 
                    {
                        self.0.as_raw_fd()
                    }
                }

                
                impl FromRawFd for UnixStream 
                {
                    #[inline] unsafe fn from_raw_fd(fd: RawFd) -> UnixStream 
                    {
                        UnixStream(Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd))))
                    }
                }

                
                impl IntoRawFd for UnixStream 
                {
                    #[inline] fn into_raw_fd(self) -> RawFd 
                    {
                        self.0.into_raw_fd()
                    }
                }

                
                impl AsFd for UnixStream 
                {
                    #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                    {
                        self.0.as_fd()
                    }
                }

                
                impl From<UnixStream> for OwnedFd 
                {
                    /// Takes ownership of a [`UnixStream`]'s socket file descriptor.
                    #[inline] fn from(unix_stream: UnixStream) -> OwnedFd 
                    {
                        unsafe { OwnedFd::from_raw_fd(unix_stream.into_raw_fd()) }
                    }
                }

                
                impl From<OwnedFd> for UnixStream 
                {
                    #[inline] fn from(owned: OwnedFd) -> Self 
                    {
                        unsafe { Self::from_raw_fd(owned.into_raw_fd()) }
                    }
                }

                impl AsInner<Socket> for UnixStream 
                {
                    #[inline] fn as_inner(&self) -> &Socket 
                    {
                        &self.0
                    }
                }
            } pub use self::stream::*;

            pub mod ucred
            {
                use ::
                {
                    libc::{gid_t, pid_t, uid_t},
                    os::unix::io::AsRawFd,
                    os::unix::net::UnixStream,
                    *,
                };
                /// Credentials for a UNIX process for credentials passing.
                #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
                pub struct UCred
                {
                    /// The UID part of the peer credential.
                    pub uid: uid_t,
                    /// The GID part of the peer credential.
                    pub gid: gid_t,
                    /// The PID part of the peer credential.
                    pub pid: Option<pid_t>,
                }
                
                pub fn peer_cred(socket: &UnixStream) -> io::Result<UCred>
                {
                    unsafe
                    {
                        let mut cred = UCred { uid: 1, gid: 1, pid: None };
                        let ret = libc::getpeereid(socket.as_raw_fd(), &mut cred.uid, &mut cred.gid);

                        if ret == 0 { Ok(cred) } else { Err(io::Error::last_os_error()) }
                    }
                }

            } pub use self::ucred::*;
        }

        pub mod process
        {
            //! Unix-specific extensions to primitives in the [`std::process`] module.
            use ::
            {
                ffi::OsStr,
                os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd},
                sealed::Sealed,
                sys_common::{AsInner, AsInnerMut, FromInner, IntoInner},
                *,
            };
            
            type UserId = u32;
            type GroupId = u32;
            /// Unix-specific extensions to the [`process::Command`] builder.
            pub trait CommandExt: Sealed
            {
                /// Sets the child process's user ID.                
                fn uid(&mut self, id: UserId) -> &mut process::Command;
                /// Similar to `uid`, but sets the group ID of the child process.
                fn gid(&mut self, id: GroupId) -> &mut process::Command;
                /// Sets the supplementary group IDs for the calling process.
                fn groups(&mut self, groups: &[GroupId]) -> &mut process::Command;
                /// Schedules a closure to be run just before the `exec` function is invoked.
                unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command where
                F: FnMut() -> io::Result<()> + Send + Sync + 'static;
                /// Schedules a closure to be run just before the `exec` function is invoked.
                unsafe fn before_exec<F>(&mut self, f: F) -> &mut process::Command where
                F: FnMut() -> io::Result<()> + Send + Sync + 'static
                {
                    unsafe { self.pre_exec(f) }
                }
                /// Performs all the required setup by this `Command`, followed by calling the `execvp` syscall.
                #[must_use]
                fn exec(&mut self) -> io::Error;
                /// Set executable argument
                fn arg0<S>(&mut self, arg: S) -> &mut process::Command where S: AsRef<OsStr>;
                /// Sets the process group ID (PGID) of the child process.
                fn process_group(&mut self, pgroup: i32) -> &mut process::Command;
            }

            impl CommandExt for process::Command
            {
                fn uid(&mut self, id: UserId) -> &mut process::Command
                {
                    self.as_inner_mut().uid(id);
                    self
                }

                fn gid(&mut self, id: GroupId) -> &mut process::Command
                {
                    self.as_inner_mut().gid(id);
                    self
                }

                fn groups(&mut self, groups: &[GroupId]) -> &mut process::Command
                {
                    self.as_inner_mut().groups(groups);
                    self
                }

                unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command where
                F: FnMut() -> io::Result<()> + Send + Sync + 'static,
                {
                    self.as_inner_mut().pre_exec(Box::new(f));
                    self
                }

                fn exec(&mut self) -> io::Error
                {
                    self.as_inner_mut().exec(sys::process::Stdio::Inherit)
                }

                fn arg0<S>(&mut self, arg: S) -> &mut process::Command where
                S: AsRef<OsStr>,
                {
                    self.as_inner_mut().set_arg_0(arg.as_ref());
                    self
                }

                fn process_group(&mut self, pgroup: i32) -> &mut process::Command
                {
                    self.as_inner_mut().pgroup(pgroup);
                    self
                }
            }
            /// Unix-specific extensions to [`process::ExitStatus`] and [`ExitStatusError`](process::ExitStatusError).
            pub trait ExitStatusExt: Sealed
            {
                /// Creates a new `ExitStatus` or `ExitStatusError` from the raw underlying integer status value from `wait.    
                fn from_raw(raw: i32) -> Self;
                /// If the process was terminated by a signal, returns that signal.
                fn signal(&self) -> Option<i32>;
                /// If the process was terminated by a signal, says whether it dumped core.
                fn core_dumped(&self) -> bool;
                /// If the process was stopped by a signal, returns that signal.
                fn stopped_signal(&self) -> Option<i32>;
                /// Whether the process was continued from a stopped status.
                fn continued(&self) -> bool;
                /// Returns the underlying raw `wait` status.
                fn into_raw(self) -> i32;
            }
            
            impl ExitStatusExt for process::ExitStatus
            {
                fn from_raw(raw: i32) -> Self 
                {
                    process::ExitStatus::from_inner(From::from(raw))
                }

                fn signal(&self) -> Option<i32> 
                {
                    self.as_inner().signal()
                }

                fn core_dumped(&self) -> bool 
                {
                    self.as_inner().core_dumped()
                }

                fn stopped_signal(&self) -> Option<i32> 
                {
                    self.as_inner().stopped_signal()
                }

                fn continued(&self) -> bool 
                {
                    self.as_inner().continued()
                }

                fn into_raw(self) -> i32 
                {
                    self.as_inner().into_raw().into()
                }
            }
            
            impl ExitStatusExt for process::ExitStatusError
            {
                fn from_raw(raw: i32) -> Self 
                {
                    process::ExitStatus::from_raw(raw)
                    .exit_ok()
                    .expect_err("<ExitStatusError as ExitStatusExt>::from_raw(0) but zero is not an error")
                }

                fn signal(&self) -> Option<i32> 
                {
                    self.into_status().signal()
                }

                fn core_dumped(&self) -> bool 
                {
                    self.into_status().core_dumped()
                }

                fn stopped_signal(&self) -> Option<i32> 
                {
                    self.into_status().stopped_signal()
                }

                fn continued(&self) -> bool 
                {
                    self.into_status().continued()
                }

                fn into_raw(self) -> i32 
                {
                    self.into_status().into_raw()
                }
            }
            
            impl FromRawFd for process::Stdio
            {
                #[inline] unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio
                {
                    let fd = sys::fd::FileDesc::from_raw_fd(fd);
                    let io = sys::process::Stdio::Fd(fd);
                    process::Stdio::from_inner(io)
                }
            }

            impl From<OwnedFd> for process::Stdio
            {
                /// Takes ownership of a file descriptor and returns a [`Stdio`](process::Stdio) that can attach a stream to it.
                #[inline] fn from(fd: OwnedFd) -> process::Stdio
                {
                    let fd = sys::fd::FileDesc::from_inner(fd);
                    let io = sys::process::Stdio::Fd(fd);
                    process::Stdio::from_inner(io)
                }
            }
            
            impl AsRawFd for process::ChildStdin
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    self.as_inner().as_raw_fd()
                }
            }

            impl AsRawFd for process::ChildStdout 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    self.as_inner().as_raw_fd()
                }
            }

            impl AsRawFd for process::ChildStderr 
            {
                #[inline] fn as_raw_fd(&self) -> RawFd 
                {
                    self.as_inner().as_raw_fd()
                }
            }

            impl IntoRawFd for process::ChildStdin 
            {
                #[inline] fn into_raw_fd(self) -> RawFd 
                {
                    self.into_inner().into_inner().into_raw_fd()
                }
            }

            impl IntoRawFd for process::ChildStdout 
            {
                #[inline] fn into_raw_fd(self) -> RawFd 
                {
                    self.into_inner().into_inner().into_raw_fd()
                }
            }

            impl IntoRawFd for process::ChildStderr 
            {
                #[inline] fn into_raw_fd(self) -> RawFd 
                {
                    self.into_inner().into_inner().into_raw_fd()
                }
            }

            impl AsFd for crate::process::ChildStdin 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    self.as_inner().as_fd()
                }
            }

            impl From<crate::process::ChildStdin> for OwnedFd 
            {
                /// Takes ownership of a [`ChildStdin`](crate::process::ChildStdin)'s file descriptor.
                #[inline] fn from(child_stdin: crate::process::ChildStdin) -> OwnedFd 
                {
                    child_stdin.into_inner().into_inner().into_inner()
                }
            }
            /// Creates a `ChildStdin` from the provided `OwnedFd`.
            impl From<OwnedFd> for process::ChildStdin 
            {
                #[inline] fn from(fd: OwnedFd) -> process::ChildStdin 
                {
                    let fd = sys::fd::FileDesc::from_inner(fd);
                    let pipe = sys::pipe::AnonPipe::from_inner(fd);
                    process::ChildStdin::from_inner(pipe)
                }
            }

            impl AsFd for crate::process::ChildStdout 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    self.as_inner().as_fd()
                }
            }

            impl From<crate::process::ChildStdout> for OwnedFd 
            {
                /// Takes ownership of a [`ChildStdout`](crate::process::ChildStdout)'s file descriptor.
                #[inline] fn from(child_stdout: crate::process::ChildStdout) -> OwnedFd 
                {
                    child_stdout.into_inner().into_inner().into_inner()
                }
            }
            /// Creates a `ChildStdout` from the provided `OwnedFd`.
            impl From<OwnedFd> for process::ChildStdout 
            {
                #[inline] fn from(fd: OwnedFd) -> process::ChildStdout 
                {
                    let fd = sys::fd::FileDesc::from_inner(fd);
                    let pipe = sys::pipe::AnonPipe::from_inner(fd);
                    process::ChildStdout::from_inner(pipe)
                }
            }

            impl AsFd for crate::process::ChildStderr 
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> 
                {
                    self.as_inner().as_fd()
                }
            }

            impl From<crate::process::ChildStderr> for OwnedFd 
            {
                /// Takes ownership of a [`ChildStderr`](crate::process::ChildStderr)'s file descriptor.
                #[inline] fn from(child_stderr: crate::process::ChildStderr) -> OwnedFd 
                {
                    child_stderr.into_inner().into_inner().into_inner()
                }
            }
            /// Creates a `ChildStderr` from the provided `OwnedFd`.
            impl From<OwnedFd> for process::ChildStderr 
            {
                #[inline] fn from(fd: OwnedFd) -> process::ChildStderr 
                {
                    let fd = sys::fd::FileDesc::from_inner(fd);
                    let pipe = sys::pipe::AnonPipe::from_inner(fd);
                    process::ChildStderr::from_inner(pipe)
                }
            }
            /// Returns the OS-assigned process identifier associated with this process's parent.
            #[must_use] pub fn parent_id() -> u32 
            {
                crate::sys::os::getppid()
            }
        }

        pub mod raw
        {
            //! Unix-specific primitives available on all unix platforms.
            use ::
            {
                *,
            };
            
            pub use super::platform::raw::pthread_t;
            pub use super::platform::raw::{blkcnt_t, time_t};
            pub use super::platform::raw::{blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t};

            pub type uid_t = u32;
            pub type gid_t = u32;
            pub type pid_t = i32;
        }

        pub mod thread
        {
            //! Unix-specific extensions to primitives in the [`std::thread`] module.
            use ::
            {
                os::unix::raw::pthread_t,
                sys::common::{AsInner, IntoInner},
                thread::JoinHandle,
                *,
            };
            
            pub type RawPthread = pthread_t;

            /// Unix-specific extensions to [`JoinHandle`].
            pub trait JoinHandleExt
            {
                /// Extracts the raw pthread_t without taking ownership
                fn as_pthread_t(&self) -> RawPthread;
                /// Consumes the thread, returning the raw pthread_t.
                fn into_pthread_t(self) -> RawPthread;
            }
            
            impl<T> JoinHandleExt for JoinHandle<T>
            {
                fn as_pthread_t(&self) -> RawPthread { self.as_inner().id() as RawPthread }

                fn into_pthread_t(self) -> RawPthread { self.into_inner().into_id() as RawPthread }
            }
        }
        /// A prelude for conveniently writing platform-specific code.
        pub mod prelude
        {
            pub use super::ffi::{ OsStrExt, OsStringExt };
            pub use super::fs::DirEntryExt;
            pub use super::fs::FileExt;
            pub use super::fs::{ FileTypeExt, MetadataExt, OpenOptionsExt, PermissionsExt };
            pub use super::io::{ AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd };
            pub use super::process::{ CommandExt, ExitStatusExt };
            pub use super::thread::JoinHandleExt;
        }
    }
    
    pub mod windows
    {
        //! Platform-specific extensions to `std` for Windows.
        use ::
        {
            *
        };

        mod platform 
        {
            
        }

        pub mod ffi
        {
            //! Windows-specific extensions to primitives in the [`std::ffi`] module.
            use ::
            {
                ffi::{ OsStr, OsString },
                sealed::Sealed,
                sys::os_str::Buf,
                sys::common::
                {
                    wtf8::{ EncodeWide, Wtf8Buf },
                    AsInner, FromInner,
                },
                *,
            };
            /// Windows-specific extensions to [`OsString`].
            pub trait OsStringExt: Sealed
            {
                /// Creates an `OsString` from a potentially ill-formed UTF-16 slice of 16-bit code units.
                fn from_wide(wide: &[u16]) -> Self;
            }
            
            impl OsStringExt for OsString 
            {
                fn from_wide(wide: &[u16]) -> OsString 
                {
                    FromInner::from_inner(Buf { inner: Wtf8Buf::from_wide(wide) })
                }
            }
            /// Windows-specific extensions to [`OsStr`].
            pub trait OsStrExt: Sealed
            {
                /// Re-encodes an `OsStr` as a wide character sequence, i.e., potentially ill-formed UTF-16.
                fn encode_wide(&self) -> EncodeWide<'_>;
            }
            
            impl OsStrExt for OsStr 
            {
                #[inline] fn encode_wide(&self) -> EncodeWide<'_> 
                {
                    self.as_inner().inner.encode_wide()
                }
            }
        }

        pub mod fs
        {
            //! Windows-specific extensions to primitives in the [`std::fs`] module.
            use ::
            {
                fs::{self, Metadata, OpenOptions},
                path::Path,
                sealed::Sealed,
                sys::common::{AsInner, AsInnerMut, IntoInner},
                time::SystemTime,
                *,
            };
            /// Windows-specific extensions to [`fs::File`].
            pub trait FileExt
            {
                /// Seeks to a given position and reads a number of bytes.
                fn seek_read(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;
                /// Seeks to a given position and writes a number of bytes.
                fn seek_write(&self, buf: &[u8], offset: u64) -> io::Result<usize>;
            }
            
            impl FileExt for fs::File
            {
                fn seek_read(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>
                {
                    self.as_inner().read_at(buf, offset)
                }

                fn seek_write(&self, buf: &[u8], offset: u64) -> io::Result<usize>
                {
                    self.as_inner().write_at(buf, offset)
                }
            }
            /// Windows-specific extensions to [`fs::OpenOptions`].
            pub trait OpenOptionsExt
            {
                /// Overrides the `dwDesiredAccess` argument to the call to [`CreateFile`] with the specified value.
                fn access_mode(&mut self, access: u32) -> &mut Self;
                /// Overrides the `dwShareMode` argument to the call to [`CreateFile`] with the specified value.
                fn share_mode(&mut self, val: u32) -> &mut Self;
                /// Sets extra flags for the `dwFileFlags` argument to the call to
                /// [`CreateFile2`] to the specified value (or combines it with
                /// `attributes` and `security_qos_flags` to set the `dwFlagsAndAttributes`
                /// for [`CreateFile`]).
                fn custom_flags(&mut self, flags: u32) -> &mut Self;
                /// Sets the `dwFileAttributes` argument to the call to [`CreateFile2`] to
                /// the specified value (or combines it with `custom_flags` and
                /// `security_qos_flags` to set the `dwFlagsAndAttributes` for
                /// [`CreateFile`]).
                fn attributes(&mut self, val: u32) -> &mut Self;
                /// Sets the `dwSecurityQosFlags` argument to the call to [`CreateFile2`] to
                /// the specified value (or combines it with `custom_flags` and `attributes`
                /// to set the `dwFlagsAndAttributes` for [`CreateFile`]).
                fn security_qos_flags(&mut self, flags: u32) -> &mut Self;
            }
            
            impl OpenOptionsExt for OpenOptions
            {
                fn access_mode(&mut self, access: u32) -> &mut OpenOptions
                {
                    self.as_inner_mut().access_mode(access);
                    self
                }

                fn share_mode(&mut self, share: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().share_mode(share);
                    self
                }

                fn custom_flags(&mut self, flags: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().custom_flags(flags);
                    self
                }

                fn attributes(&mut self, attributes: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().attributes(attributes);
                    self
                }

                fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().security_qos_flags(flags);
                    self
                }
            }
            /// Windows-specific extensions to [`fs::Metadata`].
            pub trait MetadataExt
            {
                /// Returns the value of the `dwFileAttributes` field of this metadata.
                fn file_attributes(&self) -> u32;
                /// Returns the value of the `ftCreationTime` field of this metadata.
                fn creation_time(&self) -> u64;
                /// Returns the value of the `ftLastAccessTime` field of this metadata.
                fn last_access_time(&self) -> u64;
                /// Returns the value of the `ftLastWriteTime` field of this metadata.
                fn last_write_time(&self) -> u64;
                /// Returns the value of the `nFileSize` fields of this metadata.
                fn file_size(&self) -> u64;
                /// Returns the value of the `dwVolumeSerialNumber` field of this metadata.
                fn volume_serial_number(&self) -> Option<u32>;
                /// Returns the value of the `nNumberOfLinks` field of this metadata.
                fn number_of_links(&self) -> Option<u32>;
                /// Returns the value of the `nFileIndex` fields of this metadata.
                fn file_index(&self) -> Option<u64>;
                /// Returns the value of the `ChangeTime` fields of this metadata.
                fn change_time(&self) -> Option<u64>;
            }
            
            impl MetadataExt for Metadata
            {
                fn file_attributes(&self) -> u32 
                {
                    self.as_inner().attrs()
                }

                fn creation_time(&self) -> u64 
                {
                    self.as_inner().created_u64()
                }

                fn last_access_time(&self) -> u64 
                {
                    self.as_inner().accessed_u64()
                }

                fn last_write_time(&self) -> u64 
                {
                    self.as_inner().modified_u64()
                }

                fn file_size(&self) -> u64 {
                    self.as_inner().size()
                }
                
                fn volume_serial_number(&self) -> Option<u32> 
                {
                    self.as_inner().volume_serial_number()
                }

                fn number_of_links(&self) -> Option<u32> 
                {
                    self.as_inner().number_of_links()
                }

                fn file_index(&self) -> Option<u64> 
                {
                    self.as_inner().file_index()
                }

                fn change_time(&self) -> Option<u64> 
                {
                    self.as_inner().changed_u64()
                }

            }
            /// Windows-specific extensions to [`fs::FileType`].
            pub trait FileTypeExt: Sealed
            {
                /// Returns `true` if this file type is a symbolic link that is also a directory.
                fn is_symlink_dir(&self) -> bool;
                /// Returns `true` if this file type is a symbolic link that is also a file.
                fn is_symlink_file(&self) -> bool;
            }
            
            impl Sealed for fs::FileType {}
            
            impl FileTypeExt for fs::FileType
            {
                fn is_symlink_dir(&self) -> bool { self.as_inner().is_symlink_dir() }
                
                fn is_symlink_file(&self) -> bool { self.as_inner().is_symlink_file() }
            }
            /// Windows-specific extensions to [`fs::FileTimes`].
            pub trait FileTimesExt: Sealed
            {
                /// Set the creation time of a file.
                fn set_created(self, t: SystemTime) -> Self;
            }
            
            impl FileTimesExt for fs::FileTimes 
            {
                fn set_created(mut self, t: SystemTime) -> Self
                {
                    self.as_inner_mut().set_created(t.into_inner());
                    self
                }
            }
            /// Creates a new symlink to a non-directory file on the filesystem.
            pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()>
            {
                sys::fs::symlink_inner(original.as_ref(), link.as_ref(), false)
            }
            /// Creates a new symlink to a directory on the filesystem.
            pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()>
            {
                sys::fs::symlink_inner(original.as_ref(), link.as_ref(), true)
            }
            /// Creates a junction point.
            pub fn junction_point<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()>
            {
                sys::fs::junction_point(original.as_ref(), link.as_ref())
            }
        }

        pub mod io
        {
            //! Windows-specific extensions to general I/O primitives.
            use ::
            {
                *,
            };
            
            mod handle
            {
                //! Owned and borrowed OS handles.
                use ::
                {
                    marker::{ PhantomData },
                    mem::{ ManuallyDrop },
                    sys::common::{ AsInner, FromInner, IntoInner },
                    *,
                }; use super::raw::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};
                /// A borrowed handle.
                 #[repr(transparent)] #[derive(Copy, Clone)]
                 pub struct BorrowedHandle<'handle>
                 {
                    handle: RawHandle,
                    _phantom: PhantomData<&'handle OwnedHandle>,
                }
                /// An owned handle.
                #[repr(transparent)]
                pub struct OwnedHandle
                {
                    handle: RawHandle,
                }
                /// FFI type for handles in return values or out parameters, where `NULL` is used
                /// as a sentry value to indicate errors, such as in the return value of `CreateThread`.
                #[repr(transparent)] #[derive(Debug)]
                pub struct HandleOrNull(RawHandle);
                /// FFI type for handles in return values or out parameters, where `INVALID_HANDLE_VALUE` is used
                /// as a sentry value to indicate errors, such as in the return value of `CreateFileW`.
                #[repr(transparent)] #[derive(Debug)]
                pub struct HandleOrInvalid(RawHandle);
                
                unsafe impl Send for OwnedHandle {}
                
                unsafe impl Send for HandleOrNull {}
                
                unsafe impl Send for HandleOrInvalid {}
                
                unsafe impl Send for BorrowedHandle<'_> {}
                
                unsafe impl Sync for OwnedHandle {}
                
                unsafe impl Sync for HandleOrNull {}
                
                unsafe impl Sync for HandleOrInvalid {}
                
                unsafe impl Sync for BorrowedHandle<'_> {}

                impl BorrowedHandle<'_>
                {
                    /// Returns a `BorrowedHandle` holding the given raw handle.
                    #[inline] pub const unsafe fn borrow_raw(handle: RawHandle) -> Self
                    {
                        Self { handle, _phantom: PhantomData }
                    }
                }
                
                impl TryFrom<HandleOrNull> for OwnedHandle
                {
                    type Error = NullHandleError;

                    #[inline] fn try_from(handle_or_null: HandleOrNull) -> Result<Self, NullHandleError>
                    {
                        let handle_or_null = ManuallyDrop::new(handle_or_null);
                        if handle_or_null.is_valid() {
                            // SAFETY: The handle is not null.
                            Ok(unsafe { OwnedHandle::from_raw_handle(handle_or_null.0) })
                        } else {
                            Err(NullHandleError(()))
                        }
                    }
                }
                
                impl Drop for HandleOrNull
                {
                    #[inline] fn drop(&mut self)
                    {
                        if self.is_valid() {
                            unsafe {
                                let _ = sys::c::CloseHandle(self.0);
                            }
                        }
                    }
                }

                impl OwnedHandle
                {
                    /// Creates a new `OwnedHandle` instance that shares the same underlying
                    /// object as the existing `OwnedHandle` instance.
                    pub fn try_clone(&self) -> ::io::Result<Self> 
                    {
                        self.as_handle().try_clone_to_owned()
                    }
                }

                impl BorrowedHandle<'_> 
                {
                    /// Creates a new `OwnedHandle` instance that shares the same underlying
                    /// object as the existing `BorrowedHandle` instance.
                    pub fn try_clone_to_owned(&self) -> ::io::Result<OwnedHandle> 
                    {
                        self.duplicate(0, false, ::sys::c::DUPLICATE_SAME_ACCESS)
                    }

                    pub fn duplicate(
                        &self,
                        access: u32,
                        inherit: bool,
                        options: u32,
                    ) -> io::Result<OwnedHandle> 
                    {
                        let handle = self.as_raw_handle();
                        if handle.is_null() {
                            return unsafe { Ok(OwnedHandle::from_raw_handle(handle)) };
                        }

                        let mut ret = ::ptr::null_mut();
                        cvt(unsafe 
                        {
                            let cur_proc = ::sys::c::GetCurrentProcess();
                            ::sys::c::DuplicateHandle(
                                cur_proc,
                                handle,
                                cur_proc,
                                &mut ret,
                                access,
                                inherit as ::sys::c::BOOL,
                                options,
                            )
                        })?;
                        unsafe { Ok(OwnedHandle::from_raw_handle(ret)) }
                    }
                }
                
                impl TryFrom<HandleOrInvalid> for OwnedHandle 
                {
                    type Error = InvalidHandleError;

                    #[inline] fn try_from(handle_or_invalid: HandleOrInvalid) -> Result<Self, InvalidHandleError>
                    {
                        let handle_or_invalid = ManuallyDrop::new(handle_or_invalid);
                        if handle_or_invalid.is_valid() 
                        {
                            // SAFETY: The handle is not invalid.
                            Ok(unsafe { OwnedHandle::from_raw_handle(handle_or_invalid.0) })
                        }
                        else
                        {
                            Err(InvalidHandleError(()))
                        }
                    }
                }
                
                impl Drop for HandleOrInvalid 
                {
                    #[inline] fn drop(&mut self) 
                    {
                        if self.is_valid() 
                        {
                            unsafe 
                            {
                                let _ = ::sys::c::CloseHandle(self.0);
                            }
                        }
                    }
                }
                /// This is the error type used by [`HandleOrNull`] when attempting to convert
                /// into a handle, to indicate that the value is null.
                #[derive(Debug, Clone, PartialEq, Eq)]
                pub struct NullHandleError(());

                
                impl fmt::Display for NullHandleError 
                {
                    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result 
                    {
                        "A HandleOrNull could not be converted to a handle because it was null".fmt(fmt)
                    }
                }
                
                impl ::error::Error for NullHandleError {}
                /// This is the error type used by [`HandleOrInvalid`] when attempting to
                /// convert into a handle, to indicate that the value is
                /// `INVALID_HANDLE_VALUE`.
                #[derive(Debug, Clone, PartialEq, Eq)]
                pub struct InvalidHandleError(());

                
                impl fmt::Display for InvalidHandleError 
                {
                    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result 
                    {
                        "A HandleOrInvalid could not be converted to a handle because it was INVALID_HANDLE_VALUE"
                            .fmt(fmt)
                    }
                }
                
                impl ::error::Error for InvalidHandleError {}
                
                impl AsRawHandle for BorrowedHandle<'_> 
                {
                    #[inline] fn as_raw_handle(&self) -> RawHandle 
                    {
                        self.handle
                    }
                }
                
                impl AsRawHandle for OwnedHandle 
                {
                    #[inline] fn as_raw_handle(&self) -> RawHandle 
                    {
                        self.handle
                    }
                }
                
                impl IntoRawHandle for OwnedHandle 
                {
                    #[inline] fn into_raw_handle(self) -> RawHandle 
                    {
                        ManuallyDrop::new(self).handle
                    }
                }
                
                impl FromRawHandle for OwnedHandle 
                {
                    #[inline] unsafe fn from_raw_handle(handle: RawHandle) -> Self 
                    {
                        Self { handle }
                    }
                }

                impl HandleOrNull 
                {
                    /// Constructs a new instance of `Self` from the given `RawHandle` returned
                    /// from a Windows API that uses null to indicate failure, such as
                    /// `CreateThread`.
                    #[inline] pub unsafe fn from_raw_handle(handle: RawHandle) -> Self
                    {
                        Self(handle)
                    }

                    fn is_valid(&self) -> bool { !self.0.is_null() }
                }

                impl HandleOrInvalid
                {
                    /// Constructs a new instance of `Self` from the given `RawHandle` returned
                    /// from a Windows API that uses `INVALID_HANDLE_VALUE` to indicate
                    /// failure, such as `CreateFileW`.
                    #[inline] pub unsafe fn from_raw_handle(handle: RawHandle) -> Self
                    {
                        Self(handle)
                    }

                    fn is_valid(&self) -> bool { self.0 != sys::c::INVALID_HANDLE_VALUE }
                }
                
                impl Drop for OwnedHandle
                {
                    #[inline] fn drop(&mut self)
                    {
                        unsafe 
                        {
                            let _ = sys::c::CloseHandle(self.handle);
                        }
                    }
                }
                
                impl fmt::Debug for BorrowedHandle<'_> 
                {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
                    {
                        f.debug_struct("BorrowedHandle").field("handle", &self.handle).finish()
                    }
                }
                
                impl fmt::Debug for OwnedHandle 
                {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
                    {
                        f.debug_struct("OwnedHandle").field("handle", &self.handle).finish()
                    }
                }

                macro_rules! impl_is_terminal 
                {
                    ($($t:ty),*$(,)?) => {$(
                        
                        impl crate::sealed::Sealed for $t {}

                        
                        impl ::io::IsTerminal for $t 
                        {
                            #[inline]
                            fn is_terminal(&self) -> bool 
                            {
                                crate::sys::io::is_terminal(self)
                            }
                        }
                    )*}
                }

                impl_is_terminal!(BorrowedHandle<'_>, OwnedHandle);
                /// A trait to borrow the handle from an underlying object.
                pub trait AsHandle
                {
                    /// Borrows the handle.
                    fn as_handle(&self) -> BorrowedHandle<'_>;
                }
                
                impl<T: AsHandle + ?Sized> AsHandle for &T 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        T::as_handle(self)
                    }
                }
                
                impl<T: AsHandle + ?Sized> AsHandle for &mut T 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        T::as_handle(self)
                    }
                }
                /// This impl allows implementing traits that require `AsHandle` on Arc.
                impl<T: AsHandle + ?Sized> AsHandle for crate::sync::Arc<T> 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        (**self).as_handle()
                    }
                }
                
                impl<T: AsHandle + ?Sized> AsHandle for crate::rc::Rc<T> 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        (**self).as_handle()
                    }
                }
                
                impl<T: AsHandle + ?Sized> AsHandle for crate::rc::UniqueRc<T> 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        (**self).as_handle()
                    }
                }
                
                impl<T: AsHandle + ?Sized> AsHandle for Box<T> 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        (**self).as_handle()
                    }
                }
                
                impl AsHandle for BorrowedHandle<'_> 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        *self
                    }
                }
                
                impl AsHandle for OwnedHandle 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl AsHandle for fs::File 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        self.as_inner().as_handle()
                    }
                }
                
                impl From<fs::File> for OwnedHandle 
                {
                    /// Takes ownership of a [`File`](fs::File)'s underlying file handle.
                    #[inline] fn from(file: fs::File) -> OwnedHandle 
                    {
                        file.into_inner().into_inner().into_inner()
                    }
                }
                
                impl From<OwnedHandle> for fs::File 
                {
                    /// Returns a [`File`](fs::File) that takes ownership of the given handle.
                    #[inline] fn from(owned: OwnedHandle) -> Self 
                    {
                        Self::from_inner(FromInner::from_inner(FromInner::from_inner(owned)))
                    }
                }
                
                impl AsHandle for ::io::Stdin 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl<'a> AsHandle for ::io::StdinLock<'a> 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl AsHandle for ::io::Stdout 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl<'a> AsHandle for ::io::StdoutLock<'a> 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl AsHandle for ::io::Stderr 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl<'a> AsHandle for ::io::StderrLock<'a> 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl AsHandle for ::process::ChildStdin 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl From<::process::ChildStdin> for OwnedHandle 
                {
                    /// Takes ownership of a [`ChildStdin`](::process::ChildStdin)'s file handle.
                    #[inline] fn from(child_stdin: ::process::ChildStdin) -> OwnedHandle 
                    {
                        unsafe { OwnedHandle::from_raw_handle(child_stdin.into_raw_handle()) }
                    }
                }
                
                impl AsHandle for ::process::ChildStdout 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl From<::process::ChildStdout> for OwnedHandle 
                {
                    /// Takes ownership of a [`ChildStdout`](::process::ChildStdout)'s file handle.
                    #[inline] fn from(child_stdout: ::process::ChildStdout) -> OwnedHandle 
                    {
                        unsafe { OwnedHandle::from_raw_handle(child_stdout.into_raw_handle()) }
                    }
                }
                
                impl AsHandle for ::process::ChildStderr 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl From<::process::ChildStderr> for OwnedHandle 
                {
                    /// Takes ownership of a [`ChildStderr`](::process::ChildStderr)'s file handle.
                    #[inline] fn from(child_stderr: ::process::ChildStderr) -> OwnedHandle 
                    {
                        unsafe { OwnedHandle::from_raw_handle(child_stderr.into_raw_handle()) }
                    }
                }
                
                impl<T> AsHandle for ::thread::JoinHandle<T> 
                {
                    #[inline] fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }
                    }
                }
                
                impl<T> From<::thread::JoinHandle<T>> for OwnedHandle 
                {
                    #[inline] fn from(join_handle: ::thread::JoinHandle<T>) -> OwnedHandle 
                    {
                        join_handle.into_inner().into_handle().into_inner()
                    }
                }
                
                impl AsHandle for io::PipeReader 
                {
                    fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        self.0.as_handle()
                    }
                }
                
                impl From<io::PipeReader> for OwnedHandle 
                {
                    fn from(pipe: io::PipeReader) -> Self 
                    {
                        pipe.into_inner().into_inner()
                    }
                }
                
                impl AsHandle for io::PipeWriter 
                {
                    fn as_handle(&self) -> BorrowedHandle<'_> 
                    {
                        self.0.as_handle()
                    }
                }
                
                impl From<io::PipeWriter> for OwnedHandle 
                {
                    fn from(pipe: io::PipeWriter) -> Self 
                    {
                        pipe.into_inner().into_inner()
                    }
                }
                
                impl From<OwnedHandle> for io::PipeReader 
                {
                    fn from(owned_handle: OwnedHandle) -> Self 
                    {
                        Self::from_inner(FromInner::from_inner(owned_handle))
                    }
                }
                
                impl From<OwnedHandle> for io::PipeWriter 
                {
                    fn from(owned_handle: OwnedHandle) -> Self 
                    {
                        Self::from_inner(FromInner::from_inner(owned_handle))
                    }
                }
            } pub use self::handle::*;

            mod raw
            {
                //! Windows-specific extensions to general I/O primitives.
                use ::
                {
                    os::windows::io::{ AsHandle, AsSocket },
                    os::windows::io::{ OwnedHandle, OwnedSocket },
                    os::windows::raw,
                    sys::common::{ AsInner, FromInner, IntoInner },
                    *,
                };
                /// Raw HANDLEs.
                pub type RawHandle = raw::HANDLE;
                /// Raw SOCKETs.
                pub type RawSocket = raw::SOCKET;
                /// Extracts raw handles.
                pub trait AsRawHandle
                {
                    /// Extracts the raw handle.
                    fn as_raw_handle(&self) -> RawHandle;
                }
                /// Constructs I/O objects from raw handles.
                pub trait FromRawHandle
                {
                    /// Constructs a new I/O object from the specified raw handle.
                    unsafe fn from_raw_handle(handle: RawHandle) -> Self;
                }
                /// A trait to express the ability to consume an object and acquire ownership of its raw `HANDLE`.
                pub trait IntoRawHandle
                {
                    /// Consumes this object, returning the raw underlying handle.
                    #[must_use = "losing the raw handle may leak resources"]
                    fn into_raw_handle(self) -> RawHandle;
                }
               
                impl AsRawHandle for fs::File 
                {
                    #[inline] fn as_raw_handle(&self) -> RawHandle 
                    {
                        self.as_inner().as_raw_handle() as RawHandle
                    }
                }
               
                impl AsRawHandle for io::Stdin 
                {
                    fn as_raw_handle(&self) -> RawHandle 
                    {
                        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_INPUT_HANDLE) as RawHandle })
                    }
                }
               
                impl AsRawHandle for io::Stdout 
                {
                    fn as_raw_handle(&self) -> RawHandle 
                    {
                        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_OUTPUT_HANDLE) as RawHandle })
                    }
                }
               
                impl AsRawHandle for io::Stderr 
                {
                    fn as_raw_handle(&self) -> RawHandle 
                    {
                        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_ERROR_HANDLE) as RawHandle })
                    }
                }
               
                impl<'a> AsRawHandle for io::StdinLock<'a> 
                {
                    fn as_raw_handle(&self) -> RawHandle 
                    {
                        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_INPUT_HANDLE) as RawHandle })
                    }
                }
               
                impl<'a> AsRawHandle for io::StdoutLock<'a> 
                {
                    fn as_raw_handle(&self) -> RawHandle 
                    {
                        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_OUTPUT_HANDLE) as RawHandle })
                    }
                }
               
                impl<'a> AsRawHandle for io::StderrLock<'a> 
                {
                    fn as_raw_handle(&self) -> RawHandle 
                    {
                        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_ERROR_HANDLE) as RawHandle })
                    }
                }
                
                fn stdio_handle(raw: RawHandle) -> RawHandle 
                {
                    if raw == sys::c::INVALID_HANDLE_VALUE { ptr::null_mut() } else { raw }
                }
               
                impl FromRawHandle for fs::File 
                {
                    #[inline] unsafe fn from_raw_handle(handle: RawHandle) -> fs::File 
                    {
                        unsafe 
                        {
                            let handle = handle as sys::c::HANDLE;
                            fs::File::from_inner(sys::fs::File::from_inner(FromInner::from_inner(
                                OwnedHandle::from_raw_handle(handle),
                            )))
                        }
                    }
                }
               
                impl IntoRawHandle for fs::File 
                {
                    #[inline] fn into_raw_handle(self) -> RawHandle 
                    {
                        self.into_inner().into_raw_handle() as *mut _
                    }
                }
                /// Extracts raw sockets.
                pub trait AsRawSocket 
                {
                    /// Extracts the raw socket.
                    fn as_raw_socket(&self) -> RawSocket;
                }
                /// Creates I/O objects from raw sockets.                
                pub trait FromRawSocket 
                {
                    /// Constructs a new I/O object from the specified raw socket.
                    unsafe fn from_raw_socket(sock: RawSocket) -> Self;
                }
                /// A trait to express the ability to consume an object and acquire ownership of its raw `SOCKET`.
                pub trait IntoRawSocket 
                {
                    /// Consumes this object, returning the raw underlying socket.
                    #[must_use = "losing the raw socket may leak resources"]
                    fn into_raw_socket(self) -> RawSocket;
                }
               
                impl AsRawSocket for net::TcpStream 
                {
                    #[inline] fn as_raw_socket(&self) -> RawSocket 
                    {
                        self.as_inner().socket().as_raw_socket()
                    }
                }
                
                impl AsRawSocket for net::TcpListener 
                {
                    #[inline] fn as_raw_socket(&self) -> RawSocket 
                    {
                        self.as_inner().socket().as_raw_socket()
                    }
                }
                
                impl AsRawSocket for net::UdpSocket 
                {
                    #[inline] fn as_raw_socket(&self) -> RawSocket 
                    {
                        self.as_inner().socket().as_raw_socket()
                    }
                }
               
                impl FromRawSocket for net::TcpStream 
                {
                    #[inline] unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpStream 
                    {
                        unsafe {
                            let sock = sys::net::Socket::from_inner(OwnedSocket::from_raw_socket(sock));
                            net::TcpStream::from_inner(sys::net::TcpStream::from_inner(sock))
                        }
                    }
                }
                
                impl FromRawSocket for net::TcpListener 
                {
                    #[inline] unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpListener 
                    {
                        unsafe {
                            let sock = sys::net::Socket::from_inner(OwnedSocket::from_raw_socket(sock));
                            net::TcpListener::from_inner(sys::net::TcpListener::from_inner(sock))
                        }
                    }
                }
                
                impl FromRawSocket for net::UdpSocket 
                {
                    #[inline] unsafe fn from_raw_socket(sock: RawSocket) -> net::UdpSocket 
                    {
                        unsafe {
                            let sock = sys::net::Socket::from_inner(OwnedSocket::from_raw_socket(sock));
                            net::UdpSocket::from_inner(sys::net::UdpSocket::from_inner(sock))
                        }
                    }
                }
               
                impl IntoRawSocket for net::TcpStream 
                {
                    #[inline] fn into_raw_socket(self) -> RawSocket 
                    {
                        self.into_inner().into_socket().into_inner().into_raw_socket()
                    }
                }
               
                impl IntoRawSocket for net::TcpListener 
                {
                    #[inline] fn into_raw_socket(self) -> RawSocket 
                    {
                        self.into_inner().into_socket().into_inner().into_raw_socket()
                    }
                }
               
                impl IntoRawSocket for net::UdpSocket 
                {
                    #[inline] fn into_raw_socket(self) -> RawSocket 
                    {
                        self.into_inner().into_socket().into_inner().into_raw_socket()
                    }
                }
               
                impl AsRawHandle for io::PipeReader 
                {
                    fn as_raw_handle(&self) -> RawHandle 
                    {
                        self.0.as_raw_handle()
                    }
                }
               
                impl FromRawHandle for io::PipeReader 
                {
                    unsafe fn from_raw_handle(raw_handle: RawHandle) -> Self 
                    {
                        unsafe { Self::from_inner(FromRawHandle::from_raw_handle(raw_handle)) }
                    }
                }
               
                impl IntoRawHandle for io::PipeReader 
                {
                    fn into_raw_handle(self) -> RawHandle 
                    {
                        self.0.into_raw_handle()
                    }
                }
               
                impl AsRawHandle for io::PipeWriter 
                {
                    fn as_raw_handle(&self) -> RawHandle 
                    {
                        self.0.as_raw_handle()
                    }
                }
               
                impl FromRawHandle for io::PipeWriter 
                {
                    unsafe fn from_raw_handle(raw_handle: RawHandle) -> Self 
                    {
                        unsafe { Self::from_inner(FromRawHandle::from_raw_handle(raw_handle)) }
                    }
                }
               
                impl IntoRawHandle for io::PipeWriter 
                {
                    fn into_raw_handle(self) -> RawHandle 
                    {
                        self.0.into_raw_handle()
                    }
                }
            } pub use self::raw::*;

            mod socket
            {
                //! Owned and borrowed OS sockets.
                use ::
                {
                    marker::PhantomData,
                    mem::{self, ManuallyDrop},
                    sys::cvt,
                    *,
                }; use super::raw::{ AsRawSocket, FromRawSocket, IntoRawSocket, RawSocket };
                
                type ValidRawSocket = core::num::niche_types::NotAllOnes<RawSocket>;
                /// A borrowed socket.
                #[repr(transparent)] #[rustc_nonnull_optimization_guaranteed] #[derive(Copy, Clone)]
                pub struct BorrowedSocket<'socket> 
                {
                    socket: ValidRawSocket,
                    _phantom: PhantomData<&'socket OwnedSocket>,
                }
                /// An owned socket.
                #[repr(transparent)] #[rustc_nonnull_optimization_guaranteed]
                pub struct OwnedSocket 
                {
                    socket: ValidRawSocket,
                }

                impl BorrowedSocket<'_> 
                {
                    /// Returns a `BorrowedSocket` holding the given raw socket.
                    #[inline] #[track_caller] pub const unsafe fn borrow_raw(socket: RawSocket) -> Self
                    {
                        Self { socket: ValidRawSocket::new(socket).expect("socket != -1"), _phantom: PhantomData }
                    }
                }

                impl OwnedSocket
                {
                    /// Creates a new `OwnedSocket` instance that shares the same underlying object as the existing `OwnedSocket` instance.
                    pub fn try_clone(&self) -> io::Result<Self> 
                    {
                        self.as_socket().try_clone_to_owned()
                    }
                    
                    pub fn set_no_inherit(&self) -> io::Result<()> 
                    {
                        cvt(unsafe 
                        {
                            sys::c::SetHandleInformation(
                                self.as_raw_socket() as sys::c::HANDLE,
                                sys::c::HANDLE_FLAG_INHERIT,
                                0,
                            )
                        })
                        .map(drop)
                    }
                }

                impl BorrowedSocket<'_> 
                {
                    /// Creates a new `OwnedSocket` instance that shares the same underlying
                    /// object as the existing `BorrowedSocket` instance.
                    pub fn try_clone_to_owned(&self) -> io::Result<OwnedSocket> 
                    {
                        let mut info = unsafe { mem::zeroed::<sys::c::WSAPROTOCOL_INFOW>() };
                        let result = unsafe 
                        {
                            sys::c::WSADuplicateSocketW(
                                self.as_raw_socket() as sys::c::SOCKET,
                                sys::c::GetCurrentProcessId(),
                                &mut info,
                            )
                        };
                        sys::net::cvt(result)?;
                        let socket = unsafe 
                        {
                            sys::c::WSASocketW(
                                info.iAddressFamily,
                                info.iSocketType,
                                info.iProtocol,
                                &info,
                                0,
                                sys::c::WSA_FLAG_OVERLAPPED | sys::c::WSA_FLAG_NO_HANDLE_INHERIT,
                            )
                        };

                        if socket != sys::c::INVALID_SOCKET 
                        {
                            unsafe { Ok(OwnedSocket::from_raw_socket(socket as RawSocket)) }
                        }
                        
                        else 
                        {
                            let error = unsafe { sys::c::WSAGetLastError() };

                            if error != sys::c::WSAEPROTOTYPE && error != sys::c::WSAEINVAL 
                            {
                                return Err(io::Error::from_raw_os_error(error));
                            }

                            let socket = unsafe 
                            {
                                sys::c::WSASocketW(
                                    info.iAddressFamily,
                                    info.iSocketType,
                                    info.iProtocol,
                                    &info,
                                    0,
                                    sys::c::WSA_FLAG_OVERLAPPED,
                                )
                            };

                            if socket == sys::c::INVALID_SOCKET 
                            {
                                return Err(last_error());
                            }

                            unsafe 
                            {
                                let socket = OwnedSocket::from_raw_socket(socket as RawSocket);
                                socket.set_no_inherit()?;
                                Ok(socket)
                            }
                        }
                    }
                }
                /// Returns the last error from the Windows socket interface.
                fn last_error() -> io::Error 
                {
                    io::Error::from_raw_os_error(unsafe { sys::c::WSAGetLastError() })
                }
               
                impl AsRawSocket for BorrowedSocket<'_> 
                {
                    #[inline] fn as_raw_socket(&self) -> RawSocket 
                    {
                        self.socket.as_inner()
                    }
                }
               
                impl AsRawSocket for OwnedSocket 
                {
                    #[inline] fn as_raw_socket(&self) -> RawSocket 
                    {
                        self.socket.as_inner()
                    }
                }
               
                impl IntoRawSocket for OwnedSocket 
                {
                    #[inline] fn into_raw_socket(self) -> RawSocket 
                    {
                        ManuallyDrop::new(self).socket.as_inner()
                    }
                }
               
                impl FromRawSocket for OwnedSocket 
                {
                    #[inline] #[track_caller]
                    unsafe fn from_raw_socket(socket: RawSocket) -> Self 
                    {
                        Self { socket: ValidRawSocket::new(socket).expect("socket != -1") }
                    }
                }
               
                impl Drop for OwnedSocket 
                {
                    #[inline] fn drop(&mut self) 
                    {
                        unsafe 
                        {
                            let _ = sys::c::closesocket(self.socket.as_inner() as sys::c::SOCKET);
                        }
                    }
                }
               
                impl fmt::Debug for BorrowedSocket<'_> 
                {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
                    {
                        f.debug_struct("BorrowedSocket").field("socket", &self.socket).finish()
                    }
                }
               
                impl fmt::Debug for OwnedSocket 
                {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
                    {
                        f.debug_struct("OwnedSocket").field("socket", &self.socket).finish()
                    }
                }
                /// A trait to borrow the socket from an underlying object.
                pub trait AsSocket 
                {
                    /// Borrows the socket.
                    fn as_socket(&self) -> BorrowedSocket<'_>;
                }
                
                impl<T: AsSocket> AsSocket for &T 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        T::as_socket(self)
                    }
                }
                
                impl<T: AsSocket> AsSocket for &mut T 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        T::as_socket(self)
                    }
                }               
                /// This impl allows implementing traits that require `AsSocket` on Arc.
                impl<T: AsSocket> AsSocket for crate::sync::Arc<T> 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        (**self).as_socket()
                    }
                }
                
                impl<T: AsSocket> AsSocket for crate::rc::Rc<T> 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        (**self).as_socket()
                    }
                }
                
                impl<T: AsSocket + ?Sized> AsSocket for crate::rc::UniqueRc<T> 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        (**self).as_socket()
                    }
                }
                
                impl<T: AsSocket> AsSocket for Box<T> 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        (**self).as_socket()
                    }
                }
               
                impl AsSocket for BorrowedSocket<'_> 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        *self
                    }
                }
               
                impl AsSocket for OwnedSocket 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        // Safety: `OwnedSocket` and `BorrowedSocket` have the same validity
                        // invariants, and the `BorrowedSocket` is bounded by the lifetime
                        // of `&self`.
                        unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }
                    }
                }
               
                impl AsSocket for crate::net::TcpStream 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }
                    }
                }
               
                impl From<crate::net::TcpStream> for OwnedSocket 
                {
                    /// Takes ownership of a [`TcpStream`](crate::net::TcpStream)'s socket.
                    #[inline] fn from(tcp_stream: crate::net::TcpStream) -> OwnedSocket 
                    {
                        unsafe { OwnedSocket::from_raw_socket(tcp_stream.into_raw_socket()) }
                    }
                }
               
                impl From<OwnedSocket> for crate::net::TcpStream 
                {
                    #[inline] fn from(owned: OwnedSocket) -> Self 
                    {
                        unsafe { Self::from_raw_socket(owned.into_raw_socket()) }
                    }
                }
               
                impl AsSocket for crate::net::TcpListener 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }
                    }
                }
               
                impl From<crate::net::TcpListener> for OwnedSocket 
                {
                    /// Takes ownership of a [`TcpListener`](crate::net::TcpListener)'s socket.
                    #[inline] fn from(tcp_listener: crate::net::TcpListener) -> OwnedSocket 
                    {
                        unsafe { OwnedSocket::from_raw_socket(tcp_listener.into_raw_socket()) }
                    }
                }
               
                impl From<OwnedSocket> for crate::net::TcpListener 
                {
                    #[inline] fn from(owned: OwnedSocket) -> Self 
                    {
                        unsafe { Self::from_raw_socket(owned.into_raw_socket()) }
                    }
                }
               
                impl AsSocket for crate::net::UdpSocket 
                {
                    #[inline] fn as_socket(&self) -> BorrowedSocket<'_> 
                    {
                        unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }
                    }
                }
               
                impl From<crate::net::UdpSocket> for OwnedSocket 
                {
                    /// Takes ownership of a [`UdpSocket`](crate::net::UdpSocket)'s underlying socket.
                    #[inline] fn from(udp_socket: crate::net::UdpSocket) -> OwnedSocket 
                    {
                        unsafe { OwnedSocket::from_raw_socket(udp_socket.into_raw_socket()) }
                    }
                }
               
                impl From<OwnedSocket> for crate::net::UdpSocket 
                {
                    #[inline] fn from(owned: OwnedSocket) -> Self 
                    {
                        unsafe { Self::from_raw_socket(owned.into_raw_socket()) }
                    }
                }
            } pub use self::socket::*;
            
        }

        pub mod net
        {
            use ::
            {
                *,
            };
        }

        pub mod process
        {
            use ::
            {
                *,
            };
        }

        pub mod raw
        {
            use ::
            {
                *,
            };
        }

        pub mod thread
        {
            use ::
            {
                *,
            };
        }
        /// A prelude for conveniently writing platform-specific code.
        pub mod prelude
        {
            pub use super::ffi::{OsStrExt, OsStringExt};
            pub use super::fs::FileExt;
            pub use super::fs::{MetadataExt, OpenOptionsExt};
            pub use super::io::
            {
                AsHandle, AsSocket, BorrowedHandle, BorrowedSocket, FromRawHandle, FromRawSocket,
                HandleOrInvalid, IntoRawHandle, IntoRawSocket, OwnedHandle, OwnedSocket,
            };
            pub use super::io::{AsRawHandle, AsRawSocket, RawHandle, RawSocket};
        }
    }
}

pub mod parsers
{
    pub mod line
    {
        use ::
        {
            types::{ LineInfo },
            *,
        };
        /*
        pub fn line_to_cmds(line: &str) -> Vec<String> */
        /// Parse command line for multiple commands.
        pub fn to_cmds(line: &str) -> Vec<String>
        {
            let mut result = Vec::new();
            let mut sep = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let len = line.chars().count();
            for (i, c) in line.chars().enumerate() {
                if has_backslash {
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if c == '\\' && sep != "'" {
                    has_backslash = true;
                    continue;
                }

                if c == '#' {
                    if sep.is_empty() {
                        break;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '\'' || c == '"' || c == '`' {
                    if sep.is_empty() {
                        sep.push(c);
                        token.push(c);
                        continue;
                    } else if sep == c.to_string() {
                        token.push(c);
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '&' || c == '|' {
                    // needs watch ahead here
                    if sep.is_empty() {
                        if i + 1 == len {
                            // for bg commands, e.g. `ls &`
                            token.push(c);
                            continue;
                        } else {
                            let c_next = match line.chars().nth(i + 1) {
                                Some(x) => x,
                                None => {
                                    println!("chars nth error - should never happen");
                                    continue;
                                }
                            };

                            if c_next != c {
                                token.push(c);
                                continue;
                            }
                        }
                    }

                    if sep.is_empty() {
                        sep.push(c);
                        continue;
                    } else if c.to_string() == sep {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        token = String::new();
                        result.push(format!("{}{}", sep, sep));
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == ';' {
                    if sep.is_empty() {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        result.push(String::from(";"));
                        token = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                token.push(c);
            }
            if !token.is_empty() {
                result.push(token.trim().to_string());
            }
            result
        }
        /*
        pub fn parse_line(line: &str) -> LineInfo*/
        pub fn parse(line: &str) -> LineInfo
        {
            let mut result = Vec::new();

            if ::is::arithmetic(line)
            {
                for x in line.split(' ')
                {
                    result.push((String::from(""), x.to_string()));
                }

                return LineInfo::new(result);
            }

            let mut sep = String::new();
            let mut sep_second = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let mut met_parenthesis = false;
            let mut new_round = true;
            let mut skip_next = false;
            let mut has_dollar = false;
            let mut parens_left_ignored = false;
            let mut sep_made = String::new();
            let mut semi_ok = false;
            let count_chars = line.chars().count();

            for (i, c) in line.chars().enumerate()
            {
                if skip_next
                {
                    skip_next = false;
                    continue;
                }

                if has_backslash && sep.is_empty() && (c == '>' || c == '<')
                {
                    sep_made = String::from("'");
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash && sep == "\"" && c != '\"'
                {
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash
                {
                    if new_round && sep.is_empty() && (c == '|' || c == '$') && token.is_empty()
                    {
                        sep = String::from("\\");
                        token = format!("{}", c);
                    }
                    else { token.push(c); }

                    new_round = false;
                    has_backslash = false;
                    continue;
                }

                if c == '$' { has_dollar = true; }
                
                if c == '(' && sep.is_empty()
                {
                    if !has_dollar && token.is_empty()
                    {
                        parens_left_ignored = true;
                        continue;
                    }

                    met_parenthesis = true;
                }

                if c == ')'
                {
                    if parens_left_ignored && !has_dollar
                    {
                        if i == count_chars - 1 || (i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == ' ')
                        { continue; }
                    }

                    if sep.is_empty() { met_parenthesis = false; }
                }

                if c == '\\'
                {
                    if sep == "'" || !sep_second.is_empty() { token.push(c) } else { has_backslash = true; }
                    continue;
                }

                if new_round
                {
                    if c == ' ' { continue; }
                    else if c == '"' || c == '\'' || c == '`'
                    {
                        sep = c.to_string();
                        new_round = false;
                        continue;
                    }

                    sep = String::new();

                    if c == '#' { break; }

                    if c == '|'
                    {
                        if i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == '|'
                        {
                            result.push((String::from(""), "||".to_string()));
                            skip_next = true;
                        }
                        else { result.push((String::from(""), "|".to_string())); }

                        new_round = true;
                        continue;
                    }

                    token.push(c);
                    new_round = false;
                    continue;
                }

                if c == '|' && !has_backslash
                {
                    if semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((sep.to_string(), token)); }

                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }
                    
                    else if !met_parenthesis && sep_second.is_empty() && sep.is_empty()
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((String::from(""), token)); }

                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        continue;
                    }
                }

                if c == ' '
                {
                    if semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((sep.to_string(), token)); }

                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }

                    if has_backslash
                    {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if met_parenthesis
                    {
                        token.push(c);
                        continue;
                    }

                    if sep == "\\"
                    {
                        result.push((String::from("\\"), token));
                        token = String::new();
                        new_round = true;
                        continue;
                    }

                    if sep.is_empty()
                    {
                        if sep_second.is_empty()
                        {
                            if sep.is_empty() && !sep_made.is_empty()
                            {
                                result.push((sep_made.clone(), token));
                                sep_made = String::new();
                            }
                            else { result.push((String::from(""), token)); }

                            token = String::new();
                            new_round = true;
                            continue;
                        }

                        else
                        {
                            token.push(c);
                            continue;
                        }
                    }
                    
                    else
                    {
                        token.push(c);
                        continue;
                    }
                }

                if c == '\'' || c == '"' || c == '`'
                {
                    if has_backslash
                    {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if sep != c.to_string() && semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((sep.to_string(), token)); }

                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                    }

                    if sep != c.to_string() && met_parenthesis
                    {
                        token.push(c);
                        continue;
                    }

                    if sep.is_empty() && !sep_second.is_empty() && sep_second != c.to_string()
                    {
                        token.push(c);
                        continue;
                    }

                    if sep.is_empty()
                    {
                        let is_an_env = ::regex::contains(&token, r"^[a-zA-Z0-9_]+=.*$");
                        
                        if !is_an_env && (c == '\'' || c == '"')
                        {
                            sep = c.to_string();
                            continue;
                        }

                        token.push(c);
                        
                        if sep_second.is_empty() { sep_second = c.to_string(); }
                        else if sep_second == c.to_string() { sep_second = String::new(); }

                        continue;
                    }

                    else if sep == c.to_string()
                    {
                        semi_ok = true;
                        continue;
                    }

                    else { token.push(c); }
                }
                
                else
                {
                    if has_backslash
                    {
                        has_backslash = false;
                        if sep == "\"" || sep == "'" { token.push('\\'); }
                    }

                    token.push(c);
                }
            }

            if !token.is_empty() || semi_ok
            {
                if sep.is_empty() && !sep_made.is_empty() { result.push((sep_made.clone(), token)); }
                else { result.push((sep.clone(), token)); }
            }

            let mut is_line_complete = true;

            if !result.is_empty()
            {
                let token_last = result[result.len() - 1].clone();
                if token_last.0.is_empty() && token_last.1 == "|" { is_line_complete = false; }
            }

            if !sep.is_empty() { is_line_complete = semi_ok; }

            if has_backslash { is_line_complete = false; }

            LineInfo { tokens: result, is_complete: is_line_complete }
        }
    }

    pub mod rc
    {
        //! Parses configuration files in the format of GNU Readline `inputrc`
        use ::
        {
            char::{ from_u32, ctrl, meta, parse_char_name },
            command::{ Command },
            fs::File,
            io::{stderr, Read, Write},
            path::Path,
            str::{Chars, Lines},
            *,
        };
        /// Parsed configuration directive
        #[derive(Clone, Debug)]
        pub enum Directive 
        {
            /// Bind construct; `"input-sequence": command-or-macro`
            Bind(String, Command),
            /// Conditional construct;
            Conditional
            {
                /// Value name; if `None`, value refers to application name
                name: Option<String>,
                /// Value to compare
                value: String,
                /// Group of directives evaluated when condition is true
                then_group: Vec<Directive>,
                /// Group of directives evaluated when condition is false
                else_group: Vec<Directive>,
            },
            /// Set variable; `set name value`
            SetVariable(String, String),
        }
        /// Parses the named file and returns contained directives.
        pub fn parse_file<P: ?Sized>(filename: &P) -> Option<Vec<Directive>>
                where P: AsRef<Path> {
            let filename = filename.as_ref();

            let mut f = match File::open(filename) {
                Ok(f) => f,
                Err(e) => {
                    let _ = writeln!(stderr(), "linefeed: {}: {}", filename.display(), e);
                    return None;
                }
            };

            let mut buf = String::new();

            if let Err(e) = f.read_to_string(&mut buf) {
                let _ = writeln!(stderr(), "{}: {}", filename.display(), e);
                return None;
            }

            Some(parse_text(filename, &buf))
        }

        /// Parses some text and returns contained directives.
        ///
        /// If any errors are encountered during parsing, they are printed to `stderr`.
        pub fn parse_text<P: ?Sized>(name: &P, line: &str) -> Vec<Directive>
                where P: AsRef<Path> {
            let mut p = Parser::new(name.as_ref(), line);
            p.parse()
        }

        struct Parser<'a> {
            lines: Lines<'a>,
            filename: &'a Path,
            line_num: usize,
        }

        enum Token<'a> {
            /// Colon; `:`
            Colon,
            /// Equal; `=`
            Equal,
            /// Conditional or other special directive; `$word`
            SpecialWord(&'a str),
            /// Double-quoted string; `"foo"`
            String(String),
            /// Bare word; `foo`
            Word(&'a str),
            /// Invalid token
            Invalid,
        }

        impl<'a> Parser<'a> {
            pub fn new(filename: &'a Path, text: &'a str) -> Parser<'a> {
                Parser{
                    lines: text.lines(),
                    filename: filename,
                    line_num: 0,
                }
            }

            fn next_line(&mut self) -> Option<&'a str> {
                self.lines.next().map(|line| {
                    self.line_num += 1;
                    line.trim()
                })
            }

            fn parse(&mut self) -> Vec<Directive> {
                let mut dirs = Vec::new();

                while let Some(line) = self.next_line() {
                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    if let Some(Token::SpecialWord("include")) = tokens.next() {
                        let path = tokens.line;

                        if let Some(d) = parse_file(Path::new(path)) {
                            dirs.extend(d);
                        }

                        continue;
                    }

                    if let Some(dir) = self.parse_line(line) {
                        dirs.push(dir);
                    }
                }

                dirs
            }

            fn parse_conditional(&mut self) -> (Vec<Directive>, Vec<Directive>) {
                let mut then_group = Vec::new();
                let mut else_group = Vec::new();
                let mut parse_else = false;

                loop {
                    let line = match self.next_line() {
                        Some(line) => line,
                        None => {
                            self.error("missing $endif directive");
                            break;
                        }
                    };

                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    let start = match tokens.next() {
                        Some(tok) => tok,
                        None => continue
                    };

                    match start {
                        Token::SpecialWord("else") => {
                            if parse_else {
                                self.error("duplicate $else directive");
                            } else {
                                parse_else = true;
                            }
                        }
                        Token::SpecialWord("endif") => {
                            break;
                        }
                        _ => {
                            if let Some(dir) = self.parse_line(line) {
                                if parse_else {
                                    else_group.push(dir);
                                } else {
                                    then_group.push(dir);
                                }
                            }
                        }
                    }
                }

                (then_group, else_group)
            }

            fn parse_line(&mut self, line: &str) -> Option<Directive> {
                let mut tokens = Tokens::new(line);

                let start = tokens.next()?;

                let dir = match start {
                    Token::SpecialWord("if") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (name, value) = match tokens.next() {
                            Some(Token::Equal) => {
                                let value = match tokens.next() {
                                    Some(Token::Word(w)) => w,
                                    None => "",
                                    _ => {
                                        self.invalid();
                                        return None;
                                    }
                                };

                                (Some(name), value)
                            }
                            None => (None, name),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (then_group, else_group) = self.parse_conditional();

                        Directive::Conditional{
                            name: name.map(|s| s.to_owned()),
                            value: value.to_owned(),
                            then_group: then_group,
                            else_group: else_group,
                        }
                    }
                    Token::SpecialWord("else") => {
                        self.error("$else without matching $if directive");
                        return None;
                    }
                    Token::SpecialWord("endif") => {
                        self.error("$endif without matching $if directive");
                        return None;
                    }
                    Token::String(seq) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(out)) =>
                                Directive::Bind(seq, Command::Macro(out.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    Token::Word("set") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let rest = tokens.line;

                        let value = match tokens.next() {
                            Some(Token::String(s)) => s,
                            Some(Token::Word(_)) => rest.to_owned(),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        Directive::SetVariable(name.to_owned(), value)
                    }
                    Token::Word(name) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        let seq = match parse_char_name(name) {
                            Some(seq) => seq,
                            None => {
                                self.invalid();
                                return None;
                            }
                        };

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(macro_seq)) =>
                                Directive::Bind(seq, Command::Macro(macro_seq.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    _ => {
                        self.invalid();
                        return None;
                    }
                };

                Some(dir)
            }

            fn error(&self, msg: &str) {
                let _ = writeln!(stderr(),
                    "linefeed: {} line {}: {}", self.filename.display(), self.line_num, msg);
            }

            fn invalid(&self) {
                self.error("invalid directive");
            }
        }

        struct Tokens<'a> {
            line: &'a str,
        }

        impl<'a> Tokens<'a> {
            fn new(line: &str) -> Tokens {
                Tokens{
                    line: line,
                }
            }
        }

        impl<'a> Iterator for Tokens<'a> {
            type Item = Token<'a>;

            fn next(&mut self) -> Option<Token<'a>> {
                let ch = self.line.chars().next()?;

                let tok = match ch {
                    ':' => {
                        self.line = self.line[1..].trim_start();
                        Token::Colon
                    }
                    '=' => {
                        self.line = self.line[1..].trim_start();
                        Token::Equal
                    }
                    '$' => {
                        let (word, rest) = parse_word(&self.line[1..]);
                        self.line = rest.trim_start();
                        Token::SpecialWord(word)
                    }
                    '"' => {
                        let (tok, rest) = parse_string(self.line);
                        self.line = rest.trim_start();
                        tok
                    }
                    _ => {
                        let (word, rest) = parse_word(self.line);
                        self.line = rest.trim_start();
                        Token::Word(word)
                    }
                };

                Some(tok)
            }
        }

        fn parse_escape(chars: &mut Chars) -> Option<String> {
            let ch = chars.next()?;

            let esc = match ch {
                'C'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    ctrl(chars.next()?)
                }
                'M'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    return Some(meta(chars.next()?));
                }
                'e'  => '\x1b',
                '\\' => '\\',
                '"'  => '"',
                '\'' => '\'',
                'a'  => '\x07',
                'b'  => '\x08',
                'd'  => '\x7f',
                'f'  => '\x0c',
                'n'  => '\n',
                'r'  => '\r',
                't'  => '\t',
                'u'  => {
                    match chars.next() {
                        Some('{') => (),
                        _ => return None
                    }

                    let mut n = 0;

                    for _ in 0..6 {
                        match chars.clone().next().and_then(|ch| ch.to_digit(16)) {
                            Some(digit) => {
                                chars.next();
                                n *= 16;
                                n += digit;
                            }
                            None => break
                        }
                    }

                    match chars.next() {
                        Some('}') => (),
                        _ => return None
                    }

                    from_u32(n)?
                }
                'v'  => '\x0b',
                'x'  => {
                    let mut n = 0;

                    for _ in 0..2 {
                        // Peek the next character
                        let digit = chars.clone().next()?.to_digit(16)? as u8;

                        // Consume if valid
                        chars.next();

                        n <<= 4;
                        n |= digit;
                    }

                    n as char
                }
                '0' ..= '3' => {
                    let mut n = ch as u8 - b'0';

                    for _ in 0..2 {
                        // Peek the next character
                        let digit = chars.clone().next()?.to_digit(8)? as u8;

                        // Consume if valid
                        chars.next();

                        n <<= 3;
                        n |= digit;
                    }

                    n as char
                }
                _ => return None
            };

            Some(esc.to_string())
        }

        fn parse_string(s: &str) -> (Token, &str) {
            let mut chars = s.chars();
            let mut res = String::new();

            // Skip open quote
            chars.next();

            while let Some(ch) = chars.next() {
                match ch {
                    '"' => return (Token::String(res), chars.as_str()),
                    '\\' => {
                        match parse_escape(&mut chars) {
                            Some(esc) => {
                                res.push_str(&esc);
                            }
                            None => break
                        }
                    }
                    ch => res.push(ch)
                }
            }

            (Token::Invalid, "")
        }

        fn parse_word(s: &str) -> (&str, &str) {
            let mut chars = s.char_indices();

            loop {
                let mut clone = chars.clone();

                match clone.next() {
                    Some((ind, ch)) if ch == ':' || ch == '"' || ch == '=' ||
                            ch.is_whitespace() => {
                        return (&s[..ind], &s[ind..]);
                    }
                    None => {
                        return (s, "");
                    }
                    _ => ()
                }

                chars = clone;
            }
        }
    }
}

pub mod path
{
    pub use std::path::{ * };

    use ::
    {
        *,
    };
    /*
    use std::borrow::Cow;
    use std::env;
    use std::fs::read_dir;
    use std::io::{ErrorKind, Write};
    use std::os::unix::fs::PermissionsExt;

    use regex::Regex;

    use crate::tools;
    */
    
    pub fn get_current_dir() -> String 
    {
        let mut current_dir = PathBuf::new();
        match env::current_dir() {
            Ok(x) => current_dir = x,
            Err(e) => {
                println_stderr!("env current_dir() failed: {}", e);
            }
        }
        let mut str_current_dir = "";
        match current_dir.to_str() {
            Some(x) => str_current_dir = x,
            None => {
                println_stderr!("current_dir to str failed.");
            }
        }
        str_current_dir.to_string()
    }

    pub fn basename(path: &str) -> Cow<'_, str>
    {
        let mut pieces = path.rsplit('/');
        
        match pieces.next()
        {
            Some(p) => p.into(),
            None => path.into(),
        }
    }

    pub fn expand_home(text: &str) -> String
    {
        let mut s: String = text.to_string();
        let v = vec![
            r"(?P<head> +)~(?P<tail> +)",
            r"(?P<head> +)~(?P<tail>/)",
            r"^(?P<head> *)~(?P<tail>/)",
            r"(?P<head> +)~(?P<tail> *$)",
        ];

        for item in &v
        {
            let re;
            if let Ok(x) = Regex::new(item) {
                re = x;
            } else {
                return String::new();
            }
            let home = tools::get_user_home();
            let ss = s.clone();
            let to = format!("$head{}$tail", home);
            let result = re.replace_all(ss.as_str(), to.as_str());
            s = result.to_string();
        }
        s
    }

    pub fn find_file_in_path(filename: &str, exec: bool) -> String
    {
        let env_path = match env::var("PATH") {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: error with env PATH: {:?}", e);
                return String::new();
            }
        };
        let vec_path: Vec<&str> = env_path.split(':').collect();
        for p in &vec_path {
            match read_dir(p) {
                Ok(list) => {
                    for entry in list.flatten() {
                        if let Ok(name) = entry.file_name().into_string() {
                            if name != filename {
                                continue;
                            }

                            if exec {
                                let _mode = match entry.metadata() {
                                    Ok(x) => x,
                                    Err(e) => {
                                        println_stderr!("cicada: metadata error: {:?}", e);
                                        continue;
                                    }
                                };
                                let mode = _mode.permissions().mode();
                                if mode & 0o111 == 0 {
                                    // not binary
                                    continue;
                                }
                            }

                            return entry.path().to_string_lossy().to_string();
                        }
                    }
                }
                Err(e) => {
                    if e.kind() == ErrorKind::NotFound {
                        continue;
                    }
                    log!("cicada: fs read_dir error: {}: {}", p, e);
                }
            }
        }
        String::new()
    }

    pub fn current_dir() -> String
    {
        let _current_dir = match env::current_dir() {
            Ok(x) => x,
            Err(e) => {
                log!("cicada: PROMPT: env current_dir error: {}", e);
                return String::new();
            }
        };
        let current_dir = match _current_dir.to_str() {
            Some(x) => x,
            None => {
                log!("cicada: PROMPT: to_str error");
                return String::new();
            }
        };

        current_dir.to_string()
    }
}

pub mod process
{
    pub use std::process::{ * };
    pub fn getpid() -> i32 { unsafe { ::libc::getpid() } }
    pub fn has_terminal() -> bool
    {
        unsafe
        {
            let tgid = libc::tcgetpgrp(0);
            let pgid = libc::getpgid(0);
            tgid == pgid
        }
    }
}

pub mod prompt
{
    //! Provides access to prompt input state
    use ::
    {
        char::{is_ctrl, is_printable, DELETE, EOF},
        collections::{ FindResult, HashSet },
        command::{ Category, Command },
        complete::{ Completion },
        ffi::{ Function },
        mem::{ replace },
        ops::{ Range },
        reader::{ BindingIter, InputState, ReadLock, ReadResult },
        regex::{ forward_word, replace_all },
        signals::{ Signal },
        sync::{ Arc, Mutex },
        terminal::{ Terminals },
        time::{ Instant },
        writer::{ BLINK_DURATION, display_str, Digit, Display, HistoryIter, PromptType, Writer, WriteLock },
        *,
    };
    /*

    use mortal::FindResult;
    
    use crate::table::{format_columns, Line, Table};
    use crate::terminal::{CursorMode, Signal, Size};
    use crate::util::{
        get_open_paren, find_matching_paren, first_word,
        longest_common_prefix, repeat_char,
        back_n_words, forward_n_words,
        backward_char, forward_char, backward_word, forward_word,
        word_start, word_end, RangeArgument,
    };
    use crate::variables::VariableIter;
    */

    /// ANSI color codes wrapped with \x01 and \x02 for lineread
    pub const GREEN: &str = "\x01\x1b[0;32m\x02";

    lazy_static!
    {
        pub static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
        pub static ref ALIASES: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
    }
    /// Initialize the available commands cache by scanning PATH directories
    pub fn initialize_cache()
    {
        let commands = scan_available_commands();
        if let Ok(mut cache) = AVAILABLE_COMMANDS.lock() { *cache = commands; }
    }
    /// Update aliases in the prompts highlight's cache
    pub fn update_aliases(sh: &shell::Shell)
    {
        if let Ok(mut aliases) = ALIASES.lock()
        {
            aliases.clear();
            
            for alias_name in sh.aliases.keys()
            {
                aliases.insert(alias_name.clone());
            }
        }
    }
    /*
    pub fn get_prompt(...) -> String*/
    pub fn get(sh: &shell::Shell) -> String
    {
        let ps = get_prompt_string();
        let mut prompt = render_prompt(sh, &ps);
        
        if let Some((w, _h)) = ::terminal::size::dimensions()
        {
            if get_prompt_len(&prompt) > (w / 2) as i32 && !::regex::contains(&ps, r#"(?i)\$\{?newline.\}?"#)
            {
                prompt.push_str("\n$ ");
            }
        }

        else {  log!("ERROR: Failed to get term size"); }
        prompt
    }

    pub fn trim_multiline_prompts( line:&str ) -> String
    {
        let line_new = replace_all( line, r"\\\n>> ", "" );
        let line_new = replace_all( &line_new, r"\| *\n>> ", "| " );
        replace_all( &line_new, r"(?P<NEWLINE>\n)>> ", "$NEWLINE" )
    }

    pub fn create_highlighter() -> Arc<ShellHighlighter>
    {
        Arc::new(ShellHighlighter)
    }
    /// Provides access to the current state of input while a `read_line` call is in progress.
    pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminals>
    {
        pub read: &'a mut ReadLock<'b, Term>,
        write: WriteLock<'b, Term>,
    }

    impl<'a, 'b: 'a, Term: 'b + Terminals> Prompter<'a, 'b, Term>
    {
        pub fn new(read: &'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term>) -> Prompter<'a, 'b, Term>
        {
            Prompter{read, write}
        }

        /// Returns a `Writer` instance using the currently held write lock.
        pub fn writer_append<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>>
        {
            Writer::with_ref(&mut self.write, false)
        }
        /// Returns a `Writer` instance using the currently held write lock.
        pub fn writer_erase<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>>
        {
            Writer::with_ref(&mut self.write, true)
        }

        pub fn start_read_line(&mut self) -> io::Result<()>
        {
            self.read.state = InputState::NewSequence;
            self.write.is_prompt_drawn = true;
            self.write.update_size()?;
            self.write.draw_prompt()
        }

        pub fn end_read_line(&mut self) -> io::Result<()>
        {
            self.write.expire_blink()?;

            if self.read.overwrite_mode { self.write.set_cursor_mode(CursorMode::Normal)?; }

            if self.write.is_prompt_drawn
            {
                self.write.move_to_end()?;
                self.write.write_str("\n")?;
                self.write.is_prompt_drawn = false;
            }

            self.reset_input();
            self.read.state = InputState::Inactive;

            Ok(())
        }

        pub fn handle_input(&mut self, ch: char) -> io::Result<Option<ReadResult>>
        {
            self.write.expire_blink()?;

            match self.read.state
            {
                InputState::Inactive => panic!("input received in inactive state"),
                InputState::NewSequence => {
                    if ch == EOF && self.write.buffer.is_empty() {
                        self.write.write_str("\n")?;
                        self.write.is_prompt_drawn = false;
                        return Ok(Some(ReadResult::Eof));
                    } else {
                        self.read.sequence.push(ch);
                        self.execute_sequence()?;

                        if self.read.input_accepted {
                            let s = replace(&mut self.write.buffer, String::new());
                            return Ok(Some(ReadResult::Input(s)));
                        }
                    }
                }
                InputState::ContinueSequence{expiry: _} => {
                    self.read.sequence.push(ch);

                    self.execute_sequence()?;

                    if self.read.input_accepted {
                        let s = replace(&mut self.write.buffer, String::new());
                        return Ok(Some(ReadResult::Input(s)));
                    }
                }
                InputState::Number => {
                    if let Some(digit) = ch.to_digit(10) {
                        self.write.input_arg.input(digit as i32);

                        if self.write.input_arg.is_out_of_bounds() {
                            self.read.state = InputState::NewSequence;
                            self.write.input_arg = Digit::None;
                            self.write.explicit_arg = false;
                            self.write.redraw_prompt(PromptType::Normal)?;
                        } else {
                            self.write.redraw_prompt(PromptType::Number)?;
                        }
                    } else {
                        self.read.state = InputState::NewSequence;
                        self.write.redraw_prompt(PromptType::Normal)?;
                        self.read.macro_buffer.insert(0, ch);
                    }
                }
                InputState::CharSearch{n, backward} => {
                    if n != 0 {
                        if backward {
                            self.write.backward_search_char(n, ch)?;
                        } else {
                            self.write.forward_search_char(n, ch)?;
                        }
                    }
                    self.read.state = InputState::NewSequence;
                }
                InputState::TextSearch => {
                    if ch == DELETE {
                        {
                            let write = &mut *self.write;
                            write.search_buffer.pop();
                            write.last_search.clone_from(&write.search_buffer);
                        }
                        self.write.search_history_update()?;
                    } else if self.is_abort(ch) {
                        self.abort_search_history()?;
                    } else if is_ctrl(ch) {
                        // End search, handle input after cancelling
                        self.end_search_history()?;
                        self.read.macro_buffer.insert(0, ch);
                    } else {
                        {
                            let write = &mut *self.write;
                            write.search_buffer.push(ch);
                            write.last_search.clone_from(&write.search_buffer);
                        }
                        self.write.search_history_update()?;
                    }
                }
                InputState::CompleteIntro => {
                    match ch {
                        'y' | 'Y' | ' ' => {
                            self.write.write_str("\n")?;
                            self.show_completions_page(0)?;
                        }
                        '\r' | '\n' => {
                            self.write.write_str("\n")?;
                            self.show_completions_line(0)?;
                        }
                        'q' | 'Q' |
                        'n' | 'N' | DELETE => {
                            self.write.write_str("\n")?;
                            self.end_page_completions()?;
                        }
                        _ => ()
                    }
                }
                InputState::CompleteMore(offset) => {
                    match ch {
                        'y' | 'Y' | ' ' => {
                            self.write.clear_prompt()?;
                            self.show_completions_page(offset)?;
                        }
                        '\r' | '\n' => {
                            self.write.clear_prompt()?;
                            self.show_completions_line(offset)?;
                        }
                        'q' | 'Q' |
                        'n' | 'N' | DELETE => {
                            self.write.clear_prompt()?;
                            self.end_page_completions()?;
                        }
                        _ => ()
                    }
                }
                InputState::QuotedInsert(n) => {
                    if n != 0 {
                        self.insert(n, ch)?;
                    }
                    self.read.state = InputState::NewSequence;
                }
            }

            Ok(None)
        }
        /// Returns the current buffer.
        pub fn buffer(&self) -> &str { &self.write.buffer }
        /// Returns the "backup" buffer.
        pub fn backup_buffer(&self) -> &str { &self.write.backup_buffer }
        /// Returns the command `Category` of the most recently executed command.
        pub fn last_command_category(&self) -> Category { self.read.last_cmd }
        /// Returns the set of characters that indicate a word break.
        pub fn word_break_chars(&self) -> &str { &self.read.word_break }
        /// Sets the buffer to the given value.
        pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> { self.write.set_buffer(buf) }
        /// Returns the current position of the cursor.
        pub fn cursor(&self) -> usize { self.write.cursor }
        /// Sets the cursor to the given position within the buffer.
        pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> { self.write.set_cursor(pos) }
        /// Sets the prompt that will be displayed when `read_line` is called.
        pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> { self.write.set_prompt(prompt) }
        /// Returns the size of the terminal at the last draw operation.
        pub fn screen_size(&self) -> Size { self.write.screen_size }
        /// Returns whether a numerical argument was explicitly supplied by the user.
        pub fn explicit_arg(&self) -> bool { self.write.explicit_arg }
        /// Returns the current input sequence.
        pub fn sequence(&self) -> &str { &self.read.sequence }
        /// Returns an iterator over bound sequences
        pub fn bindings(&self) -> BindingIter { self.read.bindings() }
        /// Returns an iterator over variable values.
        pub fn variables(&self) -> VariableIter { self.read.variables() }
        /// Returns an iterator over history entries
        pub fn history(&self) -> HistoryIter { self.write.history() }
        /// Returns the index into history currently being edited.
        pub fn history_index(&self) -> Option<usize> { self.write.history_index }
        /// Returns the current number of history entries.
        pub fn history_len(&self) -> usize { self.write.history.len() }
        /// Selects the history entry currently being edited by the user.
        pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()>
        { self.write.select_history_entry(new) }
        /// Returns the current set of completions.
        pub fn completions(&self) -> Option<&[Completion]> { self.read.completions.as_ref().map(|v| &v[..]) }
        /// Sets the current set of completions.
        pub fn set_completions(&mut self, completions: Option<Vec<Completion>>)
        { self.read.completions = completions; }
        /// Accepts the current input buffer as user input.
        pub fn accept_input(&mut self) -> io::Result<()>
        {
            self.write.move_to_end()?;
            self.write.write_str("\n")?;
            self.read.input_accepted = true;
            self.write.is_prompt_drawn = false;
            Ok(())
        }
        /// Moves the cursor to the given position, waits for 500 milliseconds, 
        /// then restores the original cursor position.
        pub fn blink(&mut self, pos: usize) -> io::Result<()>
        {
            self.write.blink(pos)?;

            self.read.max_wait_duration = Some(BLINK_DURATION);

            Ok(())
        }

        pub fn check_expire_timeout(&mut self) -> io::Result<()> 
        {
            let now = Instant::now();

            self.check_expire_blink(now)?;
            self.check_expire_sequence(now)
        }

        pub fn handle_resize(&mut self, size: Size) -> io::Result<()> 
        {
            self.expire_blink()?;

            if self.is_paging_completions() 
            {
                self.end_page_completions()?;
            }

            self.write.screen_size = size;

            let p = self.write.prompt_type;
            self.write.redraw_prompt(p)
        }

        pub fn handle_signal(&mut self, signal: Signal) -> io::Result<()> 
        {
            self.expire_blink()?;

            match signal 
            {
                Signal::Continue => 
                {
                    self.write.draw_prompt()?;
                }
                Signal::Interrupt => 
                {
                    self.read.macro_buffer.clear();
                    self.write.move_to_end()?;

                    if self.read.echo_control_characters 
                    {
                        self.write.write_str("^C")?;
                    }

                    self.write.write_str("\n")?;
                    self.reset_input();
                    self.write.draw_prompt()?;
                }
                _ => ()
            }

            Ok(())
        }
        /// Deletes a range of text from the input buffer.
        pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> 
        {
            self.write.delete_range(range)
        }
        /// Deletes a range from the buffer and adds the removed text to the kill ring.
        pub fn kill_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> 
        {
            let start = range.start().cloned().unwrap_or(0);
            let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
            let len = end - start;

            if len != 0 
            {
                let buf = self.write.buffer[start..end].to_owned();

                if self.read.last_cmd != Category::Kill 
                {
                    self.push_kill_ring(buf);
                } else if end == self.write.cursor 
                {
                    self.prepend_kill_ring(buf);
                } else {
                    self.append_kill_ring(buf);
                }

                self.delete_range(start..end)?;
            }

            Ok(())
        }
        /// Transposes two regions of the buffer, `src` and `dest`.
        pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>) -> io::Result<()>
        {
            self.write.transpose_range(src, dest)
        }
        /// Insert text from the front of the kill ring at the current cursor position.
        pub fn yank(&mut self) -> io::Result<()>
        {
            if let Some(kill) = self.read.kill_ring.front().cloned()
            {
                let start = self.write.cursor;
                self.read.last_yank = Some((start, start + kill.len()));
                self.insert_str(&kill)?;
            }

            Ok(())
        }
        /// Rotates the kill ring and replaces yanked text with the new front.
        pub fn yank_pop(&mut self) -> io::Result<()>
        {
            if let Some((start, end)) = self.read.last_yank
            {
                self.rotate_kill_ring();

                if let Some(kill) = self.read.kill_ring.front().cloned()
                {
                    self.read.last_yank = Some((start, start + kill.len()));
                    self.write.move_to(start)?;
                    self.replace_str_forward(start..end, &kill)?;
                }
            }

            Ok(())
        }
        /// Insert a given character at the current cursor position `n` times.
        pub fn insert(&mut self, n: usize, ch: char) -> io::Result<()>
        {
            if n != 0
            {
                let s = repeat_char(ch, n);
                self.insert_str(&s)?;
            }

            Ok(())
        }
        /// Insert a string at the current cursor position.
        pub fn insert_str(&mut self, s: &str) -> io::Result<()> { self.write.insert_str(s) }
        /// Replaces a range in the buffer and redraws.
        pub fn replace_str_backward<R: RangeArgument<usize>>(&mut self, range: R, s: &str) -> io::Result<()>
        {
            self.replace_str_impl(range, s)?;
            let len = self.write.buffer.len();
            self.write.move_from(len)
        }
        /// Replaces a range in the buffer and redraws.
        pub fn replace_str_forward<R: RangeArgument<usize>>(&mut self, range: R, s: &str) -> io::Result<()>
        {
            self.replace_str_impl(range, s)?;
            self.write.cursor += s.len();
            let len = self.write.buffer.len();
            self.write.move_from(len)
        }
        /// Replaces a range in the buffer and redraws.
        fn replace_str_impl<R: RangeArgument<usize>>(&mut self, range: R, s: &str) -> io::Result<()>
        {
            let start = range.start().cloned().unwrap_or(0);
            let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
            self.write.move_to(start)?;
            let _ = self.write.buffer.drain(start..end);
            let cursor = self.write.cursor;
            self.write.buffer.insert_str(cursor, s);
            self.write.draw_buffer(cursor)?;
            self.write.clear_to_screen_end()
        }
        /// Overwrite `n` characters; assumes `n >= 1`
        fn overwrite(&mut self, n: usize, ch: char) -> io::Result<()>
        {
            let start = self.write.cursor;
            let end = forward_char(n, &self.write.buffer, start);
            {
                let over = &self.write.buffer[start..end];
                let n_chars = over.chars().count();

                if n > n_chars { self.read.overwritten_append += n - n_chars; }

                if !over.is_empty() { self.read.overwritten_chars.push_str(&over); }
            }
            let s = repeat_char(ch, n);
            self.replace_str_forward(start..end, &s)
        }

        fn overwrite_back(&mut self, mut n: usize) -> io::Result<()>
        {
            if self.read.overwritten_append != 0
            {
                let n_del = n.min(self.read.overwritten_append);
                let pos = backward_char(n_del, &self.write.buffer, self.write.cursor);
                let r = pos..self.write.cursor;
                self.delete_range(r)?;
                self.read.overwritten_append -= n_del;
                n -= n_del;
            }

            if n != 0 && !self.read.overwritten_chars.is_empty()
            {
                let n_repl = n.min(self.read.overwritten_chars.chars().count());
                let pos = backward_char(n_repl, &self.write.buffer, self.write.cursor);
                let over_pos = backward_char(n_repl, &self.read.overwritten_chars, self.read.overwritten_chars.len());
                let over = self.read.overwritten_chars.drain(over_pos..).collect::<String>();
                let r = pos..self.write.cursor;
                self.replace_str_backward(r, &over)?;
                n -= n_repl;
            }

            if n != 0 { self.write.backward_char(n)?; }

            Ok(())
        }

        fn push_kill_ring(&mut self, s: String) 
        {
            if self.read.kill_ring.len() == self.read.kill_ring.capacity() 
            {
                self.read.kill_ring.pop_back();
            }
            self.read.kill_ring.push_front(s);
        }

        fn rotate_kill_ring(&mut self) 
        {
            if let Some(kill) = self.read.kill_ring.pop_front() 
            {
                self.read.kill_ring.push_back(kill);
            }
        }

        fn append_kill_ring(&mut self, s: String) 
        {
            if let Some(kill) = self.read.kill_ring.front_mut() 
            {
                kill.push_str(&s);
                return;
            }
            self.push_kill_ring(s);
        }

        fn prepend_kill_ring(&mut self, s: String)
        {
            if let Some(kill) = self.read.kill_ring.front_mut()
            {
                kill.insert_str(0, &s);
                return;
            }

            self.push_kill_ring(s);
        }

        fn backward_word(&mut self, n: usize) -> io::Result<()> 
        {
            let pos = backward_word(n, &self.write.buffer, self.write.cursor, &self.read.word_break);
            self.write.move_to(pos)
        }

        fn forward_word(&mut self, n: usize) -> io::Result<()> 
        {
            let pos = forward_word(n, &self.write.buffer, self.write.cursor, &self.read.word_break);
            self.write.move_to(pos)
        }

        fn expire_blink(&mut self) -> io::Result<()> 
        {
            self.read.max_wait_duration = None;
            self.write.expire_blink()
        }

        fn build_completions(&mut self) 
        {
            let compl = self.read.completer.clone();
            let end = self.write.cursor;
            let start = compl.word_start(&self.write.buffer, end, self);

            if start > end 
            {
                panic!("Completer::word_start returned invalid index; \
                    start > end ({} > {})", start, end);
            }

            let unquoted = compl.unquote(&self.write.buffer[start..end]).into_owned();

            let completions = compl.complete(&unquoted, self, start, end);
            let n_completions = completions.as_ref().map_or(0, |c| c.len());

            self.read.completions = completions;
            self.read.completion_index = n_completions;
            self.read.completion_start = start;
            self.read.completion_prefix = end;
        }

        fn complete_word(&mut self) -> io::Result<()> 
        {
            if let Some(completions) = self.read.completions.take() 
            {
                if completions.len() == 1 {
                    self.substitute_completion(&completions[0])?;
                } else {
                    self.show_completions(&completions)?;
                    self.read.completions = Some(completions);
                }
            } else 
            {
                self.build_completions();
                let completions = self.read.completions.take().unwrap_or_default();

                if completions.len() == 1 
                {
                    self.substitute_completion(&completions[0])?;
                } else if !completions.is_empty() 
                {
                    let start = self.read.completion_start;
                    let end = self.write.cursor;

                    {
                        let pfx = longest_common_prefix(completions.iter()
                            .map(|compl| &compl.completion[..]))
                            .unwrap_or_default();
                        self.replace_str_forward(start..end, &pfx)?;
                    }

                    self.read.completions = Some(completions);
                }
            }

            Ok(())
        }

        fn substitute_completion(&mut self, compl: &Completion) -> io::Result<()> 
        {
            let mut s = self.read.completer.quote(&compl.completion);

            if let Some(suffix) = compl.suffix.with_default(self.read.completion_append_character) 
            {
                s.to_mut().push(suffix);
            }

            let start = self.read.completion_start;
            let end = self.write.cursor;
            self.replace_str_forward(start..end, &s)
        }

        fn insert_completions(&mut self, completions: &[Completion]) -> io::Result<()> 
        {
            let mut words = String::new();

            for compl in completions 
            {
                words.push_str(&self.read.completer.unquote(&compl.completion));
                words.push(' ');
            }

            let start = self.read.completion_start;
            let end = self.write.cursor;

            self.replace_str_forward(start..end, &words)
        }

        fn show_completions(&mut self, completions: &[Completion]) -> io::Result<()> 
        {
            if completions.is_empty() 
            {
                return Ok(());
            }

            let eff_width = self.write.screen_size.columns
                .min(self.read.completion_display_width);

            let completions = completions.iter()
                .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                .collect::<Vec<_>>();

            let cols = format_columns(&completions, eff_width,
                self.read.print_completions_horizontally);
            let table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                self.read.print_completions_horizontally);

            self.write.write_str("\n")?;

            let n_completions = completions.len();

            if self.read.page_completions && n_completions >= self.read.completion_query_items 
            {
                self.start_page_completions(n_completions)
            } else 
            {
                self.show_list_completions(table)?;
                self.write.draw_prompt()
            }
        }

        fn start_page_completions(&mut self, n_completions: usize) -> io::Result<()> 
        {
            self.read.state = InputState::CompleteIntro;
            self.write.redraw_prompt(PromptType::CompleteIntro(n_completions))
        }

        fn end_page_completions(&mut self) -> io::Result<()> 
        {
            self.read.state = InputState::NewSequence;
            self.write.prompt_type = PromptType::Normal;
            self.write.draw_prompt()
        }

        fn is_paging_completions(&self) -> bool 
        {
            match self.read.state 
            {
                InputState::CompleteMore(_) => true,
                _ => false
            }
        }

        fn show_completions_page(&mut self, offset: usize) -> io::Result<()> 
        {
            if let Some(compl) = self.read.completions.take() 
            {
                let width = self.write.screen_size.columns
                    .min(self.read.completion_display_width);
                let n_lines = self.write.screen_size.lines - 1;

                let completions = compl.iter()
                    .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                    .collect::<Vec<_>>();

                let cols = format_columns(&completions, width,
                    self.read.print_completions_horizontally);
                let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                    self.read.print_completions_horizontally);

                for row in table.by_ref().skip(offset).take(n_lines) 
                {
                    self.show_completion_line(row)?;
                }

                if table.has_more() 
                {
                    self.read.completions = Some(compl);
                    self.read.state = InputState::CompleteMore(offset + n_lines);
                    self.write.prompt_type = PromptType::CompleteMore;
                    self.write.draw_prompt()?;
                } else 
                {
                    self.end_page_completions()?;
                }
            }

            Ok(())
        }

        fn show_completions_line(&mut self, offset: usize) -> io::Result<()> 
        {
            if let Some(compl) = self.read.completions.take() 
            {
                let width = self.write.screen_size.columns
                    .min(self.read.completion_display_width);
                let completions = compl.iter()
                    .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                    .collect::<Vec<_>>();

                let cols = format_columns(&completions, width,
                    self.read.print_completions_horizontally);
                let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                    self.read.print_completions_horizontally);

                if let Some(row) = table.by_ref().skip(offset).next() 
                {
                    self.show_completion_line(row)?;
                }

                if table.has_more() 
                {
                    self.read.completions = Some(compl);
                    self.read.state = InputState::CompleteMore(offset + 1);
                    self.write.prompt_type = PromptType::CompleteMore;
                    self.write.draw_prompt()?;
                } else 
                {
                    self.end_page_completions()?;
                }
            }

            Ok(())
        }

        fn show_completion_line<S: AsRef<str>>(&mut self, line: Line<S>) -> io::Result<()> 
        {
            let mut space = 0;

            for (width, name) in line 
            {
                self.write.move_right(space)?;
                self.write.write_str(name)?;
                space = width - name.chars().count();
            }

            self.write.write_str("\n")
        }

        fn show_list_completions<S: AsRef<str>>(&mut self, table: Table<S>) -> io::Result<()> 
        {
            for line in table 
            {
                let mut space = 0;

                for (width, name) in line 
                {
                    self.write.move_right(space)?;
                    self.write.write_str(name)?;
                    space = width - name.chars().count();
                }
                self.write.write_str("\n")?;
            }

            Ok(())
        }

        fn next_completion(&mut self, n: usize) -> io::Result<()> 
        {
            let len = self.read.completions.as_ref().map_or(0, |c| c.len());
            let max = len + 1;

            let old = self.read.completion_index;
            let new = (old + n) % max;

            if old != new 
            {
                self.set_completion(new)?;
            }

            Ok(())
        }

        fn prev_completion(&mut self, n: usize) -> io::Result<()> 
        {
            let len = self.read.completions.as_ref().map_or(0, |c| c.len());
            let max = len + 1;

            let old = self.read.completion_index;
            let new = if n <= old 
            {
                max - old - n
            } else 
            {
                old - n
            };

            self.set_completion(new)
        }

        fn set_completion(&mut self, new: usize) -> io::Result<()> 
        {
            let len = self.read.completions.as_ref().map_or(0, |c| c.len());
            let old = self.read.completion_index;

            if old != new 
            {
                self.read.completion_index = new;

                if new == len 
                {
                    let start = self.read.completion_prefix;
                    let end = self.write.cursor;

                    self.delete_range(start..end)?;
                } else 
                {
                    let start = self.read.completion_start;
                    let end = self.write.cursor;
                    let s = self.read.completions.as_ref().unwrap()[new]
                        .completion(self.read.completion_append_character).into_owned();

                    self.replace_str_forward(start..end, &s)?;
                }
            }

            Ok(())
        }

        fn abort_search_history(&mut self) -> io::Result<()> 
        {
            self.read.state = InputState::NewSequence;
            self.read.last_cmd = Category::Other;
            self.write.abort_search_history()
        }

        fn end_search_history(&mut self) -> io::Result<()> 
        {
            self.read.state = InputState::NewSequence;
            self.write.end_search_history()
        }

        fn check_expire_blink(&mut self, now: Instant) -> io::Result<()>
        {
            if self.write.check_expire_blink(now)? { self.read.max_wait_duration = None; }
            Ok(())
        }

        fn check_expire_sequence(&mut self, now: Instant) -> io::Result<()> 
        {
            if let InputState::ContinueSequence{expiry: Some(expiry)} = self.read.state 
            {
                if now >= expiry 
                {
                    self.read.max_wait_duration = None;
                    self.force_execute_sequence()?;
                }
            }

            Ok(())
        }

        fn keyseq_expiry(&mut self) -> Option<Instant> 
        {
            if let Some(t) = self.read.keyseq_timeout 
            {
                self.read.max_wait_duration = Some(t);
                Some(Instant::now() + t)
            } else {
                None
            }
        }
        /// Attempts to execute the current sequence.
        fn execute_sequence(&mut self) -> io::Result<()>
        {
            match self.find_binding(&self.read.sequence)
            {
                FindResult::Found(cmd) => {
                    let ch = self.read.sequence.chars().last().unwrap();
                    let n = self.write.input_arg.to_i32();

                    self.read.state = InputState::NewSequence;
                    self.execute_command(cmd, n, ch)?;
                    self.read.sequence.clear();
                }
                FindResult::NotFound => {
                    self.read.state = InputState::NewSequence;
                    self.insert_first_char()?;
                }
                FindResult::Incomplete => {
                    let expiry = None;
                    self.read.state = InputState::ContinueSequence{expiry};
                }
                FindResult::Undecided(_) => {
                    let expiry = self.keyseq_expiry();
                    self.read.state = InputState::ContinueSequence{expiry};
                }
            }

            Ok(())
        }

        fn force_execute_sequence(&mut self) -> io::Result<()>
        {
            self.read.state = InputState::NewSequence;

            match self.find_binding(&self.read.sequence) {
                FindResult::Found(cmd) |
                FindResult::Undecided(cmd) => {
                    let ch = self.read.sequence.chars().last().unwrap();
                    let n = self.write.input_arg.to_i32();

                    self.execute_command(cmd, n, ch)?;
                    self.read.sequence.clear();
                }
                FindResult::NotFound => {
                    self.insert_first_char()?;
                }
                FindResult::Incomplete => unreachable!(),
            }

            Ok(())
        }
        /// Execute the command `SelfInsert` on the first character in the input sequence, if it is printable.
        fn insert_first_char(&mut self) -> io::Result<()>
        {
            let (first, rest) = {
                let mut chars = self.read.sequence.chars();

                (chars.next().unwrap(), chars.as_str().to_owned())
            };

            self.read.sequence.clear();

            if is_printable(first) {
                let n = self.write.input_arg.to_i32();
                self.execute_command(Command::SelfInsert, n, first)?;
            }

            if !rest.is_empty() {
                self.read.queue_input(&rest);
            }

            Ok(())
        }

        fn find_binding(&self, seq: &str) -> FindResult<Command> { self.read.bindings.find(seq).cloned() }

        fn get_function(&self, name: &str) -> Option<&Arc<dyn Function<Term>>> { self.read.functions.get(name) }

        fn is_abort(&self, ch: char) -> bool
        {
            let mut buf = [0; 4];
            let s = ch.encode_utf8(&mut buf);
            self.find_binding(&s) == FindResult::Found(Command::Abort)
        }

        fn execute_command(&mut self, cmd: Command, n: i32, ch: char) -> io::Result<()>
        {
            use ::command::Command::*;

            let mut category = cmd.category();

            if self.read.overwrite_mode
            {
                match cmd
                {
                    DigitArgument | SelfInsert => (),
                    BackwardDeleteChar if n >= 0 => (),
                    _ => self.read.overwritten_chars.clear()
                }
            }

            match cmd
            {
                Abort => (),
                AcceptLine => {
                    self.accept_input()?;
                }
                Complete => {
                    if !self.read.disable_completion {
                        self.complete_word()?;
                    } else if is_printable(ch) {
                        self.execute_command(SelfInsert, n, ch)?;
                    }
                }
                InsertCompletions => {
                    if self.read.completions.is_none() {
                        self.build_completions();
                    }

                    if let Some(completions) = self.read.completions.take() {
                        self.insert_completions(&completions)?;
                        self.read.completions = Some(completions);
                    }
                }
                PossibleCompletions => {
                    if self.read.completions.is_none() {
                        self.build_completions();
                    }

                    if let Some(completions) = self.read.completions.take() {
                        self.show_completions(&completions)?;
                        self.read.completions = Some(completions);
                    }
                }
                MenuComplete => {
                    if self.read.completions.is_none() {
                        self.build_completions();
                    }

                    if n > 0 {
                        self.next_completion(n as usize)?;
                    } else {
                        self.prev_completion((-n) as usize)?;
                    }
                }
                MenuCompleteBackward => {
                    if self.read.completions.is_none() {
                        self.build_completions();
                    }

                    if n > 0 {
                        self.prev_completion(n as usize)?;
                    } else {
                        self.next_completion((-n) as usize)?;
                    }
                }
                DigitArgument => {
                    self.read.state = InputState::Number;
                    self.write.set_digit_from_char(ch);
                    self.write.redraw_prompt(PromptType::Number)?;
                }
                SelfInsert => {
                    if n > 0 {
                        let n = n as usize;

                        if self.read.overwrite_mode {
                            self.overwrite(n, ch)?;
                        } else {
                            self.insert(n, ch)?;
                        }

                        if self.read.blink_matching_paren {
                            if let Some(open) = get_open_paren(ch) {
                                if let Some(pos) = find_matching_paren(
                                        &self.write.buffer[..self.write.cursor],
                                        &self.read.string_chars, open, ch) {
                                    self.blink(pos)?;
                                }
                            }
                        }
                    }
                }
                TabInsert => {
                    if n > 0 {
                        self.insert(n as usize, '\t')?;
                    }
                }
                InsertComment => 
                {
                    if self.explicit_arg() &&
                            self.write.buffer.starts_with(&self.read.comment_begin[..]) {
                        self.write.move_to(0)?;
                        let n = self.read.comment_begin.len();

                        self.delete_range(..n)?;
                        self.accept_input()?;
                    } else {
                        self.write.move_to(0)?;
                        let s = self.read.comment_begin.clone();
                        self.insert_str(&s)?;
                        self.accept_input()?;
                    }
                }
                BackwardChar => {
                    if n > 0 {
                        self.write.backward_char(n as usize)?;
                    } else if n < 0 {
                        self.write.forward_char((-n) as usize)?;
                    }
                }
                ForwardChar => {
                    if n > 0 {
                        self.write.forward_char(n as usize)?;
                    } else if n < 0 {
                        self.write.backward_char((-n) as usize)?;
                    }
                }
                CharacterSearch => {
                    if n >= 0 {
                        self.read.state = InputState::CharSearch{
                            n: n as usize,
                            backward: false,
                        }
                    } else {
                        self.read.state = InputState::CharSearch{
                            n: (-n) as usize,
                            backward: true,
                        };
                    }
                }
                CharacterSearchBackward => {
                    if n >= 0 {
                        self.read.state = InputState::CharSearch{
                            n: n as usize,
                            backward: true,
                        }
                    } else {
                        self.read.state = InputState::CharSearch{
                            n: (-n) as usize,
                            backward: false,
                        };
                    }
                }
                BackwardWord => {
                    if n > 0 {
                        self.backward_word(n as usize)?;
                    } else if n < 0 {
                        self.forward_word((-n) as usize)?;
                    }
                }
                ForwardWord => {
                    if n > 0 {
                        let pos = forward_word(n as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        self.write.move_to(pos)?;
                    } else if n < 0 {
                        let pos = forward_word((-n) as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        self.write.move_to(pos)?;
                    }
                }
                BackwardKillLine => {
                    let r = ..self.write.cursor;
                    self.kill_range(r)?;
                }
                KillLine => {
                    let r = self.write.cursor..;
                    self.kill_range(r)?;
                }
                BackwardKillWord => {
                    if n > 0 {
                        let pos = ::char::backward(n as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        let r = pos..self.write.cursor;
                        self.kill_range(r)?;
                    } else if n < 0 {
                        let pos = forward_word((-n) as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        let r = self.write.cursor..pos;
                        self.kill_range(r)?;
                    }
                }
                KillWord => {
                    if n > 0 {
                        let pos = forward_word(n as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        let r = self.write.cursor..pos;
                        self.kill_range(r)?;
                    } else if n < 0 {
                        let pos = ::char::backward((-n) as usize,
                            &self.write.buffer, self.write.cursor, &self.read.word_break);
                        let r = pos..self.write.cursor;
                        self.kill_range(r)?;
                    }
                }
                UnixWordRubout => {
                    if n > 0 {
                        let pos = ::char::backward(n as usize,
                            &self.write.buffer, self.write.cursor, " \t\n");
                        let r = pos..self.write.cursor;
                        self.kill_range(r)?;
                    } else if n < 0 {
                        let pos = forward_word((-n) as usize,
                            &self.write.buffer, self.write.cursor, " \t\n");
                        let r = self.write.cursor..pos;
                        self.kill_range(r)?;
                    }
                }
                ClearScreen => {
                    self.write.clear_screen()?;
                }
                BeginningOfLine => self.write.move_to(0)?,
                EndOfLine => self.write.move_to_end()?,
                BackwardDeleteChar => {
                    if n > 0 {
                        if self.read.overwrite_mode {
                            self.overwrite_back(n as usize)?;
                        } else {
                            let pos = ::char::backward(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = pos..self.write.cursor;
                            self.delete_range(r)?;
                        }
                    } else if n < 0 {
                        let pos = ::char::forward((-n) as usize,
                            &self.write.buffer, self.write.cursor);
                        let r = self.write.cursor..pos;
                        self.delete_range(r)?;
                    }
                }
                DeleteChar => {
                    if n > 0 {
                        let pos = ::char::forward(n as usize,
                            &self.write.buffer, self.write.cursor);
                        let r = self.write.cursor..pos;
                        self.delete_range(r)?;
                    } else if n < 0 {
                        let pos = ::char::backward(n as usize,
                            &self.write.buffer, self.write.cursor);
                        let r = pos..self.write.cursor;
                        self.delete_range(r)?;
                    }
                }
                TransposeChars => {
                    if n != 0 && self.write.cursor != 0 {
                        let (src, dest);

                        if !self.explicit_arg() && self.write.cursor == self.write.buffer.len() {
                            let end = backward_char(1, &self.write.buffer, self.write.cursor);
                            let start = backward_char(1, &self.write.buffer, end);

                            src = start..end;
                            dest = end..self.write.cursor;
                        } else {
                            let start = ::char::backward(1, &self.write.buffer, self.write.cursor);
                            let end = self.write.cursor;

                            src = start..end;

                            dest = if n < 0 {
                                let back = backward_char((-n) as usize, &self.write.buffer, start);
                                back..start
                            } else {
                                let fwd = ::char::forward(n as usize + 1, &self.write.buffer, start);
                                end..fwd
                            };
                        }

                        self.transpose_range(src, dest)?;
                    }
                }
                TransposeWords => {
                    if n != 0 {
                        if let Some(first) = first_word(&self.write.buffer[..self.write.cursor], &self.read.word_break) {
                            let start = word_start(&self.write.buffer, self.write.cursor, &self.read.word_break);

                            if first != start {
                                let (src, dest);

                                if !self.explicit_arg() && start == self.write.buffer.len() {
                                    let dest_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                    let dest_end = word_end(&self.write.buffer, dest_start, &self.read.word_break);

                                    let src_start = backward_word(1, &self.write.buffer, dest_start, &self.read.word_break);
                                    let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                    src = src_start..src_end;
                                    dest = dest_start..dest_end;
                                } else {
                                    let src_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                    let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                    src = src_start..src_end;

                                    dest = if n < 0 {
                                        back_n_words((-n) as usize, &self.write.buffer, src_start, &self.read.word_break)
                                    } else {
                                        forward_n_words(n as usize, &self.write.buffer, src_start, &self.read.word_break)
                                    };
                                }

                                self.transpose_range(src, dest)?;
                            }
                        }
                    }
                }
                BeginningOfHistory => {
                    self.select_history_entry(Some(0))?;
                }
                EndOfHistory => {
                    self.select_history_entry(None)?;
                }
                NextHistory => {
                    if n > 0 {
                        self.next_history(n as usize)?;
                    } else if n < 0 {
                        self.prev_history((-n) as usize)?;
                    }
                }
                PreviousHistory => {
                    if n > 0 {
                        self.prev_history(n as usize)?;
                    } else if n < 0 {
                        self.next_history((-n) as usize)?;
                    }
                }
                ForwardSearchHistory => {
                    self.read.state = InputState::TextSearch;
                    if self.read.last_cmd == Category::IncrementalSearch {
                        self.write.continue_search_history(false)?;
                    } else {
                        self.write.start_search_history(false)?;
                    }
                }
                ReverseSearchHistory => {
                    self.read.state = InputState::TextSearch;
                    if self.read.last_cmd == Category::IncrementalSearch {
                        self.write.continue_search_history(true)?;
                    } else {
                        self.write.start_search_history(true)?;
                    }
                }
                HistorySearchForward => {
                    if self.read.last_cmd == Category::Search {
                        self.write.continue_history_search(false)?;
                    } else {
                        self.write.start_history_search(false)?;
                    }
                }
                HistorySearchBackward => {
                    if self.read.last_cmd == Category::Search {
                        self.write.continue_history_search(true)?;
                    } else {
                        self.write.start_history_search(true)?;
                    }
                }
                QuotedInsert => {
                    self.read.state = InputState::QuotedInsert(
                        if n >= 0 { n as usize } else { 0 });
                }
                OverwriteMode => {
                    self.read.overwrite_mode = !self.read.overwrite_mode;

                    if !self.read.overwrite_mode {
                        self.read.overwritten_append = 0;
                        self.read.overwritten_chars.clear();
                    }

                    let mode = if self.read.overwrite_mode {
                        CursorMode::Overwrite
                    } else {
                        CursorMode::Normal
                    };

                    self.write.set_cursor_mode(mode)?;
                }
                Yank => {
                    self.yank()?;
                }
                YankPop => {
                    self.yank_pop()?;
                }
                Custom(ref name) => {
                    if let Some(fun) = self.get_function(name).cloned() {
                        fun.execute(self, n, ch)?;

                        category = fun.category();
                    }
                }
                Macro(ref seq) => {
                    self.read.queue_input(seq);
                }
            }

            if category != Category::Digit
            {
                self.write.input_arg = Digit::None;
                self.write.explicit_arg = false;

                self.read.last_cmd = category;

                if category != Category::Complete { self.read.completions = None; }

                if category != Category::Yank { self.read.last_yank = None; }
            }

            Ok(())
        }

        fn next_history(&mut self, n: usize) -> io::Result<()> { self.write.next_history(n) }

        fn prev_history(&mut self, n: usize) -> io::Result<()> { self.write.prev_history(n) }
        /// Resets input state at the start of `read_line`
        fn reset_input(&mut self)
        {
            self.read.reset_data();
            self.write.reset_data();
        }
    }
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod reader
{
    //! Provides access to terminal read operations
    use ::
    {
        borrow::{ Cow },
        collections::{ HashMap, SequenceMap, VecDeque },
        complete::{ Completer, Completion, DummyCompleter },
        command::{ Category, Command },
        mem::{ replace },
        ops::{ Deref, DerefMut },
        path::{ Path, PathBuf },
        signals::{ Signal },
        sync::{ Arc, MutexGuard },
        terminal::{ Terminals },
        time::{ Duration, Instant },
        *,
    };
    /*
    use crate::command::{Category, Command};
    use crate::complete::{Completer, Completion, DummyCompleter};
    use crate::function::Function;
    use crate::inputrc::{parse_file, Directive};
    use crate::interface::Interface;
    use crate::prompter::Prompter;
    use crate::sys::path::{env_init_file, system_init_file, user_init_file};
    use crate::terminal::{
        RawRead, Signal, SignalSet, Size,
        Terminal, TerminalReader,
    };
    use crate::util::{first_char, match_name};
    use crate::variables::{Variable, Variables, VariableIter};
    */
    /// Default set of string characters
    pub const STRING_CHARS: &str = "\"'";

    /// Default set of word break characters
    pub const WORD_BREAK_CHARS: &str = " \t\n\"\\'`@$><=;|&{(";

    /// Indicates the start of a series of invisible characters in the prompt
    pub const START_INVISIBLE: char = '\x01';

    /// Indicates the end of a series of invisible characters in the prompt
    pub const END_INVISIBLE: char = '\x02';

    /// Maximum size of kill ring
    const MAX_KILLS: usize = 10;

    /// Provides access to data related to reading and processing user input.
    ///
    /// Holds a lock on terminal read operations.
    /// See [`Interface`] for more information about concurrent operations.
    ///
    /// An instance of this type can be constructed using the
    /// [`Interface::lock_reader`] method.
    ///
    /// [`Interface`]: ../interface/struct.Interface.html
    /// [`Interface::lock_reader`]: ../interface/struct.Interface.html#method.lock_reader
    pub struct Reader<'a, Term: 'a + Terminals> {
        iface: &'a Interface<Term>,
        lock: ReadLock<'a, Term>,
    }

    pub struct Read<Term:Terminals> {
        /// Application name
        pub application: Cow<'static, str>,

        /// Pending input
        pub input_buffer: Vec<u8>,
        /// Pending macro sequence
        pub macro_buffer: String,

        pub bindings: SequenceMap<Cow<'static, str>, Command>,
        pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,

        /// Current input sequence
        pub sequence: String,
        /// Whether newline has been received
        pub input_accepted: bool,

        /// Whether overwrite mode is currently active
        pub overwrite_mode: bool,
        /// Characters appended while in overwrite mode
        pub overwritten_append: usize,
        /// Characters overwritten in overwrite mode
        pub overwritten_chars: String,

        /// Configured completer
        pub completer: Arc<dyn Completer<Term>>,
        /// Character appended to completions
        pub completion_append_character: Option<char>,
        /// Current set of possible completions
        pub completions: Option<Vec<Completion>>,
        /// Current "menu-complete" entry being viewed:
        pub completion_index: usize,
        /// Start of the completed word
        pub completion_start: usize,
        /// Start of the inserted prefix of a completed word
        pub completion_prefix: usize,

        pub string_chars: Cow<'static, str>,
        pub word_break: Cow<'static, str>,

        pub last_cmd: Category,
        pub last_yank: Option<(usize, usize)>,
        pub kill_ring: VecDeque<String>,

        pub catch_signals: bool,
        pub ignore_signals: SignalSet,
        pub report_signals: SignalSet,
        pub last_resize: Option<Size>,
        pub last_signal: Option<Signal>,

        variables: Variables,

        pub state: InputState,
        pub max_wait_duration: Option<Duration>,
    }

    pub struct ReadLock<'a, Term: 'a + Terminals> {
        term: Box<dyn TerminalReader<Term> + 'a>,
        data: MutexGuard<'a, Read<Term>>,
    }

    /// Returned from [`read_line`] to indicate user input
    ///
    /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
    #[derive(Debug)]
    pub enum ReadResult {
        /// User issued end-of-file
        Eof,
        /// User input received
        Input(String),
        /// Reported signal was received
        Signal(Signal),
    }

    #[derive(Copy, Clone, Debug)]
    pub enum InputState {
        Inactive,
        NewSequence,
        ContinueSequence{
            expiry: Option<Instant>,
        },
        Number,
        CharSearch{
            n: usize,
            backward: bool,
        },
        TextSearch,
        CompleteIntro,
        CompleteMore(usize),
        QuotedInsert(usize),
    }

    impl<'a, Term: 'a + Terminals> Reader<'a, Term> 
    {
        pub fn new(iface: &'a Interface<Term>, lock: ReadLock<'a, Term>)
                -> Reader<'a, Term> {
            Reader{iface, lock}
        }

        /// Interactively reads a line from the terminal device.
        pub fn read_line(&mut self) -> io::Result<ReadResult> {
            loop {
                if let Some(res) = self.read_line_step(None)? {
                    return Ok(res);
                }
            }
        }
        /// Performs one step of the interactive `read_line` loop.
        pub fn read_line_step(&mut self, timeout: Option<Duration>)
                -> io::Result<Option<ReadResult>> {
            self.initialize_read_line()?;

            let state = self.prepare_term()?;
            let res = self.read_line_step_impl(timeout);
            self.lock.term.restore(state)?;

            res
        }
        /// Cancels an in-progress `read_line` operation.
        pub fn cancel_read_line(&mut self) -> io::Result<()> {
            self.end_read_line()
        }

        fn initialize_read_line(&mut self) -> io::Result<()> {
            if !self.lock.is_active() {
                self.prompter().start_read_line()?;
            }
            Ok(())
        }

        fn read_line_step_impl(&mut self, timeout: Option<Duration>)
                -> io::Result<Option<ReadResult>> {
            let do_read = if self.lock.is_input_available() {
                // This branch will be taken only if a macro has buffered some input.
                // We check for input with a zero duration to see if the user has
                // entered Ctrl-C, e.g. to interrupt an infinitely recursive macro.
                self.lock.term.wait_for_input(Some(Duration::from_secs(0)))?
            } else {
                let timeout = limit_duration(timeout, self.lock.max_wait_duration);
                self.lock.term.wait_for_input(timeout)?
            };

            if do_read {
                self.lock.read_input()?;
            }

            if let Some(size) = self.lock.take_resize() {
                self.handle_resize(size)?;
            }

            if let Some(sig) = self.lock.take_signal() {
                if self.lock.report_signals.contains(sig) {
                    return Ok(Some(ReadResult::Signal(sig)));
                }
                if !self.lock.ignore_signals.contains(sig) {
                    self.handle_signal(sig)?;
                }
            }

            // Acquire the write lock and process all available input
            {
                let mut prompter = self.prompter();

                prompter.check_expire_timeout()?;

                // If the macro buffer grows in size while input is being processed,
                // we end this step and let the caller try again. This is to allow
                // reading Ctrl-C to interrupt (perhaps infinite) macro execution.
                let mut macro_len = prompter.read.data.macro_buffer.len();

                while prompter.read.is_input_available() {
                    if let Some(ch) = prompter.read.read_char()? {
                        if let Some(r) = prompter.handle_input(ch)? {
                            prompter.end_read_line()?;
                            return Ok(Some(r));
                        }
                    }

                    let new_macro_len = prompter.read.data.macro_buffer.len();

                    if new_macro_len != 0 && new_macro_len >= macro_len {
                        break;
                    }

                    macro_len = new_macro_len;
                }
            }

            Ok(None)
        }

        fn end_read_line(&mut self) -> io::Result<()> {
            if self.lock.is_active() {
                self.prompter().end_read_line()?;
            }
            Ok(())
        }

        fn prepare_term(&mut self) -> io::Result<Term::PrepareState> {
            if self.read_next_raw() {
                self.lock.term.prepare(true, SignalSet::new())
            } else {
                let mut signals = self.lock.report_signals.union(self.lock.ignore_signals);

                if self.lock.catch_signals {
                    // Ctrl-C is always intercepted (unless we're catching no signals).
                    // By default, linefeed handles it by clearing the current input state.
                    signals.insert(Signal::Interrupt);
                }

                let block_signals = !self.lock.catch_signals;

                self.lock.term.prepare(block_signals, signals)
            }
        }

        fn read_next_raw(&self) -> bool {
            match self.lock.state {
                InputState::QuotedInsert(_) => true,
                _ => false
            }
        }
        /// Sets the input buffer to the given string.
        pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
            if self.lock.is_active() {
                self.prompter().set_buffer(buf)
            } else {
                self.iface.lock_write_data().set_buffer(buf);
                Ok(())
            }
        }
        /// Sets the cursor position in the input buffer.
        pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
            if self.lock.is_active() {
                self.prompter().set_cursor(pos)
            } else {
                self.iface.lock_write_data().set_cursor(pos);
                Ok(())
            }
        }
        /// Sets the prompt that will be displayed when `read_line` is called.
        pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
            self.prompter().set_prompt(prompt)
        }
        /// Adds a line to history.
        pub fn add_history(&self, line: String) {
            if !self.lock.is_active() {
                self.iface.lock_write().add_history(line);
            }
        }
        /// Adds a line to history, unless it is identical to the most recent entry.
        pub fn add_history_unique(&self, line: String) {
            if !self.lock.is_active() {
                self.iface.lock_write().add_history_unique(line);
            }
        }
        /// Removes all history entries.
        pub fn clear_history(&self) {
            if !self.lock.is_active() {
                self.iface.lock_write().clear_history();
            }
        }
        /// Removes the history entry at the given index.
        pub fn remove_history(&self, idx: usize) {
            if !self.lock.is_active() {
                self.iface.lock_write().remove_history(idx);
            }
        }
        /// Sets the maximum number of history entries.
        pub fn set_history_size(&self, n: usize) {
            if !self.lock.is_active() {
                self.iface.lock_write().set_history_size(n);
            }
        }
        /// Truncates history to the only the most recent `n` entries.
        pub fn truncate_history(&self, n: usize) {
            if !self.lock.is_active() {
                self.iface.lock_write().truncate_history(n);
            }
        }
        /// Returns the application name
        pub fn application(&self) -> &str {
            &self.lock.application
        }
        /// Sets the application name
        pub fn set_application<T>(&mut self, application: T)
                where T: Into<Cow<'static, str>> {
            self.lock.application = application.into();
        }
        /// Returns a reference to the current completer instance.
        pub fn completer(&self) -> &Arc<dyn Completer<Term>> {
            &self.lock.completer
        }
        /// Replaces the current completer, returning the previous instance.
        pub fn set_completer(&mut self, completer: Arc<dyn Completer<Term>>)
                -> Arc<dyn Completer<Term>> {
            replace(&mut self.lock.completer, completer)
        }
        /// Returns the value of the named variable or `None` if no such variable exists.
        pub fn get_variable(&self, name: &str) -> Option<Variable> {
            self.lock.get_variable(name)
        }
        /// Sets the value of the named variable and returns the previous value.
        pub fn set_variable(&mut self, name: &str, value: &str) -> Option<Variable> {
            self.lock.set_variable(name, value)
        }
        /// Returns an iterator over stored variables.
        pub fn variables(&self) -> VariableIter {
            self.lock.variables.iter()
        }
        /// Returns whether to "blink" matching opening parenthesis character 
        /// when a closing parenthesis character is entered.
        pub fn blink_matching_paren(&self) -> bool {
            self.lock.blink_matching_paren
        }
        /// Sets the `blink-matching-paren` variable.
        pub fn set_blink_matching_paren(&mut self, set: bool) {
            self.lock.blink_matching_paren = set;
        }
        /// Returns whether `linefeed` will catch certain signals.
        pub fn catch_signals(&self) -> bool {
            self.lock.catch_signals
        }
        /// Sets whether `linefeed` will catch certain signals.
        pub fn set_catch_signals(&mut self, enabled: bool) {
            self.lock.catch_signals = enabled;
        }
        /// Returns whether the given `Signal` is ignored.
        pub fn ignore_signal(&self, signal: Signal) -> bool {
            self.lock.ignore_signals.contains(signal)
        }
        /// Sets whether the given `Signal` will be ignored.
        pub fn set_ignore_signal(&mut self, signal: Signal, set: bool) {
            if set {
                self.lock.ignore_signals.insert(signal);
                self.lock.report_signals.remove(signal);
            } else {
                self.lock.ignore_signals.remove(signal);
            }
        }
        /// Returns whether the given `Signal` is to be reported.
        pub fn report_signal(&self, signal: Signal) -> bool {
            self.lock.report_signals.contains(signal)
        }
        /// Sets whether to report the given `Signal`.
        pub fn set_report_signal(&mut self, signal: Signal, set: bool) {
            if set {
                self.lock.report_signals.insert(signal);
                self.lock.ignore_signals.remove(signal);
            } else {
                self.lock.report_signals.remove(signal);
            }
        }
        /// Returns whether Tab completion is disabled.
        pub fn disable_completion(&self) -> bool {
            self.lock.disable_completion
        }
        /// Sets the `disable-completion` variable.
        pub fn set_disable_completion(&mut self, disable: bool) {
            self.lock.disable_completion = disable;
        }
        /// When certain control characters are pressed, 
        /// a character sequence equivalent to this character will be echoed.
        pub fn echo_control_characters(&self) -> bool {
            self.lock.echo_control_characters
        }
        /// Sets the `echo-control-characters` variable.
        pub fn set_echo_control_characters(&mut self, echo: bool) {
            self.lock.echo_control_characters = echo;
        }
        /// Returns the character, if any, that is appended to a successful completion.
        pub fn completion_append_character(&self) -> Option<char> {
            self.lock.completion_append_character
        }
        /// Sets the character, if any, that is appended to a successful completion.
        pub fn set_completion_append_character(&mut self, ch: Option<char>) {
            self.lock.completion_append_character = ch;
        }
        /// Returns the width of completion listing display.
        pub fn completion_display_width(&self) -> usize {
            self.lock.completion_display_width
        }
        /// Sets the `completion-display-width` variable.
        pub fn set_completion_display_width(&mut self, n: usize) {
            self.lock.completion_display_width = n;
        }
        /// Returns the minimum number of completion items that require user confirmation before listing.
        pub fn completion_query_items(&self) -> usize {
            self.lock.completion_query_items
        }
        /// Sets the `completion-query-items` variable.
        pub fn set_completion_query_items(&mut self, n: usize) {
            self.lock.completion_query_items = n;
        }
        /// Returns the timeout to wait for further user input when an ambiguous sequence has been entered.
        pub fn keyseq_timeout(&self) -> Option<Duration> {
            self.lock.keyseq_timeout
        }
        /// Sets the `keyseq-timeout` variable.
        pub fn set_keyseq_timeout(&mut self, timeout: Option<Duration>) {
            self.lock.keyseq_timeout = timeout;
        }
        /// Returns whether to list possible completions one page at a time.
        pub fn page_completions(&self) -> bool {
            self.lock.page_completions
        }
        /// Sets the `page-completions` variable.
        pub fn set_page_completions(&mut self, set: bool) {
            self.lock.page_completions = set;
        }
        /// Returns whether to list completions horizontally, rather than down the screen.
        pub fn print_completions_horizontally(&self) -> bool {
            self.lock.print_completions_horizontally
        }
        /// Sets the `print-completions-horizontally` variable.
        pub fn set_print_completions_horizontally(&mut self, set: bool) {
            self.lock.print_completions_horizontally = set;
        }
        /// Returns the set of characters that delimit strings.
        pub fn string_chars(&self) -> &str {
            &self.lock.string_chars
        }
        /// Sets the set of characters that delimit strings.
        pub fn set_string_chars<T>(&mut self, chars: T)
                where T: Into<Cow<'static, str>> {
            self.lock.string_chars = chars.into();
        }
        /// Returns the set of characters that indicate a word break.
        pub fn word_break_chars(&self) -> &str {
            &self.lock.word_break
        }
        /// Sets the set of characters that indicate a word break.
        pub fn set_word_break_chars<T>(&mut self, chars: T)
                where T: Into<Cow<'static, str>> {
            self.lock.word_break = chars.into();
        }
        /// Returns an iterator over bound sequences
        pub fn bindings(&self) -> BindingIter {
            self.lock.bindings()
        }
        /// Binds a sequence to a command.
        pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                where T: Into<Cow<'static, str>> {
            self.lock.bind_sequence(seq, cmd)
        }
        /// Binds a sequence to a command, if and only if the given sequence is not already bound to a command.
        pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool
                where T: Into<Cow<'static, str>> {
            self.lock.bind_sequence_if_unbound(seq, cmd)
        }
        /// Removes a binding for the given sequence.
        pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
            self.lock.unbind_sequence(seq)
        }
        /// Defines a named function to which sequences may be bound.
        pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
            self.lock.define_function(name, cmd)
        }
        /// Removes a function defined with the given name.
        pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
            self.lock.remove_function(name)
        }

        pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
            self.lock.data.evaluate_directives(term, dirs)
        }

        pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
            self.lock.data.evaluate_directive(term, dir)
        }

        fn prompter<'b>(&'b mut self) -> Prompter<'b, 'a, Term> {
            Prompter::new(
                &mut self.lock,
                self.iface.lock_write())
        }

        fn handle_resize(&mut self, size: Size) -> io::Result<()> {
            self.prompter().handle_resize(size)
        }

        fn handle_signal(&mut self, sig: Signal) -> io::Result<()> {
            self.prompter().handle_signal(sig)
        }
    }

    impl<'a, Term: 'a + Terminals> ReadLock<'a, Term> {
        pub fn new(term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>>)
                -> ReadLock<'a, Term> {
            ReadLock{term, data}
        }

        /// Reads the next character of input.
        ///
        /// Performs a non-blocking read from the terminal, if necessary.
        ///
        /// If non-input data was received (e.g. a signal) or insufficient input
        /// is available, `Ok(None)` is returned.
        pub fn read_char(&mut self) -> io::Result<Option<char>> {
            if let Some(ch) = self.macro_pop() {
                Ok(Some(ch))
            } else if let Some(ch) = self.decode_input()? {
                Ok(Some(ch))
            } else {
                Ok(None)
            }
        }

        fn read_input(&mut self) -> io::Result<()> {
            match self.term.read(&mut self.data.input_buffer)? {
                RawRead::Bytes(_) => (),
                RawRead::Resize(new_size) => {
                    self.last_resize = Some(new_size);
                }
                RawRead::Signal(sig) => {
                    self.last_signal = Some(sig);
                }
            }

            Ok(())
        }

        fn is_input_available(&self) -> bool {
            !self.data.macro_buffer.is_empty() || match self.peek_input() {
                Ok(Some(_)) | Err(_) => true,
                Ok(None) => false
            }
        }

        fn macro_pop(&mut self) -> Option<char> {
            if self.data.macro_buffer.is_empty() {
                None
            } else {
                Some(self.data.macro_buffer.remove(0))
            }
        }

        fn decode_input(&mut self) -> io::Result<Option<char>> {
            let res = self.peek_input();

            if let Ok(Some(ch)) = res {
                self.data.input_buffer.drain(..ch.len_utf8());
            }

            res
        }

        fn peek_input(&self) -> io::Result<Option<char>> {
            if self.data.input_buffer.is_empty() {
                Ok(None)
            } else {
                ::char::first(&self.data.input_buffer)
            }
        }

        pub fn reset_data(&mut self) {
            self.data.reset_data();
        }
    }

    impl<'a, Term: 'a + Terminals> Deref for ReadLock<'a, Term> {
        type Target = Read<Term>;

        fn deref(&self) -> &Read<Term> {
            &self.data
        }
    }

    impl<'a, Term: 'a + Terminals> DerefMut for ReadLock<'a, Term> {
        fn deref_mut(&mut self) -> &mut Read<Term> {
            &mut self.data
        }
    }

    impl<Term:Terminals> Deref for Read<Term> {
        type Target = Variables;

        fn deref(&self) -> &Variables {
            &self.variables
        }
    }

    impl<Term:Terminals> DerefMut for Read<Term> {
        fn deref_mut(&mut self) -> &mut Variables {
            &mut self.variables
        }
    }

    impl<Term:Terminals> Read<Term>
    {
        pub fn new(term: &Term, application: Cow<'static, str>) -> Read<Term> {
            let mut r = Read{
                application,

                bindings: default_bindings(),
                functions: HashMap::new(),

                input_buffer: Vec::new(),
                macro_buffer: String::new(),

                sequence: String::new(),
                input_accepted: false,

                overwrite_mode: false,
                overwritten_append: 0,
                overwritten_chars: String::new(),

                completer: Arc::new(DummyCompleter),
                completion_append_character: Some(' '),
                completions: None,
                completion_index: 0,
                completion_start: 0,
                completion_prefix: 0,

                string_chars: STRING_CHARS.into(),
                word_break: WORD_BREAK_CHARS.into(),

                last_cmd: Category::Other,
                last_yank: None,
                kill_ring: VecDeque::with_capacity(MAX_KILLS),

                catch_signals: true,
                ignore_signals: SignalSet::new(),
                report_signals: SignalSet::new(),
                last_resize: None,
                last_signal: None,

                variables: Variables::default(),

                state: InputState::Inactive,
                max_wait_duration: None,
            };

            r.read_init(term);
            r
        }

        pub fn bindings(&self) -> BindingIter {
            BindingIter(self.bindings.sequences().iter())
        }

        pub fn variables(&self) -> VariableIter {
            self.variables.iter()
        }

        fn take_resize(&mut self) -> Option<Size> {
            self.last_resize.take()
        }

        fn take_signal(&mut self) -> Option<Signal> {
            self.last_signal.take()
        }

        pub fn queue_input(&mut self, seq: &str) {
            self.macro_buffer.insert_str(0, seq);
        }

        pub fn is_active(&self) -> bool {
            match self.state {
                InputState::Inactive => false,
                _ => true
            }
        }

        pub fn reset_data(&mut self) {
            self.state = InputState::NewSequence;
            self.input_accepted = false;
            self.overwrite_mode = false;
            self.overwritten_append = 0;
            self.overwritten_chars.clear();
            self.sequence.clear();

            self.completions = None;

            self.last_cmd = Category::Other;
            self.last_yank = None;

            self.last_resize = None;
            self.last_signal = None;
        }

        pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                where T: Into<Cow<'static, str>> {
            self.bindings.insert(seq.into(), cmd)
        }

        pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool where
        T: Into<Cow<'static, str>>
        {
            match self.bindings.entry(seq.into())
            {
                Entry::Occupied(_) => false,
                Entry::Vacant(ent) => {
                    ent.insert(cmd);
                    true
                }
            }
        }

        pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
            self.bindings.remove(seq)
                .map(|(_, cmd)| cmd)
        }

        pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
            self.functions.insert(name.into(), cmd)
        }

        pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
            self.functions.remove(name)
        }

        fn read_init(&mut self, term: &Term) {
            if let Some(path) = env_init_file() {
                // If `INPUTRC` is present, even if invalid, parse nothing else.
                // Thus, an empty `INPUTRC` will inhibit loading configuration.
                self.read_init_file_if_exists(term, Some(path));
            } else {
                if !self.read_init_file_if_exists(term, user_init_file()) {
                    self.read_init_file_if_exists(term, system_init_file());
                }
            }
        }

        fn read_init_file_if_exists(&mut self, term: &Term, path: Option<PathBuf>) -> bool {
            match path {
                Some(ref path) if path.exists() => {
                    self.read_init_file(term, path);
                    true
                }
                _ => false
            }
        }

        fn read_init_file(&mut self, term: &Term, path: &Path) {
            if let Some(dirs) = parse_file(path) {
                self.evaluate_directives(term, dirs);
            }
        }

        /// Evaluates a series of configuration directives.
        pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
            for dir in dirs {
                self.evaluate_directive(term, dir);
            }
        }

        /// Evaluates a single configuration directive.
        pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
            match dir {
                Directive::Bind(seq, cmd) => {
                    self.bind_sequence(seq, cmd);
                }
                Directive::Conditional{name, value, then_group, else_group} => {
                    let name = name.as_ref().map(|s| &s[..]);

                    if self.eval_condition(term, name, &value) {
                        self.evaluate_directives(term, then_group);
                    } else {
                        self.evaluate_directives(term, else_group);
                    }
                }
                Directive::SetVariable(name, value) => {
                    self.set_variable(&name, &value);
                }
            }
        }

        fn eval_condition(&self, term: &Term, name: Option<&str>, value: &str) -> bool {
            match name {
                None => self.application == value,
                Some("lib") => value == "linefeed",
                Some("mode") => value == "emacs",
                Some("term") => self.term_matches(term, value),
                _ => false
            }
        }

        fn term_matches(&self, term: &Term, value: &str) -> bool {
            match_name(term.name(), value)
        }
    }

    /// Iterator over `Reader` bindings
    pub struct BindingIter<'a>(slice::Iter<'a, (Cow<'static, str>, Command)>);

    impl<'a> ExactSizeIterator for BindingIter<'a> {}

    impl<'a> Iterator for BindingIter<'a> {
        type Item = (&'a str, &'a Command);

        #[inline] fn next(&mut self) -> Option<Self::Item> {
            self.0.next().map(|&(ref s, ref cmd)| (&s[..], cmd))
        }

        #[inline] fn nth(&mut self, n: usize) -> Option<Self::Item> {
            self.0.nth(n).map(|&(ref s, ref cmd)| (&s[..], cmd))
        }

        #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
            self.0.size_hint()
        }
    }

    impl<'a> DoubleEndedIterator for BindingIter<'a> {
        #[inline] fn next_back(&mut self) -> Option<Self::Item> {
            self.0.next_back().map(|&(ref s, ref cmd)| (&s[..], cmd))
        }
    }

    fn default_bindings() -> SequenceMap<Cow<'static, str>, Command> {
        use crate::command::Command::*;

        SequenceMap::from(vec![
            // Carriage return and line feed
            ("\r".into(), AcceptLine),
            ("\n".into(), AcceptLine),

            // Possible sequences for arrow keys, Home, End
            ("\x1b[A".into(), PreviousHistory),
            ("\x1b[B".into(), NextHistory),
            ("\x1b[C".into(), ForwardChar),
            ("\x1b[D".into(), BackwardChar),
            ("\x1b[H".into(), BeginningOfLine),
            ("\x1b[F".into(), EndOfLine),

            // More possible sequences for arrow keys, Home, End
            ("\x1bOA".into(), PreviousHistory),
            ("\x1bOB".into(), NextHistory),
            ("\x1bOC".into(), ForwardChar),
            ("\x1bOD".into(), BackwardChar),
            ("\x1bOH".into(), BeginningOfLine),
            ("\x1bOF".into(), EndOfLine),

            // Possible sequences for Insert, Delete
            ("\x1b[2~".into(), OverwriteMode),
            ("\x1b[3~".into(), DeleteChar),

            // Basic commands
            ("\x01"    .into(), BeginningOfLine),           // Ctrl-A
            ("\x02"    .into(), BackwardChar),              // Ctrl-B
            ("\x04"    .into(), DeleteChar),                // Ctrl-D
            ("\x05"    .into(), EndOfLine),                 // Ctrl-E
            ("\x06"    .into(), ForwardChar),               // Ctrl-F
            ("\x07"    .into(), Abort),                     // Ctrl-G
            ("\x08"    .into(), BackwardDeleteChar),        // Ctrl-H
            ("\x0b"    .into(), KillLine),                  // Ctrl-K
            ("\x0c"    .into(), ClearScreen),               // Ctrl-L
            ("\x0e"    .into(), NextHistory),               // Ctrl-N
            ("\x10"    .into(), PreviousHistory),           // Ctrl-P
            ("\x12"    .into(), ReverseSearchHistory),      // Ctrl-R
            ("\x14"    .into(), TransposeChars),            // Ctrl-T
            ("\x15"    .into(), BackwardKillLine),          // Ctrl-U
            ("\x16"    .into(), QuotedInsert),              // Ctrl-V
            ("\x17"    .into(), UnixWordRubout),            // Ctrl-W
            ("\x19"    .into(), Yank),                      // Ctrl-Y
            ("\x1d"    .into(), CharacterSearch),           // Ctrl-]
            ("\x7f"    .into(), BackwardDeleteChar),        // Rubout
            ("\x1b\x08".into(), BackwardKillWord),          // Escape, Ctrl-H
            ("\x1b\x1d".into(), CharacterSearchBackward),   // Escape, Ctrl-]
            ("\x1b\x7f".into(), BackwardKillWord),          // Escape, Rubout
            ("\x1bb"   .into(), BackwardWord),              // Escape, b
            ("\x1bd"   .into(), KillWord),                  // Escape, d
            ("\x1bf"   .into(), ForwardWord),               // Escape, f
            ("\x1bt"   .into(), TransposeWords),            // Escape, t
            ("\x1by"   .into(), YankPop),                   // Escape, y
            ("\x1b#"   .into(), InsertComment),             // Escape, #
            ("\x1b<"   .into(), BeginningOfHistory),        // Escape, <
            ("\x1b>"   .into(), EndOfHistory),              // Escape, >

            // Completion commands
            ("\t"   .into(), Complete),             // Tab
            ("\x1b?".into(), PossibleCompletions),  // Escape, ?
            ("\x1b*".into(), InsertCompletions),    // Escape, *

            // Digit commands
            ("\x1b-".into(), DigitArgument),    // Escape, -
            ("\x1b0".into(), DigitArgument),    // Escape, 0
            ("\x1b1".into(), DigitArgument),    // Escape, 1
            ("\x1b2".into(), DigitArgument),    // Escape, 2
            ("\x1b3".into(), DigitArgument),    // Escape, 3
            ("\x1b4".into(), DigitArgument),    // Escape, 4
            ("\x1b5".into(), DigitArgument),    // Escape, 5
            ("\x1b6".into(), DigitArgument),    // Escape, 6
            ("\x1b7".into(), DigitArgument),    // Escape, 7
            ("\x1b8".into(), DigitArgument),    // Escape, 8
            ("\x1b9".into(), DigitArgument),    // Escape, 9
        ])
    }

    fn limit_duration(dur: Option<Duration>, max: Option<Duration>) -> Option<Duration> {
        match (dur, max) {
            (dur, None) | (None, dur) => dur,
            (Some(dur), Some(max)) => Some(dur.min(max)),
        }
    }
}

pub mod regex
{
    pub use ::re::{ * };

    use ::
    {
        iter::{ drop_while },
        ops::{Range, RangeFrom, RangeFull, RangeTo},
        *,
    };

    pub fn contains( text: &str, ptn: &str ) -> bool
    {
        let re = match regex::Regex::new(ptn)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println!("Regex new error: {:?}", e);
                return false;
            }
        };
        
        re.is_match(text)
    }

    pub fn find_first_group(ptn: &str, text: &str) -> Option<String>
    {
        let re = match regex::Regex::new(ptn) {
            Ok(x) => x,
            Err(_) => return None,
        };
        match re.captures(text) {
            Some(caps) => {
                if let Some(x) = caps.get(1) {
                    return Some(x.as_str().to_owned());
                }
            }
            None => {
                return None;
            }
        }
        None
    }

    pub fn replace_all(text: &str, ptn: &str, ptn_to: &str) -> String
    {
        let re = regex::Regex::new(ptn).unwrap();
        let result = re.replace_all(text, ptn_to);
        result.to_string()
    }

    pub fn get_open_paren(ch: char) -> Option<char>
    {
        match ch
        {
            ')' => Some('('),
            ']' => Some('['),
            '}' => Some('{'),
            _ => None
        }
    }

    pub fn find_matching_paren(s: &str, quotes: &str, open: char, close: char) -> Option<usize>
    {
        let mut chars = s.char_indices().rev();
        let mut level = 0;
        let mut string_delim = None;

        while let Some((ind, ch)) = chars.next() {
            if string_delim == Some(ch) {
                string_delim = None;
            } else if quotes.contains(ch) {
                string_delim = Some(ch);
            } else if string_delim.is_none() && ch == close {
                level += 1;
            } else if string_delim.is_none() && ch == open {
                level -= 1;

                if level == 0 {
                    return Some(ind);
                }
            }
        }

        None
    }

    pub fn match_name(name: &str, value: &str) -> bool
    {
        name == value || (name.starts_with(value) && name.as_bytes()[value.len()] == b'-')
    }

    pub fn backward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
    {
        let mut chars = buf[..cur].char_indices().rev();

        for _ in 0..n {
            drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
        }

        match chars.next() {
            Some((ind, ch)) => ind + ch.len_utf8(),
            None => 0
        }
    }

    pub fn forward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        for _ in 0..n {
            drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
        }

        match chars.next() {
            Some((ind, _)) => cur + ind,
            None => buf.len()
        }
    }

    pub fn back_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize>
    {
        let prev = backward_word(1, buf, cur, word_break);
        let end = word_end(&buf, prev, word_break);

        if n > 1 {
            let start = backward_word(n - 1, buf, prev, word_break);
            start..end
        } else {
            prev..end
        }
    }

    pub fn forward_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize>
    {
        let start = next_word(1, buf, cur, word_break);

        if n > 1
        {
            let last = next_word(n - 1, buf, start, word_break);
            let end = word_end(buf, last, word_break);
            start..end
        }
        
        else
        {
            let end = word_end(buf, start, word_break);
            start..end
        }
    }

    pub fn next_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        for _ in 0..n {
            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
            drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
        }

        match chars.next() {
            Some((idx, _)) => cur + idx,
            None => buf.len()
        }
    }

    pub fn word_end(buf: &str, cur: usize, word_break: &str) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

        match chars.next() {
            Some((idx, _)) => cur + idx,
            None => buf.len()
        }
    }

}

pub mod scripts
{
    use ::
    {
        fs::{ File },
        path::{ Path, PathBuf },
        regex::{ Regex, RegexBuilder },
        *,
    };

    pub fn run(sh: &mut shell::Shell, args: &Vec<String>) -> i32
    {
        let src_file = &args[1];
        let full_src_file: String;
        
        if src_file.contains('/')
        {
            full_src_file = src_file.clone();
        }

        else
        {
            let full_path = libs::path::find_file_in_path(src_file, false);
            if full_path.is_empty()
            {
                if !Path::new(src_file).exists()
                {
                    println_stderr!("cicada: {}: no such file", src_file);
                    return 1;
                }

                full_src_file = format!("./{}", src_file);
            }
            else { full_src_file = full_path.clone(); }
        }

        if !Path::new(&full_src_file).exists() 
        {
            println_stderr!("cicada: {}: no such file", src_file);
            return 1;
        }

        if Path::new(&full_src_file).is_dir() 
        {
            println_stderr!("cicada: {}: is a directory", src_file);
            return 1;
        }

        let mut file;
        match File::open(&full_src_file)
        {
            Ok(x) => file = x,
            Err(e) => {
                println_stderr!("cicada: {}: failed to open file - {:?}", &full_src_file, e.kind());
                return 1;
            }
        }

        let mut text = String::new();
        match file.read_to_string(&mut text) 
        {
            Ok(_) => {}
            Err(e) => 
            {
                match e.kind() 
                {
                    ErrorKind::InvalidData => 
                    {
                        println_stderr!("cicada: {}: not a valid script file", &full_src_file);
                    }
                    _ => 
                    {
                        println_stderr!("cicada: {}: error: {:?}", &full_src_file, e);
                    }
                }
                return 1;
            }
        }

        if text.contains("\\\n") 
        {
            let re = RegexBuilder::new(r#"([ \t]*\\\n[ \t]+)|([ \t]+\\\n[ \t]*)"#).multi_line(true).build().unwrap();
            text = re.replace_all(&text, " ").to_string();

            let re = RegexBuilder::new(r#"\\\n"#).multi_line(true).build().unwrap();
            text = re.replace_all(&text, "").to_string();
        }

        let re_func_head = Regex::new(r"^function ([a-zA-Z_-][a-zA-Z0-9_-]*) *(?:\(\))? *\{$").unwrap();
        let re_func_tail = Regex::new(r"^\}$").unwrap();
        let mut text_new = String::new();
        let mut enter_func = false;
        let mut func_name = String::new();
        let mut func_body = String::new();

        for line in text.clone().lines()
        {
            if re_func_head.is_match(line.trim())
            {
                enter_func = true;
                let cap = re_func_head.captures(line.trim()).unwrap();
                func_name = cap[1].to_string();
                func_body = String::new();
                continue;
            }

            if re_func_tail.is_match(line.trim())
            {
                sh.set_func(&func_name, &func_body);
                enter_func = false;
                continue;
            }

            if enter_func
            {
                func_body.push_str(line);
                func_body.push('\n');
            }

            else
            {
                text_new.push_str(line);
                text_new.push('\n');
            }
        }

        let mut status = 0;
        let cr_list = ::lines::run( sh, &text_new, args, false );

        if let Some(last) = cr_list.last() { status = last.status; }
        
        sh.exit_on_error = false;
        status
    }
}

pub mod sealed
{
    /// This trait being unreachable from outside the crate prevents outside implementations of our extension traits.
    pub trait Sealed {}
}

pub mod shell
{
    use ::
    {
        collections::{ HashMap },
        regex::{ replace_all },
        uuid::{ Uuid },
        *,
    };

    #[derive(Debug, Clone)]
    pub struct Shell
    {
        pub jobs: HashMap<i32, types::Job>,
        pub aliases: HashMap<String, String>,
        pub envs: HashMap<String, String>,
        pub funcs: HashMap<String, String>,
        pub cmd: String,
        pub current_dir: String,
        pub previous_dir: String,
        pub previous_cmd: String,
        pub previous_status: i32,
        pub is_login: bool,
        pub exit_on_error: bool,
        pub has_terminal: bool,
        pub session_id: String,
    }

    impl Shell
    {
        pub fn new() -> Shell
        {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = ::path::get_current_dir();
            let has_terminal = ::process::has_terminal();
            let (session_id, _) = uuid.split_at(13);
            Shell
            {
                jobs: HashMap::new(),
                aliases: HashMap::new(),
                envs: HashMap::new(),
                funcs: HashMap::new(),
                cmd: String::new(),
                current_dir: current_dir.clone(),
                previous_dir: String::new(),
                previous_cmd: String::new(),
                previous_status: 0,
                is_login: false,
                exit_on_error: false,
                has_terminal,
                session_id: session_id.to_string(),
            }
        }
    }
}

pub mod signals
{
    use ::
    {
        iter::{ FromIterator },
        nix::
        {
            sys::
            {
                signal,
                wait::{WaitPidFlag as WF, WaitStatus as WS, waitpid}
            },
            unistd::{ Pid },
        },
        *,
    };
    /*
    use errno::{errno, set_errno};
    use std::sync::Mutex;
    use std::collections::{HashMap, HashSet};
    */
    pub const NUM_SIGNALS: u8 = 6;
    /// Signal received through a terminal device
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum Signal
    {
        /// Break signal (`CTRL_BREAK_EVENT`); Windows only
        Break,
        /// Continue signal (`SIGCONT`); Unix only
        Continue,
        /// Interrupt signal (`SIGINT` on Unix, `CTRL_C_EVENT` on Windows)
        Interrupt,
        /// Terminal window resize (`SIGWINCH` on Unix, `WINDOW_BUFFER_SIZE_EVENT` on Windows)
        Resize,
        /// Suspend signal (`SIGTSTP`); Unix only
        Suspend,
        /// Quit signal (`SIGQUIT`); Unix only
        Quit,
    }
    
    pub fn block()
    {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        
        match signal::sigprocmask( signal::SigmaskHow::SIG_BLOCK, Some(&sigset), None )
        {
            Ok(_) => {},
            Err(e) =>
            {
                log!("sigprocmask block error: {:?}", e);
            }
        }
    }

    pub fn unblock()
    {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        match signal::sigprocmask(signal::SigmaskHow::SIG_UNBLOCK, Some(&sigset), None)
        {
            Ok(_) => {},
            Err(e) =>
            {
                log!("sigprocmask unblock error: {:?}", e);
            }
        }
    }

    pub fn setup_sigchld_handler()
    {
        unsafe
        {
            let sigset = signal::SigSet::empty();
            let handler = signal::SigHandler::Handler(handle_sigchld);
            let flags = signal::SaFlags::SA_RESTART;
            let sa = signal::SigAction::new(handler, flags, sigset);
            match signal::sigaction(signal::SIGCHLD, &sa)
            {
                Ok(_) => {},
                Err(e) => { log!("sigaction error: {:?}", e); }
            }
        }
    }
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod str
{
    pub use std::str::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };
} use std::sync::Arc;

pub mod system
{
    pub mod common
    {
        use ::
        {
            *,
        };
        /// A trait for viewing representations from std types.
        pub trait AsInner<Inner: ?Sized> { fn as_inner(&self) -> &Inner; }
        /// A trait for viewing representations from std types.
        pub trait AsInnerMut<Inner: ?Sized> { fn as_inner_mut(&mut self) -> &mut Inner; }
        /// A trait for extracting representations from std types.
        pub trait IntoInner<Inner> { fn into_inner(self) -> Inner; }
        /// A trait for creating std types from internal representations.
        pub trait FromInner<Inner> { fn from_inner(inner: Inner) -> Self; }
        /// Computes (value*numer)/denom without overflow,
        /// as long as both (numer*denom) and the overall result fit into i64.
        pub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64
        {
            let q = value / denom;
            let r = value % denom;
            q * numer + r * numer / denom
        }

        pub fn ignore_notfound<T>(result: ::io::Result<T>) -> ::io::Result<()>
        {
            match result
            {
                Err(err) if err.kind() == ::io::ErrorKind::NotFound => Ok(()),
                Ok(_) => Ok(()),
                Err(err) => Err(err),
            }
        }
    }

} pub use self::system as sys;

pub mod task
{
    pub use std::task::{ * };

    pub mod c
    {
        use ::
        {
            io::{ Write },
            nix::
            {
                sys::signal::Signal,
                sys::wait::waitpid,
                sys::wait::WaitPidFlag as WF,
                sys::wait::WaitStatus as WS,
                unistd::Pid,
            },
            types::{self, CommandResult},
            *,
        };

        pub fn get_job_line(job: &types::Job, trim: bool) -> String 
        {
            let mut cmd = job.cmd.clone();
            if trim && cmd.len() > 50 {
                cmd.truncate(50);
                cmd.push_str(" ...");
            }
            let _cmd = if job.is_bg && job.status == "Running" {
                format!("{} &", cmd)
            } else {
                cmd
            };
            format!("[{}] {}  {}   {}", job.id, job.gid, job.status, _cmd)
        }

        pub fn print_job(job: &types::Job) 
        {
            let line = get_job_line(job, true);
            println_stderr!("{}", line);
        }

        pub fn mark_job_as_done(sh: &mut shell::Shell, gid: i32, pid: i32, reason: &str) 
        {
            if let Some(mut job) = sh.remove_pid_from_job(gid, pid) {
                job.status = reason.to_string();
                if job.is_bg {
                    println_stderr!("");
                    print_job(&job);
                }
            }
        }

        pub fn mark_job_as_stopped(sh: &mut shell::Shell, gid: i32, report: bool) 
        {
            sh.mark_job_as_stopped(gid);
            if !report {
                return;
            }

            // add an extra line to separate output of fg commands if any.
            if let Some(job) = sh.get_job_by_gid(gid) {
                println_stderr!("");
                print_job(job);
            }
        }

        pub fn mark_job_member_stopped(sh: &mut shell::Shell, pid: i32, gid: i32, report: bool) 
        {
            let _gid = if gid == 0 {
                unsafe { libc::getpgid(pid) }
            } else {
                gid
            };

            if let Some(job) = sh.mark_job_member_stopped(pid, gid) {
                if job.all_members_stopped() {
                    mark_job_as_stopped(sh, gid, report);
                }
            }
        }

        pub fn mark_job_member_continued(sh: &mut shell::Shell, pid: i32, gid: i32) 
        {
            let _gid = if gid == 0 {
                unsafe { libc::getpgid(pid) }
            } else {
                gid
            };

            if let Some(job) = sh.mark_job_member_continued(pid, gid) {
                if job.all_members_running() {
                    mark_job_as_running(sh, gid, true);
                }
            }
        }

        pub fn mark_job_as_running(sh: &mut shell::Shell, gid: i32, bg: bool) 
        {
            sh.mark_job_as_running(gid, bg);
        }


        pub fn waitpidx(wpid: i32, block: bool) -> types::WaitStatus 
        {
            let options = if block {
                Some(WF::WUNTRACED | WF::WCONTINUED)
            } else {
                Some(WF::WUNTRACED | WF::WCONTINUED | WF::WNOHANG)
            };
            match waitpid(Pid::from_raw(wpid), options) {
                Ok(WS::Exited(pid, status)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_exited(pid, status)
                }
                Ok(WS::Stopped(pid, sig)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_stopped(pid, sig as i32)
                }
                Ok(WS::Continued(pid)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_continuted(pid)
                }
                Ok(WS::Signaled(pid, sig, _core_dumped)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_signaled(pid, sig as i32)
                }
                Ok(WS::StillAlive) => {
                    types::WaitStatus::empty()
                }
                Ok(_others) => {
                    // this is for PtraceEvent and PtraceSyscall on Linux,
                    // unreachable on other platforms.
                    types::WaitStatus::from_others()
                }
                Err(e) => {
                    types::WaitStatus::from_error(e as i32)
                }
            }
        }

        pub fn wait_fg_job(sh: &mut shell::Shell, gid: i32, pids: &[i32]) -> CommandResult 
        {
            let mut cmd_result = CommandResult::new();
            let mut count_waited = 0;
            let count_child = pids.len();
            if count_child == 0 {
                return cmd_result;
            }
            let pid_last = pids.last().unwrap();

            loop {
                let ws = waitpidx(-1, true);
                // here when we calling waitpidx(), all signals should have
                // been masked. There should no errors (ECHILD/EINTR etc) happen.
                if ws.is_error() {
                    let err = ws.get_errno();
                    if err == nix::Error::ECHILD {
                        break;
                    }

                    log!("jobc unexpected waitpid error: {}", err);
                    cmd_result = CommandResult::from_status(gid, err as i32);
                    break;
                }

                let pid = ws.get_pid();
                let is_a_fg_child = pids.contains(&pid);
                if is_a_fg_child && !ws.is_continued() {
                    count_waited += 1;
                }

                if ws.is_exited() {
                    if is_a_fg_child {
                        mark_job_as_done(sh, gid, pid, "Done");
                    } else {
                        let status = ws.get_status();
                        signals::insert_reap_map(pid, status);
                    }
                } else if ws.is_stopped() {
                    if is_a_fg_child {
                        // for stop signal of fg job (current job)
                        // i.e. Ctrl-Z is pressed on the fg job
                        mark_job_member_stopped(sh, pid, gid, true);
                    } else {
                        // for stop signal of bg jobs
                        signals::insert_stopped_map(pid);
                        mark_job_member_stopped(sh, pid, 0, false);
                    }
                } else if ws.is_continued() {
                    if !is_a_fg_child {
                        signals::insert_cont_map(pid);
                    }
                    continue;
                } else if ws.is_signaled() {
                    if is_a_fg_child {
                        mark_job_as_done(sh, gid, pid, "Killed");
                    } else {
                        signals::killed_map_insert(pid, ws.get_signal());
                    }
                }

                if is_a_fg_child && pid == *pid_last {
                    let status = ws.get_status();
                    cmd_result.status = status;
                }

                if count_waited >= count_child {
                    break;
                }
            }
            cmd_result
        }

        pub fn try_wait_bg_jobs(sh: &mut shell::Shell, report: bool, sig_handler_enabled: bool) 
        {
            if sh.jobs.is_empty() {
                return;
            }

            if !sig_handler_enabled {
                // we need to wait pids in case CICADA_ENABLE_SIG_HANDLER=0
                signals::handle_sigchld(Signal::SIGCHLD as i32);
            }

            let jobs = sh.jobs.clone();
            for (_i, job) in jobs.iter() {
                for pid in job.pids.iter() {
                    if let Some(_status) = signals::pop_reap_map(*pid) {
                        mark_job_as_done(sh, job.gid, *pid, "Done");
                        continue;
                    }

                    if let Some(sig) = signals::killed_map_pop(*pid) {
                        let reason = if sig == Signal::SIGQUIT as i32 {
                            format!("Quit: {}", sig)
                        } else if sig == Signal::SIGINT as i32 {
                            format!("Interrupt: {}", sig)
                        } else if sig == Signal::SIGKILL as i32 {
                            format!("Killed: {}", sig)
                        } else if sig == Signal::SIGTERM as i32 {
                            format!("Terminated: {}", sig)
                        } else {
                            format!("Killed: {}", sig)
                        };
                        mark_job_as_done(sh, job.gid, *pid, &reason);
                        continue;
                    }

                    if signals::pop_stopped_map(*pid) {
                        mark_job_member_stopped(sh, *pid, job.gid, report);
                    } else if signals::pop_cont_map(*pid) {
                        mark_job_member_continued(sh, *pid, job.gid);
                    }
                }
            }
        }
    }
}

pub mod terminal
{
    use ::
    {
        *,
    };

    pub mod size
    {
        use ::
        {
            libc::ioctl,
            libc::winsize,
            mem::zeroed,
            *,
        };
        /// Query the current processes's stdout, stdin, and stderr, to determine terminal width.
        pub fn dimensions() -> Option<(usize, usize)>
        {
            let w = unsafe { get_dimensions_any() };

            if w.ws_col == 0 || w.ws_row == 0 { None } else { Some((w.ws_col as usize, w.ws_row as usize)) }
        } 
        /// Runs the ioctl command.
        unsafe fn get_dimensions_any() -> winsize
        {
            let mut window: winsize = zeroed();
            let mut result = ioctl(STDOUT_FILENO, TIOCGWINSZ, &mut window);

            if result == -1
            {
                window = zeroed();
                result = ioctl(STDIN_FILENO, TIOCGWINSZ, &mut window);
                if result == -1 {
                    window = zeroed();
                    result = ioctl(STDERR_FILENO, TIOCGWINSZ, &mut window);
                    if result == -1 {
                        return zeroed();
                    }
                }
            }

            window
        }
    }
    /// Defines a low-level interface to the terminal
    pub trait Terminals: Sized + Send + Sync
    {
        /// Returned by `prepare`; passed to `restore` to restore state.
        type PrepareState;
        /*
        /// Holds an exclusive read lock and provides read operations
        type Reader: TerminalReader;
        /// Holds an exclusive write lock and provides write operations
        type Writer: TerminalWriter;
        */
        /// Returns the name of the terminal.
        fn name(&self) -> &str;
        /// Acquires a lock on terminal read operations 
        /// and returns a value holding that lock and granting access to such operations.
        fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a>;
        /// Acquires a lock on terminal write operations
        /// and returns a value holding that lock and granting access to such operations.
        fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a>;
    }
    /// Holds a lock on `Terminal` read operations
    pub trait TerminalReader<Term: Terminals>
    {
        /// Prepares the terminal for line reading and editing operations.
        fn prepare(&mut self, block_signals: bool, report_signals: SignalSet) -> io::Result<Term::PrepareState>;
        /// Like `prepare`, but called when the write lock is already held.
        unsafe fn prepare_with_lock
        (
            &mut self, 
            lock: &mut dyn TerminalWriter<Term>,
            block_signals: bool,
            report_signals: SignalSet
        ) -> io::Result<Term::PrepareState>;
        /// Restores the terminal state using the given state data.
        fn restore(&mut self, state: Term::PrepareState) -> io::Result<()>;
        /// Like `restore`, but called when the write lock is already held.
        unsafe fn restore_with_lock
        (
            &mut self,
            lock: &mut dyn TerminalWriter<Term>,
            state: Term::PrepareState
        ) -> io::Result<()>;
        /// Reads some input from the terminal and appends it to the given buffer.
        fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead>;
        /// Waits `timeout` for user input. If `timeout` is `None`, waits indefinitely.
        fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool>;
    }
    /// Holds a lock on `Terminal` write operations
    pub trait TerminalWriter<Term: Terminals>
    {
        /// Returns the size of the terminal window
        fn size(&self) -> io::Result<Size>;
        /// Presents a clear terminal screen, with cursor at first row, first column.
        fn clear_screen(&mut self) -> io::Result<()>;
        /// Clears characters on the line occupied by the cursor,
        /// beginning with the cursor and ending at the end of the line.
        fn clear_to_screen_end(&mut self) -> io::Result<()>;
        /// Moves the cursor up `n` cells; `n` may be zero.
        fn move_up(&mut self, n: usize) -> io::Result<()>;
        /// Moves the cursor down `n` cells; `n` may be zero.
        fn move_down(&mut self, n: usize) -> io::Result<()>;
        /// Moves the cursor left `n` cells; `n` may be zero.
        fn move_left(&mut self, n: usize) -> io::Result<()>;
        /// Moves the cursor right `n` cells; `n` may be zero.
        fn move_right(&mut self, n: usize) -> io::Result<()>;
        /// Moves the cursor to the first column of the current line
        fn move_to_first_column(&mut self) -> io::Result<()>;
        /// Set the current cursor mode
        fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>;
        /// Writes output to the terminal.
        fn write(&mut self, s: &str) -> io::Result<()>;
        /// Flushes any currently buffered output data.
        fn flush(&mut self) -> io::Result<()>;
    }
}

pub mod time
{
    pub use std::time::{ * };

    pub mod c
    {
        pub use ::timed::{ * };
        use ::
        {
            *,
        };

        #[derive(Debug, PartialEq, Eq)]
        pub struct DateTime
        {
            odt: OffsetDateTime,
        }

        impl DateTime
        {
            pub fn now() -> Self
            {
                let odt: OffsetDateTime = match OffsetDateTime::now_local()
                {
                    Ok(dt) => dt,
                    Err(_) => OffsetDateTime::now_utc(),
                };

                DateTime { odt }
            }

            pub fn from_timestamp(ts: f64) -> Self
            {
                let dummy_now = Self::now();
                let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
                let ts_nano = (ts + offset_seconds as f64) * 1000000000.0;
                let odt: OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos(ts_nano as i128)
                {
                    Ok(x) => x,
                    Err(_) => OffsetDateTime::now_utc(),
                };

                DateTime { odt }
            }

            pub fn unix_timestamp(&self) -> f64 { self.odt.unix_timestamp_nanos() as f64 / 1000000000.0 }
        }

        impl fmt::Display for DateTime
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            {
                write!
                (
                    f, "{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                    self.odt.year(),
                    self.odt.month() as u8,
                    self.odt.day(),
                    self.odt.hour(),
                    self.odt.minute(),
                    self.odt.second(),
                    self.odt.millisecond(),
                )
            }
        }
    }
}

pub mod tokens
{
    use ::
    {
        types::{ Redirection, Tokens },
        regex::{ contains, Regex },
        *,
    };

    pub fn tokens_to_redirections(tokens: &Tokens) -> Result<(Tokens, Vec<Redirection>), String>
    {
        let mut tokens_new = Vec::new();
        let mut redirects = Vec::new();
        let mut to_be_continued = false;
        let mut to_be_continued_s1 = String::new();
        let mut to_be_continued_s2 = String::new();

        for token in tokens
        {
            let sep = &token.0;

            if !sep.is_empty() && !to_be_continued
            {
                tokens_new.push(token.clone());
                continue;
            }

            let word = &token.1;

            if to_be_continued
            {
                if sep.is_empty() && word.starts_with('&') { return Err(String::from("bad redirection syntax near &")); }

                let s3 = word.to_string();
                if contains(&to_be_continued_s1, r"^\d+$")
                {
                    if to_be_continued_s1 != "1" && to_be_continued_s1 != "2" { return Err(String::from("Bad file descriptor #3")); }

                    let s1 = to_be_continued_s1.clone();
                    let s2 = to_be_continued_s2.clone();
                    redirects.push((s1, s2, s3));
                }

                else
                {
                    if !to_be_continued_s1.is_empty() { tokens_new.push((sep.clone(), to_be_continued_s1.to_string())); }

                    redirects.push(("1".to_string(), to_be_continued_s2.clone(), s3));
                }

                to_be_continued = false;
                continue;
            }

            let ptn1 = r"^([^>]*)(>>?)([^>]+)$";
            let ptn2 = r"^([^>]*)(>>?)$";

            if !contains(word, r">") { tokens_new.push(token.clone()); }
            else if contains(word, ptn1)
            {
                let re;
                if let Ok(x) = Regex::new(ptn1) { re = x; }
                else { return Err(String::from("Failed to build Regex")); }

                if let Some(caps) = re.captures(word)
                {
                    let s1 = caps.get(1).unwrap().as_str();
                    let s2 = caps.get(2).unwrap().as_str();
                    let s3 = caps.get(3).unwrap().as_str();

                    if s3.starts_with('&') && s3 != "&1" && s3 != "&2" { return Err(String::from("Bad file descriptor #1")); }

                    if contains(s1, r"^\d+$")
                    {
                        if s1 != "1" && s1 != "2" { return Err(String::from("Bad file descriptor #2")); }
                        redirects.push((s1.to_string(), s2.to_string(), s3.to_string()));
                    }
                    
                    else
                    {
                        if !s1.is_empty() { tokens_new.push((sep.clone(), s1.to_string())); }
                        redirects.push((String::from("1"), s2.to_string(), s3.to_string()));
                    }
                }
            }

            else if contains(word, ptn2)
            {
                let re;

                if let Ok(x) = Regex::new(ptn2) { re = x; }
                else { return Err(String::from("Failed to build Regex")); }

                if let Some(caps) = re.captures(word)
                {
                    let s1 = caps.get(1).unwrap().as_str();
                    let s2 = caps.get(2).unwrap().as_str();
                    to_be_continued = true;
                    to_be_continued_s1 = s1.to_string();
                    to_be_continued_s2 = s2.to_string();
                }
            }
        }

        if to_be_continued { return Err(String::from("redirection syntax error")); }

        Ok((tokens_new, redirects))
    }
}

pub mod types
{
    pub use std::primitive::{ * };

    use ::
    {
        collections::{ HashMap, HashSet },
        regex::{ Regex },
        *,
    };
    /*
    use crate::parsers::parser_line::tokens_to_redirections;
    */
    pub type Token = (String, String);
    pub type Tokens = Vec<Token>;
    pub type Redirection = (String, String, String);

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct WaitStatus(i32, i32, i32);

    impl WaitStatus
    {
        pub fn from_exited(pid: i32, status: i32) -> Self {
            WaitStatus(pid, 0, status)
        }

        pub fn from_signaled(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 1, sig)
        }

        pub fn from_stopped(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 2, sig)
        }

        pub fn from_continuted(pid: i32) -> Self {
            WaitStatus(pid, 3, 0)
        }

        pub fn from_others() -> Self {
            WaitStatus(0, 9, 9)
        }

        pub fn from_error(errno: i32) -> Self {
            WaitStatus(0, 255, errno)
        }

        pub fn empty() -> Self {
            WaitStatus(0, 0, 0)
        }

        pub fn is_error(&self) -> bool {
            self.1 == 255
        }

        pub fn is_others(&self) -> bool {
            self.1 == 9
        }

        pub fn is_signaled(&self) -> bool {
            self.1 == 1
        }

        pub fn get_errno(&self) -> nix::Error {
            nix::Error::from_raw(self.2)
        }

        pub fn is_exited(&self) -> bool {
            self.0 != 0 && self.1 == 0
        }

        pub fn is_stopped(&self) -> bool {
            self.1 == 2
        }

        pub fn is_continued(&self) -> bool {
            self.1 == 3
        }

        pub fn get_pid(&self) -> i32 {
            self.0
        }

        fn _get_signaled_status(&self) -> i32 {
            self.2 + 128
        }

        pub fn get_signal(&self) -> i32 {
            self.2
        }

        pub fn get_name(&self) -> String {
            if self.is_exited() {
                "Exited".to_string()
            } else if self.is_stopped() {
                "Stopped".to_string()
            } else if self.is_continued() {
                "Continued".to_string()
            } else if self.is_signaled() {
                "Signaled".to_string()
            } else if self.is_others() {
                "Others".to_string()
            } else if self.is_error() {
                "Error".to_string()
            } else {
                format!("unknown: {}", self.2)
            }
        }

        pub fn get_status(&self) -> i32 {
            if self.is_exited() {
                self.2
            } else {
                self._get_signaled_status()
            }
        }
    }

    impl fmt::Debug for WaitStatus
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let mut formatter = f.debug_struct("WaitStatus");
            formatter.field("pid", &self.0);
            let name = self.get_name();
            formatter.field("name", &name);
            formatter.field("ext", &self.2);
            formatter.finish()
        }
    }

    #[derive(Debug)]
    pub struct LineInfo
    {
        pub tokens: Tokens,
        pub is_complete: bool,
    }

    impl LineInfo
    {
        pub fn new(tokens: Tokens) -> Self { LineInfo { tokens, is_complete: true } }
    }
    
    #[derive(Debug)]
    pub struct Command
    {
        pub tokens: Tokens,
        pub redirects_to: Vec<Redirection>,
        pub redirect_from: Option<Token>,
    }

    impl Command
    {
        pub fn from_tokens(tokens: Tokens) -> Result<Command, String> {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");

            let mut len = tokens_new.len();
            while has_redirect_from {
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<") {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<<<") {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }

                has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");
            }

            let tokens_final;
            let redirects_to;
            match tokens_to_redirections(&tokens_new) {
                Ok((_tokens, _redirects_to)) => {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }
                Err(e) => {
                    return Err(e);
                }
            }

            let redirect_from = if redirects_from_type.is_empty() {
                None
            } else {
                Some((redirects_from_type, redirects_from_value))
            };

            Ok(Command{
                tokens: tokens_final,
                redirects_to,
                redirect_from,
            })
        }

        pub fn has_redirect_from(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<"
        }

        pub fn has_here_string(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<<<"
        }

        pub fn is_builtin(&self) -> bool {
            tools::is_builtin(&self.tokens[0].1)
        }
    }

    #[derive(Debug)]
    pub struct CommandLine
    {
        pub line: String,
        pub commands: Vec<Command>,
        pub envs: HashMap<String, String>,
        pub background: bool,
    }

    impl CommandLine
    {
        pub fn from_line(line: &str, sh: &mut shell::Shell) -> Result<CommandLine, String> {
            let linfo = parsers::line::parse(line);
            let mut tokens = linfo.tokens;
            shell::do_expansion(sh, &mut tokens);
            let envs = drain_env_tokens(&mut tokens);

            let mut background = false;
            let len = tokens.len();
            if len > 1 && tokens[len - 1].1 == "&" {
                background = true;
                tokens.pop();
            }

            let mut commands = Vec::new();
            for sub_tokens in split_tokens_by_pipes(&tokens) {
                match Command::from_tokens(sub_tokens) {
                    Ok(c) => {
                        commands.push(c);
                    }
                    Err(e) => {
                        return Err(e);
                    }
                }
            }

            Ok(CommandLine{
                line: line.to_string(),
                commands,
                envs,
                background,
            })
        }

        pub fn is_empty(&self) -> bool {
            self.commands.is_empty()
        }

        pub fn with_pipeline(&self) -> bool {
            self.commands.len() > 1
        }

        pub fn is_single_and_builtin(&self) -> bool {
            self.commands.len() == 1 && self.commands[0].is_builtin()
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Job
    {
        pub cmd: String,
        pub id: i32,
        pub gid: i32,
        pub pids: Vec<i32>,
        pub pids_stopped: HashSet<i32>,
        pub status: String,
        pub is_bg: bool,
    }

    impl Job
    {
        pub fn all_members_stopped(&self) -> bool {
            for pid in &self.pids {
                if !self.pids_stopped.contains(pid) {
                    return false;
                }
            }
            true
        }

        pub fn all_members_running(&self) -> bool {
            self.pids_stopped.is_empty()
        }
    }
    
    #[derive(Clone, Debug, Default)]
    pub struct CommandResult 
    {
        pub gid: i32,
        pub status: i32,
        pub stdout: String,
        pub stderr: String,
    }

    impl CommandResult
    {
        pub fn new() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 0,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn from_status(gid: i32, status: i32) -> CommandResult {
            CommandResult {
                gid,
                status,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn error() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 1,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    }
    
    #[derive(Clone, Debug, Default)]
    pub struct CommandOptions
    {
        pub background: bool,
        pub isatty: bool,
        pub capture_output: bool,
        pub envs: HashMap<String, String>,
    }

    fn split_tokens_by_pipes(tokens: &[Token]) -> Vec<Tokens>
    {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();
        for token in tokens {
            let sep = &token.0;
            let value = &token.1;
            if sep.is_empty() && value == "|" {
                if cmd.is_empty() {
                    return Vec::new();
                }
                cmds.push(cmd.clone());
                cmd = Vec::new();
            } else {
                cmd.push(token.clone());
            }
        }
        if cmd.is_empty() {
            return Vec::new();
        }
        cmds.push(cmd.clone());
        cmds
    }

    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String>
    {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new(r"^([a-zA-Z0-9_]+)=(.*)$").unwrap();
        for (sep, text) in tokens.iter()
        {
            if !sep.is_empty() || !::regex::contains(text, r"^([a-zA-Z0-9_]+)=(.*)$"){ break; }

            for cap in re.captures_iter(text)
            {
                let name = cap[1].to_string();
                let value = parsers::line::unquote(&cap[2]);
                envs.insert(name, value);
            }

            n += 1;
        }
        if n > 0 {
            tokens.drain(0..n);
        }
        envs
    }
}

pub mod uuid
{
    use ::
    {
        *,
    };
    /// A 128-bit (16 byte) buffer containing the UUID.
    pub type Bytes = [u8; 16];
    /// A Universally Unique Identifier (UUID).
    #[repr( transparent )] #[derive( Clone, Copy, Eq, Ord, PartialEq, PartialOrd )]
    pub struct Uuid( Bytes );

    impl Uuid
    {
        /// Creates a random UUID.
        pub fn new_v4() -> Uuid
        {
            Uuid::from_u128
            (
                //crate::rng::u128() & 0xFFFFFFFFFFFF4FFFBFFFFFFFFFFFFFFF | 0x40008000000000000000,
                128 & 0xFFFFFFFFFFFF4FFFBFFFFFFFFFFFFFFF | 0x40008000000000000000,
            )
        }

        #[inline] pub const fn from_bytes(bytes: Bytes) -> Uuid { Uuid(bytes) }

        pub const fn from_u128(v: u128) -> Self { Uuid::from_bytes(v.to_be_bytes()) }
    }
}

pub mod writer
{
    //! Provides access to terminal write operations
    use ::
    {
        borrow::{ Cow::{ self, Borrowed, Owned } },
        char::{is_ctrl, unctrl, ESCAPE, RUBOUT},
        collections::{ vec_deque, VecDeque },
        iter::{ repeat, Skip },
        mem::{ swap },
        ops::{ Deref, DerefMut, Range },
        reader::{ START_INVISIBLE, END_INVISIBLE },
        sync::{ MutexGuard },
        terminal::{ Terminals, TerminalWriter },
        time::{ Duration, Instant },
        *,
    };    
    /*
    use crate::terminal::{CursorMode, Size, Terminal, TerminalWriter};
    use crate::util::{
        backward_char, forward_char, backward_search_char, forward_search_char,
        filter_visible, is_combining_mark, is_wide, RangeArgument,
    };
    */
    /// Duration to wait for input when "blinking"
    pub const BLINK_DURATION: Duration = Duration::from_millis(500);
    /// Maximum value of digit input
    pub const NUMBER_MAX: i32 = 1_000_000;
    pub const COMPLETE_MORE: &'static str = "--More--";
    /// Default maximum history size
    pub const MAX_HISTORY: usize = !0;
    /// Tab column interval
    pub const TAB_STOP: usize = 8;
    // Length of "(arg: "
    pub const PROMPT_NUM_PREFIX: usize = 6;
    // Length of ") "
    pub const PROMPT_NUM_SUFFIX: usize = 2;
    // Length of "(i-search)`"
    pub const PROMPT_SEARCH_PREFIX: usize = 11;
    // Length of "failed "
    pub const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
    // Length of "reverse-"
    pub const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
    // Length of "': "
    pub const PROMPT_SEARCH_SUFFIX: usize = 3;
    /// Provides an interface to write line-by-line output to the terminal device.
    pub struct Writer<'a, 'b: 'a, Term: 'b + Terminals>
    {
        write: WriterImpl<'a, 'b, Term>,
    }

    pub enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminals>
    {
        Mutex(WriteLock<'b, Term>),
        MutRef(&'a mut WriteLock<'b, Term>),
    }

    pub struct Write
    {
        /// Input buffer
        pub buffer: String,
        /// Original buffer entered before searching through history
        pub backup_buffer: String,
        /// Position of the cursor
        pub cursor: usize,
        /// Position of the cursor if currently performing a blink
        blink: Option<Blink>,

        /// Stored history entries
        pub history: VecDeque<String>,
        /// History entry currently being edited;
        /// `None` if the new buffer is being edited
        pub history_index: Option<usize>,
        /// Maximum size of history
        history_size: usize,
        /// Number of history entries added since last loading history
        history_new_entries: usize,

        /// Whether the prompt is drawn; i.e. a `read_line` operation is in progress
        pub is_prompt_drawn: bool,

        /// Portion of prompt up to and including the final newline
        pub prompt_prefix: String,
        prompt_prefix_len: usize,
        /// Portion of prompt after the final newline
        pub prompt_suffix: String,
        prompt_suffix_len: usize,

        /// Current type of prompt
        pub prompt_type: PromptType,

        /// Whether a search in progress is a reverse search
        pub reverse_search: bool,
        /// Whether a search in progress has failed to find a match
        pub search_failed: bool,
        /// Current search string
        pub search_buffer: String,
        /// Last search string
        pub last_search: String,
        /// Selected history entry prior to a history search
        pub prev_history: Option<usize>,
        /// Position of the cursor prior to a history search
        pub prev_cursor: usize,

        /// Numerical argument
        pub input_arg: Digit,
        /// Whether a numerical argument was supplied
        pub explicit_arg: bool,

        /// Terminal size as of last draw operation
        pub screen_size: Size,
    }

    impl Write
    {
        pub fn new(screen_size: Size) -> Write {
            Write{
                buffer: String::new(),
                backup_buffer: String::new(),
                cursor: 0,
                blink: None,

                history: VecDeque::new(),
                history_index: None,
                history_size: MAX_HISTORY,
                history_new_entries: 0,

                is_prompt_drawn: false,

                prompt_prefix: String::new(),
                prompt_prefix_len: 0,
                prompt_suffix: String::new(),
                prompt_suffix_len: 0,

                prompt_type: PromptType::Normal,

                reverse_search: false,
                search_failed: false,
                search_buffer: String::new(),
                last_search: String::new(),
                prev_history: None,
                prev_cursor: !0,

                input_arg: Digit::None,
                explicit_arg: false,

                screen_size,
            }
        }

        pub fn history(&self) -> HistoryIter {
            HistoryIter(self.history.iter())
        }

        pub fn new_history(&self) -> Skip<HistoryIter> {
            let first_new = self.history.len() - self.history_new_entries;
            self.history().skip(first_new)
        }

        pub fn new_history_entries(&self) -> usize {
            self.history_new_entries
        }

        pub fn reset_data(&mut self) {
            self.buffer.clear();
            self.backup_buffer.clear();
            self.cursor = 0;
            self.history_index = None;

            self.prompt_type = PromptType::Normal;

            self.input_arg = Digit::None;
            self.explicit_arg = false;
        }

        pub fn reset_new_history(&mut self) {
            self.history_new_entries = 0;
        }

        pub fn set_buffer(&mut self, buf: &str) {
            self.buffer.clear();
            self.buffer.push_str(buf);
            self.cursor = buf.len();
        }

        pub fn set_cursor(&mut self, pos: usize) {
            if !self.buffer.is_char_boundary(pos) {
                panic!("invalid cursor position {} in buffer {:?}",
                    pos, self.buffer);
            }

            self.cursor = pos;
        }

        pub fn set_prompt(&mut self, prompt: &str) {
            let (pre, suf) = match prompt.rfind('\n') {
                Some(pos) => (&prompt[..pos + 1], &prompt[pos + 1..]),
                None => (&prompt[..0], prompt)
            };

            self.prompt_prefix = pre.to_owned();
            self.prompt_suffix = suf.to_owned();

            let pre_virt = ::filter::visible(pre);
            self.prompt_prefix_len = self.display_size(&pre_virt, 0);

            let suf_virt = ::filter::visible(suf);
            self.prompt_suffix_len = self.display_size(&suf_virt, 0);
        }

        pub fn display_size(&self, s: &str, start_col: usize) -> usize {
            let width = self.screen_size.columns;
            let mut col = start_col;

            let disp = Display{
                allow_tab: true,
                allow_newline: true,
                .. Display::default()
            };

            for ch in s.chars().flat_map(|ch| display(ch, disp)) {
                let n = match ch {
                    '\n' => width - (col % width),
                    '\t' => TAB_STOP - (col % TAB_STOP),
                    ch if ::is::combining_mark(ch) => 0,
                    ch if ::is::wide(ch) => {
                        if col % width == width - 1 {
                            // Can't render a fullwidth character into last column
                            3
                        } else {
                            2
                        }
                    }
                    _ => 1
                };

                col += n;
            }

            col - start_col
        }
    }

    pub struct WriteLock<'a, Term: 'a + Terminals>
    {
        term: Box<dyn TerminalWriter<Term> + 'a>,
        data: MutexGuard<'a, Write>,
    }

    impl<'a, Term: Terminals> WriteLock<'a, Term>
    {
        pub fn new(term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write>) -> WriteLock<'a, Term>
        {
            WriteLock{term, data}
        }

        pub fn size(&self) -> io::Result<Size> 
        {
            self.term.size()
        }

        pub fn flush(&mut self) -> io::Result<()> 
        {
            self.term.flush()
        }

        pub fn update_size(&mut self) -> io::Result<()> 
        {
            let size = self.size()?;
            self.screen_size = size;
            Ok(())
        }

        pub fn blink(&mut self, pos: usize) -> io::Result<()> 
        {
            self.expire_blink()?;

            let orig = self.cursor;
            self.move_to(pos)?;
            self.cursor = orig;

            let expiry = Instant::now() + BLINK_DURATION;

            self.blink = Some(Blink{
                pos,
                expiry,
            });

            Ok(())
        }

        pub fn check_expire_blink(&mut self, now: Instant) -> io::Result<bool> 
        {
            if let Some(blink) = self.data.blink {
                if now >= blink.expiry {
                    self.expire_blink()?;
                }
            }

            Ok(self.blink.is_none())
        }

        pub fn expire_blink(&mut self) -> io::Result<()> 
        {
            if let Some(blink) = self.data.blink.take() {
                self.move_from(blink.pos)?;
            }

            Ok(())
        }

        pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> 
        {
            self.expire_blink()?;

            let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

            if redraw {
                self.clear_full_prompt()?;
            }

            self.data.set_prompt(prompt);

            if redraw {
                self.draw_prompt()?;
            }

            Ok(())
        }
        /// Draws the prompt and current input, assuming the cursor is at column 0
        pub fn draw_prompt(&mut self) -> io::Result<()> 
        {
            self.draw_prompt_prefix()?;
            self.draw_prompt_suffix()
        }

        pub fn draw_prompt_prefix(&mut self) -> io::Result<()> 
        {
            match self.prompt_type {
                // Prefix is not drawn when completions are shown
                PromptType::CompleteMore => Ok(()),
                _ => {
                    let pfx = self.prompt_prefix.clone();
                    self.draw_raw_prompt(&pfx)
                }
            }
        }

        pub fn draw_prompt_suffix(&mut self) -> io::Result<()> 
        {
            match self.prompt_type {
                PromptType::Normal => {
                    let sfx = self.prompt_suffix.clone();
                    self.draw_raw_prompt(&sfx)?;
                }
                PromptType::Number => {
                    let n = self.input_arg.to_i32();
                    let s = format!("(arg: {}) ", n);
                    self.draw_text(0, &s)?;
                }
                PromptType::Search => {
                    let pre = match (self.reverse_search, self.search_failed) {
                        (false, false) => "(i-search)",
                        (false, true)  => "(failed i-search)",
                        (true,  false) => "(reverse-i-search)",
                        (true,  true)  => "(failed reverse-i-search)",
                    };

                    let ent = self.get_history(self.history_index).to_owned();
                    let s = format!("{}`{}': {}", pre, self.search_buffer, ent);

                    self.draw_text(0, &s)?;
                    let pos = self.cursor;

                    let (lines, cols) = self.move_delta(ent.len(), pos, &ent);
                    return self.move_rel(lines, cols);
                }
                PromptType::CompleteIntro(n) => {
                    return self.term.write(&complete_intro(n));
                }
                PromptType::CompleteMore => {
                    return self.term.write(COMPLETE_MORE);
                }
            }

            self.draw_buffer(0)?;
            let len = self.buffer.len();
            self.move_from(len)
        }

        pub fn redraw_prompt(&mut self, new_prompt: PromptType) -> io::Result<()> 
        {
            self.clear_prompt()?;
            self.prompt_type = new_prompt;
            self.draw_prompt_suffix()
        }

        /// Draws a portion of the buffer, starting from the given cursor position
        pub fn draw_buffer(&mut self, pos: usize) -> io::Result<()> 
        {
            let (_, col) = self.line_col(pos);

            let buf = self.buffer[pos..].to_owned();
            self.draw_text(col, &buf)?;
            Ok(())
        }

        /// Draw some text with the cursor beginning at the given column.
        fn draw_text(&mut self, start_col: usize, text: &str) -> io::Result<()> 
        {
            self.draw_text_impl(start_col, text, Display{
                allow_tab: true,
                allow_newline: true,
                .. Display::default()
            }, false)
        }

        fn draw_raw_prompt(&mut self, text: &str) -> io::Result<()> 
        {
            self.draw_text_impl(0, text, Display{
                allow_tab: true,
                allow_newline: true,
                allow_escape: true,
            }, true)
        }

        fn draw_text_impl(&mut self, start_col: usize, text: &str, disp: Display, handle_invisible: bool) 
        -> io::Result<()>
        {
            let width = self.screen_size.columns;
            let mut col = start_col;
            let mut out = String::with_capacity(text.len());

            let mut clear = false;
            let mut hidden = false;

            for ch in text.chars() {
                if handle_invisible && ch == START_INVISIBLE {
                    hidden = true;
                } else if handle_invisible && ch == END_INVISIBLE {
                    hidden = false;
                } else if hidden {
                    // Render the character, but assume it has 0 width.
                    out.push(ch);
                } else {
                    for ch in display(ch, disp) {
                        if ch == '\t' {
                            let n = TAB_STOP - (col % TAB_STOP);

                            if col + n > width {
                                let pre = width - col;
                                out.extend(repeat(' ').take(pre));
                                out.push_str(" \r");
                                out.extend(repeat(' ').take(n - pre));
                                col = n - pre;
                            } else {
                                out.extend(repeat(' ').take(n));
                                col += n;

                                if col == width {
                                    out.push_str(" \r");
                                    col = 0;
                                }
                            }
                        } else if ch == '\n' {
                            if !clear {
                                self.term.write(&out)?;
                                out.clear();
                                self.term.clear_to_screen_end()?;
                                clear = true;
                            }

                            out.push('\n');
                            col = 0;
                        } else if ::is::combining_mark(ch) {
                            out.push(ch);
                        } else if ::is::wide(ch) {
                            if col == width - 1 {
                                out.push_str("  \r");
                                out.push(ch);
                                col = 2;
                            } else {
                                out.push(ch);
                                col += 2;
                            }
                        } else {
                            out.push(ch);
                            col += 1;

                            if col == width {
                                // Space pushes the cursor to the next line,
                                // CR brings back to the start of the line.
                                out.push_str(" \r");
                                col = 0;
                            }
                        }
                    }
                }
            }

            if col == width {
                out.push_str(" \r");
            }

            self.term.write(&out)
        }

        pub fn set_buffer(&mut self, buf: &str) -> io::Result<()>
        {
            self.expire_blink()?;

            self.move_to(0)?;
            self.buffer.clear();
            self.buffer.push_str(buf);
            self.new_buffer()
        }

        pub fn set_cursor(&mut self, pos: usize) -> io::Result<()>
        {
            self.expire_blink()?;

            if !self.buffer.is_char_boundary(pos) {
                panic!("invalid cursor position {} in buffer {:?}",
                    pos, self.buffer);
            }

            self.move_to(pos)
        }

        pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
        {
            self.term.set_cursor_mode(mode)
        }

        pub fn history_len(&self) -> usize
        {
            self.history.len()
        }

        pub fn history_size(&self) -> usize
        {
            self.history_size
        }

        pub fn set_history_size(&mut self, n: usize)
        {
            self.history_size = n;
            self.truncate_history(n);
        }

        pub fn write_str(&mut self, s: &str) -> io::Result<()>
        {
            self.term.write(s)
        }

        pub fn start_history_search(&mut self, reverse: bool) -> io::Result<()>
        {
            self.search_buffer = self.buffer[..self.cursor].to_owned();

            self.continue_history_search(reverse)
        }

        pub fn continue_history_search(&mut self, reverse: bool) -> io::Result<()> 
        {
            if let Some(idx) = self.find_history_search(reverse) {
                self.set_history_entry(Some(idx));

                let pos = self.cursor;
                let end = self.buffer.len();

                self.draw_buffer(pos)?;
                self.clear_to_screen_end()?;
                self.move_from(end)?;
            }

            Ok(())
        }

        fn find_history_search(&self, reverse: bool) -> Option<usize> 
        {
            let len = self.history.len();
            let idx = self.history_index.unwrap_or(len);

            if reverse {
                self.history.iter().rev().skip(len - idx)
                    .position(|ent| ent.starts_with(&self.search_buffer))
                    .map(|pos| idx - (pos + 1))
            } else {
                self.history.iter().skip(idx + 1)
                    .position(|ent| ent.starts_with(&self.search_buffer))
                    .map(|pos| idx + (pos + 1))
            }
        }

        pub fn start_search_history(&mut self, reverse: bool) -> io::Result<()> 
        {
            self.reverse_search = reverse;
            self.search_failed = false;
            self.search_buffer.clear();
            self.prev_history = self.history_index;
            self.prev_cursor = self.cursor;

            self.redraw_prompt(PromptType::Search)
        }

        pub fn continue_search_history(&mut self, reverse: bool) -> io::Result<()> 
        {
            self.reverse_search = reverse;
            self.search_failed = false;

            {
                let data = &mut *self.data;
                data.search_buffer.clone_from(&data.last_search);
            }

            self.search_history_step()
        }

        pub fn end_search_history(&mut self) -> io::Result<()> 
        {
            self.redraw_prompt(PromptType::Normal)
        }

        pub fn abort_search_history(&mut self) -> io::Result<()> 
        {
            self.clear_prompt()?;

            let ent = self.prev_history;
            self.set_history_entry(ent);
            self.cursor = self.prev_cursor;

            self.prompt_type = PromptType::Normal;
            self.draw_prompt_suffix()
        }

        fn show_search_match(&mut self, next_match: Option<(Option<usize>, usize)>) -> io::Result<()>
        {
            self.clear_prompt()?;

            if let Some((idx, pos)) = next_match {
                self.search_failed = false;
                self.set_history_entry(idx);
                self.cursor = pos;
            } else {
                self.search_failed = true;
            }

            self.prompt_type = PromptType::Search;
            self.draw_prompt_suffix()
        }

        pub fn search_history_update(&mut self) -> io::Result<()>
        {
            // Search for the next match, perhaps including the current position
            let next_match = if self.reverse_search {
                self.search_history_backward(&self.search_buffer, true)
            } else {
                self.search_history_forward(&self.search_buffer, true)
            };

            self.show_search_match(next_match)
        }

        fn search_history_step(&mut self) -> io::Result<()>
        {
            if self.search_buffer.is_empty() {
                return self.redraw_prompt(PromptType::Search);
            }

            // Search for the next match
            let next_match = if self.reverse_search {
                self.search_history_backward(&self.search_buffer, false)
            } else {
                self.search_history_forward(&self.search_buffer, false)
            };

            self.show_search_match(next_match)
        }

        fn search_history_backward(&self, s: &str, include_cur: bool) -> Option<(Option<usize>, usize)>
        {
            let mut idx = self.history_index;
            let mut pos = Some(self.cursor);

            if include_cur && !self.search_failed {
                if let Some(p) = pos {
                    if self.get_history(idx).is_char_boundary(p + s.len()) {
                        pos = Some(p + s.len());
                    }
                }
            }

            loop {
                let line = self.get_history(idx);

                match line[..pos.unwrap_or(line.len())].rfind(s) {
                    Some(found) => {
                        pos = Some(found);
                        break;
                    }
                    None => {
                        match idx {
                            Some(0) => return None,
                            Some(n) => {
                                idx = Some(n - 1);
                                pos = None;
                            }
                            None => {
                                if self.history.is_empty() {
                                    return None;
                                } else {
                                    idx = Some(self.history.len() - 1);
                                    pos = None;
                                }
                            }
                        }
                    }
                }
            }

            pos.map(|pos| (idx, pos))
        }

        fn search_history_forward(&self, s: &str, include_cur: bool) -> Option<(Option<usize>, usize)>
        {
            let mut idx = self.history_index;
            let mut pos = Some(self.cursor);

            if !include_cur {
                if let Some(p) = pos {
                    pos = Some( ::char::forward(1, self.get_history(idx), p));
                }
            }

            loop {
                let line = self.get_history(idx);

                match line[pos.unwrap_or(0)..].find(s) {
                    Some(found) => {
                        pos = pos.map(|n| n + found).or(Some(found));
                        break;
                    }
                    None => {
                        if let Some(n) = idx {
                            if n + 1 == self.history.len() {
                                idx = None;
                            } else {
                                idx = Some(n + 1);
                            }
                            pos = None;
                        } else {
                            return None;
                        }
                    }
                }
            }

            pos.map(|pos| (idx, pos))
        }

        pub fn add_history(&mut self, line: String) 
        {
            if self.history.len() == self.history_size {
                self.history.pop_front();
            }

            self.history.push_back(line);
            self.history_new_entries = self.history.len()
                .min(self.history_new_entries + 1);
        }

        pub fn add_history_unique(&mut self, line: String) 
        {
            let is_duplicate = self.history.back().map_or(false, |ent| *ent == line);

            if !is_duplicate {
                self.add_history(line);
            }
        }

        pub fn clear_history(&mut self) 
        {
            self.truncate_history(0);
            self.history_new_entries = 0;
        }

        pub fn remove_history(&mut self, n: usize) 
        {
            if n < self.history.len() {
                let first_new = self.history.len() - self.history_new_entries;

                if n >= first_new {
                    self.history_new_entries -= 1;
                }

                self.history.remove(n);
            }
        }

        pub fn truncate_history(&mut self, n: usize) 
        {
            let len = self.history.len();

            if n < len {
                let _ = self.history.drain(..len - n);
                self.history_new_entries = self.history_new_entries.max(n);
            }
        }

        pub fn next_history(&mut self, n: usize) -> io::Result<()> 
        {
            if let Some(old) = self.history_index {
                let new = old.saturating_add(n);

                if new >= self.history.len() {
                    self.select_history_entry(None)?;
                } else {
                    self.select_history_entry(Some(new))?;
                }
            }

            Ok(())
        }

        pub fn prev_history(&mut self, n: usize) -> io::Result<()> 
        {
            if !self.history.is_empty() && self.history_index != Some(0) {
                let new = if let Some(old) = self.history_index {
                    old.saturating_sub(n)
                } else {
                    self.history.len().saturating_sub(n)
                };

                self.select_history_entry(Some(new))?;
            }

            Ok(())
        }

        pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
            if new != self.history_index {
                self.move_to(0)?;
                self.set_history_entry(new);
                self.new_buffer()?;
            }

            Ok(())
        }

        pub fn set_history_entry(&mut self, new: Option<usize>) 
        {
            let old = self.history_index;

            if old != new {
                let data = &mut *self.data;
                data.history_index = new;

                if let Some(old) = old {
                    data.history[old].clone_from(&data.buffer);
                } else {
                    swap(&mut data.buffer, &mut data.backup_buffer);
                }

                if let Some(new) = new {
                    data.buffer.clone_from(&data.history[new]);
                } else {
                    data.buffer.clear();
                    swap(&mut data.buffer, &mut data.backup_buffer);
                }
            }
        }

        fn get_history(&self, n: Option<usize>) -> &str 
        {
            if self.history_index == n {
                &self.buffer
            } else if let Some(n) = n {
                &self.history[n]
            } else {
                &self.backup_buffer
            }
        }

        pub fn backward_char(&mut self, n: usize) -> io::Result<()> 
        {
            let pos = ::char::backward(n, &self.buffer, self.cursor);
            self.move_to(pos)
        }

        pub fn forward_char(&mut self, n: usize) -> io::Result<()>
        {
            let pos = ::char::forward(n, &self.buffer, self.cursor);
            self.move_to(pos)
        }

        pub fn backward_search_char(&mut self, n: usize, ch: char) -> io::Result<()>
        {
            if let Some(pos) = ::char::backward_search(n, &self.buffer, self.cursor, ch)
            {
                self.move_to(pos)?;
            }

            Ok(())
        }

        pub fn forward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> 
        {
            if let Some(pos) = ::char::forward_search(n, &self.buffer, self.cursor, ch)
            {
                self.move_to(pos)?;
            }

            Ok(())
        }

        /// Deletes a range from the buffer; the cursor is moved to the end
        /// of the given range.
        pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
            let start = range.start().cloned().unwrap_or(0);
            let end = range.end().cloned().unwrap_or_else(|| self.buffer.len());

            self.move_to(start)?;

            let _ = self.buffer.drain(start..end);

            self.draw_buffer(start)?;
            self.term.clear_to_screen_end()?;
            let len = self.buffer.len();
            self.move_from(len)?;

            Ok(())
        }

        pub fn insert_str(&mut self, s: &str) -> io::Result<()>
        {
            let moves_combining = match self.buffer[self.cursor..].chars().next()
            {
                Some(ch) if ::is::combining_mark(ch) => true,
                _ => false
            };

            let cursor = self.cursor;
            self.buffer.insert_str(cursor, s);

            if moves_combining && cursor != 0
            {
                let pos = ::char::backward(1, &self.buffer, self.cursor);
                let (lines, cols) = self.move_delta(cursor, pos, &self.buffer);
                self.move_rel(lines, cols)?;
                self.draw_buffer(pos)?;
            }
            else { self.draw_buffer(cursor)?; }

            self.cursor += s.len();
            let len = self.buffer.len();
            self.move_from(len)
        }

        pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                -> io::Result<()> {
            // Ranges must not overlap
            assert!(src.end <= dest.start || src.start >= dest.end);

            // Final cursor position
            let final_cur = if src.start < dest.start {
                dest.end
            } else {
                dest.start + (src.end - src.start)
            };

            let (left, right) = if src.start < dest.start {
                (src, dest)
            } else {
                (dest, src)
            };

            self.move_to(left.start)?;

            let a = self.buffer[left.clone()].to_owned();
            let b = self.buffer[right.clone()].to_owned();

            let _ = self.buffer.drain(right.clone());
            self.buffer.insert_str(right.start, &a);

            let _ = self.buffer.drain(left.clone());
            self.buffer.insert_str(left.start, &b);

            let cursor = self.cursor;
            self.draw_buffer(cursor)?;
            self.term.clear_to_screen_end()?;

            self.cursor = final_cur;
            let len = self.buffer.len();
            self.move_from(len)
        }

        fn prompt_suffix_length(&self) -> usize {
            match self.prompt_type {
                PromptType::Normal => self.prompt_suffix_len,
                PromptType::Number => {
                    let n = number_len(self.input_arg.to_i32());
                    PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                }
                PromptType::Search => {
                    let mut prefix = PROMPT_SEARCH_PREFIX;

                    if self.reverse_search {
                        prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                    }
                    if self.search_failed {
                        prefix += PROMPT_SEARCH_FAILED_PREFIX;
                    }

                    let n = self.display_size(&self.search_buffer, prefix);
                    prefix + n + PROMPT_SEARCH_SUFFIX
                }
                PromptType::CompleteIntro(n) => complete_intro(n).len(),
                PromptType::CompleteMore => COMPLETE_MORE.len(),
            }
        }

        fn line_col(&self, pos: usize) -> (usize, usize) {
            let prompt_len = self.prompt_suffix_length();

            match self.prompt_type {
                PromptType::CompleteIntro(_) |
                PromptType::CompleteMore => {
                    let width = self.screen_size.columns;
                    (prompt_len / width, prompt_len % width)
                }
                _ => self.line_col_with(pos, &self.buffer, prompt_len)
            }
        }

        fn line_col_with(&self, pos: usize, buf: &str, start_col: usize) -> (usize, usize) {
            let width = self.screen_size.columns;
            if width == 0 {
                return (0, 0);
            }

            let n = start_col + self.display_size(&buf[..pos], start_col);

            (n / width, n % width)
        }

        pub fn clear_screen(&mut self) -> io::Result<()> {
            self.term.clear_screen()?;
            self.draw_prompt()?;

            Ok(())
        }

        pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
            self.term.clear_to_screen_end()
        }

        /// Draws a new buffer on the screen. Cursor position is assumed to be `0`.
        pub fn new_buffer(&mut self) -> io::Result<()> {
            self.draw_buffer(0)?;
            self.cursor = self.buffer.len();

            self.term.clear_to_screen_end()?;

            Ok(())
        }

        pub fn clear_full_prompt(&mut self) -> io::Result<()> {
            let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
            let (line, _) = self.line_col(self.cursor);
            self.term.move_up(prefix_lines + line)?;
            self.term.move_to_first_column()?;
            self.term.clear_to_screen_end()
        }

        pub fn clear_prompt(&mut self) -> io::Result<()> {
            let (line, _) = self.line_col(self.cursor);

            self.term.move_up(line)?;
            self.term.move_to_first_column()?;
            self.term.clear_to_screen_end()
        }

        /// Move back to true cursor position from some other position
        pub fn move_from(&mut self, pos: usize) -> io::Result<()> {
            let (lines, cols) = self.move_delta(pos, self.cursor, &self.buffer);
            self.move_rel(lines, cols)
        }

        pub fn move_to(&mut self, pos: usize) -> io::Result<()> {
            if pos != self.cursor {
                let (lines, cols) = self.move_delta(self.cursor, pos, &self.buffer);
                self.move_rel(lines, cols)?;
                self.cursor = pos;
            }

            Ok(())
        }

        pub fn move_to_end(&mut self) -> io::Result<()> {
            let pos = self.buffer.len();
            self.move_to(pos)
        }

        pub fn move_right(&mut self, n: usize) -> io::Result<()> {
            self.term.move_right(n)
        }

        /// Moves from `old` to `new` cursor position, using the given buffer
        /// as current input.
        fn move_delta(&self, old: usize, new: usize, buf: &str) -> (isize, isize) {
            let prompt_len = self.prompt_suffix_length();
            let (old_line, old_col) = self.line_col_with(old, buf, prompt_len);
            let (new_line, new_col) = self.line_col_with(new, buf, prompt_len);

            (new_line as isize - old_line as isize,
            new_col as isize - old_col as isize)
        }

        fn move_rel(&mut self, lines: isize, cols: isize) -> io::Result<()> {
            if lines > 0 {
                self.term.move_down(lines as usize)?;
            } else if lines < 0 {
                self.term.move_up((-lines) as usize)?;
            }

            if cols > 0 {
                self.term.move_right(cols as usize)?;
            } else if cols < 0 {
                self.term.move_left((-cols) as usize)?;
            }

            Ok(())
        }

        pub fn reset_data(&mut self) {
            self.data.reset_data();
        }

        pub fn set_digit_from_char(&mut self, ch: char) {
            let digit = match ch {
                '-' => Digit::NegNone,
                '0' ..= '9' => Digit::from(ch),
                _ => Digit::None
            };

            self.input_arg = digit;
            self.explicit_arg = true;
        }
    }

    #[derive(Copy, Clone)]
    struct Blink
    {
        pos: usize,
        expiry: Instant,
    }

    impl<'a, 'b: 'a, Term: 'b + Terminals> Writer<'a, 'b, Term>
    {
        fn new(mut write: WriterImpl<'a, 'b, Term>, clear: bool) -> io::Result<Self> {
            write.expire_blink()?;

            if write.is_prompt_drawn {
                if clear {
                    write.clear_full_prompt()?;
                } else {
                    write.move_to_end()?;
                    write.write_str("\n")?;
                }
            }

            Ok(Writer{write})
        }

        pub fn with_lock(write: WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
            Writer::new(WriterImpl::Mutex(write), clear)
        }

        pub fn with_ref(write: &'a mut WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
            Writer::new(WriterImpl::MutRef(write), clear)
        }

        /// Returns an iterator over history entries.
        pub fn history(&self) -> HistoryIter {
            self.write.history()
        }

        /// Writes some text to the terminal device.
        ///
        /// Before the `Writer` is dropped, any output written should be followed
        /// by a newline. A newline is automatically written if the `writeln!`
        /// macro is used.
        pub fn write_str(&mut self, s: &str) -> io::Result<()> {
            self.write.write_str(s)
        }

        /// Writes formatted text to the terminal display.
        ///
        /// This method enables `Interface` to be used as the receiver to
        /// the [`writeln!`] macro.
        ///
        /// If the text contains any unprintable characters (e.g. escape sequences),
        /// those characters will be escaped before printing.
        ///
        /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
        /// [`writeln!`]: https://doc.rust-lang.org/std/macro.writeln.html
        pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {
            let s = args.to_string();
            self.write_str(&s)
        }
    }

    impl<'a, 'b: 'a, Term: 'b + Terminals> Drop for Writer<'a, 'b, Term>
    {
        fn drop(&mut self) {
            if self.write.is_prompt_drawn {
                // There's not really anything useful to be done with this error.
                let _ = self.write.draw_prompt();
            }
        }
    }

    impl<'a, Term: 'a + Terminals> Deref for WriteLock<'a, Term>
    {
        type Target = Write;

        fn deref(&self) -> &Write {
            &self.data
        }
    }

    impl<'a, Term: 'a + Terminals> DerefMut for WriteLock<'a, Term>
    {
        fn deref_mut(&mut self) -> &mut Write {
            &mut self.data
        }
    }
    
    #[derive(Copy, Clone, Debug)]
    pub enum Digit
    {
        None,
        NegNone,
        Num(i32),
        NegNum(i32),
    }

    impl Digit
    {
        pub fn input(&mut self, n: i32)
        {
            match *self
            {
                Digit::None => *self = Digit::Num(n),
                Digit::NegNone => *self = Digit::NegNum(n),
                Digit::Num(ref mut m) | Digit::NegNum(ref mut m) =>
                {
                    *m *= 10;
                    *m += n;
                }
            }
        }

        pub fn is_out_of_bounds(&self) -> bool
        {
            match *self
            {
                Digit::Num(n) | Digit::NegNum(n) if n > NUMBER_MAX => true,
                _ => false
            }
        }

        pub fn to_i32(&self) -> i32
        {
            match *self
            {
                Digit::None => 1,
                Digit::NegNone => -1,
                Digit::Num(n) => n,
                Digit::NegNum(n) => -n,
            }
        }
    }

    impl From<char> for Digit
    {
        /// Convert a decimal digit character to a `Digit` value.
        fn from(ch: char) -> Digit
        {
            let n = (ch as u8) - b'0';
            Digit::Num(n as i32)
        }
    }

    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum PromptType
    {
        Normal,
        Number,
        Search,
        CompleteIntro(usize),
        CompleteMore,
    }

    impl PromptType
    {
        pub fn is_normal(&self) -> bool { *self == PromptType::Normal }
    }

    impl<'a, 'b, Term: 'b + Terminals> Deref for WriterImpl<'a, 'b, Term>
    {
        type Target = WriteLock<'b, Term>;
        fn deref(&self) -> &WriteLock<'b, Term>
        {
            match *self
            {
                WriterImpl::Mutex(ref m) => m,
                WriterImpl::MutRef(ref m) => m,
            }
        }
    }

    impl<'a, 'b: 'a, Term: 'b + Terminals> DerefMut for WriterImpl<'a, 'b, Term>
    {
        fn deref_mut(&mut self) -> &mut WriteLock<'b, Term>
        {
            match *self
            {
                WriterImpl::Mutex(ref mut m) => m,
                WriterImpl::MutRef(ref mut m) => m,
            }
        }
    }
    /// Iterator over `Interface` history entries
    pub struct HistoryIter<'a>(vec_deque::Iter<'a, String>);

    impl<'a> ExactSizeIterator for HistoryIter<'a> {}

    impl<'a> Iterator for HistoryIter<'a>
    {
        type Item = &'a str;

        #[inline] fn next(&mut self) -> Option<&'a str> { self.0.next().map(|s| &s[..]) }

        #[inline] fn nth(&mut self, n: usize) -> Option<&'a str> { self.0.nth(n).map(|s| &s[..]) }

        #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }
    }

    impl<'a> DoubleEndedIterator for HistoryIter<'a>
    {
        #[inline] fn next_back(&mut self) -> Option<&'a str> { self.0.next_back().map(|s| &s[..]) }
    }

    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    pub enum DisplaySequence
    {
        Char(char),
        Escape(char),
        End,
    }

    impl Iterator for DisplaySequence
    {
        type Item = char;

        fn next(&mut self) -> Option<char>
        {
            use self::DisplaySequence::*;

            let (res, next) = match *self
            {
                Char(ch) => (ch, End),
                Escape(ch) => ('^', Char(ch)),
                End => return None
            };

            *self = next;
            Some(res)
        }

        fn size_hint(&self) -> (usize, Option<usize>)
        {
            use self::DisplaySequence::*;

            let n = match *self
            {
                Char(_) => 1,
                Escape(_) => 2,
                End => 0,
            };

            (n, Some(n))
        }
    }

    #[derive(Copy, Clone, Debug, Default)]
    pub struct Display
    {
        allow_tab: bool,
        allow_newline: bool,
        allow_escape: bool,
    }

    pub fn display(ch: char, style: Display) -> DisplaySequence
    {
        match ch
        {
            '\t' if style.allow_tab => DisplaySequence::Char(ch),
            '\n' if style.allow_newline => DisplaySequence::Char(ch),
            ESCAPE if style.allow_escape => DisplaySequence::Char(ch),
            '\0' => DisplaySequence::Escape('@'),
            RUBOUT => DisplaySequence::Escape('?'),
            ch if is_ctrl(ch) => DisplaySequence::Escape(unctrl(ch)),
            ch => DisplaySequence::Char(ch)
        }
    }

    pub fn display_str<'a>(s: &'a str, style: Display) -> Cow<'a, str>
    {
        if s.chars().all(|ch| display(ch, style) == DisplaySequence::Char(ch))
        {
            Borrowed(s)
        } else {
            Owned(s.chars().flat_map(|ch| display(ch, style)).collect())
        }
    }

    fn complete_intro(n: usize) -> String { format!("Display all {} possibilities? (y/n)", n) }

    fn number_len(n: i32) -> usize
    {
        match n
        {
            -1_000_000              => 8,
            -  999_999 ..= -100_000 => 7,
            -   99_999 ..= - 10_000 => 6,
            -    9_999 ..= -  1_000 => 5,
            -      999 ..= -    100 => 4,
            -       99 ..= -     10 => 3,
            -        9 ..= -      1 => 2,
                    0 ..=        9 => 1,
                    10 ..=       99 => 2,
                100 ..=      999 => 3,
                1_000 ..=    9_999 => 4,
                10_000 ..=   99_999 => 5,
            100_000 ..=  999_999 => 6,
            1_000_000              => 7,
            _ => unreachable!()
        }
    }
}

fn main()
{
    unsafe
    {
        libc::signal(libc::SIGPIPE, libc::SIG_DFL);

        // ignore SIGTSTP (ctrl-Z) for the shell itself
        libc::signal(libc::SIGTSTP, libc::SIG_IGN);
        libc::signal(libc::SIGQUIT, libc::SIG_IGN);
    }

    ::env::initialize_paths();

    let mut sh = ::shell::Shell::new();
    let args: Vec<String> = ::env::args().collect();

    if ::is::login(&args)
    {
        ::fs::load_rc_files(&mut sh);
        sh.is_login = true;
    }
    
    ::prompt::initialize_cache();
    ::prompt::update_aliases( &sh );

    if ::is::script(&args)
    {
        log!("run script: {:?} ", &args);
        let status = ::scripts::run(&mut sh, &args);
        ::process::exit(status);
    }

    if ::is::command_string(&args)
    {
        let line = ::env::args_to_command_line();
        log!("run with -c args: {}", &line);
        now::run_command_line(&mut sh, &line, false, false);
        ::process::exit(sh.previous_status);
    }

    if ::is::non_tty()
    {
        now::run_procs_for_non_tty(&mut sh);
        return;
    }

    let mut rl;
    match ::ffi::Interface::new("pls")
    {
        Ok(x) => rl = x,
        Err(e) =>
        {
            println!(":: lineread error: {}", e);
            return;
        }
    }

    rl.define_function("enter-function", Arc::new( ffi::EnterFunction ));
    rl.bind_sequence("\r", ::command::Command::from_str("enter-function"));

    let highlighter = prompt::create_highlighter();
    rl.set_highlighter(highlighter);

    history::initialize(&mut rl);
    rl.set_completer(Arc::new(complete::ShellCompleter
    {
        sh: Arc::new(sh.clone()),
    }));

    let sig_handler_enabled = ::is::signal_handler_enabled();
    
    if sig_handler_enabled
    {
        signals::setup_sigchld_handler();
        signals::block();
    }

    loop
    {
        let prompt = prompt::get(&sh);
        match rl.set_prompt(&prompt)
        {
            Ok(_) => {}
            Err(e) =>
            {
                println_stderr!(":: prompt error: {}", e);
            }
        }

        if sig_handler_enabled  { signals::unblock(); }
        
        match rl.read_line() 
        {
            Ok( ::reader::ReadResult::Input( line ) ) => 
            {
                if sig_handler_enabled { signals::block(); }

                let line = shell::trim_multiline_prompts(&line);
                
                if line.trim() == ""
                {
                    task::c::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                    continue;
                }

                sh.cmd = line.clone();

                let tsb = ::time::c::DateTime::now().unix_timestamp();
                let mut line = line.clone();
                
                ::expand::bangbang(&sh, &mut line);

                let mut status = 0;
                let cr_list = ::now::run_command_line(&mut sh, &line, true, false);

                if let Some(last) = cr_list.last() { status = last.status; }

                let tse = ::time::c::DateTime::now().unix_timestamp();

                if !sh.cmd.starts_with(' ') && line != sh.previous_cmd
                {
                    ::history::add(&sh, &mut rl, &line, status, tsb, tse);
                    sh.previous_cmd = line.clone();
                }

                if ::is::shell_altering_command( &line )
                {
                    rl.set_completer(Arc::new( ::complete::ShellCompleter
                    {
                        sh: Arc::new(sh.clone()),
                    }));
                    
                    ::prompt::update_aliases(&sh);
                }

                task::c::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                continue;
            }
            
            Ok( ::reader::ReadResult::Eof ) => 
            {
                if let Ok(x) = ::env::var("NO_EXIT_ON_CTRL_D") { if x == "1" { println!(); } }
                else
                {
                    println!("exit");
                    break;
                }
            }

            Ok( ::reader::ReadResult::Signal( s ) ) => 
            {
                println_stderr!("readline signal: {:?}", s);
            }

            Err(e) => 
            {
                println_stderr!("readline error: {}", e);
                unsafe
                {
                    let gid = ::libc::getpgid(0);
                    ::terminal::give_to(gid);
                }
            }
        }

        if sig_handler_enabled { signals::block(); }
    }
}
// #\[stable\(feature = ".+", since = ".+"\)\]
// #\[unstable\(feature = ".+", issue = ".+"\)\]
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 13872
