#![allow
(
    ambiguous_glob_reexports,
    dead_code,
    elided_named_lifetimes,
    non_camel_case_types,
    non_snake_case,
    private_interfaces,
    stable_features,
    unknown_lints,
    unreachable_patterns,
    unused_assignments,
    unused_imports,
    unused_macros,
    unused_mut,
    unused_unsafe,
    unused_variables,
)]
#[macro_use] extern crate lazy_static;
extern crate rand;
extern crate fnv;
extern crate memchr;
extern crate nix;
extern crate regex as re;
extern crate smallvec;
extern crate time as timed;
extern crate unicode_normalization;
extern crate unicode_width;

#[macro_use] pub mod macros
{
    /// The main macro provided by this crate. See crate documentation for more information.
    #[macro_export] macro_rules! cfg_if
    {
        (
            $(
                if #[cfg( $i_meta:meta )] { $( $i_tokens:tt )* }
            ) else+
            else { $( $e_tokens:tt )* }
        ) =>
        {
            ::cfg_if!
            {
                @__items () ;
                $(
                    (( $i_meta ) ( $( $i_tokens )* )) ,
                )+
                (() ( $( $e_tokens )* )) ,
            }
        };
        
        (
            if #[cfg( $i_meta:meta )] { $( $i_tokens:tt )* }
            $(
                else if #[cfg( $e_meta:meta )] { $( $e_tokens:tt )* }
            )*
        ) =>
        {
            ::cfg_if!
            {
                @__items () ;
                (( $i_meta ) ( $( $i_tokens )* )) ,
                $(
                    (( $e_meta ) ( $( $e_tokens )* )) ,
                )*
            }
        };
        
        (@__items ( $( $_:meta , )* ) ; ) => {};
        (
            @__items ( $( $no:meta , )* ) ;
            (( $( $yes:meta )? ) ( $( $tokens:tt )* )) ,
            $( $rest:tt , )*
        ) =>
        {
            #[cfg(all
            (
                $( $yes , )?
                not(any( $( $no ),* ))
            ))]
            ::cfg_if! { @__identity $( $tokens )* }
            
            ::cfg_if!
            {
                @__items ( $( $no , )* $( $yes , )? ) ;
                $( $rest , )*
            }
        };
        
        (@__identity $( $tokens:tt )* ) => { $( $tokens )* };
    }
    /// Create an internal crate prelude with `core` reexports and common types.
    #[macro_export] macro_rules! prelude
    {
        () => {
            /// Frequently-used types that are available on all platforms
            ///
            /// We need to reexport the core types so this works with `rust-dep-of-std`.
            mod prelude {
                // Exports from `core`
                #[allow(unused_imports)]
                pub(crate) use ::core::clone::Clone;
                #[allow(unused_imports)]
                pub(crate) use ::core::marker::{Copy, Send, Sync};
                #[allow(unused_imports)]
                pub(crate) use ::core::option::Option;
                #[allow(unused_imports)]
                pub(crate) use ::core::{fmt, hash, iter, mem};
                #[allow(unused_imports)]
                pub(crate) use mem::{align_of, align_of_val, size_of, size_of_val};

                // Commonly used types defined in this crate
                #[allow(unused_imports)]
                pub(crate) use  {
                    c_char, c_double, c_float, c_int, c_long, c_longlong, c_short, c_uchar, c_uint,
                    c_ulong, c_ulonglong, c_ushort, c_void, intptr_t, size_t, ssize_t, uintptr_t,
                };
            }
        };
    }
    /// Implement `Clone` and `Copy` for a struct,
    /// as well as `Debug`, `Eq`, `Hash`, and `PartialEq` if the `extra_traits` feature is enabled.
    macro_rules! s
    {
        ($(
            $(#[$attr:meta])*
            pub $t:ident $i:ident { $($field:tt)* }
        )*) => 
        ($(
            s!(it: $(#[$attr])* pub $t $i { $($field)* });
        )*);

        (it: $(#[$attr:meta])* pub union $i:ident { $($field:tt)* }) => 
        (
            compile_error!("unions cannot derive extra traits, use s_no_extra_traits instead");
        );

        (it: $(#[$attr:meta])* pub struct $i:ident { $($field:tt)* }) => 
        (
            __item! 
            {
                #[repr(C)]
                #[cfg_attr
                (
                    feature = "extra_traits", derive( Debug, Eq, Hash, PartialEq )
                )]
                #[derive( Clone, Copy )] #[allow(deprecated)]
                $(#[$attr])*
                pub struct $i { $($field)* }
            }
        );
    }
    /// Implement `Clone` and `Copy` for a tuple struct,
    /// as well as `Debug`, `Eq`, `Hash`, and `PartialEq` if the `extra_traits` feature is enabled.
    macro_rules! s_paren
    {
        ($(
            $(#[$attr:meta])*
            pub struct $i:ident ( $($field:tt)* );
        )*) => ($(
            __item! {
                #[cfg_attr(
                    feature = "extra_traits",
                    ::core::prelude::v1::derive(Debug, Eq, Hash, PartialEq)
                )]
                #[::core::prelude::v1::derive(::core::clone::Clone, ::core::marker::Copy)]
                $(#[$attr])*
                pub struct $i ( $($field)* );
            }
        )*);
    }
    /// Implement `Clone` and `Copy` for a struct with no `extra_traits` feature, 
    /// as well as `Debug` with `extra_traits` since that can always be derived.
    macro_rules! s_no_extra_traits
    {
        ($(
            $(#[$attr:meta])*
            pub $t:ident $i:ident { $($field:tt)* }
        )*) => ($(
            s_no_extra_traits!(it: $(#[$attr])* pub $t $i { $($field)* });
        )*);

        (it: $(#[$attr:meta])* pub union $i:ident { $($field:tt)* }) => (
            __item! {
                #[repr(C)]
                #[::core::prelude::v1::derive(::core::clone::Clone, ::core::marker::Copy)]
                $(#[$attr])*
                pub union $i { $($field)* }
            }

            #[cfg(feature = "extra_traits")]
            impl ::core::fmt::Debug for $i {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct(::core::stringify!($i)).finish_non_exhaustive()
                }
            }
        );

        (it: $(#[$attr:meta])* pub struct $i:ident { $($field:tt)* }) => (
            __item! {
                #[repr(C)]
                #[::core::prelude::v1::derive(::core::clone::Clone, ::core::marker::Copy)]
                #[cfg_attr(feature = "extra_traits", ::core::prelude::v1::derive(Debug))]
                $(#[$attr])*
                pub struct $i { $($field)* }
            }
        );
    }
    /// Specify that an enum should have no traits that aren't specified in the macro invocation.
    macro_rules! missing
    {
        ($(
            $(#[$attr:meta])*
            pub enum $i:ident {}
        )*) => ($(
            $(#[$attr])*
            #[allow(missing_copy_implementations)]
            pub enum $i { }
        )*);
    }
    /// Implement `Clone` and `Copy` for an enum, 
    /// as well as `Debug`, `Eq`, `Hash`, and `PartialEq` if the `extra_traits` feature is enabled.
    macro_rules! e
    {
        ($(
            $(#[$attr:meta])*
            pub enum $i:ident { $($field:tt)* }
        )*) => ($(
            __item! {
                #[cfg_attr(
                    feature = "extra_traits",
                    ::core::prelude::v1::derive(Debug, Eq, Hash, PartialEq)
                )]
                #[::core::prelude::v1::derive(::core::clone::Clone, ::core::marker::Copy)]
                $(#[$attr])*
                pub enum $i { $($field)* }
            }
        )*);
    }
    /// Represent a C enum as Rust constants and a type.
    macro_rules! c_enum
    {
        (
            $(#[repr($repr:ty)])?
            enum $ty_name:ident {
                $($variant:ident $(= $value:literal)?,)+
            }
        ) => {
            pub type $ty_name = c_enum!(@ty $($repr)?);
            c_enum!(@one; $ty_name; 0; $($variant $(= $value)?,)+);
        };

        // Matcher for a single variant
        (@one; $_ty_name:ident; $_idx:expr;) => {};
        (
            @one; $ty_name:ident; $default_val:expr;
            $variant:ident $(= $value:literal)?,
            $($tail:tt)*
        ) => {
            pub const $variant: $ty_name = {
                #[allow(unused_variables)]
                let r = $default_val;
                $(let r = $value;)?
                r
            };

            // The next value is always one more than the previous value, unless
            // set explicitly.
            c_enum!(@one; $ty_name; $variant + 1; $($tail)*);
        };

        // Use a specific type if provided, otherwise default to `c_uint`
        (@ty $repr:ty) => { $repr };
        (@ty) => { $ c_uint };
    }

    cfg_if!
    {
        if #[cfg(libc_const_extern_fn)] 
        {
            /// Define an `unsafe` function that is const as long as `libc_const_extern_fn` is enabled.
            macro_rules! f {
                ($(
                    $(#[$attr:meta])*
                    pub $({$constness:ident})* fn $i:ident($($arg:ident: $argty:ty),* $(,)*) -> $ret:ty
                        $body:block
                )*) => ($(
                    #[inline]
                    $(#[$attr])*
                    pub $($constness)* unsafe extern "C" fn $i($($arg: $argty),*) -> $ret
                        $body
                )*)
            }

            /// Define a safe function that is const as long as `libc_const_extern_fn` is enabled.
            macro_rules! safe_f {
                ($(
                    $(#[$attr:meta])*
                    pub $({$constness:ident})* fn $i:ident($($arg:ident: $argty:ty),* $(,)*) -> $ret:ty
                        $body:block
                )*) => ($(
                    #[inline]
                    $(#[$attr])*
                    pub $($constness)* extern "C" fn $i($($arg: $argty),*) -> $ret
                        $body
                )*)
            }

            /// A nonpublic function that is const as long as `libc_const_extern_fn` is enabled.
            macro_rules! const_fn {
                ($(
                    $(#[$attr:meta])*
                    $({$constness:ident})* fn $i:ident($($arg:ident: $argty:ty),* $(,)*) -> $ret:ty
                        $body:block
                )*) => ($(
                    #[inline]
                    $(#[$attr])*
                    $($constness)* fn $i($($arg: $argty),*) -> $ret
                        $body
                )*)
            }
        }
        
        else
        {
            /// Define an `unsafe` function that is const as long as `libc_const_extern_fn` is enabled.
            macro_rules! f 
            {
                ($(
                    $(#[$attr:meta])*
                    pub $({$constness:ident})* fn $i:ident($($arg:ident: $argty:ty),* $(,)*) -> $ret:ty
                        $body:block
                )*) => ($(
                    #[inline]
                    $(#[$attr])*
                    pub unsafe extern "C" fn $i($($arg: $argty),*) -> $ret
                        $body
                )*)
            }
            /// Define a safe function that is const as long as `libc_const_extern_fn` is enabled.
            macro_rules! safe_f 
            {
                ($(
                    $(#[$attr:meta])*
                    pub $({$constness:ident})* fn $i:ident($($arg:ident: $argty:ty),* $(,)*) -> $ret:ty
                        $body:block
                )*) => ($(
                    #[inline]
                    $(#[$attr])*
                    pub extern "C" fn $i($($arg: $argty),*) -> $ret
                        $body
                )*)
            }
            /// A nonpublic function that is const as long as `libc_const_extern_fn` is enabled.
            macro_rules! const_fn
            {
                ($(
                    $(#[$attr:meta])*
                    $({$constness:ident})* fn $i:ident($($arg:ident: $argty:ty),* $(,)*) -> $ret:ty
                        $body:block
                )*) => ($(
                    #[inline]
                    $(#[$attr])*
                    fn $i($($arg: $argty),*) -> $ret
                        $body
                )*)
            }
        }
    }

    macro_rules! __item
    {
        ($i:item) => { $i };
    }
}

pub mod boxed
{
    pub use std::boxed::{ * };
}

pub mod clone
{
    pub use std::clone::{ * };
}

pub mod libc
{
    pub mod prelude
    {
        //! This module contains type aliases for C's platform-specific types and fixed-width integer types.
        pub type c_schar = i8;
        pub type c_uchar = u8;
        pub type c_short = i16;
        pub type c_ushort = u16;

        pub type c_longlong = i64;
        pub type c_ulonglong = u64;

        pub type c_float = f32;
        pub type c_double = f64;

        cfg_if!
        {
            if #[cfg(all(
                not(windows),
                // FIXME(ctest): just use `target_vendor` = "apple"` once `ctest` supports it
                not(any(
                    target_os = "macos",
                    target_os = "ios",
                    target_os = "tvos",
                    target_os = "watchos",
                    target_os = "visionos",
                )),
                not(target_os = "vita"),
                any(
                    target_arch = "aarch64",
                    target_arch = "arm",
                    target_arch = "csky",
                    target_arch = "hexagon",
                    target_arch = "msp430",
                    target_arch = "powerpc",
                    target_arch = "powerpc64",
                    target_arch = "riscv32",
                    target_arch = "riscv64",
                    target_arch = "s390x",
                    target_arch = "xtensa",
                )
            ))] {
                pub type c_char = u8;
            } else {
                // On every other target, c_char is signed.
                pub type c_char = i8;
            }
        }

        cfg_if!
        {
            if #[cfg(any(target_arch = "avr", target_arch = "msp430"))]
            {
                pub type c_int = i16;
                pub type c_uint = u16;
            }

            else
            {
                pub type c_int = i32;
                pub type c_uint = u32;
            }
        }

        cfg_if!
        {
            if #[cfg(all(target_pointer_width = "64", not(windows)))]
            {
                pub type c_long = i64;
                pub type c_ulong = u64;
            }

            else
            {
                pub type c_long = i32;
                pub type c_ulong = u32;
            }
        }

        pub type int8_t = i8;
        pub type int16_t = i16;
        pub type int32_t = i32;
        pub type int64_t = i64;
        pub type uint8_t = u8;
        pub type uint16_t = u16;
        pub type uint32_t = u32;
        pub type uint64_t = u64;

        cfg_if!
        {
            if #[cfg(all
            (
                target_arch = "aarch64",
                not(any
                (
                    target_os = "windows",
                    target_os = "macos",
                    target_os = "ios",
                    target_os = "tvos",
                    target_os = "watchos"
                ))
            ))]
            {
                pub type __int128 = i128;
                pub type __uint128 = u128;
                pub type __int128_t = i128;
                pub type __uint128_t = u128;
                const _SIZE_128: usize = 16;
                const _ALIGN_128: usize = 16;
                
                // static_assert_eq!(size_of::<__int128>(), _SIZE_128);
                // static_assert_eq!(align_of::<__int128>(), _ALIGN_128);
                // static_assert_eq!(size_of::<__uint128>(), _SIZE_128);
                // static_assert_eq!(align_of::<__uint128>(), _ALIGN_128);
                // static_assert_eq!(size_of::<__int128_t>(), _SIZE_128);
                // static_assert_eq!(align_of::<__int128_t>(), _ALIGN_128);
                // static_assert_eq!(size_of::<__uint128_t>(), _SIZE_128);
                // static_assert_eq!(align_of::<__uint128_t>(), _ALIGN_128);
            }
            else if #[cfg(all
            (
                target_arch = "aarch64",
                any
                (
                    target_os = "macos",
                    target_os = "ios",
                    target_os = "tvos",
                    target_os = "watchos"
                )
            ))]
            {
                pub type __int128_t = i128;
                pub type __uint128_t = u128;
            }
        }
    } pub use self::prelude::{ * };

    pub mod unix
    {
        use ::
        {
            libc::{ * },
            os::raw::{ c_void, },
            *,
        };

        pub type intmax_t = i64;
        pub type uintmax_t = u64;

        pub type size_t = usize;
        pub type ptrdiff_t = isize;
        pub type intptr_t = isize;
        pub type uintptr_t = usize;
        pub type ssize_t = isize;

        pub type pid_t = i32;
        pub type in_addr_t = u32;
        pub type in_port_t = u16;
        pub type sighandler_t = size_t;
        pub type cc_t = c_uchar;
        
        pub type uid_t = u32;
        pub type gid_t = u32;
        
        pub type time_t = c_longlong;
        pub type suseconds_t = i32;
        pub type clock_t = c_long;

        missing!
        {
            #[cfg_attr(feature = "extra_traits", derive(Debug))]
            pub enum DIR {}
        }

        pub type locale_t = *mut c_void;

        s! 
        {
            pub struct group
            {
                pub gr_name: *mut c_char,
                pub gr_passwd: *mut c_char,
                pub gr_gid: gid_t,
                pub gr_mem: *mut *mut c_char,
            }

            pub struct utimbuf
            {
                pub actime: time_t,
                pub modtime: time_t,
            }

            pub struct timeval
            {
                pub tv_sec: time_t,
                pub tv_usec: suseconds_t,
            }

            pub struct rlimit 
            {
                pub rlim_cur: rlim_t,
                pub rlim_max: rlim_t,
            }

            pub struct rusage 
            {
                pub ru_utime: timeval,
                pub ru_stime: timeval,
                pub ru_maxrss: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad1: u32,
                pub ru_ixrss: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad2: u32,
                pub ru_idrss: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad3: u32,
                pub ru_isrss: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad4: u32,
                pub ru_minflt: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad5: u32,
                pub ru_majflt: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad6: u32,
                pub ru_nswap: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad7: u32,
                pub ru_inblock: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad8: u32,
                pub ru_oublock: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad9: u32,
                pub ru_msgsnd: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad10: u32,
                pub ru_msgrcv: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad11: u32,
                pub ru_nsignals: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad12: u32,
                pub ru_nvcsw: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad13: u32,
                pub ru_nivcsw: c_long,
                #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
                __pad14: u32,
            }

            pub struct ipv6_mreq 
            {
                pub ipv6mr_multiaddr: in6_addr,
                pub ipv6mr_interface: c_uint,
            }

            pub struct hostent
            {
                pub h_name: *mut c_char,
                pub h_aliases: *mut *mut c_char,
                pub h_addrtype: c_int,
                pub h_length: c_int,
                pub h_addr_list: *mut *mut c_char,
            }

            pub struct iovec
            {
                pub iov_base: *mut c_void,
                pub iov_len: size_t,
            }

            pub struct pollfd
            {
                pub fd: c_int,
                pub events: c_short,
                pub revents: c_short,
            }

            pub struct winsize
            {
                pub ws_row: c_ushort,
                pub ws_col: c_ushort,
                pub ws_xpixel: c_ushort,
                pub ws_ypixel: c_ushort,
            }
            
            pub struct linger
            {
                pub l_onoff: c_int,
                pub l_linger: c_int,
            }

            pub struct sigval
            {
                pub sival_ptr: *mut c_void,
            }
            
            pub struct itimerval
            {
                pub it_interval: timeval,
                pub it_value: timeval,
            }
            
            pub struct tms
            {
                pub tms_utime: clock_t,
                pub tms_stime: clock_t,
                pub tms_cutime: clock_t,
                pub tms_cstime: clock_t,
            }

            pub struct servent
            {
                pub s_name: *mut c_char,
                pub s_aliases: *mut *mut c_char,
                pub s_port: c_int,
                pub s_proto: *mut c_char,
            }

            pub struct protoent 
            {
                pub p_name: *mut c_char,
                pub p_aliases: *mut *mut c_char,
                pub p_proto: c_int,
            }

            #[repr(align(4))]
            pub struct in6_addr
            {
                pub s6_addr: [u8; 16],
            }
        }

        pub const INT_MIN:c_int = -2147483648;
        pub const INT_MAX:c_int = 2147483647;

        pub const SIG_DFL:sighandler_t = 0 as sighandler_t;
        pub const SIG_IGN:sighandler_t = 1 as sighandler_t;
        pub const SIG_ERR:sighandler_t = !0 as sighandler_t;
        
        pub const DT_UNKNOWN: u8 = 0;
        pub const DT_FIFO: u8 = 1;
        pub const DT_CHR: u8 = 2;
        pub const DT_DIR: u8 = 4;
        pub const DT_BLK: u8 = 6;
        pub const DT_REG: u8 = 8;
        pub const DT_LNK: u8 = 10;
        pub const DT_SOCK: u8 = 12;

        pub const FD_CLOEXEC: c_int = 0x1;
        pub const USRQUOTA: c_int = 0;
        pub const GRPQUOTA: c_int = 1;
        pub const SIGIOT: c_int = 6;

        pub const S_ISUID: mode_t = 0o4000;
        pub const S_ISGID: mode_t = 0o2000;
        pub const S_ISVTX: mode_t = 0o1000;

        pub const IF_NAMESIZE: size_t = 16;
        pub const IFNAMSIZ: size_t = IF_NAMESIZE;

        pub const LOG_EMERG: c_int = 0;
        pub const LOG_ALERT: c_int = 1;
        pub const LOG_CRIT: c_int = 2;
        pub const LOG_ERR: c_int = 3;
        pub const LOG_WARNING: c_int = 4;
        pub const LOG_NOTICE: c_int = 5;
        pub const LOG_INFO: c_int = 6;
        pub const LOG_DEBUG: c_int = 7;

        pub const LOG_KERN: c_int = 0;
        pub const LOG_USER: c_int = 1 << 3;
        pub const LOG_MAIL: c_int = 2 << 3;
        pub const LOG_DAEMON: c_int = 3 << 3;
        pub const LOG_AUTH: c_int = 4 << 3;
        pub const LOG_SYSLOG: c_int = 5 << 3;
        pub const LOG_LPR: c_int = 6 << 3;
        pub const LOG_NEWS: c_int = 7 << 3;
        pub const LOG_UUCP: c_int = 8 << 3;
        pub const LOG_LOCAL0: c_int = 16 << 3;
        pub const LOG_LOCAL1: c_int = 17 << 3;
        pub const LOG_LOCAL2: c_int = 18 << 3;
        pub const LOG_LOCAL3: c_int = 19 << 3;
        pub const LOG_LOCAL4: c_int = 20 << 3;
        pub const LOG_LOCAL5: c_int = 21 << 3;
        pub const LOG_LOCAL6: c_int = 22 << 3;
        pub const LOG_LOCAL7: c_int = 23 << 3;

        pub const LOG_PID: c_int = 0x01;
        pub const LOG_CONS: c_int = 0x02;
        pub const LOG_ODELAY: c_int = 0x04;
        pub const LOG_NDELAY: c_int = 0x08;
        pub const LOG_NOWAIT: c_int = 0x10;
        pub const LOG_PRIMASK: c_int = 7;
        pub const LOG_FACMASK: c_int = 0x3f8;

        pub const PRIO_MIN: c_int = -20;
        pub const PRIO_MAX: c_int = 20;
        pub const IPPROTO_ICMP: c_int = 1;
        pub const IPPROTO_ICMPV6: c_int = 58;
        pub const IPPROTO_TCP: c_int = 6;
        pub const IPPROTO_UDP: c_int = 17;
        pub const IPPROTO_IP: c_int = 0;
        pub const IPPROTO_IPV6: c_int = 41;

        pub const INADDR_LOOPBACK: in_addr_t = 2130706433;
        pub const INADDR_ANY: in_addr_t = 0;
        pub const INADDR_BROADCAST: in_addr_t = 4294967295;
        pub const INADDR_NONE: in_addr_t = 4294967295;

        pub const IN6ADDR_LOOPBACK_INIT: in6_addr = in6_addr {
            s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        };

        pub const IN6ADDR_ANY_INIT: in6_addr = in6_addr {
            s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        };

        pub const ARPOP_REQUEST: u16 = 1;
        pub const ARPOP_REPLY: u16 = 2;

        pub const ATF_COM: c_int = 0x02;
        pub const ATF_PERM: c_int = 0x04;
        pub const ATF_PUBL: c_int = 0x08;
        pub const ATF_USETRAILERS: c_int = 0x10;

        pub const FNM_PERIOD: c_int = 1 << 2;
        pub const FNM_NOMATCH: c_int = 1;

        pub const FNM_CASEFOLD: c_int = 1 << 4;
        pub const FNM_PATHNAME: c_int = 1 << 0;

        pub const FNM_NOESCAPE: c_int = 1 << 1;

        extern "C" 
        {
            pub static in6addr_loopback: in6_addr;
            pub static in6addr_any: in6_addr;
        }
        
        #[derive(Debug)]
        pub enum FILE {}

        extern "C"
        {
            pub fn isalnum(c: c_int) -> c_int;
            pub fn isalpha(c: c_int) -> c_int;
            pub fn iscntrl(c: c_int) -> c_int;
            pub fn isdigit(c: c_int) -> c_int;
            pub fn isgraph(c: c_int) -> c_int;
            pub fn islower(c: c_int) -> c_int;
            pub fn isprint(c: c_int) -> c_int;
            pub fn ispunct(c: c_int) -> c_int;
            pub fn isspace(c: c_int) -> c_int;
            pub fn isupper(c: c_int) -> c_int;
            pub fn isxdigit(c: c_int) -> c_int;
            pub fn isblank(c: c_int) -> c_int;
            pub fn tolower(c: c_int) -> c_int;
            pub fn toupper(c: c_int) -> c_int;
            pub fn qsort
            (
                base: *mut c_void,
                num: size_t,
                size: size_t,
                compar: Option<unsafe extern "C" fn(*const c_void, *const c_void) -> c_int>,
            );

            pub fn bsearch
            (
                key: *const c_void,
                base: *const c_void,
                num: size_t,
                size: size_t,
                compar: Option<unsafe extern "C" fn(*const c_void, *const c_void) -> c_int>,
            ) -> *mut c_void;
            
            pub fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;
            
            pub fn freopen(filename: *const c_char, mode: *const c_char, file: *mut FILE) -> *mut FILE;

            pub fn fflush(file: *mut FILE) -> c_int;
            pub fn fclose(file: *mut FILE) -> c_int;
            pub fn remove(filename: *const c_char) -> c_int;
            pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;
            
            pub fn tmpfile() -> *mut FILE;
            pub fn setvbuf(stream: *mut FILE, buffer: *mut c_char, mode: c_int, size: size_t) -> c_int;
            pub fn setbuf(stream: *mut FILE, buf: *mut c_char);
            pub fn getchar() -> c_int;
            pub fn putchar(c: c_int) -> c_int;
            pub fn fgetc(stream: *mut FILE) -> c_int;
            pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE) -> *mut c_char;
            pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;
            
            pub fn fputs(s: *const c_char, stream: *mut FILE) -> c_int;
            pub fn puts(s: *const c_char) -> c_int;
            pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;
            pub fn fread(ptr: *mut c_void, size: size_t, nobj: size_t, stream: *mut FILE) -> size_t;
            
            pub fn fwrite(ptr: *const c_void, size: size_t, nobj: size_t, stream: *mut FILE) -> size_t;
            pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;
            pub fn ftell(stream: *mut FILE) -> c_long;
            pub fn rewind(stream: *mut FILE);
            pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;
            
            pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;
            pub fn feof(stream: *mut FILE) -> c_int;
            pub fn ferror(stream: *mut FILE) -> c_int;
            pub fn clearerr(stream: *mut FILE);
            pub fn perror(s: *const c_char);
            pub fn atof(s: *const c_char) -> c_double;
            pub fn atoi(s: *const c_char) -> c_int;
            pub fn atol(s: *const c_char) -> c_long;
            pub fn atoll(s: *const c_char) -> c_longlong;
            
            pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;
            pub fn strtof(s: *const c_char, endp: *mut *mut c_char) -> c_float;
            pub fn strtol(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_long;
            pub fn strtoll(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_longlong;
            pub fn strtoul(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_ulong;
            pub fn strtoull(s: *const c_char, endp: *mut *mut c_char, base: c_int) -> c_ulonglong;
            pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;
            
            pub fn malloc(size: size_t) -> *mut c_void;
            pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;
            pub fn free(p: *mut c_void);
            pub fn abort() -> !;
            pub fn exit(status: c_int) -> !;
            pub fn _exit(status: c_int) -> !;
            
            pub fn system(s: *const c_char) -> c_int;
            pub fn getenv(s: *const c_char) -> *mut c_char;

            pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;
            pub fn strncpy(dst: *mut c_char, src: *const c_char, n: size_t) -> *mut c_char;
            pub fn stpcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;
            pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;
            pub fn strncat(s: *mut c_char, ct: *const c_char, n: size_t) -> *mut c_char;
            pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;
            pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;
            pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;
            pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;
            pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;
            pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;
            pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;
            pub fn strdup(cs: *const c_char) -> *mut c_char;
            pub fn strndup(cs: *const c_char, n: size_t) -> *mut c_char;
            pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;
            pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;
            pub fn strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
            pub fn strncasecmp(s1: *const c_char, s2: *const c_char, n: size_t) -> c_int;
            pub fn strlen(cs: *const c_char) -> size_t;
            pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;
            
            pub fn strerror(n: c_int) -> *mut c_char;
            pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;
            pub fn strtok_r(s: *mut c_char, t: *const c_char, p: *mut *mut c_char) -> *mut c_char;
            pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;
            pub fn strsignal(sig: c_int) -> *mut c_char;
            pub fn wcslen(buf: *const wchar_t) -> size_t;
            pub fn wcstombs(dest: *mut c_char, src: *const wchar_t, n: size_t) -> size_t;

            pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;
            pub fn wmemchr(cx: *const wchar_t, c: wchar_t, n: size_t) -> *mut wchar_t;
            pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;
            pub fn memcpy(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;
            pub fn memmove(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;
            pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;
            pub fn memccpy(dest: *mut c_void, src: *const c_void, c: c_int, n: size_t) -> *mut c_void;
        }

        extern "C"
        {
            pub fn getpwnam(name: *const c_char) -> *mut passwd;
            pub fn getpwuid(uid:  uid_t) -> *mut passwd;

            pub fn fprintf(stream: *mut FILE, format: *const c_char, ...) -> c_int;
            pub fn printf(format: *const c_char, ...) -> c_int;
            pub fn snprintf(s: *mut c_char, n: size_t, format: *const c_char, ...) -> c_int;
            pub fn sprintf(s: *mut c_char, format: *const c_char, ...) -> c_int;
            
            pub fn fscanf(stream: *mut FILE, format: *const c_char, ...) -> c_int;
            
            pub fn scanf(format: *const c_char, ...) -> c_int;
            
            pub fn sscanf(s: *const c_char, format: *const c_char, ...) -> c_int;
            pub fn getchar_unlocked() -> c_int;
            pub fn putchar_unlocked(c: c_int) -> c_int;
            
            pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> c_int;
            
            pub fn connect(socket: c_int, address: *const sockaddr, len: socklen_t) -> c_int;
            
            pub fn listen(socket: c_int, backlog: c_int) -> c_int;
            
            pub fn accept(socket: c_int, address: *mut sockaddr, address_len: *mut socklen_t) -> c_int;
            
            pub fn getpeername(socket: c_int, address: *mut sockaddr, address_len: *mut socklen_t) -> c_int;
                
            pub fn getsockname(socket: c_int, address: *mut sockaddr, address_len: *mut socklen_t) -> c_int;
            pub fn setsockopt(
                socket: c_int,
                level: c_int,
                name: c_int,
                value: *const c_void,
                option_len: socklen_t,
            ) -> c_int;
            
            pub fn socketpair(
                domain: c_int,
                type_: c_int,
                protocol: c_int,
                socket_vector: *mut c_int,
            ) -> c_int;
            
            pub fn sendto(
                socket: c_int,
                buf: *const c_void,
                len: size_t,
                flags: c_int,
                addr: *const sockaddr,
                addrlen: socklen_t,
            ) -> ssize_t;
            
            pub fn shutdown(socket: c_int, how: c_int) -> c_int;
            
            pub fn chmod(path: *const c_char, mode: mode_t) -> c_int;
            
            pub fn fchmod(fd: c_int, mode: mode_t) -> c_int;
            
            pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;

            pub fn mkdir(path: *const c_char, mode: mode_t) -> c_int;
            
            pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;

            pub fn pclose(stream: *mut FILE) -> c_int;
            
            pub fn fdopen(fd: c_int, mode: *const c_char) -> *mut  FILE;
            pub fn fileno(stream: *mut FILE) -> c_int;
            
            pub fn open(path: *const c_char, oflag: c_int, ...) -> c_int;
            
            pub fn creat(path: *const c_char, mode: mode_t) -> c_int;
            
            pub fn fcntl(fd: c_int, cmd: c_int, ...) -> c_int;
            
            pub fn opendir(dirname: *const c_char) -> *mut  DIR;
            
            #[cfg_attr(gnu_file_offset_bits64, link_name = "readdir64")]
            pub fn readdir(dirp: *mut DIR) -> *mut  dirent;
            
            pub fn closedir(dirp: *mut DIR) -> c_int;
            
            pub fn rewinddir(dirp: *mut DIR);

            pub fn fchmodat(dirfd: c_int, pathname: *const c_char, mode: mode_t, flags: c_int) -> c_int;
            pub fn fchown(fd: c_int, owner:  uid_t, group:  gid_t) -> c_int;
            pub fn fchownat(
                dirfd: c_int,
                pathname: *const c_char,
                owner:  uid_t,
                group:  gid_t,
                flags: c_int,
            ) -> c_int;
            
            pub fn fstatat(dirfd: c_int, pathname: *const c_char, buf: *mut stat, flags: c_int) -> c_int;
            pub fn linkat(
                olddirfd: c_int,
                oldpath: *const c_char,
                newdirfd: c_int,
                newpath: *const c_char,
                flags: c_int,
            ) -> c_int;
            pub fn renameat(
                olddirfd: c_int,
                oldpath: *const c_char,
                newdirfd: c_int,
                newpath: *const c_char,
            ) -> c_int;
            pub fn symlinkat(target: *const c_char, newdirfd: c_int, linkpath: *const c_char) -> c_int;
            pub fn unlinkat(dirfd: c_int, pathname: *const c_char, flags: c_int) -> c_int;

            pub fn access(path: *const c_char, amode: c_int) -> c_int;
            pub fn alarm(seconds: c_uint) -> c_uint;
            pub fn chdir(dir: *const c_char) -> c_int;
            pub fn fchdir(dirfd: c_int) -> c_int;
            pub fn chown(path: *const c_char, uid: uid_t, gid: gid_t) -> c_int;
            
            pub fn lchown(path: *const c_char, uid: uid_t, gid: gid_t) -> c_int;
            
            pub fn close(fd: c_int) -> c_int;
            pub fn dup(fd: c_int) -> c_int;
            pub fn dup2(src: c_int, dst: c_int) -> c_int;

            pub fn execl(path: *const c_char, arg0: *const c_char, ...) -> c_int;
            pub fn execle(path: *const c_char, arg0: *const c_char, ...) -> c_int;
            pub fn execlp(file: *const c_char, arg0: *const c_char, ...) -> c_int;
            pub fn execv(prog: *const c_char, argv: *const *mut c_char) -> c_int;
            pub fn execve(prog: *const c_char, argv: *const *mut c_char, envp: *const *mut c_char) -> c_int;
            pub fn execvp(c: *const c_char, argv: *const *mut c_char) -> c_int;

            pub fn fork() -> pid_t;
            pub fn fpathconf(filedes: c_int, name: c_int) -> c_long;
            pub fn getcwd(buf: *mut c_char, size: size_t) -> *mut c_char;
            pub fn getegid() -> gid_t;
            pub fn geteuid() -> uid_t;
            pub fn getgid() -> gid_t;
            pub fn getgroups(ngroups_max: c_int, groups: *mut gid_t) -> c_int;
            pub fn getlogin() -> *mut c_char;
            pub fn getopt(argc: c_int, argv: *const *mut c_char, optstr: *const c_char) -> c_int;
            pub fn getpgid(pid: pid_t) -> pid_t;
            pub fn getpgrp() -> pid_t;
            pub fn getpid() -> pid_t;
            pub fn getppid() -> pid_t;
            pub fn getuid() -> uid_t;
            pub fn isatty(fd: c_int) -> c_int;
            #[cfg_attr(target_os = "solaris", link_name = "__link_xpg4")]
            pub fn link(src: *const c_char, dst: *const c_char) -> c_int;
            #[cfg_attr(gnu_file_offset_bits64, link_name = "lseek64")]
            pub fn lseek(fd: c_int, offset: off_t, whence: c_int) -> off_t;
            pub fn pathconf(path: *const c_char, name: c_int) -> c_long;
            pub fn pipe(fds: *mut c_int) -> c_int;
            pub fn posix_memalign(memptr: *mut *mut c_void, align: size_t, size: size_t) -> c_int;
            pub fn aligned_alloc(alignment: size_t, size: size_t) -> *mut c_void;
            
            pub fn read(fd: c_int, buf: *mut c_void, count: size_t) -> ssize_t;
            pub fn rmdir(path: *const c_char) -> c_int;
            pub fn seteuid(uid: uid_t) -> c_int;
            pub fn setegid(gid: gid_t) -> c_int;
            pub fn setgid(gid: gid_t) -> c_int;
            pub fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;
            pub fn setsid() -> pid_t;
            pub fn setuid(uid: uid_t) -> c_int;
            pub fn setreuid(ruid: uid_t, euid: uid_t) -> c_int;
            pub fn setregid(rgid: gid_t, egid: gid_t) -> c_int;
            pub fn sleep(secs: c_uint) -> c_uint;
            
            pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> c_int;
            pub fn tcgetpgrp(fd: c_int) -> pid_t;
            pub fn tcsetpgrp(fd: c_int, pgrp:  pid_t) -> c_int;
            pub fn ttyname(fd: c_int) -> *mut c_char;
            
            pub fn ttyname_r(fd: c_int, buf: *mut c_char, buflen: size_t) -> c_int;
            pub fn unlink(c: *const c_char) -> c_int;
            
            pub fn wait(status: *mut c_int) -> pid_t;
            
            pub fn waitpid(pid: pid_t, status: *mut c_int, options: c_int) -> pid_t;
            pub fn write(fd: c_int, buf: *const c_void, count: size_t) -> ssize_t;
            
            #[cfg_attr(gnu_file_offset_bits64, link_name = "pread64")]
            pub fn pread(fd: c_int, buf: *mut c_void, count: size_t, offset: off_t) -> ssize_t;
            
            #[cfg_attr(gnu_file_offset_bits64, link_name = "pwrite64")]
            pub fn pwrite(fd: c_int, buf: *const c_void, count: size_t, offset: off_t) -> ssize_t;
            pub fn umask(mask: mode_t) -> mode_t;
            
            #[cfg_attr(gnu_time_bits64, link_name = "__utime64")]
            pub fn utime(file: *const c_char, buf: *const utimbuf) -> c_int;
            pub fn kill(pid: pid_t, sig: c_int) -> c_int;
            pub fn killpg(pgrp: pid_t, sig: c_int) -> c_int;

            pub fn mlock(addr: *const c_void, len: size_t) -> c_int;
            pub fn munlock(addr: *const c_void, len: size_t) -> c_int;
            pub fn mlockall(flags: c_int) -> c_int;
            pub fn munlockall() -> c_int;
            
            #[cfg_attr(gnu_file_offset_bits64, link_name = "mmap64")]
            pub fn mmap(
                addr: *mut c_void,
                len: size_t,
                prot: c_int,
                flags: c_int,
                fd: c_int,
                offset: off_t,
            ) -> *mut c_void;
            pub fn munmap(addr: *mut c_void, len: size_t) -> c_int;
            pub fn if_nametoindex(ifname: *const c_char) -> c_uint;
            pub fn if_indextoname(ifindex: c_uint, ifname: *mut c_char) -> *mut c_char;
            pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;
            pub fn fsync(fd: c_int) -> c_int;
            pub fn setenv(name: *const c_char, val: *const c_char, overwrite: c_int) -> c_int;
            pub fn unsetenv(name: *const c_char) -> c_int;

            pub fn symlink(path1: *const c_char, path2: *const c_char) -> c_int;

            #[cfg_attr(gnu_file_offset_bits64, link_name = "truncate64")]
            pub fn truncate(path: *const c_char, length: off_t) -> c_int;
            #[cfg_attr(gnu_file_offset_bits64, link_name = "ftruncate64")]
            pub fn ftruncate(fd: c_int, length: off_t) -> c_int;

            pub fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t;
            pub fn getrusage(resource: c_int, usage: *mut rusage) -> c_int;
            pub fn realpath(pathname: *const c_char, resolved: *mut c_char) -> *mut c_char;
            
            pub fn times(buf: *mut tms) ->  clock_t;

            pub fn pthread_self() ->  pthread_t;
            pub fn pthread_equal(t1:  pthread_t, t2:  pthread_t) -> c_int;
            pub fn pthread_join(native:  pthread_t, value: *mut *mut c_void) -> c_int;
            pub fn pthread_exit(value: *mut c_void) -> !;
            pub fn pthread_attr_init(attr: *mut pthread_attr_t) -> c_int;
            pub fn pthread_attr_destroy(attr: *mut pthread_attr_t) -> c_int;
            pub fn pthread_attr_getstacksize
            (
                attr: *const pthread_attr_t,
                stacksize: *mut size_t,
            ) -> c_int;
            pub fn pthread_attr_setstacksize(attr: *mut pthread_attr_t, stack_size: size_t) -> c_int;
            pub fn pthread_attr_setdetachstate(attr: *mut pthread_attr_t, state: c_int) -> c_int;
            pub fn pthread_detach(thread:  pthread_t) -> c_int;
            pub fn sched_yield() -> c_int;
            pub fn pthread_key_create(
                key: *mut pthread_key_t,
                dtor: Option<unsafe extern "C" fn(*mut c_void)>,
            ) -> c_int;
            pub fn pthread_key_delete(key: pthread_key_t) -> c_int;
            pub fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;
            pub fn pthread_setspecific(key: pthread_key_t, value: *const c_void) -> c_int;
            pub fn pthread_mutex_init(
                lock: *mut pthread_mutex_t,
                attr: *const pthread_mutexattr_t,
            ) -> c_int;
            pub fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> c_int;
            pub fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> c_int;
            pub fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> c_int;
            pub fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> c_int;

            pub fn pthread_mutexattr_init(attr: *mut pthread_mutexattr_t) -> c_int;
            pub fn pthread_mutexattr_destroy(attr: *mut pthread_mutexattr_t) -> c_int;
            pub fn pthread_mutexattr_settype(attr: *mut pthread_mutexattr_t, _type: c_int) -> c_int;
            
            pub fn pthread_cond_init(cond: *mut pthread_cond_t, attr: *const pthread_condattr_t) -> c_int;
            pub fn pthread_cond_wait(cond: *mut pthread_cond_t, lock: *mut pthread_mutex_t) -> c_int;
            #[cfg_attr(gnu_time_bits64, link_name = "__pthread_cond_timedwait64")]
            pub fn pthread_cond_timedwait(
                cond: *mut pthread_cond_t,
                lock: *mut pthread_mutex_t,
                abstime: *const timespec,
            ) -> c_int;
            pub fn pthread_cond_signal(cond: *mut pthread_cond_t) -> c_int;
            pub fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> c_int;
            pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> c_int;
            pub fn pthread_condattr_init(attr: *mut pthread_condattr_t) -> c_int;
            pub fn pthread_condattr_destroy(attr: *mut pthread_condattr_t) -> c_int;
            pub fn pthread_rwlock_init(
                lock: *mut pthread_rwlock_t,
                attr: *const pthread_rwlockattr_t,
            ) -> c_int;
            pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> c_int;
            pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> c_int;
            pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> c_int;
            pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> c_int;
            pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> c_int;
            pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> c_int;
            pub fn pthread_rwlockattr_init(attr: *mut pthread_rwlockattr_t) -> c_int;
            pub fn pthread_rwlockattr_destroy(attr: *mut pthread_rwlockattr_t) -> c_int;
            
            #[cfg_attr(gnu_time_bits64, link_name = "__getsockopt64")]
            pub fn getsockopt(
                sockfd: c_int,
                level: c_int,
                optname: c_int,
                optval: *mut c_void,
                optlen: *mut socklen_t,
            ) -> c_int;
            pub fn raise(signum: c_int) -> c_int;
            pub fn utimes(filename: *const c_char, times: *const timeval) -> c_int;
            pub fn dlopen(filename: *const c_char, flag: c_int) -> *mut c_void;
            pub fn dlerror() -> *mut c_char;
            pub fn dlsym(handle: *mut c_void, symbol: *const c_char) -> *mut c_void;
            pub fn dlclose(handle: *mut c_void) -> c_int;
            pub fn getaddrinfo(
                node: *const c_char,
                service: *const c_char,
                hints: *const addrinfo,
                res: *mut *mut addrinfo,
            ) -> c_int;
            pub fn freeaddrinfo(res: *mut addrinfo);
            pub fn hstrerror(errcode: c_int) -> *const c_char;
            pub fn gai_strerror(errcode: c_int) -> *const c_char;
            #[cfg_attr(
                any(
                    all(
                        target_os = "linux",
                        not(any(target_env = "musl", target_env = "ohos"))
                    ),
                    target_os = "freebsd",
                    target_os = "cygwin",
                    target_os = "dragonfly",
                    target_os = "haiku"
                ),
                link_name = "__res_init"
            )]
            pub fn res_init() -> c_int;
            #[cfg_attr(gnu_time_bits64, link_name = "__gmtime64_r")]
            pub fn gmtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;
            #[cfg_attr(gnu_time_bits64, link_name = "__localtime64_r")]
            pub fn localtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;
            #[cfg_attr(gnu_time_bits64, link_name = "__mktime64")]
            pub fn mktime(tm: *mut tm) -> time_t;
            #[cfg_attr(gnu_time_bits64, link_name = "__time64")]
            pub fn time(time: *mut time_t) -> time_t;
            #[cfg_attr(gnu_time_bits64, link_name = "__gmtime64")]
            pub fn gmtime(time_p: *const time_t) -> *mut tm;
            #[cfg_attr(gnu_time_bits64, link_name = "__localtime64")]
            pub fn localtime(time_p: *const time_t) -> *mut tm;
            #[cfg_attr(gnu_time_bits64, link_name = "__difftime64")]
            pub fn difftime(time1: time_t, time0: time_t) -> c_double;
            pub fn timegm(tm: *mut tm) -> time_t;
            pub fn mknod(pathname: *const c_char, mode: mode_t, dev:  dev_t) -> c_int;
            pub fn gethostname(name: *mut c_char, len: size_t) -> c_int;
            pub fn endservent();
            pub fn getservbyname(name: *const c_char, proto: *const c_char) -> *mut servent;
            pub fn getservbyport(port: c_int, proto: *const c_char) -> *mut servent;
            pub fn getservent() -> *mut servent;
            pub fn setservent(stayopen: c_int);
            pub fn getprotobyname(name: *const c_char) -> *mut protoent;
            pub fn getprotobynumber(proto: c_int) -> *mut protoent;
            pub fn chroot(name: *const c_char) -> c_int;
            pub fn usleep(secs: c_uint) -> c_int;
            pub fn send(socket: c_int, buf: *const c_void, len: size_t, flags: c_int) -> ssize_t;
            pub fn recv(socket: c_int, buf: *mut c_void, len: size_t, flags: c_int) -> ssize_t;
            pub fn putenv(string: *mut c_char) -> c_int;
            pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: c_int) -> c_int;
            
            #[cfg_attr(gnu_time_bits64, link_name = "__select64")]
            pub fn select
            (
                nfds: c_int,
                readfds: *mut fd_set,
                writefds: *mut fd_set,
                errorfds: *mut fd_set,
                timeout: *mut timeval,
            ) -> c_int;
            pub fn setlocale(category: c_int, locale: *const c_char) -> *mut c_char;
            pub fn localeconv() -> *mut lconv;
            pub fn sem_wait(sem: *mut sem_t) -> c_int;
            pub fn sem_trywait(sem: *mut sem_t) -> c_int;
            pub fn sem_post(sem: *mut sem_t) -> c_int;
            pub fn statvfs(path: *const c_char, buf: *mut statvfs) -> c_int;
            pub fn fstatvfs(fd: c_int, buf: *mut statvfs) -> c_int;

            pub fn sigemptyset(set: *mut sigset_t) -> c_int;
            pub fn sigaddset(set: *mut sigset_t, signum: c_int) -> c_int;
            pub fn sigfillset(set: *mut sigset_t) -> c_int;
            pub fn sigdelset(set: *mut sigset_t, signum: c_int) -> c_int;
            pub fn sigismember(set: *const sigset_t, signum: c_int) -> c_int;
            pub fn sigprocmask(how: c_int, set: *const sigset_t, oldset: *mut sigset_t) -> c_int;
            pub fn sigpending(set: *mut sigset_t) -> c_int;
            pub fn sysconf(name: c_int) -> c_long;

            pub fn mkfifo(path: *const c_char, mode: mode_t) -> c_int;

            #[cfg_attr(gnu_file_offset_bits64, link_name = "fseeko64")]
            pub fn fseeko(stream: *mut FILE, offset: off_t, whence: c_int) -> c_int;
            #[cfg_attr(gnu_file_offset_bits64, link_name = "ftello64")]
            pub fn ftello(stream: *mut FILE) -> off_t;
            pub fn tcdrain(fd: c_int) -> c_int;
            pub fn cfgetispeed(termios: *const termios) ->  speed_t;
            pub fn cfgetospeed(termios: *const termios) ->  speed_t;
            pub fn cfsetispeed(termios: *mut termios, speed:  speed_t) -> c_int;
            pub fn cfsetospeed(termios: *mut termios, speed:  speed_t) -> c_int;
            pub fn tcgetattr(fd: c_int, termios: *mut termios) -> c_int;
            pub fn tcsetattr(fd: c_int, optional_actions: c_int, termios: *const termios) -> c_int;
            pub fn tcflow(fd: c_int, action: c_int) -> c_int;
            pub fn tcflush(fd: c_int, action: c_int) -> c_int;
            pub fn tcgetsid(fd: c_int) ->  pid_t;
            pub fn tcsendbreak(fd: c_int, duration: c_int) -> c_int;
            pub fn mkstemp(template: *mut c_char) -> c_int;
            pub fn mkdtemp(template: *mut c_char) -> *mut c_char;

            pub fn tmpnam(ptr: *mut c_char) -> *mut c_char;

            pub fn openlog(ident: *const c_char, logopt: c_int, facility: c_int);
            pub fn closelog();
            pub fn setlogmask(maskpri: c_int) -> c_int;
            pub fn syslog(priority: c_int, message: *const c_char, ...);
            pub fn nice(incr: c_int) -> c_int;

            pub fn grantpt(fd: c_int) -> c_int;
            pub fn posix_openpt(flags: c_int) -> c_int;
            pub fn ptsname(fd: c_int) -> *mut c_char;
            pub fn unlockpt(fd: c_int) -> c_int;
            pub fn strcasestr(cs: *const c_char, ct: *const c_char) -> *mut c_char;
            pub fn getline(lineptr: *mut *mut c_char, n: *mut size_t, stream: *mut FILE) -> ssize_t;

            #[cfg_attr(gnu_file_offset_bits64, link_name = "lockf64")]
            pub fn lockf(fd: c_int, cmd: c_int, len: off_t) -> c_int;

        }

        safe_f! 
        {
            pub {const} fn htonl(hostlong: u32) -> u32 { u32::to_be(hostlong) }
            pub {const} fn htons(hostshort: u16) -> u16 { u16::to_be(hostshort) }
            pub {const} fn ntohl(netlong: u32) -> u32 { u32::from_be(netlong) }
            pub {const} fn ntohs(netshort: u16) -> u16 { u16::from_be(netshort) }
        }
        
        extern "C"
        {
            #[cfg_attr(gnu_time_bits64, link_name = "__adjtime64")]
            pub fn adjtime(delta: *const timeval, olddelta: *mut timeval) -> c_int;
            pub fn stpncpy(dst: *mut c_char, src: *const c_char, n: size_t) -> *mut c_char;
            pub fn confstr(name: c_int, buf: *mut c_char, len: size_t) -> size_t;
            pub fn dladdr(addr: *const c_void, info: *mut Dl_info) -> c_int;
            pub fn flock(fd: c_int, operation: c_int) -> c_int;
            pub fn open_wmemstream(ptr: *mut *mut wchar_t, sizeloc: *mut size_t) -> *mut FILE;
            pub fn getsid(pid: pid_t) -> pid_t;
            #[cfg_attr(
                all(target_os = "macos", target_arch = "x86"),
                link_name = "pause$UNIX2003"
            )]
            pub fn pause() -> c_int;

            pub fn mkdirat(dirfd: c_int, pathname: *const c_char, mode: mode_t) -> c_int;
            #[cfg_attr(gnu_file_offset_bits64, link_name = "openat64")]
            pub fn openat(dirfd: c_int, pathname: *const c_char, flags: c_int, ...) -> c_int;

            #[cfg_attr(
                all(target_os = "macos", target_arch = "x86_64"),
                link_name = "fdopendir$INODE64"
            )]
            #[cfg_attr(
                all(target_os = "macos", target_arch = "x86"),
                link_name = "fdopendir$INODE64$UNIX2003"
            )]
            pub fn fdopendir(fd: c_int) -> *mut  DIR;

            #[cfg_attr(
                all(target_os = "macos", not(target_arch = "aarch64")),
                link_name = "readdir_r$INODE64"
            )]
            #[cfg_attr(target_os = "netbsd", link_name = "__readdir_r30")]
            #[cfg_attr(
                all(target_os = "freebsd", any(freebsd11, freebsd10)),
                link_name = "readdir_r@FBSD_1.0"
            )]
            #[allow(non_autolinks)] // FIXME(docs): `<>` breaks line length limit.
            /// The 64-bit libc on Solaris and illumos only has readdir_r. If a
            /// 32-bit Solaris or illumos target is ever created, it should use
            /// __posix_readdir_r. See libc(3LIB) on Solaris or illumos:
            /// https://illumos.org/man/3lib/libc
            /// https://docs.oracle.com/cd/E36784_01/html/E36873/libc-3lib.html
            /// https://www.unix.com/man-page/opensolaris/3LIB/libc/
            #[cfg_attr(gnu_file_offset_bits64, link_name = "readdir64_r")]
            pub fn readdir_r(
                dirp: *mut DIR,
                entry: *mut dirent,
                result: *mut *mut  dirent,
            ) -> c_int;
            pub fn readlinkat
            (
                dirfd: c_int,
                pathname: *const c_char,
                buf: *mut c_char,
                bufsiz: size_t,
            ) -> ssize_t;
            pub fn fmemopen(buf: *mut c_void, size: size_t, mode: *const c_char) -> *mut FILE;
            pub fn open_memstream(ptr: *mut *mut c_char, sizeloc: *mut size_t) -> *mut FILE;
            pub fn atexit(cb: extern "C" fn()) -> c_int;
            pub fn readlink(path: *const c_char, buf: *mut c_char, bufsz: size_t) -> ssize_t;
            pub fn pselect
            (
                nfds: c_int,
                readfds: *mut fd_set,
                writefds: *mut fd_set,
                errorfds: *mut fd_set,
                timeout: *const timespec,
                sigmask: *const sigset_t,
            ) -> c_int;
            pub fn cfmakeraw( termios: *mut termios );
            pub fn cfsetspeed( termios: *mut termios, speed:speed_t ) -> c_int;
            pub fn fnmatch( pattern: *const c_char, name: *const c_char, flags: c_int ) -> c_int;
        }
        
        mod linux_like
        {
            use ::libc::*;

            pub type sa_family_t = u16;
            pub type speed_t = c_uint;
            pub type tcflag_t = c_uint;
            pub type clockid_t = c_int;
            pub type timer_t = *mut c_void;
            pub type key_t = c_int;
            pub type id_t = c_uint;

            missing! 
            {
                #[derive(Debug)]
                pub enum timezone {}
            }

            s!
            {
                #[allow(unpredictable_function_pointer_comparisons)]
                pub struct __c_anonymous_sigev_thread
                {
                    pub _function: Option<extern "C" fn( sigval ) -> *mut c_void>,
                    pub _attribute: *mut  pthread_attr_t,
                }

                pub struct in_addr
                {
                    pub s_addr:  in_addr_t,
                }

                pub struct ip_mreq
                {
                    pub imr_multiaddr: in_addr,
                    pub imr_interface: in_addr,
                }

                pub struct ip_mreqn 
                {
                    pub imr_multiaddr: in_addr,
                    pub imr_address: in_addr,
                    pub imr_ifindex: c_int,
                }

                pub struct ip_mreq_source 
                {
                    pub imr_multiaddr: in_addr,
                    pub imr_interface: in_addr,
                    pub imr_sourceaddr: in_addr,
                }

                pub struct sockaddr 
                {
                    pub sa_family: sa_family_t,
                    pub sa_data: [c_char; 14],
                }

                pub struct sockaddr_in 
                {
                    pub sin_family: sa_family_t,
                    pub sin_port:  in_port_t,
                    pub sin_addr:  in_addr,
                    pub sin_zero: [u8; 8],
                }

                pub struct sockaddr_in6 
                {
                    pub sin6_family: sa_family_t,
                    pub sin6_port:  in_port_t,
                    pub sin6_flowinfo: u32,
                    pub sin6_addr:  in6_addr,
                    pub sin6_scope_id: u32,
                }
                
                pub struct addrinfo
                {
                    pub ai_flags: c_int,
                    pub ai_family: c_int,
                    pub ai_socktype: c_int,
                    pub ai_protocol: c_int,
                    pub ai_addrlen: socklen_t,
                    pub ai_addr: *mut  sockaddr,
                    pub ai_canonname: *mut c_char,
                    pub ai_addr: *mut  sockaddr,
                    pub ai_next: *mut addrinfo,
                }

                pub struct sockaddr_ll 
                {
                    pub sll_family: c_ushort,
                    pub sll_protocol: c_ushort,
                    pub sll_ifindex: c_int,
                    pub sll_hatype: c_ushort,
                    pub sll_pkttype: c_uchar,
                    pub sll_halen: c_uchar,
                    pub sll_addr: [c_uchar; 8],
                }

                pub struct fd_set 
                {
                    fds_bits: [c_ulong; FD_SETSIZE as usize / ULONG_SIZE],
                }

                pub struct tm
                {
                    pub tm_sec: c_int,
                    pub tm_min: c_int,
                    pub tm_hour: c_int,
                    pub tm_mday: c_int,
                    pub tm_mon: c_int,
                    pub tm_year: c_int,
                    pub tm_wday: c_int,
                    pub tm_yday: c_int,
                    pub tm_isdst: c_int,
                    pub tm_gmtoff: c_long,
                    pub tm_zone: *const c_char,
                }

                pub struct sched_param 
                {
                    pub sched_priority: c_int,
                }

                pub struct Dl_info
                {
                    pub dli_fname: *const c_char,
                    pub dli_fbase: *mut c_void,
                    pub dli_sname: *const c_char,
                    pub dli_saddr: *mut c_void,
                }

                pub struct lconv
                {
                    pub decimal_point: *mut c_char,
                    pub thousands_sep: *mut c_char,
                    pub grouping: *mut c_char,
                    pub int_curr_symbol: *mut c_char,
                    pub currency_symbol: *mut c_char,
                    pub mon_decimal_point: *mut c_char,
                    pub mon_thousands_sep: *mut c_char,
                    pub mon_grouping: *mut c_char,
                    pub positive_sign: *mut c_char,
                    pub negative_sign: *mut c_char,
                    pub int_frac_digits: c_char,
                    pub frac_digits: c_char,
                    pub p_cs_precedes: c_char,
                    pub p_sep_by_space: c_char,
                    pub n_cs_precedes: c_char,
                    pub n_sep_by_space: c_char,
                    pub p_sign_posn: c_char,
                    pub n_sign_posn: c_char,
                    pub int_p_cs_precedes: c_char,
                    pub int_p_sep_by_space: c_char,
                    pub int_n_cs_precedes: c_char,
                    pub int_n_sep_by_space: c_char,
                    pub int_p_sign_posn: c_char,
                    pub int_n_sign_posn: c_char,
                }

                pub struct in_pktinfo
                {
                    pub ipi_ifindex: c_int,
                    pub ipi_spec_dst:  in_addr,
                    pub ipi_addr:  in_addr,
                }

                pub struct ifaddrs
                {
                    pub ifa_next: *mut ifaddrs,
                    pub ifa_name: *mut c_char,
                    pub ifa_flags: c_uint,
                    pub ifa_addr: *mut  sockaddr,
                    pub ifa_netmask: *mut  sockaddr,
                    pub ifa_ifu: *mut  sockaddr,
                    pub ifa_data: *mut c_void,
                }

                pub struct in6_rtmsg 
                {
                    rtmsg_dst:  in6_addr,
                    rtmsg_src:  in6_addr,
                    rtmsg_gateway:  in6_addr,
                    rtmsg_type: u32,
                    rtmsg_dst_len: u16,
                    rtmsg_src_len: u16,
                    rtmsg_metric: u32,
                    rtmsg_info: c_ulong,
                    rtmsg_flags: u32,
                    rtmsg_ifindex: c_int,
                }

                pub struct arpreq 
                {
                    pub arp_pa:  sockaddr,
                    pub arp_ha:  sockaddr,
                    pub arp_flags: c_int,
                    pub arp_netmask:  sockaddr,
                    pub arp_dev: [c_char; 16],
                }

                pub struct arpreq_old 
                {
                    pub arp_pa:  sockaddr,
                    pub arp_ha:  sockaddr,
                    pub arp_flags: c_int,
                    pub arp_netmask:  sockaddr,
                }

                pub struct arphdr 
                {
                    pub ar_hrd: u16,
                    pub ar_pro: u16,
                    pub ar_hln: u8,
                    pub ar_pln: u8,
                    pub ar_op: u16,
                }

                pub struct mmsghdr 
                {
                    pub msg_hdr:  msghdr,
                    pub msg_len: c_uint,
                }
            }

            s! 
            {
                pub struct file_clone_range
                {
                    pub src_fd:  __s64,
                    pub src_offset:  __u64,
                    pub src_length:  __u64,
                    pub dest_offset:  __u64,
                }
                
                pub struct sock_filter
                {
                    pub code: __u16,
                    pub jt: __u8,
                    pub jf: __u8,
                    pub k: __u32,
                }

                pub struct sock_fprog 
                {
                    pub len: c_ushort,
                    pub filter: *mut sock_filter,
                }
            }
            

            s_no_extra_traits! 
            {
                #[repr(packed)]
                pub struct epoll_event 
                {
                    pub events: u32,
                    pub u64: u64,
                }

                pub union __c_anonymous_sigev_un 
                {
                    _pad: [c_int; SIGEV_PAD_SIZE],
                    pub _tid: c_int,
                    pub _sigev_thread: __c_anonymous_sigev_thread,
                }

                pub struct sockaddr_un 
                {
                    pub sun_family: sa_family_t,
                    pub sun_path: [c_char; 108],
                }

                pub struct sockaddr_storage 
                {
                    pub ss_family: sa_family_t,
                    #[cfg(target_pointer_width = "32")]
                    __ss_pad2: [u8; 128 - 2 - 4],
                    #[cfg(target_pointer_width = "64")]
                    __ss_pad2: [u8; 128 - 2 - 8],
                    __ss_align: size_t,
                }

                pub struct utsname 
                {
                    pub sysname: [c_char; 65],
                    pub nodename: [c_char; 65],
                    pub release: [c_char; 65],
                    pub version: [c_char; 65],
                    pub machine: [c_char; 65],
                    pub domainname: [c_char; 65],
                }

                pub struct sigevent 
                {
                    pub sigev_value:  sigval,
                    pub sigev_signo: c_int,
                    pub sigev_notify: c_int,
                    pub _sigev_un: __c_anonymous_sigev_un,
                }
            }

            cfg_if! 
            {
                if #[cfg(feature = "extra_traits")] 
                {
                    impl PartialEq for epoll_event {
                        fn eq(&self, other: &epoll_event) -> bool {
                            self.events == other.events && self.u64 == other.u64
                        }
                    }
                    impl Eq for epoll_event {}
                    impl hash::Hash for epoll_event {
                        fn hash<H: hash::Hasher>(&self, state: &mut H) {
                            let events = self.events;
                            let u64 = self.u64;
                            events.hash(state);
                            u64.hash(state);
                        }
                    }

                    impl PartialEq for sockaddr_un {
                        fn eq(&self, other: &sockaddr_un) -> bool {
                            self.sun_family == other.sun_family
                                && self
                                    .sun_path
                                    .iter()
                                    .zip(other.sun_path.iter())
                                    .all(|(a, b)| a == b)
                        }
                    }
                    impl Eq for sockaddr_un {}
                    impl hash::Hash for sockaddr_un {
                        fn hash<H: hash::Hasher>(&self, state: &mut H) {
                            self.sun_family.hash(state);
                            self.sun_path.hash(state);
                        }
                    }

                    impl PartialEq for sockaddr_storage {
                        fn eq(&self, other: &sockaddr_storage) -> bool {
                            self.ss_family == other.ss_family
                                && self
                                    .__ss_pad2
                                    .iter()
                                    .zip(other.__ss_pad2.iter())
                                    .all(|(a, b)| a == b)
                        }
                    }

                    impl Eq for sockaddr_storage {}

                    impl hash::Hash for sockaddr_storage {
                        fn hash<H: hash::Hasher>(&self, state: &mut H) {
                            self.ss_family.hash(state);
                            self.__ss_pad2.hash(state);
                        }
                    }

                    impl PartialEq for utsname {
                        fn eq(&self, other: &utsname) -> bool {
                            self.sysname
                                .iter()
                                .zip(other.sysname.iter())
                                .all(|(a, b)| a == b)
                                && self
                                    .nodename
                                    .iter()
                                    .zip(other.nodename.iter())
                                    .all(|(a, b)| a == b)
                                && self
                                    .release
                                    .iter()
                                    .zip(other.release.iter())
                                    .all(|(a, b)| a == b)
                                && self
                                    .version
                                    .iter()
                                    .zip(other.version.iter())
                                    .all(|(a, b)| a == b)
                                && self
                                    .machine
                                    .iter()
                                    .zip(other.machine.iter())
                                    .all(|(a, b)| a == b)
                                && self
                                    .domainname
                                    .iter()
                                    .zip(other.domainname.iter())
                                    .all(|(a, b)| a == b)
                        }
                    }

                    impl Eq for utsname {}

                    impl hash::Hash for utsname {
                        fn hash<H: hash::Hasher>(&self, state: &mut H) {
                            self.sysname.hash(state);
                            self.nodename.hash(state);
                            self.release.hash(state);
                            self.version.hash(state);
                            self.machine.hash(state);
                            self.domainname.hash(state);
                        }
                    }
                }
            }
            
            cfg_if! 
            {
                if #[cfg(target_pointer_width = "32")] {
                    const ULONG_SIZE: usize = 32;
                } else if #[cfg(target_pointer_width = "64")] {
                    const ULONG_SIZE: usize = 64;
                } else {
                    // Unknown target_pointer_width
                }
            }

            pub const EXIT_FAILURE: c_int = 1;
            pub const EXIT_SUCCESS: c_int = 0;
            pub const RAND_MAX: c_int = 2147483647;
            pub const EOF: c_int = -1;
            pub const SEEK_SET: c_int = 0;
            pub const SEEK_CUR: c_int = 1;
            pub const SEEK_END: c_int = 2;
            pub const _IOFBF: c_int = 0;
            pub const _IONBF: c_int = 2;
            pub const _IOLBF: c_int = 1;

            pub const F_DUPFD: c_int = 0;
            pub const F_GETFD: c_int = 1;
            pub const F_SETFD: c_int = 2;
            pub const F_GETFL: c_int = 3;
            pub const F_SETFL: c_int = 4;
            
            pub const F_SETLEASE: c_int = 1024;
            pub const F_GETLEASE: c_int = 1025;
            pub const F_NOTIFY: c_int = 1026;
            pub const F_CANCELLK: c_int = 1029;
            pub const F_DUPFD_CLOEXEC: c_int = 1030;
            pub const F_SETPIPE_SZ: c_int = 1031;
            pub const F_GETPIPE_SZ: c_int = 1032;
            pub const F_ADD_SEALS: c_int = 1033;
            pub const F_GET_SEALS: c_int = 1034;

            pub const F_SEAL_SEAL: c_int = 0x0001;
            pub const F_SEAL_SHRINK: c_int = 0x0002;
            pub const F_SEAL_GROW: c_int = 0x0004;
            pub const F_SEAL_WRITE: c_int = 0x0008;
            
            pub const SIGTRAP: c_int = 5;

            pub const PTHREAD_CREATE_JOINABLE: c_int = 0;
            pub const PTHREAD_CREATE_DETACHED: c_int = 1;

            pub const CLOCK_REALTIME:  clockid_t = 0;
            pub const CLOCK_MONOTONIC:  clockid_t = 1;
            pub const CLOCK_PROCESS_CPUTIME_ID:  clockid_t = 2;
            pub const CLOCK_THREAD_CPUTIME_ID:  clockid_t = 3;
            pub const CLOCK_MONOTONIC_RAW:  clockid_t = 4;
            pub const CLOCK_REALTIME_COARSE:  clockid_t = 5;
            pub const CLOCK_MONOTONIC_COARSE:  clockid_t = 6;
            pub const CLOCK_BOOTTIME:  clockid_t = 7;
            pub const CLOCK_REALTIME_ALARM:  clockid_t = 8;
            pub const CLOCK_BOOTTIME_ALARM:  clockid_t = 9;
            pub const CLOCK_TAI:  clockid_t = 11;
            pub const TIMER_ABSTIME: c_int = 1;

            pub const RUSAGE_SELF: c_int = 0;

            pub const O_RDONLY: c_int = 0;
            pub const O_WRONLY: c_int = 1;
            pub const O_RDWR: c_int = 2;

            pub const SOCK_CLOEXEC: c_int = O_CLOEXEC;

            pub const S_IFIFO: mode_t = 0o1_0000;
            pub const S_IFCHR: mode_t = 0o2_0000;
            pub const S_IFBLK: mode_t = 0o6_0000;
            pub const S_IFDIR: mode_t = 0o4_0000;
            pub const S_IFREG: mode_t = 0o10_0000;
            pub const S_IFLNK: mode_t = 0o12_0000;
            pub const S_IFSOCK: mode_t = 0o14_0000;
            pub const S_IFMT: mode_t = 0o17_0000;
            pub const S_IRWXU: mode_t = 0o0700;
            pub const S_IXUSR: mode_t = 0o0100;
            pub const S_IWUSR: mode_t = 0o0200;
            pub const S_IRUSR: mode_t = 0o0400;
            pub const S_IRWXG: mode_t = 0o0070;
            pub const S_IXGRP: mode_t = 0o0010;
            pub const S_IWGRP: mode_t = 0o0020;
            pub const S_IRGRP: mode_t = 0o0040;
            pub const S_IRWXO: mode_t = 0o0007;
            pub const S_IXOTH: mode_t = 0o0001;
            pub const S_IWOTH: mode_t = 0o0002;
            pub const S_IROTH: mode_t = 0o0004;
            pub const F_OK: c_int = 0;
            pub const R_OK: c_int = 4;
            pub const W_OK: c_int = 2;
            pub const X_OK: c_int = 1;
            pub const STDIN_FILENO: c_int = 0;
            pub const STDOUT_FILENO: c_int = 1;
            pub const STDERR_FILENO: c_int = 2;
            pub const SIGHUP: c_int = 1;
            pub const SIGINT: c_int = 2;
            pub const SIGQUIT: c_int = 3;
            pub const SIGILL: c_int = 4;
            pub const SIGABRT: c_int = 6;
            pub const SIGFPE: c_int = 8;
            pub const SIGKILL: c_int = 9;
            pub const SIGSEGV: c_int = 11;
            pub const SIGPIPE: c_int = 13;
            pub const SIGALRM: c_int = 14;
            pub const SIGTERM: c_int = 15;

            const SIGEV_MAX_SIZE: usize = 64;
            cfg_if! 
            {
                if #[cfg(target_pointer_width = "64")] {
                    const __ARCH_SIGEV_PREAMBLE_SIZE: usize = 4 * 2 + 8;
                } else {
                    const __ARCH_SIGEV_PREAMBLE_SIZE: usize = 4 * 2 + 4;
                }
            }
            const SIGEV_PAD_SIZE: usize = (SIGEV_MAX_SIZE - __ARCH_SIGEV_PREAMBLE_SIZE) / 4;

            pub const PROT_NONE: c_int = 0;
            pub const PROT_READ: c_int = 1;
            pub const PROT_WRITE: c_int = 2;
            pub const PROT_EXEC: c_int = 4;

            pub const XATTR_CREATE: c_int = 0x1;
            pub const XATTR_REPLACE: c_int = 0x2;
            pub const RLIM64_INFINITY:  rlim64_t = !0;

            pub const LC_CTYPE: c_int = 0;
            pub const LC_NUMERIC: c_int = 1;
            pub const LC_TIME: c_int = 2;
            pub const LC_COLLATE: c_int = 3;
            pub const LC_MONETARY: c_int = 4;
            pub const LC_MESSAGES: c_int = 5;
            pub const LC_ALL: c_int = 6;

            pub const LC_CTYPE_MASK: c_int = 1 << LC_CTYPE;
            pub const LC_NUMERIC_MASK: c_int = 1 << LC_NUMERIC;
            pub const LC_TIME_MASK: c_int = 1 << LC_TIME;
            pub const LC_COLLATE_MASK: c_int = 1 << LC_COLLATE;
            pub const LC_MONETARY_MASK: c_int = 1 << LC_MONETARY;
            pub const LC_MESSAGES_MASK: c_int = 1 << LC_MESSAGES;

            pub const MAP_FILE: c_int = 0x0000;
            pub const MAP_SHARED: c_int = 0x0001;
            pub const MAP_PRIVATE: c_int = 0x0002;
            pub const MAP_FIXED: c_int = 0x0010;

            pub const MAP_FAILED: *mut c_void = !0 as *mut c_void;
            pub const MS_ASYNC: c_int = 0x0001;
            pub const MS_INVALIDATE: c_int = 0x0002;
            pub const MS_SYNC: c_int = 0x0004;
            
            pub const MS_RDONLY: c_ulong = 0x01;
            pub const MS_NOSUID: c_ulong = 0x02;
            pub const MS_NODEV: c_ulong = 0x04;
            pub const MS_NOEXEC: c_ulong = 0x08;
            pub const MS_SYNCHRONOUS: c_ulong = 0x10;
            pub const MS_REMOUNT: c_ulong = 0x20;
            pub const MS_MANDLOCK: c_ulong = 0x40;
            pub const MS_DIRSYNC: c_ulong = 0x80;
            pub const MS_NOATIME: c_ulong = 0x0400;
            pub const MS_NODIRATIME: c_ulong = 0x0800;
            pub const MS_BIND: c_ulong = 0x1000;
            pub const MS_MOVE: c_ulong = 0x2000;
            pub const MS_REC: c_ulong = 0x4000;
            pub const MS_SILENT: c_ulong = 0x8000;
            pub const MS_POSIXACL: c_ulong = 0x010000;
            pub const MS_UNBINDABLE: c_ulong = 0x020000;
            pub const MS_PRIVATE: c_ulong = 0x040000;
            pub const MS_SLAVE: c_ulong = 0x080000;
            pub const MS_SHARED: c_ulong = 0x100000;
            pub const MS_RELATIME: c_ulong = 0x200000;
            pub const MS_KERNMOUNT: c_ulong = 0x400000;
            pub const MS_I_VERSION: c_ulong = 0x800000;
            pub const MS_STRICTATIME: c_ulong = 0x1000000;
            pub const MS_LAZYTIME: c_ulong = 0x2000000;
            pub const MS_ACTIVE: c_ulong = 0x40000000;
            pub const MS_MGC_VAL: c_ulong = 0xc0ed0000;
            pub const MS_MGC_MSK: c_ulong = 0xffff0000;

            pub const SCM_RIGHTS: c_int = 0x01;
            pub const SCM_CREDENTIALS: c_int = 0x02;

            pub const PROT_GROWSDOWN: c_int = 0x1000000;
            pub const PROT_GROWSUP: c_int = 0x2000000;

            pub const MAP_TYPE: c_int = 0x000f;

            pub const MADV_NORMAL: c_int = 0;
            pub const MADV_RANDOM: c_int = 1;
            pub const MADV_SEQUENTIAL: c_int = 2;
            pub const MADV_WILLNEED: c_int = 3;
            pub const MADV_DONTNEED: c_int = 4;
            pub const MADV_FREE: c_int = 8;
            pub const MADV_REMOVE: c_int = 9;
            pub const MADV_DONTFORK: c_int = 10;
            pub const MADV_DOFORK: c_int = 11;
            pub const MADV_MERGEABLE: c_int = 12;
            pub const MADV_UNMERGEABLE: c_int = 13;
            pub const MADV_HUGEPAGE: c_int = 14;
            pub const MADV_NOHUGEPAGE: c_int = 15;
            pub const MADV_DONTDUMP: c_int = 16;
            pub const MADV_DODUMP: c_int = 17;
            pub const MADV_WIPEONFORK: c_int = 18;
            pub const MADV_KEEPONFORK: c_int = 19;
            pub const MADV_COLD: c_int = 20;
            pub const MADV_PAGEOUT: c_int = 21;
            pub const MADV_HWPOISON: c_int = 100;
            pub const MADV_POPULATE_READ: c_int = 22;
            pub const MADV_POPULATE_WRITE: c_int = 23;
            pub const MADV_DONTNEED_LOCKED: c_int = 24;

            pub const IFF_UP: c_int = 0x1;
            pub const IFF_BROADCAST: c_int = 0x2;
            pub const IFF_DEBUG: c_int = 0x4;
            pub const IFF_LOOPBACK: c_int = 0x8;
            pub const IFF_POINTOPOINT: c_int = 0x10;
            pub const IFF_NOTRAILERS: c_int = 0x20;
            pub const IFF_RUNNING: c_int = 0x40;
            pub const IFF_NOARP: c_int = 0x80;
            pub const IFF_PROMISC: c_int = 0x100;
            pub const IFF_ALLMULTI: c_int = 0x200;
            pub const IFF_MASTER: c_int = 0x400;
            pub const IFF_SLAVE: c_int = 0x800;
            pub const IFF_MULTICAST: c_int = 0x1000;
            pub const IFF_PORTSEL: c_int = 0x2000;
            pub const IFF_AUTOMEDIA: c_int = 0x4000;
            pub const IFF_DYNAMIC: c_int = 0x8000;

            pub const SOL_IP: c_int = 0;
            pub const SOL_TCP: c_int = 6;
            pub const SOL_UDP: c_int = 17;
            pub const SOL_IPV6: c_int = 41;
            pub const SOL_ICMPV6: c_int = 58;
            pub const SOL_RAW: c_int = 255;
            pub const SOL_DECNET: c_int = 261;
            pub const SOL_X25: c_int = 262;
            pub const SOL_PACKET: c_int = 263;
            pub const SOL_ATM: c_int = 264;
            pub const SOL_AAL: c_int = 265;
            pub const SOL_IRDA: c_int = 266;
            pub const SOL_NETBEUI: c_int = 267;
            pub const SOL_LLC: c_int = 268;
            pub const SOL_DCCP: c_int = 269;
            pub const SOL_NETLINK: c_int = 270;
            pub const SOL_TIPC: c_int = 271;
            pub const SOL_BLUETOOTH: c_int = 274;
            pub const SOL_ALG: c_int = 279;

            pub const AF_UNSPEC: c_int = 0;
            pub const AF_UNIX: c_int = 1;
            pub const AF_LOCAL: c_int = 1;
            pub const AF_INET: c_int = 2;
            pub const AF_AX25: c_int = 3;
            pub const AF_IPX: c_int = 4;
            pub const AF_APPLETALK: c_int = 5;
            pub const AF_NETROM: c_int = 6;
            pub const AF_BRIDGE: c_int = 7;
            pub const AF_ATMPVC: c_int = 8;
            pub const AF_X25: c_int = 9;
            pub const AF_INET6: c_int = 10;
            pub const AF_ROSE: c_int = 11;
            pub const AF_DECnet: c_int = 12;
            pub const AF_NETBEUI: c_int = 13;
            pub const AF_SECURITY: c_int = 14;
            pub const AF_KEY: c_int = 15;
            pub const AF_NETLINK: c_int = 16;
            pub const AF_ROUTE: c_int = AF_NETLINK;
            pub const AF_PACKET: c_int = 17;
            pub const AF_ASH: c_int = 18;
            pub const AF_ECONET: c_int = 19;
            pub const AF_ATMSVC: c_int = 20;
            pub const AF_RDS: c_int = 21;
            pub const AF_SNA: c_int = 22;
            pub const AF_IRDA: c_int = 23;
            pub const AF_PPPOX: c_int = 24;
            pub const AF_WANPIPE: c_int = 25;
            pub const AF_LLC: c_int = 26;
            pub const AF_CAN: c_int = 29;
            pub const AF_TIPC: c_int = 30;
            pub const AF_BLUETOOTH: c_int = 31;
            pub const AF_IUCV: c_int = 32;
            pub const AF_RXRPC: c_int = 33;
            pub const AF_ISDN: c_int = 34;
            pub const AF_PHONET: c_int = 35;
            pub const AF_IEEE802154: c_int = 36;
            pub const AF_CAIF: c_int = 37;
            pub const AF_ALG: c_int = 38;

            pub const PF_UNSPEC: c_int = AF_UNSPEC;
            pub const PF_UNIX: c_int = AF_UNIX;
            pub const PF_LOCAL: c_int = AF_LOCAL;
            pub const PF_INET: c_int = AF_INET;
            pub const PF_AX25: c_int = AF_AX25;
            pub const PF_IPX: c_int = AF_IPX;
            pub const PF_APPLETALK: c_int = AF_APPLETALK;
            pub const PF_NETROM: c_int = AF_NETROM;
            pub const PF_BRIDGE: c_int = AF_BRIDGE;
            pub const PF_ATMPVC: c_int = AF_ATMPVC;
            pub const PF_X25: c_int = AF_X25;
            pub const PF_INET6: c_int = AF_INET6;
            pub const PF_ROSE: c_int = AF_ROSE;
            pub const PF_DECnet: c_int = AF_DECnet;
            pub const PF_NETBEUI: c_int = AF_NETBEUI;
            pub const PF_SECURITY: c_int = AF_SECURITY;
            pub const PF_KEY: c_int = AF_KEY;
            pub const PF_NETLINK: c_int = AF_NETLINK;
            pub const PF_ROUTE: c_int = AF_ROUTE;
            pub const PF_PACKET: c_int = AF_PACKET;
            pub const PF_ASH: c_int = AF_ASH;
            pub const PF_ECONET: c_int = AF_ECONET;
            pub const PF_ATMSVC: c_int = AF_ATMSVC;
            pub const PF_RDS: c_int = AF_RDS;
            pub const PF_SNA: c_int = AF_SNA;
            pub const PF_IRDA: c_int = AF_IRDA;
            pub const PF_PPPOX: c_int = AF_PPPOX;
            pub const PF_WANPIPE: c_int = AF_WANPIPE;
            pub const PF_LLC: c_int = AF_LLC;
            pub const PF_CAN: c_int = AF_CAN;
            pub const PF_TIPC: c_int = AF_TIPC;
            pub const PF_BLUETOOTH: c_int = AF_BLUETOOTH;
            pub const PF_IUCV: c_int = AF_IUCV;
            pub const PF_RXRPC: c_int = AF_RXRPC;
            pub const PF_ISDN: c_int = AF_ISDN;
            pub const PF_PHONET: c_int = AF_PHONET;
            pub const PF_IEEE802154: c_int = AF_IEEE802154;
            pub const PF_CAIF: c_int = AF_CAIF;
            pub const PF_ALG: c_int = AF_ALG;

            pub const MSG_OOB: c_int = 1;
            pub const MSG_PEEK: c_int = 2;
            pub const MSG_DONTROUTE: c_int = 4;
            pub const MSG_CTRUNC: c_int = 8;
            pub const MSG_TRUNC: c_int = 0x20;
            pub const MSG_DONTWAIT: c_int = 0x40;
            pub const MSG_EOR: c_int = 0x80;
            pub const MSG_WAITALL: c_int = 0x100;
            pub const MSG_FIN: c_int = 0x200;
            pub const MSG_SYN: c_int = 0x400;
            pub const MSG_CONFIRM: c_int = 0x800;
            pub const MSG_RST: c_int = 0x1000;
            pub const MSG_ERRQUEUE: c_int = 0x2000;
            pub const MSG_NOSIGNAL: c_int = 0x4000;
            pub const MSG_MORE: c_int = 0x8000;
            pub const MSG_WAITFORONE: c_int = 0x10000;
            pub const MSG_FASTOPEN: c_int = 0x20000000;
            pub const MSG_CMSG_CLOEXEC: c_int = 0x40000000;

            pub const SCM_TIMESTAMP: c_int = SO_TIMESTAMP;

            pub const SOCK_RAW: c_int = 3;
            pub const SOCK_RDM: c_int = 4;
            pub const IP_TOS: c_int = 1;
            pub const IP_TTL: c_int = 2;
            pub const IP_HDRINCL: c_int = 3;
            pub const IP_OPTIONS: c_int = 4;
            pub const IP_ROUTER_ALERT: c_int = 5;
            pub const IP_RECVOPTS: c_int = 6;
            pub const IP_RETOPTS: c_int = 7;
            pub const IP_PKTINFO: c_int = 8;
            pub const IP_PKTOPTIONS: c_int = 9;
            pub const IP_MTU_DISCOVER: c_int = 10;
            pub const IP_RECVERR: c_int = 11;
            pub const IP_RECVTTL: c_int = 12;
            pub const IP_RECVTOS: c_int = 13;
            pub const IP_MTU: c_int = 14;
            pub const IP_FREEBIND: c_int = 15;
            pub const IP_IPSEC_POLICY: c_int = 16;
            pub const IP_XFRM_POLICY: c_int = 17;
            pub const IP_PASSSEC: c_int = 18;
            pub const IP_TRANSPARENT: c_int = 19;
            pub const IP_ORIGDSTADDR: c_int = 20;
            pub const IP_RECVORIGDSTADDR: c_int = IP_ORIGDSTADDR;
            pub const IP_MINTTL: c_int = 21;
            pub const IP_NODEFRAG: c_int = 22;
            pub const IP_CHECKSUM: c_int = 23;
            pub const IP_BIND_ADDRESS_NO_PORT: c_int = 24;
            pub const IP_MULTICAST_IF: c_int = 32;
            pub const IP_MULTICAST_TTL: c_int = 33;
            pub const IP_MULTICAST_LOOP: c_int = 34;
            pub const IP_ADD_MEMBERSHIP: c_int = 35;
            pub const IP_DROP_MEMBERSHIP: c_int = 36;
            pub const IP_UNBLOCK_SOURCE: c_int = 37;
            pub const IP_BLOCK_SOURCE: c_int = 38;
            pub const IP_ADD_SOURCE_MEMBERSHIP: c_int = 39;
            pub const IP_DROP_SOURCE_MEMBERSHIP: c_int = 40;
            pub const IP_MSFILTER: c_int = 41;
            pub const IP_MULTICAST_ALL: c_int = 49;
            pub const IP_UNICAST_IF: c_int = 50;

            pub const IP_DEFAULT_MULTICAST_TTL: c_int = 1;
            pub const IP_DEFAULT_MULTICAST_LOOP: c_int = 1;

            pub const IP_PMTUDISC_DONT: c_int = 0;
            pub const IP_PMTUDISC_WANT: c_int = 1;
            pub const IP_PMTUDISC_DO: c_int = 2;
            pub const IP_PMTUDISC_PROBE: c_int = 3;
            pub const IP_PMTUDISC_INTERFACE: c_int = 4;
            pub const IP_PMTUDISC_OMIT: c_int = 5;
            
            /// Hop-by-hop option header
            pub const IPPROTO_HOPOPTS: c_int = 0;
            /// group mgmt protocol
            pub const IPPROTO_IGMP: c_int = 2;
            /// for compatibility
            pub const IPPROTO_IPIP: c_int = 4;
            /// exterior gateway protocol
            pub const IPPROTO_EGP: c_int = 8;
            /// pup
            pub const IPPROTO_PUP: c_int = 12;
            /// xns idp
            pub const IPPROTO_IDP: c_int = 22;
            /// tp-4 w/ class negotiation
            pub const IPPROTO_TP: c_int = 29;
            /// DCCP
            pub const IPPROTO_DCCP: c_int = 33;
            /// IP6 routing header
            pub const IPPROTO_ROUTING: c_int = 43;
            /// IP6 fragmentation header
            pub const IPPROTO_FRAGMENT: c_int = 44;
            /// resource reservation
            pub const IPPROTO_RSVP: c_int = 46;
            /// General Routing Encap.
            pub const IPPROTO_GRE: c_int = 47;
            /// IP6 Encap Sec. Payload
            pub const IPPROTO_ESP: c_int = 50;
            /// IP6 Auth Header
            pub const IPPROTO_AH: c_int = 51;
            /// IP6 no next header
            pub const IPPROTO_NONE: c_int = 59;
            /// IP6 destination option
            pub const IPPROTO_DSTOPTS: c_int = 60;
            pub const IPPROTO_MTP: c_int = 92;
            /// encapsulation header
            pub const IPPROTO_ENCAP: c_int = 98;
            /// Protocol indep. multicast
            pub const IPPROTO_PIM: c_int = 103;
            /// IP Payload Comp. Protocol
            pub const IPPROTO_COMP: c_int = 108;
            /// SCTP
            pub const IPPROTO_SCTP: c_int = 132;
            pub const IPPROTO_MH: c_int = 135;
            pub const IPPROTO_UDPLITE: c_int = 136;
            /// raw IP packet
            pub const IPPROTO_RAW: c_int = 255;
            pub const IPPROTO_BEETPH: c_int = 94;
            pub const IPPROTO_MPLS: c_int = 137;
            /// Multipath TCP
            pub const IPPROTO_MPTCP: c_int = 262;
            /// Ethernet-within-IPv6 encapsulation.
            pub const IPPROTO_ETHERNET: c_int = 143;

            pub const MCAST_EXCLUDE: c_int = 0;
            pub const MCAST_INCLUDE: c_int = 1;
            pub const MCAST_JOIN_GROUP: c_int = 42;
            pub const MCAST_BLOCK_SOURCE: c_int = 43;
            pub const MCAST_UNBLOCK_SOURCE: c_int = 44;
            pub const MCAST_LEAVE_GROUP: c_int = 45;
            pub const MCAST_JOIN_SOURCE_GROUP: c_int = 46;
            pub const MCAST_LEAVE_SOURCE_GROUP: c_int = 47;
            pub const MCAST_MSFILTER: c_int = 48;

            pub const IPV6_ADDRFORM: c_int = 1;
            pub const IPV6_2292PKTINFO: c_int = 2;
            pub const IPV6_2292HOPOPTS: c_int = 3;
            pub const IPV6_2292DSTOPTS: c_int = 4;
            pub const IPV6_2292RTHDR: c_int = 5;
            pub const IPV6_2292PKTOPTIONS: c_int = 6;
            pub const IPV6_CHECKSUM: c_int = 7;
            pub const IPV6_2292HOPLIMIT: c_int = 8;
            pub const IPV6_NEXTHOP: c_int = 9;
            pub const IPV6_AUTHHDR: c_int = 10;
            pub const IPV6_UNICAST_HOPS: c_int = 16;
            pub const IPV6_MULTICAST_IF: c_int = 17;
            pub const IPV6_MULTICAST_HOPS: c_int = 18;
            pub const IPV6_MULTICAST_LOOP: c_int = 19;
            pub const IPV6_ADD_MEMBERSHIP: c_int = 20;
            pub const IPV6_DROP_MEMBERSHIP: c_int = 21;
            pub const IPV6_ROUTER_ALERT: c_int = 22;
            pub const IPV6_MTU_DISCOVER: c_int = 23;
            pub const IPV6_MTU: c_int = 24;
            pub const IPV6_RECVERR: c_int = 25;
            pub const IPV6_V6ONLY: c_int = 26;
            pub const IPV6_JOIN_ANYCAST: c_int = 27;
            pub const IPV6_LEAVE_ANYCAST: c_int = 28;
            pub const IPV6_IPSEC_POLICY: c_int = 34;
            pub const IPV6_XFRM_POLICY: c_int = 35;
            pub const IPV6_HDRINCL: c_int = 36;
            pub const IPV6_RECVPKTINFO: c_int = 49;
            pub const IPV6_PKTINFO: c_int = 50;
            pub const IPV6_RECVHOPLIMIT: c_int = 51;
            pub const IPV6_HOPLIMIT: c_int = 52;
            pub const IPV6_RECVHOPOPTS: c_int = 53;
            pub const IPV6_HOPOPTS: c_int = 54;
            pub const IPV6_RTHDRDSTOPTS: c_int = 55;
            pub const IPV6_RECVRTHDR: c_int = 56;
            pub const IPV6_RTHDR: c_int = 57;
            pub const IPV6_RECVDSTOPTS: c_int = 58;
            pub const IPV6_DSTOPTS: c_int = 59;
            pub const IPV6_RECVPATHMTU: c_int = 60;
            pub const IPV6_PATHMTU: c_int = 61;
            pub const IPV6_DONTFRAG: c_int = 62;
            pub const IPV6_RECVTCLASS: c_int = 66;
            pub const IPV6_TCLASS: c_int = 67;
            pub const IPV6_AUTOFLOWLABEL: c_int = 70;
            pub const IPV6_ADDR_PREFERENCES: c_int = 72;
            pub const IPV6_MINHOPCOUNT: c_int = 73;
            pub const IPV6_ORIGDSTADDR: c_int = 74;
            pub const IPV6_RECVORIGDSTADDR: c_int = IPV6_ORIGDSTADDR;
            pub const IPV6_TRANSPARENT: c_int = 75;
            pub const IPV6_UNICAST_IF: c_int = 76;
            pub const IPV6_PREFER_SRC_TMP: c_int = 0x0001;
            pub const IPV6_PREFER_SRC_PUBLIC: c_int = 0x0002;
            pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: c_int = 0x0100;
            pub const IPV6_PREFER_SRC_COA: c_int = 0x0004;
            pub const IPV6_PREFER_SRC_HOME: c_int = 0x0400;
            pub const IPV6_PREFER_SRC_CGA: c_int = 0x0008;
            pub const IPV6_PREFER_SRC_NONCGA: c_int = 0x0800;

            pub const IPV6_PMTUDISC_DONT: c_int = 0;
            pub const IPV6_PMTUDISC_WANT: c_int = 1;
            pub const IPV6_PMTUDISC_DO: c_int = 2;
            pub const IPV6_PMTUDISC_PROBE: c_int = 3;
            pub const IPV6_PMTUDISC_INTERFACE: c_int = 4;
            pub const IPV6_PMTUDISC_OMIT: c_int = 5;

            pub const TCP_NODELAY: c_int = 1;
            pub const TCP_MAXSEG: c_int = 2;
            pub const TCP_CORK: c_int = 3;
            pub const TCP_KEEPIDLE: c_int = 4;
            pub const TCP_KEEPINTVL: c_int = 5;
            pub const TCP_KEEPCNT: c_int = 6;
            pub const TCP_SYNCNT: c_int = 7;
            pub const TCP_LINGER2: c_int = 8;
            pub const TCP_DEFER_ACCEPT: c_int = 9;
            pub const TCP_WINDOW_CLAMP: c_int = 10;
            pub const TCP_INFO: c_int = 11;
            pub const TCP_QUICKACK: c_int = 12;
            pub const TCP_CONGESTION: c_int = 13;
            pub const TCP_MD5SIG: c_int = 14;
            pub const TCP_COOKIE_TRANSACTIONS: c_int = 15;
            pub const TCP_THIN_LINEAR_TIMEOUTS: c_int = 16;
            pub const TCP_THIN_DUPACK: c_int = 17;
            pub const TCP_USER_TIMEOUT: c_int = 18;
            pub const TCP_REPAIR: c_int = 19;
            pub const TCP_REPAIR_QUEUE: c_int = 20;
            pub const TCP_QUEUE_SEQ: c_int = 21;
            pub const TCP_REPAIR_OPTIONS: c_int = 22;
            pub const TCP_FASTOPEN: c_int = 23;
            pub const TCP_TIMESTAMP: c_int = 24;
            pub const TCP_NOTSENT_LOWAT: c_int = 25;
            pub const TCP_CC_INFO: c_int = 26;
            pub const TCP_SAVE_SYN: c_int = 27;
            pub const TCP_SAVED_SYN: c_int = 28;
            pub const TCP_REPAIR_WINDOW: c_int = 29;
            pub const TCP_FASTOPEN_CONNECT: c_int = 30;
            pub const TCP_ULP: c_int = 31;
            pub const TCP_MD5SIG_EXT: c_int = 32;
            pub const TCP_FASTOPEN_KEY: c_int = 33;
            pub const TCP_FASTOPEN_NO_COOKIE: c_int = 34;
            pub const TCP_ZEROCOPY_RECEIVE: c_int = 35;
            pub const TCP_INQ: c_int = 36;
            pub const TCP_CM_INQ: c_int = TCP_INQ;
            // pub const TCP_TX_DELAY: c_int = 37;
            pub const TCP_MD5SIG_MAXKEYLEN: usize = 80;

            pub const SO_DEBUG: c_int = 1;

            pub const SHUT_RD: c_int = 0;
            pub const SHUT_WR: c_int = 1;
            pub const SHUT_RDWR: c_int = 2;

            pub const LOCK_SH: c_int = 1;
            pub const LOCK_EX: c_int = 2;
            pub const LOCK_NB: c_int = 4;
            pub const LOCK_UN: c_int = 8;

            pub const SS_ONSTACK: c_int = 1;
            pub const SS_DISABLE: c_int = 2;

            pub const PATH_MAX: c_int = 4096;

            pub const UIO_MAXIOV: c_int = 1024;

            pub const FD_SETSIZE: c_int = 1024;

            pub const EPOLLIN: u32 = 0x1;
            pub const EPOLLPRI: u32 = 0x2;
            pub const EPOLLOUT: u32 = 0x4;
            pub const EPOLLERR: u32 = 0x8;
            pub const EPOLLHUP: u32 = 0x10;
            pub const EPOLLRDNORM: u32 = 0x40;
            pub const EPOLLRDBAND: u32 = 0x80;
            pub const EPOLLWRNORM: u32 = 0x100;
            pub const EPOLLWRBAND: u32 = 0x200;
            pub const EPOLLMSG: u32 = 0x400;
            pub const EPOLLRDHUP: u32 = 0x2000;
            pub const EPOLLEXCLUSIVE: u32 = 0x10000000;
            pub const EPOLLWAKEUP: u32 = 0x20000000;
            pub const EPOLLONESHOT: u32 = 0x40000000;
            pub const EPOLLET: u32 = 0x80000000;

            pub const EPOLL_CTL_ADD: c_int = 1;
            pub const EPOLL_CTL_MOD: c_int = 3;
            pub const EPOLL_CTL_DEL: c_int = 2;

            pub const MNT_FORCE: c_int = 0x1;
            pub const MNT_DETACH: c_int = 0x2;
            pub const MNT_EXPIRE: c_int = 0x4;
            pub const UMOUNT_NOFOLLOW: c_int = 0x8;

            pub const Q_GETFMT: c_int = 0x800004;
            pub const Q_GETINFO: c_int = 0x800005;
            pub const Q_SETINFO: c_int = 0x800006;
            pub const QIF_BLIMITS: u32 = 1;
            pub const QIF_SPACE: u32 = 2;
            pub const QIF_ILIMITS: u32 = 4;
            pub const QIF_INODES: u32 = 8;
            pub const QIF_BTIME: u32 = 16;
            pub const QIF_ITIME: u32 = 32;
            pub const QIF_LIMITS: u32 = 5;
            pub const QIF_USAGE: u32 = 10;
            pub const QIF_TIMES: u32 = 48;
            pub const QIF_ALL: u32 = 63;

            pub const Q_SYNC: c_int = 0x800001;
            pub const Q_QUOTAON: c_int = 0x800002;
            pub const Q_QUOTAOFF: c_int = 0x800003;
            pub const Q_GETQUOTA: c_int = 0x800007;
            pub const Q_SETQUOTA: c_int = 0x800008;

            pub const TCIOFF: c_int = 2;
            pub const TCION: c_int = 3;
            pub const TCOOFF: c_int = 0;
            pub const TCOON: c_int = 1;
            pub const TCIFLUSH: c_int = 0;
            pub const TCOFLUSH: c_int = 1;
            pub const TCIOFLUSH: c_int = 2;
            pub const NL0:  tcflag_t = 0x00000000;
            pub const NL1:  tcflag_t = 0x00000100;
            pub const TAB0:  tcflag_t = 0x00000000;
            pub const CR0:  tcflag_t = 0x00000000;
            pub const FF0:  tcflag_t = 0x00000000;
            pub const BS0:  tcflag_t = 0x00000000;
            pub const VT0:  tcflag_t = 0x00000000;
            pub const VERASE: usize = 2;
            pub const VKILL: usize = 3;
            pub const VINTR: usize = 0;
            pub const VQUIT: usize = 1;
            pub const VLNEXT: usize = 15;
            pub const IGNBRK:  tcflag_t = 0x00000001;
            pub const BRKINT:  tcflag_t = 0x00000002;
            pub const IGNPAR:  tcflag_t = 0x00000004;
            pub const PARMRK:  tcflag_t = 0x00000008;
            pub const INPCK:  tcflag_t = 0x00000010;
            pub const ISTRIP:  tcflag_t = 0x00000020;
            pub const INLCR:  tcflag_t = 0x00000040;
            pub const IGNCR:  tcflag_t = 0x00000080;
            pub const ICRNL:  tcflag_t = 0x00000100;
            pub const IXANY:  tcflag_t = 0x00000800;
            pub const IMAXBEL:  tcflag_t = 0x00002000;
            pub const OPOST:  tcflag_t = 0x1;
            pub const CS5:  tcflag_t = 0x00000000;
            pub const CRTSCTS:  tcflag_t = 0x80000000;
            pub const ECHO:  tcflag_t = 0x00000008;
            pub const OCRNL:  tcflag_t = 0o000010;
            pub const ONOCR:  tcflag_t = 0o000020;
            pub const ONLRET:  tcflag_t = 0o000040;
            pub const OFILL:  tcflag_t = 0o000100;
            pub const OFDEL:  tcflag_t = 0o000200;

            pub const CLONE_VM: c_int = 0x100;
            pub const CLONE_FS: c_int = 0x200;
            pub const CLONE_FILES: c_int = 0x400;
            pub const CLONE_SIGHAND: c_int = 0x800;
            pub const CLONE_PTRACE: c_int = 0x2000;
            pub const CLONE_VFORK: c_int = 0x4000;
            pub const CLONE_PARENT: c_int = 0x8000;
            pub const CLONE_THREAD: c_int = 0x10000;
            pub const CLONE_NEWNS: c_int = 0x20000;
            pub const CLONE_SYSVSEM: c_int = 0x40000;
            pub const CLONE_SETTLS: c_int = 0x80000;
            pub const CLONE_PARENT_SETTID: c_int = 0x100000;
            pub const CLONE_CHILD_CLEARTID: c_int = 0x200000;
            pub const CLONE_DETACHED: c_int = 0x400000;
            pub const CLONE_UNTRACED: c_int = 0x800000;
            pub const CLONE_CHILD_SETTID: c_int = 0x01000000;
            pub const CLONE_NEWCGROUP: c_int = 0x02000000;
            pub const CLONE_NEWUTS: c_int = 0x04000000;
            pub const CLONE_NEWIPC: c_int = 0x08000000;
            pub const CLONE_NEWUSER: c_int = 0x10000000;
            pub const CLONE_NEWPID: c_int = 0x20000000;
            pub const CLONE_NEWNET: c_int = 0x40000000;
            pub const CLONE_IO: c_int = 0x80000000;

            pub const WNOHANG: c_int = 0x00000001;
            pub const WUNTRACED: c_int = 0x00000002;
            pub const WSTOPPED: c_int = WUNTRACED;
            pub const WEXITED: c_int = 0x00000004;
            pub const WCONTINUED: c_int = 0x00000008;
            pub const WNOWAIT: c_int = 0x01000000;
            
            pub const ADDR_NO_RANDOMIZE: c_int = 0x0040000;
            pub const MMAP_PAGE_ZERO: c_int = 0x0100000;
            pub const ADDR_COMPAT_LAYOUT: c_int = 0x0200000;
            pub const READ_IMPLIES_EXEC: c_int = 0x0400000;
            pub const ADDR_LIMIT_32BIT: c_int = 0x0800000;
            pub const SHORT_INODE: c_int = 0x1000000;
            pub const WHOLE_SECONDS: c_int = 0x2000000;
            pub const STICKY_TIMEOUTS: c_int = 0x4000000;
            pub const ADDR_LIMIT_3GB: c_int = 0x8000000;
            
            pub const PTRACE_O_TRACESYSGOOD: c_int = 0x00000001;
            pub const PTRACE_O_TRACEFORK: c_int = 0x00000002;
            pub const PTRACE_O_TRACEVFORK: c_int = 0x00000004;
            pub const PTRACE_O_TRACECLONE: c_int = 0x00000008;
            pub const PTRACE_O_TRACEEXEC: c_int = 0x00000010;
            pub const PTRACE_O_TRACEVFORKDONE: c_int = 0x00000020;
            pub const PTRACE_O_TRACEEXIT: c_int = 0x00000040;
            pub const PTRACE_O_TRACESECCOMP: c_int = 0x00000080;
            pub const PTRACE_O_SUSPEND_SECCOMP: c_int = 0x00200000;
            pub const PTRACE_O_EXITKILL: c_int = 0x00100000;
            pub const PTRACE_O_MASK: c_int = 0x003000ff;
            
            pub const PTRACE_EVENT_FORK: c_int = 1;
            pub const PTRACE_EVENT_VFORK: c_int = 2;
            pub const PTRACE_EVENT_CLONE: c_int = 3;
            pub const PTRACE_EVENT_EXEC: c_int = 4;
            pub const PTRACE_EVENT_VFORK_DONE: c_int = 5;
            pub const PTRACE_EVENT_EXIT: c_int = 6;
            pub const PTRACE_EVENT_SECCOMP: c_int = 7;

            pub const __WNOTHREAD: c_int = 0x20000000;
            pub const __WALL: c_int = 0x40000000;
            pub const __WCLONE: c_int = 0x80000000;

            pub const SPLICE_F_MOVE: c_uint = 0x01;
            pub const SPLICE_F_NONBLOCK: c_uint = 0x02;
            pub const SPLICE_F_MORE: c_uint = 0x04;
            pub const SPLICE_F_GIFT: c_uint = 0x08;

            pub const RTLD_LOCAL: c_int = 0;
            pub const RTLD_LAZY: c_int = 1;

            pub const POSIX_FADV_NORMAL: c_int = 0;
            pub const POSIX_FADV_RANDOM: c_int = 1;
            pub const POSIX_FADV_SEQUENTIAL: c_int = 2;
            pub const POSIX_FADV_WILLNEED: c_int = 3;

            pub const AT_FDCWD: c_int = -100;
            pub const AT_SYMLINK_NOFOLLOW: c_int = 0x100;
            pub const AT_REMOVEDIR: c_int = 0x200;
            pub const AT_SYMLINK_FOLLOW: c_int = 0x400;
            pub const AT_NO_AUTOMOUNT: c_int = 0x800;
            pub const AT_EMPTY_PATH: c_int = 0x1000;
            pub const AT_RECURSIVE: c_int = 0x8000;

            pub const LOG_CRON: c_int = 9 << 3;
            pub const LOG_AUTHPRIV: c_int = 10 << 3;
            pub const LOG_FTP: c_int = 11 << 3;
            pub const LOG_PERROR: c_int = 0x20;

            pub const PIPE_BUF: usize = 4096;

            pub const SI_LOAD_SHIFT: c_uint = 16;
            
            pub const SI_USER: c_int = 0;
            pub const SI_KERNEL: c_int = 0x80;
            pub const SI_QUEUE: c_int = -1;
            pub const SI_TIMER: c_int = -2;
            pub const SI_MESGQ: c_int = -3;
            pub const SI_ASYNCIO: c_int = -4;
            pub const SI_SIGIO: c_int = -5;
            pub const SI_TKILL: c_int = -6;
            pub const SI_ASYNCNL: c_int = -60;
            
            pub const BUS_ADRALN: c_int = 1;
            pub const BUS_ADRERR: c_int = 2;
            pub const BUS_OBJERR: c_int = 3;
            
            pub const BUS_MCEERR_AR: c_int = 4;
            pub const BUS_MCEERR_AO: c_int = 5;
            
            pub const TRAP_BRKPT: c_int = 1;
            pub const TRAP_TRACE: c_int = 2;
            pub const TRAP_BRANCH: c_int = 3;
            pub const TRAP_HWBKPT: c_int = 4;
            pub const TRAP_UNK: c_int = 5;
            
            pub const CLD_EXITED: c_int = 1;
            pub const CLD_KILLED: c_int = 2;
            pub const CLD_DUMPED: c_int = 3;
            pub const CLD_TRAPPED: c_int = 4;
            pub const CLD_STOPPED: c_int = 5;
            pub const CLD_CONTINUED: c_int = 6;

            pub const SIGEV_SIGNAL: c_int = 0;
            pub const SIGEV_NONE: c_int = 1;
            pub const SIGEV_THREAD: c_int = 2;

            pub const P_ALL: idtype_t = 0;
            pub const P_PID: idtype_t = 1;
            pub const P_PGID: idtype_t = 2;
            pub const P_PIDFD: idtype_t = 3;

            pub const UTIME_OMIT: c_long = 1073741822;
            pub const UTIME_NOW: c_long = 1073741823;

            pub const POLLIN: c_short = 0x1;
            pub const POLLPRI: c_short = 0x2;
            pub const POLLOUT: c_short = 0x4;
            pub const POLLERR: c_short = 0x8;
            pub const POLLHUP: c_short = 0x10;
            pub const POLLNVAL: c_short = 0x20;
            pub const POLLRDNORM: c_short = 0x040;
            pub const POLLRDBAND: c_short = 0x080;
            pub const POLLRDHUP: c_short = 0x2000;

            pub const IPTOS_LOWDELAY: u8 = 0x10;
            pub const IPTOS_THROUGHPUT: u8 = 0x08;
            pub const IPTOS_RELIABILITY: u8 = 0x04;
            pub const IPTOS_MINCOST: u8 = 0x02;

            pub const IPTOS_PREC_NETCONTROL: u8 = 0xe0;
            pub const IPTOS_PREC_INTERNETCONTROL: u8 = 0xc0;
            pub const IPTOS_PREC_CRITIC_ECP: u8 = 0xa0;
            pub const IPTOS_PREC_FLASHOVERRIDE: u8 = 0x80;
            pub const IPTOS_PREC_FLASH: u8 = 0x60;
            pub const IPTOS_PREC_IMMEDIATE: u8 = 0x40;
            pub const IPTOS_PREC_PRIORITY: u8 = 0x20;
            pub const IPTOS_PREC_ROUTINE: u8 = 0x00;

            pub const IPTOS_ECN_MASK: u8 = 0x03;
            pub const IPTOS_ECN_ECT1: u8 = 0x01;
            pub const IPTOS_ECN_ECT0: u8 = 0x02;
            pub const IPTOS_ECN_CE: u8 = 0x03;

            pub const IPOPT_COPY: u8 = 0x80;
            pub const IPOPT_CLASS_MASK: u8 = 0x60;
            pub const IPOPT_NUMBER_MASK: u8 = 0x1f;

            pub const IPOPT_CONTROL: u8 = 0x00;
            pub const IPOPT_RESERVED1: u8 = 0x20;
            pub const IPOPT_MEASUREMENT: u8 = 0x40;
            pub const IPOPT_RESERVED2: u8 = 0x60;
            pub const IPOPT_END: u8 = 0 | IPOPT_CONTROL;
            pub const IPOPT_NOOP: u8 = 1 | IPOPT_CONTROL;
            pub const IPOPT_SEC: u8 = 2 | IPOPT_CONTROL | IPOPT_COPY;
            pub const IPOPT_LSRR: u8 = 3 | IPOPT_CONTROL | IPOPT_COPY;
            pub const IPOPT_TIMESTAMP: u8 = 4 | IPOPT_MEASUREMENT;
            pub const IPOPT_RR: u8 = 7 | IPOPT_CONTROL;
            pub const IPOPT_SID: u8 = 8 | IPOPT_CONTROL | IPOPT_COPY;
            pub const IPOPT_SSRR: u8 = 9 | IPOPT_CONTROL | IPOPT_COPY;
            pub const IPOPT_RA: u8 = 20 | IPOPT_CONTROL | IPOPT_COPY;
            pub const IPVERSION: u8 = 4;
            pub const MAXTTL: u8 = 255;
            pub const IPDEFTTL: u8 = 64;
            pub const IPOPT_OPTVAL: u8 = 0;
            pub const IPOPT_OLEN: u8 = 1;
            pub const IPOPT_OFFSET: u8 = 2;
            pub const IPOPT_MINOFF: u8 = 4;
            pub const MAX_IPOPTLEN: u8 = 40;
            pub const IPOPT_NOP: u8 = IPOPT_NOOP;
            pub const IPOPT_EOL: u8 = IPOPT_END;
            pub const IPOPT_TS: u8 = IPOPT_TIMESTAMP;
            pub const IPOPT_TS_TSONLY: u8 = 0;
            pub const IPOPT_TS_TSANDADDR: u8 = 1;
            pub const IPOPT_TS_PRESPEC: u8 = 3;

            pub const ARPOP_RREQUEST: u16 = 3;
            pub const ARPOP_RREPLY: u16 = 4;
            pub const ARPOP_InREQUEST: u16 = 8;
            pub const ARPOP_InREPLY: u16 = 9;
            pub const ARPOP_NAK: u16 = 10;

            pub const ATF_NETMASK: c_int = 0x20;
            pub const ATF_DONTPUB: c_int = 0x40;

            pub const ARPHRD_NETROM: u16 = 0;
            pub const ARPHRD_ETHER: u16 = 1;
            pub const ARPHRD_EETHER: u16 = 2;
            pub const ARPHRD_AX25: u16 = 3;
            pub const ARPHRD_PRONET: u16 = 4;
            pub const ARPHRD_CHAOS: u16 = 5;
            pub const ARPHRD_IEEE802: u16 = 6;
            pub const ARPHRD_ARCNET: u16 = 7;
            pub const ARPHRD_APPLETLK: u16 = 8;
            pub const ARPHRD_DLCI: u16 = 15;
            pub const ARPHRD_ATM: u16 = 19;
            pub const ARPHRD_METRICOM: u16 = 23;
            pub const ARPHRD_IEEE1394: u16 = 24;
            pub const ARPHRD_EUI64: u16 = 27;
            pub const ARPHRD_INFINIBAND: u16 = 32;

            pub const ARPHRD_SLIP: u16 = 256;
            pub const ARPHRD_CSLIP: u16 = 257;
            pub const ARPHRD_SLIP6: u16 = 258;
            pub const ARPHRD_CSLIP6: u16 = 259;
            pub const ARPHRD_RSRVD: u16 = 260;
            pub const ARPHRD_ADAPT: u16 = 264;
            pub const ARPHRD_ROSE: u16 = 270;
            pub const ARPHRD_X25: u16 = 271;
            pub const ARPHRD_HWX25: u16 = 272;
            pub const ARPHRD_CAN: u16 = 280;
            pub const ARPHRD_PPP: u16 = 512;
            pub const ARPHRD_CISCO: u16 = 513;
            pub const ARPHRD_HDLC: u16 = ARPHRD_CISCO;
            pub const ARPHRD_LAPB: u16 = 516;
            pub const ARPHRD_DDCMP: u16 = 517;
            pub const ARPHRD_RAWHDLC: u16 = 518;

            pub const ARPHRD_TUNNEL: u16 = 768;
            pub const ARPHRD_TUNNEL6: u16 = 769;
            pub const ARPHRD_FRAD: u16 = 770;
            pub const ARPHRD_SKIP: u16 = 771;
            pub const ARPHRD_LOOPBACK: u16 = 772;
            pub const ARPHRD_LOCALTLK: u16 = 773;
            pub const ARPHRD_FDDI: u16 = 774;
            pub const ARPHRD_BIF: u16 = 775;
            pub const ARPHRD_SIT: u16 = 776;
            pub const ARPHRD_IPDDP: u16 = 777;
            pub const ARPHRD_IPGRE: u16 = 778;
            pub const ARPHRD_PIMREG: u16 = 779;
            pub const ARPHRD_HIPPI: u16 = 780;
            pub const ARPHRD_ASH: u16 = 781;
            pub const ARPHRD_ECONET: u16 = 782;
            pub const ARPHRD_IRDA: u16 = 783;
            pub const ARPHRD_FCPP: u16 = 784;
            pub const ARPHRD_FCAL: u16 = 785;
            pub const ARPHRD_FCPL: u16 = 786;
            pub const ARPHRD_FCFABRIC: u16 = 787;
            pub const ARPHRD_IEEE802_TR: u16 = 800;
            pub const ARPHRD_IEEE80211: u16 = 801;
            pub const ARPHRD_IEEE80211_PRISM: u16 = 802;
            pub const ARPHRD_IEEE80211_RADIOTAP: u16 = 803;
            pub const ARPHRD_IEEE802154: u16 = 804;

            pub const ARPHRD_VOID: u16 = 0xFFFF;
            pub const ARPHRD_NONE: u16 = 0xFFFE;

            // linux/if_tun.h
            /* TUNSETIFF ifr flags */
            pub const IFF_TUN: c_int = 0x0001;
            pub const IFF_TAP: c_int = 0x0002;
            pub const IFF_NAPI: c_int = 0x0010;
            pub const IFF_NAPI_FRAGS: c_int = 0x0020;
            // Used in TUNSETIFF to bring up tun/tap without carrier
            pub const IFF_NO_CARRIER: c_int = 0x0040;
            pub const IFF_NO_PI: c_int = 0x1000;
            // Read queue size
            pub const TUN_READQ_SIZE: c_short = 500;
            // TUN device type flags: deprecated. Use IFF_TUN/IFF_TAP instead.
            pub const TUN_TUN_DEV: c_short =  IFF_TUN as c_short;
            pub const TUN_TAP_DEV: c_short =  IFF_TAP as c_short;
            pub const TUN_TYPE_MASK: c_short = 0x000f;
            // This flag has no real effect
            pub const IFF_ONE_QUEUE: c_int = 0x2000;
            pub const IFF_VNET_HDR: c_int = 0x4000;
            pub const IFF_TUN_EXCL: c_int = 0x8000;
            pub const IFF_MULTI_QUEUE: c_int = 0x0100;
            pub const IFF_ATTACH_QUEUE: c_int = 0x0200;
            pub const IFF_DETACH_QUEUE: c_int = 0x0400;
            // read-only flag
            pub const IFF_PERSIST: c_int = 0x0800;
            pub const IFF_NOFILTER: c_int = 0x1000;
            // Socket options
            pub const TUN_TX_TIMESTAMP: c_int = 1;
            // Features for GSO (TUNSETOFFLOAD)
            pub const TUN_F_CSUM: c_uint = 0x01;
            pub const TUN_F_TSO4: c_uint = 0x02;
            pub const TUN_F_TSO6: c_uint = 0x04;
            pub const TUN_F_TSO_ECN: c_uint = 0x08;
            pub const TUN_F_UFO: c_uint = 0x10;
            pub const TUN_F_USO4: c_uint = 0x20;
            pub const TUN_F_USO6: c_uint = 0x40;
            // Protocol info prepended to the packets (when IFF_NO_PI is not set)
            pub const TUN_PKT_STRIP: c_int = 0x0001;
            // Accept all multicast packets
            pub const TUN_FLT_ALLMULTI: c_int = 0x0001;
            // Ioctl operation codes
            const T_TYPE: u32 = b'T' as u32;
            pub const TUNSETNOCSUM: Ioctl = _IOW::<c_int>(T_TYPE, 200);
            pub const TUNSETDEBUG: Ioctl = _IOW::<c_int>(T_TYPE, 201);
            pub const TUNSETIFF: Ioctl = _IOW::<c_int>(T_TYPE, 202);
            pub const TUNSETPERSIST: Ioctl = _IOW::<c_int>(T_TYPE, 203);
            pub const TUNSETOWNER: Ioctl = _IOW::<c_int>(T_TYPE, 204);
            pub const TUNSETLINK: Ioctl = _IOW::<c_int>(T_TYPE, 205);
            pub const TUNSETGROUP: Ioctl = _IOW::<c_int>(T_TYPE, 206);
            pub const TUNGETFEATURES: Ioctl = _IOR::<c_int>(T_TYPE, 207);
            pub const TUNSETOFFLOAD: Ioctl = _IOW::<c_int>(T_TYPE, 208);
            pub const TUNSETTXFILTER: Ioctl = _IOW::<c_int>(T_TYPE, 209);
            pub const TUNGETIFF: Ioctl = _IOR::<c_int>(T_TYPE, 210);
            pub const TUNGETSNDBUF: Ioctl = _IOR::<c_int>(T_TYPE, 211);
            pub const TUNSETSNDBUF: Ioctl = _IOW::<c_int>(T_TYPE, 212);
            pub const TUNATTACHFILTER: Ioctl = _IOW::<sock_fprog>(T_TYPE, 213);
            pub const TUNDETACHFILTER: Ioctl = _IOW::<sock_fprog>(T_TYPE, 214);
            pub const TUNGETVNETHDRSZ: Ioctl = _IOR::<c_int>(T_TYPE, 215);
            pub const TUNSETVNETHDRSZ: Ioctl = _IOW::<c_int>(T_TYPE, 216);
            pub const TUNSETQUEUE: Ioctl = _IOW::<c_int>(T_TYPE, 217);
            pub const TUNSETIFINDEX: Ioctl = _IOW::<c_int>(T_TYPE, 218);
            pub const TUNGETFILTER: Ioctl = _IOR::<sock_fprog>(T_TYPE, 219);
            pub const TUNSETVNETLE: Ioctl = _IOW::<c_int>(T_TYPE, 220);
            pub const TUNGETVNETLE: Ioctl = _IOR::<c_int>(T_TYPE, 221);
            pub const TUNSETVNETBE: Ioctl = _IOW::<c_int>(T_TYPE, 222);
            pub const TUNGETVNETBE: Ioctl = _IOR::<c_int>(T_TYPE, 223);
            pub const TUNSETSTEERINGEBPF: Ioctl = _IOR::<c_int>(T_TYPE, 224);
            pub const TUNSETFILTEREBPF: Ioctl = _IOR::<c_int>(T_TYPE, 225);
            pub const TUNSETCARRIER: Ioctl = _IOW::<c_int>(T_TYPE, 226);
            pub const TUNGETDEVNETNS: Ioctl = _IO(T_TYPE, 227);

            // linux/fs.h
            pub const FS_IOC_GETFLAGS: Ioctl = _IOR::<c_long>('f' as u32, 1);
            pub const FS_IOC_SETFLAGS: Ioctl = _IOW::<c_long>('f' as u32, 2);
            pub const FS_IOC_GETVERSION: Ioctl = _IOR::<c_long>('v' as u32, 1);
            pub const FS_IOC_SETVERSION: Ioctl = _IOW::<c_long>('v' as u32, 2);
            pub const FS_IOC32_GETFLAGS: Ioctl = _IOR::<c_int>('f' as u32, 1);
            pub const FS_IOC32_SETFLAGS: Ioctl = _IOW::<c_int>('f' as u32, 2);
            pub const FS_IOC32_GETVERSION: Ioctl = _IOR::<c_int>('v' as u32, 1);
            pub const FS_IOC32_SETVERSION: Ioctl = _IOW::<c_int>('v' as u32, 2);

            pub const FICLONE: Ioctl = _IOW::<c_int>(0x94, 9);
            pub const FICLONERANGE: Ioctl = _IOW::< file_clone_range>(0x94, 13);

            pub const ADFS_SUPER_MAGIC: c_long = 0x0000adf5;
            pub const AFFS_SUPER_MAGIC: c_long = 0x0000adff;
            pub const AFS_SUPER_MAGIC: c_long = 0x5346414f;
            pub const AUTOFS_SUPER_MAGIC: c_long = 0x0187;
            pub const BPF_FS_MAGIC: c_long = 0xcafe4a11;
            pub const BTRFS_SUPER_MAGIC: c_long = 0x9123683e;
            pub const CGROUP2_SUPER_MAGIC: c_long = 0x63677270;
            pub const CGROUP_SUPER_MAGIC: c_long = 0x27e0eb;
            pub const CODA_SUPER_MAGIC: c_long = 0x73757245;
            pub const CRAMFS_MAGIC: c_long = 0x28cd3d45;
            pub const DEBUGFS_MAGIC: c_long = 0x64626720;
            pub const DEVPTS_SUPER_MAGIC: c_long = 0x1cd1;
            pub const ECRYPTFS_SUPER_MAGIC: c_long = 0xf15f;
            pub const EFS_SUPER_MAGIC: c_long = 0x00414a53;
            pub const EXT2_SUPER_MAGIC: c_long = 0x0000ef53;
            pub const EXT3_SUPER_MAGIC: c_long = 0x0000ef53;
            pub const EXT4_SUPER_MAGIC: c_long = 0x0000ef53;
            pub const F2FS_SUPER_MAGIC: c_long = 0xf2f52010;
            pub const FUSE_SUPER_MAGIC: c_long = 0x65735546;
            pub const FUTEXFS_SUPER_MAGIC: c_long = 0xbad1dea;
            pub const HOSTFS_SUPER_MAGIC: c_long = 0x00c0ffee;
            pub const HPFS_SUPER_MAGIC: c_long = 0xf995e849;
            pub const HUGETLBFS_MAGIC: c_long = 0x958458f6;
            pub const ISOFS_SUPER_MAGIC: c_long = 0x00009660;
            pub const JFFS2_SUPER_MAGIC: c_long = 0x000072b6;
            pub const MINIX2_SUPER_MAGIC2: c_long = 0x00002478;
            pub const MINIX2_SUPER_MAGIC: c_long = 0x00002468;
            pub const MINIX3_SUPER_MAGIC: c_long = 0x4d5a;
            pub const MINIX_SUPER_MAGIC2: c_long = 0x0000138f;
            pub const MINIX_SUPER_MAGIC: c_long = 0x0000137f;
            pub const MSDOS_SUPER_MAGIC: c_long = 0x00004d44;
            pub const NCP_SUPER_MAGIC: c_long = 0x0000564c;
            pub const NFS_SUPER_MAGIC: c_long = 0x00006969;
            pub const NILFS_SUPER_MAGIC: c_long = 0x3434;
            pub const OCFS2_SUPER_MAGIC: c_long = 0x7461636f;
            pub const OPENPROM_SUPER_MAGIC: c_long = 0x00009fa1;
            pub const OVERLAYFS_SUPER_MAGIC: c_long = 0x794c7630;
            pub const PROC_SUPER_MAGIC: c_long = 0x00009fa0;
            pub const QNX4_SUPER_MAGIC: c_long = 0x0000002f;
            pub const QNX6_SUPER_MAGIC: c_long = 0x68191122;
            pub const RDTGROUP_SUPER_MAGIC: c_long = 0x7655821;
            pub const REISERFS_SUPER_MAGIC: c_long = 0x52654973;
            pub const SECURITYFS_MAGIC: c_long = 0x73636673;
            pub const SELINUX_MAGIC: c_long = 0xf97cff8c;
            pub const SMACK_MAGIC: c_long = 0x43415d53;
            pub const SMB_SUPER_MAGIC: c_long = 0x0000517b;
            pub const SYSFS_MAGIC: c_long = 0x62656572;
            pub const TMPFS_MAGIC: c_long = 0x01021994;
            pub const TRACEFS_MAGIC: c_long = 0x74726163;
            pub const UDF_SUPER_MAGIC: c_long = 0x15013346;
            pub const USBDEVICE_SUPER_MAGIC: c_long = 0x00009fa2;
            pub const XENFS_SUPER_MAGIC: c_long = 0xabba1974;
            pub const NSFS_MAGIC: c_long = 0x6e736673;            
            const _IOC_NRBITS: u32 = 8;
            const _IOC_TYPEBITS: u32 = 8;

            cfg_if! {
                if #[cfg(any(
                    any(target_arch = "powerpc", target_arch = "powerpc64"),
                    any(target_arch = "sparc", target_arch = "sparc64"),
                    any(target_arch = "mips", target_arch = "mips64"),
                ))] {
                    // https://github.com/torvalds/linux/blob/b311c1b497e51a628aa89e7cb954481e5f9dced2/arch/powerpc/include/uapi/asm/ioctl.h
                    // https://github.com/torvalds/linux/blob/b311c1b497e51a628aa89e7cb954481e5f9dced2/arch/sparc/include/uapi/asm/ioctl.h
                    // https://github.com/torvalds/linux/blob/b311c1b497e51a628aa89e7cb954481e5f9dced2/arch/mips/include/uapi/asm/ioctl.h

                    const _IOC_SIZEBITS: u32 = 13;
                    const _IOC_DIRBITS: u32 = 3;

                    const _IOC_NONE: u32 = 1;
                    const _IOC_READ: u32 = 2;
                    const _IOC_WRITE: u32 = 4;
                } else {
                    // https://github.com/torvalds/linux/blob/b311c1b497e51a628aa89e7cb954481e5f9dced2/include/uapi/asm-generic/ioctl.h

                    const _IOC_SIZEBITS: u32 = 14;
                    const _IOC_DIRBITS: u32 = 2;

                    const _IOC_NONE: u32 = 0;
                    const _IOC_WRITE: u32 = 1;
                    const _IOC_READ: u32 = 2;
                }
            }
            const _IOC_NRMASK: u32 = (1 << _IOC_NRBITS) - 1;
            const _IOC_TYPEMASK: u32 = (1 << _IOC_TYPEBITS) - 1;
            const _IOC_SIZEMASK: u32 = (1 << _IOC_SIZEBITS) - 1;
            const _IOC_DIRMASK: u32 = (1 << _IOC_DIRBITS) - 1;

            const _IOC_NRSHIFT: u32 = 0;
            const _IOC_TYPESHIFT: u32 = _IOC_NRSHIFT + _IOC_NRBITS;
            const _IOC_SIZESHIFT: u32 = _IOC_TYPESHIFT + _IOC_TYPEBITS;
            const _IOC_DIRSHIFT: u32 = _IOC_SIZESHIFT + _IOC_SIZEBITS;

            // adapted from https://github.com/torvalds/linux/blob/8a696a29c6905594e4abf78eaafcb62165ac61f1/rust/kernel/ioctl.rs

            /// Build an ioctl number, analogous to the C macro of the same name.
            const fn _IOC(dir: u32, ty: u32, nr: u32, size: usize) -> Ioctl {
                // FIXME(ctest) the `garando_syntax` crate (used by ctest in the CI test suite)
                // cannot currently parse these `debug_assert!`s
                //
                // debug_assert!(dir <= _IOC_DIRMASK);
                // debug_assert!(ty <= _IOC_TYPEMASK);
                // debug_assert!(nr <= _IOC_NRMASK);
                // debug_assert!(size <= (_IOC_SIZEMASK as usize));

                ((dir << _IOC_DIRSHIFT)
                    | (ty << _IOC_TYPESHIFT)
                    | (nr << _IOC_NRSHIFT)
                    | ((size as u32) << _IOC_SIZESHIFT)) as Ioctl
            }

            /// Build an ioctl number for an argumentless ioctl.
            pub const fn _IO(ty: u32, nr: u32) -> Ioctl {
                _IOC(_IOC_NONE, ty, nr, 0)
            }

            /// Build an ioctl number for an read-only ioctl.
            pub const fn _IOR<T>(ty: u32, nr: u32) -> Ioctl {
                _IOC(_IOC_READ, ty, nr, size_of::<T>())
            }

            /// Build an ioctl number for an write-only ioctl.
            pub const fn _IOW<T>(ty: u32, nr: u32) -> Ioctl {
                _IOC(_IOC_WRITE, ty, nr, size_of::<T>())
            }

            /// Build an ioctl number for a read-write ioctl.
            pub const fn _IOWR<T>(ty: u32, nr: u32) -> Ioctl {
                _IOC(_IOC_READ | _IOC_WRITE, ty, nr, size_of::<T>())
            }

            extern "C" {
                #[cfg_attr(gnu_time_bits64, link_name = "__ioctl_time64")]
                pub fn ioctl(fd: c_int, request: Ioctl, ...) -> c_int;
            }

            const_fn! {
                {const} fn CMSG_ALIGN(len: usize) -> usize {
                    (len + size_of::<usize>() - 1) & !(size_of::<usize>() - 1)
                }
            }

            f! {
                pub fn CMSG_FIRSTHDR(mhdr: *const  msghdr) -> *mut  cmsghdr {
                    if (*mhdr).msg_controllen as usize >= size_of::< cmsghdr>() {
                        (*mhdr).msg_control.cast::< cmsghdr>()
                    } else {
                        core::ptr::null_mut::< cmsghdr>()
                    }
                }

                pub fn CMSG_DATA(cmsg: *const  cmsghdr) -> *mut c_uchar {
                    cmsg.offset(1) as *mut c_uchar
                }

                pub {const} fn CMSG_SPACE(length: c_uint) -> c_uint {
                    (CMSG_ALIGN(length as usize) + CMSG_ALIGN(size_of::< cmsghdr>())) as c_uint
                }

                pub {const} fn CMSG_LEN(length: c_uint) -> c_uint {
                    CMSG_ALIGN(size_of::< cmsghdr>()) as c_uint + length
                }

                pub fn FD_CLR(fd: c_int, set: *mut fd_set) -> () {
                    let fd = fd as usize;
                    let size = size_of_val(&(*set).fds_bits[0]) * 8;
                    (*set).fds_bits[fd / size] &= !(1 << (fd % size));
                    return;
                }

                pub fn FD_ISSET(fd: c_int, set: *const fd_set) -> bool {
                    let fd = fd as usize;
                    let size = size_of_val(&(*set).fds_bits[0]) * 8;
                    return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0;
                }

                pub fn FD_SET(fd: c_int, set: *mut fd_set) -> () {
                    let fd = fd as usize;
                    let size = size_of_val(&(*set).fds_bits[0]) * 8;
                    (*set).fds_bits[fd / size] |= 1 << (fd % size);
                    return;
                }

                pub fn FD_ZERO(set: *mut fd_set) -> () {
                    for slot in &mut (*set).fds_bits {
                        *slot = 0;
                    }
                }
            }

            safe_f! {
                pub fn SIGRTMAX() -> c_int {
                    unsafe { __libc_current_sigrtmax() }
                }

                pub fn SIGRTMIN() -> c_int {
                    unsafe { __libc_current_sigrtmin() }
                }

                pub {const} fn WIFSTOPPED(status: c_int) -> bool {
                    (status & 0xff) == 0x7f
                }

                pub {const} fn WSTOPSIG(status: c_int) -> c_int {
                    (status >> 8) & 0xff
                }

                pub {const} fn WIFCONTINUED(status: c_int) -> bool {
                    status == 0xffff
                }

                pub {const} fn WIFSIGNALED(status: c_int) -> bool {
                    ((status & 0x7f) + 1) as i8 >= 2
                }

                pub {const} fn WTERMSIG(status: c_int) -> c_int {
                    status & 0x7f
                }

                pub {const} fn WIFEXITED(status: c_int) -> bool {
                    (status & 0x7f) == 0
                }

                pub {const} fn WEXITSTATUS(status: c_int) -> c_int {
                    (status >> 8) & 0xff
                }

                pub {const} fn WCOREDUMP(status: c_int) -> bool {
                    (status & 0x80) != 0
                }

                pub {const} fn W_EXITCODE(ret: c_int, sig: c_int) -> c_int {
                    (ret << 8) | sig
                }

                pub {const} fn W_STOPCODE(sig: c_int) -> c_int {
                    (sig << 8) | 0x7f
                }

                pub {const} fn QCMD(cmd: c_int, type_: c_int) -> c_int {
                    (cmd << 8) | (type_ & 0x00ff)
                }

                pub {const} fn IPOPT_COPIED(o: u8) -> u8 {
                    o & IPOPT_COPY
                }

                pub {const} fn IPOPT_CLASS(o: u8) -> u8 {
                    o & IPOPT_CLASS_MASK
                }

                pub {const} fn IPOPT_NUMBER(o: u8) -> u8 {
                    o & IPOPT_NUMBER_MASK
                }

                pub {const} fn IPTOS_ECN(x: u8) -> u8 {
                    x &  IPTOS_ECN_MASK
                }

                #[allow(ellipsis_inclusive_range_patterns)]
                pub {const} fn KERNEL_VERSION(a: u32, b: u32, c: u32) -> u32 {
                    ((a << 16) + (b << 8)) + if c > 255 { 255 } else { c }
                }
            }

            extern "C" {
                #[doc(hidden)]
                pub fn __libc_current_sigrtmax() -> c_int;
                #[doc(hidden)]
                pub fn __libc_current_sigrtmin() -> c_int;

                pub fn sem_destroy(sem: *mut sem_t) -> c_int;
                pub fn sem_init(sem: *mut sem_t, pshared: c_int, value: c_uint) -> c_int;
                pub fn fdatasync(fd: c_int) -> c_int;
                pub fn mincore(addr: *mut c_void, len: size_t, vec: *mut c_uchar) -> c_int;

                #[cfg_attr(gnu_time_bits64, link_name = "__clock_getres64")]
                pub fn clock_getres(clk_id:  clockid_t, tp: *mut  timespec) -> c_int;
                #[cfg_attr(gnu_time_bits64, link_name = "__clock_gettime64")]
                pub fn clock_gettime(clk_id:  clockid_t, tp: *mut  timespec) -> c_int;
                #[cfg_attr(gnu_time_bits64, link_name = "__clock_settime64")]
                pub fn clock_settime(clk_id:  clockid_t, tp: *const  timespec) -> c_int;
                pub fn clock_getcpuclockid(pid:  pid_t, clk_id: *mut  clockid_t) -> c_int;

                pub fn dirfd(dirp: *mut  DIR) -> c_int;

                pub fn pthread_getattr_np(native:  pthread_t, attr: *mut  pthread_attr_t) -> c_int;
                pub fn pthread_attr_getstack(
                    attr: *const  pthread_attr_t,
                    stackaddr: *mut *mut c_void,
                    stacksize: *mut size_t,
                ) -> c_int;
                pub fn pthread_attr_setstack(
                    attr: *mut  pthread_attr_t,
                    stackaddr: *mut c_void,
                    stacksize: size_t,
                ) -> c_int;
                pub fn memalign(align: size_t, size: size_t) -> *mut c_void;
                pub fn setgroups(ngroups: size_t, ptr: *const  gid_t) -> c_int;
                pub fn pipe2(fds: *mut c_int, flags: c_int) -> c_int;
                #[cfg_attr(gnu_file_offset_bits64, link_name = "statfs64")]
                pub fn statfs(path: *const c_char, buf: *mut statfs) -> c_int;
                #[cfg_attr(gnu_file_offset_bits64, link_name = "fstatfs64")]
                pub fn fstatfs(fd: c_int, buf: *mut statfs) -> c_int;
                pub fn memrchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;
                #[cfg_attr(gnu_file_offset_bits64, link_name = "posix_fadvise64")]
                pub fn posix_fadvise(fd: c_int, offset: off_t, len: off_t, advise: c_int) -> c_int;
                #[cfg_attr(gnu_time_bits64, link_name = "__futimens64")]
                pub fn futimens(fd: c_int, times: *const  timespec) -> c_int;
                #[cfg_attr(gnu_time_bits64, link_name = "__utimensat64")]
                pub fn utimensat(
                    dirfd: c_int,
                    path: *const c_char,
                    times: *const  timespec,
                    flag: c_int,
                ) -> c_int;
                pub fn duplocale(base:  locale_t) ->  locale_t;
                pub fn freelocale(loc:  locale_t);
                pub fn newlocale(mask: c_int, locale: *const c_char, base:  locale_t) ->  locale_t;
                pub fn uselocale(loc:  locale_t) ->  locale_t;
                pub fn mknodat(dirfd: c_int, pathname: *const c_char, mode: mode_t, dev: dev_t) -> c_int;
                pub fn pthread_condattr_getclock(
                    attr: *const pthread_condattr_t,
                    clock_id: *mut clockid_t,
                ) -> c_int;
                pub fn pthread_condattr_setclock(
                    attr: *mut pthread_condattr_t,
                    clock_id:  clockid_t,
                ) -> c_int;
                pub fn pthread_condattr_setpshared(attr: *mut pthread_condattr_t, pshared: c_int) -> c_int;
                pub fn pthread_mutexattr_setpshared(attr: *mut pthread_mutexattr_t, pshared: c_int) -> c_int;
                pub fn pthread_rwlockattr_getpshared(
                    attr: *const pthread_rwlockattr_t,
                    val: *mut c_int,
                ) -> c_int;
                pub fn pthread_rwlockattr_setpshared(attr: *mut pthread_rwlockattr_t, val: c_int) -> c_int;
                pub fn ptsname_r(fd: c_int, buf: *mut c_char, buflen: size_t) -> c_int;
                pub fn clearenv() -> c_int;
                pub fn waitid(
                    idtype: idtype_t,
                    id: id_t,
                    infop: *mut  siginfo_t,
                    options: c_int,
                ) -> c_int;
                pub fn getresuid(
                    ruid: *mut  uid_t,
                    euid: *mut  uid_t,
                    suid: *mut  uid_t,
                ) -> c_int;
                pub fn getresgid(
                    rgid: *mut  gid_t,
                    egid: *mut  gid_t,
                    sgid: *mut  gid_t,
                ) -> c_int;
                pub fn acct(filename: *const c_char) -> c_int;
                pub fn brk(addr: *mut c_void) -> c_int;
                pub fn sbrk(increment: intptr_t) -> *mut c_void;
                pub fn setresgid(rgid:  gid_t, egid:  gid_t, sgid:  gid_t) -> c_int;
                pub fn setresuid(ruid:  uid_t, euid:  uid_t, suid:  uid_t) -> c_int;
                #[cfg_attr(gnu_time_bits64, link_name = "__wait4_time64")]
                pub fn wait4(
                    pid:  pid_t,
                    status: *mut c_int,
                    options: c_int,
                    rusage: *mut  rusage,
                ) ->  pid_t;
                pub fn login_tty(fd: c_int) -> c_int;
                pub fn execvpe(
                    file: *const c_char,
                    argv: *const *mut c_char,
                    envp: *const *mut c_char,
                ) -> c_int;
                pub fn fexecve(fd: c_int, argv: *const *mut c_char, envp: *const *mut c_char) -> c_int;
                pub fn getifaddrs(ifap: *mut *mut  ifaddrs) -> c_int;
                pub fn freeifaddrs(ifa: *mut  ifaddrs);
                pub fn bind(
                    socket: c_int,
                    address: *const  sockaddr,
                    address_len:  socklen_t,
                ) -> c_int;

                pub fn writev(fd: c_int, iov: *const  iovec, iovcnt: c_int) -> ssize_t;
                pub fn readv(fd: c_int, iov: *const  iovec, iovcnt: c_int) -> ssize_t;

                #[cfg_attr(gnu_time_bits64, link_name = "__sendmsg64")]
                pub fn sendmsg(fd: c_int, msg: *const  msghdr, flags: c_int) -> ssize_t;
                #[cfg_attr(gnu_time_bits64, link_name = "__recvmsg64")]
                pub fn recvmsg(fd: c_int, msg: *mut  msghdr, flags: c_int) -> ssize_t;
                pub fn uname(buf: *mut  utsname) -> c_int;

                pub fn strchrnul(s: *const c_char, c: c_int) -> *mut c_char;

                pub fn strftime(
                    s: *mut c_char,
                    max: size_t,
                    format: *const c_char,
                    tm: *const  tm,
                ) -> size_t;
                pub fn strftime_l(
                    s: *mut c_char,
                    max: size_t,
                    format: *const c_char,
                    tm: *const  tm,
                    locale:  locale_t,
                ) -> size_t;
                pub fn strptime(s: *const c_char, format: *const c_char, tm: *mut  tm) -> *mut c_char;

                #[cfg_attr(gnu_file_offset_bits64, link_name = "mkostemp64")]
                pub fn mkostemp(template: *mut c_char, flags: c_int) -> c_int;
                #[cfg_attr(gnu_file_offset_bits64, link_name = "mkostemps64")]
                pub fn mkostemps(template: *mut c_char, suffixlen: c_int, flags: c_int) -> c_int;

                pub fn getdomainname(name: *mut c_char, len: size_t) -> c_int;
                pub fn setdomainname(name: *const c_char, len: size_t) -> c_int;
            }

            // LFS64 extensions
            //
            // * musl and Emscripten has 64-bit versions only so aliases the LFS64 symbols to the standard ones
            // * ulibc doesn't have preadv64/pwritev64
            cfg_if! {
                if #[cfg(not(any(target_env = "musl", target_os = "emscripten")))] {
                    extern "C" {
                        pub fn fstatfs64(fd: c_int, buf: *mut statfs64) -> c_int;
                        pub fn statvfs64(path: *const c_char, buf: *mut statvfs64) -> c_int;
                        pub fn fstatvfs64(fd: c_int, buf: *mut statvfs64) -> c_int;
                        pub fn statfs64(path: *const c_char, buf: *mut statfs64) -> c_int;
                        pub fn creat64(path: *const c_char, mode: mode_t) -> c_int;
                        #[cfg_attr(gnu_time_bits64, link_name = "__fstat64_time64")]
                        pub fn fstat64(fildes: c_int, buf: *mut stat64) -> c_int;
                        #[cfg_attr(gnu_time_bits64, link_name = "__fstatat64_time64")]
                        pub fn fstatat64(
                            dirfd: c_int,
                            pathname: *const c_char,
                            buf: *mut stat64,
                            flags: c_int,
                        ) -> c_int;
                        pub fn ftruncate64(fd: c_int, length: off64_t) -> c_int;
                        pub fn lseek64(fd: c_int, offset: off64_t, whence: c_int) -> off64_t;
                        #[cfg_attr(gnu_time_bits64, link_name = "__lstat64_time64")]
                        pub fn lstat64(path: *const c_char, buf: *mut stat64) -> c_int;
                        pub fn mmap64(
                            addr: *mut c_void,
                            len: size_t,
                            prot: c_int,
                            flags: c_int,
                            fd: c_int,
                            offset: off64_t,
                        ) -> *mut c_void;
                        pub fn open64(path: *const c_char, oflag: c_int, ...) -> c_int;
                        pub fn openat64(fd: c_int, path: *const c_char, oflag: c_int, ...) -> c_int;
                        pub fn posix_fadvise64(
                            fd: c_int,
                            offset: off64_t,
                            len: off64_t,
                            advise: c_int,
                        ) -> c_int;
                        pub fn pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: off64_t) -> ssize_t;
                        pub fn pwrite64(
                            fd: c_int,
                            buf: *const c_void,
                            count: size_t,
                            offset: off64_t,
                        ) -> ssize_t;
                        pub fn readdir64(dirp: *mut  DIR) -> *mut  dirent64;
                        pub fn readdir64_r(
                            dirp: *mut  DIR,
                            entry: *mut  dirent64,
                            result: *mut *mut  dirent64,
                        ) -> c_int;
                        #[cfg_attr(gnu_time_bits64, link_name = "__stat64_time64")]
                        pub fn stat64(path: *const c_char, buf: *mut stat64) -> c_int;
                        pub fn truncate64(path: *const c_char, length: off64_t) -> c_int;
                    }
                }
            }

            cfg_if! {
                if #[cfg(not(any(
                    target_env = "uclibc",
                    target_env = "musl",
                    target_os = "emscripten"
                )))] {
                    extern "C" {
                        pub fn preadv64(
                            fd: c_int,
                            iov: *const  iovec,
                            iovcnt: c_int,
                            offset: off64_t,
                        ) -> ssize_t;
                        pub fn pwritev64(
                            fd: c_int,
                            iov: *const  iovec,
                            iovcnt: c_int,
                            offset: off64_t,
                        ) -> ssize_t;
                    }
                }
            }

            cfg_if! {
                if #[cfg(not(target_env = "uclibc"))] {
                    extern "C" {
                        // uclibc has separate non-const version of this function
                        pub fn forkpty(
                            amaster: *mut c_int,
                            name: *mut c_char,
                            termp: *const termios,
                            winp: *const  winsize,
                        ) ->  pid_t;
                        // uclibc has separate non-const version of this function
                        pub fn openpty(
                            amaster: *mut c_int,
                            aslave: *mut c_int,
                            name: *mut c_char,
                            termp: *const termios,
                            winp: *const  winsize,
                        ) -> c_int;
                    }
                }
            }

            // The statx syscall, available on some libcs.
            cfg_if! {
                if #[cfg(any(target_env = "gnu", target_os = "android"))] {
                    extern "C" {
                        pub fn statx(
                            dirfd: c_int,
                            pathname: *const c_char,
                            flags: c_int,
                            mask: c_uint,
                            statxbuf: *mut statx,
                        ) -> c_int;
                    }
                }
            }

            cfg_if! {
                if #[cfg(target_os = "emscripten")] {
                    mod emscripten;
                    pub use self::emscripten::*;
                } else if #[cfg(target_os = "linux")] {
                    mod linux;
                    pub use self::linux::*;
                } else if #[cfg(target_os = "l4re")] {
                    mod linux;
                    pub use self::linux::*;
                } else if #[cfg(target_os = "android")] {
                    mod android;
                    pub use self::android::*;
                } else {
                    // Unknown target_os
                }
            }
        } pub use self::linux_like::{ * };
    }
    } #[cfg( unix )] pub use self::unix::{ * };

    pub mod windows
    {

    } #[cfg( windows )] pub use self::windows::{ * };
}

pub mod marker
{
    pub use std::marker::{ * };
}

pub mod os
{
    pub mod raw
    {
        pub use std::os::raw::{ * };
    }
}

pub mod result
{
    pub use std::result::{ * };
}

pub mod system
{
    use ::
    {
        *,
    };

    pub mod signal
    {
        use ::
        {
            *,
        };
    }

    pub mod prelude
    {
        pub use std::prelude::v1::{ * };
    } pub use self::prelude::{ * };
}

unsafe fn domain() -> ::result::Result<(), Box<dyn std::error::Error>>
{
    Ok(())
}

fn main() -> ::result::Result<(), Box<dyn std::error::Error>>
{
    unsafe
    {
        libc::signal(libc::SIGPIPE, libc::SIG_DFL);
        libc::signal(libc::SIGTSTP, libc::SIG_IGN);
        libc::signal(libc::SIGQUIT, libc::SIG_IGN);
        let _ = domain()?;   
    }
}
// #\[stable\(feature = ".+", since = ".+"\)\]
// #\[unstable\(feature = ".+", issue = ".+"\)\]
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 3521
